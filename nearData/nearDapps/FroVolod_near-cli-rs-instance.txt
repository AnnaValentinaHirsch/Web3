*GitHub Repository "FroVolod/near-cli-rs-instance"*

'''--- .github/workflows/release.yml ---
name: release
on:
  push:
    # Enable when testing release infrastructure on a branch.
    # branches:
    # - ci/release-check
    tags:
    - "[0-9]+.[0-9]+.[0-9]+"
    - "[0-9]+.[0-9]+.[0-9]+-*"
jobs:
  create-release:
    name: create-release
    runs-on: ubuntu-latest
    # env:
      # Set to force version number, e.g., when no tag exists.
      # NEAR_CLI_VERSION: TEST-0.0.0
    outputs:
      upload_url: ${{ steps.release.outputs.upload_url }}
      near_cli_version: ${{ env.NEAR_CLI_VERSION }}
    steps:
      - name: Get the release version from the tag
        shell: bash
        if: env.NEAR_CLI_VERSION == ''
        run: |
          # Apparently, this is the right way to get a tag name. Really?
          #
          # See: https://github.community/t5/GitHub-Actions/How-to-get-just-the-tag-name/m-p/32167/highlight/true#M1027
          echo "NEAR_CLI_VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_ENV
          echo "version is: ${{ env.NEAR_CLI_VERSION }}"
      - name: Create GitHub release
        id: release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ env.NEAR_CLI_VERSION }}
          release_name: ${{ env.NEAR_CLI_VERSION }}

  build-release:
    name: build-release
    needs: ['create-release']
    runs-on: ${{ matrix.os }}
    env:
      # For some builds, we use cross to test on 32-bit and big-endian
      # systems.
      CARGO: cargo
      # When CARGO is set to CROSS, this is set to `--target matrix.target`.
      TARGET_FLAGS: ""
      # When CARGO is set to CROSS, TARGET_DIR includes matrix.target.
      TARGET_DIR: ./target
      # For some builds, we disable ledger support
      FEATURES_FLAGS:
      # Emit backtraces on panics.
      RUST_BACKTRACE: 1
      # Build static releases with PCRE2.
      PCRE2_SYS_STATIC: 1
    strategy:
      fail-fast: false
      matrix:
        include:
        - build: linux-x86_64
          os: ubuntu-18.04
          rust: stable
          target: x86_64-unknown-linux-gnu
        - build: linux-x86_64-musl
          os: ubuntu-18.04
          rust: stable
          target: x86_64-unknown-linux-musl
        - build: linux-aarch64-musl
          os: ubuntu-18.04
          rust: stable
          target: aarch64-unknown-linux-musl
        - build: macos-x86_64
          os: macos-latest
          rust: stable
          target: x86_64-apple-darwin
        - build: win64-msvc
          os: windows-2019
          rust: stable
          target: x86_64-pc-windows-msvc
        - build: win32-msvc
          os: windows-2019
          rust: stable
          target: i686-pc-windows-msvc

    steps:
    - name: Checkout repository
      uses: actions/checkout@v2
      with:
        fetch-depth: 1

    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: ${{ matrix.rust }}
        profile: minimal
        override: true
        target: ${{ matrix.target }}

    - name: Use Cross
      run: |
        cargo install cross
        echo "CARGO=cross" >> $GITHUB_ENV
        echo "TARGET_FLAGS=--target ${{ matrix.target }}" >> $GITHUB_ENV
        echo "TARGET_DIR=./target/${{ matrix.target }}" >> $GITHUB_ENV

    - name: Build cross environment
      shell: bash
      run: |
        if [ -d "./cross/${{ matrix.target }}" ]; then
          docker build --tag "cross:${{ matrix.target }}" "./cross/${{ matrix.target }}"
        fi

    - name: Disable Ledger support for platforms that don't have udev
      if: matrix.target == 'x86_64-unknown-linux-musl' || matrix.target == 'aarch64-unknown-linux-musl'
      run: |
        echo "FEATURES_FLAGS=--no-default-features" >> $GITHUB_ENV

    - name: Show command used for Cargo
      run: |
        echo "cargo command is: ${{ env.CARGO }}"
        echo "target flag is: ${{ env.TARGET_FLAGS }}"
        echo "target dir is: ${{ env.TARGET_DIR }}"

    - name: Build release binary
      run: ${{ env.CARGO }} build --verbose --release ${{ env.TARGET_FLAGS }} ${{ env.FEATURES_FLAGS }}

    - name: Strip release binary (linux and macos)
      if: matrix.build == 'linux-x86_64' || matrix.build == 'macos-x86_64'
      run: strip "${{ env.TARGET_DIR }}/release/near-cli"

    - name: Strip release binary (linux-aarch64)
      if: matrix.build == 'linux-aarch64-musl'
      run: |
        docker run --rm -v \
          "$PWD/target:/target:Z" \
          rustembedded/cross:aarch64-unknown-linux-musl \
          aarch64-linux-musl-strip \
          /target/aarch64-unknown-linux-musl/release/near-cli

    - name: Build archive
      shell: bash
      run: |
        staging="near-cli-${{ needs.create-release.outputs.near_cli_version }}-${{ matrix.target }}"
        mkdir -p "$staging"/"docs"

        cp README.md "$staging/"
        cp -a "docs"/* "$staging/docs/"

        if [ "${{ matrix.os }}" = "windows-2019" ]; then
          cp "${{ env.TARGET_DIR }}/release/near-cli.exe" "$staging/"
          7z a "$staging.zip" "$staging"
          echo "ASSET=$staging.zip" >> $GITHUB_ENV
        else
          cp "${{ env.TARGET_DIR }}/release/near-cli" "$staging/"
          tar czf "$staging.tar.gz" "$staging"
          echo "ASSET=$staging.tar.gz" >> $GITHUB_ENV
        fi

    - name: Upload release archive
      uses: actions/upload-release-asset@v1.0.1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ needs.create-release.outputs.upload_url }}
        asset_path: ${{ env.ASSET }}
        asset_name: ${{ env.ASSET }}
        asset_content_type: application/octet-stream

'''
'''--- .github/workflows/test.yml ---
name: ci
on:
  pull_request:
    branches: [master]
  push:
    branches: [master]
  # schedule:
  # - cron: '00 01 * * *'
jobs:
  test:
    name: test
    env:
      # For some builds, we use cross to test on 32-bit and big-endian
      # systems.
      CARGO: cargo
      # When CARGO is set to CROSS, this is set to `--target matrix.target`.
      TARGET_FLAGS: ""
      # When CARGO is set to CROSS, TARGET_DIR includes matrix.target.
      TARGET_DIR: ./target
      # For some builds, we disable ledger support
      FEATURES_FLAGS:
      # Emit backtraces on panics.
      RUST_BACKTRACE: 1
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
        - build: linux-x86_64
          os: ubuntu-18.04
          rust: stable
          target: x86_64-unknown-linux-gnu
        - build: linux-x86_64-musl
          os: ubuntu-18.04
          rust: stable
          target: x86_64-unknown-linux-musl
        - build: linux-aarch64-musl
          os: ubuntu-18.04
          rust: stable
          target: aarch64-unknown-linux-musl
        - build: macos-x86_64
          os: macos-latest
          rust: stable
          target: x86_64-apple-darwin
        - build: win64-msvc
          os: windows-2019
          rust: stable
          target: x86_64-pc-windows-msvc
        - build: win32-msvc
          os: windows-2019
          rust: stable
          target: i686-pc-windows-msvc

    steps:
    - name: Checkout repository
      uses: actions/checkout@v2

    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: ${{ matrix.rust }}
        profile: minimal
        override: true

    - name: Use Cross
      run: |
        cargo install cross
        echo "CARGO=cross" >> $GITHUB_ENV
        echo "TARGET_FLAGS=--target ${{ matrix.target }}" >> $GITHUB_ENV
        echo "TARGET_DIR=./target/${{ matrix.target }}" >> $GITHUB_ENV

    - name: Build cross environment
      shell: bash
      run: |
        if [ -d "./cross/${{ matrix.target }}" ]; then
          docker build --tag "cross:${{ matrix.target }}" "./cross/${{ matrix.target }}"
        fi
 
    - name: Disable Ledger support for platforms that don't have udev
      if: matrix.target == 'x86_64-unknown-linux-musl' || matrix.target == 'aarch64-unknown-linux-musl'
      run: |
        echo "FEATURES_FLAGS=--no-default-features" >> $GITHUB_ENV

    - name: Show command used for Cargo
      run: |
        echo "cargo command is: ${{ env.CARGO }}"
        echo "target flag is: ${{ env.TARGET_FLAGS }}"
    
    - name: Build near-cli and all crates
      run: ${{ env.CARGO }} build --verbose --all ${{ env.TARGET_FLAGS }} ${{ env.FEATURES_FLAGS }}

    - name: Run tests
      run: ${{ env.CARGO }} test --verbose --all ${{ env.TARGET_FLAGS }} ${{ env.FEATURES_FLAGS }}
    
    - name: View account summary for 'fro_volod.testnet'
      if: matrix.build != 'linux-aarch64-musl'
      run: |
        ${{ env.TARGET_DIR }}/debug/near-cli account view-account-summary fro_volod.testnet network testnet now
    
    - name: Transfer NEAR Tokens
      if: matrix.build != 'linux-aarch64-musl'
      run: |
        ${{ env.TARGET_DIR }}/debug/near-cli tokens volodymyr.testnet send-near fro_volod.testnet '0.1 NEAR' network testnet sign-with-plaintext-private-key --signer-public-key ed25519:Ebx7NiwqupsshnUsEZCzgm84SQqi8LZWJx7ermrr14JF --signer-private-key ed25519:2qM8v3nF4opam1frweMmD5h4PM3H6jtxfuAE77rpEuUx2rSGj64AzDf9xPKG76bgAs5L1oecV93etPy6xKjds2YB display

  rustfmt:
    name: rustfmt
    runs-on: ubuntu-18.04
    steps:
    - name: Checkout repository
      uses: actions/checkout@v2
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        override: true
        profile: minimal
        components: rustfmt
    - name: Check formatting
      run: |
        cargo fmt --all -- --check

'''
'''--- Cargo.toml ---
[package]
name = "near-cli"
version = "0.2.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
clap = { version = "3.1.17", features = ["derive"] }

dialoguer = "0.9"
strum = { git = "https://github.com/frol/strum", branch = "feat/discriminants-pass-through-attributes", features = ["derive"] }
strum_macros = "0.20"
smart-default = "0.6.0"
derive_more = "0.99.9"

async-recursion = "0.3.2"

tokio = { version = "1.0", features = [ "rt", "time" ] }
# Ad-hoc fix for compilation errors (rustls is used instead of openssl to ease the deployment avoiding the system dependency on openssl)
openssl = { version = "0.10", features = [ "vendored" ] }

base64 = "0.12.3"
bip39 = { version = "1.0.0", features = [ "rand" ] }
bs58 = "0.3"
ed25519-dalek = { version = "1" }
hex = "0.4.2"
linked-hash-map = { version = "0.5", features = ["serde_impl"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0.57"
toml = "0.5.9"
dirs = "3.0"
shellexpand = "2.1.0"
slip10 = "0.4.3"
url = { version = "2", features = ["serde"] }
open = "2"
shell-words = "1.0.0"
cargo-util = "0.1.1"

color-eyre = "0.6"

near-ledger = { version = "0.1.1", optional = true }

near-crypto = "0.14"
near-primitives = "0.14"
near-jsonrpc-client = "0.4.0-beta.0"
near-jsonrpc-primitives = "0.14"

interactive_clap = { git = "https://github.com/FroVolod/interactive-clap", rev="56ffcc743bb4f823d47980f77a9c5de40301fc3f" }
interactive_clap_derive = { git = "https://github.com/FroVolod/interactive-clap", rev="56ffcc743bb4f823d47980f77a9c5de40301fc3f" }

[features]
default = ["ledger"]
ledger = ["near-ledger"]

'''
'''--- Cross.toml ---
[target.x86_64-unknown-linux-gnu]
# Run the following command to get the build environment:
# ```
# docker build --tag cross:x86_64-unknown-linux-gnu ./cross/x86_64-unknown-linux-gnu/
# ```
image = "cross:x86_64-unknown-linux-gnu"

'''
'''--- README.md ---
near-cli
--------

near-cli is a command line utility for working with the Near Protocol blockchain. 

<p>
  <img src="docs/media/view-account.svg" alt="" width="1200">
</p>

#### [README in English](docs/README.en.md)  
  * [Usage](docs/README.en.md#usage)
  * [User Guide](docs/README.en.md#user-guide)
  * [Installation](docs/README.en.md#installation)
  * [Building](docs/README.en.md#building)

#### [README на Русском (in Russian)](docs/README.ru.md)
  * [Применение](docs/README.ru.md#применение)
  * [Инструкция](docs/README.ru.md#инструкция)
  * [Установка](docs/README.ru.md#установка)
  * [Сборка](docs/README.ru.md#сборка)

'''
'''--- docs/GUIDE.en.md ---
## User Guide

This guide is intended to give a detailed description of _near-cli_ and an
overview of its capabilities. This guide assumes that _near-cli_ is
[installed](README.md#installation)
and that readers have passing familiarity with using command line tools. This
also assumes a Unix-like system, although most commands are probably easily
translatable to any command line shell environment.

Before proceeding to the description of specific commands, it is necessary to consider two points common to these commands:

1. _Online_ / _Offline_ mode

    The result of the creation of any transaction in the _Offline_ mode (display)  is a prepared transaction in the form of a Base64-encoded string, which can then be [sent to the network via RPC](https://docs.near.org/docs/api/rpc#transactions). In _Online_ mode, such a function has already been added (send).
    Also, the _Online_ mode provides automatic collection of data necessary to form and send a transaction, and in the _Offline_ mode, you will need to enter some parameters manually:

      * _transaction nonce_

        This number will need to be obtained using [View a nonce](#view-a-nonce), increasing by 1

      * _recent block hash_

        Information for this parameter should be found [here](https://explorer.testnet.near.org/blocks) or will need to be obtained using [View recent block hash](#view-recent-block-hash).

        <details><summary><i>recent block hash</i></summary>
            <img src="media/blocks.png" width="836"/>
            <img src="media/block_hash.png" width="836"/>
        </details>

        <details><summary><i>Demonstration of the _Offline_ mode</i></summary>
        <a href="https://asciinema.org/a/REcIXg1yQqLpz42EzNQt8B99f?autoplay=1&t=1&speed=2">
            <img src="https://asciinema.org/a/REcIXg1yQqLpz42EzNQt8B99f.png" width="836"/>
        </a>
        </details>

2. Sign transaction

    _near-cli_ offers several ways to sign the created transaction. Let's take a closer look at each.

      * _I want to sign the transaction with my private key_

        When choosing this signature option, _near-cli_ will ask the user to enter access keys:
          "public_key":"ed25519:Ebx7...",
          "private_key":"ed25519:2qM8..."

      * _I want to sign the transaction with keychain_
        
        Depending on the selected network mode, _Online_ / _Offline_ near-cli will independently find access keys and sign the created transaction.  
        For _Offline_ mode, the access keys must be in the *username.json* file located in */Users/user/.near-credentials/default/*.  
        For example, */Users/frovolod/.near-credentials/default/volodymyr.testnet.json*.  
        For _Online_ mode, the access keys must be in the *public_key.json* file located in */Users/user/.near-credentials/network_name/user_name/*.  
        For example, */Users/frovolod/.near-credentials/testnet/volodymyr.testnet/ed25519_8h7kFK4quSUJRkUwo3LLiK83sraEm2jnQTECuZhWu8HC.json*

      * _I want to sign the transaction with Ledger device_
        
        This option involves signing the created transaction using a ledger.

        <details><summary><i>Demonstration of the command in interactive mode</i></summary>
        <a href="https://asciinema.org/a/7WyNHxSCKY1v6uOa5INPvXW9x?autoplay=1&t=1&speed=2">
            <img src="https://asciinema.org/a/7WyNHxSCKY1v6uOa5INPvXW9x.png" width="836"/>
        </a>
        </details>

      * _I want to construct the transaction and sign it somewhere else_
        
        This option assumes that a third-party software product will sign the created transaction.

### Actions

* [View account, contract code, contract state, transaction, nonce, recent block hash](#view-account-contract-code-contract-state-transaction-nonce-recent-block-hash)
* [Transfer tokens](#transfer-tokens)
* [Execute function (contract method)](#execute-function-contract-method)
* [Add access key, contract code, stake proposal, sub-account, implicit-account](#add-access-key-contract-code-stake-proposal-sub-account-implicit-account)
* [Delete access key, account](#delete-access-key-account)
* [Construct a new transaction](#construct-a-new-transaction)
* [Helpers](#helpers)

### View account, contract code, contract state, transaction, nonce, recent block hash

It is possible to [View properties for an account](#view-properties-for-an-account), to [View a contract code](#view-a-contract-code) and to [View a contract state](#view-a-contract-state) in real time (__at-final-block__) and in the mode of archived data (__at-block-height__, __at-block-hash__). The examples below show how these modes can be used.

#### View properties for an account

##### at-final-block

To view account information, in the terminal command line type:
```txt
./near-cli view account-summary \
        network testnet \
        account 'volodymyr.testnet' \
        at-final-block
```

<details><summary><i>The result of this command will be as follows:</i></summary>

```txt
Account details for 'volodymyr.testnet' at block #49787790 (33RYuu9YoLDVCidWig8uKtuSb7jr3NmcJDzVeeKmSkiW)
Native account balance: 256.718 NEAR
Validator stake: 0 NEAR
Storage used by the account: 115385 bytes
Contract code SHA-256 checksum (hex): 4de7df8ee6ff3780cfed298ceafde26e7477041ca8e2af7ae8c749de7068c0f2
Number of access keys: 7
   1. ed25519:2KZwhWEM5hbtP28kpx9TER3zyz9rL3Az1fcHsgr2Fzd1 (nonce: 9) is granted to full access
   2. ed25519:36u45LFDfgKQYr8ApgBi1kUHN5FpkTQRqvt66cwEdqiK (nonce: 0) is granted to full access
   3. ed25519:7FmDRADa1v4BcLiiR9MPPdmWQp3Um1iPdAYATvBY1YzS (nonce: 168) is granted to full access
   4. ed25519:8b6ghV9BLNNB7RwaxSxjbH636bfM9m6NL7bmLBSXPqK8 (nonce: 2) is granted to full access
   5. ed25519:937VyVwszEH13quNuPM4nNQTrDssNzRNnLMjPbN92tgu (nonce: 3) is granted to full access
   6. ed25519:ApWodksvd7grTjFFimCroLxvrVDi7WD6g6gDE7RuhoGH (nonce: 1) is granted to full access
   7. ed25519:JC5R9H6wjthHeumnUePRjvJNJrRm6ZTFUoi1NYuj9DBZ (nonce: 0) is granted to full access
```
</details>

<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/8sdSrqPbi1TVaoZgQ5luKJgod?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/8sdSrqPbi1TVaoZgQ5luKJgod.png" width="836"/>
</a>
</details>

##### at-block-height

To view account information, in the terminal command line type:
```txt
./near-cli view account-summary \
        network testnet \
        account 'volodymyr.testnet' \
        at-block-height 42775277
```

<details><summary><i>The result of this command will be as follows:</i></summary>

```txt
Account details for 'volodymyr.testnet' at block #42775277 (FrMNHB5y2fZZVfgC6VgfykSRWoTViT2KeWGhgkXKgtTe)
Native account balance: 377.874 NEAR
Validator stake: 0 NEAR
Storage used by the account: 592 bytes
Contract code is not deployed to this account.
Number of access keys: 6
   1. ed25519:36u45LFDfgKQYr8ApgBi1kUHN5FpkTQRqvt66cwEdqiK (nonce: 0) is granted to full access
   2. ed25519:7FmDRADa1v4BcLiiR9MPPdmWQp3Um1iPdAYATvBY1YzS (nonce: 111) is granted to full access
   3. ed25519:8b6ghV9BLNNB7RwaxSxjbH636bfM9m6NL7bmLBSXPqK8 (nonce: 1) is granted to full access
   4. ed25519:937VyVwszEH13quNuPM4nNQTrDssNzRNnLMjPbN92tgu (nonce: 3) is granted to full access
   5. ed25519:ApWodksvd7grTjFFimCroLxvrVDi7WD6g6gDE7RuhoGH (nonce: 1) is granted to full access
   6. ed25519:JC5R9H6wjthHeumnUePRjvJNJrRm6ZTFUoi1NYuj9DBZ (nonce: 0) is granted to full access
```
</details>

<details><summary><i>Demonstration of the command in interactive mode</i></summary>
</details>

##### at-block-hash

To view account information, in the terminal command line type:
```txt
./near-cli view account-summary \
        network testnet \
        account 'volodymyr.testnet' \
        at-block-hash BWUZMBHPnsQR1u69keUZcYKpsjREqtGFNNGkXq74c8JN
```

<details><summary><i>The result of this command will be as follows:</i></summary>

```txt
Account details for 'volodymyr.testnet' at block #42466273 (BWUZMBHPnsQR1u69keUZcYKpsjREqtGFNNGkXq74c8JN)
Native account balance: 377.874 NEAR
Validator stake: 0 NEAR
Storage used by the account: 592 bytes
Contract code is not deployed to this account.
Number of access keys: 6
   1. ed25519:36u45LFDfgKQYr8ApgBi1kUHN5FpkTQRqvt66cwEdqiK (nonce: 0) is granted to full access
   2. ed25519:7FmDRADa1v4BcLiiR9MPPdmWQp3Um1iPdAYATvBY1YzS (nonce: 111) is granted to full access
   3. ed25519:8b6ghV9BLNNB7RwaxSxjbH636bfM9m6NL7bmLBSXPqK8 (nonce: 1) is granted to full access
   4. ed25519:937VyVwszEH13quNuPM4nNQTrDssNzRNnLMjPbN92tgu (nonce: 3) is granted to full access
   5. ed25519:ApWodksvd7grTjFFimCroLxvrVDi7WD6g6gDE7RuhoGH (nonce: 1) is granted to full access
   6. ed25519:JC5R9H6wjthHeumnUePRjvJNJrRm6ZTFUoi1NYuj9DBZ (nonce: 0) is granted to full access
```
</details>

<details><summary><i>Demonstration of the command in interactive mode</i></summary>
</details>

#### View a contract code

Real-time (__at-final-block__) and archived data (__at-block-height__, __at-block-hash__) modes should be used in the same way as [View properties for an account](#view-properties-for-an-account).  

  * In order to get the contract file, type the following in the terminal command line:

    ```txt
    ./near-cli view contract-code \
            network testnet \
            contract 'volodymyr.testnet' \
            download './contract-volodymyr.testnet.wasm' \
            at-final-block
    ```

    <details><summary><i>The result of this command will be as follows:</i></summary>
    
    ```txt
    The file "contract-volodymyr.testnet.wasm" was downloaded successfully
    ```
    </details>

    <details><summary><i>Demonstration of the command in interactive mode</i></summary>
    <a href="https://asciinema.org/a/4sJOszIaaH3zfGzpWAlR9Gxpk?autoplay=1&t=1&speed=2">
        <img src="https://asciinema.org/a/4sJOszIaaH3zfGzpWAlR9Gxpk.png" width="836"/>
    </a>
    </details>

  * In order to get the contract hash, type the following in the terminal command line:

    ```txt
    ./near-cli view contract-code \
            network testnet \
            contract 'volodymyr.testnet' \
            hash \
            at-final-block
    ```
    
    <details><summary><i>The result of this command will be as follows:</i></summary>

    ```txt
    Hash of the contract: 6F7TqH3ggf4iKbmJpFg9uJq87HTUohP1rdrDU7tZx9iH
    ```
    </details>

    <details><summary><i>Demonstration of the command in interactive mode</i></summary>
    <a href="https://asciinema.org/a/JQPVxVliUflaVqUeyfOShXqqQ?autoplay=1&t=1&speed=2">
        <img src="https://asciinema.org/a/JQPVxVliUflaVqUeyfOShXqqQ.png" width="836"/>
    </a>
    </details>

#### View a contract state

Real-time (__at-final-block__) and archived data (__at-block-height__, __at-block-hash__) modes should be used in the same way as [View properties for an account](#view-properties-for-an-account).  

To view the status of the contract, type the following in the terminal command line:
```txt
./near-cli view contract-state \
        network testnet \
        account 'volodymyr.testnet' \
        at-final-block
```

<details><summary><i>The result of this command will be as follows:</i></summary>

```txt
Contract state (values):
[
    StateItem {
        key: "U1RBVEU=",
        value: "BA==",
        proof: [],
    },
]

Contract state (proof):
[]
```
</details>

<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/P1jqzFGpF9qjm5XbKA1yr8RqZ?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/P1jqzFGpF9qjm5XbKA1yr8RqZ.png" width="836"/>
</a>
</details>

#### View a transaction status

To view the status of the desired transaction, type its hash in the terminal command line:
```txt
./near-cli view transaction \
        network testnet \
        transaction-hash 'GDoinMecpvnqahzJz9tXLxYycznL4cAoxKTPEnJZ3ank' \
        signer 'volodymyr.testnet'
```

<details><summary><i>The result of this command will be as follows:</i></summary>

```txt
Specify the account that signed the transaction: volodymyr.testnet
Transactiion status: FinalExecutionOutcome {
    status: SuccessValue(``),
    transaction: SignedTransactionView {
        signer_id: "volodymyr.testnet",
        public_key: ed25519:7FmDRADa1v4BcLiiR9MPPdmWQp3Um1iPdAYATvBY1YzS,
        nonce: 165,
        receiver_id: "qweqweqwe.volodymyr.testnet",
        actions: [
            CreateAccount,
            Transfer {
                deposit: 100000000000000000000000000,
            },
            AddKey {
                public_key: ed25519:AgVv8qjZ7yix3pTo7BimT1zoDYUSTGcg73RBssC5JMRf,
                access_key: AccessKeyView {
                    nonce: 0,
                    permission: FullAccess,
                },
            },
        ],
        signature: ed25519:266jBRjvnaxe4mDyHRGwv3TJesvgRo2umJBqkZU26fRwmhVHciu3tBSLqRZFjEuqLTiwDTrFvfxpJ8Sbd2PqHHhv,
        hash: `GDoinMecpvnqahzJz9tXLxYycznL4cAoxKTPEnJZ3ank`,
    },
    transaction_outcome: ExecutionOutcomeWithIdView {
        proof: [],
        block_hash: `AQH6jDqqxpBYj5NSZv3Skg5hUZQRsn16jvDuphCTugSQ`,
        id: `GDoinMecpvnqahzJz9tXLxYycznL4cAoxKTPEnJZ3ank`,
        outcome: ExecutionOutcomeView {
            logs: [],
            receipt_ids: [
                `5DmuFwQaiSbEDiR7dx6sDurjyDyF92c1tK7gfN7bXqPh`,
            ],
            gas_burnt: 424555062500,
            tokens_burnt: 42455506250000000000,
            executor_id: "volodymyr.testnet",
            status: SuccessReceiptId(5DmuFwQaiSbEDiR7dx6sDurjyDyF92c1tK7gfN7bXqPh),
        },
    },
    receipts_outcome: [
        ExecutionOutcomeWithIdView {
            proof: [],
            block_hash: `DBUpiLVVDBQwSAPU8ZTE8KQnX5skDD1dTsBjJQ8kV24R`,
            id: `5DmuFwQaiSbEDiR7dx6sDurjyDyF92c1tK7gfN7bXqPh`,
            outcome: ExecutionOutcomeView {
                logs: [],
                receipt_ids: [
                    `851GMnZZ5FJ2aDSHM34N99yVb1ZkwY8n7F8rUcvuRpUU`,
                ],
                gas_burnt: 424555062500,
                tokens_burnt: 42455506250000000000,
                executor_id: "qweqweqwe.volodymyr.testnet",
                status: SuccessValue(``),
            },
        },
        ExecutionOutcomeWithIdView {
            proof: [],
            block_hash: `BSjrH3WyKnXhD17drR94YfM725Ho59us9N4msXrrgHEw`,
            id: `851GMnZZ5FJ2aDSHM34N99yVb1ZkwY8n7F8rUcvuRpUU`,
            outcome: ExecutionOutcomeView {
                logs: [],
                receipt_ids: [],
                gas_burnt: 0,
                tokens_burnt: 0,
                executor_id: "volodymyr.testnet",
                status: SuccessValue(``),
            },
        },
    ],
}
```
</details>

<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/HYNfgJ5Gze7fFKntubz7TW6r6?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/HYNfgJ5Gze7fFKntubz7TW6r6.png" width="836"/>
</a>
</details>

#### View a nonce

To view the _nonce_ of the desired public access key, type the following in the terminal command line:
```txt
./near-cli view nonce \
        network testnet \
        account 'volodymyr.testnet' \
        public-key 'ed25519:7FmDRADa1v4BcLiiR9MPPdmWQp3Um1iPdAYATvBY1YzS'
```

<details><summary><i>The result of this command will be as follows:</i></summary>

```txt
current nonce: 168  for a public key: ed25519:7FmDRADa1v4BcLiiR9MPPdmWQp3Um1iPdAYATvBY1YzS
```
</details>

<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/g2WZpFu6njjxoklP4J7Ibc5Q6?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/g2WZpFu6njjxoklP4J7Ibc5Q6.png" width="836"/>
</a>
</details>

#### View recent block hash

To view the _recent block hash_ for network, type the following in the terminal command line:
```txt
./near-cli view recent-block-hash \
        network testnet
```

<details><summary><i>The result of this command will be as follows:</i></summary>

```txt
recent block hash: `CDgRvkv2qv2c8e5m2WDKFUFqAtXrq2fiUteM6XHpy58t`
```
</details>

<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/vF2X1zKIMg2rdByGCKHDIYDKa?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/vF2X1zKIMg2rdByGCKHDIYDKa.png" width="836"/>
</a>
</details>

### Transfer tokens

This command is used to transfer tokens between accounts. Please note that the amount of tokens forwarded is indicated together with the dimensional unit (this is NEAR or yoctoNEAR).
In order to execute this command, in the terminal command line type:
```txt
./near-cli transfer near \
        network testnet \
        sender 'volodymyr.testnet' \
        receiver '21.volodymyr.testnet' \
        amount  '1 NEAR' \
        sign-with-keychain \
        send
```

<details><summary><i>The result of this command will be as follows:</i></summary>

```txt
Transaction sent ...
Successful transaction
<volodymyr.testnet> has transferred 1.000 NEAR to <21.volodymyr.testnet> successfully.
Transaction ID: EiRJ7JCCX7qi9wc9KETnco2n81afU1xbsjyJCuH5SWcX.
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/EiRJ7JCCX7qi9wc9KETnco2n81afU1xbsjyJCuH5SWcX
```
</details>

<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/NjCuGbC6IDyz5VsrXZrgrSF17?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/NjCuGbC6IDyz5VsrXZrgrSF17.png" width="836"/>
</a>
</details>

### Execute function (contract method)

#### Change a method

In order to execute this command, in the terminal command line type:
```txt
./near-cli execute change-method \
        network testnet \
        contract 'meta.pool.testnet' \
        call 'distribute_staking' '{}' \
            --attached-deposit '0 NEAR' \
            --prepaid-gas '3 Tgas' \
        signer 'volodymyr.testnet' \
        sign-with-keychain \
        send
```

<details><summary><i>The result of this command will be as follows:</i></summary>

```txt
Transaction sent ...
Successful transaction
The "distribute_staking" call to <meta.pool.testnet> on behalf of <volodymyr.testnet> succeeded.
Transaction ID: 7TpFFVBs9CXYoRpRtZqMuLAWnGbgx3qyRy9jhawv8HqX.
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/7TpFFVBs9CXYoRpRtZqMuLAWnGbgx3qyRy9jhawv8HqX
```
</details>

<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/wyk4o4FltmUD00tmToCSoH24l?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/wyk4o4FltmUD00tmToCSoH24l.png" width="836"/>
</a>
</details>

#### View a method

Real-time (__at-final-block__) and archived data (__at-block-height__, __at-block-hash__) modes should be used in the same way as [View properties for an account](#view-properties-for-an-account).  

In order to execute this command, in the terminal command line type:
```txt
./near-cli execute view-method \
        network mainnet \
        contract zavodil.poolv1.near \
        call 'get_accounts' '{"from_index": 0, "limit": 3}' \
        at-final-block
```

<details><summary><i>The result of this command will be as follows:</i></summary>

```txt
[
  {
    "account_id": "zavodil.near",
    "unstaked_balance": "8",
    "staked_balance": "11662078846731298726428263471",
    "can_withdraw": true
  },
  {
    "account_id": "gagdiez.near",
    "unstaked_balance": "4",
    "staked_balance": "2195619736137302553610087167",
    "can_withdraw": true
  },
  {
    "account_id": "5ff98e7c85755e0f77c78eaf4a8aeca24846d8b5.lockup.near",
    "unstaked_balance": "1300000000000000000000000001",
    "staked_balance": "10759346016497580677112779659",
    "can_withdraw": false
  }
]
```
</details>

<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/0v0TBnInhHeXv3N85dRmyXEZM?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/0v0TBnInhHeXv3N85dRmyXEZM.png" width="836"/>
</a>
</details>

### Add access key, contract code, stake proposal, sub-account, implicit-account

#### Add a new access key for an account

Let's execute the command to add a new pair of access keys to the account with the following conditions:
  * the public key will be entered manually
  * keys will have full access
  * the transaction will be signed automatically (if there is a file with access keys)

In order to execute this command, in the terminal command line type:
```txt
./near-cli add access-key \
        network testnet \
        account 'volodymyr.testnet' \
        public-key 'ed25519:61WaaKFEXTvhk35xmyScVE9yHc5DareBvomLYbCYteb' \
        grant-full-access \
        sign-with-keychain \
        send
```

<details><summary><i>The result of this command will be as follows:</i></summary>

```txt
Transaction sent ...
Successful transaction
Added access key = ed25519:61WaaKFEXTvhk35xmyScVE9yHc5DareBvomLYbCYteb to volodymyr.testnet.
Transaction ID: 59LEJEQT7jVMXdVi3ab4y8nbQ7uFJ8wRny9tD3qkv5Ez.
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/59LEJEQT7jVMXdVi3ab4y8nbQ7uFJ8wRny9tD3qkv5Ez
```
</details>

<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/bXhJzaCUNf3FHih268NJZ8Fit?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/bXhJzaCUNf3FHih268NJZ8Fit.png" width="836"/>
</a>
</details>

Let's change our parameters to add access keys:
  * keys will be generated automatically
  * keys will have functional access
  * the transaction will be signed with key pair

In order to execute this command, in the terminal command line type:
```txt
./near-cli add access-key \
        network testnet \
        account '21.volodymyr.testnet' \
        generate-keypair \
        grant-function-call-access \ 
            --receiver-id 'meta.pool.testnet' \
            --allowance '10 NEAR' \
            --method-names 'set_a, set_b' \
        sign-private-key \
            --signer-public-key ed25519:Ebx7NiwqupsshnUsEZCzgm84SQqi8LZWJx7ermrr14JF \
            --signer-private-key  ed25519:2qM8v3nF4opam1frweMmD5h4PM3H6jtxfuAE77rpEuUx2rSGj64AzDf9xPKG76bgAs5L1oecV93etPy6xKjds2YB \
        send

```

<details><summary><i>The result of this command will be as follows:</i></summary>

```txt
Transaction sent ...
Successful transaction
Added access key = ed25519:H8pzJt6RHCtVL7THc2AW5KwTXUtVhDCRocHqapfH5L47 to 21.volodymyr.testnet.
Transaction ID: 92y4UzovU4vgfKRVBmLR15M6mYPGp1y2za6HKXXsjF1H.
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/92y4UzovU4vgfKRVBmLR15M6mYPGp1y2za6HKXXsjF1H
```
</details>

<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/DOOZ2yQfUUzuRUY1S3LaktHRm?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/DOOZ2yQfUUzuRUY1S3LaktHRm.png" width="836"/>
</a>
</details>

#### Add a new contract code

In order to add a new contract, in the terminal command line type:
```txt
./near-cli add contract-code \
        network testnet \
        account '21.volodymyr.testnet' \
        contract-file '/Users/frovolod/Documents/NEAR/rust-counter/contract/target/wasm32-unknown-unknown/release/rust_counter_tutorial.wasm' \
        initialize 'increment' '{}'     \
            --attached-deposit '0 NEAR' \
            --prepaid-gas '1 TGas' \
        sign-with-keychain \
        send
```

<details><summary><i>The result of this command will be as follows:</i></summary>

```txt
Transaction sent ...
Successful transaction
Contract code has been successfully deployed.
The "increment" call to <volodymyr.testnet> on behalf of <volodymyr.testnet> succeeded.
Transaction ID: AhJ2fRAu6ocn3RDaKaCtofzfhr5C1z4wXEZDbrhewm4.
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/AhJ2fRAu6ocn3RDaKaCtofzfhr5C1z4wXEZDbrhewm4
```
</details>

<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/wO3YVUR8GOh5KoYjpSWxGwlQB?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/wO3YVUR8GOh5KoYjpSWxGwlQB.png" width="836"/>
</a>
</details>

#### Add an implicit-account

This command automatically generates access keys and saves them to a file.
In order to execute this command, in the terminal command line type:
```txt
./near-cli add implicit-account \
        generate-keypair
```

<details><summary><i>The result of this command will be as follows:</i></summary>

```txt
The data for the access key is saved in a file /Users/frovolod/.near-credentials/default/cbb8d84ac58503f2a53e07830008531a8480b8dd42db045316cd89c87d2b4862.json
```
</details>

<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/Ub5Q13ZEKfzG4I0yKd0zinFjr?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/Ub5Q13ZEKfzG4I0yKd0zinFjr.png" width="836"/>
</a>
</details>

#### Add a new stake proposal

You can place a state using this command:
```txt
./near-cli add stake-proposal \
        network testnet \
        validator 'volodymyr.testnet' \
        amount '100 NEAR' \
        transactions-signing-public-key 'ed25519:7ctWiPKSxdvPmAbwCBDT7dBCcJ5iqP14ohwVr7vf4whJ' \
        sign-with-keychain \
        send
```

<details><summary><i>The result of this command will be as follows:</i></summary>

```txt
Transaction sent ...
Failed transaction
Error: Insufficient stake 100.000 NEAR.
The minimum rate must be 31097.761 NEAR.
Transaction ID: 8m2NphgJfvY4u4kWt7ntaZmXt6CrqXuq44VVZoDMUATo.
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/8m2NphgJfvY4u4kWt7ntaZmXt6CrqXuq44VVZoDMUATo
```
</details>

<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/nMovygVG9GyKSVU0ywtk5z0RT?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/nMovygVG9GyKSVU0ywtk5z0RT.png" width="836"/>
</a>
</details>

#### Add a new sub-account

In order to create a sub-account, in the terminal command line type:
```txt
./near-cli add sub-account \
        network testnet \
        owner-account 'volodymyr.testnet' \
        sub-account '282.volodymyr.testnet' \
        sub-account-full-access \
        generate-keypair \
        deposit '1 NEAR' \
        sign-with-keychain \
        send
```

<details><summary><i>The result of this command will be as follows:</i></summary>

```txt
Transaction sent ...
Successful transaction
New account <282.volodymyr.testnet> has been successfully created.
Added access key = ed25519:512RGPTghPXSNziZRUi9K7UzMHiAwEetL5FpmZw6zdHd to 282.volodymyr.testnet.
<volodymyr.testnet> has transferred 1.000 NEAR to <282.volodymyr.testnet> successfully.
Transaction ID: 24a5rxkH4gLus4YBqm47JRNygbZEKLgiJVCZFx3Hcjqp.
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/24a5rxkH4gLus4YBqm47JRNygbZEKLgiJVCZFx3Hcjqp
```
</details>

<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/nW78yyzNhkK09sAxSFTgk0zX8?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/nW78yyzNhkK09sAxSFTgk0zX8.png" width="836"/>
</a>
</details>

### Delete access key, account

#### Delete an access key for this account

In order to remove access keys, in the terminal command line type:
```txt
./near-cli delete access-key \
        network testnet \
        account 'volodymyr.testnet' \
        public-key 'ed25519:Ekgny2BNdwaoRuNW2JBkSv6FGDjmrd5iP8noXE4dTUk2' \
        sign-with-keychain \
        send
```

<details><summary><i>The result of this command will be as follows:</i></summary>

```txt
Transaction sent ...
Successful transaction
Access key <ed25519:Ekgny2BNdwaoRuNW2JBkSv6FGDjmrd5iP8noXE4dTUk2> for account <volodymyr.testnet> has been successfully deletted.
Transaction ID: 9xeBgqpRButrSGZNUGcYbsxs2JM3A9NoH7Bkh6op4K8D.
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/9xeBgqpRButrSGZNUGcYbsxs2JM3A9NoH7Bkh6op4K8D
```
</details>

<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/KSZkGbwnQbG5vGtlG2fGIrawm?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/KSZkGbwnQbG5vGtlG2fGIrawm.png" width="836"/>
</a>
</details>

#### Delete this account

This command is designed to delete the current account. It is important to remember that all tokens of the deleted account will be transferred to the "_beneficiary_" account.
In order to execute this command, in the terminal command line type:
```txt
./near-cli delete account \
        network testnet \
        account '282.volodymyr.testnet' \
        beneficiary 'volodymyr.testnet' \
        sign-with-keychain \
        send
```

<details><summary><i>The result of this command will be as follows:</i></summary>

```txt
Transaction sent ...
Successful transaction
Account <282.volodymyr.testnet> has been successfully deletted.
Transaction ID: CfRvfMvEY7vtKM2ub18nKsMivNo95wUC5VYYQ64gcPm.
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/CfRvfMvEY7vtKM2ub18nKsMivNo95wUC5VYYQ64gcPm
```
</details>

<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/XEwJ4NVkuG7mnDiADiNPQ2L7n?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/XEwJ4NVkuG7mnDiADiNPQ2L7n.png" width="836"/>
</a>
</details>

### Construct a new transaction

Let's consider an example when it is necessary to perform several actions within one transaction:
1. Create an account
2. Add access keys to the created account
3. Transfer tokens to the created account

To do this, we will use the transaction constructor:

<details><summary>Construct a new transaction (демонстрация работы команды)</summary>
<a href="https://asciinema.org/a/2HPsb14qsgkr05eesfzXAKTXb?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/2HPsb14qsgkr05eesfzXAKTXb.png" width="836"/>
</a>
</details>

### Helpers

#### Generate a key pair

This utility generates access keys at random. 
<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/vwlWvmyNnxaGOFMeHb5wkwe2t?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/vwlWvmyNnxaGOFMeHb5wkwe2t.png" width="836"/>
</a>
</details>

#### Sign a transaction with private key

This utility allows you to sign a previously formed and unsigned transaction with your keys.
<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/sjS78AfPfwltNge2Yb9uRCxSX?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/sjS78AfPfwltNge2Yb9uRCxSX.png" width="836"/>
</a>
</details>

#### Sign a transaction with Ledger

This utility allows you to sign a previously formed and unsigned transaction using a ledger. It is assumed that the ledger is connected to the computer, unlocked and running the _NEAR_ application.
<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/G96fR2Ap9qdImtn2ITUJL82RR?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/G96fR2Ap9qdImtn2ITUJL82RR.png" width="836"/>
</a>
</details>

#### Combine unsigned transaction with signature

This utility allows you to sign a previously generated and unsigned transaction with your signature.
<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/HfsutLZKnWS8w1PnY1kGIUYid?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/HfsutLZKnWS8w1PnY1kGIUYid.png" width="836"/>
</a>
</details>

#### Deserializing the bytes from base64

It might be useful to view the contents of a serialized transaction (either signed or not).
Given a base64-encoded string, we should be able to view the human-readable representation.
<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/Gtb4M13a8QW5VaVmfgBLEcq3X?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/Gtb4M13a8QW5VaVmfgBLEcq3X.png" width="836"/>
</a>
</details>

#### Send signed transaction

Given the base64 encoded string, we should be able to send it for execution.
<details><summary><i>Demonstration of the command in interactive mode</i></summary>
<a href="https://asciinema.org/a/4g9yN7PFBdBSeQRxPc8ydfpWs?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/4g9yN7PFBdBSeQRxPc8ydfpWs.png" width="836"/>
</a>
</details>

'''
'''--- docs/GUIDE.ru.md ---
## Инструкция

Это руководство предназначено для того, чтобы дать подробное описание утилиты near-cli и
обзор её возможностей. Предполагается, что утилита near-cli
[установлена](README.ru.md#installation)
и пользователи знакомы с использованием инструментов командной строки. Также предполагается Unix-подобная система, хотя большинство команд, вероятно, легко
переводимы в любую среду оболочки командной строки.

Прежде, чем перейти к описанию конкретных команд, необходимо рассмотреть два общих для этих команд пункта:

1. Подпись транзакции

   near-cli предполагает несколько способов подписи созданной транзакции. Рассмотрим подробнее каждый.

   - _sign-with-keychain - Sign the transaction with a keychain_

     near-cli самостоятельно найдет ключи доступа и подпишет созданную транзакцию.
     Каталог с ключами доступа определен в конфигурационном файле (near-cli/config.toml), который находится в зависимости от операциооной системы в следующих местах:

     - Linux: $XDG_CONFIG_HOME или $HOME/.config (/home/alice/.config)
     - macOS: $HOME/Library/Application Support (/Users/Alice/Library/Application Support)
     - Windows: {FOLDERID*RoamingAppData} (C:\Users\Alice\AppData\Roaming)
       Ключи доступа должны находиться в файле \*публичный*ключ.json*, расположенном в */Users/user/.near-credentials/имя*сети/имя*пользователя/_.  
       Например, _/Users/frovolod/.near-credentials/testnet/volodymyr.testnet/ed25519_8h7kFK4quSUJRkUwo3LLiK83sraEm2jnQTECuZhWu8HC.json\*

   - _sign-with-ledger - Sign the transaction with a ledger_

     Этот вариант предполагает подписание созданной транзакции при помощи леджера.

   - _sign-with-plaintext-private-key - Sign the transaction with a plaintext private key_

     При выборе этого варианта подписи near-cli попросит пользователя ввести ключи доступа:
     "public_key":"ed25519:Ebx7...",
     "private_key":"ed25519:2qM8..."

     <details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
     <a href="https://asciinema.org/a/30jHxm9lRevRG4K1h0GWlEciV?autoplay=1&t=1&speed=2">
         <img src="https://asciinema.org/a/30jHxm9lRevRG4K1h0GWlEciV.png" width="836"/>
     </a>
     </details>

2. Действия с подписанной транзакцией

   Подписанную транзакцию можно либо немедленно отправить на выполнение:

   - _send - Send the transaction to the network_

   либо вывести на экран в формате base64 для последующей отправки:

   - _display - Print only base64 encoded transaction for JSON RPC input and exit_

### Группы команд

- [account     - Manage accounts](#account---Manage-accounts)
- [tokens      - Manage token assets such as NEAR, FT, NFT](#tokens---Manage-token-assets-such-as-NEAR-FT-NFT)
- [contract    - Manage smart-contracts: deploy code, call functions](#contract---Manage-smart-contracts-deploy-code-call-functions)
- [transaction - Operate transactions](#transaction---Operate-transactions)

### account - Manage accounts

Просмотреть сведения об аккаунте ([View properties for an account](#view-account-summary---view-properties-for-an-account)) и просмотреть ключи доступа к аккаунту ([View a list of access keys of an account](#list-keys---View-a-list-of-access-keys-of-an-account)) возможно в режиме реального времени (**now**) и режиме архивных данных (**at-block-height**, **at-block-hash**). На примерах ниже показаны варианты применения этих режимов.

- [view-account-summary](#view-account-summary---View-properties-for-an-account)
- [login](#login---Log-in-with-NEAR-Wallet-authorization)
- [create-subaccount](#create-subaccount---Create-a-new-sub-account)
- [create-implicit-account](#create-implicit-account---Create-an-implicit-account)
- [delete-account](#delete-account---Delete-an-account)
- [list-keys](#list-keys---View-a-list-of-access-keys-of-an-account)
- [add-key](#add-key---Add-an-access-key-to-an-account)
- [delete-key](#delete-key---Delete-an-access-key-from-an-account)

#### view-account-summary - View properties for an account

- [now](#now---View-properties-in-the-final-block)
- [at-block-height](#at-block-height---View-properties-in-a-height-selected-block)
- [at-block-hash](#at-block-hash---View-properties-in-a-hash-selected-block)

##### now - View properties in the final block

Для просмотра сведений об аккаунте на последнем блоке необходимо ввести в командной строке терминала:

```txt
./near-cli account \
    view-account-summary fro_volod.testnet \
    network testnet \
    now
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
Account details for 'fro_volod.testnet' at block #97804915 (5G8HHWMJMHRMMaHTjeZLSvL7ruYMtH9tXq25Q6BPUivu)
Native account balance: 182.685021399504861699999997 NEAR
Validator stake: 0 NEAR
Storage used by the account: 288962 bytes
Contract code SHA-256 checksum (hex): fd999145baf49ece7d09fca7d030d384c4ea8ed4df651c6e87a015c4dfa6c0ec
Number of access keys: 14
   1. ed25519:2QFAeUutKUDpmgKDyHXm7Wcz1uhjxk92fK6zY2dB7FCD (nonce: 97492076000000) is granted to only do [] function calls on v2.ref-farming.testnet with an allowance of 0.25 NEAR
   2. ed25519:3p1HbrTDYxY4q3V6QznW14qkuv3Bq1phFpCTsbrJpbEC (nonce: 94363284000000) is granted to full access
   3. ed25519:5UJE4PzyxECS42hBZSD1QQCLdq5j39vCtzshFPbnGdm1 (nonce: 73069087000002) is granted to full access
   4. ed25519:6YU78BezKwQNrz5vmtkSCALtx7cPDC1JBs9DhjeSJ39X (nonce: 97490513000000) is granted to only do [] function calls on v2.ref-farming.testnet with an allowance of 0.25 NEAR
   5. ed25519:7YCfA1KrToJtAYGTBgAMe4LWfQEi4iwLGcH2q5SvGKzD (nonce: 94982716000000) is granted to only do [] function calls on mintspace2.testnet with an allowance of 0.25 NEAR
   6. ed25519:95w5YFsJ3iktzDwRBWUGqLF6Gv5CoJuVifBjcEEdJs8s (nonce: 72253433000003) is granted to full access
   7. ed25519:9nyDySTNAGPywxC9pG4DPdnF3eEVexDgrfzZYsoahPsV (nonce: 76057805000000) is granted to full access
   8. ed25519:AEC4szaeNzT8PQAifsnisdivq4mwswJbBM65DdkT6kdS (nonce: 72263674000000) is granted to full access
   9. ed25519:D31un5TFeABdNUVMaf3QzeBz3Z3yau2GZA2VPe8XX6GB (nonce: 72325441000021) is granted to full access
  10. ed25519:DZz4r5oLSBVcLuqFzSoLUEJ3Qv67cpgGbsRHy8SvbGiU (nonce: 72253481000000) is granted to full access
  11. ed25519:DyKmdLkWMqC1HFs6t6PfNhVemjQE16W2RNofWPpW5ZZh (nonce: 72325378000007) is granted to full access
  12. ed25519:EWoYxHNZHtApUfu1nTGC49XHW5dNinoDKABcauHnjevZ (nonce: 73069042000001) is granted to full access
  13. ed25519:EYtsL67TpgfpE1udnga2m41vDoBqeZ2DB32onhsxsVUb (nonce: 72251760000002) is granted to full access
  14. ed25519:G2U7aZ91pgG3TS96gCWov5L1DkNWSi3756RRkwuspZ4L (nonce: 72251684000002) is granted to full access
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/WA7eNU7hbmv7oa5lNLrmJzmRu?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/WA7eNU7hbmv7oa5lNLrmJzmRu.png" width="836"/>
</a>
</details>

##### at-block-height - View properties in a height-selected block

Для просмотра сведений об аккаунте на конктретном блоке необходимо ввести в командной строке терминала:
```txt
./near-cli account \
    view-account-summary fro_volod.testnet \
    network testnet \
    at-block-height 73069245
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
Account details for 'fro_volod.testnet' at block #73069245 (HCUJq3vQ3ztyCZAhmRmHR3cwSDcoE4zEbaWkhAjFuxUY)
Native account balance: 198.9924766125790117 NEAR
Validator stake: 0 NEAR
Storage used by the account: 288660 bytes
Contract code SHA-256 checksum (hex): fd999145baf49ece7d09fca7d030d384c4ea8ed4df651c6e87a015c4dfa6c0ec
Number of access keys: 12
   1. ed25519:5UJE4PzyxECS42hBZSD1QQCLdq5j39vCtzshFPbnGdm1 (nonce: 73069087000001) is granted to full access
   2. ed25519:95w5YFsJ3iktzDwRBWUGqLF6Gv5CoJuVifBjcEEdJs8s (nonce: 72253433000003) is granted to full access
   3. ed25519:AEC4szaeNzT8PQAifsnisdivq4mwswJbBM65DdkT6kdS (nonce: 72263674000000) is granted to full access
   4. ed25519:D31un5TFeABdNUVMaf3QzeBz3Z3yau2GZA2VPe8XX6GB (nonce: 72325441000009) is granted to full access
   5. ed25519:DZz4r5oLSBVcLuqFzSoLUEJ3Qv67cpgGbsRHy8SvbGiU (nonce: 72253481000000) is granted to full access
   6. ed25519:DyKmdLkWMqC1HFs6t6PfNhVemjQE16W2RNofWPpW5ZZh (nonce: 72325378000001) is granted to full access
   7. ed25519:EWoYxHNZHtApUfu1nTGC49XHW5dNinoDKABcauHnjevZ (nonce: 73069042000001) is granted to full access
   8. ed25519:EYtsL67TpgfpE1udnga2m41vDoBqeZ2DB32onhsxsVUb (nonce: 72251760000002) is granted to full access
   9. ed25519:G2U7aZ91pgG3TS96gCWov5L1DkNWSi3756RRkwuspZ4L (nonce: 72251684000002) is granted to full access
  10. ed25519:H5A5WfckocSLeXC7h22PcnscrWWrADHaRzrVWFMYT5o9 (nonce: 72254265000000) is granted to full access
  11. ed25519:HXHM2GTqDzCZnd7UQzPtL7VwcFfcm7n8Z8voo1ArE4Tr (nonce: 72263503000002) is granted to full access
  12. ed25519:HjzSeCGdWT15iSj2TybmKV2dZteu1VYYAaYvNYVNZY2W (nonce: 72253750000000) is granted to full access
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/oKL2H2gbDntOt0MHqpjsPnZZv?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/oKL2H2gbDntOt0MHqpjsPnZZv.png" width="836"/>
</a>
</details>

##### at-block-hash - View properties in a hash-selected block

Для просмотра сведений об аккаунте необходимо ввести в командной строке терминала:
```txt
./near-cli account \
    view-account-summary fro_volod.testnet \
    network testnet \
    at-block-hash HCUJq3vQ3ztyCZAhmRmHR3cwSDcoE4zEbaWkhAjFuxUY
````

<details><summary><i>Результат выполнения команды</i></summary>

```txt
Account details for 'fro_volod.testnet' at block #73069245 (HCUJq3vQ3ztyCZAhmRmHR3cwSDcoE4zEbaWkhAjFuxUY)
Native account balance: 198.9924766125790117 NEAR
Validator stake: 0 NEAR
Storage used by the account: 288660 bytes
Contract code SHA-256 checksum (hex): fd999145baf49ece7d09fca7d030d384c4ea8ed4df651c6e87a015c4dfa6c0ec
Number of access keys: 12
   1. ed25519:5UJE4PzyxECS42hBZSD1QQCLdq5j39vCtzshFPbnGdm1 (nonce: 73069087000001) is granted to full access
   2. ed25519:95w5YFsJ3iktzDwRBWUGqLF6Gv5CoJuVifBjcEEdJs8s (nonce: 72253433000003) is granted to full access
   3. ed25519:AEC4szaeNzT8PQAifsnisdivq4mwswJbBM65DdkT6kdS (nonce: 72263674000000) is granted to full access
   4. ed25519:D31un5TFeABdNUVMaf3QzeBz3Z3yau2GZA2VPe8XX6GB (nonce: 72325441000009) is granted to full access
   5. ed25519:DZz4r5oLSBVcLuqFzSoLUEJ3Qv67cpgGbsRHy8SvbGiU (nonce: 72253481000000) is granted to full access
   6. ed25519:DyKmdLkWMqC1HFs6t6PfNhVemjQE16W2RNofWPpW5ZZh (nonce: 72325378000001) is granted to full access
   7. ed25519:EWoYxHNZHtApUfu1nTGC49XHW5dNinoDKABcauHnjevZ (nonce: 73069042000001) is granted to full access
   8. ed25519:EYtsL67TpgfpE1udnga2m41vDoBqeZ2DB32onhsxsVUb (nonce: 72251760000002) is granted to full access
   9. ed25519:G2U7aZ91pgG3TS96gCWov5L1DkNWSi3756RRkwuspZ4L (nonce: 72251684000002) is granted to full access
  10. ed25519:H5A5WfckocSLeXC7h22PcnscrWWrADHaRzrVWFMYT5o9 (nonce: 72254265000000) is granted to full access
  11. ed25519:HXHM2GTqDzCZnd7UQzPtL7VwcFfcm7n8Z8voo1ArE4Tr (nonce: 72263503000002) is granted to full access
  12. ed25519:HjzSeCGdWT15iSj2TybmKV2dZteu1VYYAaYvNYVNZY2W (nonce: 72253750000000) is granted to full access
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/TqhSdwjoc9PMxbLZtTWSnCRR5?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/TqhSdwjoc9PMxbLZtTWSnCRR5.png" width="836"/>
</a>
</details>

#### login - Log in with NEAR Wallet authorization

Для авторизации пользователя необходимо ввести в командной строке терминала:
```txt
./near-cli account \
    import-account \
    network testnet
```

Вы будете перенаправлены браузер для авторизации. После успешной авторизации в "NEAR Wallet" необходимо вернуться в терминал и ввести имя пользователя.
<details><summary><i>Результат выполнения команды</i></summary>

```txt
The data for the access key is saved in a file /Users/frovolod/.near-credentials/testnet/fro_volod.testnet/ed25519_GicfpXn1Ebb71gkBAoXKsoU1Nwv2hBppiMexxSFRHjyM.json
The file: /Users/frovolod/.near-credentials/testnet/fro_volod.testnet.json already exists! Therefore it was not overwritten.
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/ham4fYGgVjOJq3U2gfwwySIvj?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/ham4fYGgVjOJq3U2gfwwySIvj.png" width="836"/>
</a>
</details>

#### create-subaccount - Create a new sub-account

Для создания суб-аккаунта необходимо ввести в командной строке терминала:
```txt
./near-cli account \
    create-subaccount 2.fro_volod.testnet \
    '10 NEAR' \
    autogenerate-new-keypair \
    save-to-keychain \
    network testnet \
    sign-with-keychain \
    send
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
Transaction sent ...
Successful transaction
New account <2.fro_volod.testnet> has been successfully created.
<fro_volod.testnet> has transferred 10 NEAR to <2.fro_volod.testnet> successfully.
Added access key = ed25519:EvGEHtEdEqsywGcGbegLpm5JQvqbv1Bo19jUa8jidqZc to 2.fro_volod.testnet.
Transaction ID: 82i7DWkAvVQFM2C1afaYhyPuZmr5DVeC4qQfM6D5V7Yt
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/82i7DWkAvVQFM2C1afaYhyPuZmr5DVeC4qQfM6D5V7Yt
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/NjpfOJDMlOrr7chIyYrWCZAzH?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/NjpfOJDMlOrr7chIyYrWCZAzH.png" width="836"/>
</a>
</details>

#### create-implicit-account - Create an implicit-account

- [use-auto-generation](#use-auto-generation---Use-auto-generation-to-create-an-implicit-account)
- [use-ledger](#use-ledger---Use-ledger-to-create-an-implicit-account)

##### use-auto-generation - Use auto-generation to create an implicit account

Данная команда автоматически генерирует аккаунт с ключами доступа и сохраняет их в файле с именем implicit-account-id.
Для выполнения этой команды необходимо ввести в командной строке терминала:
```txt
./near-cli account \
    create-implicit-account \
    use-auto-generation \
    save-to-folder /Users/frovolod/.near-credentials/implicit
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
The file "/Users/frovolod/.near-credentials/implicit/38a078c59b84e49e01b42ae79c77992b86dd1204c79cac688401a33045199441.json" was saved successfully
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/wvItMyT51nBKAbnlhW7D13reT?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/wvItMyT51nBKAbnlhW7D13reT.png" width="836"/>
</a>
</details>

##### use-ledger - Use ledger to create an implicit account

Данная команда с помощью леджера создает аккаунт с ключами доступа и сохраняет их в файле с именем implicit-account-id.
Для выполнения этой команды необходимо ввести в командной строке терминала:
```txt
./near-cli account \
    create-implicit-account \
    use-ledger \
    save-to-folder /Users/frovolod/.near-credentials/implicit/ledger
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
The file "/Users/frovolod/.near-credentials/implicit/ledger/739c872c3057cd5d812c49345248b9fdd318c8ad33ace6cf0468109eae972c8e.json" was saved successfully
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/kL5x9MXNrlSZWS83YjVkxnsf7?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/kL5x9MXNrlSZWS83YjVkxnsf7.png" width="836"/>
</a>
</details>

#### delete-account - Delete an account

Данная команда предназначена для удаления текущего аккаунта. Важно помнить, что все средства удаляемого аккаунта перейдут на счет "_beneficiary_".
Для выполнения этой команды необходимо ввести в командной строке терминала:
```txt
./near-cli account \
    delete-account 2.fro_volod.testnet \
    beneficiary volodymyr.testnet \
    network testnet \
    sign-with-keychain \
    send
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
Transaction sent ...
Successful transaction
Account <2.fro_volod.testnet> has been successfully deleted.
Transaction ID: EHvB47npN8Z46qhsrw5XpKmD3n3jDn4MGiD85YSqw7cy
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/EHvB47npN8Z46qhsrw5XpKmD3n3jDn4MGiD85YSqw7cy
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/bicRQEA5bhRG6e7nKaF8ghzVm?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/bicRQEA5bhRG6e7nKaF8ghzVm.png" width="836"/>
</a>
</details>

#### list-keys - View a list of access keys of an account

Режимами реального времени (**at-final-block**) и архивных данных (**at-block-height**, **at-block-hash**) следует пользоваться аналогично просмотру сведений об аккаунте ([View properties for an account](#view-account-summary---view-properties-for-an-account)).

Для просмотра списка ключей доступа необходимо ввести в командной строке терминала:
```txt
./near-cli account \
    list-keys fro_volod.testnet \
    network testnet \
    now
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
Number of access keys: 14
   1. ed25519:2QFAeUutKUDpmgKDyHXm7Wcz1uhjxk92fK6zY2dB7FCD (nonce: 97492076000000) is granted to only do [] function calls on v2.ref-farming.testnet with an allowance of 0.25 NEAR
   2. ed25519:3p1HbrTDYxY4q3V6QznW14qkuv3Bq1phFpCTsbrJpbEC (nonce: 94363284000000) is granted to full access
   3. ed25519:5UJE4PzyxECS42hBZSD1QQCLdq5j39vCtzshFPbnGdm1 (nonce: 73069087000002) is granted to full access
   4. ed25519:6YU78BezKwQNrz5vmtkSCALtx7cPDC1JBs9DhjeSJ39X (nonce: 97490513000000) is granted to only do [] function calls on v2.ref-farming.testnet with an allowance of 0.25 NEAR
   5. ed25519:7YCfA1KrToJtAYGTBgAMe4LWfQEi4iwLGcH2q5SvGKzD (nonce: 94982716000000) is granted to only do [] function calls on mintspace2.testnet with an allowance of 0.25 NEAR
   6. ed25519:95w5YFsJ3iktzDwRBWUGqLF6Gv5CoJuVifBjcEEdJs8s (nonce: 72253433000003) is granted to full access
   7. ed25519:9nyDySTNAGPywxC9pG4DPdnF3eEVexDgrfzZYsoahPsV (nonce: 76057805000000) is granted to full access
   8. ed25519:AEC4szaeNzT8PQAifsnisdivq4mwswJbBM65DdkT6kdS (nonce: 72263674000000) is granted to full access
   9. ed25519:D31un5TFeABdNUVMaf3QzeBz3Z3yau2GZA2VPe8XX6GB (nonce: 72325441000021) is granted to full access
  10. ed25519:DZz4r5oLSBVcLuqFzSoLUEJ3Qv67cpgGbsRHy8SvbGiU (nonce: 72253481000000) is granted to full access
  11. ed25519:DyKmdLkWMqC1HFs6t6PfNhVemjQE16W2RNofWPpW5ZZh (nonce: 72325378000007) is granted to full access
  12. ed25519:EWoYxHNZHtApUfu1nTGC49XHW5dNinoDKABcauHnjevZ (nonce: 73069042000001) is granted to full access
  13. ed25519:EYtsL67TpgfpE1udnga2m41vDoBqeZ2DB32onhsxsVUb (nonce: 72251760000002) is granted to full access
  14. ed25519:G2U7aZ91pgG3TS96gCWov5L1DkNWSi3756RRkwuspZ4L (nonce: 72251684000002) is granted to full access
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/KVfcCCyj2dEHEm4TcDkjtiW6s?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/KVfcCCyj2dEHEm4TcDkjtiW6s.png" width="836"/>
</a>
</details>

#### add-key - Add an access key to an account

Выполним команду добавления новой пары ключей доступа аккаунту с такими условиями:
  - публичный ключ доступа будет введен вручную
  - ключи будут иметь полный доступ
  - транзакция будет подписана автоматически (при наличии файла с ключами доступа)

Для выполнения этой команды необходимо ввести в командной строке терминала:
```txt
./near-cli account \
    add-key fro_volod.testnet \
    grant-full-access \
    use-manually-provided-public-key ed25519:75a5ZgVZ9DFTxs4THtFxPtLj7AY3YzpxtapTQBdcMXx3 \
    network testnet \
    sign-with-keychain \
    send
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
Transaction sent ...
Successful transaction
Added access key = ed25519:75a5ZgVZ9DFTxs4THtFxPtLj7AY3YzpxtapTQBdcMXx3 to fro_volod.testnet.
Transaction ID: 2oVDKopcWphN3qrUoq7XjFMpRuCUjz6jSU327q8trAQ5
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/2oVDKopcWphN3qrUoq7XjFMpRuCUjz6jSU327q8trAQ5
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/H4BfrteW1ClAzrLcRx9m8gQAV?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/H4BfrteW1ClAzrLcRx9m8gQAV.png" width="836"/>
</a>
</details>

Изменим наши парамерты для добавления кючей доступа:
  - ключи будут сгенерированы автоматически
  - будут иметь функциональный доступ
  - транзакция будет подписана вручную

Для этого введем следующую команду:
```txt
./near-cli account \
    add-key fro_volod.testnet \
    grant-function-call-access \
        --allowance '10 NEAR' \
        --receiver-account-id 'meta.pool.testnet' \
        --method-names 'set_a, set_b' \
    autogenerate-new-keypair \
    save-to-keychain \
    network testnet \
    sign-with-plaintext-private-key \
        --signer-public-key ed25519:D31un5TFeABdNUVMaf3QzeBz3Z3yau2GZA2VPe8XX6GB \
        --signer-private-key  ed25519:3UVo1GAatRz12iX3CRuKAuK3MPLDD9bPf4LXJD5DkHs13er3UeJLW7aRPAVsFQ2FjopUw6DEApEngac8FPtnnkYB \
    send
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
Transaction sent ...
Successful transaction
Added access key = ed25519:27R66L6yevyHbsk4fESZDC8QUQBwCdx6vvkk1uQmG7NY to fro_volod.testnet.
Transaction ID: DaJySrNtSUZU7KPyvfUMbh6xYi9vZeMvnj4Umo7ZzdB3
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/DaJySrNtSUZU7KPyvfUMbh6xYi9vZeMvnj4Umo7ZzdB3
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/h08oydOTq3njf6mt1FNRMHGVs?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/h08oydOTq3njf6mt1FNRMHGVs.png" width="836"/>
</a>
</details>

#### delete-key - Delete an access key from an account

Для удаления ключей доступа необходимо ввести в командной строке терминала:
```txt
./near-cli account \
    delete-key fro_volod.testnet \
    ed25519:75a5ZgVZ9DFTxs4THtFxPtLj7AY3YzpxtapTQBdcMXx3 \
    network testnet \
    sign-with-keychain \
    send
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
Transaction sent ...
Successful transaction
Access key <ed25519:75a5ZgVZ9DFTxs4THtFxPtLj7AY3YzpxtapTQBdcMXx3> for account <fro_volod.testnet> has been successfully deleted.
Transaction ID: 6S7bJ76QNFypUvP7PCB1hkLM7X5GxPxP2gn4rnDHMzPz
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/6S7bJ76QNFypUvP7PCB1hkLM7X5GxPxP2gn4rnDHMzPz
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/IYaNEYcMHtmSe6zKc2L63Okph?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/IYaNEYcMHtmSe6zKc2L63Okph.png" width="836"/>
</a>
</details>

### tokens - Manage token assets such as NEAR, FT, NFT
- [send-near](#send-near---The-transfer-is-carried-out-in-NEAR-tokens)
- [send-ft](#send-ft---The-transfer-is-carried-out-in-FT-tokens)
- [send-nft](#send-nft---The-transfer-is-carried-out-in-NFT-tokens)
- [view-near-balance](#view-near-balance---View-the-balance-of-Near-tokens)
- [view-ft-balance](#view-ft-balance---View-the-balance-of-FT-tokens)
- [view-nft-assets](#view-nft-assets---View-the-balance-of-NFT-tokens)

#### send-near - The transfer is carried out in NEAR tokens

Данная команда служит для перевода средств NEAR токенах между аккаунтами. Обратите внимание, что количество пересылаемых токенов указывается совместно с размерной единицей (это NEAR либо yoctoNEAR).
Для выполнения этой команды необходимо ввести в командной строке терминала:
```txt
./near-cli tokens \
    fro_volod.testnet \
    send-near volodymyr.testnet 0.1NEAR \
    network testnet \
    sign-with-keychain \
    send
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
Transaction sent ...
Successful transaction
<fro_volod.testnet> has transferred 0.1 NEAR to <volodymyr.testnet> successfully.
Transaction ID: 8BbB674VDxeg36egMzdHFsCUExpkLWAWeYqEfd9u9ZaD
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/8BbB674VDxeg36egMzdHFsCUExpkLWAWeYqEfd9u9ZaD
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/U1pNSHZw812e4BHvnFGpefVs4?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/U1pNSHZw812e4BHvnFGpefVs4.png" width="836"/>
</a>
</details>

#### send-ft - The transfer is carried out in FT tokens

Данная команда служит для перевода средств в FT токенах между аккаунтами. Обратите внимание, что количество пересылаемых токенов указывается в безразмерных единицах.
Для выполнения этой команды необходимо ввести в командной строке терминала:
```txt
./near-cli tokens \
    fro_volod.testnet \
    send-ft usdn.testnet volodymyr.testnet 10000000000000000000 \
        --prepaid-gas 100.000TeraGas \
        --attached-deposit 0.000000000000000000000001NEAR \
    network testnet \
    sign-with-keychain \
    send
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
Transaction sent ...
Successful transaction
The "ft_transfer" call to <usdn.testnet> on behalf of <fro_volod.testnet> succeeded.
Transaction ID: 5a7YmANdpimiqUm6WC6n4dd91b6A9PafNNhad8HWKugN
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/5a7YmANdpimiqUm6WC6n4dd91b6A9PafNNhad8HWKugN
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/uvZGcJUpufJZdB10GsQlfXwW1?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/uvZGcJUpufJZdB10GsQlfXwW1.png" width="836"/>
</a>
</details>

#### send-nft - The transfer is carried out in NFT tokens

Данная команда служит для перевода средств в NFT токенах между аккаунтами.
Для выполнения этой команды необходимо ввести в командной строке терминала:
```txt
./near-cli tokens \
    fro_volod.testnet \
    send-nft paras-token-v2.testnet volodymyr.testnet 1604:4 \
        --prepaid-gas 100.000TeraGas \
        --attached-deposit 0.000000000000000000000001NEAR \
    network testnet \
    sign-with-keychain \
    send
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
Transaction sent ...
Successful transaction
The "nft_transfer" call to <paras-token-v2.testnet> on behalf of <fro_volod.testnet> succeeded.
Transaction ID: 9q2VbakZbj5ja6GAFXpFnbtbYHijEHyT7Ry34GQ6cvLB
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/9q2VbakZbj5ja6GAFXpFnbtbYHijEHyT7Ry34GQ6cvLB
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/iFXW6ryGQSdsWML0c3qAw3qGY?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/iFXW6ryGQSdsWML0c3qAw3qGY.png" width="836"/>
</a>
</details>

#### view-near-balance - View the balance of Near tokens

Режимами реального времени (**at-final-block**) и архивных данных (**at-block-height**, **at-block-hash**) следует пользоваться аналогично просмотру сведений об аккаунте ([View properties for an account](#view-account-summary---view-properties-for-an-account)).

Для просмотра средств в NEAR токенах на счету аккаунта необходимо ввести в командной строке терминала:
```txt
./near-cli tokens \
    fro_volod.testnet \
    view-near-balance \
    network testnet \
    now
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
fro_volod.testnet account has 169.589001320890476999999994 NEAR available for transfer (the total balance is 172.482461320890476999999994 NEAR, but 2.89246 NEAR is locked for storage and the transfer transaction fee is ~0.001 NEAR)
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/lKGalzAxt3zCSxOsreqdykO8X?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/lKGalzAxt3zCSxOsreqdykO8X.png" width="836"/>
</a>
</details>

#### view-ft-balance - View the balance of FT tokens

Режимами реального времени (**at-final-block**) и архивных данных (**at-block-height**, **at-block-hash**) следует пользоваться аналогично просмотру сведений об аккаунте ([View properties for an account](#view-account-summary---view-properties-for-an-account)).

Для просмотра средств в FT токенах на счету аккаунта необходимо ввести в командной строке терминала:
```txt
./near-cli tokens \
    fro_volod.testnet \
    view-ft-balance usdn.testnet \
    network testnet \
    now
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
fro_volod.testnet account has "31942967677775774595" FT tokens (FT-contract: usdn.testnet)
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/k7Bz5r20x2Bo5RIX7Q1VnpNZC?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/k7Bz5r20x2Bo5RIX7Q1VnpNZC.png" width="836"/>
</a>
</details>

#### view-nft-assets - View the balance of NFT tokens

Режимами реального времени (**at-final-block**) и архивных данных (**at-block-height**, **at-block-hash**) следует пользоваться аналогично просмотру сведений об аккаунте ([View properties for an account](#view-account-summary---view-properties-for-an-account)).

Для просмотра средств в NFT токенах на счету аккаунта необходимо ввести в командной строке терминала:
```txt
./near-cli tokens \
    fro_volod.testnet \
    view-nft-assets paras-token-v2.testnet \
    network testnet \
    now
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
fro_volod.testnet account has NFT tokens:
[
  {
    "approved_account_ids": {},
    "metadata": {
      "copies": 100,
      "description": null,
      "expires_at": null,
      "extra": null,
      "issued_at": "1657613801537412611",
      "media": "bafybeib65t37t2tagukok4m7f5rldfirzb5ykvdq3yqbwnbcrtllpggg6u",
      "media_hash": null,
      "reference": "bafkreidmbv4j2qylxc2mngsup7cxakw7gwyd7lu2zycznrdtqw4kc52cwu",
      "reference_hash": null,
      "starts_at": null,
      "title": "Apollo42 #01 #4",
      "updated_at": null
    },
    "owner_id": "fro_volod.testnet",
    "token_id": "1604:4"
  }
]
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/znmY5yzIlSTjOlRRRUHzeeuzJ?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/znmY5yzIlSTjOlRRRUHzeeuzJ.png" width="836"/>
</a>
</details>

### contract - Manage smart-contracts: deploy code, call functions

- [call-function](#call-function---Execute-function-contract-method)
- [deploy](#deploy---Add-a-new-contract-code)
- [download-wasm](#download-wasm---Download-wasm)

#### call-function - Execute function (contract method)

- [as-read-only](#as-read-only---Calling-a-view-method)
- [as-transaction](#as-transaction---Calling-a-change-method)

##### as-read-only - Calling a view method

Режимами реального времени (**at-final-block**) и архивных данных (**at-block-height**, **at-block-hash**) следует пользоваться аналогично просмотру сведений об аккаунте ([View properties for an account](#view-account-summary---view-properties-for-an-account)).

Для выполнения этой команды необходимо ввести в командной строке терминала:
```txt
./near-cli contract \
    call-function \
    as-read-only \
    zavodil.poolv1.near \
    get_accounts '{"from_index": 0, "limit": 3}' \
    network mainnet \
    now
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
[
  {
    "account_id": "zavodil.near",
    "can_withdraw": false,
    "staked_balance": "107480661091559500516766891",
    "unstaked_balance": "1307739180247557404925470405"
  },
  {
    "account_id": "gagdiez.near",
    "can_withdraw": true,
    "staked_balance": "4387193990112136827894210960",
    "unstaked_balance": "1"
  },
  {
    "account_id": "gibby49.near",
    "can_withdraw": true,
    "staked_balance": "1105950300133283278041226",
    "unstaked_balance": "1"
  }
]
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/OHhdlJEaoA4nLJSDtybgc7kCR?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/OHhdlJEaoA4nLJSDtybgc7kCR.png" width="836"/>
</a>
</details>

##### as-transaction - Calling a change method

Для выполнения этой команды необходимо ввести в командной строке терминала:
```txt
./near-cli contract \
    call-function \
    as-transaction \
    turbo.volodymyr.testnet \
    rate '{"other_user":"volodymyr.testnet", "vote":5}' \
        --prepaid-gas '3 Tgas' \
        --attached-deposit '1 NEAR' \
    fro_volod.testnet \
    network testnet \
    sign-with-keychain \
    send
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
Transaction sent ...
Successful transaction
The "rate" call to <turbo.volodymyr.testnet> on behalf of <fro_volod.testnet> succeeded.
Transaction ID: 7RuoSAdCctSEw63GKsfQJg1YXRzH3msUCo4oygzauPko
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/7RuoSAdCctSEw63GKsfQJg1YXRzH3msUCo4oygzauPko
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/S6LHwINBHskznxMrJPHzUmgxM?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/S6LHwINBHskznxMrJPHzUmgxM.png" width="836"/>
</a>
</details>

#### deploy - Add a new contract code

Для добавления нового контракта необходимо ввести в командной строке терминала:
```txt
./near-cli contract \
    deploy \
    262.volodymyr.testnet \
    use-file /Users/frovolod/Documents/NEAR/rust-counter/contract/target/wasm32-unknown-unknown/release/rust_counter_tutorial.wasm \
    with-init-call increment {} \
        --prepaid-gas '1 TGas' \
        --attached-deposit '0 NEAR' \
    network testnet \
    sign-with-keychain \
    send
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
Transaction sent ...
Successful transaction
Contract code has been successfully deployed.
The "increment" call to <262.volodymyr.testnet> on behalf of <262.volodymyr.testnet> succeeded.
Transaction ID: 4YGGhF88aevNGpF5uaXNGHfQprHRqkia7eTpyxegJVms
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/4YGGhF88aevNGpF5uaXNGHfQprHRqkia7eTpyxegJVms
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/7KD9gM9tj2AWtgGpjUmytkPg9?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/7KD9gM9tj2AWtgGpjUmytkPg9.png" width="836"/>
</a>
</details>

#### download-wasm - Download wasm

Режимами реального времени (**at-final-block**) и архивных данных (**at-block-height**, **at-block-hash**) следует пользоваться аналогично просмотру сведений об аккаунте ([View properties for an account](#view-account-summary---view-properties-for-an-account)).

Для получения файла контракта необходимо ввести в командной строке терминала:

```txt
./near-cli contract \
    download-wasm 262.volodymyr.testnet \
    to-folder /Users/frovolod/Downloads \
    network testnet \
    now
```

<details><summary><i>Результат выполнения команды</i></summary>
```txt
The file "/Users/frovolod/Downloads/contract_262_volodymyr_testnet.wasm" was downloaded successfully
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/2UbeTzLJq16qtCUR015wuRFmN?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/2UbeTzLJq16qtCUR015wuRFmN.png" width="836"/>
</a>
</details>

### transaction - Operate transactions

- [view-status](#view-status---View-a-transaction-status)
- [construct-transaction](#construct-transaction---Construct-a-new-transaction)

#### view-status - View a transaction status

Для просмотра статуса желаемой транзакции необходимо ввести в командной строке терминала её хэш:
```txt
./near-cli transaction \
    view-status GDoinMecpvnqahzJz9tXLxYycznL4cAoxKTPEnJZ3ank \
    volodymyr.testnet \
    network testnet
```

<details><summary><i>Результат выполнения команды</i></summary>

```txt
Transaction status: FinalExecutionOutcomeWithReceiptView {
    final_outcome: FinalExecutionOutcome {
        status: SuccessValue(``),
        transaction: SignedTransactionView {
            signer_id: AccountId(
                "volodymyr.testnet",
            ),
            public_key: ed25519:7FmDRADa1v4BcLiiR9MPPdmWQp3Um1iPdAYATvBY1YzS,
            nonce: 165,
            receiver_id: AccountId(
                "qweqweqwe.volodymyr.testnet",
            ),
            actions: [
                CreateAccount,
                Transfer {
                    deposit: 100000000000000000000000000,
                },
                AddKey {
                    public_key: ed25519:AgVv8qjZ7yix3pTo7BimT1zoDYUSTGcg73RBssC5JMRf,
                    access_key: AccessKeyView {
                        nonce: 0,
                        permission: FullAccess,
                    },
                },
            ],
            signature: ed25519:266jBRjvnaxe4mDyHRGwv3TJesvgRo2umJBqkZU26fRwmhVHciu3tBSLqRZFjEuqLTiwDTrFvfxpJ8Sbd2PqHHhv,
            hash: `GDoinMecpvnqahzJz9tXLxYycznL4cAoxKTPEnJZ3ank`,
        },
        transaction_outcome: ExecutionOutcomeWithIdView {
            proof: [],
            block_hash: `AQH6jDqqxpBYj5NSZv3Skg5hUZQRsn16jvDuphCTugSQ`,
            id: `GDoinMecpvnqahzJz9tXLxYycznL4cAoxKTPEnJZ3ank`,
            outcome: ExecutionOutcomeView {
                logs: [],
                receipt_ids: [
                    `5DmuFwQaiSbEDiR7dx6sDurjyDyF92c1tK7gfN7bXqPh`,
                ],
                gas_burnt: 424555062500,
                tokens_burnt: 42455506250000000000,
                executor_id: AccountId(
                    "volodymyr.testnet",
                ),
                status: SuccessReceiptId(5DmuFwQaiSbEDiR7dx6sDurjyDyF92c1tK7gfN7bXqPh),
                metadata: ExecutionMetadataView {
                    version: 1,
                    gas_profile: None,
                },
            },
        },
        receipts_outcome: [
            ExecutionOutcomeWithIdView {
                proof: [],
                block_hash: `DBUpiLVVDBQwSAPU8ZTE8KQnX5skDD1dTsBjJQ8kV24R`,
                id: `5DmuFwQaiSbEDiR7dx6sDurjyDyF92c1tK7gfN7bXqPh`,
                outcome: ExecutionOutcomeView {
                    logs: [],
                    receipt_ids: [
                        `851GMnZZ5FJ2aDSHM34N99yVb1ZkwY8n7F8rUcvuRpUU`,
                    ],
                    gas_burnt: 424555062500,
                    tokens_burnt: 42455506250000000000,
                    executor_id: AccountId(
                        "qweqweqwe.volodymyr.testnet",
                    ),
                    status: SuccessValue(``),
                    metadata: ExecutionMetadataView {
                        version: 1,
                        gas_profile: None,
                    },
                },
            },
            ExecutionOutcomeWithIdView {
                proof: [],
                block_hash: `BSjrH3WyKnXhD17drR94YfM725Ho59us9N4msXrrgHEw`,
                id: `851GMnZZ5FJ2aDSHM34N99yVb1ZkwY8n7F8rUcvuRpUU`,
                outcome: ExecutionOutcomeView {
                    logs: [],
                    receipt_ids: [],
                    gas_burnt: 0,
                    tokens_burnt: 0,
                    executor_id: AccountId(
                        "volodymyr.testnet",
                    ),
                    status: SuccessValue(``),
                    metadata: ExecutionMetadataView {
                        version: 1,
                        gas_profile: None,
                    },
                },
            },
        ],
    },
    receipts: [
        ReceiptView {
            predecessor_id: AccountId(
                "volodymyr.testnet",
            ),
            receiver_id: AccountId(
                "qweqweqwe.volodymyr.testnet",
            ),
            receipt_id: `5DmuFwQaiSbEDiR7dx6sDurjyDyF92c1tK7gfN7bXqPh`,
            receipt: Action {
                signer_id: AccountId(
                    "volodymyr.testnet",
                ),
                signer_public_key: ed25519:7FmDRADa1v4BcLiiR9MPPdmWQp3Um1iPdAYATvBY1YzS,
                gas_price: 103000000,
                output_data_receivers: [],
                input_data_ids: [],
                actions: [
                    CreateAccount,
                    Transfer {
                        deposit: 100000000000000000000000000,
                    },
                    AddKey {
                        public_key: ed25519:AgVv8qjZ7yix3pTo7BimT1zoDYUSTGcg73RBssC5JMRf,
                        access_key: AccessKeyView {
                            nonce: 0,
                            permission: FullAccess,
                        },
                    },
                ],
            },
        },
        ReceiptView {
            predecessor_id: AccountId(
                "system",
            ),
            receiver_id: AccountId(
                "volodymyr.testnet",
            ),
            receipt_id: `851GMnZZ5FJ2aDSHM34N99yVb1ZkwY8n7F8rUcvuRpUU`,
            receipt: Action {
                signer_id: AccountId(
                    "volodymyr.testnet",
                ),
                signer_public_key: ed25519:7FmDRADa1v4BcLiiR9MPPdmWQp3Um1iPdAYATvBY1YzS,
                gas_price: 0,
                output_data_receivers: [],
                input_data_ids: [],
                actions: [
                    Transfer {
                        deposit: 1273665187500000000,
                    },
                ],
            },
        },
    ],
}
```
</details>

<details><summary><i>Демонстрация работы команды в интерактивном режиме</i></summary>
<a href="https://asciinema.org/a/xf69gJEha7yO27E27CZszkN97?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/xf69gJEha7yO27E27CZszkN97.png" width="836"/>
</a>
</details>

#### construct-transaction - Construct a new transaction
  
Рассмотрим пример, когда необходимо выполнить несколько действий в рамках одной транзакции:
1. Создать аккаунт
2. Добавить созданному аккаунту ключи доступа
3. Осуществить перевод токенов на созданный аккаунт

Для этого воспользуемся конструктором транзакции:

<details><summary>Construct a new transaction (демонстрация работы команды)</summary>
<a href="https://asciinema.org/a/WNbxN1GB861q2sBbiKbQyVl3S?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/WNbxN1GB861q2sBbiKbQyVl3S.png" width="836"/>
</a>
</details>

'''
'''--- docs/README.en.md ---
near-cli
--------
near-cli is a command line utility for working with the Near Protocol blockchain.

## README.md

* ru [Русский](README.ru.md)

## Documentation quick links

* [Usage](#usage)
* [User Guide](#user-guide)
* [Installation](#installation)
* [Building](#building)

## Usage

In general, it is difficult for a beginner to immediately understand how commands work.  
For example, I consider having the following command to do a transfer:
```txt
./near-cli tokens \
    'volodymyr.testnet' \
    send-near \
    'fro_volod.testnet' \
    '1 NEAR' \
    network testnet \
    sign-with-keychain \
    send
```
This is the complete version of the command. The result of this command will be as follows:
```txt
Successful transaction
<volodymyr.testnet> has transferred 1 NEAR to <fro_volod.testnet> successfully.
Transaction ID: G4t6Sgz2FjnNpruYjPP1ZJAKfRmBffVaqmj8Nup2TaAg
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/G4t6Sgz2FjnNpruYjPP1ZJAKfRmBffVaqmj8Nup2TaAg
```
Typing this or another command manually, you can make a mistake or forget the sequence of the command.  
It is not a problem. `--help` will tell you how to build a command properly.  
However, using near-cli, you can press _Enter_ anywhere in the command line and the interactive mode of the program will continue to compose the command from the place where you finished entering the necessary parameters.

<details><summary><i>Demonstration of the utility with a partially recruited command</i></summary>
<a href="https://asciinema.org/a/AfxLN1QtJi1z1qXuowTj2nDw2?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/AfxLN1QtJi1z1qXuowTj2nDw2.png" width="836"/>
</a>
</details>

## User Guide

Detailed user guide is available in the file [GUIDE.en.md](GUIDE.en.md).

## Installation

At this stage of the development of the utility, installation of the program is not required.  
It is enough to [download](https://github.com/FroVolod/near-cli/releases/) the archive file suitable for your operating system installed on the computer and unzip it.  
The resulting directory contains the executable file _near-cli_, which is accompanied by detailed [user guide](GUIDE.en.md).

### Building

near-cli is written in Rust, so you'll need to grab a
[Rust installation](https://www.rust-lang.org/) in order to compile it.
near-cli compiles with Rust 1.61.0 (stable) or newer. In general, near-cli tracks the latest stable release of the Rust compiler.

To build near-cli:

```txt
$ git clone https://github.com/FroVolod/near-cli
$ cd near-cli
$ cargo build --release
$ ./target/release/near-cli --version
near-cli 0.1.0
```

'''
'''--- docs/README.ru.md ---
near-cli
--------
near-cli – это утилита командной строки для работы с блокчейном Near Protocol.

## README.md

* en [English](README.en.md)

## Оглавление

* [Применение](#применение)
* [Инструкция](#инструкция)
* [Установка](#установка)
* [Сборка](#сборка)

## Применение

Вцелом новичку трудно сразу разобраться как устроены команды.  
Например, для осуществления перевода токенов необходимо набрать в терминале такую команду:

```txt
./near-cli tokens \
    'volodymyr.testnet' \
    send-near \
    'fro_volod.testnet' \
    '1 NEAR' \
    network testnet \
    sign-with-keychain \
    send
```

Это полная команда. Результат ее работы будет такой:

```txt
Successful transaction
<volodymyr.testnet> has transferred 1 NEAR to <fro_volod.testnet> successfully.
Transaction ID: G4t6Sgz2FjnNpruYjPP1ZJAKfRmBffVaqmj8Nup2TaAg
To see the transaction in the transaction explorer, please open this url in your browser:
https://explorer.testnet.near.org/transactions/G4t6Sgz2FjnNpruYjPP1ZJAKfRmBffVaqmj8Nup2TaAg
```

Набирая эту или другую команду вручную, Вы можете допустить ошибку, либо забыть последовательность набора команды.  
Не проблема, `--help` подскажет как правильно выстроить команду.  
Однако, используя near-cli, Вы __в любом месте набора команды__ можете нажать Enter и интерактивный режим программы продолжит работу по составлению команды с того места, где Вы закончили вводить необходимые параметры.

<details><summary><i>Демонстрация работы утилиты с частично набранной командой</i></summary>
<a href="https://asciinema.org/a/AfxLN1QtJi1z1qXuowTj2nDw2?autoplay=1&t=1&speed=2">
    <img src="https://asciinema.org/a/AfxLN1QtJi1z1qXuowTj2nDw2.png" width="836"/>
</a>
</details>

## Инструкция

Подробная инструкция доступна в файле [GUIDE.ru.md](GUIDE.ru.md).

## Установка

На данном этапе разработки утилиты установка программы не требуется.  
Достаточно [загрузить](https://github.com/FroVolod/near-cli/releases/) архивный файл, подходящий к Вашей операциой системе, установленной на компьютере, и разархивировать его.  
В полученном каталоге находится исполняемый файл _near-cli_, к которому прилагается [подробная инструкция для пользователя](GUIDE.ru.md).

## Сборка

near-cli написан на Rust. Поэтому необходимо
[установить Rust](https://www.rust-lang.org/) для компиляции программы.
near-cli компилируется на версии Rust 1.61.0 (stable) или новее.

Сборка near-cli:

```txt
$ git clone https://github.com/FroVolod/near-cli
$ cd near-cli
$ cargo build --release
$ ./target/release/near-cli --version
near-cli 0.1.0
```

'''
'''--- docs/media/view-account.svg ---
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="2180" height="906.69"><rect width="2180" height="906.69" rx="5" ry="5" class="a"/><svg y="0%" x="0%"><circle cx="20" cy="20" r="6" fill="#ff5f58"/><circle cx="40" cy="20" r="6" fill="#ffbd2e"/><circle cx="60" cy="20" r="6" fill="#18c132"/></svg><svg height="846.69" viewBox="0 0 214 84.669" width="2140" x="15" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" y="50"><style>@keyframes n{0%{transform:translateX(0)}.04%{transform:translateX(-214px)}.05%{transform:translateX(-428px)}5.47%{transform:translateX(-642px)}5.84%{transform:translateX(-856px)}11.32%{transform:translateX(-1070px)}12.08%{transform:translateX(-1284px)}16.69%{transform:translateX(-1498px)}16.73%{transform:translateX(-1712px)}16.74%{transform:translateX(-1926px)}23.39%{transform:translateX(-2354px)}31.68%{transform:translateX(-2782px)}38.19%{transform:translateX(-3424px)}45.76%{transform:translateX(-3638px)}46.62%{transform:translateX(-3852px)}47.48%{transform:translateX(-4066px)}48.38%{transform:translateX(-4280px)}50.51%{transform:translateX(-4494px)}52.44%{transform:translateX(-4708px)}54.47%{transform:translateX(-4922px)}56.81%{transform:translateX(-5136px)}57.54%{transform:translateX(-5350px)}60.67%{transform:translateX(-5564px)}62.91%{transform:translateX(-5778px)}63.6%{transform:translateX(-5992px)}64.91%{transform:translateX(-6206px)}65.63%{transform:translateX(-6420px)}67.63%{transform:translateX(-6634px)}69.28%{transform:translateX(-6848px)}70%{transform:translateX(-7062px)}74%{transform:translateX(-7704px)}83.92%{transform:translateX(-8132px)}85.29%{transform:translateX(-8346px)}89.15%{transform:translateX(-8774px)}89.7%{transform:translateX(-8988px)}90.23%{transform:translateX(-9202px)}90.25%{transform:translateX(-9416px)}to{transform:translateX(-9630px)}}.a{fill:#282d35}.f{fill:#b9c0cb;white-space:pre}.g{fill:#dbab79}.g,.h,.i,.j,.k{white-space:pre}.h{fill:#b9c0cb;font-weight:700}.i,.j,.k{fill:#6f7783}.j,.k{fill:#a8cc8c}.k{fill:#66c2cd}</style><g font-family="Monaco,Consolas,Menlo,'Bitstream Vera Sans Mono','Powerline Symbols',monospace" font-size="1.67"><defs><symbol id="1"><text y="1.67" class="f">The</text><text x="4.008" y="1.67" class="f">default</text><text x="12.024" y="1.67" class="f">interactive</text><text x="24.048" y="1.67" class="f">shell</text><text x="30.06" y="1.67" class="f">is</text><text x="33.066" y="1.67" class="f">now</text><text x="37.074" y="1.67" class="f">zsh.</text></symbol><symbol id="2"><text y="1.67" class="f">To</text><text x="3.006" y="1.67" class="f">update</text><text x="10.02" y="1.67" class="f">your</text><text x="15.03" y="1.67" class="f">account</text><text x="23.046" y="1.67" class="f">to</text><text x="26.052" y="1.67" class="f">use</text><text x="30.06" y="1.67" class="f">zsh,</text><text x="35.07" y="1.67" class="f">please</text><text x="42.084" y="1.67" class="f">run</text><text x="46.092" y="1.67" class="f">`chsh</text><text x="52.104" y="1.67" class="f">-s</text><text x="55.11" y="1.67" class="f">/bin/zsh`.</text></symbol><symbol id="3"><text y="1.67" class="f">For</text><text x="4.008" y="1.67" class="f">more</text><text x="9.018" y="1.67" class="f">details,</text><text x="18.036" y="1.67" class="f">please</text><text x="25.05" y="1.67" class="f">visit</text><text x="31.062" y="1.67" class="f">https://support.apple.com/kb/HT208050.</text></symbol><symbol id="4"><text y="1.67" class="f">bash-3.2$</text></symbol><symbol id="5"><text y="1.67" class="f">bash-3.2$</text><text x="10.02" y="1.67" class="f">./near-cli</text></symbol><symbol id="6"><text y="1.67" class="g">?</text><text x="2.004" y="1.67" class="h">Choose</text><text x="9.018" y="1.67" class="h">your</text><text x="14.028" y="1.67" class="h">action</text><text x="21.042" y="1.67" class="i">›</text></symbol><symbol id="7"><text y="1.67" class="j">✔</text><text x="2.004" y="1.67" class="h">Choose</text><text x="9.018" y="1.67" class="h">your</text><text x="14.028" y="1.67" class="h">action</text><text x="21.042" y="1.67" class="i">·</text><text x="23.046" y="1.67" class="j">View</text><text x="28.056" y="1.67" class="j">account,</text><text x="37.074" y="1.67" class="j">contract</text><text x="46.092" y="1.67" class="j">code,</text><text x="52.104" y="1.67" class="j">contract</text><text x="61.122" y="1.67" class="j">state,</text><text x="68.136" y="1.67" class="j">transaction</text></symbol><symbol id="8"><text y="1.67" class="j">✔</text><text x="2.004" y="1.67" class="h">Сhoose</text><text x="9.018" y="1.67" class="h">what</text><text x="14.028" y="1.67" class="h">you</text><text x="18.036" y="1.67" class="h">want</text><text x="23.046" y="1.67" class="h">to</text><text x="26.052" y="1.67" class="h">view</text><text x="31.062" y="1.67" class="i">·</text><text x="33.066" y="1.67" class="j">View</text><text x="38.076" y="1.67" class="j">properties</text><text x="49.098" y="1.67" class="j">for</text><text x="53.106" y="1.67" class="j">an</text><text x="56.112" y="1.67" class="j">account</text></symbol><symbol id="9"><text y="1.67" class="j">✔</text><text x="2.004" y="1.67" class="h">Select</text><text x="9.018" y="1.67" class="h">NEAR</text><text x="14.028" y="1.67" class="h">protocol</text><text x="23.046" y="1.67" class="h">RPC</text><text x="27.054" y="1.67" class="h">server:</text><text x="35.07" y="1.67" class="i">·</text><text x="37.074" y="1.67" class="j">Testnet</text></symbol><symbol id="10"><text y="1.67" class="f">What</text><text x="5.01" y="1.67" class="f">Account</text><text x="13.026" y="1.67" class="f">ID</text><text x="16.032" y="1.67" class="f">do</text><text x="19.038" y="1.67" class="f">you</text><text x="23.046" y="1.67" class="f">need</text><text x="28.056" y="1.67" class="f">to</text><text x="31.062" y="1.67" class="f">view?:</text><text x="38.076" y="1.67" class="f">volodymyr.testnet</text></symbol><symbol id="11"><text y="1.67" class="j">❯</text><text x="2.004" y="1.67" class="k">View</text><text x="7.014" y="1.67" class="k">this</text><text x="12.024" y="1.67" class="k">account</text><text x="20.04" y="1.67" class="k">at</text><text x="23.046" y="1.67" class="k">final</text><text x="29.058" y="1.67" class="k">block</text></symbol><symbol id="12"><text x="2.004" y="1.67" class="f">View</text><text x="7.014" y="1.67" class="f">this</text><text x="12.024" y="1.67" class="f">account</text><text x="20.04" y="1.67" class="f">at</text><text x="23.046" y="1.67" class="f">block</text><text x="29.058" y="1.67" class="f">heigt</text></symbol><symbol id="13"><text x="2.004" y="1.67" class="f">View</text><text x="7.014" y="1.67" class="f">this</text><text x="12.024" y="1.67" class="f">account</text><text x="20.04" y="1.67" class="f">at</text><text x="23.046" y="1.67" class="f">block</text><text x="29.058" y="1.67" class="f">hash</text></symbol><symbol id="14"><text x="2.004" y="1.67" class="f">View</text><text x="7.014" y="1.67" class="f">this</text><text x="12.024" y="1.67" class="f">account</text><text x="20.04" y="1.67" class="f">at</text><text x="23.046" y="1.67" class="f">final</text><text x="29.058" y="1.67" class="f">block</text></symbol><symbol id="15"><text y="1.67" class="j">❯</text><text x="2.004" y="1.67" class="k">View</text><text x="7.014" y="1.67" class="k">this</text><text x="12.024" y="1.67" class="k">account</text><text x="20.04" y="1.67" class="k">at</text><text x="23.046" y="1.67" class="k">block</text><text x="29.058" y="1.67" class="k">heigt</text></symbol><symbol id="16"><text y="1.67" class="j">✔</text><text x="2.004" y="1.67" class="h">Choose</text><text x="9.018" y="1.67" class="h">your</text><text x="14.028" y="1.67" class="h">action</text><text x="21.042" y="1.67" class="i">·</text><text x="23.046" y="1.67" class="j">View</text><text x="28.056" y="1.67" class="j">this</text><text x="33.066" y="1.67" class="j">account</text><text x="41.082" y="1.67" class="j">at</text><text x="44.088" y="1.67" class="j">final</text><text x="50.1" y="1.67" class="j">block</text></symbol><symbol id="17"><text y="1.67" class="f">Account</text><text x="8.016" y="1.67" class="f">details</text><text x="16.032" y="1.67" class="f">for</text><text x="20.04" y="1.67" class="f">&apos;volodymyr.testnet&apos;</text><text x="40.08" y="1.67" class="f">at</text><text x="43.086" y="1.67" class="f">block</text><text x="49.098" y="1.67" class="f">#49788132</text><text x="59.118" y="1.67" class="f">(ApumAzJnz5bHnheUwtNNeiHW4nRJ8TZJgqQLBdns3c9d)</text></symbol><symbol id="18"><text y="1.67" class="f">Native</text><text x="7.014" y="1.67" class="f">account</text><text x="15.03" y="1.67" class="f">balance:</text><text x="24.048" y="1.67" class="f">256.718</text><text x="32.064" y="1.67" class="f">NEAR</text></symbol><symbol id="19"><text y="1.67" class="f">Validator</text><text x="10.02" y="1.67" class="f">stake:</text><text x="17.034" y="1.67" class="f">0</text><text x="19.038" y="1.67" class="f">NEAR</text></symbol><symbol id="20"><text y="1.67" class="f">Storage</text><text x="8.016" y="1.67" class="f">used</text><text x="13.026" y="1.67" class="f">by</text><text x="16.032" y="1.67" class="f">the</text><text x="20.04" y="1.67" class="f">account:</text><text x="29.058" y="1.67" class="f">115385</text><text x="36.072" y="1.67" class="f">bytes</text></symbol><symbol id="21"><text y="1.67" class="f">Contract</text><text x="9.018" y="1.67" class="f">code</text><text x="14.028" y="1.67" class="f">SHA-256</text><text x="22.044" y="1.67" class="f">checksum</text><text x="31.062" y="1.67" class="f">(hex):</text><text x="38.076" y="1.67" class="f">4de7df8ee6ff3780cfed298ceafde26e7477041ca8e2af7ae8c749de7068c0f2</text></symbol><symbol id="22"><text y="1.67" class="f">Number</text><text x="7.014" y="1.67" class="f">of</text><text x="10.02" y="1.67" class="f">access</text><text x="17.034" y="1.67" class="f">keys:</text><text x="23.046" y="1.67" class="f">7</text></symbol><symbol id="23"><text x="3.006" y="1.67" class="f">1.</text><text x="6.012" y="1.67" class="f">ed25519:2KZwhWEM5hbtP28kpx9TER3zyz9rL3Az1fcHsgr2Fzd1</text><text x="59.118" y="1.67" class="f">(nonce:</text><text x="67.134" y="1.67" class="f">9)</text><text x="70.14" y="1.67" class="f">is</text><text x="73.146" y="1.67" class="f">granted</text><text x="81.162" y="1.67" class="f">to</text><text x="84.168" y="1.67" class="f">full</text><text x="89.178" y="1.67" class="f">access</text></symbol><symbol id="24"><text x="3.006" y="1.67" class="f">2.</text><text x="6.012" y="1.67" class="f">ed25519:36u45LFDfgKQYr8ApgBi1kUHN5FpkTQRqvt66cwEdqiK</text><text x="59.118" y="1.67" class="f">(nonce:</text><text x="67.134" y="1.67" class="f">0)</text><text x="70.14" y="1.67" class="f">is</text><text x="73.146" y="1.67" class="f">granted</text><text x="81.162" y="1.67" class="f">to</text><text x="84.168" y="1.67" class="f">full</text><text x="89.178" y="1.67" class="f">access</text></symbol><symbol id="25"><text x="3.006" y="1.67" class="f">3.</text><text x="6.012" y="1.67" class="f">ed25519:7FmDRADa1v4BcLiiR9MPPdmWQp3Um1iPdAYATvBY1YzS</text><text x="59.118" y="1.67" class="f">(nonce:</text><text x="67.134" y="1.67" class="f">168)</text><text x="72.144" y="1.67" class="f">is</text><text x="75.15" y="1.67" class="f">granted</text><text x="83.166" y="1.67" class="f">to</text><text x="86.172" y="1.67" class="f">full</text><text x="91.182" y="1.67" class="f">access</text></symbol><symbol id="26"><text x="3.006" y="1.67" class="f">4.</text><text x="6.012" y="1.67" class="f">ed25519:8b6ghV9BLNNB7RwaxSxjbH636bfM9m6NL7bmLBSXPqK8</text><text x="59.118" y="1.67" class="f">(nonce:</text><text x="67.134" y="1.67" class="f">2)</text><text x="70.14" y="1.67" class="f">is</text><text x="73.146" y="1.67" class="f">granted</text><text x="81.162" y="1.67" class="f">to</text><text x="84.168" y="1.67" class="f">full</text><text x="89.178" y="1.67" class="f">access</text></symbol><symbol id="27"><text x="3.006" y="1.67" class="f">5.</text><text x="6.012" y="1.67" class="f">ed25519:937VyVwszEH13quNuPM4nNQTrDssNzRNnLMjPbN92tgu</text><text x="59.118" y="1.67" class="f">(nonce:</text><text x="67.134" y="1.67" class="f">3)</text><text x="70.14" y="1.67" class="f">is</text><text x="73.146" y="1.67" class="f">granted</text><text x="81.162" y="1.67" class="f">to</text><text x="84.168" y="1.67" class="f">full</text><text x="89.178" y="1.67" class="f">access</text></symbol><symbol id="28"><text x="3.006" y="1.67" class="f">6.</text><text x="6.012" y="1.67" class="f">ed25519:ApWodksvd7grTjFFimCroLxvrVDi7WD6g6gDE7RuhoGH</text><text x="59.118" y="1.67" class="f">(nonce:</text><text x="67.134" y="1.67" class="f">1)</text><text x="70.14" y="1.67" class="f">is</text><text x="73.146" y="1.67" class="f">granted</text><text x="81.162" y="1.67" class="f">to</text><text x="84.168" y="1.67" class="f">full</text><text x="89.178" y="1.67" class="f">access</text></symbol><symbol id="29"><text x="3.006" y="1.67" class="f">7.</text><text x="6.012" y="1.67" class="f">ed25519:JC5R9H6wjthHeumnUePRjvJNJrRm6ZTFUoi1NYuj9DBZ</text><text x="59.118" y="1.67" class="f">(nonce:</text><text x="67.134" y="1.67" class="f">0)</text><text x="70.14" y="1.67" class="f">is</text><text x="73.146" y="1.67" class="f">granted</text><text x="81.162" y="1.67" class="f">to</text><text x="84.168" y="1.67" class="f">full</text><text x="89.178" y="1.67" class="f">access</text></symbol><symbol id="a"><path fill="transparent" d="M0 0h214v39H0z"/></symbol><symbol id="b"><path fill="#6f7683" d="M0 0h1.102v2.171H0z"/></symbol></defs><path class="a" d="M0 0h214v84.669H0z"/><g style="animation-duration:23.229185s;animation-iteration-count:infinite;animation-name:n;animation-timing-function:steps(1,end)"><svg width="9844"><svg><use xlink:href="#a"/><use xlink:href="#b" x="-.004"/></svg><svg x="214"><use xlink:href="#a"/><use xlink:href="#b" x="-.004" y="8.659"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/></svg><svg x="428"><use xlink:href="#a"/><use xlink:href="#b" x="9.996" y="8.659"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#4" y="8.684"/></svg><svg x="642"><use xlink:href="#a"/><use xlink:href="#b" x="10.996" y="8.659"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><text y="10.354" class="f">bash-3.2$</text><text x="10.02" y="10.354" class="f">.</text></svg><svg x="856"><use xlink:href="#a"/><use xlink:href="#b" x="11.996" y="8.659"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><text y="10.354" class="f">bash-3.2$</text><text x="10.02" y="10.354" class="f">./</text></svg><svg x="1070"><use xlink:href="#a"/><use xlink:href="#b" x="12.996" y="8.659"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><text y="10.354" class="f">bash-3.2$</text><text x="10.02" y="10.354" class="f">./n</text></svg><svg x="1284"><use xlink:href="#a"/><use xlink:href="#b" x="20.996" y="8.659"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/></svg><svg x="1498"><use xlink:href="#a"/><use xlink:href="#b" x="-.004" y="10.83"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/></svg><svg x="1712"><use xlink:href="#a"/><use xlink:href="#b" x="-.004" y="13.001"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/></svg><svg x="1926"><use xlink:href="#a"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#6" y="13.026"/><text y="16.867" class="j">❯</text><text x="2.004" y="16.867" class="k">View</text><text x="7.014" y="16.867" class="k">account,</text><text x="16.032" y="16.867" class="k">contract</text><text x="25.05" y="16.867" class="k">code,</text><text x="31.062" y="16.867" class="k">contract</text><text x="40.08" y="16.867" class="k">state,</text><text x="47.094" y="16.867" class="k">transaction</text><text x="2.004" y="19.038" class="f">Transfer</text><text x="11.022" y="19.038" class="f">tokens</text><text x="2.004" y="21.209" class="f">Execute</text><text x="10.02" y="21.209" class="f">function</text><text x="19.038" y="21.209" class="f">(contract</text><text x="29.058" y="21.209" class="f">method)</text><text x="2.004" y="23.38" class="f">Add</text><text x="6.012" y="23.38" class="f">access</text><text x="13.026" y="23.38" class="f">key,</text><text x="18.036" y="23.38" class="f">contract</text><text x="27.054" y="23.38" class="f">code,</text><text x="33.066" y="23.38" class="f">stake</text><text x="39.078" y="23.38" class="f">proposal,</text><text x="49.098" y="23.38" class="f">sub-account,</text><text x="62.124" y="23.38" class="f">implicit-account</text><text x="2.004" y="25.551" class="f">Delete</text><text x="9.018" y="25.551" class="f">access</text><text x="16.032" y="25.551" class="f">key,</text><text x="21.042" y="25.551" class="f">account</text><text x="2.004" y="27.722" class="f">Construct</text><text x="12.024" y="27.722" class="f">a</text><text x="14.028" y="27.722" class="f">new</text><text x="18.036" y="27.722" class="f">transaction</text><text x="2.004" y="29.893" class="f">Helpers</text></svg><svg x="2140"><use xlink:href="#a"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/></svg><svg x="2354"><use xlink:href="#a"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><text y="19.038" class="g">?</text><text x="2.004" y="19.038" class="h">Сhoose</text><text x="9.018" y="19.038" class="h">what</text><text x="14.028" y="19.038" class="h">you</text><text x="18.036" y="19.038" class="h">want</text><text x="23.046" y="19.038" class="h">to</text><text x="26.052" y="19.038" class="h">view</text><text x="31.062" y="19.038" class="i">›</text><text y="21.209" class="j">❯</text><text x="2.004" y="21.209" class="k">View</text><text x="7.014" y="21.209" class="k">properties</text><text x="18.036" y="21.209" class="k">for</text><text x="22.044" y="21.209" class="k">an</text><text x="25.05" y="21.209" class="k">account</text><text x="2.004" y="23.38" class="f">View</text><text x="7.014" y="23.38" class="f">a</text><text x="9.018" y="23.38" class="f">contract</text><text x="18.036" y="23.38" class="f">code</text><text x="2.004" y="25.551" class="f">View</text><text x="7.014" y="25.551" class="f">a</text><text x="9.018" y="25.551" class="f">contract</text><text x="18.036" y="25.551" class="f">state</text><text x="2.004" y="27.722" class="f">View</text><text x="7.014" y="27.722" class="f">a</text><text x="9.018" y="27.722" class="f">transaction</text><text x="21.042" y="27.722" class="f">status</text></svg><svg x="2568"><use xlink:href="#a"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/></svg><svg x="2782"><use xlink:href="#a"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><text y="23.38" class="g">?</text><text x="2.004" y="23.38" class="h">Select</text><text x="9.018" y="23.38" class="h">NEAR</text><text x="14.028" y="23.38" class="h">protocol</text><text x="23.046" y="23.38" class="h">RPC</text><text x="27.054" y="23.38" class="h">server:</text><text x="35.07" y="23.38" class="i">›</text><text y="25.551" class="j">❯</text><text x="2.004" y="25.551" class="k">Testnet</text><text x="2.004" y="27.722" class="f">Mainnet</text><text x="2.004" y="29.893" class="f">Betanet</text><text x="2.004" y="32.064" class="f">Custom</text></svg><svg x="2996"><use xlink:href="#a"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/></svg><svg x="3210"><use xlink:href="#a"/><use xlink:href="#b" x="-.004" y="23.856"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/></svg><svg x="3424"><use xlink:href="#a"/><use xlink:href="#b" x="37.996" y="26.027"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><text y="27.722" class="f">What</text><text x="5.01" y="27.722" class="f">Account</text><text x="13.026" y="27.722" class="f">ID</text><text x="16.032" y="27.722" class="f">do</text><text x="19.038" y="27.722" class="f">you</text><text x="23.046" y="27.722" class="f">need</text><text x="28.056" y="27.722" class="f">to</text><text x="31.062" y="27.722" class="f">view?:</text></svg><svg x="3638"><use xlink:href="#a"/><use xlink:href="#b" x="38.996" y="26.027"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><text y="27.722" class="f">What</text><text x="5.01" y="27.722" class="f">Account</text><text x="13.026" y="27.722" class="f">ID</text><text x="16.032" y="27.722" class="f">do</text><text x="19.038" y="27.722" class="f">you</text><text x="23.046" y="27.722" class="f">need</text><text x="28.056" y="27.722" class="f">to</text><text x="31.062" y="27.722" class="f">view?:</text><text x="38.076" y="27.722" class="f">v</text></svg><svg x="3852"><use xlink:href="#a"/><use xlink:href="#b" x="39.996" y="26.027"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><text y="27.722" class="f">What</text><text x="5.01" y="27.722" class="f">Account</text><text x="13.026" y="27.722" class="f">ID</text><text x="16.032" y="27.722" class="f">do</text><text x="19.038" y="27.722" class="f">you</text><text x="23.046" y="27.722" class="f">need</text><text x="28.056" y="27.722" class="f">to</text><text x="31.062" y="27.722" class="f">view?:</text><text x="38.076" y="27.722" class="f">vo</text></svg><svg x="4066"><use xlink:href="#a"/><use xlink:href="#b" x="40.996" y="26.027"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><text y="27.722" class="f">What</text><text x="5.01" y="27.722" class="f">Account</text><text x="13.026" y="27.722" class="f">ID</text><text x="16.032" y="27.722" class="f">do</text><text x="19.038" y="27.722" class="f">you</text><text x="23.046" y="27.722" class="f">need</text><text x="28.056" y="27.722" class="f">to</text><text x="31.062" y="27.722" class="f">view?:</text><text x="38.076" y="27.722" class="f">vol</text></svg><svg x="4280"><use xlink:href="#a"/><use xlink:href="#b" x="41.996" y="26.027"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><text y="27.722" class="f">What</text><text x="5.01" y="27.722" class="f">Account</text><text x="13.026" y="27.722" class="f">ID</text><text x="16.032" y="27.722" class="f">do</text><text x="19.038" y="27.722" class="f">you</text><text x="23.046" y="27.722" class="f">need</text><text x="28.056" y="27.722" class="f">to</text><text x="31.062" y="27.722" class="f">view?:</text><text x="38.076" y="27.722" class="f">volo</text></svg><svg x="4494"><use xlink:href="#a"/><use xlink:href="#b" x="42.996" y="26.027"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><text y="27.722" class="f">What</text><text x="5.01" y="27.722" class="f">Account</text><text x="13.026" y="27.722" class="f">ID</text><text x="16.032" y="27.722" class="f">do</text><text x="19.038" y="27.722" class="f">you</text><text x="23.046" y="27.722" class="f">need</text><text x="28.056" y="27.722" class="f">to</text><text x="31.062" y="27.722" class="f">view?:</text><text x="38.076" y="27.722" class="f">volod</text></svg><svg x="4708"><use xlink:href="#a"/><use xlink:href="#b" x="43.996" y="26.027"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><text y="27.722" class="f">What</text><text x="5.01" y="27.722" class="f">Account</text><text x="13.026" y="27.722" class="f">ID</text><text x="16.032" y="27.722" class="f">do</text><text x="19.038" y="27.722" class="f">you</text><text x="23.046" y="27.722" class="f">need</text><text x="28.056" y="27.722" class="f">to</text><text x="31.062" y="27.722" class="f">view?:</text><text x="38.076" y="27.722" class="f">volody</text></svg><svg x="4922"><use xlink:href="#a"/><use xlink:href="#b" x="44.996" y="26.027"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><text y="27.722" class="f">What</text><text x="5.01" y="27.722" class="f">Account</text><text x="13.026" y="27.722" class="f">ID</text><text x="16.032" y="27.722" class="f">do</text><text x="19.038" y="27.722" class="f">you</text><text x="23.046" y="27.722" class="f">need</text><text x="28.056" y="27.722" class="f">to</text><text x="31.062" y="27.722" class="f">view?:</text><text x="38.076" y="27.722" class="f">volodym</text></svg><svg x="5136"><use xlink:href="#a"/><use xlink:href="#b" x="45.996" y="26.027"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><text y="27.722" class="f">What</text><text x="5.01" y="27.722" class="f">Account</text><text x="13.026" y="27.722" class="f">ID</text><text x="16.032" y="27.722" class="f">do</text><text x="19.038" y="27.722" class="f">you</text><text x="23.046" y="27.722" class="f">need</text><text x="28.056" y="27.722" class="f">to</text><text x="31.062" y="27.722" class="f">view?:</text><text x="38.076" y="27.722" class="f">volodymy</text></svg><svg x="5350"><use xlink:href="#a"/><use xlink:href="#b" x="46.996" y="26.027"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><text y="27.722" class="f">What</text><text x="5.01" y="27.722" class="f">Account</text><text x="13.026" y="27.722" class="f">ID</text><text x="16.032" y="27.722" class="f">do</text><text x="19.038" y="27.722" class="f">you</text><text x="23.046" y="27.722" class="f">need</text><text x="28.056" y="27.722" class="f">to</text><text x="31.062" y="27.722" class="f">view?:</text><text x="38.076" y="27.722" class="f">volodymyr</text></svg><svg x="5564"><use xlink:href="#a"/><use xlink:href="#b" x="47.996" y="26.027"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><text y="27.722" class="f">What</text><text x="5.01" y="27.722" class="f">Account</text><text x="13.026" y="27.722" class="f">ID</text><text x="16.032" y="27.722" class="f">do</text><text x="19.038" y="27.722" class="f">you</text><text x="23.046" y="27.722" class="f">need</text><text x="28.056" y="27.722" class="f">to</text><text x="31.062" y="27.722" class="f">view?:</text><text x="38.076" y="27.722" class="f">volodymyr.</text></svg><svg x="5778"><use xlink:href="#a"/><use xlink:href="#b" x="48.996" y="26.027"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><text y="27.722" class="f">What</text><text x="5.01" y="27.722" class="f">Account</text><text x="13.026" y="27.722" class="f">ID</text><text x="16.032" y="27.722" class="f">do</text><text x="19.038" y="27.722" class="f">you</text><text x="23.046" y="27.722" class="f">need</text><text x="28.056" y="27.722" class="f">to</text><text x="31.062" y="27.722" class="f">view?:</text><text x="38.076" y="27.722" class="f">volodymyr.t</text></svg><svg x="5992"><use xlink:href="#a"/><use xlink:href="#b" x="49.996" y="26.027"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><text y="27.722" class="f">What</text><text x="5.01" y="27.722" class="f">Account</text><text x="13.026" y="27.722" class="f">ID</text><text x="16.032" y="27.722" class="f">do</text><text x="19.038" y="27.722" class="f">you</text><text x="23.046" y="27.722" class="f">need</text><text x="28.056" y="27.722" class="f">to</text><text x="31.062" y="27.722" class="f">view?:</text><text x="38.076" y="27.722" class="f">volodymyr.te</text></svg><svg x="6206"><use xlink:href="#a"/><use xlink:href="#b" x="50.996" y="26.027"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><text y="27.722" class="f">What</text><text x="5.01" y="27.722" class="f">Account</text><text x="13.026" y="27.722" class="f">ID</text><text x="16.032" y="27.722" class="f">do</text><text x="19.038" y="27.722" class="f">you</text><text x="23.046" y="27.722" class="f">need</text><text x="28.056" y="27.722" class="f">to</text><text x="31.062" y="27.722" class="f">view?:</text><text x="38.076" y="27.722" class="f">volodymyr.tes</text></svg><svg x="6420"><use xlink:href="#a"/><use xlink:href="#b" x="51.996" y="26.027"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><text y="27.722" class="f">What</text><text x="5.01" y="27.722" class="f">Account</text><text x="13.026" y="27.722" class="f">ID</text><text x="16.032" y="27.722" class="f">do</text><text x="19.038" y="27.722" class="f">you</text><text x="23.046" y="27.722" class="f">need</text><text x="28.056" y="27.722" class="f">to</text><text x="31.062" y="27.722" class="f">view?:</text><text x="38.076" y="27.722" class="f">volodymyr.test</text></svg><svg x="6634"><use xlink:href="#a"/><use xlink:href="#b" x="52.996" y="26.027"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><text y="27.722" class="f">What</text><text x="5.01" y="27.722" class="f">Account</text><text x="13.026" y="27.722" class="f">ID</text><text x="16.032" y="27.722" class="f">do</text><text x="19.038" y="27.722" class="f">you</text><text x="23.046" y="27.722" class="f">need</text><text x="28.056" y="27.722" class="f">to</text><text x="31.062" y="27.722" class="f">view?:</text><text x="38.076" y="27.722" class="f">volodymyr.testn</text></svg><svg x="6848"><use xlink:href="#a"/><use xlink:href="#b" x="53.996" y="26.027"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><text y="27.722" class="f">What</text><text x="5.01" y="27.722" class="f">Account</text><text x="13.026" y="27.722" class="f">ID</text><text x="16.032" y="27.722" class="f">do</text><text x="19.038" y="27.722" class="f">you</text><text x="23.046" y="27.722" class="f">need</text><text x="28.056" y="27.722" class="f">to</text><text x="31.062" y="27.722" class="f">view?:</text><text x="38.076" y="27.722" class="f">volodymyr.testne</text></svg><svg x="7062"><use xlink:href="#a"/><use xlink:href="#b" x="54.996" y="26.027"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><use xlink:href="#10" y="26.052"/></svg><svg x="7276"><use xlink:href="#a"/><use xlink:href="#b" x="-.004" y="28.198"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><use xlink:href="#10" y="26.052"/></svg><svg x="7490"><use xlink:href="#a"/><use xlink:href="#b" x="-.004" y="30.369"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><use xlink:href="#10" y="26.052"/></svg><svg x="7704"><use xlink:href="#a"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><use xlink:href="#10" y="26.052"/><use xlink:href="#6" y="30.394"/><use xlink:href="#11" y="32.565"/><use xlink:href="#12" y="34.736"/><use xlink:href="#13" y="36.907"/></svg><svg x="7918"><use xlink:href="#a"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><use xlink:href="#10" y="26.052"/><use xlink:href="#6" y="30.394"/><use xlink:href="#14" y="32.565"/><use xlink:href="#15" y="34.736"/><use xlink:href="#13" y="36.907"/></svg><svg x="8132"><use xlink:href="#a"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><use xlink:href="#10" y="26.052"/><use xlink:href="#6" y="30.394"/><use xlink:href="#14" y="32.565"/><use xlink:href="#15" y="34.736"/><use xlink:href="#13" y="36.907"/></svg><svg x="8346"><use xlink:href="#a"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><use xlink:href="#10" y="26.052"/><use xlink:href="#6" y="30.394"/><use xlink:href="#11" y="32.565"/><use xlink:href="#12" y="34.736"/><use xlink:href="#13" y="36.907"/></svg><svg x="8560"><use xlink:href="#a"/><use xlink:href="#b" x="-.004" y="32.54"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><use xlink:href="#10" y="26.052"/><use xlink:href="#16" y="30.394"/></svg><svg x="8774"><use xlink:href="#a"/><use xlink:href="#b" x="-.004" y="34.711"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><use xlink:href="#10" y="26.052"/><use xlink:href="#16" y="30.394"/></svg><svg x="8988"><use xlink:href="#a"/><use xlink:href="#b" x="-.004" y="45.566"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><use xlink:href="#10" y="26.052"/><use xlink:href="#16" y="30.394"/><use xlink:href="#17" y="34.736"/><use xlink:href="#18" y="36.907"/><use xlink:href="#19" y="39.078"/><use xlink:href="#20" y="41.249"/><use xlink:href="#21" y="43.42"/></svg><svg x="9202"><use xlink:href="#a"/><use xlink:href="#b" x="-.004" y="62.934"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><use xlink:href="#10" y="26.052"/><use xlink:href="#16" y="30.394"/><use xlink:href="#17" y="34.736"/><use xlink:href="#18" y="36.907"/><use xlink:href="#19" y="39.078"/><use xlink:href="#20" y="41.249"/><use xlink:href="#21" y="43.42"/><use xlink:href="#22" y="45.591"/><use xlink:href="#23" y="47.762"/><use xlink:href="#24" y="49.933"/><use xlink:href="#25" y="52.104"/><use xlink:href="#26" y="54.275"/><use xlink:href="#27" y="56.446"/><use xlink:href="#28" y="58.617"/><use xlink:href="#29" y="60.788"/></svg><svg x="9416"><use xlink:href="#a"/><use xlink:href="#b" x="9.996" y="62.934"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><use xlink:href="#10" y="26.052"/><use xlink:href="#16" y="30.394"/><use xlink:href="#17" y="34.736"/><use xlink:href="#18" y="36.907"/><use xlink:href="#19" y="39.078"/><use xlink:href="#20" y="41.249"/><use xlink:href="#21" y="43.42"/><use xlink:href="#22" y="45.591"/><use xlink:href="#23" y="47.762"/><use xlink:href="#24" y="49.933"/><use xlink:href="#25" y="52.104"/><use xlink:href="#26" y="54.275"/><use xlink:href="#27" y="56.446"/><use xlink:href="#28" y="58.617"/><use xlink:href="#29" y="60.788"/><use xlink:href="#4" y="62.959"/></svg><svg x="9630"><use xlink:href="#a"/><use xlink:href="#b" x="-.004" y="65.105"/><use xlink:href="#1" y="2.171"/><use xlink:href="#2" y="4.342"/><use xlink:href="#3" y="6.513"/><use xlink:href="#5" y="8.684"/><use xlink:href="#7" y="13.026"/><use xlink:href="#8" y="17.368"/><use xlink:href="#9" y="21.71"/><use xlink:href="#10" y="26.052"/><use xlink:href="#16" y="30.394"/><use xlink:href="#17" y="34.736"/><use xlink:href="#18" y="36.907"/><use xlink:href="#19" y="39.078"/><use xlink:href="#20" y="41.249"/><use xlink:href="#21" y="43.42"/><use xlink:href="#22" y="45.591"/><use xlink:href="#23" y="47.762"/><use xlink:href="#24" y="49.933"/><use xlink:href="#25" y="52.104"/><use xlink:href="#26" y="54.275"/><use xlink:href="#27" y="56.446"/><use xlink:href="#28" y="58.617"/><use xlink:href="#29" y="60.788"/><text y="64.629" class="f">bash-3.2$</text><text x="10.02" y="64.629" class="f">exit</text></svg></svg></g></g></svg></svg>
'''
'''--- src/commands/account/add_key/access_key_type/mod.rs ---
use std::str::FromStr;

use dialoguer::{console::Term, theme::ColorfulTheme, Input, Select};

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct FullAccessType {
    #[interactive_clap(subcommand)]
    pub access_key_mode: super::AccessKeyMode,
}

impl FullAccessType {
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        self.access_key_mode
            .process(
                config,
                prepopulated_unsigned_transaction,
                near_primitives::account::AccessKeyPermission::FullAccess,
            )
            .await
    }
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[interactive_clap(skip_default_from_cli)]
pub struct FunctionCallType {
    #[interactive_clap(long)]
    #[interactive_clap(skip_default_from_cli_arg)]
    #[interactive_clap(skip_default_input_arg)]
    allowance: Option<crate::common::NearBalance>,
    #[interactive_clap(long)]
    ///Enter a receiver to use by this access key to pay for function call gas and transaction fees.
    receiver_account_id: crate::types::account_id::AccountId,
    #[interactive_clap(long)]
    #[interactive_clap(skip_default_from_cli_arg)]
    #[interactive_clap(skip_default_input_arg)]
    method_names: crate::types::vec_string::VecString,
    #[interactive_clap(subcommand)]
    access_key_mode: super::AccessKeyMode,
}

impl FunctionCallType {
    pub fn from_cli(
        optional_clap_variant: Option<<FunctionCallType as interactive_clap::ToCli>::CliVariant>,
        context: crate::GlobalContext,
    ) -> color_eyre::eyre::Result<Option<Self>> {
        let allowance: Option<crate::common::NearBalance> = match optional_clap_variant
            .clone()
            .and_then(|clap_variant| clap_variant.allowance)
        {
            Some(cli_allowance) => Some(cli_allowance),
            None => FunctionCallType::input_allowance()?,
        };
        let receiver_account_id = match optional_clap_variant
            .clone()
            .and_then(|clap_variant| clap_variant.receiver_account_id)
        {
            Some(cli_receiver_account_id) => cli_receiver_account_id,
            None => Self::input_receiver_account_id(&context)?,
        };
        let method_names: crate::types::vec_string::VecString = match optional_clap_variant
            .clone()
            .and_then(|clap_variant| clap_variant.method_names)
        {
            Some(cli_method_names) => {
                if cli_method_names.0.is_empty() {
                    crate::types::vec_string::VecString(vec![])
                } else {
                    cli_method_names
                }
            }
            None => FunctionCallType::input_method_names()?,
        };
        let optional_access_key_mode =
            match optional_clap_variant.and_then(|clap_variant| clap_variant.access_key_mode) {
                Some(cli_access_key_mode) => {
                    super::AccessKeyMode::from_cli(Some(cli_access_key_mode), context)?
                }
                None => super::AccessKeyMode::choose_variant(context)?,
            };
        let access_key_mode = if let Some(access_key_mode) = optional_access_key_mode {
            access_key_mode
        } else {
            return Ok(None);
        };
        Ok(Some(Self {
            allowance,
            receiver_account_id,
            method_names,
            access_key_mode,
        }))
    }
}

impl FunctionCallType {
    pub fn input_method_names() -> color_eyre::eyre::Result<crate::types::vec_string::VecString> {
        println!();
        let choose_input = vec![
            "Yes, I want to input a list of method names that can be used",
            "No, I don't to input a list of method names that can be used",
        ];
        let select_choose_input = Select::with_theme(&ColorfulTheme::default())
            .with_prompt("Do You want to input a list of method names that can be used")
            .items(&choose_input)
            .default(0)
            .interact_on_opt(&Term::stderr())?;
        match select_choose_input {
            Some(0) => {
                let mut input_method_names: String = Input::new()
                    .with_prompt("Enter a comma-separated list of method names that will be allowed to be called in a transaction signed by this access key.")
                    .interact_text()
                    ?;
                if input_method_names.contains("\"") {
                    input_method_names.clear()
                };
                if input_method_names.is_empty() {
                    Ok(crate::types::vec_string::VecString(vec![]))
                } else {
                    crate::types::vec_string::VecString::from_str(&input_method_names)
                }
            }
            Some(1) => Ok(crate::types::vec_string::VecString(vec![])),
            _ => unreachable!("Error"),
        }
    }

    pub fn input_allowance() -> color_eyre::eyre::Result<Option<crate::common::NearBalance>> {
        println!();
        let choose_input = vec![
            "Yes, I want to input allowance for receiver ID",
            "No, I don't to input allowance for receiver ID",
        ];
        let select_choose_input = Select::with_theme(&ColorfulTheme::default())
            .with_prompt("Do You want to input an allowance for receiver ID")
            .items(&choose_input)
            .default(0)
            .interact_on_opt(&Term::stderr())?;
        match select_choose_input {
            Some(0) => {
                let allowance_near_balance: crate::common::NearBalance = Input::new()
                    .with_prompt("Enter an allowance which is a balance limit to use by this access key to pay for function call gas and transaction fees. (example: 10NEAR or 0.5near or 10000yoctonear)")
                    .interact_text()
                    ?;
                Ok(Some(allowance_near_balance))
            }
            Some(1) => Ok(None),
            _ => unreachable!("Error"),
        }
    }

    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        let permission = near_primitives::account::AccessKeyPermission::FunctionCall(
            near_primitives::account::FunctionCallPermission {
                allowance: {
                    match self.allowance.clone() {
                        Some(allowance) => Some(allowance.to_yoctonear()),
                        None => None,
                    }
                },
                receiver_id: self.receiver_account_id.to_string().clone(),
                method_names: self.method_names.clone().into(),
            },
        );
        self.access_key_mode
            .process(config, prepopulated_unsigned_transaction, permission)
            .await
    }
}

'''
'''--- src/commands/account/add_key/autogenerate_new_keypair/mod.rs ---
use std::str::FromStr;
use strum::{EnumDiscriminants, EnumIter, EnumMessage};

mod print_keypair_to_terminal;
mod save_keypair_to_keychain;

#[derive(Debug, Clone, interactive_clap_derive::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct GenerateKeypair {
    #[interactive_clap(subcommand)]
    save_mode: SaveMode,
}

impl GenerateKeypair {
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
        permission: near_primitives::account::AccessKeyPermission,
    ) -> crate::CliResult {
        self.save_mode
            .process(config, prepopulated_unsigned_transaction, permission)
            .await
    }
}

#[derive(Debug, Clone, EnumDiscriminants, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///Save an access key for this account
pub enum SaveMode {
    #[strum_discriminants(strum(
        message = "save-to-keychain   - Save automatically generated key pair to keychain"
    ))]
    ///Save automatically generated key pair to keychain
    SaveToKeychain(self::save_keypair_to_keychain::SaveKeypairToKeychain),
    #[strum_discriminants(strum(
        message = "print-to-terminal  - Print automatically generated key pair in terminal"
    ))]
    ///Print automatically generated key pair in terminal
    PrintToTerminal(self::print_keypair_to_terminal::PrintKeypairToTerminal),
}

impl SaveMode {
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
        permission: near_primitives::account::AccessKeyPermission,
    ) -> crate::CliResult {
        let key_pair_properties: crate::common::KeyPairProperties =
            crate::common::generate_keypair().await?;
        let access_key: near_primitives::account::AccessKey = near_primitives::account::AccessKey {
            nonce: 0,
            permission,
        };
        let action = near_primitives::transaction::Action::AddKey(
            near_primitives::transaction::AddKeyAction {
                public_key: near_crypto::PublicKey::from_str(&key_pair_properties.public_key_str)?,
                access_key,
            },
        );
        let mut actions = prepopulated_unsigned_transaction.actions.clone();
        actions.push(action);
        let prepopulated_unsigned_transaction = near_primitives::transaction::Transaction {
            actions,
            ..prepopulated_unsigned_transaction
        };
        match self {
            SaveMode::SaveToKeychain(save_keypair_to_keychain) => {
                save_keypair_to_keychain
                    .process(
                        config,
                        key_pair_properties,
                        prepopulated_unsigned_transaction,
                    )
                    .await
            }
            SaveMode::PrintToTerminal(print_keypair_to_terminal) => {
                print_keypair_to_terminal
                    .process(
                        config,
                        key_pair_properties,
                        prepopulated_unsigned_transaction,
                    )
                    .await
            }
        }
    }
}

'''
'''--- src/commands/account/add_key/autogenerate_new_keypair/print_keypair_to_terminal/mod.rs ---
#[derive(Debug, Clone, interactive_clap_derive::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct PrintKeypairToTerminal {
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_for_transaction::NetworkForTransactionArgs,
}

impl PrintKeypairToTerminal {
    pub async fn process(
        &self,
        config: crate::config::Config,
        key_pair_properties: crate::common::KeyPairProperties,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        println!(
            "Master Seed Phrase: {}\nSeed Phrase HD Path: {}\nImplicit Account ID: {}\nPublic Key: {}\nSECRET KEYPAIR: {}",
            key_pair_properties.master_seed_phrase,
            key_pair_properties.seed_phrase_hd_path.to_string(),
            key_pair_properties.implicit_account_id,
            key_pair_properties.public_key_str,
            key_pair_properties.secret_keypair_str,
        );
        match self.network.get_sign_option() {
            crate::transaction_signature_options::SignWith::SignWithPlaintextPrivateKey(
                sign_private_key,
            ) => {
                sign_private_key
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
            crate::transaction_signature_options::SignWith::SignWithKeychain(sign_keychain) => {
                sign_keychain
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config.clone()),
                        config.credentials_home_dir,
                    )
                    .await
            }
            #[cfg(feature = "ledger")]
            crate::transaction_signature_options::SignWith::SignWithLedger(sign_ledger) => {
                sign_ledger
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
        }
    }
}

'''
'''--- src/commands/account/add_key/autogenerate_new_keypair/save_keypair_to_keychain/mod.rs ---
#[derive(Debug, Clone, interactive_clap_derive::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct SaveKeypairToKeychain {
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_for_transaction::NetworkForTransactionArgs,
}

impl SaveKeypairToKeychain {
    pub async fn process(
        &self,
        config: crate::config::Config,
        key_pair_properties: crate::common::KeyPairProperties,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        let network_config = self.network.get_network_config(config.clone());
        crate::common::save_access_key_to_keychain(
            network_config,
            config.credentials_home_dir.clone(),
            key_pair_properties,
            &prepopulated_unsigned_transaction.receiver_id.to_string(),
        )
        .await
        .map_err(|err| {
            color_eyre::Report::msg(format!("Failed to save a file with access key: {}", err))
        })?;
        match self.network.get_sign_option() {
            crate::transaction_signature_options::SignWith::SignWithPlaintextPrivateKey(
                sign_private_key,
            ) => {
                sign_private_key
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
            crate::transaction_signature_options::SignWith::SignWithKeychain(sign_keychain) => {
                sign_keychain
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config.clone()),
                        config.credentials_home_dir,
                    )
                    .await
            }
            #[cfg(feature = "ledger")]
            crate::transaction_signature_options::SignWith::SignWithLedger(sign_ledger) => {
                sign_ledger
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
        }
    }
}

'''
'''--- src/commands/account/add_key/mod.rs ---
use strum::{EnumDiscriminants, EnumIter, EnumMessage};

mod access_key_type;
mod autogenerate_new_keypair;
mod use_manually_provided_seed_phrase;
mod use_public_key;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct AddKeyCommand {
    ///Which account should You add an access key to?
    owner_account_id: crate::types::account_id::AccountId,
    #[interactive_clap(subcommand)]
    permission: AccessKeyPermission,
}

impl AddKeyCommand {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        let prepopulated_unsigned_transaction = near_primitives::transaction::Transaction {
            signer_id: self.owner_account_id.clone().into(),
            public_key: near_crypto::PublicKey::empty(near_crypto::KeyType::ED25519),
            nonce: 0,
            receiver_id: self.owner_account_id.clone().into(),
            block_hash: Default::default(),
            actions: vec![],
        };
        match self.permission.clone() {
            AccessKeyPermission::GrantFullAccess(full_access_type) => {
                full_access_type
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            AccessKeyPermission::GrantFunctionCallAccess(function_call_type) => {
                function_call_type
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
        }
    }
}

#[derive(Debug, Clone, EnumDiscriminants, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///Select a permission that you want to add to the access key
pub enum AccessKeyPermission {
    #[strum_discriminants(strum(
        message = "grant-full-access           - A permission with full access"
    ))]
    ///Provide data for a full access key
    GrantFullAccess(self::access_key_type::FullAccessType),
    #[strum_discriminants(strum(
        message = "grant-function-call-access  - A permission with function call"
    ))]
    ///Provide data for a function-call access key
    GrantFunctionCallAccess(self::access_key_type::FunctionCallType),
}

#[derive(Debug, Clone, EnumDiscriminants, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///Add an access key for this account
pub enum AccessKeyMode {
    #[strum_discriminants(strum(
        message = "autogenerate-new-keypair          - Automatically generate a key pair"
    ))]
    ///Automatically generate a key pair
    AutogenerateNewKeypair(self::autogenerate_new_keypair::GenerateKeypair),
    #[strum_discriminants(strum(
        message = "use-manually-provided-seed-prase  - Use the provided seed phrase manually"
    ))]
    ///Use the provided seed phrase manually
    UseManuallyProvidedSeedPhrase(
        self::use_manually_provided_seed_phrase::AddAccessWithSeedPhraseAction,
    ),
    #[strum_discriminants(strum(
        message = "use-manually-provided-public-key  - Use the provided public key manually"
    ))]
    ///Use the provided public key manually
    UseManuallyProvidedPublicKey(self::use_public_key::AddAccessKeyAction),
}

impl AccessKeyMode {
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
        permission: near_primitives::account::AccessKeyPermission,
    ) -> crate::CliResult {
        match self {
            AccessKeyMode::UseManuallyProvidedPublicKey(add_access_key_action) => {
                add_access_key_action
                    .process(config, prepopulated_unsigned_transaction, permission)
                    .await
            }
            AccessKeyMode::AutogenerateNewKeypair(generate_keypair) => {
                generate_keypair
                    .process(config, prepopulated_unsigned_transaction, permission)
                    .await
            }
            AccessKeyMode::UseManuallyProvidedSeedPhrase(add_access_with_seed_phrase_action) => {
                add_access_with_seed_phrase_action
                    .process(config, prepopulated_unsigned_transaction, permission)
                    .await
            }
        }
    }
}

'''
'''--- src/commands/account/add_key/use_manually_provided_seed_phrase/mod.rs ---
use std::str::FromStr;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct AddAccessWithSeedPhraseAction {
    ///Enter the seed-phrase for this sub-account
    master_seed_phrase: String,
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_for_transaction::NetworkForTransactionArgs,
}

impl AddAccessWithSeedPhraseAction {
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
        permission: near_primitives::account::AccessKeyPermission,
    ) -> crate::CliResult {
        let seed_phrase_hd_path_default = slip10::BIP32Path::from_str("m/44'/397'/0'").unwrap();
        let public_key = crate::common::get_public_key_from_seed_phrase(
            seed_phrase_hd_path_default,
            &self.master_seed_phrase,
        )?;
        let access_key = near_primitives::account::AccessKey {
            nonce: 0,
            permission,
        };
        let action = near_primitives::transaction::Action::AddKey(
            near_primitives::transaction::AddKeyAction {
                public_key,
                access_key,
            },
        );
        let mut actions = prepopulated_unsigned_transaction.actions.clone();
        actions.push(action);
        let prepopulated_unsigned_transaction = near_primitives::transaction::Transaction {
            actions,
            ..prepopulated_unsigned_transaction
        };

        match self.network.get_sign_option() {
            crate::transaction_signature_options::SignWith::SignWithPlaintextPrivateKey(
                sign_private_key,
            ) => {
                sign_private_key
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
            crate::transaction_signature_options::SignWith::SignWithKeychain(sign_keychain) => {
                sign_keychain
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config.clone()),
                        config.credentials_home_dir,
                    )
                    .await
            }
            #[cfg(feature = "ledger")]
            crate::transaction_signature_options::SignWith::SignWithLedger(sign_ledger) => {
                sign_ledger
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
        }
    }
}

'''
'''--- src/commands/account/add_key/use_public_key/mod.rs ---
#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct AddAccessKeyAction {
    ///Enter the public key for this account
    public_key: crate::types::public_key::PublicKey,
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_for_transaction::NetworkForTransactionArgs,
}

impl AddAccessKeyAction {
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
        permission: near_primitives::account::AccessKeyPermission,
    ) -> crate::CliResult {
        let access_key = near_primitives::account::AccessKey {
            nonce: 0,
            permission,
        };
        let action = near_primitives::transaction::Action::AddKey(
            near_primitives::transaction::AddKeyAction {
                public_key: self.public_key.clone().into(),
                access_key,
            },
        );
        let mut actions = prepopulated_unsigned_transaction.actions.clone();
        actions.push(action);
        let prepopulated_unsigned_transaction = near_primitives::transaction::Transaction {
            actions,
            ..prepopulated_unsigned_transaction
        };

        match self.network.get_sign_option() {
            crate::transaction_signature_options::SignWith::SignWithPlaintextPrivateKey(
                sign_private_key,
            ) => {
                sign_private_key
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
            crate::transaction_signature_options::SignWith::SignWithKeychain(sign_keychain) => {
                sign_keychain
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config.clone()),
                        config.credentials_home_dir,
                    )
                    .await
            }
            #[cfg(feature = "ledger")]
            crate::transaction_signature_options::SignWith::SignWithLedger(sign_ledger) => {
                sign_ledger
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
        }
    }
}

'''
'''--- src/commands/account/create_implicit_account/mod.rs ---
use dialoguer::Input;
use std::io::Write;
use strum::{EnumDiscriminants, EnumIter, EnumMessage};

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct ImplicitAccount {
    #[interactive_clap(subcommand)]
    mode: Mode,
}

impl ImplicitAccount {
    pub async fn process(&self) -> crate::CliResult {
        self.mode.process().await
    }
}

#[derive(Debug, Clone, EnumDiscriminants, interactive_clap_derive::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///Choose a mode to create an implicit account
pub enum Mode {
    #[strum_discriminants(strum(
        message = "use-auto-generation  - Use auto-generation to create an implicit account"
    ))]
    ///Use auto-generation to create an implicit account
    UseAutoGeneration(self::SaveImplicitAccount),
    #[cfg(feature = "ledger")]
    #[strum_discriminants(strum(
        message = "use-ledger           - Use ledger to create an implicit account"
    ))]
    ///Use ledger to create an implicit account
    UseLedger(self::SaveImplicitAccount),
}

impl Mode {
    pub async fn process(&self) -> crate::CliResult {
        let mut file_path = std::path::PathBuf::new();
        let mut file_name = std::path::PathBuf::new();
        let mut buf = String::new();
        match self {
            Mode::UseAutoGeneration(save_implicit_account) => {
                let key_pair_properties = crate::common::generate_keypair().await?;
                buf.push_str(&format!(
                    "{}",
                    serde_json::json!({
                        "master_seed_phrase": key_pair_properties.master_seed_phrase,
                        "seed_phrase_hd_path": key_pair_properties.seed_phrase_hd_path.to_string(),
                        "implicit_account_id": key_pair_properties.implicit_account_id,
                        "public_key": key_pair_properties.public_key_str,
                        "private_key": key_pair_properties.secret_keypair_str,
                    })
                ));
                file_name.push(format!("{}.json", key_pair_properties.implicit_account_id));
                file_path.push(save_implicit_account.save_to_folder.get_folder_path());
            }
            #[cfg(feature = "ledger")]
            Mode::UseLedger(save_implicit_account) => {
                let seed_phrase_hd_path = crate::transaction_signature_options::sign_with_ledger::SignLedger::input_seed_phrase_hd_path();
                println!(
                    "Please allow getting the PublicKey on Ledger device (HD Path: {})",
                    seed_phrase_hd_path
                );
                let public_key = near_ledger::get_public_key(seed_phrase_hd_path.clone().into()).await
                    .map_err(|near_ledger_error| {
                        color_eyre::Report::msg(format!(
                            "An error occurred while trying to get PublicKey from Ledger device: {:?}",
                            near_ledger_error
                        ))
                    })?;
                let public_key_str = format!("ed25519:{}", bs58::encode(&public_key).into_string());
                let implicit_account_id =
                    near_primitives::types::AccountId::try_from(hex::encode(&public_key))?;
                buf.push_str(&format!(
                    "{}",
                    serde_json::json!({
                        "seed_phrase_hd_path": seed_phrase_hd_path.to_string(),
                        "implicit_account_id": implicit_account_id.to_string(),
                        "public_key": public_key_str,
                    })
                ));
                file_name = format!("{}.json", implicit_account_id).into();
                file_path.push(save_implicit_account.save_to_folder.get_folder_path());
            }
        }
        std::fs::create_dir_all(&file_path)?;
        file_path.push(file_name);
        std::fs::File::create(&file_path)
            .map_err(|err| color_eyre::Report::msg(format!("Failed to create file: {:?}", err)))?
            .write(&buf.as_bytes())
            .map_err(|err| {
                color_eyre::Report::msg(format!("Failed to write to file: {:?}", err))
            })?;
        println!("\nThe file {:?} was saved successfully", &file_path);
        Ok(())
    }
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct SaveImplicitAccount {
    #[interactive_clap(named_arg)]
    ///Specify a folder to save the implicit account file
    save_to_folder: SaveToFolder,
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct SaveToFolder {
    #[interactive_clap(skip_default_input_arg)]
    ///Where to save the implicit account file?
    folder_path: crate::types::path_buf::PathBuf,
}

impl SaveToFolder {
    fn get_folder_path(&self) -> std::path::PathBuf {
        self.folder_path.clone().into()
    }

    fn input_folder_path(
        context: &crate::GlobalContext,
    ) -> color_eyre::eyre::Result<crate::types::path_buf::PathBuf> {
        println!();
        let input_folder_path: String = Input::new()
            .with_prompt("Where to save the implicit account file?")
            .with_initial_text(format!(
                "{}/implicit",
                context.0.credentials_home_dir.to_string_lossy()
            ))
            .interact_text()?;
        let folder_path = shellexpand::tilde(&input_folder_path).as_ref().parse()?;
        Ok(folder_path)
    }
}

'''
'''--- src/commands/account/create_subaccount/mod.rs ---
#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct SubAccount {
    ///What is the sub-account ID?
    new_account_id: crate::types::account_id::AccountId,
    ///Enter the amount for the subaccount
    initial_balance: crate::common::NearBalance,
    #[interactive_clap(subcommand)]
    access_key_mode: super::add_key::AccessKeyMode,
}

impl SubAccount {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        let prepopulated_unsigned_transaction = near_primitives::transaction::Transaction {
            signer_id: self
                .new_account_id
                .clone()
                .get_owner_account_id_from_sub_account()
                .into(),
            public_key: near_crypto::PublicKey::empty(near_crypto::KeyType::ED25519),
            nonce: 0,
            receiver_id: self.new_account_id.clone().into(),
            block_hash: Default::default(),
            actions: vec![
                near_primitives::transaction::Action::CreateAccount(
                    near_primitives::transaction::CreateAccountAction {},
                ),
                near_primitives::transaction::Action::Transfer(
                    near_primitives::transaction::TransferAction {
                        deposit: self.initial_balance.to_yoctonear(),
                    },
                ),
            ],
        };
        self.access_key_mode
            .process(
                config,
                prepopulated_unsigned_transaction,
                near_primitives::account::AccessKeyPermission::FullAccess,
            )
            .await
    }
}

'''
'''--- src/commands/account/delete_account/mod.rs ---
#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct DeleteAccount {
    ///What Account ID to be deleted
    account_id: crate::types::account_id::AccountId,
    #[interactive_clap(named_arg)]
    ///Enter the beneficiary ID to delete this account ID
    beneficiary: BeneficiaryAccount,
}

impl DeleteAccount {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        self.beneficiary
            .process(config, self.account_id.clone().into())
            .await
    }
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct BeneficiaryAccount {
    ///Specify a beneficiary
    beneficiary_account_id: crate::types::account_id::AccountId,
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_for_transaction::NetworkForTransactionArgs,
}

impl BeneficiaryAccount {
    pub async fn process(
        &self,
        config: crate::config::Config,
        account_id: near_primitives::types::AccountId,
    ) -> crate::CliResult {
        let beneficiary_id: near_primitives::types::AccountId =
            self.beneficiary_account_id.clone().into();
        let prepopulated_unsigned_transaction = near_primitives::transaction::Transaction {
            signer_id: account_id.clone(),
            public_key: near_crypto::PublicKey::empty(near_crypto::KeyType::ED25519),
            nonce: 0,
            receiver_id: account_id,
            block_hash: Default::default(),
            actions: vec![near_primitives::transaction::Action::DeleteAccount(
                near_primitives::transaction::DeleteAccountAction { beneficiary_id },
            )],
        };

        match self.network.get_sign_option() {
            crate::transaction_signature_options::SignWith::SignWithPlaintextPrivateKey(
                sign_private_key,
            ) => {
                sign_private_key
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
            crate::transaction_signature_options::SignWith::SignWithKeychain(sign_keychain) => {
                sign_keychain
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config.clone()),
                        config.credentials_home_dir,
                    )
                    .await
            }
            #[cfg(feature = "ledger")]
            crate::transaction_signature_options::SignWith::SignWithLedger(sign_ledger) => {
                sign_ledger
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
        }
    }
}

'''
'''--- src/commands/account/delete_key/mod.rs ---
#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct DeleteKeyCommand {
    ///Which account should You delete the access key for?
    owner_account_id: crate::types::account_id::AccountId,
    ///Enter the public key You wish to delete
    public_key: crate::types::public_key::PublicKey,
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_for_transaction::NetworkForTransactionArgs,
}

impl DeleteKeyCommand {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        let prepopulated_unsigned_transaction = near_primitives::transaction::Transaction {
            signer_id: self.owner_account_id.clone().into(),
            public_key: near_crypto::PublicKey::empty(near_crypto::KeyType::ED25519),
            nonce: 0,
            receiver_id: self.owner_account_id.clone().into(),
            block_hash: Default::default(),
            actions: vec![near_primitives::transaction::Action::DeleteKey(
                near_primitives::transaction::DeleteKeyAction {
                    public_key: self.public_key.clone().into(),
                },
            )],
        };

        match self.network.get_sign_option() {
            crate::transaction_signature_options::SignWith::SignWithPlaintextPrivateKey(
                sign_private_key,
            ) => {
                sign_private_key
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
            crate::transaction_signature_options::SignWith::SignWithKeychain(sign_keychain) => {
                sign_keychain
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config.clone()),
                        config.credentials_home_dir,
                    )
                    .await
            }
            #[cfg(feature = "ledger")]
            crate::transaction_signature_options::SignWith::SignWithLedger(sign_ledger) => {
                sign_ledger
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
        }
    }
}

'''
'''--- src/commands/account/import_account/mod.rs ---
use dialoguer::Input;
use std::str::FromStr;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct Login {
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network::Network,
}

impl Login {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        let network_config = self.network.get_network_config(config.clone());
        login(network_config, config.credentials_home_dir).await
    }
}

async fn login(
    network_config: crate::config::NetworkConfig,
    credentials_home_dir: std::path::PathBuf,
) -> crate::CliResult {
    let key_pair_properties: crate::common::KeyPairProperties =
        crate::common::generate_keypair().await?;
    let mut url: url::Url = network_config.wallet_url.join("login/")?;
    url.query_pairs_mut()
        .append_pair("title", "NEAR CLI")
        .append_pair("public_key", &key_pair_properties.public_key_str);
    // Use `success_url` once capture mode is implemented
    //.append_pair("success_url", "http://127.0.0.1:8080");
    println!(
        "If your browser doesn't automatically open, please visit this URL:\n {}\n",
        &url.as_str()
    );
    // url.open();
    open::that(url.as_ref()).ok();

    let public_key: near_crypto::PublicKey =
        near_crypto::PublicKey::from_str(&key_pair_properties.public_key_str)?;

    let account_id = get_account_from_cli(public_key, network_config.clone()).await?;
    // save_account(&account_id, key_pair_properties, self.connection_config).await?
    crate::common::save_access_key_to_keychain(
        network_config,
        credentials_home_dir,
        key_pair_properties.clone(),
        &account_id.to_string(),
    )
    .await
    .map_err(|err| {
        color_eyre::Report::msg(format!("Failed to save a file with access key: {}", err))
    })?;
    Ok(())
}

async fn get_account_from_cli(
    public_key: near_crypto::PublicKey,
    network_config: crate::config::NetworkConfig,
) -> color_eyre::eyre::Result<near_primitives::types::AccountId> {
    let account_id = input_account_id()?;
    verify_account_id(account_id.clone(), public_key, network_config)
        .await
        .map_err(|err| color_eyre::Report::msg(format!("Failed account ID: {:?}", err)))?;
    Ok(account_id)
}

fn input_account_id() -> color_eyre::eyre::Result<near_primitives::types::AccountId> {
    Ok(Input::new()
        .with_prompt("Enter account ID")
        .interact_text()?)
}

async fn verify_account_id(
    account_id: near_primitives::types::AccountId,
    public_key: near_crypto::PublicKey,
    network_config: crate::config::NetworkConfig,
) -> crate::CliResult {
    network_config
        .json_rpc_client()?
        .call(near_jsonrpc_client::methods::query::RpcQueryRequest {
            block_reference: near_primitives::types::Finality::Final.into(),
            request: near_primitives::views::QueryRequest::ViewAccessKey {
                account_id,
                public_key,
            },
        })
        .await
        .map_err(|err| {
            color_eyre::Report::msg(format!(
                "Failed to fetch query for view access key: {:?}",
                err
            ))
        })?;
    Ok(())
}

'''
'''--- src/commands/account/list_keys/mod.rs ---
#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct ViewListKeys {
    ///What Account ID do you need to view?
    account_id: crate::types::account_id::AccountId,
    #[interactive_clap(named_arg)]
    /// Select network
    network: crate::network_view_at_block::NetworkViewAtBlockArgs,
}

impl ViewListKeys {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        crate::common::display_access_key_list(
            self.account_id.clone().into(),
            self.network.get_network_config(config),
            self.network.get_block_ref(),
        )
        .await?;
        Ok(())
    }
}

'''
'''--- src/commands/account/mod.rs ---
use strum::{EnumDiscriminants, EnumIter, EnumMessage};

mod add_key;
mod create_implicit_account;
mod create_subaccount;
mod delete_account;
mod delete_key;
mod import_account;
mod list_keys;
mod view_account_summary;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct AccountCommands {
    #[interactive_clap(subcommand)]
    account_actions: AccountActions,
}

impl AccountCommands {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        self.account_actions.process(config).await
    }
}

#[derive(Debug, EnumDiscriminants, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
/// What do you want to do with an account?
pub enum AccountActions {
    #[strum_discriminants(strum(
        message = "view-account-summary    - View properties for an account"
    ))]
    /// View properties for an account
    ViewAccountSummary(self::view_account_summary::ViewAccountSummary),
    #[strum_discriminants(strum(
        message = "login                   - Log in with NEAR Wallet authorization"
    ))]
    /// Log in with NEAR Wallet
    ImportAccount(self::import_account::Login),
    #[strum_discriminants(strum(message = "create-subaccount       - Create a new sub-account"))]
    /// Create a new sub-account
    CreateSubaccount(self::create_subaccount::SubAccount),
    #[strum_discriminants(strum(
        message = "create-implicit-account - Create an implicit-account"
    ))]
    /// Create an implicit-account
    CreateImplicitAccount(self::create_implicit_account::ImplicitAccount),
    #[strum_discriminants(strum(message = "delete-account          - Delete an account"))]
    /// Delete an account
    DeleteAccount(self::delete_account::DeleteAccount),
    #[strum_discriminants(strum(
        message = "list-keys               - View a list of access keys of an account"
    ))]
    /// View a list of access keys of an account
    ListKeys(self::list_keys::ViewListKeys),
    #[strum_discriminants(strum(
        message = "add-key                 - Add an access key to an account"
    ))]
    /// Add an access key to an account
    AddKey(self::add_key::AddKeyCommand),
    #[strum_discriminants(strum(
        message = "delete-key              - Delete an access key from an account"
    ))]
    /// Delete an access key from an account
    DeleteKey(self::delete_key::DeleteKeyCommand),
}

impl AccountActions {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        match self {
            Self::ViewAccountSummary(view_account_command) => {
                view_account_command.process(config).await
            }
            Self::ListKeys(view_list_keys) => view_list_keys.process(config).await,
            Self::DeleteAccount(delete_account) => delete_account.process(config).await,
            Self::CreateSubaccount(sub_account) => sub_account.process(config).await,
            Self::CreateImplicitAccount(implicit_account) => implicit_account.process().await,
            Self::AddKey(add_key_command) => add_key_command.process(config).await,
            Self::DeleteKey(delete_key_command) => delete_key_command.process(config).await,
            Self::ImportAccount(login) => login.process(config).await,
        }
    }
}

'''
'''--- src/commands/account/view_account_summary/mod.rs ---
#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct ViewAccountSummary {
    ///What Account ID do you need to view?
    account_id: crate::types::account_id::AccountId,
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_view_at_block::NetworkViewAtBlockArgs,
}

impl ViewAccountSummary {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        let network_config = self.network.get_network_config(config);
        crate::common::display_account_info(
            self.account_id.clone().into(),
            network_config.clone(),
            self.network.get_block_ref(),
        )
        .await?;
        crate::common::display_access_key_list(
            self.account_id.clone().into(),
            network_config,
            self.network.get_block_ref(),
        )
        .await?;
        Ok(())
    }
}

'''
'''--- src/commands/config/add_connection/mod.rs ---
use dialoguer::{console::Term, theme::ColorfulTheme, Input, Select};

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[interactive_clap(skip_default_from_cli)]
pub struct AddNetworkConnection {
    ///What is the NEAR network? (e.g. mainnet, testnet, shardnet)
    network_name: String,
    ///What is the connection name? (e.g. pagoda-mainnet)
    connection_name: String,
    ///What is the RPC endpoint?
    rpc_url: crate::types::url::Url,
    ///What is the wallet endpoint?
    wallet_url: crate::types::url::Url,
    ///What is the transaction explorer endpoint?
    explorer_transaction_url: crate::types::url::Url,
    #[interactive_clap(skip_default_from_cli_arg)]
    #[interactive_clap(skip_default_input_arg)]
    api_key: Option<String>,
}

impl AddNetworkConnection {
    pub fn from_cli(
        optional_clap_variant: Option<
            <AddNetworkConnection as interactive_clap::ToCli>::CliVariant,
        >,
        context: crate::GlobalContext,
    ) -> color_eyre::eyre::Result<Option<Self>> {
        let network_name = match optional_clap_variant
            .clone()
            .and_then(|clap_variant| clap_variant.network_name)
        {
            Some(cli_network_name) => cli_network_name,
            None => Self::input_network_name(&context)?,
        };
        let connection_name = match optional_clap_variant
            .clone()
            .and_then(|clap_variant| clap_variant.connection_name)
        {
            Some(cli_connection_name) => cli_connection_name,
            None => Self::input_connection_name(&context)?,
        };
        let rpc_url = match optional_clap_variant
            .clone()
            .and_then(|clap_variant| clap_variant.rpc_url)
        {
            Some(cli_rpc_url) => cli_rpc_url,
            None => Self::input_rpc_url(&context)?,
        };
        let wallet_url = match optional_clap_variant
            .clone()
            .and_then(|clap_variant| clap_variant.wallet_url)
        {
            Some(cli_wallet_url) => cli_wallet_url,
            None => Self::input_wallet_url(&context)?,
        };
        let explorer_transaction_url = match optional_clap_variant
            .clone()
            .and_then(|clap_variant| clap_variant.explorer_transaction_url)
        {
            Some(cli_explorer_transaction_url) => cli_explorer_transaction_url,
            None => Self::input_explorer_transaction_url(&context)?,
        };
        let api_key: Option<String> = match optional_clap_variant
            .clone()
            .and_then(|clap_variant| clap_variant.api_key)
        {
            Some(cli_api_key) => Some(cli_api_key),
            None => Self::input_api_key()?,
        };
        Ok(Some(Self {
            network_name,
            connection_name,
            rpc_url,
            wallet_url,
            explorer_transaction_url,
            api_key,
        }))
    }

    fn input_api_key() -> color_eyre::eyre::Result<Option<String>> {
        println!();
        let choose_input = vec![
            "Yes, the RPC endpoint requires API key",
            "No, the RPC endpoint does not require API key",
        ];
        let select_choose_input = Select::with_theme(&ColorfulTheme::default())
            .with_prompt("Do you want to input an API key?")
            .items(&choose_input)
            .default(0)
            .interact_on_opt(&Term::stderr())?;
        match select_choose_input {
            Some(0) => {
                let api_key = Input::new()
                    .with_prompt("Enter an API key")
                    .interact_text()?;
                Ok(Some(api_key))
            }
            Some(1) => Ok(None),
            _ => unreachable!("Error"),
        }
    }

    pub async fn process(&self, mut config: crate::config::Config) -> crate::CliResult {
        config.networks.insert(
            self.connection_name.clone(),
            crate::config::NetworkConfig {
                network_name: self.network_name.clone(),
                rpc_url: self.rpc_url.0.clone(),
                wallet_url: self.wallet_url.0.clone(),
                explorer_transaction_url: self.explorer_transaction_url.0.clone(),
                api_key: self.api_key.clone(),
            },
        );
        println!();
        crate::common::write_config_toml(config)
    }
}

'''
'''--- src/commands/config/delete_connection/mod.rs ---
#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct DeleteNetworkConnection {
    ///What is the network name?
    #[interactive_clap(skip_default_input_arg)]
    network_name: String,
}

impl DeleteNetworkConnection {
    fn input_network_name(context: &crate::GlobalContext) -> color_eyre::eyre::Result<String> {
        crate::common::input_network_name(context)
    }

    pub async fn process(&self, mut config: crate::config::Config) -> crate::CliResult {
        config.networks.remove(&self.network_name);
        crate::common::write_config_toml(config)
    }
}

'''
'''--- src/commands/config/mod.rs ---
use strum::{EnumDiscriminants, EnumIter, EnumMessage};

mod add_connection;
mod delete_connection;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct ConfigCommands {
    #[interactive_clap(subcommand)]
    config_actions: ConfigActions,
}

impl ConfigCommands {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        self.config_actions.process(config).await
    }
}

#[derive(Debug, EnumDiscriminants, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
/// What do you want to do with a near-cli config?
pub enum ConfigActions {
    #[strum_discriminants(strum(
        message = "show-connections       - Show a list of network connections"
    ))]
    ///Show a list of network connections
    ShowConnections,
    #[strum_discriminants(strum(message = "add-connection         - Add a network connection"))]
    ///Add a network connection
    AddConnection(self::add_connection::AddNetworkConnection),
    #[strum_discriminants(strum(
        message = "delete-connection      - Delete a network connection"
    ))]
    ///Delete a network connection
    DeleteConnection(self::delete_connection::DeleteNetworkConnection),
}

impl ConfigActions {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        match self {
            Self::ShowConnections => {
                let mut path_config_toml =
                    dirs::config_dir().expect("Impossible to get your config dir!");
                path_config_toml.push("near-cli/config.toml");
                println!(
                    "\nConfiguration data is stored in a file {:?}",
                    &path_config_toml
                );
                let config_toml = toml::to_string(&config)?;
                println!("{}", &config_toml);
                Ok(())
            }
            Self::AddConnection(add_network_connection) => {
                add_network_connection.process(config).await
            }
            Self::DeleteConnection(delete_network_connection) => {
                delete_network_connection.process(config).await
            }
        }
    }
}

'''
'''--- src/commands/contract/call_function/as_read_only/mod.rs ---
#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct CallFunctionView {
    ///What is the account ID?
    account_id: crate::types::account_id::AccountId,
    ///What is the name of the function?
    function_name: String,
    ///Enter arguments to this function
    function_args: String,
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_view_at_block::NetworkViewAtBlockArgs,
}

impl CallFunctionView {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        let args: near_primitives::types::FunctionArgs =
            near_primitives::types::FunctionArgs::from(self.function_args.clone().into_bytes());
        let query_view_method_response = self
            .network
            .get_network_config(config)
            .json_rpc_client()?
            .call(near_jsonrpc_client::methods::query::RpcQueryRequest {
                block_reference: self.network.get_block_ref(),
                request: near_primitives::views::QueryRequest::CallFunction {
                    account_id: self.account_id.clone().into(),
                    method_name: self.function_name.clone(),
                    args,
                },
            })
            .await
            .map_err(|err| {
                color_eyre::Report::msg(format!("Failed to fetch query for view method: {:?}", err))
            })?;
        let call_result =
            if let near_jsonrpc_primitives::types::query::QueryResponseKind::CallResult(result) =
                query_view_method_response.kind
            {
                result.result
            } else {
                return Err(color_eyre::Report::msg(format!("Error call result")));
            };

        let serde_call_result = if call_result.is_empty() {
            serde_json::Value::Null
        } else {
            serde_json::from_slice(&call_result)
                .map_err(|err| color_eyre::Report::msg(format!("serde json: {:?}", err)))?
        };
        println!("--------------");
        println!();
        println!("{}", serde_json::to_string_pretty(&serde_call_result)?);
        Ok(())
    }
}

'''
'''--- src/commands/contract/call_function/as_transaction/mod.rs ---
use dialoguer::Input;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct CallFunctionAction {
    ///What is the contract account ID?
    contract_account_id: crate::types::account_id::AccountId,
    ///What is the name of the function?
    function_name: String,
    ///Enter arguments to this function
    function_args: String,
    #[interactive_clap(long = "prepaid-gas")]
    #[interactive_clap(skip_default_input_arg)]
    ///Enter gas for function call
    gas: crate::common::NearGas,
    #[interactive_clap(long = "attached-deposit")]
    #[interactive_clap(skip_default_input_arg)]
    ///Enter deposit for a function call
    deposit: crate::common::NearBalance,
    ///What is the signer account ID?
    signer_account_id: crate::types::account_id::AccountId,
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_for_transaction::NetworkForTransactionArgs,
}

impl CallFunctionAction {
    fn input_gas(
        _context: &crate::GlobalContext,
    ) -> color_eyre::eyre::Result<crate::common::NearGas> {
        println!();
        let gas: u64 = loop {
            let input_gas: crate::common::NearGas = Input::new()
                .with_prompt("Enter gas for function call")
                .with_initial_text("100 TeraGas")
                .interact_text()?;
            let gas: u64 = match input_gas {
                crate::common::NearGas { inner: num } => num,
            };
            if gas <= 300000000000000 {
                break gas;
            } else {
                println!("You need to enter a value of no more than 300 TERAGAS")
            }
        };
        Ok(gas.into())
    }

    fn input_deposit(
        _context: &crate::GlobalContext,
    ) -> color_eyre::eyre::Result<crate::common::NearBalance> {
        println!();
        let deposit: crate::common::NearBalance = Input::new()
            .with_prompt(
                "Enter deposit for a function call (example: 10NEAR or 0.5near or 10000yoctonear).",
            )
            .with_initial_text("0 NEAR")
            .interact_text()?;
        Ok(deposit)
    }
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        let prepopulated_unsigned_transaction = near_primitives::transaction::Transaction {
            signer_id: self.signer_account_id.clone().into(),
            public_key: near_crypto::PublicKey::empty(near_crypto::KeyType::ED25519),
            nonce: 0,
            receiver_id: self.contract_account_id.clone().into(),
            block_hash: Default::default(),
            actions: vec![near_primitives::transaction::Action::FunctionCall(
                near_primitives::transaction::FunctionCallAction {
                    method_name: self.function_name.clone(),
                    args: self.function_args.clone().into_bytes(),
                    gas: self.gas.clone().inner,
                    deposit: self.deposit.clone().to_yoctonear(),
                },
            )],
        };

        match self.network.get_sign_option() {
            crate::transaction_signature_options::SignWith::SignWithPlaintextPrivateKey(
                sign_private_key,
            ) => {
                sign_private_key
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
            crate::transaction_signature_options::SignWith::SignWithKeychain(sign_keychain) => {
                sign_keychain
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config.clone()),
                        config.credentials_home_dir,
                    )
                    .await
            }
            #[cfg(feature = "ledger")]
            crate::transaction_signature_options::SignWith::SignWithLedger(sign_ledger) => {
                sign_ledger
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
        }
    }
}

'''
'''--- src/commands/contract/call_function/mod.rs ---
use strum::{EnumDiscriminants, EnumIter, EnumMessage};

mod as_read_only;
mod as_transaction;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct CallFunctionCommands {
    #[interactive_clap(subcommand)]
    call_function_actions: CallFunctionActions,
}

impl CallFunctionCommands {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        self.call_function_actions.process(config).await
    }
}

#[derive(Debug, EnumDiscriminants, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///Сhoose action for account
pub enum CallFunctionActions {
    #[strum_discriminants(strum(message = "as-read-only    - Calling a view method"))]
    ///Calling a view method
    AsReadOnly(self::as_read_only::CallFunctionView),
    #[strum_discriminants(strum(message = "as-transaction  - Calling a change method"))]
    ///Calling a change method
    AsTransaction(self::as_transaction::CallFunctionAction),
}

impl CallFunctionActions {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        match self {
            Self::AsReadOnly(call_function_view) => call_function_view.process(config).await,
            Self::AsTransaction(call_function_action) => call_function_action.process(config).await,
        }
    }
}

'''
'''--- src/commands/contract/deploy/initialize_mode/call_function_type/mod.rs ---
use dialoguer::Input;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct CallFunctionAction {
    ///What is the name of the function?
    function_name: String,
    ///Enter arguments to this function
    function_args: String,
    #[interactive_clap(long = "prepaid-gas")]
    #[interactive_clap(skip_default_input_arg)]
    ///Enter gas for function call
    gas: crate::common::NearGas,
    #[interactive_clap(long = "attached-deposit")]
    #[interactive_clap(skip_default_input_arg)]
    ///Enter deposit for a function call
    deposit: crate::common::NearBalance,
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_for_transaction::NetworkForTransactionArgs,
}

impl CallFunctionAction {
    fn input_gas(
        _context: &crate::GlobalContext,
    ) -> color_eyre::eyre::Result<crate::common::NearGas> {
        println!();
        let gas: u64 = loop {
            let input_gas: crate::common::NearGas = Input::new()
                .with_prompt("Enter gas for function call")
                .with_initial_text("100 TeraGas")
                .interact_text()?;
            let gas: u64 = match input_gas {
                crate::common::NearGas { inner: num } => num,
            };
            if gas <= 300000000000000 {
                break gas;
            } else {
                println!("You need to enter a value of no more than 300 TERAGAS")
            }
        };
        Ok(gas.into())
    }

    fn input_deposit(
        _context: &crate::GlobalContext,
    ) -> color_eyre::eyre::Result<crate::common::NearBalance> {
        println!();
        let deposit: crate::common::NearBalance = Input::new()
            .with_prompt(
                "Enter deposit for a function call (example: 10NEAR or 0.5near or 10000yoctonear).",
            )
            .with_initial_text("0 NEAR")
            .interact_text()?;
        Ok(deposit)
    }

    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        let action = near_primitives::transaction::Action::FunctionCall(
            near_primitives::transaction::FunctionCallAction {
                method_name: self.function_name.clone(),
                args: self.function_args.clone().into_bytes(),
                gas: self.gas.clone().inner,
                deposit: self.deposit.clone().to_yoctonear(),
            },
        );
        let mut actions = prepopulated_unsigned_transaction.actions.clone();
        actions.push(action);
        let prepopulated_unsigned_transaction = near_primitives::transaction::Transaction {
            actions,
            ..prepopulated_unsigned_transaction
        };
        match self.network.get_sign_option() {
            crate::transaction_signature_options::SignWith::SignWithPlaintextPrivateKey(
                sign_private_key,
            ) => {
                sign_private_key
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
            crate::transaction_signature_options::SignWith::SignWithKeychain(sign_keychain) => {
                sign_keychain
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config.clone()),
                        config.credentials_home_dir,
                    )
                    .await
            }
            #[cfg(feature = "ledger")]
            crate::transaction_signature_options::SignWith::SignWithLedger(sign_ledger) => {
                sign_ledger
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
        }
    }
}

'''
'''--- src/commands/contract/deploy/initialize_mode/mod.rs ---
use strum::{EnumDiscriminants, EnumIter, EnumMessage};

mod call_function_type;

#[derive(Debug, Clone, EnumDiscriminants, interactive_clap_derive::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///Select the need for initialization
pub enum InitializeMode {
    /// Add an initialize
    #[strum_discriminants(strum(message = "with-init-call     - Add an initialize"))]
    WithInitCall(self::call_function_type::CallFunctionAction),
    /// Don't add an initialize
    #[strum_discriminants(strum(message = "without-init-call  - Don't add an initialize"))]
    WithoutInitCall(NoInitialize),
}

impl InitializeMode {
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        match self {
            InitializeMode::WithInitCall(call_function_action) => {
                call_function_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            InitializeMode::WithoutInitCall(no_initialize) => {
                no_initialize
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
        }
    }
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct NoInitialize {
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_for_transaction::NetworkForTransactionArgs,
}

impl NoInitialize {
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        match self.network.get_sign_option() {
            crate::transaction_signature_options::SignWith::SignWithPlaintextPrivateKey(
                sign_private_key,
            ) => {
                sign_private_key
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
            crate::transaction_signature_options::SignWith::SignWithKeychain(sign_keychain) => {
                sign_keychain
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config.clone()),
                        config.credentials_home_dir,
                    )
                    .await
            }
            #[cfg(feature = "ledger")]
            crate::transaction_signature_options::SignWith::SignWithLedger(sign_ledger) => {
                sign_ledger
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
        }
    }
}

'''
'''--- src/commands/contract/deploy/mod.rs ---
mod initialize_mode;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct Contract {
    ///What is the contract account ID?
    account_id: crate::types::account_id::AccountId,
    #[interactive_clap(named_arg)]
    ///Specify a path to wasm file
    use_file: ContractFile,
}

impl Contract {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        self.use_file
            .process(config, self.account_id.clone().into())
            .await
    }
}

#[derive(Debug, Clone, interactive_clap_derive::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct ContractFile {
    ///What is a file location of the contract?
    pub file_path: crate::types::path_buf::PathBuf,
    #[interactive_clap(subcommand)]
    initialize: self::initialize_mode::InitializeMode,
}

impl ContractFile {
    pub async fn process(
        &self,
        config: crate::config::Config,
        account_id: near_primitives::types::AccountId,
    ) -> crate::CliResult {
        let code = std::fs::read(&self.file_path.0.clone()).map_err(|err| {
            color_eyre::Report::msg(format!(
                "Failed to open or read the file: {:?}.\nError: {:?}",
                &self.file_path.0.clone(),
                err
            ))
        })?;
        let prepopulated_unsigned_transaction = near_primitives::transaction::Transaction {
            signer_id: account_id.clone(),
            public_key: near_crypto::PublicKey::empty(near_crypto::KeyType::ED25519),
            nonce: 0,
            receiver_id: account_id,
            block_hash: Default::default(),
            actions: vec![near_primitives::transaction::Action::DeployContract(
                near_primitives::transaction::DeployContractAction { code },
            )],
        };
        self.initialize
            .process(config, prepopulated_unsigned_transaction)
            .await
    }
}

'''
'''--- src/commands/contract/download_wasm/mod.rs ---
use dialoguer::Input;
use std::io::Write;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct ContractAccount {
    ///What is the contract account ID?
    account_id: crate::types::account_id::AccountId,
    #[interactive_clap(named_arg)]
    ///Select a folder to download the contract
    to_folder: DownloadContract,
}

impl ContractAccount {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        self.to_folder
            .process(config, self.account_id.clone().into())
            .await
    }
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct DownloadContract {
    #[interactive_clap(skip_default_input_arg)]
    ///Where to download the contract file?
    folder_path: crate::types::path_buf::PathBuf,
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_view_at_block::NetworkViewAtBlockArgs,
}

impl DownloadContract {
    fn input_folder_path(
        _context: &crate::GlobalContext,
    ) -> color_eyre::eyre::Result<crate::types::path_buf::PathBuf> {
        let home_dir = dirs::home_dir().expect("Impossible to get your home dir!");
        let mut folder_path = std::path::PathBuf::from(&home_dir);
        folder_path.push("Downloads");
        println!();
        let input_folder_path: String = Input::new()
            .with_prompt("Where to download the contract file?")
            .with_initial_text(format!("{}", folder_path.to_string_lossy()))
            .interact_text()?;
        let folder_path = shellexpand::tilde(&input_folder_path).as_ref().parse()?;
        Ok(folder_path)
    }

    pub async fn process(
        &self,
        config: crate::config::Config,
        account_id: near_primitives::types::AccountId,
    ) -> crate::CliResult {
        let query_view_method_response = self
            .network
            .get_network_config(config)
            .json_rpc_client()?
            .call(near_jsonrpc_client::methods::query::RpcQueryRequest {
                block_reference: self.network.get_block_ref(),
                request: near_primitives::views::QueryRequest::ViewCode {
                    account_id: account_id.clone(),
                },
            })
            .await
            .map_err(|err| {
                color_eyre::Report::msg(format!(
                    "Failed to fetch query for view contract: {:?}",
                    err
                ))
            })?;
        let call_access_view =
            if let near_jsonrpc_primitives::types::query::QueryResponseKind::ViewCode(result) =
                query_view_method_response.kind
            {
                result
            } else {
                return Err(color_eyre::Report::msg(format!("Error call result")));
            };
        let mut file_path = self.folder_path.0.clone();
        std::fs::create_dir_all(&file_path)?;
        let file_name: std::path::PathBuf =
            format!("contract_{}.wasm", account_id.as_str().replace(".", "_")).into();
        file_path.push(file_name);
        std::fs::File::create(&file_path)
            .map_err(|err| color_eyre::Report::msg(format!("Failed to create file: {:?}", err)))?
            .write(&call_access_view.code)
            .map_err(|err| {
                color_eyre::Report::msg(format!("Failed to write to file: {:?}", err))
            })?;
        println!("\nThe file {:?} was downloaded successfully", &file_path);
        Ok(())
    }
}

'''
'''--- src/commands/contract/mod.rs ---
use strum::{EnumDiscriminants, EnumIter, EnumMessage};

mod call_function;
mod deploy;
mod download_wasm;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct ContractCommands {
    #[interactive_clap(subcommand)]
    contract_actions: ContractActions,
}

impl ContractCommands {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        self.contract_actions.process(config).await
    }
}

#[derive(Debug, EnumDiscriminants, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///Сhoose action for account
pub enum ContractActions {
    #[strum_discriminants(strum(
        message = "call-function   - Execute function (contract method)"
    ))]
    ///Execute function (contract method)
    CallFunction(self::call_function::CallFunctionCommands),
    #[strum_discriminants(strum(message = "deploy          - Add a new contract code"))]
    ///Add a contract code
    Deploy(self::deploy::Contract),
    #[strum_discriminants(strum(message = "download-wasm   - Download wasm"))]
    ///Download wasm
    DownloadWasm(self::download_wasm::ContractAccount),
}

impl ContractActions {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        match self {
            Self::CallFunction(call_function_commands) => {
                call_function_commands.process(config).await
            }
            Self::Deploy(contract) => contract.process(config).await,
            Self::DownloadWasm(download_contract) => download_contract.process(config).await,
        }
    }
}

'''
'''--- src/commands/mod.rs ---
use strum::{EnumDiscriminants, EnumIter, EnumMessage};

mod account;
mod config;
mod contract;
mod tokens;
mod transaction;

#[derive(Debug, EnumDiscriminants, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
#[interactive_clap(disable_back)]
/// What are you up to? (select one of the options with the up-down arrows on your keyboard and press Enter)
pub enum TopLevelCommand {
    #[strum_discriminants(strum(message = "account     - Manage accounts"))]
    /// View account summary, create subaccount, delete account, list keys, add key, delete key, import account
    Account(self::account::AccountCommands),
    #[strum_discriminants(strum(
        message = "tokens      - Manage token assets such as NEAR, FT, NFT"
    ))]
    /// Use this for token actions: send or view balances of NEAR, FT, or NFT
    Tokens(self::tokens::TokensCommands),
    #[strum_discriminants(strum(
        message = "contract    - Manage smart-contracts: deploy code, call functions"
    ))]
    /// Use this for contract actions: call function, deploy, download wasm, inspect storage
    Contract(self::contract::ContractCommands),
    #[strum_discriminants(strum(message = "transaction - Operate transactions"))]
    /// Use this to construct transactions or view a transaction status.
    Transaction(self::transaction::TransactionCommands),
    #[strum_discriminants(strum(
        message = "config      - Manage connections in a configuration file (config.toml)"
    ))]
    /// Use this to manage connections in a configuration file (config.toml).
    Config(self::config::ConfigCommands),
}

impl TopLevelCommand {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        match self {
            Self::Tokens(tokens_commands) => tokens_commands.process(config).await,
            Self::Account(account_commands) => account_commands.process(config).await,
            Self::Contract(contract_commands) => contract_commands.process(config).await,
            Self::Transaction(transaction_commands) => transaction_commands.process(config).await,
            Self::Config(config_commands) => config_commands.process(config).await,
        }
    }
}

'''
'''--- src/commands/tokens/mod.rs ---
use strum::{EnumDiscriminants, EnumIter, EnumMessage};

mod send_ft;
mod send_near;
mod send_nft;
mod view_ft_balance;
mod view_near_balance;
mod view_nft_assets;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct TokensCommands {
    ///What is your account ID?
    owner_account_id: crate::types::account_id::AccountId,
    #[interactive_clap(subcommand)]
    tokens_actions: TokensActions,
}

impl TokensCommands {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        self.tokens_actions
            .process(config, self.owner_account_id.clone().into())
            .await
    }
}

#[derive(Debug, EnumDiscriminants, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///Select actions with tokens
pub enum TokensActions {
    #[strum_discriminants(strum(
        message = "send-near         - The transfer is carried out in NEAR tokens"
    ))]
    ///The transfer is carried out in NEAR tokens
    SendNear(self::send_near::SendNearCommand),
    #[strum_discriminants(strum(
        message = "send-ft           - The transfer is carried out in FT tokens"
    ))]
    ///The transfer is carried out in FT tokens
    SendFt(self::send_ft::SendFtCommand),
    #[strum_discriminants(strum(
        message = "send-nft          - The transfer is carried out in NFT tokens"
    ))]
    ///The transfer is carried out in NFT tokens
    SendNft(self::send_nft::SendNftCommand),
    #[strum_discriminants(strum(message = "view-near-balance - View the balance of Near tokens"))]
    ///View the balance of Near tokens
    ViewNearBalance(self::view_near_balance::ViewNearBalance),
    #[strum_discriminants(strum(message = "view-ft-balance   - View the balance of FT tokens"))]
    ///View the balance of FT tokens
    ViewFtBalance(self::view_ft_balance::ViewFtBalance),
    #[strum_discriminants(strum(message = "view-nft-assets   - View the balance of NFT tokens"))]
    ///View the balance of NFT tokens
    ViewNftAssets(self::view_nft_assets::ViewNftAssets),
}

impl TokensActions {
    async fn process(
        &self,
        config: crate::config::Config,
        owner_account_id: near_primitives::types::AccountId,
    ) -> crate::CliResult {
        match self {
            Self::SendNear(send_near_command) => {
                send_near_command.process(config, owner_account_id).await
            }
            Self::ViewNearBalance(view_near_balance) => {
                view_near_balance.process(config, owner_account_id).await
            }
            Self::SendFt(send_ft_command) => {
                send_ft_command.process(config, owner_account_id).await
            }
            Self::SendNft(send_nft_command) => {
                send_nft_command.process(config, owner_account_id).await
            }
            Self::ViewFtBalance(view_ft_balance) => {
                view_ft_balance.process(config, owner_account_id).await
            }
            Self::ViewNftAssets(view_nft_assets) => {
                view_nft_assets.process(config, owner_account_id).await
            }
        }
    }
}

'''
'''--- src/commands/tokens/send_ft/mod.rs ---
use dialoguer::Input;
use serde_json::json;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct SendFtCommand {
    ///What is the ft-contract account ID?
    ft_contract_account_id: crate::types::account_id::AccountId,
    ///What is the receiver account ID?
    receiver_account_id: crate::types::account_id::AccountId,
    ///Enter an amount FT to transfer
    amount: u128,
    #[interactive_clap(long = "prepaid-gas")]
    #[interactive_clap(skip_default_input_arg)]
    ///Enter gas for function call
    gas: crate::common::NearGas,
    #[interactive_clap(long = "attached-deposit")]
    #[interactive_clap(skip_default_input_arg)]
    ///Enter deposit for a function call
    deposit: crate::common::NearBalance,
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_for_transaction::NetworkForTransactionArgs,
}

impl SendFtCommand {
    fn input_gas(
        _context: &crate::GlobalContext,
    ) -> color_eyre::eyre::Result<crate::common::NearGas> {
        println!();
        let gas: u64 = loop {
            let input_gas: crate::common::NearGas = Input::new()
                .with_prompt("Enter gas for function call")
                .with_initial_text("100 TeraGas")
                .interact_text()?;
            let gas: u64 = match input_gas {
                crate::common::NearGas { inner: num } => num,
            };
            if gas <= 300000000000000 {
                break gas;
            } else {
                println!("You need to enter a value of no more than 300 TERAGAS")
            }
        };
        Ok(gas.into())
    }

    fn input_deposit(
        _context: &crate::GlobalContext,
    ) -> color_eyre::eyre::Result<crate::common::NearBalance> {
        println!();
        let deposit: crate::common::NearBalance = Input::new()
            .with_prompt(
                "Enter deposit for a function call (example: 10NEAR or 0.5near or 10000yoctonear).",
            )
            .with_initial_text("1 yoctoNEAR")
            .interact_text()?;
        Ok(deposit)
    }

    pub async fn process(
        &self,
        config: crate::config::Config,
        owner_account_id: near_primitives::types::AccountId,
    ) -> crate::CliResult {
        let method_name = "ft_transfer".to_string();
        let args = json!({
            "receiver_id": self.receiver_account_id.to_string(),
            "amount": self.amount.to_string()
        })
        .to_string()
        .into_bytes();
        let prepopulated_unsigned_transaction = near_primitives::transaction::Transaction {
            signer_id: owner_account_id,
            public_key: near_crypto::PublicKey::empty(near_crypto::KeyType::ED25519),
            nonce: 0,
            receiver_id: self.ft_contract_account_id.clone().into(),
            block_hash: Default::default(),
            actions: vec![near_primitives::transaction::Action::FunctionCall(
                near_primitives::transaction::FunctionCallAction {
                    method_name,
                    args,
                    gas: self.gas.clone().inner,
                    deposit: self.deposit.clone().to_yoctonear(),
                },
            )],
        };

        match self.network.get_sign_option() {
            crate::transaction_signature_options::SignWith::SignWithPlaintextPrivateKey(
                sign_private_key,
            ) => {
                sign_private_key
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
            crate::transaction_signature_options::SignWith::SignWithKeychain(sign_keychain) => {
                sign_keychain
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config.clone()),
                        config.credentials_home_dir,
                    )
                    .await
            }
            #[cfg(feature = "ledger")]
            crate::transaction_signature_options::SignWith::SignWithLedger(sign_ledger) => {
                sign_ledger
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
        }
    }
}

'''
'''--- src/commands/tokens/send_near/mod.rs ---
use dialoguer::Input;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct SendNearCommand {
    ///What is the receiver account ID?
    receiver_account_id: crate::types::account_id::AccountId,
    #[interactive_clap(skip_default_input_arg)]
    ///Enter an amount to transfer
    amount_in_near: crate::common::NearBalance,
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_for_transaction::NetworkForTransactionArgs,
}

impl SendNearCommand {
    fn input_amount_in_near(
        _context: &crate::GlobalContext,
    ) -> color_eyre::eyre::Result<crate::common::NearBalance> {
        let input_amount: crate::common::NearBalance = Input::new()
                        .with_prompt("How many NEAR Tokens do you want to transfer? (example: 10NEAR or 0.5near or 10000yoctonear)")
                        .interact_text()
                        ?;
        Ok(input_amount)
    }

    pub async fn process(
        &self,
        config: crate::config::Config,
        owner_account_id: near_primitives::types::AccountId,
    ) -> crate::CliResult {
        let prepopulated_unsigned_transaction = near_primitives::transaction::Transaction {
            signer_id: owner_account_id,
            public_key: near_crypto::PublicKey::empty(near_crypto::KeyType::ED25519),
            nonce: 0,
            receiver_id: self.receiver_account_id.clone().into(),
            block_hash: Default::default(),
            actions: vec![near_primitives::transaction::Action::Transfer(
                near_primitives::transaction::TransferAction {
                    deposit: self.amount_in_near.to_yoctonear(),
                },
            )],
        };

        match self.network.get_sign_option() {
            crate::transaction_signature_options::SignWith::SignWithPlaintextPrivateKey(
                sign_private_key,
            ) => {
                sign_private_key
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
            crate::transaction_signature_options::SignWith::SignWithKeychain(sign_keychain) => {
                sign_keychain
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config.clone()),
                        config.credentials_home_dir,
                    )
                    .await
            }
            #[cfg(feature = "ledger")]
            crate::transaction_signature_options::SignWith::SignWithLedger(sign_ledger) => {
                sign_ledger
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
        }
    }
}

'''
'''--- src/commands/tokens/send_nft/mod.rs ---
use dialoguer::Input;
use serde_json::json;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct SendNftCommand {
    ///What is the nft-contract account ID?
    nft_contract_account_id: crate::types::account_id::AccountId,
    ///What is the receiver account ID?
    receiver_account_id: crate::types::account_id::AccountId,
    ///Enter an token_id for NFT
    token_id: String,
    #[interactive_clap(long = "prepaid-gas")]
    #[interactive_clap(skip_default_input_arg)]
    ///Enter gas for function call
    gas: crate::common::NearGas,
    #[interactive_clap(long = "attached-deposit")]
    #[interactive_clap(skip_default_input_arg)]
    ///Enter deposit for a function call
    deposit: crate::common::NearBalance,
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_for_transaction::NetworkForTransactionArgs,
}

impl SendNftCommand {
    fn input_gas(
        _context: &crate::GlobalContext,
    ) -> color_eyre::eyre::Result<crate::common::NearGas> {
        println!();
        let gas: u64 = loop {
            let input_gas: crate::common::NearGas = Input::new()
                .with_prompt("Enter gas for function call")
                .with_initial_text("100 TeraGas")
                .interact_text()?;
            let gas: u64 = match input_gas {
                crate::common::NearGas { inner: num } => num,
            };
            if gas <= 300000000000000 {
                break gas;
            } else {
                println!("You need to enter a value of no more than 300 TERAGAS")
            }
        };
        Ok(gas.into())
    }

    fn input_deposit(
        _context: &crate::GlobalContext,
    ) -> color_eyre::eyre::Result<crate::common::NearBalance> {
        println!();
        let deposit: crate::common::NearBalance = Input::new()
            .with_prompt(
                "Enter deposit for a function call (example: 10NEAR or 0.5near or 10000yoctonear).",
            )
            .with_initial_text("1 yoctoNEAR")
            .interact_text()?;
        Ok(deposit)
    }

    pub async fn process(
        &self,
        config: crate::config::Config,
        owner_account_id: near_primitives::types::AccountId,
    ) -> crate::CliResult {
        let method_name = "nft_transfer".to_string();
        let args = json!({
            "receiver_id": self.receiver_account_id.to_string(),
            "token_id": self.token_id
        })
        .to_string()
        .into_bytes();
        let prepopulated_unsigned_transaction = near_primitives::transaction::Transaction {
            signer_id: owner_account_id,
            public_key: near_crypto::PublicKey::empty(near_crypto::KeyType::ED25519),
            nonce: 0,
            receiver_id: self.nft_contract_account_id.clone().into(),
            block_hash: Default::default(),
            actions: vec![near_primitives::transaction::Action::FunctionCall(
                near_primitives::transaction::FunctionCallAction {
                    method_name,
                    args,
                    gas: self.gas.clone().inner,
                    deposit: self.deposit.clone().to_yoctonear(),
                },
            )],
        };

        match self.network.get_sign_option() {
            crate::transaction_signature_options::SignWith::SignWithPlaintextPrivateKey(
                sign_private_key,
            ) => {
                sign_private_key
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
            crate::transaction_signature_options::SignWith::SignWithKeychain(sign_keychain) => {
                sign_keychain
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config.clone()),
                        config.credentials_home_dir,
                    )
                    .await
            }
            #[cfg(feature = "ledger")]
            crate::transaction_signature_options::SignWith::SignWithLedger(sign_ledger) => {
                sign_ledger
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
        }
    }
}

'''
'''--- src/commands/tokens/view_ft_balance/mod.rs ---
use serde_json::json;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct ViewFtBalance {
    ///What is the ft-contract account ID?
    ft_contract_account_id: crate::types::account_id::AccountId,
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_view_at_block::NetworkViewAtBlockArgs,
}

impl ViewFtBalance {
    pub async fn process(
        &self,
        config: crate::config::Config,
        owner_account_id: near_primitives::types::AccountId,
    ) -> crate::CliResult {
        let method_name = "ft_balance_of".to_string();
        let args = json!({
            "account_id": owner_account_id.to_string(),
        })
        .to_string()
        .into_bytes();
        let query_view_method_response = self
            .network
            .get_network_config(config)
            .json_rpc_client()?
            .call(near_jsonrpc_client::methods::query::RpcQueryRequest {
                block_reference: self.network.get_block_ref(),
                request: near_primitives::views::QueryRequest::CallFunction {
                    account_id: self.ft_contract_account_id.clone().into(),
                    method_name,
                    args: near_primitives::types::FunctionArgs::from(args),
                },
            })
            .await
            .map_err(|err| {
                color_eyre::Report::msg(format!("Failed to fetch query for view method: {:?}", err))
            })?;
        let call_result =
            if let near_jsonrpc_primitives::types::query::QueryResponseKind::CallResult(result) =
                query_view_method_response.kind
            {
                result.result
            } else {
                return Err(color_eyre::Report::msg(format!("Error call result")));
            };

        let serde_call_result = if call_result.is_empty() {
            serde_json::Value::Null
        } else {
            serde_json::from_slice(&call_result)
                .map_err(|err| color_eyre::Report::msg(format!("serde json: {:?}", err)))?
        };
        println!(
            "\n{} account has {} FT tokens (FT-contract: {})",
            owner_account_id.to_string(),
            serde_json::to_string_pretty(&serde_call_result)?,
            self.ft_contract_account_id
        );
        Ok(())
    }
}

'''
'''--- src/commands/tokens/view_near_balance/mod.rs ---
#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct ViewNearBalance {
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_view_at_block::NetworkViewAtBlockArgs,
}

impl ViewNearBalance {
    pub async fn process(
        &self,
        config: crate::config::Config,
        owner_account_id: near_primitives::types::AccountId,
    ) -> crate::CliResult {
        let account_transfer_allowance = crate::common::get_account_transfer_allowance(
            self.network.get_network_config(config),
            owner_account_id,
            self.network.get_block_ref(),
        )
        .await?;
        println! {"{}", &account_transfer_allowance};
        Ok(())
    }
}

'''
'''--- src/commands/tokens/view_nft_assets/mod.rs ---
use serde_json::json;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct ViewNftAssets {
    ///What is the nft-contract account ID?
    nft_contract_account_id: crate::types::account_id::AccountId,
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_view_at_block::NetworkViewAtBlockArgs,
}

impl ViewNftAssets {
    pub async fn process(
        &self,
        config: crate::config::Config,
        owner_account_id: near_primitives::types::AccountId,
    ) -> crate::CliResult {
        let method_name = "nft_tokens_for_owner".to_string();
        let args = json!({
            "account_id": owner_account_id.to_string(),
        })
        .to_string()
        .into_bytes();
        let query_view_method_response = self
            .network
            .get_network_config(config)
            .json_rpc_client()?
            .call(near_jsonrpc_client::methods::query::RpcQueryRequest {
                block_reference: self.network.get_block_ref(),
                request: near_primitives::views::QueryRequest::CallFunction {
                    account_id: self.nft_contract_account_id.clone().into(),
                    method_name,
                    args: near_primitives::types::FunctionArgs::from(args),
                },
            })
            .await
            .map_err(|err| {
                color_eyre::Report::msg(format!("Failed to fetch query for view method: {:?}", err))
            })?;
        let call_result =
            if let near_jsonrpc_primitives::types::query::QueryResponseKind::CallResult(result) =
                query_view_method_response.kind
            {
                result.result
            } else {
                return Err(color_eyre::Report::msg(format!("Error call result")));
            };

        let serde_call_result = if call_result.is_empty() {
            serde_json::Value::Null
        } else {
            serde_json::from_slice(&call_result)
                .map_err(|err| color_eyre::Report::msg(format!("serde json: {:?}", err)))?
        };
        println!("\n{} account has NFT tokens:", owner_account_id.to_string());
        println!("{}", serde_json::to_string_pretty(&serde_call_result)?);
        Ok(())
    }
}

'''
'''--- src/commands/transaction/construct_transaction/add_access_key/access_key_type/mod.rs ---
use dialoguer::{console::Term, theme::ColorfulTheme, Input, Select};
use std::str::FromStr;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct FullAccessType {
    #[interactive_clap(subcommand)]
    access_key_mode: super::AccessKeyMode,
}

impl FullAccessType {
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        self.access_key_mode
            .process(
                config,
                prepopulated_unsigned_transaction,
                near_primitives::account::AccessKeyPermission::FullAccess,
            )
            .await
    }
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[interactive_clap(skip_default_from_cli)]
pub struct FunctionCallType {
    #[interactive_clap(long)]
    #[interactive_clap(skip_default_from_cli_arg)]
    #[interactive_clap(skip_default_input_arg)]
    allowance: Option<crate::common::NearBalance>,
    #[interactive_clap(long)]
    ///Enter a receiver to use by this access key to pay for function call gas and transaction fees.
    receiver_account_id: crate::types::account_id::AccountId,
    #[interactive_clap(long)]
    #[interactive_clap(skip_default_from_cli_arg)]
    #[interactive_clap(skip_default_input_arg)]
    method_names: crate::types::vec_string::VecString,
    #[interactive_clap(subcommand)]
    access_key_mode: super::AccessKeyMode,
}

impl FunctionCallType {
    pub fn from_cli(
        optional_clap_variant: Option<<FunctionCallType as interactive_clap::ToCli>::CliVariant>,
        context: crate::GlobalContext,
    ) -> color_eyre::eyre::Result<Option<Self>> {
        let allowance: Option<crate::common::NearBalance> = match optional_clap_variant
            .clone()
            .and_then(|clap_variant| clap_variant.allowance)
        {
            Some(cli_allowance) => Some(cli_allowance),
            None => FunctionCallType::input_allowance()?,
        };
        let receiver_account_id = match optional_clap_variant
            .clone()
            .and_then(|clap_variant| clap_variant.receiver_account_id)
        {
            Some(cli_receiver_account_id) => cli_receiver_account_id,
            None => Self::input_receiver_account_id(&context)?,
        };
        let method_names: crate::types::vec_string::VecString = match optional_clap_variant
            .clone()
            .and_then(|clap_variant| clap_variant.method_names)
        {
            Some(cli_method_names) => {
                if cli_method_names.0.is_empty() {
                    crate::types::vec_string::VecString(vec![])
                } else {
                    cli_method_names
                }
            }
            None => FunctionCallType::input_method_names()?,
        };
        let optional_access_key_mode =
            match optional_clap_variant.and_then(|clap_variant| clap_variant.access_key_mode) {
                Some(cli_access_key_mode) => {
                    super::AccessKeyMode::from_cli(Some(cli_access_key_mode), context)?
                }
                None => super::AccessKeyMode::choose_variant(context)?,
            };
        let access_key_mode = if let Some(access_key_mode) = optional_access_key_mode {
            access_key_mode
        } else {
            return Ok(None);
        };
        Ok(Some(Self {
            allowance,
            receiver_account_id,
            method_names,
            access_key_mode,
        }))
    }
}

impl FunctionCallType {
    pub fn input_method_names() -> color_eyre::eyre::Result<crate::types::vec_string::VecString> {
        println!();
        let choose_input = vec![
            "Yes, I want to input a list of method names that can be used",
            "No, I don't to input a list of method names that can be used",
        ];
        let select_choose_input = Select::with_theme(&ColorfulTheme::default())
            .with_prompt("Do You want to input a list of method names that can be used")
            .items(&choose_input)
            .default(0)
            .interact_on_opt(&Term::stderr())?;
        match select_choose_input {
            Some(0) => {
                let mut input_method_names: String = Input::new()
                    .with_prompt("Enter a comma-separated list of method names that will be allowed to be called in a transaction signed by this access key.")
                    .interact_text()
                    ?;
                if input_method_names.contains("\"") {
                    input_method_names.clear()
                };
                if input_method_names.is_empty() {
                    Ok(crate::types::vec_string::VecString(vec![]))
                } else {
                    crate::types::vec_string::VecString::from_str(&input_method_names)
                }
            }
            Some(1) => Ok(crate::types::vec_string::VecString(vec![])),
            _ => unreachable!("Error"),
        }
    }

    pub fn input_allowance() -> color_eyre::eyre::Result<Option<crate::common::NearBalance>> {
        println!();
        let choose_input = vec![
            "Yes, I want to input allowance for receiver ID",
            "No, I don't to input allowance for receiver ID",
        ];
        let select_choose_input = Select::with_theme(&ColorfulTheme::default())
            .with_prompt("Do You want to input an allowance for receiver ID")
            .items(&choose_input)
            .default(0)
            .interact_on_opt(&Term::stderr())?;
        match select_choose_input {
            Some(0) => {
                let allowance_near_balance: crate::common::NearBalance = Input::new()
                    .with_prompt("Enter an allowance which is a balance limit to use by this access key to pay for function call gas and transaction fees. (example: 10NEAR or 0.5near or 10000yoctonear)")
                    .interact_text()
                    ?;
                Ok(Some(allowance_near_balance))
            }
            Some(1) => Ok(None),
            _ => unreachable!("Error"),
        }
    }

    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        let permission = near_primitives::account::AccessKeyPermission::FunctionCall(
            near_primitives::account::FunctionCallPermission {
                allowance: {
                    match self.allowance.clone() {
                        Some(allowance) => Some(allowance.to_yoctonear()),
                        None => None,
                    }
                },
                receiver_id: self.receiver_account_id.to_string().clone(),
                method_names: self.method_names.clone().into(),
            },
        );
        self.access_key_mode
            .process(config, prepopulated_unsigned_transaction, permission)
            .await
    }
}

'''
'''--- src/commands/transaction/construct_transaction/add_access_key/mod.rs ---
use strum::{EnumDiscriminants, EnumIter, EnumMessage};

mod access_key_type;
mod use_manually_provided_seed_phrase;
mod use_public_key;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct AddKeyCommand {
    #[interactive_clap(subcommand)]
    permission: AccessKeyPermission,
}

impl AddKeyCommand {
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        match self.permission.clone() {
            AccessKeyPermission::GrantFullAccess(full_access_type) => {
                full_access_type
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            AccessKeyPermission::GrantFunctionCallAccess(function_call_type) => {
                function_call_type
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
        }
    }
}

#[derive(Debug, Clone, EnumDiscriminants, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///Select a permission that you want to add to the access key
pub enum AccessKeyPermission {
    #[strum_discriminants(strum(
        message = "grant-full-access           - A permission with full access"
    ))]
    /// Provide data for a full access key
    GrantFullAccess(self::access_key_type::FullAccessType),
    #[strum_discriminants(strum(
        message = "grant-function-call-access  - A permission with function call"
    ))]
    /// Provide data for a function-call access key
    GrantFunctionCallAccess(self::access_key_type::FunctionCallType),
}

#[derive(Debug, Clone, EnumDiscriminants, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///Add an access key for this account
pub enum AccessKeyMode {
    #[strum_discriminants(strum(
        message = "use-manually-provided-seed-prase  - Use the provided seed phrase manually"
    ))]
    ///Use the provided seed phrase manually
    UseManuallyProvidedSeedPhrase(
        self::use_manually_provided_seed_phrase::AddAccessWithSeedPhraseAction,
    ),
    #[strum_discriminants(strum(
        message = "use-manually-provided-public-key  - Use the provided public key manually"
    ))]
    ///Use the provided public key manually
    UseManuallyProvidedPublicKey(self::use_public_key::AddAccessKeyAction),
}

impl AccessKeyMode {
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
        permission: near_primitives::account::AccessKeyPermission,
    ) -> crate::CliResult {
        match self {
            AccessKeyMode::UseManuallyProvidedPublicKey(add_access_key_action) => {
                add_access_key_action
                    .process(config, prepopulated_unsigned_transaction, permission)
                    .await
            }
            AccessKeyMode::UseManuallyProvidedSeedPhrase(add_access_with_seed_phrase_action) => {
                add_access_with_seed_phrase_action
                    .process(config, prepopulated_unsigned_transaction, permission)
                    .await
            }
        }
    }
}

'''
'''--- src/commands/transaction/construct_transaction/add_access_key/use_manually_provided_seed_phrase/mod.rs ---
use async_recursion::async_recursion;
use std::str::FromStr;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct AddAccessWithSeedPhraseAction {
    ///Enter the seed_phrase for this sub-account
    master_seed_phrase: String,
    #[interactive_clap(subcommand)]
    next_action: super::super::BoxNextAction,
}

impl AddAccessWithSeedPhraseAction {
    #[async_recursion(?Send)]
    pub async fn process(
        &self,
        config: crate::config::Config,
        mut prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
        permission: near_primitives::account::AccessKeyPermission,
    ) -> crate::CliResult {
        let seed_phrase_hd_path_default = slip10::BIP32Path::from_str("m/44'/397'/0'").unwrap();
        let public_key = crate::common::get_public_key_from_seed_phrase(
            seed_phrase_hd_path_default,
            &self.master_seed_phrase,
        )?;
        let access_key = near_primitives::account::AccessKey {
            nonce: 0,
            permission,
        };
        let action = near_primitives::transaction::Action::AddKey(
            near_primitives::transaction::AddKeyAction {
                public_key,
                access_key,
            },
        );
        prepopulated_unsigned_transaction.actions.push(action);
        match *self.next_action.clone().inner {
            super::super::NextAction::AddAction(select_action) => {
                select_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            super::super::NextAction::Skip(skip_action) => {
                skip_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
        }
    }
}

'''
'''--- src/commands/transaction/construct_transaction/add_access_key/use_public_key/mod.rs ---
use async_recursion::async_recursion;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct AddAccessKeyAction {
    ///Enter the public key for this account
    public_key: crate::types::public_key::PublicKey,
    #[interactive_clap(subcommand)]
    next_action: super::super::BoxNextAction,
}

impl AddAccessKeyAction {
    #[async_recursion(?Send)]
    pub async fn process(
        &self,
        config: crate::config::Config,
        mut prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
        permission: near_primitives::account::AccessKeyPermission,
    ) -> crate::CliResult {
        let access_key = near_primitives::account::AccessKey {
            nonce: 0,
            permission,
        };
        let action = near_primitives::transaction::Action::AddKey(
            near_primitives::transaction::AddKeyAction {
                public_key: self.public_key.clone().into(),
                access_key,
            },
        );
        prepopulated_unsigned_transaction.actions.push(action);
        match *self.next_action.clone().inner {
            super::super::NextAction::AddAction(select_action) => {
                select_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            super::super::NextAction::Skip(skip_action) => {
                skip_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
        }
    }
}

'''
'''--- src/commands/transaction/construct_transaction/call_function/mod.rs ---
use async_recursion::async_recursion;
use dialoguer::Input;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct CallFunctionAction {
    ///What is the name of the function?
    function_name: String,
    ///Enter arguments to this function
    function_args: String,
    #[interactive_clap(long = "prepaid-gas")]
    #[interactive_clap(skip_default_input_arg)]
    ///Enter gas for function call
    gas: crate::common::NearGas,
    #[interactive_clap(long = "attached-deposit")]
    #[interactive_clap(skip_default_input_arg)]
    ///Enter deposit for a function call
    deposit: crate::common::NearBalance,
    #[interactive_clap(subcommand)]
    next_action: super::BoxNextAction,
}

impl CallFunctionAction {
    fn input_gas(
        _context: &crate::GlobalContext,
    ) -> color_eyre::eyre::Result<crate::common::NearGas> {
        println!();
        let gas: u64 = loop {
            let input_gas: crate::common::NearGas = Input::new()
                .with_prompt("Enter gas for function call")
                .with_initial_text("100 TeraGas")
                .interact_text()?;
            let gas: u64 = match input_gas {
                crate::common::NearGas { inner: num } => num,
            };
            if gas <= 300000000000000 {
                break gas;
            } else {
                println!("You need to enter a value of no more than 300 TERAGAS")
            }
        };
        Ok(gas.into())
    }

    fn input_deposit(
        _context: &crate::GlobalContext,
    ) -> color_eyre::eyre::Result<crate::common::NearBalance> {
        println!();
        let deposit: crate::common::NearBalance = Input::new()
            .with_prompt(
                "Enter deposit for a function call (example: 10NEAR or 0.5near or 10000yoctonear).",
            )
            .with_initial_text("0 NEAR")
            .interact_text()?;
        Ok(deposit)
    }

    #[async_recursion(?Send)]
    pub async fn process(
        &self,
        config: crate::config::Config,
        mut prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        let action = near_primitives::transaction::Action::FunctionCall(
            near_primitives::transaction::FunctionCallAction {
                method_name: self.function_name.clone(),
                args: self.function_args.clone().into_bytes(),
                gas: self.gas.clone().inner,
                deposit: self.deposit.clone().to_yoctonear(),
            },
        );
        prepopulated_unsigned_transaction.actions.push(action);
        match *self.next_action.clone().inner {
            super::NextAction::AddAction(select_action) => {
                select_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            super::NextAction::Skip(skip_action) => {
                skip_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
        }
    }
}

'''
'''--- src/commands/transaction/construct_transaction/create_subaccount/mod.rs ---
use async_recursion::async_recursion;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct CreateSubAccountAction {
    #[interactive_clap(subcommand)]
    next_action: super::BoxNextAction,
}

impl CreateSubAccountAction {
    #[async_recursion(?Send)]
    pub async fn process(
        &self,
        config: crate::config::Config,
        mut prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        let action = near_primitives::transaction::Action::CreateAccount(
            near_primitives::transaction::CreateAccountAction {},
        );
        prepopulated_unsigned_transaction.actions.push(action);
        match *self.next_action.clone().inner {
            super::NextAction::AddAction(select_action) => {
                select_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            super::NextAction::Skip(skip_action) => {
                skip_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
        }
    }
}

'''
'''--- src/commands/transaction/construct_transaction/delete_access_key/mod.rs ---
use async_recursion::async_recursion;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct DeleteKeyCommand {
    ///Enter the public key You wish to delete
    public_key: crate::types::public_key::PublicKey,
    #[interactive_clap(subcommand)]
    next_action: super::BoxNextAction,
}

impl DeleteKeyCommand {
    #[async_recursion(?Send)]
    pub async fn process(
        &self,
        config: crate::config::Config,
        mut prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        let action = near_primitives::transaction::Action::DeleteKey(
            near_primitives::transaction::DeleteKeyAction {
                public_key: self.public_key.clone().into(),
            },
        );
        prepopulated_unsigned_transaction.actions.push(action);
        match *self.next_action.clone().inner {
            super::NextAction::AddAction(select_action) => {
                select_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            super::NextAction::Skip(skip_action) => {
                skip_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
        }
    }
}

'''
'''--- src/commands/transaction/construct_transaction/delete_account/mod.rs ---
use async_recursion::async_recursion;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct DeleteAccountAction {
    #[interactive_clap(long)]
    ///Enter the beneficiary ID to delete this account ID
    beneficiary_id: crate::types::account_id::AccountId,
    #[interactive_clap(subcommand)]
    next_action: super::BoxNextAction,
}

impl DeleteAccountAction {
    #[async_recursion(?Send)]
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        let beneficiary_id: near_primitives::types::AccountId = self.beneficiary_id.clone().into();
        let action = near_primitives::transaction::Action::DeleteAccount(
            near_primitives::transaction::DeleteAccountAction { beneficiary_id },
        );
        let mut actions = prepopulated_unsigned_transaction.actions.clone();
        actions.push(action);
        let unsigned_transaction = near_primitives::transaction::Transaction {
            actions,
            ..prepopulated_unsigned_transaction
        };
        match *self.next_action.clone().inner {
            super::NextAction::AddAction(select_action) => {
                select_action.process(config, unsigned_transaction).await
            }
            super::NextAction::Skip(skip_action) => {
                skip_action.process(config, unsigned_transaction).await
            }
        }
    }
}

'''
'''--- src/commands/transaction/construct_transaction/deploy_contract/initialize_mode/call_function_type/mod.rs ---
use async_recursion::async_recursion;
use dialoguer::Input;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct CallFunctionAction {
    ///What is the name of the function?
    function_name: String,
    ///Enter arguments to this function
    function_args: String,
    #[interactive_clap(long = "prepaid-gas")]
    #[interactive_clap(skip_default_input_arg)]
    ///Enter gas for function call
    gas: crate::common::NearGas,
    #[interactive_clap(long = "attached-deposit")]
    #[interactive_clap(skip_default_input_arg)]
    ///Enter deposit for a function call
    deposit: crate::common::NearBalance,
    #[interactive_clap(subcommand)]
    next_action: super::super::super::BoxNextAction,
}

impl CallFunctionAction {
    fn input_gas(
        _context: &crate::GlobalContext,
    ) -> color_eyre::eyre::Result<crate::common::NearGas> {
        println!();
        let gas: u64 = loop {
            let input_gas: crate::common::NearGas = Input::new()
                .with_prompt("Enter gas for function call")
                .with_initial_text("100 TeraGas")
                .interact_text()?;
            let gas: u64 = match input_gas {
                crate::common::NearGas { inner: num } => num,
            };
            if gas <= 300000000000000 {
                break gas;
            } else {
                println!("You need to enter a value of no more than 300 TERAGAS")
            }
        };
        Ok(gas.into())
    }

    fn input_deposit(
        _context: &crate::GlobalContext,
    ) -> color_eyre::eyre::Result<crate::common::NearBalance> {
        println!();
        let deposit: crate::common::NearBalance = Input::new()
            .with_prompt(
                "Enter deposit for a function call (example: 10NEAR or 0.5near or 10000yoctonear).",
            )
            .with_initial_text("0 NEAR")
            .interact_text()?;
        Ok(deposit)
    }

    #[async_recursion(?Send)]
    pub async fn process(
        &self,
        config: crate::config::Config,
        mut prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        let action = near_primitives::transaction::Action::FunctionCall(
            near_primitives::transaction::FunctionCallAction {
                method_name: self.function_name.clone(),
                args: self.function_args.clone().into_bytes(),
                gas: self.gas.clone().inner,
                deposit: self.deposit.clone().to_yoctonear(),
            },
        );
        prepopulated_unsigned_transaction.actions.push(action);
        match *self.next_action.clone().inner {
            super::super::super::NextAction::AddAction(select_action) => {
                select_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            super::super::super::NextAction::Skip(skip_action) => {
                skip_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
        }
    }
}

'''
'''--- src/commands/transaction/construct_transaction/deploy_contract/initialize_mode/mod.rs ---
use async_recursion::async_recursion;
use strum::{EnumDiscriminants, EnumIter, EnumMessage};

mod call_function_type;

#[derive(Debug, Clone, EnumDiscriminants, interactive_clap_derive::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///Select the need for initialization
pub enum InitializeMode {
    /// Add an initialize
    #[strum_discriminants(strum(message = "with-init-call     - Add an initialize"))]
    WithInitCall(self::call_function_type::CallFunctionAction),
    /// Don't add an initialize
    #[strum_discriminants(strum(message = "without-init-call  - Don't add an initialize"))]
    WithoutInitCall(NoInitialize),
}

impl InitializeMode {
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        match self {
            InitializeMode::WithInitCall(call_function_action) => {
                call_function_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            InitializeMode::WithoutInitCall(no_initialize) => {
                no_initialize
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
        }
    }
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct NoInitialize {
    #[interactive_clap(subcommand)]
    next_action: super::super::BoxNextAction,
}

impl NoInitialize {
    #[async_recursion(?Send)]
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        match *self.next_action.clone().inner {
            super::super::NextAction::AddAction(select_action) => {
                select_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            super::super::NextAction::Skip(skip_action) => {
                skip_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
        }
    }
}

'''
'''--- src/commands/transaction/construct_transaction/deploy_contract/mod.rs ---
mod initialize_mode;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct Contract {
    #[interactive_clap(named_arg)]
    ///Specify a path to wasm file
    use_file: ContractFile,
}

impl Contract {
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        self.use_file
            .process(config, prepopulated_unsigned_transaction)
            .await
    }
}

#[derive(Debug, Clone, interactive_clap_derive::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct ContractFile {
    ///What is a file location of the contract?
    pub file_path: crate::types::path_buf::PathBuf,
    #[interactive_clap(subcommand)]
    initialize: self::initialize_mode::InitializeMode,
}

impl ContractFile {
    pub async fn process(
        &self,
        config: crate::config::Config,
        mut prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        let code = std::fs::read(&self.file_path.0.clone()).map_err(|err| {
            color_eyre::Report::msg(format!(
                "Failed to open or read the file: {:?}.\nError: {:?}",
                &self.file_path.0.clone(),
                err
            ))
        })?;
        let action = near_primitives::transaction::Action::DeployContract(
            near_primitives::transaction::DeployContractAction { code },
        );
        prepopulated_unsigned_transaction.actions.push(action);
        self.initialize
            .process(config, prepopulated_unsigned_transaction)
            .await
    }
}

'''
'''--- src/commands/transaction/construct_transaction/mod.rs ---
use strum::{EnumDiscriminants, EnumIter, EnumMessage};

mod add_access_key;
mod call_function;
mod create_subaccount;
mod delete_access_key;
mod delete_account;
mod deploy_contract;
mod stake_near_tokens;
mod transfer_tokens;

#[derive(Debug, Clone, clap::Parser)]
pub enum CliSkipNextAction {
    ///Go to transaction signing
    Skip(CliSkipAction),
}

impl CliSkipNextAction {
    pub fn to_cli_args(&self) -> std::collections::VecDeque<String> {
        match self {
            Self::Skip(subcommand) => {
                // // let mut args = ;  it is not implemented now!!!
                // // args.push_front("skip".to_owned());
                // // args
                // subcommand.to_cli_args()
                let mut args = subcommand.to_cli_args();
                args.push_front("skip".to_owned());
                args
            }
        }
    }
}

#[derive(Debug, Clone, EnumDiscriminants, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///Select an action that you want to add to the action:
pub enum NextAction {
    #[strum_discriminants(strum(message = "add-action   - Select a new action"))]
    /// Choose next action
    AddAction(SelectAction),
    #[strum_discriminants(strum(message = "skip         - Skip adding a new action"))]
    /// Go to transaction signing
    Skip(SkipAction),
}

impl From<NextAction> for CliSkipNextAction {
    fn from(next_action: NextAction) -> Self {
        match next_action {
            NextAction::AddAction(_select_action) => Self::Skip(CliSkipAction { network: None }),
            NextAction::Skip(skip_action) => Self::Skip(skip_action.into()),
        }
    }
}

impl From<CliSkipNextAction> for CliNextAction {
    fn from(cli_skip_next_action: CliSkipNextAction) -> Self {
        match cli_skip_next_action {
            CliSkipNextAction::Skip(skip_action) => Self::Skip(skip_action),
        }
    }
}

impl NextAction {
    pub fn from_cli_skip_next_action(
        item: Option<CliSkipNextAction>,
        context: crate::GlobalContext,
    ) -> color_eyre::eyre::Result<Option<Self>> {
        match item {
            Some(CliSkipNextAction::Skip(cli_skip_action)) => {
                let optional_skip_action =
                    SkipAction::from_cli(Some(cli_skip_action), context.clone())?;
                if let Some(skip_action) = optional_skip_action {
                    Ok(Some(Self::Skip(skip_action)))
                } else {
                    Self::choose_variant(context.clone())
                }
            }
            None => Self::choose_variant(context.clone()),
        }
    }
}
//-------------------------------------
/// This mode is not provided now
// impl CliNextAction {
//     fn from(item: CliSkipNextAction) -> color_eyre::eyre::Result<Self> {
//         match item {
//             CliSkipNextAction::Skip(cli_skip_action) => Ok(Self::Skip(cli_skip_action)),
//         }
//     }
// }
//--------------------------------------
impl NextAction {
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        match self {
            NextAction::AddAction(select_action) => {
                select_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            NextAction::Skip(skip_action) => {
                skip_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
        }
    }
}

#[derive(Debug, Clone)]
pub struct BoxNextAction {
    inner: Box<NextAction>,
}

impl interactive_clap::ToCli for BoxNextAction {
    type CliVariant = CliSkipNextAction;
}

impl From<BoxNextAction> for CliSkipNextAction {
    fn from(box_next_action: BoxNextAction) -> Self {
        Self::from(*box_next_action.inner)
    }
}

impl BoxNextAction {
    fn choose_variant(context: crate::GlobalContext) -> color_eyre::eyre::Result<Option<Self>> {
        let optional_next_action = NextAction::choose_variant(context)?;
        if let Some(next_action) = optional_next_action {
            Ok(Some(Self {
                inner: Box::new(next_action),
            }))
        } else {
            return Ok(None);
        }
    }
}

impl BoxNextAction {
    pub fn from_cli(
        optional_clap_variant: Option<<BoxNextAction as interactive_clap::ToCli>::CliVariant>,
        context: crate::GlobalContext,
    ) -> color_eyre::eyre::Result<Option<Self>> {
        let optional_next_action =
            NextAction::from_cli(optional_clap_variant.map(Into::into), context)?;
        if let Some(next_action) = optional_next_action {
            Ok(Some(Self {
                inner: Box::new(next_action),
            }))
        } else {
            return Ok(None);
        }
    }
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct SelectAction {
    #[interactive_clap(subcommand)]
    transaction_subcommand: ActionSubcommand,
}

impl SelectAction {
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        self.transaction_subcommand
            .process(config, prepopulated_unsigned_transaction)
            .await
    }
}

#[derive(Debug, Clone, EnumDiscriminants, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///Select an action that you want to add to the action:
pub enum ActionSubcommand {
    #[strum_discriminants(strum(
        message = "send-near            - The transfer is carried out in NEAR tokens"
    ))]
    ///Specify data for transfer tokens
    SendNear(self::transfer_tokens::SendNearCommand),
    #[strum_discriminants(strum(
        message = "call-function        - Execute function (contract method)"
    ))]
    ///Specify data to call the function
    CallFunction(self::call_function::CallFunctionAction),
    #[strum_discriminants(strum(message = "stake-near-tokens    - Stake NEAR Tokens"))]
    ///Specify data to stake NEAR Tokens
    StakeNearTokens(self::stake_near_tokens::StakeNearTokensAction),
    #[strum_discriminants(strum(message = "create-subaccount    - Create a new sub-account"))]
    ///Specify data to create a sub-account
    CreateSubaccount(self::create_subaccount::CreateSubAccountAction),
    #[strum_discriminants(strum(message = "delete-account       - Delete an account"))]
    ///Specify data to delete an account
    DeleteAccount(self::delete_account::DeleteAccountAction),
    #[strum_discriminants(strum(
        message = "add-key              - Add an access key to an account"
    ))]
    ///Specify the data to add an access key to the account
    AddKey(self::add_access_key::AddKeyCommand),
    #[strum_discriminants(strum(
        message = "delete-key           - Delete an access key from an account"
    ))]
    ///Specify the data to delete the access key to the account
    DeleteKey(self::delete_access_key::DeleteKeyCommand),
    #[strum_discriminants(strum(message = "deploy               - Add a new contract code"))]
    ///Specify the details to deploy the contract code
    Deploy(self::deploy_contract::Contract),
}

impl ActionSubcommand {
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        match self {
            ActionSubcommand::SendNear(args_transfer) => {
                args_transfer
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            ActionSubcommand::CallFunction(args_function) => {
                args_function
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            ActionSubcommand::StakeNearTokens(args_stake) => {
                args_stake
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            ActionSubcommand::CreateSubaccount(args_create_account) => {
                args_create_account
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            ActionSubcommand::DeleteAccount(args_delete_account) => {
                args_delete_account
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            ActionSubcommand::AddKey(args_add_key_command) => {
                args_add_key_command
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            ActionSubcommand::DeleteKey(args_delete_access_key) => {
                args_delete_access_key
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            ActionSubcommand::Deploy(args_contract_file) => {
                args_contract_file
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
        }
    }
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct SkipAction {
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network_for_transaction::NetworkForTransactionArgs,
}
//------------------------------------
// impl From<SelectAction> for CliSkipAction {
//     fn from(select_action: SelectAction) -> Self {
//         Self{
//             sign_option:
//         }
//     }
// }
//-----------------------------------------

impl SkipAction {
    pub async fn process(
        &self,
        config: crate::config::Config,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        match self.network.get_sign_option() {
            crate::transaction_signature_options::SignWith::SignWithPlaintextPrivateKey(
                sign_private_key,
            ) => {
                sign_private_key
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
            crate::transaction_signature_options::SignWith::SignWithKeychain(sign_keychain) => {
                sign_keychain
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config.clone()),
                        config.credentials_home_dir,
                    )
                    .await
            }
            #[cfg(feature = "ledger")]
            crate::transaction_signature_options::SignWith::SignWithLedger(sign_ledger) => {
                sign_ledger
                    .process(
                        prepopulated_unsigned_transaction,
                        self.network.get_network_config(config),
                    )
                    .await
            }
        }
    }
}

'''
'''--- src/commands/transaction/construct_transaction/stake_near_tokens/mod.rs ---
use async_recursion::async_recursion;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct StakeNearTokensAction {
    stake_amount: crate::common::NearBalance,
    public_key: crate::types::public_key::PublicKey,
    #[interactive_clap(subcommand)]
    next_action: super::BoxNextAction,
}

impl StakeNearTokensAction {
    #[async_recursion(?Send)]
    pub async fn process(
        &self,
        config: crate::config::Config,
        mut prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        let action = near_primitives::transaction::Action::Stake(
            near_primitives::transaction::StakeAction {
                stake: self.stake_amount.to_yoctonear(),
                public_key: self.public_key.clone().into(),
            },
        );
        prepopulated_unsigned_transaction.actions.push(action);
        match *self.next_action.clone().inner {
            super::NextAction::AddAction(select_action) => {
                select_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            super::NextAction::Skip(skip_action) => {
                skip_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
        }
    }
}

'''
'''--- src/commands/transaction/construct_transaction/transfer_tokens/mod.rs ---
use async_recursion::async_recursion;
use dialoguer::Input;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct SendNearCommand {
    #[interactive_clap(skip_default_input_arg)]
    ///Enter an amount to transfer
    amount_in_near: crate::common::NearBalance,
    #[interactive_clap(subcommand)]
    next_action: super::BoxNextAction,
}

impl SendNearCommand {
    fn input_amount_in_near(
        _context: &crate::GlobalContext,
    ) -> color_eyre::eyre::Result<crate::common::NearBalance> {
        let input_amount: crate::common::NearBalance = Input::new()
                        .with_prompt("How many NEAR Tokens do you want to transfer? (example: 10NEAR or 0.5near or 10000yoctonear)")
                        .interact_text()
                        ?;
        Ok(input_amount)
    }

    #[async_recursion(?Send)]
    pub async fn process(
        &self,
        config: crate::config::Config,
        mut prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
    ) -> crate::CliResult {
        let action = near_primitives::transaction::Action::Transfer(
            near_primitives::transaction::TransferAction {
                deposit: self.amount_in_near.to_yoctonear(),
            },
        );
        prepopulated_unsigned_transaction.actions.push(action);
        match *self.next_action.clone().inner {
            super::NextAction::AddAction(select_action) => {
                select_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
            super::NextAction::Skip(skip_action) => {
                skip_action
                    .process(config, prepopulated_unsigned_transaction)
                    .await
            }
        }
    }
}

'''
'''--- src/commands/transaction/mod.rs ---
use strum::{EnumDiscriminants, EnumIter, EnumMessage};

mod construct_transaction;
mod view_status;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct TransactionCommands {
    #[interactive_clap(subcommand)]
    transaction_actions: TransactionActions,
}

impl TransactionCommands {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        self.transaction_actions.process(config).await
    }
}

#[derive(Debug, EnumDiscriminants, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///Сhoose action for transaction
pub enum TransactionActions {
    #[strum_discriminants(strum(message = "view-status            - View a transaction status"))]
    ///Execute function (contract method)
    ViewStatus(self::view_status::TransactionInfo),
    #[strum_discriminants(strum(
        message = "construct-transaction  - Construct a new transaction"
    ))]
    ///Construct a new transaction
    ConstructTransaction(TransactionAccounts),
}

impl TransactionActions {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        match self {
            Self::ViewStatus(transaction_info) => transaction_info.process(config).await,
            Self::ConstructTransaction(transaction_accounts) => {
                transaction_accounts.process(config).await
            }
        }
    }
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct TransactionAccounts {
    ///What is the sender account ID?
    sender_account_id: crate::types::account_id::AccountId,
    ///What is the receiver account ID?
    receiver_account_id: crate::types::account_id::AccountId,
    #[interactive_clap(subcommand)]
    next_actions: self::construct_transaction::NextAction,
}

impl TransactionAccounts {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        let prepopulated_unsigned_transaction = near_primitives::transaction::Transaction {
            signer_id: self.sender_account_id.clone().into(),
            public_key: near_crypto::PublicKey::empty(near_crypto::KeyType::ED25519),
            nonce: 0,
            receiver_id: self.receiver_account_id.clone().into(),
            block_hash: Default::default(),
            actions: vec![],
        };
        self.next_actions
            .process(config, prepopulated_unsigned_transaction)
            .await
    }
}

'''
'''--- src/commands/transaction/view_status/mod.rs ---
use std::str::FromStr;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct TransactionInfo {
    ///Enter the hash of the transaction you need to view
    transaction_hash: String,
    ///What is the signer account ID?
    signer_account_id: crate::types::account_id::AccountId,
    #[interactive_clap(named_arg)]
    ///Select network
    network: crate::network::Network,
}

impl TransactionInfo {
    pub async fn process(&self, config: crate::config::Config) -> crate::CliResult {
        let query_view_transaction_status = self.network.get_network_config(config).json_rpc_client()?
            .call(near_jsonrpc_client::methods::EXPERIMENTAL_tx_status::RpcTransactionStatusRequest {
                transaction_info: near_jsonrpc_client::methods::EXPERIMENTAL_tx_status::TransactionInfo::TransactionId {
                    hash: near_primitives::hash::CryptoHash::from_str(&self.transaction_hash).unwrap(),
                    account_id: self.signer_account_id.clone().into()
                }
            })
            .await
            .map_err(|err| {
                color_eyre::Report::msg(format!(
                    "Failed to fetch query for view transaction: {:?}",
                    err
                ))
            })?;
        println!("Transaction status: {:#?}", query_view_transaction_status);
        Ok(())
    }
}

'''
'''--- src/common.rs ---
use std::convert::{TryFrom, TryInto};
use std::io::Write;
use std::str::FromStr;

use near_primitives::{
    borsh::BorshDeserialize,
    hash::CryptoHash,
    types::{AccountId, BlockReference},
    views::{AccessKeyPermissionView, QueryRequest},
};

pub type CliResult = color_eyre::eyre::Result<()>;

use dialoguer::{theme::ColorfulTheme, Select};
use strum::{EnumMessage, IntoEnumIterator};
pub fn prompt_variant<T>(prompt: &str) -> T
where
    T: IntoEnumIterator + EnumMessage,
    T: Copy + Clone,
{
    let variants = T::iter().collect::<Vec<_>>();
    let actions = variants
        .iter()
        .map(|p| {
            p.get_message()
                .unwrap_or_else(|| "error[This entry does not have an option message!!]")
                .to_owned()
        })
        .collect::<Vec<_>>();

    let selected = Select::with_theme(&ColorfulTheme::default())
        .with_prompt(prompt)
        .items(&actions)
        .default(0)
        .interact()
        .unwrap();

    variants[selected]
}

// #[derive(Debug, Clone)]
// pub enum ViewItems {
//     ViewAccountSummary,
//     ViewAccessKeyList,
//     ViewNonce,
//     ViewCallFunction,
//     ViewContractHash,
//     ViewContractCode,
//     ViewContractState,
//     ViewTransactionStatus,
//     ViewNearBalance,
//     ViewFtBalance,
//     ViewNftBalance,
// }

// #[derive(Debug, Clone)]
// pub struct SignerContext {
//     pub connection_config: Option<ConnectionConfig>,
//     pub signer_account_id: crate::types::account_id::AccountId,
// }

#[derive(
    Debug,
    Clone,
    strum_macros::IntoStaticStr,
    strum_macros::EnumString,
    strum_macros::EnumVariantNames,
    smart_default::SmartDefault,
)]
#[strum(serialize_all = "snake_case")]
pub enum OutputFormat {
    #[default]
    Plaintext,
    Json,
}

impl std::fmt::Display for OutputFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            OutputFormat::Plaintext => write!(f, "plaintext"),
            OutputFormat::Json => write!(f, "json"),
        }
    }
}

#[derive(Debug, Clone)]
pub struct SignedTransactionAsBase64 {
    pub inner: near_primitives::transaction::SignedTransaction,
}

impl std::str::FromStr for SignedTransactionAsBase64 {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Self {
            inner: near_primitives::transaction::SignedTransaction::try_from_slice(
                &near_primitives::serialize::from_base64(s)
                    .map_err(|err| format!("base64 transaction sequence is invalid: {}", err))?,
            )
            .map_err(|err| format!("transaction could not be parsed: {}", err))?,
        })
    }
}

impl std::fmt::Display for SignedTransactionAsBase64 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.inner.get_hash())
    }
}

#[derive(Debug, Clone)]
pub struct TransactionAsBase64 {
    pub inner: near_primitives::transaction::Transaction,
}

impl std::str::FromStr for TransactionAsBase64 {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Self {
            inner: near_primitives::transaction::Transaction::try_from_slice(
                &near_primitives::serialize::from_base64(s)
                    .map_err(|err| format!("base64 transaction sequence is invalid: {}", err))?,
            )
            .map_err(|err| format!("transaction could not be parsed: {}", err))?,
        })
    }
}

impl std::fmt::Display for TransactionAsBase64 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.inner.get_hash_and_size().0)
    }
}

#[derive(Debug, Clone)]
pub struct BlockHashAsBase58 {
    pub inner: near_primitives::hash::CryptoHash,
}

impl std::str::FromStr for BlockHashAsBase58 {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Self {
            inner: near_primitives::serialize::from_base(s)
                .map_err(|err| format!("base block hash sequence is invalid: {}", err))?
                .as_slice()
                .try_into()
                .map_err(|err| format!("block hash could not be collected: {}", err))?,
        })
    }
}

impl std::fmt::Display for BlockHashAsBase58 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BlockHash {}", self.inner)
    }
}

const ONE_NEAR: u128 = 10u128.pow(24);

#[derive(Debug, Clone, Default, PartialEq, PartialOrd)]
pub struct NearBalance {
    pub yoctonear_amount: u128,
}

impl NearBalance {
    pub fn from_yoctonear(yoctonear_amount: u128) -> Self {
        Self { yoctonear_amount }
    }

    pub fn to_yoctonear(&self) -> u128 {
        self.yoctonear_amount
    }
}

impl std::fmt::Display for NearBalance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.yoctonear_amount == 0 {
            write!(f, "0 NEAR")
        } else if self.yoctonear_amount % ONE_NEAR == 0 {
            write!(f, "{} NEAR", self.yoctonear_amount / ONE_NEAR,)
        } else {
            write!(
                f,
                "{}.{} NEAR",
                self.yoctonear_amount / ONE_NEAR,
                format!("{:0>24}", (self.yoctonear_amount % ONE_NEAR)).trim_end_matches('0')
            )
        }
    }
}

impl std::str::FromStr for NearBalance {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let num = s.trim().trim_end_matches(char::is_alphabetic).trim();
        let currency = s.trim().trim_start_matches(&num).trim().to_uppercase();
        let yoctonear_amount = match currency.as_str() {
            "N" | "NEAR" => {
                let res_split: Vec<&str> = num.split('.').collect();
                match res_split.len() {
                    2 => {
                        let num_int_yocto = res_split[0]
                            .parse::<u128>()
                            .map_err(|err| format!("Near Balance: {}", err))?
                            .checked_mul(10u128.pow(24))
                            .ok_or_else(|| "Near Balance: underflow or overflow happens")?;
                        let len_fract = res_split[1].len() as u32;
                        let num_fract_yocto = if len_fract <= 24 {
                            res_split[1]
                                .parse::<u128>()
                                .map_err(|err| format!("Near Balance: {}", err))?
                                .checked_mul(10u128.pow(24 - res_split[1].len() as u32))
                                .ok_or_else(|| "Near Balance: underflow or overflow happens")?
                        } else {
                            return Err(
                                "Near Balance: too large fractional part of a number".to_string()
                            );
                        };
                        num_int_yocto
                            .checked_add(num_fract_yocto)
                            .ok_or_else(|| "Near Balance: underflow or overflow happens")?
                    }
                    1 => res_split[0]
                        .parse::<u128>()
                        .map_err(|err| format!("Near Balance: {}", err))?
                        .checked_mul(10u128.pow(24))
                        .ok_or_else(|| "Near Balance: underflow or overflow happens")?,
                    _ => return Err("Near Balance: incorrect number entered".to_string()),
                }
            }
            "YN" | "YNEAR" | "YOCTONEAR" | "YOCTON" => num
                .parse::<u128>()
                .map_err(|err| format!("Near Balance: {}", err))?,
            _ => return Err("Near Balance: incorrect currency value entered".to_string()),
        };
        Ok(NearBalance { yoctonear_amount })
    }
}

impl interactive_clap::ToCli for NearBalance {
    type CliVariant = NearBalance;
}

const ONE_TERA_GAS: u64 = 10u64.pow(12);
const ONE_GIGA_GAS: u64 = 10u64.pow(9);

#[derive(Debug, Clone, Default, PartialEq)]
pub struct NearGas {
    pub inner: u64,
}

impl std::fmt::Display for NearGas {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.inner == 0 {
            write!(f, "0 Gas")
        } else if self.inner >= ONE_TERA_GAS {
            write!(
                f,
                "{}.{:0>3} TeraGas",
                self.inner / ONE_TERA_GAS,
                self.inner / (ONE_TERA_GAS / 1000) % 1000
            )
        } else {
            write!(
                f,
                "{}.{:0>3} GigaGas",
                self.inner / ONE_GIGA_GAS,
                self.inner / (ONE_GIGA_GAS / 1000) % 1000
            )
        }
    }
}

impl std::str::FromStr for NearGas {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let num = s.trim().trim_end_matches(char::is_alphabetic).trim();
        let currency = s.trim().trim_start_matches(&num).trim().to_uppercase();
        let number = match currency.as_str() {
            "T" | "TGAS" | "TERAGAS" => NearGas::into_tera_gas(num)?,
            "GIGAGAS" | "GGAS" => NearGas::into_tera_gas(num)? / 1000,
            _ => return Err("Near Gas: incorrect currency value entered".to_string()),
        };
        Ok(NearGas { inner: number })
    }
}

impl From<u64> for NearGas {
    fn from(num: u64) -> Self {
        Self { inner: num }
    }
}

impl NearGas {
    fn into_tera_gas(num: &str) -> Result<u64, String> {
        let res_split: Vec<&str> = num.split('.').collect();
        match res_split.len() {
            2 => {
                let num_int_gas: u64 = res_split[0]
                    .parse::<u64>()
                    .map_err(|err| format!("Near Gas: {}", err))?
                    .checked_mul(10u64.pow(12))
                    .ok_or_else(|| "Near Gas: underflow or overflow happens")?;
                let len_fract = res_split[1].len() as u32;
                let num_fract_gas = if len_fract <= 12 {
                    res_split[1]
                        .parse::<u64>()
                        .map_err(|err| format!("Near Gas: {}", err))?
                        .checked_mul(10u64.pow(12 - res_split[1].len() as u32))
                        .ok_or_else(|| "Near Gas: underflow or overflow happens")?
                } else {
                    return Err("Near Gas: too large fractional part of a number".to_string());
                };
                Ok(num_int_gas
                    .checked_add(num_fract_gas)
                    .ok_or_else(|| "Near Gas: underflow or overflow happens")?)
            }
            1 => Ok(res_split[0]
                .parse::<u64>()
                .map_err(|err| format!("Near Gas: {}", err))?
                .checked_mul(10u64.pow(12))
                .ok_or_else(|| "Near Gas: underflow or overflow happens")?),
            _ => return Err("Near Gas: incorrect number entered".to_string()),
        }
    }
}

impl interactive_clap::ToCli for NearGas {
    type CliVariant = NearGas;
}

#[derive(Debug, Clone, Default, PartialEq, PartialOrd)]
pub struct TransferAmount {
    amount: NearBalance,
}

impl interactive_clap::ToCli for TransferAmount {
    type CliVariant = NearBalance;
}

impl std::fmt::Display for TransferAmount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.amount)
    }
}

impl TransferAmount {
    pub fn from(
        amount: NearBalance,
        account_transfer_allowance: &AccountTransferAllowance,
    ) -> color_eyre::eyre::Result<Self> {
        if amount <= account_transfer_allowance.transfer_allowance() {
            Ok(Self { amount })
        } else {
            Err(color_eyre::Report::msg(
                "the amount exceeds the transfer allowance",
            ))
        }
    }

    pub fn from_unchecked(amount: NearBalance) -> Self {
        Self { amount }
    }

    pub fn to_yoctonear(&self) -> u128 {
        self.amount.to_yoctonear()
    }
}

impl From<TransferAmount> for NearBalance {
    fn from(item: TransferAmount) -> Self {
        item.amount
    }
}

#[derive(Debug)]
pub struct AccountTransferAllowance {
    account_id: near_primitives::types::AccountId,
    account_liquid_balance: NearBalance,
    account_locked_balance: NearBalance,
    storage_stake: NearBalance,
    pessimistic_transaction_fee: NearBalance,
}

impl std::fmt::Display for AccountTransferAllowance {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(fmt,
            "\n{} account has {} available for transfer (the total balance is {}, but {} is locked for storage and the transfer transaction fee is ~{})",
            self.account_id,
            self.transfer_allowance(),
            self.account_liquid_balance,
            self.liquid_storage_stake(),
            self.pessimistic_transaction_fee
        )
    }
}

impl AccountTransferAllowance {
    pub fn liquid_storage_stake(&self) -> NearBalance {
        NearBalance::from_yoctonear(
            self.storage_stake
                .to_yoctonear()
                .saturating_sub(self.account_locked_balance.to_yoctonear()),
        )
    }

    pub fn transfer_allowance(&self) -> NearBalance {
        NearBalance::from_yoctonear(
            self.account_liquid_balance.to_yoctonear()
                - self.liquid_storage_stake().to_yoctonear()
                - self.pessimistic_transaction_fee.to_yoctonear(),
        )
    }
}

pub async fn get_account_transfer_allowance(
    network_config: crate::config::NetworkConfig,
    account_id: near_primitives::types::AccountId,
    block_reference: BlockReference,
) -> color_eyre::eyre::Result<AccountTransferAllowance> {
    let account_view = if let Some(account_view) =
        get_account_state(network_config.clone(), account_id.clone(), block_reference).await?
    {
        account_view
    } else {
        return Ok(AccountTransferAllowance {
            account_id,
            account_liquid_balance: NearBalance::from_yoctonear(0),
            account_locked_balance: NearBalance::from_yoctonear(0),
            storage_stake: NearBalance::from_yoctonear(0),
            pessimistic_transaction_fee: NearBalance::from_yoctonear(0),
        });
    };
    let storage_amount_per_byte = network_config
        .json_rpc_client()?
        .call(
            near_jsonrpc_client::methods::EXPERIMENTAL_protocol_config::RpcProtocolConfigRequest {
                block_reference: near_primitives::types::BlockReference::Finality(
                    near_primitives::types::Finality::Final,
                ),
            },
        )
        .await
        .map_err(|err| color_eyre::Report::msg(format!("RpcError: {:?}", err)))?
        .runtime_config
        .storage_amount_per_byte;

    Ok(AccountTransferAllowance {
        account_id,
        account_liquid_balance: NearBalance::from_yoctonear(account_view.amount),
        account_locked_balance: NearBalance::from_yoctonear(account_view.locked),
        storage_stake: NearBalance::from_yoctonear(
            u128::from(account_view.storage_usage) * storage_amount_per_byte,
        ),
        // pessimistic_transaction_fee = 10^21 - this value is set temporarily
        // In the future, its value will be calculated by the function: fn tx_cost(...)
        // https://github.com/near/nearcore/blob/8a377fda0b4ce319385c463f1ae46e4b0b29dcd9/runtime/runtime/src/config.rs#L178-L232
        pessimistic_transaction_fee: NearBalance::from_yoctonear(10u128.pow(21)),
    })
}

pub async fn get_account_state(
    network_config: crate::config::NetworkConfig,
    account_id: near_primitives::types::AccountId,
    block_reference: BlockReference,
) -> color_eyre::eyre::Result<Option<near_primitives::views::AccountView>> {
    let json_rpc_client = match block_reference {
        BlockReference::Finality(_) | BlockReference::BlockId(_) => {
            network_config.json_rpc_client()?
        }
        BlockReference::SyncCheckpoint(_) => todo!(),
    };
    let query_view_method_response = json_rpc_client
        .call(near_jsonrpc_client::methods::query::RpcQueryRequest {
            block_reference,
            request: near_primitives::views::QueryRequest::ViewAccount { account_id },
        })
        .await;
    match query_view_method_response {
        Ok(rpc_query_response) => {
            let account_view =
                if let near_jsonrpc_primitives::types::query::QueryResponseKind::ViewAccount(
                    result,
                ) = rpc_query_response.kind
                {
                    result
                } else {
                    return Err(color_eyre::Report::msg(format!("Error call result")));
                };
            Ok(Some(account_view.into()))
        }
        Err(_) => return Ok(None),
    }
}

/// Returns true if the account ID length is 64 characters and it's a hex representation. This is used to check the implicit account.
pub fn is_64_len_hex(account_id: impl AsRef<str>) -> bool {
    let account_id = account_id.as_ref();
    account_id.len() == 64
        && account_id
            .as_bytes()
            .iter()
            .all(|b| matches!(b, b'a'..=b'f' | b'0'..=b'9'))
}

#[derive(Debug, Clone)]
pub struct KeyPairProperties {
    pub seed_phrase_hd_path: slip10::BIP32Path,
    pub master_seed_phrase: String,
    pub implicit_account_id: near_primitives::types::AccountId,
    pub public_key_str: String,
    pub secret_keypair_str: String,
}

pub fn get_public_key_from_seed_phrase(
    seed_phrase_hd_path: slip10::BIP32Path,
    master_seed_phrase: &str,
) -> color_eyre::eyre::Result<near_crypto::PublicKey> {
    let master_seed = bip39::Mnemonic::parse(master_seed_phrase)?.to_seed("");
    let derived_private_key =
        slip10::derive_key_from_path(&master_seed, slip10::Curve::Ed25519, &seed_phrase_hd_path)
            .map_err(|err| {
                color_eyre::Report::msg(format!(
                    "Failed to derive a key from the master key: {}",
                    err
                ))
            })?;
    let secret_keypair = {
        let secret = ed25519_dalek::SecretKey::from_bytes(&derived_private_key.key)?;
        let public = ed25519_dalek::PublicKey::from(&secret);
        ed25519_dalek::Keypair { secret, public }
    };
    let public_key_str = format!(
        "ed25519:{}",
        bs58::encode(&secret_keypair.public).into_string()
    );
    Ok(near_crypto::PublicKey::from_str(&public_key_str)?)
}

pub async fn generate_keypair() -> color_eyre::eyre::Result<KeyPairProperties> {
    let generate_keypair: crate::utils_command::generate_keypair_subcommand::CliGenerateKeypair =
        crate::utils_command::generate_keypair_subcommand::CliGenerateKeypair::default();
    let (master_seed_phrase, master_seed) =
        if let Some(master_seed_phrase) = generate_keypair.master_seed_phrase.as_deref() {
            (
                master_seed_phrase.to_owned(),
                bip39::Mnemonic::parse(master_seed_phrase)?.to_seed(""),
            )
        } else {
            let mnemonic =
                bip39::Mnemonic::generate(generate_keypair.new_master_seed_phrase_words_count)?;
            let master_seed_phrase = mnemonic.word_iter().collect::<Vec<&str>>().join(" ");
            (master_seed_phrase, mnemonic.to_seed(""))
        };

    let derived_private_key = slip10::derive_key_from_path(
        &master_seed,
        slip10::Curve::Ed25519,
        &generate_keypair.seed_phrase_hd_path.clone().into(),
    )
    .map_err(|err| {
        color_eyre::Report::msg(format!(
            "Failed to derive a key from the master key: {}",
            err
        ))
    })?;

    let secret_keypair = {
        let secret = ed25519_dalek::SecretKey::from_bytes(&derived_private_key.key)?;
        let public = ed25519_dalek::PublicKey::from(&secret);
        ed25519_dalek::Keypair { secret, public }
    };

    let implicit_account_id =
        near_primitives::types::AccountId::try_from(hex::encode(&secret_keypair.public))?;
    let public_key_str = format!(
        "ed25519:{}",
        bs58::encode(&secret_keypair.public).into_string()
    );
    let secret_keypair_str = format!(
        "ed25519:{}",
        bs58::encode(secret_keypair.to_bytes()).into_string()
    );
    let key_pair_properties: KeyPairProperties = KeyPairProperties {
        seed_phrase_hd_path: generate_keypair.seed_phrase_hd_path.into(),
        master_seed_phrase,
        implicit_account_id,
        public_key_str,
        secret_keypair_str,
    };
    Ok(key_pair_properties)
}

pub fn print_transaction(transaction: near_primitives::transaction::Transaction) {
    println!("{:<13} {}", "signer_id:", &transaction.signer_id);
    println!("{:<13} {}", "public_key:", &transaction.public_key);
    println!("{:<13} {}", "nonce:", &transaction.nonce);
    println!("{:<13} {}", "receiver_id:", &transaction.receiver_id);
    println!("{:<13} {}", "block_hash:", &transaction.block_hash);
    println!("actions:");
    let actions = transaction.actions.clone();
    for action in actions {
        match action {
            near_primitives::transaction::Action::CreateAccount(_) => {
                println!(
                    "{:>5} {:<20} {}",
                    "--", "create account:", &transaction.receiver_id
                )
            }
            near_primitives::transaction::Action::DeployContract(_) => {
                println!("{:>5} {:<20}", "--", "deploy contract")
            }
            near_primitives::transaction::Action::FunctionCall(function_call_action) => {
                println!("{:>5} {:<20}", "--", "function call:");
                println!(
                    "{:>18} {:<13} {}",
                    "", "method name:", &function_call_action.method_name
                );
                println!(
                    "{:>18} {:<13} {:?}",
                    "", "args:", &function_call_action.args
                );
                println!(
                    "{:>18} {:<13} {}",
                    "",
                    "gas:",
                    crate::common::NearGas {
                        inner: function_call_action.gas
                    }
                );
                println!(
                    "{:>18} {:<13} {}",
                    "",
                    "deposit:",
                    crate::common::NearBalance::from_yoctonear(function_call_action.deposit)
                );
            }
            near_primitives::transaction::Action::Transfer(transfer_action) => {
                println!(
                    "{:>5} {:<20} {}",
                    "--",
                    "transfer deposit:",
                    crate::common::NearBalance::from_yoctonear(transfer_action.deposit)
                );
            }
            near_primitives::transaction::Action::Stake(stake_action) => {
                println!("{:>5} {:<20}", "--", "stake:");
                println!(
                    "{:>18} {:<13} {}",
                    "", "public key:", &stake_action.public_key
                );
                println!(
                    "{:>18} {:<13} {}",
                    "",
                    "stake:",
                    crate::common::NearBalance::from_yoctonear(stake_action.stake)
                );
            }
            near_primitives::transaction::Action::AddKey(add_key_action) => {
                println!("{:>5} {:<20}", "--", "add access key:");
                println!(
                    "{:>18} {:<13} {}",
                    "", "public key:", &add_key_action.public_key
                );
                println!(
                    "{:>18} {:<13} {}",
                    "", "nonce:", &add_key_action.access_key.nonce
                );
                println!(
                    "{:>18} {:<13} {:?}",
                    "", "permission:", &add_key_action.access_key.permission
                );
            }
            near_primitives::transaction::Action::DeleteKey(delete_key_action) => {
                println!("{:>5} {:<20}", "--", "delete access key:");
                println!(
                    "{:>18} {:<13} {}",
                    "", "public key:", &delete_key_action.public_key
                );
            }
            near_primitives::transaction::Action::DeleteAccount(delete_account_action) => {
                println!(
                    "{:>5} {:<20} {}",
                    "--", "delete account:", &transaction.receiver_id
                );
                println!(
                    "{:>5} {:<20} {}",
                    "", "beneficiary id:", &delete_account_action.beneficiary_id
                );
            }
        }
    }
}

fn print_value_successful_transaction(
    transaction_info: near_primitives::views::FinalExecutionOutcomeView,
) {
    println!("Successful transaction");
    for action in transaction_info.transaction.actions {
        match action {
            near_primitives::views::ActionView::CreateAccount => {
                println!(
                    "New account <{}> has been successfully created.",
                    transaction_info.transaction.receiver_id,
                );
            }
            near_primitives::views::ActionView::DeployContract { code: _ } => {
                println!("Contract code has been successfully deployed.",);
            }
            near_primitives::views::ActionView::FunctionCall {
                method_name,
                args: _,
                gas: _,
                deposit: _,
            } => {
                println!(
                    "The \"{}\" call to <{}> on behalf of <{}> succeeded.",
                    method_name,
                    transaction_info.transaction.receiver_id,
                    transaction_info.transaction.signer_id,
                );
            }
            near_primitives::views::ActionView::Transfer { deposit } => {
                println!(
                    "<{}> has transferred {} to <{}> successfully.",
                    transaction_info.transaction.signer_id,
                    crate::common::NearBalance::from_yoctonear(deposit),
                    transaction_info.transaction.receiver_id,
                );
            }
            near_primitives::views::ActionView::Stake {
                stake,
                public_key: _,
            } => {
                println!(
                    "Validator <{}> has successfully staked {}.",
                    transaction_info.transaction.signer_id,
                    crate::common::NearBalance::from_yoctonear(stake),
                );
            }
            near_primitives::views::ActionView::AddKey {
                public_key,
                access_key: _,
            } => {
                println!(
                    "Added access key = {} to {}.",
                    public_key, transaction_info.transaction.receiver_id,
                );
            }
            near_primitives::views::ActionView::DeleteKey { public_key } => {
                println!(
                    "Access key <{}> for account <{}> has been successfully deleted.",
                    public_key, transaction_info.transaction.signer_id,
                );
            }
            near_primitives::views::ActionView::DeleteAccount { beneficiary_id: _ } => {
                println!(
                    "Account <{}> has been successfully deleted.",
                    transaction_info.transaction.signer_id,
                );
            }
        }
    }
}

pub fn rpc_transaction_error(
    err: near_jsonrpc_client::errors::JsonRpcError<
        near_jsonrpc_client::methods::broadcast_tx_commit::RpcTransactionError,
    >,
) -> CliResult {
    match &err {
        near_jsonrpc_client::errors::JsonRpcError::TransportError(_rpc_transport_error) => {
            println!("Transport error transaction.\nPlease wait. The next try to send this transaction is happening right now ...");
        }
        near_jsonrpc_client::errors::JsonRpcError::ServerError(rpc_server_error) => match rpc_server_error {
            near_jsonrpc_client::errors::JsonRpcServerError::HandlerError(rpc_transaction_error) => match rpc_transaction_error {
                near_jsonrpc_client::methods::broadcast_tx_commit::RpcTransactionError::TimeoutError => {
                    println!("Timeout error transaction.\nPlease wait. The next try to send this transaction is happening right now ...");
                }
                near_jsonrpc_client::methods::broadcast_tx_commit::RpcTransactionError::InvalidTransaction { context } => {
                    let err_invalid_transaction = crate::common::handler_invalid_tx_error(context.clone());
                    return color_eyre::eyre::Result::Err(color_eyre::eyre::eyre!("{}", err_invalid_transaction));
                }
                near_jsonrpc_client::methods::broadcast_tx_commit::RpcTransactionError::DoesNotTrackShard => {
                    return color_eyre::eyre::Result::Err(color_eyre::eyre::eyre!("RPC Server Error: {}", err));
                }
                near_jsonrpc_client::methods::broadcast_tx_commit::RpcTransactionError::RequestRouted{transaction_hash} => {
                    return color_eyre::eyre::Result::Err(color_eyre::eyre::eyre!("RPC Server Error for transaction with hash {}\n{}", transaction_hash, err));
                }
                near_jsonrpc_client::methods::broadcast_tx_commit::RpcTransactionError::UnknownTransaction{requested_transaction_hash} => {
                    return color_eyre::eyre::Result::Err(color_eyre::eyre::eyre!("RPC Server Error for transaction with hash {}\n{}", requested_transaction_hash, err));
                }
                near_jsonrpc_client::methods::broadcast_tx_commit::RpcTransactionError::InternalError{debug_info} => {
                    return color_eyre::eyre::Result::Err(color_eyre::eyre::eyre!("RPC Server Error: {}", debug_info));
                }
            }
            near_jsonrpc_client::errors::JsonRpcServerError::RequestValidationError(rpc_request_validation_error) => {
                return color_eyre::eyre::Result::Err(color_eyre::eyre::eyre!("Incompatible request with the server: {:#?}",  rpc_request_validation_error));
            }
            near_jsonrpc_client::errors::JsonRpcServerError::InternalError{ info } => {
                println!("Internal server error: {}.\nPlease wait. The next try to send this transaction is happening right now ...", info.clone().unwrap_or_default());
            }
            near_jsonrpc_client::errors::JsonRpcServerError::NonContextualError(rpc_error) => {
                return color_eyre::eyre::Result::Err(color_eyre::eyre::eyre!("Unexpected response: {}", rpc_error));
            }
            near_jsonrpc_client::errors::JsonRpcServerError::ResponseStatusError(json_rpc_server_response_status_error) => match json_rpc_server_response_status_error {
                near_jsonrpc_client::errors::JsonRpcServerResponseStatusError::Unauthorized => {
                    return color_eyre::eyre::Result::Err(color_eyre::eyre::eyre!("JSON RPC server requires authentication. Please, authenticate near CLI with the JSON RPC server you use."));
                }
                near_jsonrpc_client::errors::JsonRpcServerResponseStatusError::TooManyRequests => {
                    println!("JSON RPC server is currently busy.\nPlease wait. The next try to send this transaction is happening right now ...");
                }
                near_jsonrpc_client::errors::JsonRpcServerResponseStatusError::Unexpected{status} => {
                    return color_eyre::eyre::Result::Err(color_eyre::eyre::eyre!("JSON RPC server responded with an unexpected status code: {}", status));
                }
            }
        }
    }
    Ok(())
}

pub fn print_action_error(action_error: near_primitives::errors::ActionError) {
    match action_error.kind {
        near_primitives::errors::ActionErrorKind::AccountAlreadyExists { account_id } => {
            println!("Error: Create Account action tries to create an account with account ID <{}> which already exists in the storage.", account_id)
        }
        near_primitives::errors::ActionErrorKind::AccountDoesNotExist { account_id } => {
            println!(
                "Error: TX receiver ID <{}> doesn't exist (but action is not \"Create Account\").",
                account_id
            )
        }
        near_primitives::errors::ActionErrorKind::CreateAccountOnlyByRegistrar {
            account_id: _,
            registrar_account_id: _,
            predecessor_id: _,
        } => {
            println!("Error: A top-level account ID can only be created by registrar.")
        }
        near_primitives::errors::ActionErrorKind::CreateAccountNotAllowed {
            account_id,
            predecessor_id,
        } => {
            println!("Error: A newly created account <{}> must be under a namespace of the creator account <{}>.", account_id, predecessor_id)
        }
        near_primitives::errors::ActionErrorKind::ActorNoPermission {
            account_id: _,
            actor_id: _,
        } => {
            println!("Error: Administrative actions can be proceed only if sender=receiver or the first TX action is a \"Create Account\" action.")
        }
        near_primitives::errors::ActionErrorKind::DeleteKeyDoesNotExist {
            account_id,
            public_key,
        } => {
            println!(
                "Error: Account <{}>  tries to remove an access key <{}> that doesn't exist.",
                account_id, public_key
            )
        }
        near_primitives::errors::ActionErrorKind::AddKeyAlreadyExists {
            account_id,
            public_key,
        } => {
            println!(
                "Error: Public key <{}> is already used for an existing account ID <{}>.",
                public_key, account_id
            )
        }
        near_primitives::errors::ActionErrorKind::DeleteAccountStaking { account_id } => {
            println!(
                "Error: Account <{}> is staking and can not be deleted",
                account_id
            )
        }
        near_primitives::errors::ActionErrorKind::LackBalanceForState { account_id, amount } => {
            println!("Error: Receipt action can't be completed, because the remaining balance will not be enough to cover storage.\nAn account which needs balance: <{}>\nBalance required to complete the action: <{}>",
                account_id,
                crate::common::NearBalance::from_yoctonear(amount)
            )
        }
        near_primitives::errors::ActionErrorKind::TriesToUnstake { account_id } => {
            println!(
                "Error: Account <{}> is not yet staked, but tries to unstake.",
                account_id
            )
        }
        near_primitives::errors::ActionErrorKind::TriesToStake {
            account_id,
            stake,
            locked: _,
            balance,
        } => {
            println!(
                "Error: Account <{}> doesn't have enough balance ({}) to increase the stake ({}).",
                account_id,
                crate::common::NearBalance::from_yoctonear(balance),
                crate::common::NearBalance::from_yoctonear(stake)
            )
        }
        near_primitives::errors::ActionErrorKind::InsufficientStake {
            account_id: _,
            stake,
            minimum_stake,
        } => {
            println!(
                "Error: Insufficient stake {}.\nThe minimum rate must be {}.",
                crate::common::NearBalance::from_yoctonear(stake),
                crate::common::NearBalance::from_yoctonear(minimum_stake)
            )
        }
        near_primitives::errors::ActionErrorKind::FunctionCallError(function_call_error_ser) => {
            println!("Error: An error occurred during a `FunctionCall` Action, parameter is debug message.\n{:?}", function_call_error_ser)
        }
        near_primitives::errors::ActionErrorKind::NewReceiptValidationError(
            receipt_validation_error,
        ) => {
            println!("Error: Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails.\n{:?}", receipt_validation_error)
        }
        near_primitives::errors::ActionErrorKind::OnlyImplicitAccountCreationAllowed {
            account_id: _,
        } => {
            println!("Error: `CreateAccount` action is called on hex-characters account of length 64.\nSee implicit account creation NEP: https://github.com/nearprotocol/NEPs/pull/71")
        }
        near_primitives::errors::ActionErrorKind::DeleteAccountWithLargeState { account_id } => {
            println!(
                "Error: Delete account <{}> whose state is large is temporarily banned.",
                account_id
            )
        }
    }
}

pub fn handler_invalid_tx_error(
    invalid_tx_error: near_primitives::errors::InvalidTxError,
) -> String {
    match invalid_tx_error {
        near_primitives::errors::InvalidTxError::InvalidAccessKeyError(invalid_access_key_error) => {
            match invalid_access_key_error {
                near_primitives::errors::InvalidAccessKeyError::AccessKeyNotFound{account_id, public_key} => {
                    format!("Error: Public key {} doesn't exist for the account <{}>.", public_key, account_id)
                },
                near_primitives::errors::InvalidAccessKeyError::ReceiverMismatch{tx_receiver, ak_receiver} => {
                    format!("Error: Transaction for <{}> doesn't match the access key for <{}>.", tx_receiver, ak_receiver)
                },
                near_primitives::errors::InvalidAccessKeyError::MethodNameMismatch{method_name} => {
                    format!("Error: Transaction method name <{}> isn't allowed by the access key.", method_name)
                },
                near_primitives::errors::InvalidAccessKeyError::RequiresFullAccess => {
                    format!("Error: Transaction requires a full permission access key.")
                },
                near_primitives::errors::InvalidAccessKeyError::NotEnoughAllowance{account_id, public_key, allowance, cost} => {
                    format!("Error: Access Key <{}> for account <{}> does not have enough allowance ({}) to cover transaction cost ({}).",
                        public_key,
                        account_id,
                        crate::common::NearBalance::from_yoctonear(allowance),
                        crate::common::NearBalance::from_yoctonear(cost)
                    )
                },
                near_primitives::errors::InvalidAccessKeyError::DepositWithFunctionCall => {
                    format!("Error: Having a deposit with a function call action is not allowed with a function call access key.")
                }
            }
        },
        near_primitives::errors::InvalidTxError::InvalidSignerId { signer_id } => {
            format!("Error: TX signer ID <{}> is not in a valid format or does not satisfy requirements\nSee \"near_runtime_utils::utils::is_valid_account_id\".", signer_id)
        },
        near_primitives::errors::InvalidTxError::SignerDoesNotExist { signer_id } => {
            format!("Error: TX signer ID <{}> is not found in the storage.", signer_id)
        },
        near_primitives::errors::InvalidTxError::InvalidNonce { tx_nonce, ak_nonce } => {
            format!("Error: Transaction nonce ({}) must be account[access_key].nonce ({}) + 1.", tx_nonce, ak_nonce)
        },
        near_primitives::errors::InvalidTxError::NonceTooLarge { tx_nonce, upper_bound } => {
            format!("Error: Transaction nonce ({}) is larger than the upper bound ({}) given by the block height.", tx_nonce, upper_bound)
        },
        near_primitives::errors::InvalidTxError::InvalidReceiverId { receiver_id } => {
            format!("Error: TX receiver ID ({}) is not in a valid format or does not satisfy requirements\nSee \"near_runtime_utils::is_valid_account_id\".", receiver_id)
        },
        near_primitives::errors::InvalidTxError::InvalidSignature => {
            format!("Error: TX signature is not valid")
        },
        near_primitives::errors::InvalidTxError::NotEnoughBalance {signer_id, balance, cost} => {
            format!("Error: Account <{}> does not have enough balance ({}) to cover TX cost ({}).",
                signer_id,
                crate::common::NearBalance::from_yoctonear(balance),
                crate::common::NearBalance::from_yoctonear(cost)
            )
        },
        near_primitives::errors::InvalidTxError::LackBalanceForState {signer_id, amount} => {
            format!("Error: Signer account <{}> doesn't have enough balance ({}) after transaction.",
                signer_id,
                crate::common::NearBalance::from_yoctonear(amount)
            )
        },
        near_primitives::errors::InvalidTxError::CostOverflow => {
            format!("Error: An integer overflow occurred during transaction cost estimation.")
        },
        near_primitives::errors::InvalidTxError::InvalidChain => {
            format!("Error: Transaction parent block hash doesn't belong to the current chain.")
        },
        near_primitives::errors::InvalidTxError::Expired => {
            format!("Error: Transaction has expired.")
        },
        near_primitives::errors::InvalidTxError::ActionsValidation(actions_validation_error) => {
            match actions_validation_error {
                near_primitives::errors::ActionsValidationError::DeleteActionMustBeFinal => {
                    format!("Error: The delete action must be the final action in transaction.")
                },
                near_primitives::errors::ActionsValidationError::TotalPrepaidGasExceeded {total_prepaid_gas, limit} => {
                    format!("Error: The total prepaid gas ({}) for all given actions exceeded the limit ({}).",
                    total_prepaid_gas,
                    limit
                    )
                },
                near_primitives::errors::ActionsValidationError::TotalNumberOfActionsExceeded {total_number_of_actions, limit} => {
                    format!("Error: The number of actions ({}) exceeded the given limit ({}).", total_number_of_actions, limit)
                },
                near_primitives::errors::ActionsValidationError::AddKeyMethodNamesNumberOfBytesExceeded {total_number_of_bytes, limit} => {
                    format!("Error: The total number of bytes ({}) of the method names exceeded the limit ({}) in a Add Key action.", total_number_of_bytes, limit)
                },
                near_primitives::errors::ActionsValidationError::AddKeyMethodNameLengthExceeded {length, limit} => {
                    format!("Error: The length ({}) of some method name exceeded the limit ({}) in a Add Key action.", length, limit)
                },
                near_primitives::errors::ActionsValidationError::IntegerOverflow => {
                    format!("Error: Integer overflow.")
                },
                near_primitives::errors::ActionsValidationError::InvalidAccountId {account_id} => {
                    format!("Error: Invalid account ID <{}>.", account_id)
                },
                near_primitives::errors::ActionsValidationError::ContractSizeExceeded {size, limit} => {
                    format!("Error: The size ({}) of the contract code exceeded the limit ({}) in a DeployContract action.", size, limit)
                },
                near_primitives::errors::ActionsValidationError::FunctionCallMethodNameLengthExceeded {length, limit} => {
                    format!("Error: The length ({}) of the method name exceeded the limit ({}) in a Function Call action.", length, limit)
                },
                near_primitives::errors::ActionsValidationError::FunctionCallArgumentsLengthExceeded {length, limit} => {
                    format!("Error: The length ({}) of the arguments exceeded the limit ({}) in a Function Call action.", length, limit)
                },
                near_primitives::errors::ActionsValidationError::UnsuitableStakingKey {public_key} => {
                    format!("Error: An attempt to stake with a public key <{}> that is not convertible to ristretto.", public_key)
                },
                near_primitives::errors::ActionsValidationError::FunctionCallZeroAttachedGas => {
                    format!("Error: The attached amount of gas in a FunctionCall action has to be a positive number.")
                }
            }
        },
        near_primitives::errors::InvalidTxError::TransactionSizeExceeded { size, limit } => {
            format!("Error: The size ({}) of serialized transaction exceeded the limit ({}).", size, limit)
        }
    }
}

pub fn print_transaction_error(tx_execution_error: near_primitives::errors::TxExecutionError) {
    println!("Failed transaction");
    match tx_execution_error {
        near_primitives::errors::TxExecutionError::ActionError(action_error) => {
            print_action_error(action_error)
        }
        near_primitives::errors::TxExecutionError::InvalidTxError(invalid_tx_error) => {
            println!("{}", handler_invalid_tx_error(invalid_tx_error))
        }
    }
}

pub fn print_transaction_status(
    transaction_info: near_primitives::views::FinalExecutionOutcomeView,
    network_config: crate::config::NetworkConfig,
) {
    match transaction_info.status {
        near_primitives::views::FinalExecutionStatus::NotStarted
        | near_primitives::views::FinalExecutionStatus::Started => unreachable!(),
        near_primitives::views::FinalExecutionStatus::Failure(tx_execution_error) => {
            print_transaction_error(tx_execution_error)
        }
        near_primitives::views::FinalExecutionStatus::SuccessValue(_) => {
            print_value_successful_transaction(transaction_info.clone())
        }
    };
    println!("Transaction ID: {id}\nTo see the transaction in the transaction explorer, please open this url in your browser:\n{path}{id}\n",
        id=transaction_info.transaction_outcome.id,
        path=network_config.explorer_transaction_url
    );
}

pub async fn save_access_key_to_keychain(
    network_config: crate::config::NetworkConfig,
    credentials_home_dir: std::path::PathBuf,
    key_pair_properties: crate::common::KeyPairProperties,
    account_id: &str,
) -> crate::CliResult {
    let buf = format!(
        "{}",
        serde_json::json!({
            "master_seed_phrase": key_pair_properties.master_seed_phrase,
            "seed_phrase_hd_path": key_pair_properties.seed_phrase_hd_path.to_string(),
            "account_id": account_id,
            "public_key": key_pair_properties.public_key_str,
            "private_key": key_pair_properties.secret_keypair_str,
        })
    );
    let dir_name = network_config.network_name.as_str();
    let file_with_key_name: std::path::PathBuf = format!(
        "{}.json",
        key_pair_properties.public_key_str.replace(":", "_")
    )
    .into();
    let mut path_with_key_name = std::path::PathBuf::from(&credentials_home_dir);
    path_with_key_name.push(dir_name);
    path_with_key_name.push(account_id);
    std::fs::create_dir_all(&path_with_key_name)?;
    path_with_key_name.push(file_with_key_name);
    std::fs::File::create(&path_with_key_name)
        .map_err(|err| color_eyre::Report::msg(format!("Failed to create file: {:?}", err)))?
        .write(buf.as_bytes())
        .map_err(|err| color_eyre::Report::msg(format!("Failed to write to file: {:?}", err)))?;
    println!(
        "The data for the access key is saved in a file {:?}",
        &path_with_key_name
    );

    let file_with_account_name: std::path::PathBuf = format!("{}.json", account_id).into();
    let mut path_with_account_name = std::path::PathBuf::from(&credentials_home_dir);
    path_with_account_name.push(dir_name);
    path_with_account_name.push(file_with_account_name);
    if path_with_account_name.exists() {
        println!(
            "The file: {} already exists! Therefore it was not overwritten.",
            &path_with_account_name.display()
        );
    } else {
        std::fs::File::create(&path_with_account_name)
            .map_err(|err| color_eyre::Report::msg(format!("Failed to create file: {:?}", err)))?
            .write(buf.as_bytes())
            .map_err(|err| {
                color_eyre::Report::msg(format!("Failed to write to file: {:?}", err))
            })?;
        println!(
            "The data for the access key is saved in a file {:?}",
            &path_with_account_name
        );
    };
    Ok(())
}

pub fn get_config_toml() -> color_eyre::eyre::Result<crate::config::Config> {
    if let Some(mut path_config_toml) = dirs::config_dir() {
        path_config_toml.push("near-cli");
        std::fs::create_dir_all(&path_config_toml)?;
        path_config_toml.push("config.toml");

        if !path_config_toml.is_file() {
            write_config_toml(crate::config::Config::default())?;
        };
        let config_toml = std::fs::read_to_string(path_config_toml)?;
        Ok(toml::from_str(&config_toml)?)
    } else {
        Ok(crate::config::Config::default())
    }
}

pub fn write_config_toml(config: crate::config::Config) -> CliResult {
    let config_toml = toml::to_string(&config)?;
    let mut path_config_toml = dirs::config_dir().expect("Impossible to get your config dir!");
    path_config_toml.push("near-cli/config.toml");
    std::fs::File::create(&path_config_toml)
        .map_err(|err| color_eyre::Report::msg(format!("Failed to create file: {:?}", err)))?
        .write(config_toml.as_bytes())
        .map_err(|err| color_eyre::Report::msg(format!("Failed to write to file: {:?}", err)))?;
    println!(
        "Configuration data is stored in a file {:?}",
        &path_config_toml
    );
    Ok(())
}

pub fn try_external_subcommand_execution(error: clap::Error) -> CliResult {
    let (subcommand, args) = {
        let mut args = std::env::args().skip(1);
        let subcommand = args
            .next()
            .ok_or_else(|| color_eyre::eyre::eyre!("subcommand is not provided"))?;
        (subcommand, args.collect::<Vec<String>>())
    };
    let is_top_level_command_known = crate::commands::TopLevelCommandDiscriminants::iter()
        .map(|x| format!("{:?}", &x).to_lowercase())
        .find(|x| x == &subcommand)
        .is_some();
    if is_top_level_command_known {
        error.exit()
    }
    let subcommand_exe = format!("near-cli-{}{}", subcommand, std::env::consts::EXE_SUFFIX);

    let path = path_directories()
        .iter()
        .map(|dir| dir.join(&subcommand_exe))
        .find(|file| is_executable(file));

    let command = path.ok_or_else(|| {
        color_eyre::eyre::eyre!(
            "{} command or {} extension does not exist",
            subcommand,
            subcommand_exe
        )
    })?;

    let err = match cargo_util::ProcessBuilder::new(&command)
        .args(&args)
        .exec_replace()
    {
        Ok(()) => return Ok(()),
        Err(e) => e,
    };

    if let Some(perr) = err.downcast_ref::<cargo_util::ProcessError>() {
        if let Some(code) = perr.code {
            return Err(color_eyre::eyre::eyre!("perror occurred, code: {}", code));
        }
    }
    return Err(color_eyre::eyre::eyre!(err));
}

fn is_executable<P: AsRef<std::path::Path>>(path: P) -> bool {
    #[cfg(target_family = "unix")]
    {
        use std::os::unix::prelude::*;
        std::fs::metadata(path)
            .map(|metadata| metadata.is_file() && metadata.permissions().mode() & 0o111 != 0)
            .unwrap_or(false)
    }
    #[cfg(target_family = "windows")]
    path.as_ref().is_file()
}

fn path_directories() -> Vec<std::path::PathBuf> {
    let mut dirs = vec![];
    if let Some(val) = std::env::var_os("PATH") {
        dirs.extend(std::env::split_paths(&val));
    }
    dirs
}

pub async fn display_account_info(
    account_id: AccountId,
    network_config: crate::config::NetworkConfig,
    block_ref: BlockReference,
) -> crate::CliResult {
    // let mut json_rpc_client =
    //     near_jsonrpc_client::JsonRpcClient::connect(network_config.rpc_url.clone());
    // if let Some(api_key) = network_config.api_key {
    //     json_rpc_client = json_rpc_client.header(near_jsonrpc_client::auth::ApiKey::new(api_key)?)
    // };
    let resp = network_config
        .json_rpc_client()?
        .call(near_jsonrpc_client::methods::query::RpcQueryRequest {
            block_reference: block_ref,
            request: QueryRequest::ViewAccount {
                account_id: account_id.clone(),
            },
        })
        .await
        .map_err(|err| {
            color_eyre::Report::msg(format!("Failed to fetch query for view account: {:?}", err))
        })?;

    let account_view = match resp.kind {
        near_jsonrpc_primitives::types::query::QueryResponseKind::ViewAccount(view) => view,
        _ => return Err(color_eyre::Report::msg("Error call result")),
    };

    println!(
        "Account details for '{}' at block #{} ({})\n\
        Native account balance: {}\n\
        Validator stake: {}\n\
        Storage used by the account: {} bytes",
        account_id,
        resp.block_height,
        resp.block_hash,
        NearBalance::from_yoctonear(account_view.amount),
        NearBalance::from_yoctonear(account_view.locked),
        account_view.storage_usage
    );

    if account_view.code_hash == CryptoHash::default() {
        println!("Contract code is not deployed to this account.");
    } else {
        println!(
            "Contract code SHA-256 checksum (hex): {}",
            hex::encode(account_view.code_hash.as_ref())
        );
    }
    Ok(())
}

pub async fn display_access_key_list(
    account_id: AccountId,
    network_config: crate::config::NetworkConfig,
    block_ref: BlockReference,
) -> crate::CliResult {
    let resp = network_config
        .json_rpc_client()?
        .call(near_jsonrpc_client::methods::query::RpcQueryRequest {
            block_reference: block_ref,
            request: QueryRequest::ViewAccessKeyList { account_id },
        })
        .await
        .map_err(|err| {
            color_eyre::Report::msg(format!(
                "Failed to fetch query for view key list: {:?}",
                err
            ))
        })?;

    let view = match resp.kind {
        near_jsonrpc_primitives::types::query::QueryResponseKind::AccessKeyList(result) => result,
        _ => return Err(color_eyre::Report::msg(format!("Error call result"))),
    };

    println!("Number of access keys: {}", view.keys.len());
    for (index, access_key) in view.keys.iter().enumerate() {
        let permissions_message = match &access_key.access_key.permission {
            AccessKeyPermissionView::FullAccess => "full access".to_owned(),
            AccessKeyPermissionView::FunctionCall {
                allowance,
                receiver_id,
                method_names,
            } => {
                let allowance_message = match allowance {
                    Some(amount) => format!(
                        "with an allowance of {}",
                        NearBalance::from_yoctonear(*amount)
                    ),
                    None => format!("with no limit"),
                };
                format!(
                    "only do {:?} function calls on {} {}",
                    method_names, receiver_id, allowance_message
                )
            }
        };

        println!(
            "{: >4}. {} (nonce: {}) is granted to {}",
            index + 1,
            access_key.public_key,
            access_key.access_key.nonce,
            permissions_message
        );
    }
    Ok(())
}

pub fn input_network_name(context: &crate::GlobalContext) -> color_eyre::eyre::Result<String> {
    let variants = context.0.networks.keys().collect::<Vec<_>>();
    let select_submit = Select::with_theme(&ColorfulTheme::default())
        .with_prompt("What is the name of the network?")
        .items(&variants)
        .default(0)
        .interact()
        .unwrap();
    Ok(variants[select_submit].to_string())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::str::FromStr;

    #[test]
    fn near_balance_to_string_0_near() {
        assert_eq!(
            NearBalance {
                yoctonear_amount: 0
            }
            .to_string(),
            "0 NEAR".to_string()
        )
    }
    #[test]
    fn near_balance_to_string_0dot02_near() {
        assert_eq!(
            NearBalance {
                yoctonear_amount: 20000000000000000000000 // 23 digits
            }
            .to_string(),
            "0.02 NEAR".to_string()
        )
    }
    #[test]
    fn near_balance_to_string_0dot1_near() {
        assert_eq!(
            NearBalance {
                yoctonear_amount: 100000000000000000000000 // 24 digits
            }
            .to_string(),
            "0.1 NEAR".to_string()
        )
    }
    #[test]
    fn near_balance_to_string_0dot00001230045600789_near() {
        assert_eq!(
            NearBalance {
                yoctonear_amount: 12300456007890000000 // 20 digits
            }
            .to_string(),
            "0.00001230045600789 NEAR".to_string()
        )
    }
    #[test]
    fn near_balance_to_string_10_near() {
        assert_eq!(
            NearBalance {
                yoctonear_amount: 10000000000000000000000000 // 26 digits
            }
            .to_string(),
            "10 NEAR".to_string()
        )
    }
    #[test]
    fn near_balance_to_string_10dot02_near() {
        assert_eq!(
            NearBalance {
                yoctonear_amount: 10020000000000000000000000 // 26 digits
            }
            .to_string(),
            "10.02 NEAR".to_string()
        )
    }
    #[test]
    fn near_balance_to_string_1yocto_near() {
        let yocto_near = NearBalance::from_yoctonear(1);
        assert_eq!(
            yocto_near.to_string(),
            "0.000000000000000000000001 NEAR".to_string()
        )
    }
    #[test]
    fn near_balance_to_string_1_yocto_near() {
        assert_eq!(
            NearBalance {
                yoctonear_amount: 1
            }
            .to_string(),
            "0.000000000000000000000001 NEAR".to_string()
        )
    }
    #[test]
    fn near_balance_to_string_100_yocto_near() {
        assert_eq!(
            NearBalance {
                yoctonear_amount: 100
            }
            .to_string(),
            "0.0000000000000000000001 NEAR".to_string()
        )
    }

    #[test]
    fn near_balance_from_str_currency_near() {
        assert_eq!(
            NearBalance::from_str("10 near").unwrap(),
            NearBalance {
                yoctonear_amount: 10000000000000000000000000 // 26 digits
            }
        );
        assert_eq!(
            NearBalance::from_str("10.055NEAR").unwrap(),
            NearBalance {
                yoctonear_amount: 10055000000000000000000000 // 26 digits
            }
        );
    }
    #[test]
    fn near_balance_from_str_currency_n() {
        assert_eq!(
            NearBalance::from_str("10 n").unwrap(),
            NearBalance {
                yoctonear_amount: 10000000000000000000000000 // 26 digits
            }
        );
        assert_eq!(
            NearBalance::from_str("10N ").unwrap(),
            NearBalance {
                yoctonear_amount: 10000000000000000000000000 // 26 digits
            }
        );
    }
    #[test]
    fn near_balance_from_str_f64_near() {
        assert_eq!(
            NearBalance::from_str("0.000001 near").unwrap(),
            NearBalance {
                yoctonear_amount: 1000000000000000000 // 18 digits
            }
        );
    }
    #[test]
    fn near_balance_from_str_f64_near_without_int() {
        let near_balance = NearBalance::from_str(".055NEAR");
        assert_eq!(
            near_balance,
            Err("Near Balance: cannot parse integer from empty string".to_string())
        );
    }
    #[test]
    fn near_balance_from_str_currency_ynear() {
        assert_eq!(
            NearBalance::from_str("100 ynear").unwrap(),
            NearBalance {
                yoctonear_amount: 100
            }
        );
        assert_eq!(
            NearBalance::from_str("100YNEAR ").unwrap(),
            NearBalance {
                yoctonear_amount: 100
            }
        );
    }
    #[test]
    fn near_balance_from_str_currency_yn() {
        assert_eq!(
            NearBalance::from_str("9000 YN  ").unwrap(),
            NearBalance {
                yoctonear_amount: 9000
            }
        );
        assert_eq!(
            NearBalance::from_str("0 yn").unwrap(),
            NearBalance {
                yoctonear_amount: 0
            }
        );
    }
    #[test]
    fn near_balance_from_str_currency_yoctonear() {
        assert_eq!(
            NearBalance::from_str("111YOCTONEAR").unwrap(),
            NearBalance {
                yoctonear_amount: 111
            }
        );
        assert_eq!(
            NearBalance::from_str("333 yoctonear").unwrap(),
            NearBalance {
                yoctonear_amount: 333
            }
        );
    }
    #[test]
    fn near_balance_from_str_currency_yocton() {
        assert_eq!(
            NearBalance::from_str("10YOCTON").unwrap(),
            NearBalance {
                yoctonear_amount: 10
            }
        );
        assert_eq!(
            NearBalance::from_str("10 yocton      ").unwrap(),
            NearBalance {
                yoctonear_amount: 10
            }
        );
    }
    #[test]
    fn near_balance_from_str_f64_ynear() {
        let near_balance = NearBalance::from_str("0.055yNEAR");
        assert_eq!(
            near_balance,
            Err("Near Balance: invalid digit found in string".to_string())
        );
    }
    #[test]
    fn near_balance_from_str_without_currency() {
        let near_balance = NearBalance::from_str("100");
        assert_eq!(
            near_balance,
            Err("Near Balance: incorrect currency value entered".to_string())
        );
    }
    #[test]
    fn near_balance_from_str_incorrect_currency() {
        let near_balance = NearBalance::from_str("100 UAH");
        assert_eq!(
            near_balance,
            Err("Near Balance: incorrect currency value entered".to_string())
        );
    }
    #[test]
    fn near_balance_from_str_invalid_double_dot() {
        let near_balance = NearBalance::from_str("100.55.");
        assert_eq!(
            near_balance,
            Err("Near Balance: incorrect currency value entered".to_string())
        );
    }
    #[test]
    fn near_balance_from_str_large_fractional_part() {
        let near_balance = NearBalance::from_str("100.1111122222333334444455555 n"); // 25 digits after "."
        assert_eq!(
            near_balance,
            Err("Near Balance: too large fractional part of a number".to_string())
        );
    }
    #[test]
    fn near_balance_from_str_large_int_part() {
        let near_balance = NearBalance::from_str("1234567890123456.0 n");
        assert_eq!(
            near_balance,
            Err("Near Balance: underflow or overflow happens".to_string())
        );
    }
    #[test]
    fn near_balance_from_str_without_fractional_part() {
        let near_balance = NearBalance::from_str("100. n");
        assert_eq!(
            near_balance,
            Err("Near Balance: cannot parse integer from empty string".to_string())
        );
    }
    #[test]
    fn near_balance_from_str_negative_value() {
        let near_balance = NearBalance::from_str("-100 n");
        assert_eq!(
            near_balance,
            Err("Near Balance: invalid digit found in string".to_string())
        );
    }

    #[test]
    fn near_balance_from_str_currency_tgas() {
        assert_eq!(
            NearGas::from_str("10 tgas").unwrap(),
            NearGas {
                inner: 10000000000000 // 14 digits
            }
        );
        assert_eq!(
            NearGas::from_str("10.055TERAGAS").unwrap(),
            NearGas {
                inner: 10055000000000 // 14 digits
            }
        );
    }
    #[test]
    fn near_gas_from_str_currency_gigagas() {
        assert_eq!(
            NearGas::from_str("10 gigagas").unwrap(),
            NearGas { inner: 10000000000 } // 11 digits
        );
        assert_eq!(
            NearGas::from_str("10GGAS ").unwrap(),
            NearGas { inner: 10000000000 } // 11 digits
        );
    }
    #[test]
    fn near_gas_from_str_f64_tgas() {
        assert_eq!(
            NearGas::from_str("0.000001 tgas").unwrap(),
            NearGas { inner: 1000000 } // 7 digits
        );
    }
    #[test]
    fn near_gas_from_str_f64_gas_without_int() {
        let near_gas = NearGas::from_str(".055ggas");
        assert_eq!(
            near_gas,
            Err("Near Gas: cannot parse integer from empty string".to_string())
        );
    }
    #[test]
    fn near_gas_from_str_without_currency() {
        let near_gas = NearGas::from_str("100");
        assert_eq!(
            near_gas,
            Err("Near Gas: incorrect currency value entered".to_string())
        );
    }
    #[test]
    fn near_gas_from_str_incorrect_currency() {
        let near_gas = NearGas::from_str("100 UAH");
        assert_eq!(
            near_gas,
            Err("Near Gas: incorrect currency value entered".to_string())
        );
    }
    #[test]
    fn near_gas_from_str_invalid_double_dot() {
        let near_gas = NearGas::from_str("100.55.");
        assert_eq!(
            near_gas,
            Err("Near Gas: incorrect currency value entered".to_string())
        );
    }
    #[test]
    fn near_gas_from_str_large_fractional_part() {
        let near_gas = NearGas::from_str("100.1111122222333 ggas"); // 13 digits after "."
        assert_eq!(
            near_gas,
            Err("Near Gas: too large fractional part of a number".to_string())
        );
    }
    #[test]
    fn near_gas_from_str_large_int_part() {
        let near_gas = NearGas::from_str("200123456789123.0 tgas");
        assert_eq!(
            near_gas,
            Err("Near Gas: underflow or overflow happens".to_string())
        );
    }
    #[test]
    fn near_gas_from_str_negative_value() {
        let near_gas = NearGas::from_str("-100 ggas");
        assert_eq!(
            near_gas,
            Err("Near Gas: invalid digit found in string".to_string())
        );
    }
}

'''
'''--- src/config.rs ---
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Config {
    pub credentials_home_dir: std::path::PathBuf,
    pub networks: linked_hash_map::LinkedHashMap<String, NetworkConfig>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct NetworkConfig {
    pub network_name: String,
    pub rpc_url: url::Url,
    pub wallet_url: url::Url,
    pub explorer_transaction_url: url::Url,
    pub api_key: Option<String>,
}

impl Default for Config {
    fn default() -> Self {
        let home_dir = dirs::home_dir().expect("Impossible to get your home dir!");
        let mut credentials_home_dir = std::path::PathBuf::from(&home_dir);
        credentials_home_dir.push(".near-credentials");

        let mut networks = linked_hash_map::LinkedHashMap::new();
        networks.insert(
            "mainnet".to_string(),
            NetworkConfig {
                network_name: "mainnet".to_string(),
                rpc_url: "https://archival-rpc.mainnet.near.org".parse().unwrap(),
                wallet_url: "https://wallet.mainnet.near.org".parse().unwrap(),
                explorer_transaction_url: "https://explorer.mainnet.near.org/transactions/"
                    .parse()
                    .unwrap(),
                api_key: None,
            },
        );
        networks.insert(
            "testnet".to_string(),
            NetworkConfig {
                network_name: "testnet".to_string(),
                rpc_url: "https://archival-rpc.testnet.near.org".parse().unwrap(),
                wallet_url: "https://wallet.testnet.near.org".parse().unwrap(),
                explorer_transaction_url: "https://explorer.testnet.near.org/transactions/"
                    .parse()
                    .unwrap(),
                api_key: None,
            },
        );
        networks.insert(
            "shardnet".to_string(),
            NetworkConfig {
                network_name: "shardnet".to_string(),
                rpc_url: "https://rpc.shardnet.near.org".parse().unwrap(),
                wallet_url: "https://wallet.shardnet.near.org".parse().unwrap(),
                explorer_transaction_url: "https://explorer.shardnet.near.org/transactions/"
                    .parse()
                    .unwrap(),
                api_key: None,
            },
        );
        Self {
            credentials_home_dir,
            networks,
        }
    }
}

impl NetworkConfig {
    pub fn json_rpc_client(&self) -> color_eyre::eyre::Result<near_jsonrpc_client::JsonRpcClient> {
        let mut json_rpc_client = near_jsonrpc_client::JsonRpcClient::connect(self.rpc_url.clone());
        if let Some(api_key) = self.api_key.clone() {
            json_rpc_client =
                json_rpc_client.header(near_jsonrpc_client::auth::ApiKey::new(api_key)?)
        };
        Ok(json_rpc_client)
    }
}

'''
'''--- src/main.rs ---
use common::{try_external_subcommand_execution, CliResult};

mod commands;
mod common;
mod config;
mod network;
mod network_for_transaction;
mod network_view_at_block;
mod transaction_signature_options;
mod types;
mod utils_command;

pub type GlobalContext = (crate::config::Config,);

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
struct Cmd {
    #[interactive_clap(subcommand)]
    top_level: self::commands::TopLevelCommand,
}

impl Cmd {
    async fn process(&self, config: crate::config::Config) -> CliResult {
        self.top_level.process(config).await
    }
}

fn main() -> CliResult {
    let config = crate::common::get_config_toml()?;

    color_eyre::install()?;

    let cli = match Cmd::try_parse() {
        Ok(cli) => cli,
        Err(error) => {
            if matches!(
                error.kind(),
                clap::error::ErrorKind::UnknownArgument | clap::error::ErrorKind::InvalidSubcommand
            ) {
                return try_external_subcommand_execution(error);
            }
            error.exit();
        }
    };

    // if let Some(self::commands::CliTopLevelCommand::GenerateShellCompletions(subcommand)) =
    //     cli.top_level_command
    // {
    //     subcommand.process();
    //     return Ok(());
    // }

    let cmd = loop {
        if let Some(cmd) = Cmd::from_cli(Some(cli.clone()), (config.clone(),))? {
            break cmd;
        }
    };

    let completed_cli = CliCmd::from(cmd.clone());

    let process_result = tokio::runtime::Runtime::new()
        .unwrap()
        .block_on(cmd.process(config));

    println!(
        "Your console command:\n{} {}",
        std::env::args().next().as_deref().unwrap_or("./near_cli"),
        shell_words::join(&completed_cli.to_cli_args())
    );

    process_result
}

'''
'''--- src/network/mod.rs ---
#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct Network {
    ///What is the name of the network
    #[interactive_clap(skip_default_input_arg)]
    network_name: String,
}

impl Network {
    fn input_network_name(context: &crate::GlobalContext) -> color_eyre::eyre::Result<String> {
        crate::common::input_network_name(context)
    }

    pub fn get_network_config(
        &self,
        config: crate::config::Config,
    ) -> crate::config::NetworkConfig {
        let network_config = config.networks;
        network_config
            .get(self.network_name.as_str())
            .expect("Impossible to get network name!")
            .clone()
    }
}

'''
'''--- src/network_for_transaction/mod.rs ---
#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct NetworkForTransactionArgs {
    ///What is the name of the network
    #[interactive_clap(skip_default_input_arg)]
    network_name: String,
    #[interactive_clap(subcommand)]
    transaction_signature_options: crate::transaction_signature_options::SignWith,
}

impl NetworkForTransactionArgs {
    fn input_network_name(context: &crate::GlobalContext) -> color_eyre::eyre::Result<String> {
        crate::common::input_network_name(context)
    }

    pub fn get_network_config(
        &self,
        config: crate::config::Config,
    ) -> crate::config::NetworkConfig {
        let network_config = config.networks;
        network_config
            .get(self.network_name.as_str())
            .expect("Impossible to get network name!")
            .clone()
    }

    pub fn get_sign_option(&self) -> crate::transaction_signature_options::SignWith {
        self.transaction_signature_options.clone()
    }
}

'''
'''--- src/network_view_at_block/mod.rs ---
use near_primitives::types::{BlockId, BlockReference, Finality};
use std::str::FromStr;
use strum::{EnumDiscriminants, EnumIter, EnumMessage};

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct NetworkViewAtBlockArgs {
    ///What is the name of the network
    #[interactive_clap(skip_default_input_arg)]
    network_name: String,
    #[interactive_clap(subcommand)]
    next: ViewAtBlock,
}

impl NetworkViewAtBlockArgs {
    fn input_network_name(context: &crate::GlobalContext) -> color_eyre::eyre::Result<String> {
        crate::common::input_network_name(context)
    }

    pub fn get_network_config(
        &self,
        config: crate::config::Config,
    ) -> crate::config::NetworkConfig {
        let network_config = config.networks;
        network_config
            .get(self.network_name.as_str())
            .expect("Impossible to get network name!")
            .clone()
    }

    pub fn get_block_ref(&self) -> BlockReference {
        match self.next.clone() {
            ViewAtBlock::Now => Finality::Final.into(),
            ViewAtBlock::AtBlockHash(at_block_hash) => BlockReference::BlockId(BlockId::Hash(
                near_primitives::hash::CryptoHash::from_str(at_block_hash.block_id_hash.as_str())
                    .unwrap(),
            )),
            ViewAtBlock::AtBlockHeight(at_block_height) => {
                BlockReference::BlockId(BlockId::Height(at_block_height.block_id_height))
            }
        }
    }
}

#[derive(Debug, EnumDiscriminants, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///Сhoose block for view
pub enum ViewAtBlock {
    #[strum_discriminants(strum(
        message = "now               - View properties in the final block"
    ))]
    ///View properties in the final block
    Now,
    #[strum_discriminants(strum(
        message = "at-block-height   - View properties in a height-selected block"
    ))]
    ///View properties in a height-selected block
    AtBlockHeight(AtBlockHeight),
    #[strum_discriminants(strum(
        message = "at-block-hash     - View properties in a hash-selected block"
    ))]
    ///View properties in a hash-selected block
    AtBlockHash(BlockIdHash),
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct AtBlockHeight {
    ///Type the block ID height
    block_id_height: near_primitives::types::BlockHeight,
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
pub struct BlockIdHash {
    ///Type the block ID hash
    block_id_hash: String,
}

'''
'''--- src/transaction_signature_options/mod.rs ---
use dialoguer::{theme::ColorfulTheme, Input, Select};
use strum::{EnumDiscriminants, EnumIter, EnumMessage, IntoEnumIterator};

pub mod sign_with_keychain;
#[cfg(feature = "ledger")]
pub mod sign_with_ledger;
pub mod sign_with_private_key;

#[derive(Debug, EnumDiscriminants, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///Select a tool for signing the transaction
pub enum SignWith {
    #[strum_discriminants(strum(
        message = "sign-with-keychain               - Sign the transaction with a keychain"
    ))]
    ///Sign the transaction with a keychain
    SignWithKeychain(self::sign_with_keychain::SignKeychain),
    #[cfg(feature = "ledger")]
    #[strum_discriminants(strum(
        message = "sign-with-ledger                 - Sign the transaction with a ledger"
    ))]
    ///Sign the transaction with a ledger
    SignWithLedger(self::sign_with_ledger::SignLedger),
    #[strum_discriminants(strum(
        message = "sign-with-plaintext-private-key  - Sign the transaction with a plaintext private key"
    ))]
    ///Sign the transaction with a plaintext private key
    SignWithPlaintextPrivateKey(self::sign_with_private_key::SignPrivateKey),
}

pub fn input_signer_public_key() -> color_eyre::eyre::Result<crate::types::public_key::PublicKey> {
    Ok(Input::new()
        .with_prompt("Enter sender (signer) public key")
        .interact_text()?)
}

pub fn input_signer_private_key() -> color_eyre::eyre::Result<crate::types::secret_key::SecretKey> {
    Ok(Input::new()
        .with_prompt("Enter sender (signer) private (secret) key")
        .interact_text()?)
}
//-----------------------------------------------------------------------------------
//---- these functions are used for offline mode ----
// pub fn input_access_key_nonce(public_key: &str) -> color_eyre::eyre::Result<u64> {
//     println!("Your public key: `{}`", public_key);
//     Ok(Input::new()
//         .with_prompt(
//             "Enter transaction nonce for this public key (query the access key information with \
//             `./near-cli view nonce \
//                 network testnet \
//                 account 'volodymyr.testnet' \
//                 public-key ed25519:...` incremented by 1)",
//         )
//         .interact_text()?)
// }

// pub fn input_block_hash() -> color_eyre::eyre::Result<crate::types::crypto_hash::CryptoHash> {
//     let input_block_hash: crate::common::BlockHashAsBase58 = Input::new()
//         .with_prompt(
//             "Enter recent block hash (query information about the hash of the last block with \
//             `./near-cli view recent-block-hash network testnet`)",
//         )
//         .interact_text()?;
//     Ok(crate::types::crypto_hash::CryptoHash(
//         input_block_hash.inner,
//     ))
// }
//-----------------------------------------------------------------------------------

#[derive(Debug, EnumDiscriminants, Clone, clap::Parser, interactive_clap::ToCliArgs)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
pub enum Submit {
    #[strum_discriminants(strum(message = "send      - Send the transaction to the network"))]
    Send,
    #[strum_discriminants(strum(
        message = "display   - Print only base64 encoded transaction for JSON RPC input and exit"
    ))]
    Display,
}

impl interactive_clap::ToCli for Submit {
    type CliVariant = Submit;
}

impl Submit {
    pub fn choose_submit() -> Self {
        let variants = SubmitDiscriminants::iter().collect::<Vec<_>>();
        let submits = variants
            .iter()
            .map(|p| p.get_message().unwrap().to_owned())
            .collect::<Vec<_>>();
        let select_submit = Select::with_theme(&ColorfulTheme::default())
            .with_prompt("How would you like to proceed")
            .items(&submits)
            .default(0)
            .interact()
            .unwrap();
        match variants[select_submit] {
            SubmitDiscriminants::Send => Submit::Send,
            SubmitDiscriminants::Display => Submit::Display,
        }
    }

    pub async fn process(
        &self,
        network_config: crate::config::NetworkConfig,
        signed_transaction: near_primitives::transaction::SignedTransaction,
        serialize_to_base64: String,
    ) -> crate::CliResult {
        match self {
            Submit::Send => {
                println!("Transaction sent ...");
                let transaction_info = loop {
                    let transaction_info_result = network_config.json_rpc_client()?
                        .call(near_jsonrpc_client::methods::broadcast_tx_commit::RpcBroadcastTxCommitRequest{signed_transaction: signed_transaction.clone()})
                        .await;
                    match transaction_info_result {
                        Ok(response) => {
                            break response;
                        }
                        Err(err) => match crate::common::rpc_transaction_error(err) {
                            Ok(_) => {
                                tokio::time::sleep(std::time::Duration::from_millis(100)).await
                            }
                            Err(report) => return color_eyre::eyre::Result::Err(report),
                        },
                    };
                };
                crate::common::print_transaction_status(transaction_info, network_config);
                Ok(())
            }
            Submit::Display => {
                println!("\nSerialize_to_base64:\n{}", &serialize_to_base64);
                Ok(())
            }
        }
    }
}

'''
'''--- src/transaction_signature_options/sign_with_keychain/mod.rs ---
extern crate dirs;

use serde::Deserialize;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[interactive_clap(skip_default_from_cli)]
pub struct SignKeychain {
    #[interactive_clap(long)]
    #[interactive_clap(skip_default_from_cli_arg)]
    #[interactive_clap(skip_default_input_arg)]
    nonce: Option<u64>,
    #[interactive_clap(long)]
    #[interactive_clap(skip_default_from_cli_arg)]
    #[interactive_clap(skip_default_input_arg)]
    block_hash: Option<String>,
    #[interactive_clap(subcommand)]
    submit: Option<super::Submit>,
}

#[derive(Debug, Deserialize)]
struct User {
    public_key: near_crypto::PublicKey,
    private_key: near_crypto::SecretKey,
}

impl SignKeychain {
    pub fn from_cli(
        optional_clap_variant: Option<<SignKeychain as interactive_clap::ToCli>::CliVariant>,
        _context: crate::GlobalContext,
    ) -> color_eyre::eyre::Result<Option<Self>> {
        let submit: Option<super::Submit> = optional_clap_variant
            .clone()
            .and_then(|clap_variant| clap_variant.submit);
        Ok(Some(Self {
            nonce: None,
            block_hash: None,
            submit,
        }))
    }
}

impl SignKeychain {
    pub async fn process(
        &self,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
        network_config: crate::config::NetworkConfig,
        credentials_home_dir: std::path::PathBuf,
    ) -> crate::CliResult {
        let file_name = format!("{}.json", prepopulated_unsigned_transaction.signer_id);
        let mut path = std::path::PathBuf::from(&credentials_home_dir);

        let data_path: std::path::PathBuf = {
            let dir_name = network_config.network_name.as_str();
            path.push(dir_name);
            path.push(file_name);

            if path.exists() {
                path
            } else {
                let query_view_method_response = network_config
                    .json_rpc_client()?
                    .call(near_jsonrpc_client::methods::query::RpcQueryRequest {
                        block_reference: near_primitives::types::Finality::Final.into(),
                        request: near_primitives::views::QueryRequest::ViewAccessKeyList {
                            account_id: prepopulated_unsigned_transaction.signer_id.clone(),
                        },
                    })
                    .await
                    .map_err(|err| {
                        color_eyre::Report::msg(format!(
                            "Failed to fetch query for view key list: {:?}",
                            err
                        ))
                    })?;
                let access_key_view =
                    if let near_jsonrpc_primitives::types::query::QueryResponseKind::AccessKeyList(
                        result,
                    ) = query_view_method_response.kind
                    {
                        result
                    } else {
                        return Err(color_eyre::Report::msg(format!("Error call result")));
                    };
                let mut path = std::path::PathBuf::from(&credentials_home_dir);
                path.push(dir_name);
                path.push(&prepopulated_unsigned_transaction.signer_id.to_string());
                let mut data_path = std::path::PathBuf::new();
                'outer: for access_key in access_key_view.keys {
                    let account_public_key = access_key.public_key.to_string();
                    let is_full_access_key: bool = match &access_key.access_key.permission {
                        near_primitives::views::AccessKeyPermissionView::FullAccess => true,
                        near_primitives::views::AccessKeyPermissionView::FunctionCall {
                            allowance: _,
                            receiver_id: _,
                            method_names: _,
                        } => false,
                    };
                    let dir = path
                            .read_dir()
                            .map_err(|err| {
                                color_eyre::Report::msg(format!("There are no access keys found in the keychain for the signer account. Log in before signing transactions with keychain. {}", err))
                            })?;
                    for entry in dir {
                        if let Ok(entry) = entry {
                            if entry
                                .path()
                                .file_stem()
                                .unwrap()
                                .to_str()
                                .unwrap()
                                .contains(account_public_key.rsplit(':').next().unwrap())
                                && is_full_access_key
                            {
                                data_path.push(entry.path());
                                break 'outer;
                            }
                        } else {
                            return Err(color_eyre::Report::msg(format!(
                                    "There are no access keys found in the keychain for the signer account. Log in before signing transactions with keychain."
                                )));
                        };
                    }
                }
                data_path
            }
        };
        let data = std::fs::read_to_string(data_path).map_err(|err| {
            color_eyre::Report::msg(format!("Access key file not found! Error: {}", err))
        })?;
        let account_json: User = serde_json::from_str(&data)
            .map_err(|err| color_eyre::Report::msg(format!("Error reading data: {}", err)))?;
        let sign_with_private_key = super::sign_with_private_key::SignPrivateKey {
            signer_public_key: crate::types::public_key::PublicKey(account_json.public_key),
            signer_private_key: crate::types::secret_key::SecretKey(account_json.private_key),
            nonce: self.nonce.clone(),
            block_hash: self.block_hash.clone(),
            submit: self.submit.clone(),
        };
        sign_with_private_key
            .process(prepopulated_unsigned_transaction, network_config)
            .await
    }
}

'''
'''--- src/transaction_signature_options/sign_with_ledger/mod.rs ---
use dialoguer::Input;
use near_primitives::borsh::BorshSerialize;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[interactive_clap(skip_default_from_cli)]
pub struct SignLedger {
    #[interactive_clap(long)]
    #[interactive_clap(skip_default_from_cli_arg)]
    #[interactive_clap(skip_default_input_arg)]
    seed_phrase_hd_path: crate::types::slip10::BIP32Path,
    #[interactive_clap(skip)]
    signer_public_key: crate::types::public_key::PublicKey,
    #[interactive_clap(long)]
    #[interactive_clap(skip_default_from_cli_arg)]
    #[interactive_clap(skip_default_input_arg)]
    nonce: Option<u64>,
    #[interactive_clap(long)]
    #[interactive_clap(skip_default_from_cli_arg)]
    #[interactive_clap(skip_default_input_arg)]
    block_hash: Option<String>,
    #[interactive_clap(subcommand)]
    submit: Option<super::Submit>,
}

impl SignLedger {
    pub fn from_cli(
        optional_clap_variant: Option<<SignLedger as interactive_clap::ToCli>::CliVariant>,
        _context: crate::GlobalContext,
    ) -> color_eyre::eyre::Result<Option<Self>> {
        let seed_phrase_hd_path = match optional_clap_variant
            .clone()
            .and_then(|clap_variant| clap_variant.seed_phrase_hd_path)
        {
            Some(hd_path) => hd_path,
            None => SignLedger::input_seed_phrase_hd_path(),
        };
        println!(
            "Please allow getting the PublicKey on Ledger device (HD Path: {})",
            seed_phrase_hd_path
        );
        let public_key = tokio::runtime::Runtime::new()
            .unwrap()
            .block_on(async {
                near_ledger::get_public_key(seed_phrase_hd_path.clone().into()).await
            })
            .map_err(|near_ledger_error| {
                color_eyre::Report::msg(format!(
                    "An error occurred while trying to get PublicKey from Ledger device: {:?}",
                    near_ledger_error
                ))
            })?;
        let signer_public_key: crate::types::public_key::PublicKey =
            near_crypto::PublicKey::ED25519(near_crypto::ED25519PublicKey::from(
                public_key.to_bytes(),
            ))
            .into();
        let submit: Option<super::Submit> = optional_clap_variant
            .clone()
            .and_then(|clap_variant| clap_variant.submit);
        Ok(Some(Self {
            seed_phrase_hd_path,
            signer_public_key,
            nonce: None,
            block_hash: None,
            submit,
        }))
    }

    pub fn input_seed_phrase_hd_path() -> crate::types::slip10::BIP32Path {
        Input::new()
            .with_prompt("Enter seed phrase HD Path (if you not sure leave blank for default)")
            .with_initial_text("44'/397'/0'/0'/1'")
            .interact_text()
            .unwrap()
    }

    pub async fn process(
        &self,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
        network_config: crate::config::NetworkConfig,
    ) -> crate::CliResult {
        let seed_phrase_hd_path = self.seed_phrase_hd_path.clone().into();
        let online_signer_access_key_response = network_config
            .json_rpc_client()?
            .call(near_jsonrpc_client::methods::query::RpcQueryRequest {
                block_reference: near_primitives::types::Finality::Final.into(),
                request: near_primitives::views::QueryRequest::ViewAccessKey {
                    account_id: prepopulated_unsigned_transaction.signer_id.clone(),
                    public_key: self.signer_public_key.clone().into(),
                },
            })
            .await
            .map_err(|err| {
                println!("\nUnsigned transaction:\n");
                crate::common::print_transaction(prepopulated_unsigned_transaction.clone());
                println!("\nYour transaction was not successfully signed.\n");
                color_eyre::Report::msg(format!(
                    "Failed to fetch public key information for nonce: {:?}",
                    err
                ))
            })?;
        let current_nonce =
            if let near_jsonrpc_primitives::types::query::QueryResponseKind::AccessKey(
                online_signer_access_key,
            ) = online_signer_access_key_response.kind
            {
                online_signer_access_key.nonce
            } else {
                return Err(color_eyre::Report::msg(format!("Error current_nonce")));
            };
        let unsigned_transaction = near_primitives::transaction::Transaction {
            public_key: self.signer_public_key.clone().into(),
            block_hash: online_signer_access_key_response.block_hash,
            nonce: current_nonce + 1,
            ..prepopulated_unsigned_transaction
        };
        println!("\nUnsigned transaction:\n");
        crate::common::print_transaction(unsigned_transaction.clone());
        println!(
            "Confirm transaction signing on your Ledger device (HD Path: {})",
            seed_phrase_hd_path,
        );
        let signature = match near_ledger::sign_transaction(
            unsigned_transaction
                .try_to_vec()
                .expect("Transaction is not expected to fail on serialization"),
            seed_phrase_hd_path,
        )
        .await
        {
            Ok(signature) => {
                near_crypto::Signature::from_parts(near_crypto::KeyType::ED25519, &signature)
                    .expect("Signature is not expected to fail on deserialization")
            }
            Err(near_ledger_error) => {
                return Err(color_eyre::Report::msg(format!(
                    "Error occurred while signing the transaction: {:?}",
                    near_ledger_error
                )));
            }
        };

        let signed_transaction =
            near_primitives::transaction::SignedTransaction::new(signature, unsigned_transaction);
        let serialize_to_base64 = near_primitives::serialize::to_base64(
            signed_transaction
                .try_to_vec()
                .expect("Transaction is not expected to fail on serialization"),
        );
        println!("Your transaction was signed successfully.");
        match self.submit.clone() {
            None => {
                let submit = super::Submit::choose_submit();
                submit
                    .process(network_config, signed_transaction, serialize_to_base64)
                    .await
            }
            Some(submit) => {
                submit
                    .process(network_config, signed_transaction, serialize_to_base64)
                    .await
            }
        }
    }
}

'''
'''--- src/transaction_signature_options/sign_with_private_key/mod.rs ---
use near_primitives::borsh::BorshSerialize;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = crate::GlobalContext)]
#[interactive_clap(skip_default_from_cli)]
pub struct SignPrivateKey {
    #[interactive_clap(long)]
    #[interactive_clap(skip_default_from_cli_arg)]
    #[interactive_clap(skip_default_input_arg)]
    pub signer_public_key: crate::types::public_key::PublicKey,
    #[interactive_clap(long)]
    #[interactive_clap(skip_default_from_cli_arg)]
    #[interactive_clap(skip_default_input_arg)]
    pub signer_private_key: crate::types::secret_key::SecretKey,
    #[interactive_clap(long)]
    #[interactive_clap(skip_default_from_cli_arg)]
    #[interactive_clap(skip_default_input_arg)]
    pub nonce: Option<u64>,
    #[interactive_clap(long)]
    #[interactive_clap(skip_default_from_cli_arg)]
    #[interactive_clap(skip_default_input_arg)]
    pub block_hash: Option<String>,
    #[interactive_clap(subcommand)]
    pub submit: Option<super::Submit>,
}

impl SignPrivateKey {
    pub fn from_cli(
        optional_clap_variant: Option<<SignPrivateKey as interactive_clap::ToCli>::CliVariant>,
        _context: crate::GlobalContext,
    ) -> color_eyre::eyre::Result<Option<Self>> {
        let signer_public_key: crate::types::public_key::PublicKey = match optional_clap_variant
            .clone()
            .and_then(|clap_variant| clap_variant.signer_public_key)
        {
            Some(cli_public_key) => cli_public_key,
            None => super::input_signer_public_key()?,
        };
        let signer_private_key: crate::types::secret_key::SecretKey = match optional_clap_variant
            .clone()
            .and_then(|clap_variant| clap_variant.signer_private_key)
        {
            Some(signer_private_key) => signer_private_key,
            None => super::input_signer_private_key()?,
        };
        let submit: Option<super::Submit> = optional_clap_variant
            .clone()
            .and_then(|clap_variant| clap_variant.submit);
        Ok(Some(Self {
            signer_public_key,
            signer_private_key,
            nonce: None,
            block_hash: None,
            submit,
        }))
    }
}

impl SignPrivateKey {
    pub async fn process(
        &self,
        prepopulated_unsigned_transaction: near_primitives::transaction::Transaction,
        network_config: crate::config::NetworkConfig,
    ) -> crate::CliResult {
        let signer_secret_key: near_crypto::SecretKey = self.signer_private_key.clone().into();
        let online_signer_access_key_response = network_config
            .json_rpc_client()?
            .call(near_jsonrpc_client::methods::query::RpcQueryRequest {
                block_reference: near_primitives::types::Finality::Final.into(),
                request: near_primitives::views::QueryRequest::ViewAccessKey {
                    account_id: prepopulated_unsigned_transaction.signer_id.clone(),
                    public_key: self.signer_public_key.clone().into(),
                },
            })
            .await
            .map_err(|err| {
                println!("\nUnsigned transaction:\n");
                crate::common::print_transaction(prepopulated_unsigned_transaction.clone());
                println!("\nYour transaction was not successfully signed.\n");
                color_eyre::Report::msg(format!(
                    "Failed to fetch public key information for nonce: {:?}",
                    err
                ))
            })?;
        let current_nonce =
            if let near_jsonrpc_primitives::types::query::QueryResponseKind::AccessKey(
                online_signer_access_key,
            ) = online_signer_access_key_response.kind
            {
                online_signer_access_key.nonce
            } else {
                return Err(color_eyre::Report::msg(format!("Error current_nonce")));
            };
        let unsigned_transaction = near_primitives::transaction::Transaction {
            public_key: self.signer_public_key.clone().into(),
            block_hash: online_signer_access_key_response.block_hash,
            nonce: current_nonce + 1,
            ..prepopulated_unsigned_transaction
        };
        let signature = signer_secret_key.sign(unsigned_transaction.get_hash_and_size().0.as_ref());
        let signed_transaction =
            near_primitives::transaction::SignedTransaction::new(signature, unsigned_transaction);
        let serialize_to_base64 = near_primitives::serialize::to_base64(
            signed_transaction
                .try_to_vec()
                .expect("Transaction is not expected to fail on serialization"),
        );
        println!("\nYour transaction was signed successfully.");
        println!("Signed transaction:\n");
        crate::common::print_transaction(signed_transaction.transaction.clone());
        println!();
        match self.submit.clone() {
            None => {
                let submit = super::Submit::choose_submit();
                submit
                    .process(network_config, signed_transaction, serialize_to_base64)
                    .await
            }
            Some(submit) => {
                submit
                    .process(network_config, signed_transaction, serialize_to_base64)
                    .await
            }
        }
    }
}

'''
'''--- src/types/account_id.rs ---
use std::str::FromStr;

#[derive(Eq, Ord, Hash, Clone, Debug, PartialEq, PartialOrd)]
pub struct AccountId(pub near_primitives::types::AccountId);

impl From<AccountId> for near_primitives::types::AccountId {
    fn from(account_id: AccountId) -> Self {
        account_id.0
    }
}

impl std::fmt::Display for AccountId {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        self.0.fmt(f)
    }
}

impl std::str::FromStr for AccountId {
    type Err = <near_primitives::types::AccountId as std::str::FromStr>::Err;

    fn from_str(account_id: &str) -> Result<Self, Self::Err> {
        let account_id = near_primitives::types::AccountId::from_str(account_id)?;
        Ok(Self(account_id))
    }
}

impl AsRef<str> for AccountId {
    fn as_ref(&self) -> &str {
        self.0.as_ref()
    }
}

impl interactive_clap::ToCli for AccountId {
    type CliVariant = AccountId;
}

impl AccountId {
    pub fn get_owner_account_id_from_sub_account(self) -> Self {
        let owner_account_id = self.to_string();
        let owner_account_id = owner_account_id.split_once('.').map_or("default", |s| s.1);
        Self::from_str(owner_account_id).unwrap()
    }
}

'''
'''--- src/types/crypto_hash.rs ---
#[derive(Debug, Default, Clone)]
pub struct CryptoHash(pub near_primitives::hash::CryptoHash);

impl From<CryptoHash> for near_primitives::hash::CryptoHash {
    fn from(item: CryptoHash) -> Self {
        item.0
    }
}

impl std::fmt::Display for CryptoHash {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        self.0.fmt(f)
    }
}

impl std::str::FromStr for CryptoHash {
    type Err = Box<dyn std::error::Error>;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let crypto_hash =
            near_primitives::hash::CryptoHash::from_str(s).map_err(|err| err.to_string())?;
        Ok(Self(crypto_hash))
    }
}

impl interactive_clap::ToCli for CryptoHash {
    type CliVariant = CryptoHash;
}

'''
'''--- src/types/mod.rs ---
pub mod account_id;
pub mod crypto_hash;
pub mod path_buf;
pub mod public_key;
pub mod secret_key;
pub mod signature;
pub mod slip10;
pub mod url;
pub mod vec_string;

'''
'''--- src/types/path_buf.rs ---
#[derive(Debug, Default, Clone)]
pub struct PathBuf(pub std::path::PathBuf);

impl From<PathBuf> for std::path::PathBuf {
    fn from(path_buf: PathBuf) -> Self {
        path_buf.0
    }
}

impl From<std::path::PathBuf> for PathBuf {
    fn from(path_buf: std::path::PathBuf) -> Self {
        Self(path_buf)
    }
}

impl std::fmt::Display for PathBuf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0.display())
    }
}

impl std::str::FromStr for PathBuf {
    type Err = core::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let path_buf = std::path::PathBuf::from_str(s)?;
        Ok(Self(path_buf))
    }
}

impl interactive_clap::ToCli for PathBuf {
    type CliVariant = PathBuf;
}

'''
'''--- src/types/public_key.rs ---
#[derive(Debug, Clone, PartialEq, PartialOrd, Ord, Eq)]
pub struct PublicKey(pub near_crypto::PublicKey);

impl std::fmt::Display for PublicKey {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        self.0.fmt(f)
    }
}

impl std::str::FromStr for PublicKey {
    type Err = near_crypto::ParseKeyError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let public_key = near_crypto::PublicKey::from_str(s)?;
        Ok(Self(public_key))
    }
}

impl From<PublicKey> for near_crypto::PublicKey {
    fn from(item: PublicKey) -> Self {
        item.0
    }
}

impl From<near_crypto::PublicKey> for PublicKey {
    fn from(item: near_crypto::PublicKey) -> Self {
        Self(item)
    }
}

impl interactive_clap::ToCli for PublicKey {
    type CliVariant = PublicKey;
}

'''
'''--- src/types/secret_key.rs ---
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SecretKey(pub near_crypto::SecretKey);

impl std::fmt::Display for SecretKey {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        self.0.fmt(f)
    }
}

impl std::str::FromStr for SecretKey {
    type Err = near_crypto::ParseKeyError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let public_key = near_crypto::SecretKey::from_str(s)?;
        Ok(Self(public_key))
    }
}

impl From<SecretKey> for near_crypto::SecretKey {
    fn from(item: SecretKey) -> Self {
        item.0
    }
}

impl interactive_clap::ToCli for SecretKey {
    type CliVariant = SecretKey;
}

'''
'''--- src/types/signature.rs ---
#[derive(Debug, Clone)]
pub struct Signature(pub near_crypto::Signature);

impl std::fmt::Display for Signature {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        self.0.fmt(f)
    }
}

impl std::str::FromStr for Signature {
    type Err = near_crypto::ParseSignatureError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let signature = near_crypto::Signature::from_str(s)?;
        Ok(Self(signature))
    }
}

impl From<Signature> for near_crypto::Signature {
    fn from(item: Signature) -> Self {
        item.0
    }
}

'''
'''--- src/types/slip10.rs ---
#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
pub struct BIP32Path(pub slip10::BIP32Path);

impl std::fmt::Display for BIP32Path {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        self.0.fmt(f)
    }
}

impl std::str::FromStr for BIP32Path {
    type Err = color_eyre::eyre::Report;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let bip32path = slip10::BIP32Path::from_str(s).map_err(Self::Err::msg)?;
        Ok(Self(bip32path))
    }
}

impl From<BIP32Path> for slip10::BIP32Path {
    fn from(item: BIP32Path) -> Self {
        item.0
    }
}

impl interactive_clap::ToCli for crate::types::slip10::BIP32Path {
    type CliVariant = crate::types::slip10::BIP32Path;
}

'''
'''--- src/types/url.rs ---
#[derive(Debug, Clone)]
pub struct Url(pub url::Url);

impl From<Url> for url::Url {
    fn from(url: Url) -> Self {
        url.0
    }
}

impl From<url::Url> for Url {
    fn from(url: url::Url) -> Self {
        Self(url)
    }
}

impl std::fmt::Display for Url {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.0.fmt(f)
    }
}

impl std::str::FromStr for Url {
    type Err = url::ParseError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let url = url::Url::parse(s)?;
        Ok(Self(url))
    }
}

impl interactive_clap::ToCli for Url {
    type CliVariant = Url;
}

'''
'''--- src/types/vec_string.rs ---
#[derive(Debug, Default, Clone)]
pub struct VecString(pub Vec<String>);

impl std::fmt::Display for VecString {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for VecString {
    type Err = color_eyre::eyre::ErrReport;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let vec_str: Vec<String> = s
            .trim_matches(|p| p == '[' || p == ']')
            .split(",")
            .map(|str| str.trim().to_string())
            .collect();
        Ok(Self(vec_str))
    }
}

impl From<VecString> for Vec<String> {
    fn from(item: VecString) -> Self {
        item.0
    }
}

impl interactive_clap::ToCli for VecString {
    type CliVariant = VecString;
}

'''
'''--- src/utils_command/generate_keypair_subcommand/mod.rs ---
use std::str::FromStr;

/// Generate a key pair of private and public keys (use it anywhere you need
/// Ed25519 keys)
#[derive(Debug, Clone, clap::Parser)]
pub struct CliGenerateKeypair {
    #[clap(long)]
    pub master_seed_phrase: Option<String>,
    #[clap(long, default_value = "12")]
    pub new_master_seed_phrase_words_count: usize,
    #[clap(long, default_value = "m/44'/397'/0'")]
    pub seed_phrase_hd_path: crate::types::slip10::BIP32Path,
    #[clap(long, default_value = "plaintext")]
    pub format: crate::common::OutputFormat,
}

impl Default for CliGenerateKeypair {
    fn default() -> Self {
        Self {
            master_seed_phrase: None,
            new_master_seed_phrase_words_count: 12,
            seed_phrase_hd_path: crate::types::slip10::BIP32Path::from_str("m/44'/397'/0'")
                .unwrap(),
            format: crate::common::OutputFormat::Json,
        }
    }
}

impl CliGenerateKeypair {
    pub async fn process(self) -> crate::CliResult {
        let key_pair_properties = crate::common::generate_keypair().await?;
        match self.format {
            crate::common::OutputFormat::Plaintext => {
                println!(
                    "Master Seed Phrase: {}\nSeed Phrase HD Path: {}\nImplicit Account ID: {}\nPublic Key: {}\nSECRET KEYPAIR: {}",
                    key_pair_properties.master_seed_phrase,
                    key_pair_properties.seed_phrase_hd_path.to_string(),
                    key_pair_properties.implicit_account_id,
                    key_pair_properties.public_key_str,
                    key_pair_properties.secret_keypair_str,
                );
            }
            crate::common::OutputFormat::Json => {
                println!(
                    "{}",
                    serde_json::to_string_pretty(&serde_json::json!({
                        "master_seed_phrase": key_pair_properties.master_seed_phrase,
                        "seed_phrase_hd_path": key_pair_properties.seed_phrase_hd_path.to_string(),
                        "account_id": key_pair_properties.implicit_account_id,
                        "public_key": key_pair_properties.public_key_str,
                        "private_key": key_pair_properties.secret_keypair_str,
                    }))
                    .unwrap()
                );
            }
        };
        Ok(())
    }
}

'''
'''--- src/utils_command/mod.rs ---
pub mod generate_keypair_subcommand;

'''