*GitHub Repository "ahsan-arif/Near-Staking-DApp"*

'''--- webapp/public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- webapp/public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- webapp/src/App.js ---
import './App.css';
import Header from './components/Header';
import StakingComponent from './components/StakingComponent';
import NearProvider from './provider/NearProvider';

function App() {
  return (
    <div className="App">
    <NearProvider>
        <Header/>
      <StakingComponent/>
      </NearProvider>
      
    </div>
  );
}

export default App;

'''
'''--- webapp/src/App.test.js ---
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

'''
'''--- webapp/src/components/APYComponent.js ---
import { Grid, TableBody, Typography ,TableContainer,Table,Paper} from "@mui/material";
import { useContext, useEffect, useState } from "react";
import { NearContext } from "../provider/NearProvider";
import APYTableBody from "./APYTablebody";
import APYTableHead from "./APYTableHead";

export default function APYComponent(){
    const {getAPY,account} = useContext(NearContext)
    const [ftApy, setFtApy] = useState([])

    useEffect(()=>{
        const ftApys = async()=>{
            const response  = await getAPY()
            console.log("apys",response.apy_against_duration)
       let tempArr=[]
Object.values(response.apy_against_duration).map(item=>{
    tempArr=[...tempArr,item]
  
})
setFtApy(tempArr)
//console.log('tempArr', ftApy)

        }
        if (account){
            ftApys()
        }
    })
    return (
        <Grid container xs={12}>
            <Typography variant="h7" sx={{width:'100%'}}>APY Rates</Typography>
            <Grid item xs={12} marginTop="20px">
            <TableContainer component={Paper} sx={{maxWidth : '90%', marginTop :'10px'}}>
            <Table aria-label="simple table" size="small" >
                <APYTableHead/>
                <TableBody>
                    {ftApy?.map((apy)=>{
                        const {apy_key,interest_rate,min_duration,min_staking_amount} = apy
                        return  <APYTableBody key={apy_key} apyKey={apy_key} interestRate = {interest_rate} minDuration = {min_duration} minStakingAmount = {min_staking_amount}/>
                    })}
                </TableBody>
            </Table>
            </TableContainer>
            </Grid>
        </Grid>
    )
}
'''
'''--- webapp/src/components/APYTableHead.js ---
import { TableHead, TableRow, TableCell, Typography } from "@mui/material"
export default function APYTableHead(){

    return(
        <TableHead>
        <TableRow>
            <TableCell>
                <Typography>Staking Plan</Typography>
            </TableCell>
            <TableCell>
                <Typography>Min Tokens</Typography>
            </TableCell>
            <TableCell>
                <Typography>Lock Period (Mins)</Typography>
            </TableCell>
            <TableCell>
                <Typography>APY</Typography>
            </TableCell>
        </TableRow>
    </TableHead>
    )

 
}
'''
'''--- webapp/src/components/APYTablebody.js ---
import { TableCell, TableRow } from "@mui/material";
import { formatNearAmount, parseNearAmount } from "near-api-js/lib/utils/format";

export default function APYTableBody({apyKey,interestRate,minDuration,minStakingAmount}){
    const amount = formatNearAmount(minStakingAmount)
    const interest = (interestRate/10) + "%";
    const apy = minDuration +" "+"Minutes"
    return(
        <TableRow>
            <TableCell>
            {apy || "N/A"}
            </TableCell>
            <TableCell>
               {amount || "NA" }
            </TableCell>
            <TableCell>
                {minDuration || "NA"}
            </TableCell>
            <TableCell>
                {interest || "NA"}
            </TableCell>
        </TableRow>
    )
}
'''
'''--- webapp/src/components/AccountBalance.js ---
import { useEffect,useState } from "react";
import {  Grid, TextField, Typography , Button } from "@mui/material";
import { NearContext } from '../provider/NearProvider';
import { useContext } from 'react';
import { formatNearAmount } from "near-api-js/lib/utils/format";

export default function AccountBalance(){
    const [accountBalance,setAccountBalance]=useState(0)
    const { account, getFTBalance, getAirdrop } = useContext(NearContext)
    useEffect(() => {
        const getBalance = async () => {
            let balance=await getFTBalance()
            //balance = parseInt(balance)
            setAccountBalance(formatNearAmount(balance))
        }
        if(account){
            getBalance()
        }
    },[account,getFTBalance])
    return (
       
        <Grid container spacing={2}>
            <Grid item >
                <Typography variant="h7">Account Balance :</Typography>
            </Grid>
            <Grid item xs={3} container spacing={2}>
                {!account ? (
                
                <Grid item xs={6}>
                <Typography variant="h8">Connect wallet</Typography>
                </Grid>
                ) : (
                <>
                <Grid item xs={6}>
                {/* <Typography variant="h8">{accountBalance ?  parseFloat(accountBalance.replace(/\,/g,''), 10).toFixed(2) : "0"} UNCT</Typography> */}
                <Typography variant="h8">{typeof(accountBalance)==="string" ? parseFloat(accountBalance.replace(/\,/g,''), 10).toFixed(2) : typeof(accountBalance)==="number" ? accountBalance.toFixed(2):"0" } UNCT</Typography>
                                
                </Grid>
                <Grid item xs={6}>
                                <Button variant="outlined" onClick={() => {
                                    getAirdrop()
                }} type="primary">Get UNCT</Button>

                </Grid>
                        </>        
                )}
            </Grid>
        </Grid>
 
        )
}
    

'''
'''--- webapp/src/components/Header.js ---
import * as React from 'react';
import AppBar from '@mui/material/AppBar';
import Box from '@mui/material/Box';
import Toolbar from '@mui/material/Toolbar';
import Typography from '@mui/material/Typography';
import Button from '@mui/material/Button';
// import {login} from '../provider/NearProvider'
import { NearContext } from '../provider/NearProvider';
import { useContext } from 'react';

export default function ButtonAppBar() {
const {login,isConnecting,accountId,isSignedIn,isRegistered,logout} = useContext(NearContext)
const handleLoginChange =()=>{
   login();
   /* let abc = isRegistered()
   console.log("response", abc) */
  }
  return (
    <Box sx={{ flexGrow: 1, width : '100%' }}>
      <AppBar position="static">
        <Toolbar>
         {/*  <IconButton
            size="large"
            edge="start"
            color="inherit"
            aria-label="menu"
            sx={{ mr: 2 }}
          >
            <MenuIcon />
          </IconButton> */}
          <Typography variant="h6" component="div" sx={{width : "210px"}}>
            UNCT Staking Portal
          </Typography>
          <Box sx={{ display : 'flex' ,justifyContent : 'flex-end' ,width: '100%'}}>
        {isSignedIn ?   <Typography component = "div" >{accountId}</Typography>: <Button color="inherit" sx={{display:"visible"}} onClick={handleLoginChange}>Connect Wallet</Button>}

          </Box>
          {isSignedIn && (
              <Button color="inherit" sx={{whiteSpace:'no-wrap',width:'10%'}} onClick={logout}>
                Log Out
              </Button>
        )}
        </Toolbar>
        {/* <Typography variant="h6" component="div" sx={{justifyContent : 'flex-end'}}>Balance</Typography> */}
      </AppBar>
    </Box>
  );
}

'''
'''--- webapp/src/components/StakeForm.js ---
import {  Paper, TextField } from "@mui/material";
export default function StakingInformation({tokens,setTokens}){
    return(
        
        <Paper component='form' elevation={0}>
            <TextField onChange={(e)=>setTokens(e.target.value)} fullWidth label="Tokens to Stake" id="fullWidth" sx={{maxWidth : '50%'}}/>
        </Paper>
    )
}
'''
'''--- webapp/src/components/StakingComponent.js ---
import { Grid, Paper } from "@mui/material";
import AccountBalance from "./AccountBalance";
import APYComponent from "./APYComponent";
import StakingDuration from "./StakingDuration";
import StakingHistory from "./StakingHistory";

export default function StakingForm() {
    return (
        <Paper sx={{ marginTop: '10px' }} elevation={0}>
            <Grid container marginLeft="8px" marginRight="8px">
                {/* Balance item start */}
                <Grid item xs={12} marginTop="10px" >
                    <AccountBalance />
                </Grid>
                {/* Balance item End */}

                <Grid item xs={12} marginTop="10px" marginLeft="10px" marginRight="10px">
                    <APYComponent marginTop="10px"/>
                </Grid>

                {/* Duration Starts */}
                <Grid item xs={12} marginTop="20px">
                    <StakingDuration />
                </Grid>
                {/* Duration Ends */}

                {/* Textfield Start */}

                <Grid item xs={12}>
                   <StakingHistory/>
                </Grid>
            </Grid>
        </Paper>
    )

}

'''
'''--- webapp/src/components/StakingDuration.js ---
import { useState } from "react";
import { Button, Grid, Typography } from "@mui/material";
import StakingInformation from "./StakeForm";
import { NearContext } from '../provider/NearProvider';
import { useContext } from 'react';
import { parseNearAmount } from "near-api-js/lib/utils/format";

export default function StakingDuration() {
    const [duration,setDuration]=useState(0)
    const [tokens,setTokens]=useState(0)
const {stakeTokens,accountId} = useContext(NearContext)
    return (
        <>
        <Grid container xs={12} marginTop="20px">
            <Typography variant="h7" sx={{width : '100%'}}>Select Duration</Typography>

            <Grid item xs={12} marginTop="20px">
                <Grid container spacing={{xs:2}}>
                <Grid item xs={3} >
                <Button variant={duration===3 ? "contained" : 'text'} onClick={()=>setDuration(3)}>3 Minutes</Button>
            </Grid>
            <Grid item xs={3} >
                <Button variant={duration===6 ? "contained" : 'text'} onClick={()=>setDuration(6)}>6 Minutes</Button>
            </Grid>
            <Grid item xs={3} >
                <Button variant={duration===9 ? "contained" : 'text'} onClick={()=>setDuration(9)}>9 Minutes</Button>
            </Grid>
            <Grid item xs={3}>
                <Button variant={duration===12 ? "contained" : 'text'} onClick={()=>setDuration(12)}>12 Minutes</Button>
            </Grid>
                </Grid> 
            </Grid>

        </Grid>
        <Grid item xs={12} marginTop="20px" marginRight="16px">
                <StakingInformation tokens={tokens} setTokens={setTokens}/>
        </Grid>
        <Button onClick={()=>{
            const msg= {
                ft_symbol : "UNCT",
                ft_account_id:"ncd_ft_token.testnet",
                decimal : 24,
                duration: duration*60,
                staked_by : `${accountId}`,
                staking_plan: `${duration}minutes`
            }
            stakeTokens(parseNearAmount(tokens),JSON.stringify(msg))
        }} sx={{ margin: '10px' }}>Stake</Button>

        </>
    )
}
'''
'''--- webapp/src/components/StakingHistory.js ---
import { useEffect,useState } from "react";
import { Grid,Typography,TableContainer,Table,TableBody,Paper } from "@mui/material"
import StakingData from "./TableBody";
import TableHeadings from "./TableHead";
import { NearContext } from '../provider/NearProvider';
import { useContext } from 'react';
export default function StakingHistory(){
    const {getStakingHistory,account} = useContext(NearContext)
    const [history,setHistory]=useState([])
    useEffect(()=>{
        const getHistory=async()=>{
            const historyResponse=await getStakingHistory('0',10)
            setHistory(historyResponse)
        }
        if(account){
            getHistory()
        }else{
            setHistory([])
        }
    },[account])
    return (
        <Grid container xs={12}>
        <Typography variant="h7" sx={{width:'100%'}}>Staking History</Typography>
        <Grid item xs={12} marginTop="10px">
            <TableContainer component={Paper} sx={{maxWidth : '90%'}}>
                <Table aria-label="simple table" >
                    <TableHeadings />
                    <TableBody>
                        {history?.map((stake)=>{
                            const{stake_id,amount,staked_at,staking_plan}=stake
                            //console.log("stake : ",stake)
                           return <StakingData key={stake_id} stakeId={stake_id} amount={amount} stakedAt={staked_at} stakingPlan = {staking_plan}/>
                        })}
                    </TableBody>
                </Table>
            </TableContainer>
        </Grid>
    </Grid>
    )
}
'''
'''--- webapp/src/components/TableBody.js ---
import { Button, TableCell,TableRow } from "@mui/material"
import { formatNearAmount } from "near-api-js/lib/utils/format";
import { NearContext } from '../provider/NearProvider';
import { useContext } from 'react';
export default function StakingData({stakeId,amount,stakedAt,stakingPlan}){
    const {claimReward,unstakeTokens} = useContext(NearContext)
    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }
    const date=new Date(stakedAt*1000).toLocaleDateString("en-US", options)

    const RewardClaimer=async()=>{
        try {
            await claimReward(stakeId)
        window.location.reload()

        } catch (error) {
            alert("Reward can be claimed after staking for 1 minute")
        }
    }

    const TokenUnStaker=async()=>{
        try {
            await unstakeTokens(stakeId)
        window.location.reload()

        } catch (error) {
            alert("Cannot withdraw before locked time")
        }
    }

    return (
        <TableRow>
        <TableCell>
            {stakeId || "N/A"}
        </TableCell>
        <TableCell>
            {formatNearAmount(amount) || "N/A"}
        </TableCell>
        <TableCell>
            {date || "N/A"}
        </TableCell>
        <TableCell>
            {stakingPlan || "N/A"}
        </TableCell>
        <TableCell>
            <Button onClick={()=>RewardClaimer()}>Claim Reward</Button>
            <Button onClick={TokenUnStaker}>Unstake</Button>
        </TableCell>
    </TableRow>
    
    )
}
'''
'''--- webapp/src/components/TableHead.js ---
import { TableHead, TableRow, TableCell, Typography } from "@mui/material"
export default function TableHeadings() {
    return (
        <TableHead>
            <TableRow>
                <TableCell>
                    <Typography variant="h7">
                        Stake ID
                    </Typography>
                </TableCell>
                <TableCell alig>
                    <Typography variant="h7">
                        Amount Staked
                    </Typography>
                </TableCell>
                <TableCell>
                    <Typography variant="h7">Staked On</Typography>

                </TableCell>
                <TableCell>
                    <Typography variant="h7">Staked For</Typography>

                </TableCell>
                <TableCell>
                    <Typography variant="h7">
                        Actions
                    </Typography>
                </TableCell>
            </TableRow>
        </TableHead>
    )
}
'''
'''--- webapp/src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
    <App />
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

'''
'''--- webapp/src/provider/NearProvider.js ---
import { createContext, useCallback, useEffect, useState } from "react";
import { connect, keyStores, WalletConnection, utils, Contract } from "near-api-js";
import { parseNearAmount } from "near-api-js/lib/utils/format";
/* import NFT from "../models/NFT";
import Purchasable from "../models/Purchasable";
import viewToMax from "../utils/viewToMax"; */

// --- Production: mainnet ---
// const config = {
//   networkId: "mainnet",
//   contractName: "mtvrs-app.near",
//   nodeUrl: "https://rpc.mainnet.near.org",
//   walletUrl: "https://wallet.mainnet.near.org",
//   helperUrl: "https://helper.mainnet.near.org",
//   explorerUrl: "https://explorer.mainnet.near.org",
// };

// --- Development: testnet ---
const config = {
  networkId: "testnet",
  contractName: "ncd_staking_contract.testnet",
  nodeUrl: "https://rpc.testnet.near.org",
  walletUrl: "https://wallet.testnet.near.org",
  helperUrl: "https://helper.testnet.near.org",
  explorerUrl: "https://explorer.testnet.near.org",
};

const GAS = "300000000000000"; // max gas for any transaction

export const NearContext = createContext({});

export default function NearProvider({ children }) {
  // Internal state
  const [, setNearConnection] = useState(null);
  const [walletConnection, setWalletConnection] = useState(null);
  const [accountId, setAccountId] = useState(null);

  // External state.
  const [isConnecting, setIsConnecting] = useState(true);
  const [isSignedIn, setIsSignedIn] = useState(false);
  const [isError, setIsError] = useState(false);
  const [isLoggingIn] = useState(false);
  const [account, setAccount] = useState(null);
  const [accountNearBalance, setAccountNearBalance] = useState(null);
  const [accountUsername, setAccountUsername] = useState(null);
  const [regInfo, setregInfo] = useState({})

  const loginKey = 'loginKey';

  useEffect(() => {
    const keyStore = new keyStores.BrowserLocalStorageKeyStore();
    const connectNear = async () => {
      try {
        const near = await connect({ ...config, keyStore });
        const walletConnection = new WalletConnection(near);
        setNearConnection(near);
        setWalletConnection(walletConnection);

        if (walletConnection.isSignedIn()) {
          const account = walletConnection.account();
          const name = walletConnection._authData.accountId;
          setAccountId(walletConnection.getAccountId());
          setIsSignedIn(true)
          setAccount(account)
          /*     let abc = isRegistered()
       console.log("response", abc) */
        } else {
          setIsSignedIn(false)

        }
      } catch (e) {
        console.error(e);
        setIsError(true);
      }
      setIsConnecting(false);
    };

    connectNear();
  }, []);

  useEffect(() => {
    if (account != null) {
      hasDeposittedForStorage()

    }

  }, [account])

  const getAccountAndNearBalance = useCallback(async () => {
    if (account == null) {
      setAccountNearBalance(null);
      return;
    }

    let balance;
    try {
      balance = await account.getAccountBalance();
    } catch (e) {
      console.error(e);
      setAccountNearBalance(null);
      return;
    }

    setAccountNearBalance(utils.format.formatNearAmount(balance.available, 2));
  }, [account]);

  useEffect(() => {
    // Fetch the near balance.
    getAccountAndNearBalance();
  }, [getAccountAndNearBalance]);

  const login = useCallback(() => {
    // console.log ("near amount", parseNearAmount("0.00859"))
    walletConnection?.requestSignIn({
      contractId: config.contractName,

    }
    );

  }, [walletConnection]);

  const logout = useCallback(() => {
    walletConnection?.signOut();
    setIsSignedIn(false);
    setAccountId(null);
    setAccount(null);
  }, [walletConnection]);

  /*   const getNftsForAccount = useCallback(async () => {
      if (account == null || accountId == null) {
        throw new Error("account must be defined");
      }
  
      const tokens = await viewToMax(
        account,
        config.contractName,
        "nft_tokens_for_owner",
        { account_id: accountId }
      );
  
      return (tokens ?? []).map(NFT.fromNear);
    }, [account, accountId]); */

  /*   const getMetadataForToken = useCallback(
      async (tokenType) => {
        if (account == null) {
          throw new Error("account must be defined");
        }
  
        const token = await account.viewFunction(
          config.contractName,
          "metadata_get",
          {
            token_type: tokenType,
          }
        );
  
        if (token == null) {
          return null;
        }
  
        const tokenList = await viewToMax(
          account,
          config.contractName,
          "minted_tokens_list",
          { token_type: tokenType },
          "offset"
        );
  
        const tokenMaxSupply = parseInt(token.copies);
        const numOfMintedTokens = tokenList?.length ?? 0;
  
        const isAvailable =
          !isNaN(tokenMaxSupply) && numOfMintedTokens < tokenMaxSupply;
  
        return Purchasable.fromNear(tokenType, token, isAvailable);
      },
      [account]
    ); */

  /*   const purchaseNFT = useCallback(
      async (tokenId, quantity) => {
        if (account == null) {
          throw new Error("Account must be defined");
        }
  
        return account.functionCall({
          contractId: config.contractName,
          methodName: "metamon_purchase",
          args: {
            token_type: tokenId,
          },
          gas: GAS,
          // TODO - Get price from master ali.
          attachedDeposit: parseNearAmount("10"),
        });
      },
      [account]
    ); */

  
  const isRegistered = useCallback(
    async () => {
      console.log("account_id and contract", account.accountId + " " + config.contractName)
      if (account == null) {
        throw new Error("Account must be defined");
      }
      return account.viewFunction({
        contractId: config.contractName,
        methodName: "is_registered",
        args: {
          ft_contract_id: "ncd_ft_token.testnet",
          account_id: account.accountId
        }
      });
      console.log('regInfo****', regInfo)
    },
    [account]
    // console.log("account : ",account)
  );

  const hasDeposittedForStorage = useCallback(
    async () => {
      let token;
      if (account != null) {
        token = await account?.viewFunction(
          config.contractName,
          "has_depositted_for_storage",
          {
            ft_contract_id: "ncd_ft_token.testnet",
            account_id: account.accountId
          }
        );
        console.log("has_depositted_for_storage", token)
        if (token === false) {
          depositForStorage()
        }

      }
      setregInfo(token)

    },
    [account]
  );

  const getStakingHistory = useCallback(
    async (fromIndex,limit)=>{
      if (account == null) {
        throw new Error("Account must be defined");
      }
      let history= await account?.viewFunction(
        config.contractName, "get_staking_history",
        {
          account_id : account.accountId,
          from_index : fromIndex,
          limit : limit
        }
        
        );
        return history
    },[account]
    )
    const getAPY =useCallback(
      
      async()=>{
        if (account == null) {
          throw new Error("Account must be defined");
        }
        const res = await account?.viewFunction(
          config.contractName, "get_apy",
          {
            ft_contract_id : "ncd_ft_token.testnet"
          }
        );
        return res
      },[account]
    )

  const depositForStorage = useCallback(
    async () => {
      if (account == null) {
        throw new Error("Account must be defined");
      }
      try {
        const resp = await account.functionCall({
          contractId: config.contractName,
          methodName: "deposit_for_storage",
          args: {
            ft_contract_id: "ncd_ft_token.testnet"
          }, gas: GAS,
          attachedDeposit: parseNearAmount("0.00859")
        })
        console.log('resp*****', resp)
      } catch (error) {
        console.log('error****', error)
      }

    }, [account]
  );

  const claimReward = useCallback(
    async (stakeId) => {
      if (account == null) {
        throw new Error("Account must be defined");
      }
      return account.functionCall({
        contractId: config.contractName,
        methodName: "claim_reward",
        args: {
          stake_id: stakeId
        },
        gas: GAS
      })
    }, [account]
  )

  const unstakeTokens = useCallback(
    async (stakeId) => {
      if (account == null) {
        throw new Error("Account must be defined");
      }
      return account.functionCall({
        contractId: config.contractName,
        methodName: "ft_unstake",
        args: {
          stake_id: stakeId
        }, gas: GAS
      })
    }, [account]
  )

  const getFTBalance = useCallback(
    async()=>{
      if (account === null){
        throw new Error("Account must be defined");
      }
      const ftContract =  new Contract(account,"ncd_ft_token.testnet",{
        viewMethods : ["ft_balance_of"],
        sender : account.accountId
      })
      let balance;
      balance = await ftContract?.ft_balance_of(
        {account_id : account.accountId}
      );
      return balance
    },[account]
  )

  const getAirdrop =useCallback(
    async()=>{
      try {
        if (account == null){
          throw new Error("Account must be defined");
        }
        const stakingContract =  new Contract(account,"ncd_staking_contract.testnet",{
          changeMethods : ["drop_ft"], sender : account.accountId
        })
        let response;
        response = await stakingContract?.drop_ft(
          {account_id : account.accountId, ft_contract_id : "ncd_ft_token.testnet"}
        );
        window.location.reload()
        return response
      } catch (error) {
        alert("Already claimed drop")
      }
    },[account]
  )

  const stakeTokens = useCallback(
    async(amt,message)=>{
      if (account == null){
        throw new Error("Account must be defined");
      }
      const res = await account.functionCall(
        {
          contractId : "ncd_ft_token.testnet",
          methodName : "ft_transfer_call",
          args:{
            receiver_id : "ncd_staking_contract.testnet",
            amount : amt,
            msg: message
          },gas : GAS,attachedDeposit: utils.format.parseNearAmount(
            "0.000000000000000000000001"
          )
        }
      )

  /*     const ftContract = new Contract(account, "ncd_ft_token.testnet", {
        changeMethods : ["ft_transfer_call"], sender : account.accountId
      })
      let response = await ftContract?.ft_transfer_call(
        {receiver_id : "ncd_staking_contract.testnet",amount: amt,msg : message,attachedDeposit: parseNearAmount("0.000000000000000000000001") }
      );
      return response */
      return res
    },[account]
  )

 /*  const res = await account.functionCall({
    contractId: contractName,
    methodName: change_methods.STAKE_TOKENS,
    args: {
      receiver_id: "staking_bkrt.testnet",
      amount: amount,
      msg: JSON.stringify({
        ft_symbol: "BKRT",
        ft_account_id: "ft_bkrt.testnet",
        decimal: 24,
        duration: duration,
        staked_by: walletAccountId,
        staking_plan: "BKRTPremium6",
      }),
    },

    gas: digits.GAS,
    // // TODO - Get price from master ali.
    attachedDeposit: utils.format.parseNearAmount(
      "0.000000000000000000000001"
    ),
  }); */

 

  /*   const stakeTokens = useCallback(
      async ()=>{
        if(account==null){
          throw new Error("Account must be defined");
        }
        return account.functionCall({
          contractId : ft_contract_id,
          methodName : "ft_transfer_call",
          args : {
            receiver_id : config.contractName,
  
          }
        })
      },[account]
    ) */

  const redeemSurprisePack = useCallback(
    (tokenId) => {
      if (account == null) {
        throw new Error("Account Must be defined");
      }

      return account.functionCall({
        contractId: config.contractName,
        methodName: "metamon_redeem_surprise_pack",
        args: {
          token_id: tokenId,
        },
        gas: GAS,
      });
    },
    [account]
  );

  const evolveToNextGeneration = useCallback(
    (firstTokenId, secondTokenId) => {
      if (
        firstTokenId == null ||
        secondTokenId == null ||
        firstTokenId === "" ||
        secondTokenId === "" ||
        firstTokenId === secondTokenId
      ) {
        throw new Error("Tokens must be unique and defined");
      }

      if (account == null) {
        throw new Error("Accoutn msut be defined");
      }

      return account.functionCall({
        contractId: config.contractName,
        methodName: "metamon_evolve",
        args: {
          token1_id: firstTokenId,
          token2_id: secondTokenId,
        },
        gas: GAS,
      });
    },
    [account]
  );
  return (
    
    <NearContext.Provider
      value={{
        accountUsername,
        isConnecting,
        isLoggingIn,
        isError,
        isSignedIn,
        login,
        logout,
        depositForStorage,
        isRegistered,
        accountNearBalance,
        getAccountAndNearBalance,
        redeemSurprisePack,
        evolveToNextGeneration,
        accountId,
        account,
        getFTBalance,
        getAirdrop,
        stakeTokens,
        getStakingHistory,
        unstakeTokens,
        claimReward,
        getAPY
      }}
    >
      {children}
    </NearContext.Provider>
  );
}
'''
'''--- webapp/src/reportWebVitals.js ---
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

'''
'''--- webapp/src/setupTests.js ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

'''