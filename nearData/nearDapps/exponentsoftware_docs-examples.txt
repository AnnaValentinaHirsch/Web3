*GitHub Repository "exponentsoftware/docs-examples"*

'''--- README.md ---
# Docs Snippets

This repository holds all the code snippets that are displayed in [near-docs.io](near-docs.io).

'''
'''--- cross-contract-hello-as/README.md ---
# Cross-Contract Assemblyscript

An example on how to write AS cross-contract code

'''
'''--- cross-contract-hello-as/contract/as-pect.config.js ---
module.exports = require('near-sdk-as/imports')
'''
'''--- cross-contract-hello-as/contract/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- cross-contract-hello-as/contract/assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- cross-contract-hello-as/contract/assembly/__tests__/main.spec.ts ---
import { Context, storage, VMContext } from "near-sdk-as";

import { init } from '..';

describe("Initializing", () => {
  it("initializes correctly", () => {
    VMContext.setPredecessor_account_id(Context.contractName)
    init("test-account")
    const stored_account = storage.getSome<string>('hello-near')
    expect(stored_account).toBe("test-account", "Error during init")
  })
})
'''
'''--- cross-contract-hello-as/contract/assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- cross-contract-hello-as/contract/assembly/external.ts ---
import { context, ContractPromise, ContractPromiseResult, u128 } from "near-sdk-as";

// Constants
export const TGAS: u64 = 1000000000000;
export const NO_DEPOSIT: u128 = u128.Zero;
export const XCC_SUCCESS = 1

// Auxiliary Method: Make the callback private and return its result
export function get_callback_result(): ContractPromiseResult {
  assert(
    context.predecessor == context.contractName,
    "Only the contract itself can call this method"
  );

  // Return the result from the external pool
  const results = ContractPromise.getResults();
  assert(results.length == 1, "This is a callback method");
  return results[0];
}

// Auxiliary classes for cross-contract calls
@nearBindgen
export class GreetingArgs {
  constructor(
    public message: string
  ) { }
}
'''
'''--- cross-contract-hello-as/contract/assembly/index.ts ---
import { storage, context, logging, ContractPromise } from "near-sdk-as";
import { get_callback_result, XCC_SUCCESS, TGAS, NO_DEPOSIT, GreetingArgs }  from "./external";

// Public - init function, save the "Hello NEAR" contract account
export function init(hello_account: string): void {
  assert(context.predecessor == context.contractName, "Method new is private");
  storage.set<string>("hello-near", hello_account);
}

// Public - query external greeting
export function query_greeting(): void {
  // Make sure there is enough GAS to execute the callback
  assert(context.prepaidGas >= 20 * TGAS, "Please attach at least 20 Tgas");

  // Create a promise to call  HelloNEAR.get_greeting()
  const hello_address: string = storage.getPrimitive<string>("hello-near", "");

  const promise: ContractPromise = ContractPromise.create(
    hello_address, "get_greeting", "{}", 5*TGAS, NO_DEPOSIT
  );

  // Create a promise to callback, needs 5 Tgas
  const callbackPromise = promise.then(
    context.contractName, "query_greeting_callback", "{}", 5*TGAS, NO_DEPOSIT
  );

  callbackPromise.returnAsResult();
}

// Public callback
export function query_greeting_callback(): string {
  // make callback private and get result
  const response = get_callback_result();

  if (response.status == XCC_SUCCESS) {
    // `get_greeting` succeeded
    const greeting: string = decode<string>(response.buffer);
    logging.log(`The greeting is "${greeting}"`);
    return greeting;
  } else {
    // it failed
    logging.log(`There was an error contacting Hello NEAR`);
    return "";
  }
}

// Public - change external greeting
export function change_greeting(new_greeting: string): void {
  assert(context.prepaidGas >= 20 * TGAS, "Please attach at least 20 Tgas");

  // Create a promise to call HelloNEAR.set_greeting(message:string)
  const args: GreetingArgs = new GreetingArgs(new_greeting);
  const hello_address: string = storage.getPrimitive<string>("hello-near", "");

  const promise: ContractPromise = ContractPromise.create(
    hello_address, "set_greeting", args.encode(), 5*TGAS, NO_DEPOSIT
  );

  // Create a promise to callback, needs 5 Tgas
  const callbackPromise = promise.then(
    context.contractName, "change_greeting_callback", "{}", 5*TGAS, NO_DEPOSIT
  );

  callbackPromise.returnAsResult();
}

// Public callback
export function change_greeting_callback(): bool {
  // make callback private and get result
  const response = get_callback_result();

  if (response.status == XCC_SUCCESS) {
    // `set_greeting` succeeded
    return true;
  } else {
    // it failed
    return false;
  }
}

'''
'''--- cross-contract-hello-as/contract/assembly/tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}
'''
'''--- cross-contract-hello-as/contract/compile.js ---
/* Compile the contract and copy the resulting wasm into `../out` */

// `shelljs` is included in the devDependencies of the root project
const sh = require('shelljs')

// Define the build command
const buildCmd = 'npm run build'

// Execute the build command, storing exit code for later use
const { code } = sh.exec(buildCmd)

// Get package name from Cargo.toml
const packageName = require(`./package.json`).name
const compiledWasm = `./build/release/${packageName}.wasm`

// Create `../out` dir
const destination = `../out`
sh.mkdir('-p', destination)

// Copy link
const outFile = `${destination}/main.wasm`
sh.rm('-f', outFile)
sh.cp('-u', compiledWasm, outFile)

// exit script with the same code as the build command
process.exit(code)
'''
'''--- cross-contract-hello-as/contract/package.json ---
{
  "name": "xcc_hello_contract",
  "version": "1.0.0",
  "license": "MIT",
  "private": true,
  "scripts": {
    "build": "asb",
    "test": "asp --nologo"
  },
  "dependencies": {
    "near-sdk-as": "^3.2.1"
  },
  "devDependencies": {
    "shelljs": "^0.8.4"
  }
}

'''
'''--- cross-contract-hello-as/neardev/shared-test/test.near.json ---
{"account_id":"test.near","private_key":"ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw"}

'''
'''--- cross-contract-hello-as/package.json ---
{
  "name": "xcc_hello",
  "version": "1.0.0",
  "license": "UNLICENSED",
  "scripts": {
    "test": "npm run build && cd contract && npm run test && cd .. && jest test --runInBand",
    "jest": "npm run build && jest test --runInBand",
    "build": "cd contract && node ./compile.js",
    "deploy": "npm run build && near dev-deploy"
  },
  "devDependencies": {
    "asbuild": "^0.2.0",
    "env-cmd": "~10.1.0",
    "jest": "~27.5.1",
    "jest-environment-node": "~27.5.1",
    "near-cli": "~3.2.0",
    "shelljs": "~0.8.5"
  },
  "dependencies": {
    "near-sdk-as": "^3.2.3"
  },
  "jest": {
    "testEnvironment": "near-cli/test_environment",
    "testPathIgnorePatterns": [
      "<rootDir>/contract/",
      "<rootDir>/node_modules/"
    ]
  }
}

'''
'''--- cross-contract-hello-as/test/cross-hello.test.js ---
const { Near, Account, Contract } = nearAPI;
const { deploy_contract } = require('./near_wrapper')

describe('Cross-contract Greetings', function () {
  let contract
  const hello_address = `hello.${nearConfig.contractName}`

  jest.setTimeout(1200000);

  beforeAll(async function () {
    // Deploy hello-near contract
    await deploy_contract(hello_address, `${__dirname}/aux_contracts/hello-near.wasm`)

    // Connect to our contract
    const near = await new Near(nearConfig);
    const user = await new Account(near.connection, nearConfig.contractName);
    contract = await new Contract(
      user,
      nearConfig.contractName,
      { viewMethods: [], changeMethods: ["init", "query_greeting", "change_greeting"] });
  });

  describe('Cross-contract Greetings', function () {
    it("Initializes", async () => {
      await contract.init({args: {hello_account: hello_address}})
    })
    it("returns the default greeting", async () => {
      const message = await contract.query_greeting({args:{}});
      expect(message).toBe("Hello");
    });
    it("should change the greeting", async () => {
      await contract.change_greeting({ args: { new_greeting: "Howdy" } });
      const message = await contract.query_greeting({args:{}});
      expect(message).toBe("Howdy");
    });
  });
});
'''
'''--- cross-contract-hello-as/test/near_wrapper.js ---
// Functions to interact with the NEAR network
const { keyStores: { InMemoryKeyStore }, Near, KeyPair, Account,
				Contract, utils: {format: { parseNearAmount, formatNearAmount } }, transactions: { deployContract } } = nearAPI
const BN = require('bn.js')
const fs = require("fs")

// Load credentials
const credPath = `./neardev/${nearConfig.networkId}/${nearConfig.contractName}.json`

let credentials
try {
	credentials = JSON.parse(fs.readFileSync(credPath));
} catch(e) {
	console.warn(e)
	/// attempt to load backup creds from local machine
	credentials = JSON.parse(
		fs.readFileSync(
			`${process.env.HOME}/.near-credentials/${nearConfig.networkId}/${nearConfig.contractName}.json`
		)
	);
}

// Create an InMemoryKeyStore
const keyStore = new InMemoryKeyStore();

keyStore.setKey(
	nearConfig.networkId,
	nearConfig.contractName,
	KeyPair.fromString(credentials.private_key)
);

// Connect to the NEAR blockchain
const near = new Near({
	networkId: nearConfig.networkId, nodeUrl:nearConfig.nodeUrl, deps: { keyStore } 
});

// Aux function to create accounts
const DEFAULT_NEW_ACCOUNT_AMOUNT = "20"

async function createAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT, secret) {
	const contractAccount = new Account(near.connection, nearConfig.contractName);
	const newKeyPair = secret ? KeyPair.fromString(secret) : KeyPair.fromRandom('ed25519');
	await contractAccount.createAccount(accountId, newKeyPair.publicKey, new BN(parseNearAmount(fundingAmount)));
	keyStore.setKey(nearConfig.networkId, accountId, newKeyPair);
	return new Account(near.connection, accountId);
}

// Get the account or create it if it doesn't exists
async function getOrCreateAccount(accountId) {
	// accountId must be with `${something}.${contractName}`
	const account = new Account(near.connection, accountId);
	try {
		await account.state();
		return account;
	} catch(e) {
		if (!/does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return await createAccount(accountId);
};

// Create Contract
async function create_contract(accountId, viewMethods, changeMethods, contractId){
	let account = await getOrCreateAccount(accountId)
	const contractMethods = { viewMethods, changeMethods };
	return new Contract(account, contractId || nearConfig.contractName, contractMethods);
}

wallet_balance = async function (account_id) {
	let account = await near.account(account_id)
	let balance = await account.getAccountBalance()

	balance.total = parseFloat(formatNearAmount(balance.total))
	balance.available = parseFloat(formatNearAmount(balance.available))

	return balance
}

async function deploy_contract(accountId, filePath){
	const validator = await getOrCreateAccount(accountId)
	const validatorContractBytes = fs.readFileSync(filePath);

	await validator.signAndSendTransaction({
		receiverId: accountId,
		actions: [deployContract(validatorContractBytes)]
	});
}

module.exports = {create_contract, wallet_balance, deploy_contract}
'''
'''--- cross-contract-hello-rs/README.md ---
# Cross-Contract in RUST

An example for cross-contract code writen in RUST

'''
'''--- cross-contract-hello-rs/contract/Cargo.toml ---
[package]
name = "cross_contract_call"
version = "1.0.0"
authors = ["Guillermo Gallardo <guillermo@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
uint = { version = "0.8.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- cross-contract-hello-rs/contract/README.md ---
Donation Smart Contract
=======================

A [smart contract] written in [RUST] 

Exploring The Code
==================

1. The main smart contract code lives in `src/lib.rs`. You can compile
   by running `cargo build`.
2. Tests: You can run smart contract tests by doing `cargo test`.

  [smart contract]: https://docs.near.org/
  [RUST]: https://doc.rust-lang.org/book/title-page.html
'''
'''--- cross-contract-hello-rs/contract/src/external.rs ---
use near_sdk::{ext_contract};

pub const TGAS: u64 = 1_000_000_000_000;
pub const NO_DEPOSIT: u128 = 0;
pub const XCC_SUCCESS: u64 = 1;

// Interface of this contract, for callbacks
#[ext_contract(this_contract)]
trait Callbacks {
  fn query_greeting_callback(&mut self) -> String;
  fn change_greeting_callback(&mut self) -> bool;
}

// Validator interface, for cross-contract calls
#[ext_contract(hello_near)]
trait HelloNear {
  #[payable]
  fn get_greeting(&mut self) -> String;
  fn set_greeting(&self, message: String);
}
'''
'''--- cross-contract-hello-rs/contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, log, near_bindgen, AccountId, Gas, Promise, PromiseError, PanicOnDefault};

pub mod external;
pub use crate::external::*;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
  pub hello_account: AccountId
}

#[near_bindgen]
impl Contract {
  #[init]
  #[private] // Public - but only callable by env::current_account_id()
  pub fn new(hello_account: AccountId) -> Self {
    assert!(!env::state_exists(), "Already initialized");
    Self {
      hello_account,
    }
  }

  // Public - query external greeting
  pub fn query_greeting(&self) -> Promise {
    // Create a promise to call HelloNEAR.get_greeting()
    let promise = hello_near::ext(self.hello_account.clone())
      .with_static_gas(Gas(5*TGAS))
      .get_greeting();
    
    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .with_static_gas(Gas(5*TGAS))
      .query_greeting_callback()
    )
  }

  #[private] // Public - but only callable by env::current_account_id()
  pub fn query_greeting_callback(&self, #[callback_result] call_result: Result<String, PromiseError>) -> String {
    // Check if the promise succeeded by calling the method outlined in external.rs
    if call_result.is_err() {
      log!("There was an error contacting Hello NEAR");
      return "".to_string();
    }

    // Return the greeting
    let greeting: String = call_result.unwrap();
    greeting
  }

  // Public - change external greeting
  pub fn change_greeting(&mut self, new_greeting: String) -> Promise {
    // Create a promise to call HelloNEAR.set_greeting(message:string)
    hello_near::ext(self.hello_account.clone())
      .with_static_gas(Gas(5*TGAS))
      .set_greeting(new_greeting)
    .then( // Create a callback change_greeting_callback
      Self::ext(env::current_account_id())
      .with_static_gas(Gas(5*TGAS))
      .change_greeting_callback()
    )
  }

  #[private]
  pub fn change_greeting_callback(&mut self, #[callback_result] call_result: Result<(), PromiseError>) -> bool {
    // Return whether or not the promise succeeded using the method outlined in external.rs
    if call_result.is_err() {
      env::log_str("set_greeting was successful!");
      return true;
    } else {
      env::log_str("set_greeting failed...");
      return false;
    }
  }
}

#[cfg(test)]
mod tests {
    use super::*;

    const HELLO_NEAR: &str = "beneficiary";

    #[test]
    fn initializes() {
        let beneficiary: AccountId = HELLO_NEAR.parse().unwrap();
        let contract = Contract::new(beneficiary);
        assert_eq!(contract.hello_account, HELLO_NEAR.parse().unwrap())
    }
}
'''
'''--- cross-contract-hello-rs/neardev/shared-test/test.near.json ---
{"account_id":"test.near","private_key":"ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw"}

'''
'''--- cross-contract-hello-rs/package.json ---
{
  "name": "donation",
  "version": "1.0.0",
  "license": "UNLICENSED",
  "scripts": {
    "test": "npm run build && cd contract && cargo test && cd .. && jest test --runInBand",
    "jest": "npm run build && jest test --runInBand",
    "build": "npm run build:rustup && npm run build:cpwasm",
      "build:rustup": "cd contract && rustup target add wasm32-unknown-unknown && cargo build --all --target wasm32-unknown-unknown --release",
      "build:cpwasm": "mkdir -p out && rm -f ./out/main.wasm && cp ./contract/target/wasm32-unknown-unknown/release/cross_contract_call.wasm ./out/main.wasm",
    "deploy": "npm run build && near dev-deploy"
  },
  "devDependencies": {
    "env-cmd": "~10.1.0",
    "jest": "~27.5.1",
    "jest-environment-node": "~27.5.1",
    "near-cli": "~3.2.0"
  },
  "dependencies": {
    "near-api-js": "^0.44.2"
  },
  "jest": {
    "testEnvironment": "near-cli/test_environment",
    "testPathIgnorePatterns": [
      "<rootDir>/contract/",
      "<rootDir>/node_modules/"
    ]
  }
}

'''
'''--- cross-contract-hello-rs/test/cross-hello.test.js ---
const { Near, Account, Contract } = nearAPI;
const { deploy_contract } = require('./near_wrapper')

describe('Cross-contract Greetings', function () {
  let contract
  const hello_address = `hello.${nearConfig.contractName}`

  jest.setTimeout(1200000);

  beforeAll(async function () {
    // Deploy hello-near contract
    await deploy_contract(hello_address, `${__dirname}/aux_contracts/hello-near.wasm`)

    // Connect to our contract
    const near = await new Near(nearConfig);
    const user = await new Account(near.connection, nearConfig.contractName);
    contract = await new Contract(
      user,
      nearConfig.contractName,
      { viewMethods: [], changeMethods: ["new", "query_greeting", "change_greeting"] });
  });

  describe('Cross-contract Greetings', function () {
    it("Initializes", async () => {
      await contract.new({args: {hello_account: hello_address}})
    })
    it("returns the default greeting", async () => {
      const message = await contract.query_greeting({args:{}});
      expect(message).toBe("Hello");
    });
    it("should change the greeting", async () => {
      await contract.change_greeting({ args: { new_greeting: "Howdy" } });
      const message = await contract.query_greeting({args:{}});
      expect(message).toBe("Howdy");
    });
  });
});
'''
'''--- cross-contract-hello-rs/test/near_wrapper.js ---
// Functions to interact with the NEAR network
const { keyStores: { InMemoryKeyStore }, Near, KeyPair, Account,
				Contract, utils: {format: { parseNearAmount, formatNearAmount } }, transactions: { deployContract } } = nearAPI
const BN = require('bn.js')
const fs = require("fs")

// Load credentials
const credPath = `./neardev/${nearConfig.networkId}/${nearConfig.contractName}.json`

let credentials
try {
	credentials = JSON.parse(fs.readFileSync(credPath));
} catch(e) {
	console.warn(e)
	/// attempt to load backup creds from local machine
	credentials = JSON.parse(
		fs.readFileSync(
			`${process.env.HOME}/.near-credentials/${nearConfig.networkId}/${nearConfig.contractName}.json`
		)
	);
}

// Create an InMemoryKeyStore
const keyStore = new InMemoryKeyStore();

keyStore.setKey(
	nearConfig.networkId,
	nearConfig.contractName,
	KeyPair.fromString(credentials.private_key)
);

// Connect to the NEAR blockchain
const near = new Near({
	networkId: nearConfig.networkId, nodeUrl:nearConfig.nodeUrl, deps: { keyStore } 
});

// Aux function to create accounts
const DEFAULT_NEW_ACCOUNT_AMOUNT = "20"

async function createAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT, secret) {
	const contractAccount = new Account(near.connection, nearConfig.contractName);
	const newKeyPair = secret ? KeyPair.fromString(secret) : KeyPair.fromRandom('ed25519');
	await contractAccount.createAccount(accountId, newKeyPair.publicKey, new BN(parseNearAmount(fundingAmount)));
	keyStore.setKey(nearConfig.networkId, accountId, newKeyPair);
	return new Account(near.connection, accountId);
}

// Get the account or create it if it doesn't exists
async function getOrCreateAccount(accountId) {
	// accountId must be with `${something}.${contractName}`
	const account = new Account(near.connection, accountId);
	try {
		await account.state();
		return account;
	} catch(e) {
		if (!/does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return await createAccount(accountId);
};

// Create Contract
async function create_contract(accountId, viewMethods, changeMethods, contractId){
	let account = await getOrCreateAccount(accountId)
	const contractMethods = { viewMethods, changeMethods };
	return new Contract(account, contractId || nearConfig.contractName, contractMethods);
}

wallet_balance = async function (account_id) {
	let account = await near.account(account_id)
	let balance = await account.getAccountBalance()

	balance.total = parseFloat(formatNearAmount(balance.total))
	balance.available = parseFloat(formatNearAmount(balance.available))

	return balance
}

async function deploy_contract(accountId, filePath){
	const validator = await getOrCreateAccount(accountId)
	const validatorContractBytes = fs.readFileSync(filePath);

	await validator.signAndSendTransaction({
		receiverId: accountId,
		actions: [deployContract(validatorContractBytes)]
	});
}

module.exports = {create_contract, wallet_balance, deploy_contract}
'''
'''--- donation-as/README.md ---
# Donations Assemblyscript

An example on how to write AS contracts

'''
'''--- donation-as/contract/as-pect.config.js ---
module.exports = require('near-sdk-as/imports')
'''
'''--- donation-as/contract/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- donation-as/contract/assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- donation-as/contract/assembly/__tests__/donation.spec.ts ---
import { Context, u128, VMContext } from "near-sdk-as";

import { init, donate, get_donation_by_number, total_number_of_donation } from '..';
import { get_beneficiary, } from '../model';

const NEAR: u128 = u128.from("1000000000000000000000000")

describe("Initializing", () => {
  it("initializes correctly", () => {
    set_context(Context.contractName, u128.Zero)
    expect(() => { init("beneficiary") }).not.toThrow()
    expect(get_beneficiary()).toBe("beneficiary")
  })
})

describe("Donations", () => {
  it("stores and retrieves donations", ()=>{
    set_context(Context.contractName, u128.Zero)
    expect(() => { init("beneficiary") }).not.toThrow()

    // Make a donation
    set_context("donor_a", u128.One)
    const first_donation_idx = donate()
    const first_donation = get_donation_by_number(first_donation_idx)

    // Check the donation was recorded correctly
    expect(first_donation_idx).toBe(1)
    expect(first_donation.donor).toBe("donor_a")
    expect(first_donation.amount).toBe(u128.One * NEAR)

    // Make another donation
    set_context("donor_b", u128.from(2))
    const second_donation_idx = donate()
    const second_donation = get_donation_by_number(second_donation_idx)

    // Check the donation was recorded correctly
    expect(second_donation_idx).toBe(2)
    expect(second_donation.donor).toBe("donor_b")
    expect(second_donation.amount).toBe(u128.from(2) * NEAR)

    expect(total_number_of_donation()).toBe(2)
  })
})

// Auxiliar fn: create a mock context
function set_context(predecessor: string, near_units: u128): void {
  VMContext.setPredecessor_account_id(predecessor)
  VMContext.setAttached_deposit(near_units * NEAR)
}

'''
'''--- donation-as/contract/assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- donation-as/contract/assembly/index.ts ---
import { u128, context, logging, ContractPromiseBatch } from "near-sdk-as";
import { STORAGE_COST, Donation, add_donation, get_donation,
         set_beneficiary, get_beneficiary, total_donations } from "./model";

// Public - init function, define the beneficiary of donations
export function init(beneficiary: string): void {
  assert(context.predecessor == context.contractName, "Method new is private");
  set_beneficiary(beneficiary);
}

// Public - donate
export function donate(): i32 {
  // assert enough money was attached to at least cover the storage
  assert(context.attachedDeposit > STORAGE_COST, `Attach at least ${STORAGE_COST}`)

  // Get who is calling the method, and how much NEAR they attached
  const donor: string = context.predecessor;
  const amount: u128 = context.attachedDeposit;

  // Record the donation
  const donation_number: i32 = add_donation(donor, amount);
  logging.log(`Thank you ${donor}! donation number: ${donation_number}`);

  // Send the money to the beneficiary
  const beneficiary: string = get_beneficiary();
  ContractPromiseBatch.create(beneficiary).transfer(amount - STORAGE_COST);

  return donation_number;
}

// Public - get donation by number
export function get_donation_by_number(donation_number: i32): Donation {
  return get_donation(donation_number);
}

// Public - get total number of donations
export function total_number_of_donation(): i32 {
  return total_donations();
}

// Public - get a range of donations
export function get_donation_list(from: i32, until: i32): Array<Donation> {
  let result: Array<Donation> = new Array<Donation>();
  for (let i: i32 = from; i <= until; i++) {
    result.push(get_donation(i));
  }
  return result;
}

// Public - beneficiary getter
export function beneficiary(): string {
  return get_beneficiary();
}

// Public - beneficiary setter
export function change_beneficiary(beneficiary: string): void {
  assert(context.predecessor == context.contractName, "Method change_beneficiary is private")
  set_beneficiary(beneficiary);
}
'''
'''--- donation-as/contract/assembly/model.ts ---
import { storage, u128, PersistentVector, context } from "near-sdk-as";

// Class and vector holding donations
@nearBindgen
export class Donation{
  constructor(
    public donor: string,
    public amount: u128
  ) { }
}

// Aprox. cost (u128 + string = 16b + 64b = 80b = 800000000000000000000yN)
export const STORAGE_COST: u128 = u128.from("1000000000000000000000")

const donations = new PersistentVector<Donation>("unique-id-1")

// Beneficiary
export function set_beneficiary(beneficiary: string): void{
  storage.set<string>("beneficiary", beneficiary)
}

export function get_beneficiary(): string{
  return storage.getPrimitive<string>("beneficiary", "v1.faucet.nonofficial.testnet")
}

// Donations
export function add_donation(donor: string, amount: u128): i32 {
  const new_donation: Donation = new Donation(donor, amount)
  donations.push(new_donation)
  return donations.length
}

export function get_donation(donation_number: i32): Donation {
  assert(donation_number > 0 &&  donation_number <= donations.length,
         "Error: Invalid donation number")
  return donations[donation_number - 1]
}

export function total_donations() : i32{
  return donations.length
}
'''
'''--- donation-as/contract/assembly/tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}
'''
'''--- donation-as/contract/package.json ---
{
  "name": "donation_contract",
  "version": "1.0.0",
  "license": "MIT",
  "private": true,
  "scripts": {
    "build": "asb",
    "test": "asp --nologo"
  },
  "dependencies": {
    "near-sdk-as": "^3.2.1"
  },
  "devDependencies": {
    "shelljs": "^0.8.4"
  }
}

'''
'''--- donation-as/frontend/assets/css/global.css ---
* {
  box-sizing: border-box;
}

html {
  --bg: #e7f3ff;
  --fg: #1e1e1e;
  --gray: #555;
  --light-gray: #ccc;
  --shadow: #e6e6e6;
  --success: rgb(90, 206, 132);
  --primary: #FF585D;
  --secondary: #0072CE;

  color: var(--fg);
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  line-height: 1.3;
}

body {
  margin: 0;
  background-color: var(--bg);
}

.donation-box {
  max-width: 24em;
  box-shadow: #bac4cd 0px 0px 18px;
  border-radius: 8px;
}

.column{
  width: 50%;
  float:left;
}

main {
  padding: 2em;
  text-align: justify;
  background-color: #f2f2f2;
  z-index: 1;
  border-radius: 8px;
}

.donation-box-head {
  text-align: center;
  background-color: #fff;
  margin: 0;
  border-radius: 8px 8px 0 0;
  padding: 1em 0em 2em 0em;
}

.logo {
  background-image: url(../img/logo-black.svg);
  background-position: center 0em;
  background-repeat: no-repeat;
  position: relative;
  top: -2em;
  transform: translateX(-50%);
  background-color: #fff;
  padding: 15px 25px;
  height: 40px;
  border-radius: 50px;
  width: 50px;
  box-shadow: #bbb 0px 2px 5px;
}

a,
.link {
  color: var(--primary);
  text-decoration: none;
}
a:hover,
a:focus,
.link:hover,
.link:focus {
  text-decoration: underline;
}
a:active,
.link:active {
  color: var(--secondary);
}

.btn-outline-primary{
  width: 100%;
}

button, input {
  font: inherit;
  outline: none;
}

button.link {
  background: none;
  border: none;
  box-shadow: none;
  display: inline;
}

fieldset {
  border: none;
  padding: 2em 0;
}

form {
  margin: 0.2em -0.5em -1em -0.5em;
}

aside {
  animation: notify ease-in-out 10s;
  background-color: var(--shadow);
  border-radius: 5px;
  bottom: 0;
  font-size: 0.8em;
  margin: 1em;
  padding: 1em;
  position: fixed;
  transform: translateY(10em);
  right: 0;
}
aside footer {
  display: flex;
  font-size: 0.9em;
  justify-content: space-between;
  margin-top: 0.5em;
}
aside footer *:first-child {
  color: var(--success);
}
aside footer *:last-child {
  color: var(--gray);
}
@keyframes notify {
  0% { transform: translateY(10em) }
  5% { transform: translateY(0) }
  95% { transform: translateY(0) }
  100% { transform: translateY(10em) }
}

'''
'''--- donation-as/frontend/assets/img/logo-black.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#24272a"/><stop offset=".42" stop-color="#24272a" stop-opacity="0"/><stop offset=".59" stop-color="#24272a" stop-opacity="0"/><stop offset=".81" stop-color="#24272a"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#24272a"/></svg>
'''
'''--- donation-as/frontend/assets/img/logo-white.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#fff"/><stop offset=".42" stop-color="#fff" stop-opacity="0"/><stop offset=".59" stop-color="#fff" stop-opacity="0"/><stop offset=".81" stop-color="#fff"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#fff"/></svg>
'''
'''--- donation-as/frontend/assets/js/index.js ---
import 'regenerator-runtime/runtime'
import { initContract, login, logout, donate,
         getBeneficiary, latestDonations, getTransactionResult } from './near/utils'

// On submit, get the greeting and send it to the contract
document.querySelector('form').onsubmit = async (event) => {
  event.preventDefault()

  // get elements from the form using their id attribute
  const { fieldset, donation } = event.target.elements

  // disable the form while the value gets updated on-chain
  fieldset.disabled = true

  try {
    await donate(donation.value)
  } catch (e) {
    alert(
      'Something went wrong! ' +
      'Maybe you need to sign out and back in? ' +
      'Check your browser console for more info.'
    )
    throw e
  }

  // re-enable the form, whether the call succeeded or failed
  fieldset.disabled = false
}

document.querySelector('#sign-in-button').onclick = login
document.querySelector('#sign-out-button').onclick = logout

async function fetchBeneficiary() {
  // Get greeting from the contract
  const currentGreeting = await getBeneficiary()

  // Set all elements marked as greeting with the current greeting
  document.querySelectorAll('[data-behavior=beneficiary]').forEach(el => {
    el.innerText = currentGreeting
    el.value = currentGreeting
  })
}

// `nearInitPromise` gets called on page load
window.nearInitPromise = initContract()
                        .then(flow)
                        .catch(console.error)

function flow(){
  if (window.walletConnection.isSignedIn()){
    signedInFlow()
  }else{
    signedOutFlow()
  }
  fetchBeneficiary()
  getAndShowDonations()
}

// Display the signed-out-flow container
function signedOutFlow() {
  document.querySelector('.signed-out-flow').style.display = 'block'
}

async function signedInFlow() {
  // Displaying the signed in flow container
  document.querySelectorAll('.signed-in-flow').forEach(elem => elem.style.display = 'block')

  // Check if there is a transaction hash in the URL (come back from a donation)
  const urlParams = new URLSearchParams(window.location.search);
  const txhash = urlParams.get("transactionHashes")

  if(txhash !== null){
    // Get result from the transaction
    let result = await getTransactionResult(txhash)
    document.querySelector('[data-behavior=donation-number]').innerText = result

    // show notification
    document.querySelector('[data-behavior=notification]').style.display = 'block'

    // remove notification again after css animation completes
    setTimeout(() => {
      document.querySelector('[data-behavior=notification]').style.display = 'none'
    }, 11000)
  }

}

async function getAndShowDonations(){
  document.getElementById('donations-table').innerHTML = 'Loading ...'

  // Load last 10 donations
  let donations = await latestDonations()

  document.getElementById('donations-table').innerHTML = ''

  donations.forEach(elem => {
    let tr = document.createElement('tr')
    tr.innerHTML = `
      <tr>
        <th scope="row">${elem.number}</th>
        <td>${elem.donor}</td>
        <td>${elem.amount}</td>
      </tr>
    `
    document.getElementById('donations-table').appendChild(tr)
  })
}

window.set_donation = async function(amount){
  let data = await fetch("https://api.coingecko.com/api/v3/simple/price?ids=near&vs_currencies=usd").then(response => response.json())
  const near2usd = data['near']['usd']
  const amount_in_near = amount / near2usd
  const rounded_two_decimals = Math.round(amount_in_near * 100) / 100
  document.querySelector('#donation').value = rounded_two_decimals
}
'''
'''--- donation-as/frontend/assets/js/near/config.js ---
import { keyStores } from 'near-api-js'

const CONTRACT_NAME = process.env.CONTRACT_NAME ||'new-awesome-project'

function getConfig(env) {
  switch (env) {

  case 'production':
  case 'mainnet':
    return {
      networkId: 'mainnet',
      nodeUrl: 'https://rpc.mainnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.near.org',
      helperUrl: 'https://helper.mainnet.near.org',
      explorerUrl: 'https://explorer.mainnet.near.org',
      deps: { keyStore: new keyStores.BrowserLocalStorageKeyStore() }
    }
  case 'development':
  case 'testnet':
    return {
      networkId: 'testnet',
      nodeUrl: 'https://rpc.testnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.testnet.near.org',
      helperUrl: 'https://helper.testnet.near.org',
      explorerUrl: 'https://explorer.testnet.near.org',
      deps: { keyStore: new keyStores.BrowserLocalStorageKeyStore() }
    }
  default:
    throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
  }
}

module.exports = getConfig

'''
'''--- donation-as/frontend/assets/js/near/utils.js ---
import { connect, Contract, WalletConnection, utils, providers } from 'near-api-js'
import { formatError } from 'near-api-js/lib/utils/rpc_errors'

import getConfig from './config'

const nearConfig = getConfig(process.env.NODE_ENV || 'development')

// Initialize contract & set global variables
export async function initContract() {
  // Initialize connection to the NEAR testnet
  window.near = await connect(nearConfig)

  // Initializing Wallet based Account. It can work with NEAR testnet wallet that
  // is hosted at https://wallet.testnet.near.org
  window.walletConnection = new WalletConnection(window.near)

  // Initializing our contract APIs by contract name and configuration
  window.contract = await new Contract(window.walletConnection.account(), nearConfig.contractName, {
    // View methods are read only. They don't modify the state, but usually return some value.
    viewMethods: ['beneficiary', 'get_donation_list', 'total_number_of_donation'],
    // Change methods can modify the state. But you don't receive the returned value when called.
    changeMethods: ['donate'],
  })
}

export function logout() {
  window.walletConnection.signOut()
  // reload page
  window.location.replace(window.location.origin + window.location.pathname)
}

export function login() {
  // Allow the current app to make calls to the specified contract on the
  // user's behalf.
  // This works by creating a new access key for the user's account and storing
  // the private key in localStorage.
  window.walletConnection.requestSignIn(nearConfig.contractName)
}

export async function getTransactionResult(txhash){
  const transaction = await window.near.connection.provider.txStatus(txhash, window.walletConnection.getAccountId())
  return providers.getTransactionLastResult(transaction)
}

export async function getBeneficiary() {
  return await window.contract.beneficiary()
}

export async function latestDonations() {
  const total_donations = await window.contract.total_number_of_donation()

  const min = total_donations > 10 ? total_donations - 9 : 1;
  let donations = await window.contract.get_donation_list({ from: min, until: total_donations })

  for (let i = 0; i < donations.length; i++) {
    const amount = utils.format.formatNearAmount(donations[i].amount)
    const rounded_two_decimals = Math.floor(amount * 100) / 100
    donations[i].amount = rounded_two_decimals
    donations[i].number = min + i
  }

  return donations
}

export async function donate(amount) {
  amount = utils.format.parseNearAmount(amount.toString())
  let response = await window.contract.donate({
    args: {}, amount: amount
  })
  return response
}
'''
'''--- donation-as/frontend/index.html ---
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor" crossorigin="anonymous">
  <link rel="icon" href="./assets/img/favicon.ico" />
  <link rel="apple-touch-icon" href="./assets/img/favicon.ico" />
  <link rel="stylesheet" href="./assets/css/global.css">
  <title>Welcome to NEAR</title>
</head>

<body class="p-4 p-sm-5">

  <div class="row">
    <div class="col-sm-8 pe-2 pe-sm-5">
      <h4> Latest Donations </h4>

      <table class="table table-striped">
        <thead>
          <tr>
            <th scope="col">#</th>
            <th scope="col">User</th>
            <th scope="col">Donation Ⓝ</th>
          </tr>
        </thead>
        <tbody id="donations-table"> </tbody>
      </table>

    </div>

    <div class="col-sm-4">
      <div class="donation-box mt-md-4">

        <div class="donation-box-head">
          <i class="logo"></i>
          <h4> Donate to <label
            for="beneficiary"
            data-behavior="beneficiary"
            style="color: var(--secondary); border-bottom: 2px solid var(--secondary);"
          >
          </label> </h4>
        </div>

        <main class="donation-body signed-out-flow" style="display: none">
          <p>
            Please sign in with your NEAR wallet to make a donation.
          </p>
          <p style="text-align: center; margin-top: 2.5em">
            <button id="sign-in-button" class="btn btn-primary">Sign in</button>
          </p>
        </main>
      
        <main class="signed-in-flow" class="donation-body" style="display: none">
          <div class="row">
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="set_donation(10)"> $ 10 </button></div>
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="set_donation(20)"> $ 20 </button></div>
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="set_donation(50)"> $ 50 </button></div>
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="set_donation(100)"> $ 100 </button></div>
          </div>
  
          <form>
            <fieldset id="fieldset">
              <label for="donation" class="form-label" >
                Donation amount (in Ⓝ)
              </label>
              <div class="input-group">
                <input id="donation" class="form-control" data-behavior="donation" />
                <span class="input-group-text">Ⓝ</span>
                <button class="btn btn-primary" >Donate</button>
              </div>
            </fieldset>
          </form>
        </main>
  
        <button class="link signed-in-flow" style="display: none; float: right" id="sign-out-button">
          Sign out
        </button>
      </div>

    </div>

  </div>

  <aside data-behavior="notification" style="display:none" class="bg-success p-2 text-white bg-opacity-75">
    Thank you! Your donation is the number 
    <label for="donation-number" data-behavior="donation-number" > </label>
    <footer>
      <div>✔ Succeeded</div>
    </footer>
  </aside>

  <script src="./assets/js/index.js"></script>
</body>
</html>
'''
'''--- donation-as/integration-tests/rs/Cargo.toml ---
[package]
name = "workspace-tests"
version = "1.0.0"
publish = false
edition = "2018"

[dev-dependencies]
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.2.1"
pkg-config = "0.3.1"

[[example]]
name = "integration-tests"
path = "src/tests.rs"

'''
'''--- donation-as/integration-tests/rs/src/tests.rs ---
use serde_json::json;
use near_units::parse_near;
use workspaces::prelude::*; 
use workspaces::{network::Sandbox, Account, Contract, Worker};

const WASM_FILEPATH: &str = "../../out/main.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let wasm = std::fs::read(WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    // create accounts
    let owner = worker.root_account();

    let alice = owner
    .create_subaccount(&worker, "alice")
    .initial_balance(parse_near!("30 N"))
    .transact()
    .await?
    .into_result()?;

    let bob = owner
    .create_subaccount(&worker, "bob")
    .initial_balance(parse_near!("30 N"))
    .transact()
    .await?
    .into_result()?;

    let beneficiary = owner
    .create_subaccount(&worker, "beneficiary")
    .initial_balance(parse_near!("30 N"))
    .transact()
    .await?
    .into_result()?;

    // Initialize contract
    contract.call(&worker, "init")
            .args_json(json!({"beneficiary": beneficiary.id()}))?
            .transact()
            .await?;

    // begin tests  
    test_donation(&alice, &bob, &beneficiary, &contract, &worker).await?;
    test_records(&alice, &contract, &worker).await?;
    Ok(())
}   

async fn test_donation(
    alice: &Account,
    bob: &Account,
    beneficiary: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let balance = beneficiary
        .view_account(&worker)
        .await?
        .balance;

    alice.call(&worker, contract.id(), "donate")
         .deposit(parse_near!("1 N"))
         .transact()
         .await?;

    bob.call(&worker, contract.id(), "donate")
       .deposit(parse_near!("2 N"))
       .transact()
       .await?;

    let new_balance = beneficiary.view_account(&worker)
    .await?
    .balance;

    const FEES: u128 = parse_near!("0.001 N");
    assert_eq!(new_balance, balance + parse_near!("3 N") - 2*FEES );

    println!("      Passed ✅ sends donation");
    Ok(())
}

async fn test_records(
    alice: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let donation_idx: i32 = alice.call(&worker, contract.id(), "donate")
       .deposit(parse_near!("3 N"))
       .transact()
       .await?
       .json()?;

    assert_eq!(donation_idx, 3);

    let donation: serde_json::Value = alice.call(&worker, contract.id(), "get_donation_by_number")
       .args_json(json!({"donation_number": donation_idx}))?
       .transact()
       .await?
       .json()?;

    let expected = json!(
        {
            "amount": parse_near!("3N").to_string(),
            "donor": alice.id()
        }
    );    

    assert_eq!(donation, expected);

    println!("      Passed ✅ retrieves donation");
    Ok(())
}
'''
'''--- donation-as/integration-tests/ts/main.ava.ts ---
import { Worker, NEAR, NearAccount } from "near-workspaces";
import anyTest, { TestFn } from "ava";

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async (t) => {
  // Init the worker and start a Sandbox server
  const worker = await Worker.init();

  // deploy contract
  const root = worker.rootAccount;
  const contract = await root.createAndDeploy(
    root.getSubAccount("donation").accountId,
    "./out/main.wasm",
    { initialBalance: NEAR.parse("30 N").toJSON() }
  );

  const beneficiary = await root.createSubAccount("beneficiary", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });

  const alice = await root.createSubAccount("alice", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });

  const bob = await root.createSubAccount("bob", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });

  // Initialize contract
  await contract.call(contract, "init", { beneficiary: beneficiary.accountId });

  // Save state for test runs, it is unique for each test
  t.context.worker = worker;
  t.context.accounts = { root, contract, beneficiary, alice, bob };
});

test.afterEach(async (t) => {
  // Stop Sandbox server
  await t.context.worker.tearDown().catch((error) => {
    console.log("Failed to stop the Sandbox:", error);
  });
});

test("cannot be initialized twice", async (t) => {
  const { contract, alice, beneficiary } = t.context.accounts;
  await t.throwsAsync(alice.call(contract, "init", { beneficiary: beneficiary.accountId }));
});

test("sends donations to the beneficiary", async (t) => {
  const { contract, alice, bob, beneficiary } = t.context.accounts;

  const balance = await beneficiary.balance()
  const available = parseFloat(balance.available.toHuman())

  await alice.call(contract, "donate", {}, {attachedDeposit: NEAR.parse("1 N").toString()});
  await bob.call(contract, "donate", {}, {attachedDeposit: NEAR.parse("2 N").toString()});

  const new_balance = await beneficiary.balance()
  const new_available = parseFloat(new_balance.available.toHuman())

  const FEES: number = 0.001
  t.is(new_available, available + 3 - 2*FEES)
});

test("records the donation", async (t) => {
  const { contract, alice, bob } = t.context.accounts;

  await alice.call(contract, "donate", {}, {attachedDeposit: NEAR.parse("1 N").toString()});
  await bob.call(contract, "donate", {}, {attachedDeposit: NEAR.parse("2 N").toString()});
  const donation_idx = await alice.call(contract, "donate", {}, {attachedDeposit: NEAR.parse("3 N").toString()});

  t.is(donation_idx, 3)

  const donation: Donation = await contract.view("get_donation_by_number", {donation_number: donation_idx})
  
  t.is(donation.donor, alice.accountId)
  t.is(donation.amount, NEAR.parse("3 N").toString())
});

class Donation{
  donor: string = "";
  amount: string = "";
}
'''
'''--- donation-as/neardev/shared-test/test.near.json ---
{"account_id":"test.near","private_key":"ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw"}

'''
'''--- donation-as/package.json ---
{
  "name": "donation",
  "version": "1.0.0",
  "license": "UNLICENSED",
  "scripts": {
    "build": "cd contract && npm run build && mkdir -p ../out && rm -f ./out/donation_contract.wasm && cp ./build/release/donation_contract.wasm ../out/main.wasm",
    "deploy": "npm run build && near dev-deploy",
    "start": "npm run deploy && echo The app is starting! && env-cmd -f ./neardev/dev-account.env parcel frontend/index.html --open",
    "dev": "nodemon --watch contract -e ts --exec \"npm run start\"",
    "test": "npm run test:unit && npm run test:integration",
    "test:unit": "npm run build && cd contract && npm i && npm run test",
    "test:integration": "npm run test:integration:ts && npm run test:integration:rs",
    "test:integration:ts": "ava --verbose",
    "test:integration:rs": "cd integration-tests/rs && cargo run --example integration-tests"
  },
  "devDependencies": {
    "near-sdk-as": "3.2.3",
    "env-cmd": "^10.1.0",
    "near-cli": "^3.2.0",
    "nodemon": "~2.0.15",
    "parcel-bundler": "~1.12.5",
    "ava": "^4.2.0",
    "near-workspaces": "^2.0.0",
    "typescript": "^4.6.4",
    "ts-node": "^10.7.0"
  },
  "dependencies": {
    "near-api-js": "~0.43.1",
    "near-sdk-as": "^3.2.3",
    "regenerator-runtime": "~0.13.5"
  }
}
'''
'''--- donation-rs/README.md ---
# Donation in RUST

An example contract writen in RUST

'''
'''--- donation-rs/contract/Cargo.toml ---
[package]
name = "donation_contract"
version = "1.0.0"
authors = ["Guillermo Gallardo <guillermo@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
uint = { version = "0.8.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- donation-rs/contract/README.md ---
Donation Smart Contract
=======================

A [smart contract] written in [RUST] 

Exploring The Code
==================

1. The main smart contract code lives in `src/lib.rs`. You can compile
   by running `cargo build`.
2. Tests: You can run smart contract tests by doing `cargo test`.

  [smart contract]: https://docs.near.org/
  [RUST]: https://doc.rust-lang.org/book/title-page.html
'''
'''--- donation-rs/contract/src/lib.rs ---
use near_sdk::json_types::U128;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, log, near_bindgen, AccountId, Promise, Balance};
use near_sdk::collections::{UnorderedMap};

pub const STORAGE_COST: u128 = 1_000_000_000_000_000_000_000;

mod views;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
  pub beneficiary: AccountId,
  pub donations: UnorderedMap<AccountId, u128>,
}

impl Default for Contract {
  fn default() -> Self {
    Self{
      beneficiary: "v1.faucet.nonofficial.testnet".parse().unwrap(),
      donations: UnorderedMap::new(b"d"),
    }
  }
}

#[near_bindgen]
impl Contract {
  #[init]
  #[private] // Public - but only callable by env::current_account_id()
  pub fn new(beneficiary: AccountId) -> Self {
    assert!(!env::state_exists(), "Already initialized");
    Self {
      beneficiary,
      donations: UnorderedMap::new(b"d"),
    }
  }

  #[payable] // Public - People can attach money
  pub fn donate(&mut self) -> U128 {
    // Get who is calling the method and how much $NEAR they attached
    let donor: AccountId = env::predecessor_account_id();
    let donation_amount: Balance = env::attached_deposit();

    let mut donated_so_far = self.donations.get(&donor).unwrap_or(0);

    let to_transfer: Balance = if donated_so_far == 0 {
      // This is the user's first donation, lets register it, which increases storage
      assert!(donation_amount > STORAGE_COST, "Attach at least {} yoctoNEAR", STORAGE_COST);

      // Subtract the storage cost to the amount to transfer
      donation_amount - STORAGE_COST
    }else{
      donation_amount
    };

    // Persist in storage the amount donated so far
    donated_so_far += donation_amount;
    self.donations.insert(&donor, &donated_so_far);
    
    log!("Thank you {} for donating {}! You donated a total of {}", donor.clone(), donation_amount, donated_so_far);
    
    // Send the money to the beneficiary
    Promise::new(self.beneficiary.clone()).transfer(to_transfer);

    // Return the total amount donated so far
    U128(donated_so_far)
  }

  // Public - but only callable by env::current_account_id(). Sets the beneficiary
  #[private]
  pub fn change_beneficiary(&mut self, beneficiary: AccountId) {
    self.beneficiary = beneficiary;
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use near_sdk::testing_env;
  use near_sdk::test_utils::VMContextBuilder;

  const BENEFICIARY: &str = "beneficiary";
  const NEAR: u128 = 1000000000000000000000000;

  #[test]
  fn initializes() {
      let contract = Contract::new(BENEFICIARY.parse().unwrap());
      assert_eq!(contract.beneficiary, BENEFICIARY.parse().unwrap())
  }

  #[test]
  fn donate() {
      let mut contract = Contract::new(BENEFICIARY.parse().unwrap());

      // Make a donation
      set_context("donor_a", 1*NEAR);
      contract.donate();
      let first_donation = contract.get_donation_for_account("donor_a".parse().unwrap());

      // Check the donation was recorded correctly
      assert_eq!(first_donation.total_amount.0, 1*NEAR);

      // Make another donation
      set_context("donor_b", 2*NEAR);
      contract.donate();
      let second_donation = contract.get_donation_for_account("donor_b".parse().unwrap());

      // Check the donation was recorded correctly
      assert_eq!(second_donation.total_amount.0, 2*NEAR);

      // User A makes another donation on top of their original
      set_context("donor_a", 1*NEAR);
      contract.donate();
      let first_donation = contract.get_donation_for_account("donor_a".parse().unwrap());

      // Check the donation was recorded correctly
      assert_eq!(first_donation.total_amount.0, 1*NEAR * 2);

      assert_eq!(contract.total_donations(), 2);
  }

  // Auxiliar fn: create a mock context
  fn set_context(predecessor: &str, amount: Balance) {
    let mut builder = VMContextBuilder::new();
    builder.predecessor_account_id(predecessor.parse().unwrap());
    builder.attached_deposit(amount);

    testing_env!(builder.build());
  }
}
'''
'''--- donation-rs/contract/src/views.rs ---
use near_sdk::serde::Serialize;

use crate::*; 

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Donation {
  pub account_id: AccountId, 
  pub total_amount: U128,
}

#[near_bindgen]
impl Contract {
  // Public - get donation by account ID
  pub fn get_donation_for_account(&self, account_id: AccountId) -> Donation {
    Donation {
      account_id: account_id.clone(),
      total_amount: U128(self.donations.get(&account_id).unwrap_or(0))
    }
  }

    // Public - get total number of donations
    pub fn total_donations(&self) -> u64 {
        self.donations.len()
    }

    // Public - paginate through all donations on the contract
    pub fn get_donations(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<Donation> {
        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through donation
        self.donations.keys()
          //skip to the index we specified in the start variable
          .skip(start as usize) 
          //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
          .take(limit.unwrap_or(50) as usize) 
          .map(|account| self.get_donation_for_account(account))
          //since we turned map into an iterator, we need to turn it back into a vector to return
          .collect()
    }

    // Public - beneficiary getter
    pub fn beneficiary(&self) -> AccountId {
        self.beneficiary.clone()
    }
}
'''
'''--- donation-rs/frontend/assets/css/global.css ---
* {
  box-sizing: border-box;
}

html {
  --bg: #e7f3ff;
  --fg: #1e1e1e;
  --gray: #555;
  --light-gray: #ccc;
  --shadow: #e6e6e6;
  --success: rgb(90, 206, 132);
  --primary: #FF585D;
  --secondary: #0072CE;

  color: var(--fg);
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  line-height: 1.3;
}

body {
  margin: 0;
  background-color: var(--bg);
}

.donation-box {
  max-width: 24em;
  box-shadow: #bac4cd 0px 0px 18px;
  border-radius: 8px;
}

.column{
  width: 50%;
  float:left;
}

main {
  padding: 2em;
  text-align: justify;
  background-color: #f2f2f2;
  z-index: 1;
  border-radius: 8px;
}

.donation-box-head {
  text-align: center;
  background-color: #fff;
  margin: 0;
  border-radius: 8px 8px 0 0;
  padding: 1em 0em 2em 0em;
}

.logo {
  background-image: url(../img/logo-black.svg);
  background-position: center 0em;
  background-repeat: no-repeat;
  position: relative;
  top: -2em;
  transform: translateX(-50%);
  background-color: #fff;
  padding: 15px 25px;
  height: 40px;
  border-radius: 50px;
  width: 50px;
  box-shadow: #bbb 0px 2px 5px;
}

a,
.link {
  color: var(--primary);
  text-decoration: none;
}
a:hover,
a:focus,
.link:hover,
.link:focus {
  text-decoration: underline;
}
a:active,
.link:active {
  color: var(--secondary);
}

.btn-outline-primary{
  width: 100%;
}

button, input {
  font: inherit;
  outline: none;
}

button.link {
  background: none;
  border: none;
  box-shadow: none;
  display: inline;
}

fieldset {
  border: none;
  padding: 2em 0;
}

form {
  margin: 0.2em -0.5em -1em -0.5em;
}

aside {
  animation: notify ease-in-out 10s;
  background-color: var(--shadow);
  border-radius: 5px;
  bottom: 0;
  font-size: 0.8em;
  margin: 1em;
  padding: 1em;
  position: fixed;
  transform: translateY(10em);
  right: 0;
}
aside footer {
  display: flex;
  font-size: 0.9em;
  justify-content: space-between;
  margin-top: 0.5em;
}
aside footer *:first-child {
  color: var(--success);
}
aside footer *:last-child {
  color: var(--gray);
}
@keyframes notify {
  0% { transform: translateY(10em) }
  5% { transform: translateY(0) }
  95% { transform: translateY(0) }
  100% { transform: translateY(10em) }
}

'''
'''--- donation-rs/frontend/assets/img/logo-black.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#24272a"/><stop offset=".42" stop-color="#24272a" stop-opacity="0"/><stop offset=".59" stop-color="#24272a" stop-opacity="0"/><stop offset=".81" stop-color="#24272a"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#24272a"/></svg>
'''
'''--- donation-rs/frontend/assets/img/logo-white.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#fff"/><stop offset=".42" stop-color="#fff" stop-opacity="0"/><stop offset=".59" stop-color="#fff" stop-opacity="0"/><stop offset=".81" stop-color="#fff"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#fff"/></svg>
'''
'''--- donation-rs/frontend/assets/js/index.js ---
import { formatNearAmount } from 'near-api-js/lib/utils/format'
import 'regenerator-runtime/runtime'
import { initContract, login, logout, donate,
         getBeneficiary, latestDonations, getTransactionResult } from './near/utils'

// On submit, get the greeting and send it to the contract
document.querySelector('form').onsubmit = async (event) => {
  event.preventDefault()

  // get elements from the form using their id attribute
  const { fieldset, donation } = event.target.elements

  // disable the form while the value gets updated on-chain
  fieldset.disabled = true

  try {
    await donate(donation.value)
  } catch (e) {
    alert(
      'Something went wrong! ' +
      'Maybe you need to sign out and back in? ' +
      'Check your browser console for more info.'
    )
    throw e
  }

  // re-enable the form, whether the call succeeded or failed
  fieldset.disabled = false
}

document.querySelector('#sign-in-button').onclick = login
document.querySelector('#sign-out-button').onclick = logout

async function fetchBeneficiary() {
  // Get greeting from the contract
  const currentGreeting = await getBeneficiary()

  // Set all elements marked as greeting with the current greeting
  document.querySelectorAll('[data-behavior=beneficiary]').forEach(el => {
    el.innerText = currentGreeting
    el.value = currentGreeting
  })
}

// `nearInitPromise` gets called on page load
window.nearInitPromise = initContract()
                        .then(flow)
                        .catch(console.error)

function flow(){
  if (window.walletConnection.isSignedIn()){
    signedInFlow()
  }else{
    signedOutFlow()
  }
  fetchBeneficiary()
  getAndShowDonations()
}

// Display the signed-out-flow container
function signedOutFlow() {
  document.querySelector('.signed-out-flow').style.display = 'block'
}

async function signedInFlow() {
  // Displaying the signed in flow container
  document.querySelectorAll('.signed-in-flow').forEach(elem => elem.style.display = 'block')

  // Check if there is a transaction hash in the URL
  const urlParams = new URLSearchParams(window.location.search);
  const txhash = urlParams.get("transactionHashes")

  if(txhash !== null){
    // Get result from the transaction
    let result = await getTransactionResult(txhash)
    document.querySelector('[data-behavior=donation-so-far]').innerText = result

    // show notification
    document.querySelector('[data-behavior=notification]').style.display = 'block'

    // remove notification again after css animation completes
    setTimeout(() => {
      document.querySelector('[data-behavior=notification]').style.display = 'none'
    }, 11000)
  }

}

async function getAndShowDonations(){
  document.getElementById('donations-table').innerHTML = 'Loading ...'

  // Load last 10 donations
  let donations = await latestDonations()

  document.getElementById('donations-table').innerHTML = ''

  donations.forEach(elem => {
    let tr = document.createElement('tr')
    tr.innerHTML = `
      <tr>
        <th scope="row">${elem.account_id}</th>
        <td>${formatNearAmount(elem.total_amount)}</td>
      </tr>
    `
    document.getElementById('donations-table').appendChild(tr)
  })
}

window.set_donation = async function(amount){
  let data = await fetch("https://api.coingecko.com/api/v3/simple/price?ids=near&vs_currencies=usd").then(response => response.json())
  const near2usd = data['near']['usd']
  const amount_in_near = amount / near2usd
  const rounded_two_decimals = Math.round(amount_in_near * 100) / 100
  document.querySelector('#donation').value = rounded_two_decimals
}
'''
'''--- donation-rs/frontend/assets/js/near/config.js ---
import { keyStores } from 'near-api-js'

const CONTRACT_NAME = process.env.CONTRACT_NAME ||'new-awesome-project'

function getConfig(env) {
  switch (env) {

  case 'production':
  case 'mainnet':
    return {
      networkId: 'mainnet',
      nodeUrl: 'https://rpc.mainnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.near.org',
      helperUrl: 'https://helper.mainnet.near.org',
      explorerUrl: 'https://explorer.mainnet.near.org',
      deps: { keyStore: new keyStores.BrowserLocalStorageKeyStore() }
    }
  case 'development':
  case 'testnet':
    return {
      networkId: 'testnet',
      nodeUrl: 'https://rpc.testnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.testnet.near.org',
      helperUrl: 'https://helper.testnet.near.org',
      explorerUrl: 'https://explorer.testnet.near.org',
      deps: { keyStore: new keyStores.BrowserLocalStorageKeyStore() }
    }
  default:
    throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
  }
}

module.exports = getConfig

'''
'''--- donation-rs/frontend/assets/js/near/utils.js ---
import { connect, Contract, WalletConnection, utils, providers } from 'near-api-js'
import getConfig from './config'

const nearConfig = getConfig(process.env.NODE_ENV || 'development')

// Initialize contract & set global variables
export async function initContract() {
  // Set a connection to the NEAR network
  window.near = await connect(nearConfig)

  // Initialize a Wallet Object
  window.walletConnection = new WalletConnection(window.near)

  // Initialize a Contract Object (to interact with the contract)
  window.contract = await new Contract(
    window.walletConnection.account(), // user's account
    nearConfig.contractName, // contract's account
    {
      viewMethods: ['beneficiary', 'get_donations', 'total_donations'],
      changeMethods: ['donate'],
    }
  )
}

export function logout() {
  window.walletConnection.signOut()
  // reload page
  window.location.replace(window.location.origin + window.location.pathname)
}

export function login() {
  // Allows to make calls to the contract on the user's behalf.
  // Works by creating a new access key for the user's account
  // and storing the private key in localStorage.
  window.walletConnection.requestSignIn(nearConfig.contractName)
}

export async function getTransactionResult(txhash) {
  const transaction = await window.near.connection.provider.txStatus(txhash, window.walletConnection.getAccountId())
  let donated_so_far = providers.getTransactionLastResult(transaction)
  return utils.format.formatNearAmount(donated_so_far);
}

export async function getBeneficiary() {
  return await window.contract.beneficiary()
}

export async function latestDonations() {
  const total_donations = await window.contract.total_donations()

  const min = total_donations > 10 ? total_donations - 9 : 0

  let donations = await window.contract.get_donations({ from_index: min.toString(), limit: total_donations })
  
  return donations
}

export async function donate(amount) {
  amount = utils.format.parseNearAmount(amount.toString())
  let response = await window.contract.donate({
    args: {}, amount: amount
  })
  return response
}
'''
'''--- donation-rs/frontend/index.html ---
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor" crossorigin="anonymous">
  <link rel="icon" href="./assets/img/favicon.ico" />
  <link rel="apple-touch-icon" href="./assets/img/favicon.ico" />
  <link rel="stylesheet" href="./assets/css/global.css">
  <title>Welcome to NEAR</title>
</head>

<body class="p-4 p-sm-5">

  <div class="row">
    <div class="col-sm-8 pe-2 pe-sm-5">
      <h4> Latest Donations </h4>

      <table class="table table-striped">
        <thead>
          <tr>
            <th scope="col">User</th>
            <th scope="col">Total Donated Ⓝ</th>
          </tr>
        </thead>
        <tbody id="donations-table"> </tbody>
      </table>

    </div>

    <div class="col-sm-4">
      <div class="donation-box mt-md-4">

        <div class="donation-box-head">
          <i class="logo"></i>
          <h4> Donate to <label
            for="beneficiary"
            data-behavior="beneficiary"
            style="color: var(--secondary); border-bottom: 2px solid var(--secondary);"
          >
          </label> </h4>
        </div>

        <main class="donation-body signed-out-flow" style="display: none">
          <p>
            Please sign in with your NEAR wallet to make a donation.
          </p>
          <p style="text-align: center; margin-top: 2.5em">
            <button id="sign-in-button" class="btn btn-primary">Sign in</button>
          </p>
        </main>
      
        <main class="signed-in-flow" class="donation-body" style="display: none">
          <div class="row">
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="set_donation(10)"> $ 10 </button></div>
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="set_donation(20)"> $ 20 </button></div>
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="set_donation(50)"> $ 50 </button></div>
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="set_donation(100)"> $ 100 </button></div>
          </div>
  
          <form>
            <fieldset id="fieldset">
              <label for="donation" class="form-label" >
                Donation amount (in Ⓝ)
              </label>
              <div class="input-group">
                <input id="donation" class="form-control" data-behavior="donation" />
                <span class="input-group-text">Ⓝ</span>
                <button class="btn btn-primary" >Donate</button>
              </div>
            </fieldset>
          </form>
        </main>
  
        <button class="link signed-in-flow" style="display: none; float: right" id="sign-out-button">
          Sign out
        </button>
      </div>

    </div>

  </div>

  <aside data-behavior="notification" style="display:none" class="bg-success p-2 text-white bg-opacity-75">
    Thank you! You have donated so far:
    <label for="donation-number" data-behavior="donation-so-far" > </label>Ⓝ
    <footer>
      <div>✔ Succeeded</div>
    </footer>
  </aside>

  <script src="./assets/js/index.js"></script>
</body>
</html>
'''
'''--- donation-rs/integration-tests/rs/Cargo.toml ---
[package]
name = "workspace-tests"
version = "1.0.0"
publish = false
edition = "2018"

[dev-dependencies]
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.3.1"
pkg-config = "0.3.1"

[[example]]
name = "integration-tests"
path = "src/tests.rs"

'''
'''--- donation-rs/integration-tests/rs/src/tests.rs ---
use serde_json::json;
use near_units::parse_near;
use workspaces::prelude::*; 
use workspaces::{network::Sandbox, Account, Contract, Worker};

const WASM_FILEPATH: &str = "../../out/main.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let wasm = std::fs::read(WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    // create accounts
    let owner = worker.root_account();

    let alice = owner
        .create_subaccount(&worker, "alice")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    let bob = owner
        .create_subaccount(&worker, "bob")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    let beneficiary = owner
        .create_subaccount(&worker, "beneficiary")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    // Initialize contract
    contract.call(&worker, "new")
            .args_json(json!({"beneficiary": beneficiary.id()}))?
            .transact()
            .await?;

    // begin tests  
    test_donation(&alice, &beneficiary, &contract, &worker).await?;
    test_records(&bob, &contract, &worker).await?;
    Ok(())
}   

async fn test_donation(
    alice: &Account,
    beneficiary: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let balance = beneficiary
        .view_account(&worker)
        .await?
        .balance;

    alice.call(&worker, contract.id(), "donate")
         .deposit(parse_near!("1 N"))
         .transact()
         .await?;

    let new_balance = beneficiary.view_account(&worker)
    .await?
    .balance;

    const FEES: u128 = parse_near!("0.001 N");
    assert_eq!(new_balance, balance + parse_near!("1 N") - FEES );

    println!("      Passed ✅ sends donation");
    Ok(())
}

async fn test_records(
    bob: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    bob.call(&worker, contract.id(), "donate")
       .deposit(parse_near!("3 N"))
       .transact()
       .await?;

    let donation: serde_json::Value = bob.call(&worker, contract.id(), "get_donation_for_account")
       .args_json(json!({"account_id": bob.id()}))?
       .transact()
       .await?
       .json()?;

    let expected = json!(
        {
            "total_amount": parse_near!("3N").to_string(),
            "account_id": bob.id()
        }
    );    

    assert_eq!(donation, expected);

    println!("      Passed ✅ retrieves donation");
    Ok(())
}
'''
'''--- donation-rs/integration-tests/ts/main.ava.ts ---
import { Worker, NEAR, NearAccount } from "near-workspaces";
import anyTest, { TestFn } from "ava";
import { parseNearAmount } from "near-api-js/lib/utils/format";

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async (t) => {
  // Init the worker and start a Sandbox server
  const worker = await Worker.init();

  // deploy contract
  const root = worker.rootAccount;
  const contract = await root.createAndDeploy(
    root.getSubAccount("donation").accountId,
    "./out/main.wasm",
    { initialBalance: NEAR.parse("30 N").toJSON() }
  );

  const beneficiary = await root.createSubAccount("beneficiary", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });

  const alice = await root.createSubAccount("alice", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });

  const bob = await root.createSubAccount("bob", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });

  // Initialize contract
  await contract.call(contract, "new", { beneficiary: beneficiary.accountId });

  // Save state for test runs, it is unique for each test
  t.context.worker = worker;
  t.context.accounts = { root, contract, beneficiary, alice, bob };
});

test("cannot be initialized twice", async (t) => {
  const { contract, alice, beneficiary } = t.context.accounts;
  await t.throwsAsync(alice.call(contract, "init", { beneficiary: beneficiary.accountId }));
});

test("sends donations to the beneficiary", async (t) => {
  const { contract, alice, bob, beneficiary } = t.context.accounts;

  const balance = await beneficiary.balance()
  const available = parseFloat(balance.available.toHuman())

  await alice.call(contract, "donate", {}, {attachedDeposit: NEAR.parse("1 N").toString()});

  const new_balance = await beneficiary.balance()
  const new_available = parseFloat(new_balance.available.toHuman())

  const FEES: number = 0.001
  t.is(new_available, available + 1 - FEES)
});

test("records the donation", async (t) => {
  const { contract, bob } = t.context.accounts;

  await bob.call(contract, "donate", {}, {attachedDeposit: NEAR.parse("2 N").toString()});

  class Donation{ total_amount: string = ""; account_id: string = ""; }
  const donation: Donation = await contract.view("get_donation_for_account", {account_id: bob.accountId})
  
  t.is(donation.account_id, bob.accountId)
  t.is(donation.total_amount, parseNearAmount("3"))
});

test.afterEach(async (t) => {
  // Stop Sandbox server
  await t.context.worker.tearDown().catch((error) => {
    console.log("Failed to stop the Sandbox:", error);
  });
});
'''
'''--- donation-rs/neardev/shared-test/test.near.json ---
{"account_id":"test.near","private_key":"ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw"}

'''
'''--- donation-rs/package.json ---
{
  "name": "donation",
  "version": "1.0.0",
  "license": "UNLICENSED",
  "scripts": {
    "build:rustup": "cd contract && rustup target add wasm32-unknown-unknown && cargo build --all --target wasm32-unknown-unknown --release",
    "build:cpwasm": "mkdir -p out && rm -f ./out/main.wasm && cp ./contract/target/wasm32-unknown-unknown/release/donation_contract.wasm ./out/main.wasm",
    "build": "npm run build:rustup && npm run build:cpwasm",
    "deploy": "npm run build && near dev-deploy",
    "test:integration:ts": "echo workspaces-ts is not compatible with sdk4.0 && exit && ava --verbose",
    "test:integration:rs": "cd integration-tests/rs && cargo run --example integration-tests",
    "test:integration": "npm run build && npm run test:integration:ts && npm run test:integration:rs",
    "test:unit": "cd contract && cargo test",
    "test": "npm run test:unit && npm run test:integration",
    "start": "npm run build && npm run deploy && echo The app is starting! && env-cmd -f ./neardev/dev-account.env parcel frontend/index.html --open",
    "dev": "nodemon --watch contract -e ts --exec \"npm run start\""
  },
  "devDependencies": {
    "env-cmd": "^10.1.0",
    "near-cli": "^3.2.0",
    "nodemon": "~2.0.15",
    "parcel-bundler": "~1.12.5",
    "near-workspaces": "^2.0.0",
    "ava": "^4.2.0",
    "typescript": "^4.6.4",
    "ts-node": "^10.7.0"
  },
  "dependencies": {
    "near-api-js": "^0.44.2",
    "regenerator-runtime": "^0.13.9"
  }
}

'''
'''--- storage-as/README.md ---
# Storage Assemblyscript

An example on how to use storage in AS

'''
'''--- storage-as/contract/as-pect.config.js ---
module.exports = require('near-sdk-as/imports')
'''
'''--- storage-as/contract/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- storage-as/contract/assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- storage-as/contract/assembly/__tests__/map.spec.ts ---
import { map } from '../index'

describe("Map", () => {
  it("stores and retrieves data", () => {
    const key: string = "key"
    const value: i32 = 1

    map.set(key, value)
    assert(map.contains(key), "Error setting key-value")

    let read_value: i32 = map.getSome(key)
    assert(read_value == value, "Wrong value obtained")

    map.delete(key)
    assert(!map.contains(key), "Error deleting")
  })
})
'''
'''--- storage-as/contract/assembly/__tests__/set.spec.ts ---
import { set } from '../index'

describe("Set", () => {
  it("stores and retrieves data", () => {
    const value: i32 = 1

    set.add(value)
    assert(set.has(value), "Error adding value")

    set.delete(value)
    assert(!set.has(value), "Error removing value")
  })
})
'''
'''--- storage-as/contract/assembly/__tests__/storage.spec.ts ---
import { u128 } from 'near-sdk-as'
import { setter_demo_u128, setter_demo_str, getter_demo_u128, getter_demo_str, ONE_NEAR } from '../index'

describe("Storage", () => {
  it("stores and retrieves data", () => {
    assert(getter_demo_u128() == ONE_NEAR, "Error in getting const")

    const value: u128 = u128.Zero;
    setter_demo_u128(value);
    assert(getter_demo_u128() == value, "Error in getting u128")

    assert(getter_demo_str() == "default value", "Error in default value")

    const str_value: string = "another string"
    setter_demo_str(str_value)

    assert(getter_demo_str() == str_value, "Error in setting str")
  })
})
'''
'''--- storage-as/contract/assembly/__tests__/tree.spec.ts ---
import { tree } from '../index'

describe("Tree", () => {
  it("stores and retrieves data", () => {
    const key: string = "key"
    const value: i32 = 1

    tree.set(key, value)
    assert(tree.has(key), "Error setting key-value")

    let read_value: i32 = tree.getSome(key)
    assert(read_value == value, "Wrong value obtained")

    // tree.delete(key)
    // assert(!tree.has(key), "Error deleting")
  })
})
'''
'''--- storage-as/contract/assembly/__tests__/vector.spec.ts ---
import { vector } from '../index'

function test_vector(): void {
  const value: i32 = 1

  vector.push(value)
  vector.push(1)

  assert(vector.length == 2, "Incorrect length")
  assert(vector[0] == value, "Error saving value")

  let last_element: i32 = vector.pop()
  assert(vector.length == 1, "Error popping value")

  vector[0] = 3
  assert(vector[0] == 3, "Error updating value")

}
'''
'''--- storage-as/contract/assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- storage-as/contract/assembly/index.ts ---
import { storage, u128 } from "near-sdk-as";
import { PersistentMap, PersistentVector, PersistentSet, AVLTree } from "near-sdk-as";

// Collections
export let vector = new PersistentVector<i32>("unique-id-vector1");
export let map = new PersistentMap<string, i32>("unique-id-map1");
export let set = new PersistentSet<i32>("unique-id-set1");
export let tree = new AVLTree<string, i32>("unique-id-tree1");

// Constants
export const ONE_NEAR: u128 = u128.from("1000000000000000000000000")

// Storage setters & getters ("Attributes")
export function setter_demo_str(value: string): void {
  storage.set<string>("var-string", value)
}

export function setter_demo_u128(value: u128): void {
  storage.set<u128>("var-u128", value)
}

export function getter_demo_str(): string {
  return storage.getPrimitive<string>("var-string", "default value")
}

export function getter_demo_u128(): u128 {
  if (!storage.contains('var-u128')) { return ONE_NEAR }
  return storage.getSome<u128>("var-u128")
}
'''
'''--- storage-as/contract/assembly/tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}
'''
'''--- storage-as/contract/package.json ---
{
  "name": "storage_contract",
  "version": "1.0.0",
  "license": "MIT",
  "private": true,
  "scripts": {
    "test": "asp --nologo"
  },
  "dependencies": {
    "near-sdk-as": "^3.2.1"
  },
  "devDependencies": {
    "shelljs": "^0.8.4"
  }
}

'''
'''--- storage-as/package.json ---
{
  "name": "donation",
  "version": "1.0.0",
  "license": "UNLICENSED",
  "scripts": {
    "test": "cd contract && npm run test"
  },
  "devDependencies": {
    "asbuild": "^0.2.0"
  },
  "dependencies": {
    "near-sdk-as": "^3.2.3"
  },
  "jest": {
    "testEnvironment": "near-cli/test_environment",
    "testPathIgnorePatterns": [
      "<rootDir>/contract/",
      "<rootDir>/node_modules/"
    ]
  }
}

'''
'''--- storage-js/README.md ---
# Cross-Contract JavaScript

An example on how to write JS cross-contract code

'''
'''--- storage-js/babel.config.json ---
{
    "plugins": ["near-sdk-js/lib/build-tools/near-bindgen-exporter", ["@babel/plugin-proposal-decorators", { "version": "legacy" }]],
    "presets": ["@babel/preset-typescript"]
}

'''
'''--- storage-js/integration/test-storage.ava.js ---
import { Worker } from "near-workspaces";
import test from "ava";

test.beforeEach(async (t) => {
  // Init the worker and start a Sandbox server
  const worker = await Worker.init();

  // Prepare sandbox for tests, create accounts, deploy contracts, etx.
  const root = worker.rootAccount;
  const contract = await root.createSubAccount('storage')
  await contract.deploy("./build/storage.wasm");

  // Initialize storage
  await contract.call(contract, "init", { "demo_string": "hi" });

  // Save state for test runs, it is unique for each test
  t.context.worker = worker;
  t.context.accounts = { contract };
});

test.afterEach(async (t) => {
  await t.context.worker.tearDown().catch((error) => {
    console.log("Failed tear down the worker:", error);
  });
});

test("vector_ops works", async (t) => {
  const { contract } = t.context.accounts;
  await contract.call(contract, "vector_ops", {value:"1"}, { gas: 200000000000000 });
  t.pass()
});

test("map_ops works", async (t) => {
  const { contract } = t.context.accounts;
  await contract.call(contract, "map_ops", {key: "key", value:"1"}, { gas: 200000000000000 });
  t.pass()
});

test("set_ops works", async (t) => {
  const { contract } = t.context.accounts;
  await contract.call(contract, "set_ops", {value:"1"}, { gas: 200000000000000 });
  t.pass()
});
'''
'''--- storage-js/package.json ---
{
  "name": "standalone-examples",
  "version": "1.0.0",
  "description": "Cross-contract example with near-sdk-js",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "build": "near-sdk-js build src/index.ts build/storage.wasm",
    "rebuild": "rm -rf node_modules && rm -rf build && npm i && npm run build",
    "test": "ava --verbose --timeout=10m"
  },
  "author": "Near Inc <hello@nearprotocol.com>",
  "license": "MIT",
  "dependencies": {
    "lodash-es": "^4.17.21",
    "near-sdk-js": "^v0.4.0-5"
  },
  "devDependencies": {
    "typescript": "^4.7.4",
    "ava": "^4.3.1",
    "near-workspaces": "^3.1.0"
  }
}
'''
'''--- storage-js/src/index.ts ---
import { NearContract, NearBindgen, call, near, LookupSet, UnorderedMap, Vector } from "near-sdk-js";

// Constants
const ONE_NEAR = BigInt("1000000000000000000000000");

@NearBindgen
class CollectionsContract extends NearContract {
  vector: Vector;
  map: UnorderedMap;
  set: LookupSet;
  demo_string: String;

  constructor({demo_string}: {demo_string: string}) {
    super()
    this.vector = new Vector('unique-id-vector1');
    this.map = new UnorderedMap('unique-id-map1');
    this.set = new LookupSet('unique-id-set1');
    this.demo_string = demo_string.toString();
  }

  default(){ return new CollectionsContract({demo_string: "Hello!"})}

  @call
  vector_ops({value}) {
    this.vector.push(value);
    assert(this.vector.len() == 1, "Incorrect length")
    const _value = this.vector.pop()
    assert(_value == value, "Error popping value")
  }

  @call
  map_ops({key, value}) {
    this.map.set(key, value);
    assert(this.map.get(key) == value, "Error saving value")
  
    this.map.remove(key)
    assert(this.map.get(key) === null, "Error removing value")
  }

  @call
  set_ops({value}) {
    this.set.set(value);
    assert(this.set.contains(value), "Error saving value")
  
    this.set.remove(value)
    assert(!this.set.contains(value), "Error removing value")
  }
}

function assert(condition, message) { if(!condition) near.panic(message); }
'''
'''--- storage-rs/README.md ---
# Donation in RUST

An example contract writen in RUST

'''
'''--- storage-rs/contract/Cargo.toml ---
[package]
name = "donation_contract"
version = "1.0.0"
authors = ["Guillermo Gallardo <guillermo@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.7"
uint = { version = "0.8.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- storage-rs/contract/README.md ---
Storage Smart Contract
======================

A [smart contract] written in [RUST] 

Exploring The Code
==================

1. The main smart contract code lives in `src/lib.rs`. You can compile
   by running `cargo build`.
2. Tests: You can run smart contract tests by doing `cargo test`.

  [smart contract]: https://docs.near.org/
  [RUST]: https://doc.rust-lang.org/book/title-page.html
'''
'''--- storage-rs/contract/src/lib.rs ---
pub mod storage;
pub mod vector;
pub mod map;
pub mod set;
pub mod tree;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen, PanicOnDefault};
use near_sdk::collections::{LookupMap, Vector, UnorderedSet, TreeMap};

// Constants
const ONE_NEAR: u128 = 1_000_000_000_000_000_000_000_000;

// Contract Structure
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
  pub vector: Vector<i32>,
  pub map: LookupMap<String, i32>,
  pub set: UnorderedSet<i32>,
  pub tree: TreeMap<String, i32>,
  pub demo_u128: u128,
  pub demo_string: String,
}

#[near_bindgen]
impl Contract {
  #[init]
  #[private]
  pub fn new(demo_string: String) -> Self {
    assert!(!env::state_exists(), "Already initialized");
    Self {
      vector: Vector::new(b"vec-uid-1".to_vec()),
      map: LookupMap::new(b"map-uid-1".to_vec()),
      set: UnorderedSet::new(b"set-uid-1".to_vec()),
      tree: TreeMap::new(b"tree-uid-1".to_vec()),
      demo_u128: ONE_NEAR,
      demo_string: demo_string
    }
  }
}
'''
'''--- storage-rs/contract/src/map.rs ---
use crate::Contract;

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_map() {
    let mut contract = Contract::new("".to_string());
    let key: String = "key".to_string();
    let value: i32 = 1;

    contract.map.insert(&key, &value);
    assert!(contract.map.contains_key(&key), "Error saving value");

    let val = match contract.map.get(&key) {
      Some(x) => x,
      None => panic!("Error saving value"),
    };

    assert!(val == value, "Wrong value obtained");

    contract.map.remove(&key);
    assert!(!contract.map.contains_key(&key), "Error deleting")
  }
}

'''
'''--- storage-rs/contract/src/set.rs ---
use crate::Contract;

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_set() {
    let mut contract = Contract::new("".to_string());
    let value: i32 = 1;

    contract.set.insert(&value);
    assert!(contract.set.contains(&value), "Error adding value");

    contract.set.remove(&value);
    assert!(!contract.set.contains(&value), "Error removing value");
  }
}

'''
'''--- storage-rs/contract/src/storage.rs ---
use crate::{Contract, ONE_NEAR};

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_storage() {
    let mut contract = Contract::new("init value".to_string());

    assert!(contract.demo_u128 == ONE_NEAR, "Error in demo_u128");
    assert!(contract.demo_string == "init value".to_string(), "Error in demo_str");

    contract.demo_u128 = 0;
    assert!(contract.demo_u128 == 0, "Error in demo_u128");

    let another_string: String = "another string".to_string();
    contract.demo_string = another_string.clone();
    assert!(contract.demo_string == another_string, "Error in demo_str");
  }
}

'''
'''--- storage-rs/contract/src/tree.rs ---
use crate::Contract;

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_tree() {
    let mut contract = Contract::new("".to_string());
    let key: String = "key".to_string();
    let value: i32 = 1;

    contract.tree.insert(&key, &value);
    assert!(contract.tree.contains_key(&key), "Error saving value");

    let val = match contract.tree.get(&key) {
      Some(x) => x,
      None => panic!("Error saving value"),
    };

    assert!(val == value, "Wrong value obtained");

    contract.tree.remove(&key);
    assert!(!contract.tree.contains_key(&key), "Error deleting")
  }
}

'''
'''--- storage-rs/contract/src/vector.rs ---
use crate::Contract;

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_vector() {
    let mut contract = Contract::new("".to_string());
    let value: i32 = 1;

    contract.vector.push(&value);
    contract.vector.push(&1);

    assert!(contract.vector.len() == 2, "Incorrect length");

    let val = match contract.vector.get(0) {
      Some(x) => x,
      None => panic!("Error saving value"),
    };

    assert!(val == value, "Error saving value");

    contract.vector.replace(0, &3);
    let val2 = match contract.vector.get(0) {
      Some(x) => x,
      None => panic!("Error saving value"),
    };

    assert!(val2 == 3, "Error saving value")
  }
}

'''
'''--- storage-rs/package.json ---
{
  "name": "donation",
  "version": "1.0.0",
  "license": "UNLICENSED",
  "scripts": {
    "test": "cd contract && rustup override set nightly && cargo test"
  }
}

'''