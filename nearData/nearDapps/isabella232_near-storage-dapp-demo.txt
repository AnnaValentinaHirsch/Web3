*GitHub Repository "isabella232/near-storage-dapp-demo"*

'''--- .eslintrc.yml ---
env:
  es2021: true
  node: true
  jest: true
  dom: true
extends:
  - "eslint:recommended"
  - "plugin:@typescript-eslint/recommended"
  - "plugin:jest-dom/recommended"
parser: "@typescript-eslint/parser"
parserOptions:
  ecmaVersion: 12
  sourceType: module
plugins:
  - "@typescript-eslint"
  - "jest-dom"
rules: {}

'''
'''--- .github/workflows/deploy.yml ---
name: Build and Deploy
on:
  push:
    branches:
      - main
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout 🛎️
        uses: actions/checkout@v2.3.1
        with:
          persist-credentials: false

      - name: Cache 📦
        uses: actions/cache@v1
        with:
          path: ~/.npm # npm cache files are stored in `~/.npm` on Linux/macOS
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ env.cache-name }}-
            ${{ runner.os }}-build-
            ${{ runner.os }}-

      - name: Setup Node Environment ⬢
        uses: actions/setup-node@v1
        with:
          node-version: 12

      - name: Install and Build 🔧
        run: |
          npm install
          npm run build

      - name: Deploy 🚀
        uses: JamesIves/github-pages-deploy-action@3.7.1
        with:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH: gh-pages
          FOLDER: dist

'''
'''--- README.md ---
# NEAR dApp + Filecoin Storage Demo

This project is an example of how to integrate Textile's Filecoin Storage into any
NEAR dApp using the Filecoin Storage library for NEAR, `@textile/near-storage`. The library interacts with
the `near-api-js` code you've already written to provide an easy to use API for storing any
amount of data off of the NEAR blockchain, and in the Filecoin network.

This example allows users to authenticate with their NEAR account, create unique visualizations of
[cellular automata](https://mathworld.wolfram.com/ElementaryCellularAutomaton.html), store those
visualizations on the Filecoin network, and mint verifiable records of the stored visualizations
within a NEAR smart contract.

This app was built starting from one of the many [NEAR example apps](https://github.com/near-examples),
so be sure you're familiar with those examples and the [NEAR docs](https://docs.near.org/docs/concepts/new-to-near) 
so you know the basics of NEAR smart contracts and `near-api-js` usage.

# Table of Contents

- [Quick start](#quick-start)
- [How it Works](#how-it-works)
- [Learn More](#learn-more)
- [Exploring the Code](#exploring-the-code)
- [Deploy](#deploy)

# Quick Start

To run this project locally:

1. Prerequisites: Make sure you have Node.js ≥ 12 installed (https://nodejs.org).
2. Install dependencies: `npm install` (or just `npm i`)
3. Run the local development server: `npm run dev` (see `package.json` for a
   full list of `scripts` you can run with `npm`)

Now you'll have a local development environment backed by the NEAR TestNet and Filecoin Storage!
Running `npm run dev` will tell you the URL you can visit in your browser to see the app.

# How it Works

There are two main components in this example NEAR dApp using Filecoin Storage:

1. The example NEAR dApp and associated smart contract. This would be replaced by your own app and smart contract.
2. The `@textile/near-storage` library which abstracts use of the Filecoin Storage NEAR smart contract and Filecoin Storage Provider into an easy-to-use API.

## Example dApp and Smart Contract

We start with code you'll typically see in any NEAR dApp... In `src/index.tsx`, we read our configuration,
initialize the `Near` client, create a `WalletConnection`, get a reference to the current NEAR user, 
and create a reference to our example app's smart contract:

```
import getConfig from './config.js';
import { connect, keyStores, Contract, WalletConnection } from 'near-api-js';

// Read the configuration
const nearConfig = getConfig(ENV.NODE_ENV as any || 'testnet');

// Initializing connection to the NEAR TestNet
const near = await connect({
  deps: {
    keyStore: new keyStores.BrowserLocalStorageKeyStore()
  },
  ...nearConfig
});

// Needed to access wallet
const walletConnection = new WalletConnection(near, null);

// Load in account data
let currentUser;
if (walletConnection.getAccountId()) {
  currentUser = {
    accountId: walletConnection.getAccountId(),
    balance: (await walletConnection.account().state()).amount
  };
}

// Initializing our contract APIs by contract name and configuration
const contract = await new Contract(walletConnection.account(), nearConfig.contractName, {
  viewMethods: ['getStoredAssets'],
  changeMethods: ['storeNewAsset'],
  sender: walletConnection.getAccountId()
});
```

Our app's smart contract (the source is in the `assembly` directory) exposes two functions;
`storeNewAsset` which we'll use to store on chain records of the cellular automata visualizations
stored on Filecoin and `getStoredAssets` which will be used to retrieve the list of all records
previously stored using `storeNewAsset`.

## Using Filecoin Storage

### Initializing the API

After creating a NEAR `WalletConnection` in the `src/index.tsx` code above, we pass that object into the
`init` function provided by `@textile/near-storage`. This provides the API we'll use from then on to
interact with Filecoin Storage.

```
import { init } from "@textile/near-storage"

const storage = await init(walletConnection)
```

We bind our newly created NEAR and Filecoin Storage objects to the `App` React component, and the web
app is then rendered in `App.tsx`.

### User Sign In

Before using Filecoin Storage to store data, the web app user must be signed in to their NEAR account.
If they aren't already signed in, Filecoin Storage provides a helper method to initiate the sign in.
Here, we use it inside a function that is bound to a clickable UI element:

```
const signIn = () => {
  storage.requestSignIn('RULE TOKENS')
};
```

### Adding a Deposit

Before a user can store data using Filecoin Storage, a deposit of 1 NEAR must be made, either by the user or by
you (the dApp developer) on the user's behalf, into the Filecoin Storage NEAR smart contract. The deposited
funds help provide the Filecoin Storage Provider some amount of Sybil attack resistance. After depositing
funds, the user has an active storage session. The session will expire after an hour, and the deposited
funds will be returned to the sender.

```
const addDeposit = async () => {
  await storage.addDeposit()
}
```

### Storing Data

Once a deposit is made and the user has an active storage session, we can now store data.
It's as simple as passing a `File` object into the Filecoin Storage `store` function. Our
`mint` funtion in `App.tsx` builds a `File` from a blob of data, our cellular automaton visualization,
stores the file using the `store` function, and then saves the resulting information about
the stored data in our dApp's smart contract using its `storeNewAsset` function:

```
const mint = async () => {
  if (artwork == undefined) {
    alert("error: no token selected");
    return;
  }

  const data = await fetch(artwork)
  const blob = await data.blob()

  const file = new File([blob], "rule.png", {
    type: "image/png",
    lastModified: new Date().getTime(),
  });
  const stored = await storage.store(file)
  const rule = "" + parseInt([...positionals].reverse().join(""), 2)
  contract.storeNewAsset(
    { id: stored.id, cid: stored.cid["/"], rule },
    BOATLOAD_OF_GAS,
    Big('0').toFixed()
  ).then(() => {
    contract.getStoredAssets().then((tokens: any) => {
      setTokens(tokens);
    });
  });
  return
}
```

We've now stored data using Filecoin Storage and kept a record of that data storage on
the NEAR blockchain.

### Checking Filecoin Storage Status

You stored data is available on the IPFS network (note that during the Testnet release,
data will pinned for a limited time only), but stored data takes time to make it
through the Filecoin Storage Provider, become sealed with a Filecoin miner, and
verified on the Filecoin blockchain. You can check the data's status at any time
by calling the Filecoin Storage `status` method. In `App.tsx` we do that when the page
loads by getting a list of stored data IDs from our dApp's smart contract and passing
those IDs to the `status` method. It's a bit of Javascript async `Promise` wrangling,
but all comes down to calling:

```
useEffect(() => {
  ...
  return await storage.status(asset.id)
  ...
}, []);
```

# Learn More
Our example dApp provides a thorough example of integrating Filecoin Storage into a
NEAR dApp. We've covered all the highlights of the integration in this README, but 
be sure to check out the [full Filecoin Storage documentation](https://near.storage/docs/)
for more.

# Exploring the Code

1. The backend code lives in the `/assembly` folder. This code gets deployed to
   the NEAR blockchain when you run `npm run deploy:contract`. This sort of
   code-that-runs-on-a-blockchain is called a "smart contract" – [learn more
   about NEAR smart contracts][smart contract docs].
2. The frontend code lives in the `/src` folder.
   [/src/index.html](/src/index.html) is a great place to start exploring. Note
   that it loads in `/src/index.js`, where you can learn how the frontend
   connects to the NEAR blockchain.
3. Tests: there are different kinds of tests for the frontend and backend. The
   backend code gets tested with the [asp] command for running the backend
   AssemblyScript tests, and [jest] for running frontend tests. You can run
   both of these at once with `npm test`.

Both contract and client-side code will auto-reload as you change source files.

# Deploy

Every smart contract in NEAR has its [own associated account][near accounts]. Ours is deployed to `{TODO}.testnet`.

One command:

    npm run deploy

As you can see in `package.json`, this does two things:

1. builds & deploys smart contracts to NEAR TestNet
2. builds & deploys frontend code to GitHub using [gh-pages].

For now, you can view the "app" at: https://textileio.github.io/near-storage-dapp-demo/

[near]: https://nearprotocol.com/
[assemblyscript]: https://docs.assemblyscript.org/
[react]: https://reactjs.org
[smart contract docs]: https://docs.nearprotocol.com/docs/roles/developer/contracts/assemblyscript
[asp]: https://www.npmjs.com/package/@as-pect/cli
[jest]: https://jestjs.io/
[near accounts]: https://docs.nearprotocol.com/docs/concepts/account
[near wallet]: https://wallet.nearprotocol.com
[near-cli]: https://github.com/nearprotocol/near-cli
[cli]: https://www.w3schools.com/whatis/whatis_cli.asp
[create-near-app]: https://github.com/nearprotocol/create-near-app
[gh-pages]: https://github.com/tschaub/gh-pages

'''
'''--- as-pect.config.js ---
module.exports = require('near-sdk-as/imports')

'''
'''--- asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json",
  "entry": "assembly/main.ts",
  "options": {
    "binaryFile": "out/main.wasm"
  }
} 

'''
'''--- assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />

'''
'''--- assembly/__tests__/tokenAssets.spec.ts ---
import { storeNewAsset, getStoredAssets } from '../main';
import { TokenAsset, assets } from '../model';
import { VMContext, Context, u128 } from 'near-sdk-as';

function createTokenAsset(cid: string, rule: string): TokenAsset {
  return new TokenAsset(cid, rule);
}

const asset = createTokenAsset('bafybeifcxjvbad4lgpnbwff2dafufmnlylylmku4qoqtlkwgidupwi6f3a', '0');

describe('message tests', () => {
  afterEach(() => {
    while(assets.length > 0) {
      assets.pop();
    }
  });

  it('adds an asset', () => {
    storeNewAsset('bafybeifcxjvbad4lgpnbwff2dafufmnlylylmku4qoqtlkwgidupwi6f3a', '0');
    expect(assets.length).toBe(
      1,
      'should only contain one asset'
    );
    expect(assets[0].cid).toStrictEqual(
      asset.cid,
      'message should be "hello world"'
    );
  });

  it('retrieves messages', () => {
    storeNewAsset('bafybeifcxjvbad4lgpnbwff2dafufmnlylylmku4qoqtlkwgidupwi6f3a', '0');
    const assetsArr = getStoredAssets();
    expect(assetsArr.length).toBe(
      1,
      'should be one asset'
    );
    expect(assetsArr).toIncludeEqual(
      asset,
      'assets should include:\n' + asset.toJSON()
    );
  });

  it('only show the last 10 messages', () => {
    storeNewAsset('bafybeifcxjvbad4lgpnbwff2dafufmnlylylmku4qoqtlkwgidupwi6f3a', '0');
    const newAssets: TokenAsset[] = [];
    for(let i: i32 = 0; i < 10; i++) {
      const cid = 'bafy' + i.toString();
      const rule = ''+i
      newAssets.push(createTokenAsset(cid, rule));
      storeNewAsset(cid, rule);
    }
    const assets = getStoredAssets();
    log(assets.slice(7, 10));
    expect(assets).toStrictEqual(
      newAssets,
      'should be the last ten assets'
    );
    expect(assets).not.toIncludeEqual(
      asset,
      'shouldn\'t contain the first element'
    );
  });
});

'''
'''--- assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />

'''
'''--- assembly/main.ts ---
import { context } from "near-sdk-as";
import { TokenAsset, assets } from './model';

// --- contract code goes below

// The maximum number of latest messages the contract returns.
const ASSET_LIMIT = 10;

/**
 * Adds a new message under the name of the sender's account id.\
 * NOTE: This is a change method. Which means it will modify the state.\
 * But right now we don't distinguish them with annotations yet.
 */
export function storeNewAsset(id: string, cid: string, rule: string): void {
  // Creating a new message and populating fields with our data
  const message = new TokenAsset(id, cid, rule);
  // Adding the message to end of the the persistent collection
  assets.push(message);
}

/**
 * Returns an array of last N messages.\
 * NOTE: This is a view method. Which means it should NOT modify the state.
 */
export function getStoredAssets(): TokenAsset[] {
  const numMessages = min(ASSET_LIMIT, assets.length);
  const startIndex = assets.length - numMessages;
  const result = new Array<TokenAsset>(numMessages);
  for(let i = 0; i < numMessages; i++) {
    result[i] = assets[i + startIndex];
  }
  return result;
}

export function resetState(): i32 {
  if (context.sender != context.contractName) {
    throw new Error("invalid sender account id")
  }
  let empty = assets.isEmpty
  let numDeleted = 0
  while (!empty) {
    assets.pop()
    numDeleted++
    empty = assets.isEmpty
  }
  return numDeleted
}

'''
'''--- assembly/model.ts ---
import { context, u128, PersistentVector } from "near-sdk-as";

/** 
 * Exporting a new class TokenAsset so it can be used outside of this file.
 */
@nearBindgen
export class TokenAsset {
  sender: string;
  constructor(public id: string, public cid: string, public rule: string) {
    this.sender = context.sender;
  }
}
/**
 * collections.vector is a persistent collection. Any changes to it will
 * be automatically saved in the storage.
 * The parameter to the constructor needs to be unique across a single contract.
 * It will be used as a prefix to all keys required to store data in the storage.
 */
export const assets = new PersistentVector<TokenAsset>("b");

'''
'''--- assembly/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- babel.config.js ---
module.exports = {
  presets: ['@babel/preset-env', '@babel/preset-react']
}

'''
'''--- neardev/shared-test-staging/test.near.json ---
{"account_id":"test.near","private_key":"ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw"}

'''
'''--- neardev/shared-test/test.near.json ---
{"account_id":"test.near","private_key":"ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw"}

'''
'''--- package.json ---
{
  "name": "near-storage-dapp-demo",
  "version": "0.1.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "build": "npm run build:contract && npm run build:web",
    "build:contract": "asb",
    "build:contract:debug": "asb --target debug",
    "build:web": "parcel build src/index.html --public-url ./",
    "deploy": "npm run build && near deploy && gh-pages -d dist/",
    "dev": "npm run build:contract:debug && near dev-deploy && nodemon --watch assembly -e ts --exec npm run dev:start",
    "lint": "eslint \"./**/*.js\" \"./**/*.jsx\"",
    "start": "npm run deploy && parcel src/index.html",
    "dev:start": "env-cmd -f ./neardev/dev-account.env parcel src/index.html",
    "test": "npm run build:contract:debug && asp"
  },
  "devDependencies": {
    "@babel/core": "^7.13.14",
    "@babel/preset-env": "^7.13.12",
    "@babel/preset-react": "^7.13.13",
    "@typescript-eslint/eslint-plugin": "^4.21.0",
    "@typescript-eslint/parser": "^4.21.0",
    "babel-jest": "^26.6.3",
    "eslint": "^7.23.0",
    "eslint-plugin-jest-dom": "^3.7.0",
    "gh-pages": "^3.1.0",
    "jest": "^26.6.3",
    "jest-environment-node": "^26.6.2",
    "near-cli": "^1.6.0",
    "near-sdk-as": "^3.1.0",
    "nodemon": "^2.0.7",
    "parcel-bundler": "^1.12.5",
    "react-test-renderer": "^17.0.2",
    "sass": "^1.32.8",
    "typescript": "^4.2.4"
  },
  "dependencies": {
    "@stablelib/base64": "^1.0.0",
    "@textile/near-storage": "^6.0.2",
    "@types/big.js": "^6.0.2",
    "@types/bs58": "^4.0.1",
    "@types/prop-types": "^15.7.3",
    "@types/react": "^17.0.3",
    "@types/react-dom": "^17.0.3",
    "@types/react-test-renderer": "^17.0.1",
    "big.js": "^6.0.3",
    "bs58": "^4.0.1",
    "env-cmd": "^10.1.0",
    "near-api-js": "^0.41.0",
    "prop-types": "^15.7.2",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-grid-system": "7.1.2",
    "regenerator-runtime": "^0.13.7"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  },
  "jest": {
    "projects": [
      {
        "displayName": "User interface tests",
        "testEnvironment": "jsdom",
        "testMatch": [
          "<rootDir>/src/tests/ui/*.js"
        ]
      },
      {
        "displayName": "Integration tests",
        "testEnvironment": "near-cli/test_environment",
        "testMatch": [
          "<rootDir>/src/tests/integration/*.js"
        ]
      }
    ],
    "testPathIgnorePatterns": [
      "assembly/*"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- src/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME || 'nft-asset-storage.testnet';

function getConfig(env) {
  switch(env) {
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org'
      };
    // This is an example app so production is set to testnet.
    // You can move production to mainnet if that is applicable.
    case 'production':
    case 'development':
    case 'testnet':
      return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org'
      };
    case 'betanet':
      return {
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org'
      };
    case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
        contractName: CONTRACT_NAME
      };
    case 'test':
    case 'ci':
      return {
        networkId: 'shared-test',
        nodeUrl: 'https://rpc.ci-testnet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near'
      };
    case 'ci-betanet':
      return {
        networkId: 'shared-test-staging',
        nodeUrl: 'https://rpc.ci-betanet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near'
      };
    default:
      throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`);
  }
}

module.exports = getConfig;
'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="./favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <link rel="apple-touch-icon" href="./favicon.ico" />
    <link rel="stylesheet" href="global.scss">
    <title>Rule Token Storage</title>
    <meta property="og:title" content="Rule Token Storage">
    <meta property="og:description" content="An NFT asset minter with decentralized Filecoin and IPFS storage.">
    <!-- <meta property="og:image" content=""> -->
    <!-- <meta property="og:url" content=""> -->
    <!-- <meta name="twitter:card" content="summary_large_image"> -->
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm run dev`.
      To create a production bundle, use `npm run build`.
    -->
    <script src="./index.tsx"></script>
  </body>
</html>

'''
'''--- src/tests/integration/App-integration.test.js ---
// these are made available by near-cli/test_environment
// note: do not remove the line below as it is needed for these tests
/* global nearlib, nearConfig */

import 'regenerator-runtime/runtime';

let near;
let contract;
let accountId;

beforeAll(async function() {
  near = await nearlib.connect(nearConfig);
  accountId = nearConfig.contractName;
  contract = await near.loadContract(nearConfig.contractName, {
    viewMethods: ['getStoredAssets'],
    changeMethods: ['storeNewAsset'],
    sender: accountId
  });
});

it('send one message and retrieve it', async() => {
  await contract.storeNewAsset({ id: 'id1', cid: 'cid1', rule: 'aloha1' });
  const msgs = await contract.getStoredAssets();
  const expectedMessagesResult = [{
    sender: accountId,
    id: 'id1',
    cid: 'cid1',
    rule: 'aloha1'
  }];
  expect(msgs).toEqual(expectedMessagesResult);
});

it('send two more messages and expect three total', async() => {
  await contract.storeNewAsset({ id: 'id2', cid: 'cid2', rule: 'aloha2' });
  await contract.storeNewAsset({ id: 'id3', cid: 'cid3', rule: 'aloha3' });
  const msgs = await contract.getStoredAssets();
  expect(msgs.length).toEqual(3);
});

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig.json to read more about this file */
    /* Basic Options */
    // "incremental": true,                         /* Enable incremental compilation */
    "target": "ES6", /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */
    "module": "commonjs", /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */
    "lib": [
      "ES6",
      "DOM",
      "DOM.Iterable"
    ],
    // "allowJs": true, /* Allow javascript files to be compiled. */
    // "checkJs": true,                             /* Report errors in .js files. */
    "jsx": "react", /* Specify JSX code generation: 'preserve', 'react-native', 'react', 'react-jsx' or 'react-jsxdev'. */
    // "declaration": true,                         /* Generates corresponding '.d.ts' file. */
    // "declarationMap": true,                      /* Generates a sourcemap for each corresponding '.d.ts' file. */
    // "sourceMap": true,                           /* Generates corresponding '.map' file. */
    // "outFile": "./",                             /* Concatenate and emit output to single file. */
    // "outDir": "./",                              /* Redirect output structure to the directory. */
    // "rootDir": "./",                             /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */
    // "composite": true,                           /* Enable project compilation */
    // "tsBuildInfoFile": "./",                     /* Specify file to store incremental compilation information */
    // "removeComments": true,                      /* Do not emit comments to output. */
    // "noEmit": true,                              /* Do not emit outputs. */
    // "importHelpers": true,                       /* Import emit helpers from 'tslib'. */
    // "downlevelIteration": true,                  /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */
    // "isolatedModules": true,                     /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */
    /* Strict Type-Checking Options */
    "strict": true, /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                       /* Raise error on expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                    /* Enable strict null checks. */
    // "strictFunctionTypes": true,                 /* Enable strict checking of function types. */
    // "strictBindCallApply": true,                 /* Enable strict 'bind', 'call', and 'apply' methods on functions. */
    // "strictPropertyInitialization": true,        /* Enable strict checking of property initialization in classes. */
    // "noImplicitThis": true,                      /* Raise error on 'this' expressions with an implied 'any' type. */
    // "alwaysStrict": true,                        /* Parse in strict mode and emit "use strict" for each source file. */
    /* Additional Checks */
    // "noUnusedLocals": true,                      /* Report errors on unused locals. */
    // "noUnusedParameters": true,                  /* Report errors on unused parameters. */
    // "noImplicitReturns": true,                   /* Report error when not all code paths in function return a value. */
    // "noFallthroughCasesInSwitch": true,          /* Report errors for fallthrough cases in switch statement. */
    // "noUncheckedIndexedAccess": true,            /* Include 'undefined' in index signature results */
    // "noPropertyAccessFromIndexSignature": true,  /* Require undeclared properties from index signatures to use element accesses. */
    /* Module Resolution Options */
    "moduleResolution": "node", /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */
    // "baseUrl": "./",                             /* Base directory to resolve non-absolute module names. */
    // "paths": {},                                 /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */
    // "rootDirs": [],                              /* List of root folders whose combined content represents the structure of the project at runtime. */
    // "typeRoots": [],                             /* List of folders to include type definitions from. */
    // "types": [],                                 /* Type declaration files to be included in compilation. */
    // "allowSyntheticDefaultImports": true,        /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */
    "esModuleInterop": true, /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */
    // "preserveSymlinks": true,                    /* Do not resolve the real path of symlinks. */
    // "allowUmdGlobalAccess": true,                /* Allow accessing UMD globals from modules. */
    /* Source Map Options */
    // "sourceRoot": "",                            /* Specify the location where debugger should locate TypeScript files instead of source locations. */
    // "mapRoot": "",                               /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,                     /* Emit a single file with source maps instead of having a separate file. */
    // "inlineSources": true,                       /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */
    /* Experimental Options */
    // "experimentalDecorators": true,              /* Enables experimental support for ES7 decorators. */
    // "emitDecoratorMetadata": true,               /* Enables experimental support for emitting type metadata for decorators. */
    /* Advanced Options */
    "skipLibCheck": true, /* Skip type checking of declaration files. */
    "forceConsistentCasingInFileNames": true /* Disallow inconsistently-cased references to the same file. */
  }
}
'''