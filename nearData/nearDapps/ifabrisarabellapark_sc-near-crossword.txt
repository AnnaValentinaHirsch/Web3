*GitHub Repository "ifabrisarabellapark/sc-near-crossword"*

'''--- DEPLOY.md ---
<p align="center">
  <a href="https://near.org/">
    <img alt="Near" src="https://github.com/irene-bbox/sc-near-crossword/blob/master/public/near_white.png" width="250" />
  </a>
</p>

# Build & Deploy a NEAR Smart Contract
This guide teaches you how to compile, deploy, and interact with a Rust Smart Contract on NEAR testnet. For more comprehensive NEAR SDK documentation consult their official webpage [here](https://www.near-sdk.io/zero-to-hero/basics/set-up-skeleton)

---

## Create testnet account

Navigate to NEAR testnet [wallet](https://wallet.testnet.near.org) and click on 'Create Account'.

## Configure CLI

```bash
npm install -g near-cli                                                    # Install the NEAR CLI
near                                                                       # To see various possible commands run
near login                                                                 # Log into your NEAR testnet wallet
near keys <youraccountname>.testnet                                        # Visualize your keys running
```

## Set up Rust

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh              # If you haven't installed Rust yet, install it now using rustup
rustup target add wasm32-unknown-unknown                                    # Add Wasm toolchain
```

Some -but not all- Smart Contracts (e.g., SCRT Network, NEAR Protocol, etc.) compile to WebAssembly (Wasm) and that's why we add the toolchain for Rust.
> :no_entry_sign: Note: NEAR never uses `cargo run`. Why? Because smart contracts are technically libraries and not binaries, so some blockchains, like NEAR, choose not to compile a contract via commonly used Rust commands, like `cargo run`.

## Prep smart contract

This guide assumes you already have a ready-to-deploy smart contract. If you haven't, download a simple smart contract template [here.](https://github.com/near-examples/rust-template)

## Deploy

There are 4 basic steps to deploy a Smart Contract on NEAR:
1. :wrench: build contract
2. :truck: create a sub-account (or delete and recreate it)
3. :clapper: deploy to subaccount
4. :surfer: interact 

`Cd` into the repo with the Rust codebase for your contract and run:

```bash
./build.sh                                                                                        # Build the contract
near create-account subaccountname.accountname.testnet --masterAccount accountname.testnet        # Create a subaccount
near state subaccountname.accountname.testnet                                                     # Check subaccount state
# now ensure you're in the directory that contains the 'res' directory, then run
near deploy subaccountname.accountname.testnet --wasmFile res/<my_projectname>.wasm               # Deploy the contract
near state subaccountname.accountname.testnet                                                     # Check again state of subaccount
```
`<my_projectname>` is the name you assigned to the 'name' variable inside your Cargo.toml file

## Interact

There are few ways to interact with the contract, depending on whether you are calling on a method that is view-only or a method that changes the state of the contract. For view-only use the `near view` command:

```bash
near view subaccountname.accountname.testnet <name_of_viewing_function>
```

For state-handling use the `near call` command:

```bash
near call subaccountname.accountname.testnet <name_of_handling_function> '{"string": "Helloworld!"}' --accountId accountname.testnet
```
Notice that in the `near call` command we must include the `--accountId` flag. This is because changing the state of a contract cost a gas fee and thus we must specify which NEAR account we want to use to sign the transaction, and pay the gas fee.

## Reset account

Your best bet to start fresh with a smart contract is to first **delete** the subaccount (sending all remaining testnet Ⓝ to a recipient)  and then **create** the account again, in this way: 

```bash
near delete subaccountname.accountname.testnet accountname.testnet
near create-account subaccountname.accountname.testnet --masterAccount accountname.testnet
```
The first command deletes `subaccountname.accountname.testnet` and sends the rest of its NEAR to `accountname.testnet`.
> :warning: Beware though! Every interaction with your account costs gas (e.g., creating an accounts costs 100 Ⓝ).

## Unit test

Remember that a smart contract is technically a library as defined in the manifest file (which is the Cargo.toml). A consequence of writing a library in Rust is not having a 'main' function that runs, and that's why we use unit tests to ineract with the contract instead. Unit tests act as a helper during development. To execute your test run

```bash
cargo test                                              # w/o output 
cargo test -- --nocapture                               # this additional flag includes the test output
cargo test <name_of_test_function> -- --nocapture       # only run the specified test
```

## Batch Actions
Batch actions occurs when you want to perform multiple actions in batch, for example, when you want to *deploy* a smart contract and *call* an initialization function at the same time. Fortunately, NEAR CLI has flags especially designed for this, which you can add to the deploy command to batch multiple actions at once. Just run the `near deploy` command with the handy `--initFunction` and `--initArgs` flags. 

```bash
# Deploy & call the init functions SIMULTANEOUSLY
near deploy subaccount.account.testnet --wasmFile res/<my_projectname>.wasm \
  --initFunction 'my_init_function' \
  --initArgs '{"parameter": "my_init_parameter"}'
```

> `<my_projectname>` is the name you assigned to the 'name' variable inside your Cargo.toml file

> :radioactive: Beware though! Every smart contract can only be initialized **ONCE** and never again!
'''
'''--- README.md ---

# :spades: :spades: :spades:  Play Crossword Puzzles on NEAR Protocol
<p align="center">
  <a href="https://near.org/">
    <img alt="Near" src="https://github.com/irene-bbox/sc-near-crossword/blob/master/public/near_purple.png" width="1000" />
  </a>
</p>

---

### Requirements  

node.js, npm (or yarn), Rust, and Wasm toolchain

##### Install Rust and Wasm toolchain

To [install Rust](https://doc.rust-lang.org/book/ch01-01-installation.html) on Linux or MacOS, use the following command:

```bash
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
```

Then, add the `wasm32-unknown-unknown` toolchain. This toolchain is required because the Rust contract that we will build will be compiled to [Wasm](https://webassembly.org/) (Web Assembly) to run on the NEAR blockchain.

```bash
rustup target add wasm32-unknown-unknown
```

### Getting started 

Run the following command on your local environment:

```bash
git clone https://github.com/irene-bbox/sc-near-crossword.git <path_to_local_repository>        # clone repo
cd <path_to_local_repository>                                                                   # enter repo

cd contract                                                                                     # enter directory with Smart Contract code  
export PATH="$HOME/.cargo/bin:$PATH"                                                            # (optional) add the Cargo Rust dir to path
./build.sh                                                                                      # compile the Smart Contract

cd ..                                                                                           # exit Smart Contract directory
env CONTRACT_NAME=crossword.zion.testnet npm run start                                          # launch React dApp
```

Tha last command will runs the app in the development mode.\
Open [http://localhost:1234](http://localhost:1234) to view it in the browser.

### Log into NEAR 

Create a [NEAR wallet](https://wallet.testnet.near.org/) on testnet.\
Log into your NEAR wallet from the browser where you launched the crossword puzzle. :satellite: 

![NEAR Login](https://github.com/irene-bbox/sc-near-crossword/blob/master/public/login.png)

### Solve the puzzle  :ninja:

You're now ready to play!\
Go ahead and solve the crossword puzzle!\
Your solution will be saved to the NEAR blockchain and will be visible in the NEAR Blockchain [Explorer](https://explorer.testnet.near.org/).

'''
'''--- contract/Cargo.toml ---
[package]
name = "my_crossword"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>", "Mike Purvis <mike@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0-pre.4"
hex = "0.4.3"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- contract/build.bat ---
cargo build --target wasm32-unknown-unknown --release
copy target\wasm32-unknown-unknown\release\crossword_tutorial_chapter_2.wasm res
'''
'''--- contract/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/crossword_tutorial_chapter_2.wasm ./res/

'''
'''--- contract/src/lib.rs ---
// Import crates
use near_sdk::collections::{LookupMap, UnorderedSet};
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    log,
    serde::{Deserialize, Serialize},
    AccountId, PanicOnDefault, Promise,
};
use near_sdk::{env, near_bindgen};

// 5 Ⓝ in yoctoNEAR
const PRIZE_AMOUNT: u128 = 5_000_000_000_000_000_000_000_000;

//___________________________________________________________________________________//
//                                                                                   //
//                                  Structs & Enums                                  //
//                                                                                   //
//___________________________________________________________________________________//

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum PuzzleStatus {
    Unsolved,
    Solved { memo: String },
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct UnsolvedPuzzles {
    puzzles: Vec<JsonPuzzle>,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum AnswerDirection {
    Across,
    Down,
}

// Coordinates of where the crossword begins
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct CoordinatePair {
    x: u8,
    y: u8,
}

// Info on puzzle answer
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Answer {
    num: u8,
    start: CoordinatePair,
    direction: AnswerDirection,
    length: u8,
    clue: String,
}

// Puzzle status
#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub struct Puzzle {
    status: PuzzleStatus, // ⟵ An enum we'll get to soon
    answer: Vec<Answer>,  // ⟵ Another struct we've defined
}

// Same Puzzle as above w/ human-readable (not in bytes) hash of the crossword solution
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonPuzzle {
    solution_hash: String,
    status: PuzzleStatus,
    answer: Vec<Answer>,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
// 'Crossword' is our primary struct or singleton.
// Remember the singleton is the ONLY struct that ALWAYS gets the #[near_bindgen] macro placed on it
pub struct Crossword {
    // crossword_solution: String, // SETUP CONTRACT STATE
    // add an owner_id because it's common in smart contract development to implement a rudimentary permission system which can restrict access to certain functions
    owner_id: AccountId,
    puzzles: LookupMap<String, Puzzle>, // ⟵ 'Puzzle' is a struct we're defining
    unsolved_puzzles: UnorderedSet<String>,
}

// Check user balance
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalance {
    pub total: u128,
    pub available: u128,
}

//___________________________________________________________________________________//
//                                                                                   //
//                              Implementations                                      //
//                                                                                   //
//___________________________________________________________________________________//
#[near_bindgen]
impl Crossword {
    // ADD CONTRACT METHODS HERE

    // create a new 'Crossword' object
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        Self {
            owner_id,
            puzzles: LookupMap::new(b"c"),
            unsolved_puzzles: UnorderedSet::new(b"u"),
        }
    }

    // create a new puzzle method to insert multiple crosswords
    pub fn new_puzzle(&mut self, solution_hash: String, answers: Vec<Answer>) {
        // first thing that happens in the new_puzzle method is a check
        // we check that the predecessor (whoever called this method last) is indeed the contract owner
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "Only the owner may call this method"
        ); // if someone else other than the owner is trying to call new_puzzle, the smart contract will panic,
           // going no further. Hence, notice that assert_eq! breaks contract executions when it panics.

        let existing = self.puzzles.insert(
            &solution_hash,
            &Puzzle {
                status: PuzzleStatus::Unsolved,
                answer: answers,
            },
        );

        // perform another check: add a new puzzle only if it's not a duplicate of a pre-existing one
        assert!(existing.is_none(), "Puzzle with that key already exists");
        self.unsolved_puzzles.insert(&solution_hash);
    }

    // submit solution to the net
    pub fn submit_solution(&mut self, solution: String, memo: String) {
        let hashed_input = env::sha256(solution.as_bytes());
        let hashed_input_hex = hex::encode(&hashed_input);

        // Check to see if the hashed answer is among the puzzles
        let mut puzzle = self
            .puzzles
            .get(&hashed_input_hex)
            .expect("ERR_NOT_CORRECT_ANSWER");

        // Check if the puzzle is already solved. If it's unsolved, set the status to solved,
        //   then proceed to update the puzzle and pay the winner.
        puzzle.status = match puzzle.status {
            PuzzleStatus::Unsolved => PuzzleStatus::Solved { memo: memo.clone() },
            _ => {
                env::panic_str("ERRO_PUZZLE_SOLVED");
            }
        };

        // Reinsert the puzzle back in after we modified the status
        self.puzzles.insert(&hashed_input_hex, &puzzle);
        // Remove from the list of unsolved ones
        self.unsolved_puzzles.remove(&hashed_input_hex);

        log!(
            "Puzzle with solution hash {} solved, with memo {}",
            hashed_input_hex,
            memo
        );

        // Transfer the prize money to the winner
        Promise::new(env::predecessor_account_id()).transfer(PRIZE_AMOUNT);
    }

    /// Get the hash of a crossword puzzle solution from the unsolved_puzzles
    pub fn get_solution(&self, puzzle_index: u32) -> Option<String> {
        let mut index = 0;
        for puzzle_hash in self.unsolved_puzzles.iter() {
            if puzzle_index == index {
                return Some(puzzle_hash);
            }
            index += 1;
        }
        // Did not find that index
        None
    }

    pub fn get_puzzle_status(&self, solution_hash: String) -> Option<PuzzleStatus> {
        let puzzle = self.puzzles.get(&solution_hash);
        if puzzle.is_none() {
            return None;
        }
        Some(puzzle.unwrap().status)
    }

    pub fn get_unsolved_puzzles(&self) -> UnsolvedPuzzles {
        let solution_hashes = self.unsolved_puzzles.to_vec();
        let mut all_unsolved_puzzles = vec![];
        for hash in solution_hashes {
            let puzzle = self
                .puzzles
                .get(&hash)
                .unwrap_or_else(|| env::panic_str("ERR_LOADING_PUZZLE"));
            let json_puzzle = JsonPuzzle {
                solution_hash: hash,
                status: puzzle.status,
                answer: puzzle.answer,
            };
            all_unsolved_puzzles.push(json_puzzle)
        }
        UnsolvedPuzzles {
            puzzles: all_unsolved_puzzles,
        }
    }

    // // costless query the state of the contract
    // // CHALLENGE: try and query for free ALL solutions from the contract
    // // performs a check to see whether the querier is the contract owner
    // pub fn get_solution(&self) -> String {
    //     self.crossword_solution.clone()
    // }
}

//___________________________________________________________________________________//
//                                                                                   //
//                                   Unit Tests                                      //
//                                                                                   //
//___________________________________________________________________________________//
/*
 * the rest of this file sets up unit tests
 * to run these, the command will be:
 * cargo test --package rust-template -- --nocapture
 * Note: 'rust-template' comes from Cargo.toml's 'name' key
 */

// use the attribute below for unit tests
#[cfg(test)] // <-- this line prevents this module from being run unless I execute 'cargo test'
mod tests {
    use super::*;
    use near_sdk::test_utils::{get_logs, VMContextBuilder};
    use near_sdk::{testing_env, AccountId};

    #[test]
    fn debug_get_hash() {
        // Basic set up for a unit test
        testing_env!(VMContextBuilder::new().build());

        // Use a unit test to rapidly debug and iterate
        let debug_solution = "happy birthday mayllon from bboxteam";
        let debug_hash_bytes = env::sha256(debug_solution.as_bytes());
        let debug_hash_string = hex::encode(debug_hash_bytes);
        println!("Let's debug: {:?}", debug_hash_string)
    }

    // part of writing unit tests is setting up a mock context
    // provide a `predecessor` here, it'll modify the default context
    fn get_context(predecessor: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder.predecessor_account_id(predecessor);
        builder
    }

    #[test]
    fn check_guess_solution() {
        // get your account id
        let arabella = AccountId::new_unchecked("arabellapark.testnet".to_string());
        // set up the testing context and the unit test environmnet
        let context = get_context(arabella);
        testing_env!(context.build());

        // set up the contract object
        let mut contract = Contract::new(
            "a01c354e04406da49ec20d9f258a71e050e1ea1f2756db451626be2ffd5ae13f".to_string(),
        );

        // call the guess_solution function with the incorrect solution
        let mut guess_result = contract.guess_solution("wrong answer here".to_string());
        println!("First attempt: {}", !guess_result);
        assert!(!guess_result, "Expected a failure from the wrong guess"); // 'assert' with a custom message
        assert_eq!(get_logs(), ["Try again"], "Expected a failure log."); // 'assert_eq' with a custom message

        // call the guess_solution function with the correct solution
        guess_result = contract.guess_solution("happy birthday mayllon from bboxteam".to_string());
        println!("Second attempt: {}", guess_result);
        assert!(guess_result, "Expected the correct answer to return true.");
        assert_eq!(
            get_logs(),
            ["You guessed right"],
            "Expected a successful log after the previous failed log."
        );
    }
}

'''
'''--- contract/test.sh ---
#!/bin/bash
set -e

cargo test -- --nocapture

'''
'''--- contract/testnet-deploy.sh ---
#!/bin/bash

./build.sh

export NEAR_ACCT=xword.demo.testnet
export PARENT_ACCT=demo.testnet
near delete $NEAR_ACCT $PARENT_ACCT
near create-account $NEAR_ACCT --masterAccount $PARENT_ACCT
near deploy $NEAR_ACCT --wasmFile res/crossword_tutorial_chapter_2.wasm --initFunction new --initArgs '{"owner_id": "'$NEAR_ACCT'"}'

# We're able to determine the public key by visiting a site like:
# https://www.wolframalpha.com/input/?i=sha256+%22paras+rainbowbridge+mintbase+yoctonear+cli%22

near call $NEAR_ACCT new_puzzle '{
  "solution_hash": "d1a5cf9ad1adefe0528f7d31866cf901e665745ff172b96892693769ad284010",
  "answers": [
   {
     "num": 1,
     "start": {
       "x": 1,
       "y": 1
     },
     "direction": "Down",
     "length": 5,
     "clue": "NFT market on NEAR that specializes in cards and comics."
   },
   {
     "num": 2,
     "start": {
       "x": 0,
       "y": 2
     },
     "direction": "Across",
     "length": 13,
     "clue": "You can move assets between NEAR and different chains, including Ethereum, by visiting ______.app"
   },
   {
     "num": 3,
     "start": {
       "x": 9,
       "y": 1
     },
     "direction": "Down",
     "length": 8,
     "clue": "NFT market on NEAR with art, physical items, tickets, and more."
   },
   {
     "num": 4,
     "start": {
       "x": 3,
       "y": 8
     },
     "direction": "Across",
     "length": 9,
     "clue": "The smallest denomination of the native token on NEAR."
   },
   {
     "num": 5,
     "start": {
       "x": 5,
       "y": 8
     },
     "direction": "Down",
     "length": 3,
     "clue": "You typically deploy a smart contract with the NEAR ___ tool."
   }
  ]
}' --accountId $NEAR_ACCT

'''
'''--- dist/contract/Cargo.toml ---
[package]
name = "my-crossword"
version = "0.1.0"
authors = ["zion.testnet"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0-pre.4"
hex = "0.4.3"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- dist/contract/build.bat ---
cargo build --target wasm32-unknown-unknown --release
copy target\wasm32-unknown-unknown\release\*.wasm res
'''
'''--- dist/contract/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./res/

'''
'''--- dist/contract/src/lib.rs ---
// Import crates
use near_sdk::collections::{LookupMap, UnorderedSet};
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    log,
    serde::{Deserialize, Serialize},
    AccountId, PanicOnDefault, Promise,
};
use near_sdk::{env, near_bindgen};

// 5 Ⓝ in yoctoNEAR
const PRIZE_AMOUNT: u128 = 5_000_000_000_000_000_000_000_000;

//___________________________________________________________________________________//
//                                                                                   //
//                                  Structs & Enums                                  //
//                                                                                   //
//___________________________________________________________________________________//

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum PuzzleStatus {
    Unsolved,
    Solved { memo: String },
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum AnswerDirection {
    Across,
    Down,
}

// Coordinates of where the crossword begins
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct CoordinatePair {
    x: u8,
    y: u8,
}

// Info on puzzle answer
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Answer {
    num: u8,
    start: CoordinatePair,
    direction: AnswerDirection,
    length: u8,
    clue: String,
}

// Puzzle status
#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub struct Puzzle {
    status: PuzzleStatus, // ⟵ An enum we'll get to soon
    answer: Vec<Answer>,  // ⟵ Another struct we've defined
}

// Same Puzzle as above w/ human-readable (not in bytes) hash of the crossword solution
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonPuzzle {
    solution_hash: String,
    status: PuzzleStatus,
    answer: Vec<Answer>,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
// 'Crossword' is our primary struct or singleton.
// Remember the singleton is the ONLY struct that ALWAYS gets the #[near_bindgen] macro placed on it
pub struct Crossword {
    // crossword_solution: String, // SETUP CONTRACT STATE
    // add an owner_id because it's common in smart contract development to implement a rudimentary permission system which can restrict access to certain functions
    owner_id: AccountId,
    puzzles: LookupMap<String, Puzzle>, // ⟵ 'Puzzle' is a struct we're defining
    unsolved_puzzles: UnorderedSet<String>,
}

// Check user balance
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalance {
    pub total: u128,
    pub available: u128,
}

//___________________________________________________________________________________//
//                                                                                   //
//                              Implementations                                      //
//                                                                                   //
//___________________________________________________________________________________//
#[near_bindgen]
impl Crossword {
    // ADD CONTRACT METHODS HERE

    // create a new 'Corossword' object
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        Self {
            owner_id,
            puzzles: LookupMap::new(b"c"),
            unsolved_puzzles: UnorderedSet::new(b"u"),
        }
    }

    // create a new puzzle method to insert multiple crosswords
    pub fn new_puzzle(&mut self, solution_hash: String, answers: Vec<Answer>) {
        // first thing that happens in the new_puzzle method is a check
        // we check that the predecessor (whoever called this method last) is indeed the contract owner
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "Only the owner may call this method"
        ); // if someone else other than the owner is trying to call new_puzzle, the smart contract will panic,
           // going no further. Hence, notice that assert_eq! breaks contract executions when it panics.

        let existing = self.puzzles.insert(
            &solution_hash,
            &Puzzle {
                status: PuzzleStatus::Unsolved,
                answer: answers,
            },
        );

        // perform another check: add a new puzzle only if it's not a duplicate of a pre-existing one
        assert!(existing.is_none(), "Puzzle with that key already exists");
        self.unsolved_puzzles.insert(&solution_hash);
    }

    // submit solution to the net
    pub fn submit_solution(&mut self, solution: String, memo: String) {
        let hashed_input = env::sha256(solution.as_bytes());
        let hashed_input_hex = hex::encode(&hashed_input);

        // Check to see if the hashed answer is among the puzzles
        let mut puzzle = self
            .puzzles
            .get(&hashed_input_hex)
            .expect("ERR_NOT_CORRECT_ANSWER");

        // Check if the puzzle is already solved. If it's unsolved, set the status to solved,
        //   then proceed to update the puzzle and pay the winner.
        puzzle.status = match puzzle.status {
            PuzzleStatus::Unsolved => PuzzleStatus::Solved { memo: memo.clone() },
            _ => {
                env::panic_str("ERRO_PUZZLE_SOLVED");
            }
        };

        // Reinsert the puzzle back in after we modified the status
        self.puzzles.insert(&hashed_input_hex, &puzzle);
        // Remove from the list of unsolved ones
        self.unsolved_puzzles.remove(&hashed_input_hex);

        log!(
            "Puzzle with solution hash {} solved, with memo {}",
            hashed_input_hex,
            memo
        );

        // Transfer the prize money to the winner
        Promise::new(env::predecessor_account_id()).transfer(PRIZE_AMOUNT);
    }

    // // costless query the state of the contract
    // // CHALLENGE: try and query for free ALL solutions from the contract
    // // performs a check to see whether the querier is the contract owner
    // pub fn get_solution(&self) -> String {
    //     self.crossword_solution.clone()
    // }
}

//___________________________________________________________________________________//
//                                                                                   //
//                                   Unit Tests                                      //
//                                                                                   //
//___________________________________________________________________________________//
/*
 * the rest of this file sets up unit tests
 * to run these, the command will be:
 * cargo test --package rust-template -- --nocapture
 * Note: 'rust-template' comes from Cargo.toml's 'name' key
 */

// use the attribute below for unit tests
#[cfg(test)] // <-- this line prevents this module from being run unless I execute 'cargo test'
mod tests {
    use super::*;
    use near_sdk::test_utils::{get_logs, VMContextBuilder};
    use near_sdk::{testing_env, AccountId};

    #[test]
    fn debug_get_hash() {
        // Basic set up for a unit test
        testing_env!(VMContextBuilder::new().build());

        // Use a unit test to rapidly debug and iterate
        let debug_solution = "happy birthday mayllon from bboxteam";
        let debug_hash_bytes = env::sha256(debug_solution.as_bytes());
        let debug_hash_string = hex::encode(debug_hash_bytes);
        println!("Let's debug: {:?}", debug_hash_string)
    }

    // part of writing unit tests is setting up a mock context
    // provide a `predecessor` here, it'll modify the default context
    fn get_context(predecessor: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder.predecessor_account_id(predecessor);
        builder
    }

    #[test]
    fn check_guess_solution() {
        // get your account id
        let arabella = AccountId::new_unchecked("arabellapark.testnet".to_string());
        // set up the testing context and the unit test environmnet
        let context = get_context(arabella);
        testing_env!(context.build());

        // set up the contract object
        let mut contract = Contract::new(
            "a01c354e04406da49ec20d9f258a71e050e1ea1f2756db451626be2ffd5ae13f".to_string(),
        );

        // call the guess_solution function with the incorrect solution
        let mut guess_result = contract.guess_solution("wrong answer here".to_string());
        println!("First attempt: {}", !guess_result);
        assert!(!guess_result, "Expected a failure from the wrong guess"); // 'assert' with a custom message
        assert_eq!(get_logs(), ["Try again"], "Expected a failure log."); // 'assert_eq' with a custom message

        // call the guess_solution function with the correct solution
        guess_result = contract.guess_solution("happy birthday mayllon from bboxteam".to_string());
        println!("Second attempt: {}", guess_result);
        assert!(guess_result, "Expected the correct answer to return true.");
        assert_eq!(
            get_logs(),
            ["You guessed right"],
            "Expected a successful log after the previous failed log."
        );
    }
}

'''
'''--- dist/contract/test.sh ---
#!/bin/bash
set -e

cargo test -- --nocapture

'''
'''--- dist/index.css ---
#page {
    padding: 2em;
}

h1 {
    margin-bottom: 1em;
}

#crossword-wrapper .clue.correct::before {
    content: "✓";
    display: inline-block;
    text-decoration: none;
    color: rgb(100, 200, 100);
    margin-right: 0.25em;
}

#crossword-wrapper {
    margin-top: 2em;
}

#messages {
    background-color: rgb(230, 230, 230);
    margin: 1em 0;
    padding: 1em;
}

body {
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

code {
    font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

/*# sourceMappingURL=/index.css.map */
'''
'''--- dist/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <link rel="icon" href="/favicon.26242483.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#000000">
  <link rel="apple-touch-icon" href="/favicon.26242483.ico">
<!--  <link rel="stylesheet" href="global.scss">-->
  <title>NEAR Crossword Puzzle</title>
  <meta property="og:title" content="NEAR Crossword Puzzle">
  <meta property="og:description" content="A learning opportunity with NEAR smart contracts and tools.">

<link rel="stylesheet" href="/src.e31bb0bc.css"></head>
<body>
<noscript>You need to enable JavaScript to run this app.</noscript>
<div id="root"></div>
<script src="/src.e31bb0bc.js"></script>
</body>
</html>

'''
'''--- dist/src.e31bb0bc.css ---
#page {
    padding: 2em;
}

h1 {
    margin-bottom: 1em;
}

#crossword-wrapper .clue.correct::before {
    content: "✓";
    display: inline-block;
    text-decoration: none;
    color: rgb(100, 200, 100);
    margin-right: 0.25em;
}

#crossword-wrapper {
    max-width: 66%;
    margin: 2em auto 0 auto;
}

#messages {
    background-color: rgb(230, 230, 230);
    margin: 1em 0;
    padding: 1em;
}

@font-face {
    font-family: 'Inter';
    src:  url('/Inter-Regular.3b99ff55.ttf') format('ttf'),
    url('/Inter-Medium.ccf17ea8.ttf') format('ttf');
}

body {
    margin: 0;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

code {
    font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

span.important {
    font-size: 1.9rem;
    color: #FF585D;
}

.claim-inputs {
    margin-top: 30px
}

.claim-inputs label {
    font-size: 1.3em;
}

#claim-memo, #claim-account-id, .btn {
    border-radius: 5px;
    border: .1em solid #000;
    padding: .5em 1em;
    font-size: 1.66em;
    margin: .5em;
}

.claim-inputs .btn {
    margin: .5em;
}

#page h1, #page .no-puzzles {
    text-align: center;
}

#page .no-puzzles .cli-command {
    text-align: left;
}

#page.claim {
    margin: 0 auto;
    width: 576px;
}

button, .highlight {
    border-radius: 5px;
    border: 0.1em solid #262626;
    padding: 0.5em 1em;
}

button:hover, button:focus, button:focus-within, .highlight:hover, .highlight:focus, .highlight:focus-within {
    border-color: #5F8AFA;
}

#login {
    text-align: right;
}

button {
    background: transparent;
    color: inherit;
    cursor: pointer;
    font: inherit;
    outline: none;
}

/*# sourceMappingURL=/src.e31bb0bc.css.map */
'''
'''--- package.json ---
{
  "name": "crossword-react",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.11.4",
    "@testing-library/react": "^11.1.0",
    "@testing-library/user-event": "^12.1.10",
    "bs58": "^4.0.1",
    "js-sha256": "^0.9.0",
    "near-api-js": "^0.42.0",
    "prop-types": "^15.5.4",
    "react": "^15.0.0 || ^16.0.0",
    "react-crossword-near": "^2.3.1",
    "react-dom": "^15.0.0 || ^16.0.0",
    "react-fullpage-custom-loader": "^0.1.6",
    "react-scripts": "4.0.3",
    "styled-components": "^5.2.0",
    "web-vitals": "^1.0.1"
  },
  "scripts": {
    "start": "parcel src/index.html",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "parcel-bundler": "^1.12.5"
  }
}

'''
'''--- public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- public/manifest.json ---
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

'''
'''--- public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- src/App.css ---
#page {
    padding: 2em;
}

h1 {
    margin-bottom: 1em;
}

#crossword-wrapper .clue.correct::before {
    content: "✓";
    display: inline-block;
    text-decoration: none;
    color: rgb(100, 200, 100);
    margin-right: 0.25em;
}

#crossword-wrapper {
    max-width: 66%;
    margin: 2em auto 0 auto;
}

#messages {
    background-color: rgb(230, 230, 230);
    margin: 1em 0;
    padding: 1em;
}

@font-face {
    font-family: 'Inter';
    src:  url('./fonts/static/Inter-Regular.ttf') format('ttf'),
    url('./fonts/static/Inter-Medium.ttf') format('ttf');
}

body {
    margin: 0;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

code {
    font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

span.important {
    font-size: 1.9rem;
    color: #FF585D;
}

.claim-inputs {
    margin-top: 30px
}

.claim-inputs label {
    font-size: 1.3em;
}

#claim-memo, #claim-account-id, .btn {
    border-radius: 5px;
    border: .1em solid #000;
    padding: .5em 1em;
    font-size: 1.66em;
    margin: .5em;
}

.claim-inputs .btn {
    margin: .5em;
}

#page h1, #page .no-puzzles {
    text-align: center;
}

#page .no-puzzles .cli-command {
    text-align: left;
}

#page.claim {
    margin: 0 auto;
    width: 576px;
}

button, .highlight {
    border-radius: 5px;
    border: 0.1em solid #262626;
    padding: 0.5em 1em;
}

button:hover, button:focus, button:focus-within, .highlight:hover, .highlight:focus, .highlight:focus-within {
    border-color: #5F8AFA;
}

#login {
    text-align: right;
}

button {
    background: transparent;
    color: inherit;
    cursor: pointer;
    font: inherit;
    outline: none;
}
'''
'''--- src/App.js ---
import './App.css';
import React, { useCallback, useRef, useState } from 'react';
import Crossword from 'react-crossword-near';
import { parseSolutionSeedPhrase } from './utils';
import nearCLICommand from './near-cli-command';
import { createGridData, loadGuesses } from "react-crossword-near/dist/es/util";
import sha256 from 'js-sha256';
import SimpleDark from './loader';
import { DEFAULT_FUNCTION_CALL_GAS } from "near-api-js/src/constants";

const App = ({ data, hash, nearConfig, walletConnection, currentUser }) => {
  const crossword = useRef();
  const [solutionFound, setSolutionFound] = useState("Not correct yet");
  const [showLoader, setShowLoader] = useState(false);
  const [solutionHash, setSolutionHash] = useState(hash);
  const [transactionHash, setTransactionHash] = useState(false);

  const onCrosswordComplete = useCallback(
    async (completeCount) => {
      if (completeCount !== false) {
        let gridData = createGridData(data).gridData;
        loadGuesses(gridData, 'guesses');
        await checkSolution(gridData);
      }
    },
    []
  );

  // This function is called when all entries are filled
  async function checkSolution(gridData) {
    let seedPhrase = parseSolutionSeedPhrase(data, gridData);
    let answerHash = sha256.sha256(seedPhrase);
    // Compare crossword solution's public key with the known public key for this puzzle
    // (It was given to us when we first fetched the puzzle in index.js)
    if (answerHash === solutionHash) {
      console.log("You're correct!");
      setSolutionFound("Correct!");

      // Clean up and get ready for next puzzle
      localStorage.removeItem('guesses');
      setSolutionHash(null);
      // Show full-screen loader as we process transaction
      setShowLoader(true);
      // Send the 5 NEAR prize to the logged-in winner
      let functionCallResult = await walletConnection.account().functionCall({
        contractId: nearConfig.contractName,
        methodName: 'submit_solution',
        args: {solution: seedPhrase, memo: "Yay I won!"},
        gas: DEFAULT_FUNCTION_CALL_GAS, // optional param, by the way
        attachedDeposit: 0,
        walletMeta: '', // optional param, by the way
        walletCallbackUrl: '' // optional param, by the way
      });
      if (functionCallResult && functionCallResult.transaction && functionCallResult.transaction.hash) {
        console.log('Transaction hash for explorer', functionCallResult.transaction.hash)
        setTransactionHash(functionCallResult.transaction.hash);
      }
      setShowLoader(false);
    } else {
      console.log("That's not the correct solution. :/");
      setSolutionFound("Not correct yet");
    }
  }

  const signIn = () => {
    walletConnection.requestSignIn(
      nearConfig.contractName,
      '', // title. Optional, by the way
      '', // successUrl. Optional, by the way
      '', // failureUrl. Optional, by the way
    );
  };

  const signOut = () => {
    walletConnection.signOut();
    window.location.replace(window.location.origin + window.location.pathname);
  };

  if (showLoader) {
    return (
      <div className="wrapper">
        <header className="site-header">
        </header>
        <main className="main-area">
          <SimpleDark />
        </main>
      </div>
    )
  } else if (solutionHash) {
    // A solution hash was found, meaning there's a crossword puzzle to solve
    return (
      <div id="page">
        <h1>NEAR Crossword Puzzle</h1>
        <div id="crossword-wrapper">
          <div id="login">
            { currentUser
              ? <button onClick={signOut}>Log out</button>
              : <button onClick={signIn}>Log in</button>
            }
          </div>
          <h3>Status: { solutionFound }</h3>
          <Crossword
            data={data}
            ref={crossword}
            onCrosswordComplete={onCrosswordComplete}
          />
          <p>Thank you <a href="https://github.com/JaredReisinger/react-crossword" target="_blank" rel="noreferrer">@jaredreisinger/react-crossword</a>!</p>
        </div>
      </div>
    );
  } else {
    // No solution hash was found, let the user know
    const explorerUrl = `https://explorer.testnet.near.org/transactions/${transactionHash}`;
    return (
      <div id="page">
        <h1>NEAR Crossword Puzzle</h1>
        <div id="crossword-wrapper" className="no-puzzles">
          { transactionHash && <a href={explorerUrl} target="_blank">See transaction on NEAR Explorer</a>}
          <h2>No puzzles to solve :)</h2>
          <p>Sorry, no puzzles to solve.</p>
          <p>If you are the developer and are surprised to see this, perhaps you'll want to add a puzzle:</p>
          <p>With <a href="https://docs.near.org/docs/tools/near-cli#installation" target="_blank">NEAR CLI</a>:</p>
          <div className="cli-command">
            <code>
              {nearCLICommand}
            </code>
          </div>
        </div>
      </div>
    );
  }
}

export default App;

'''
'''--- src/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME || 'crossword.zion.testnet';

function getConfig(env) {
  switch(env) {
    case 'production':
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org'
      };
    case 'development':
    case 'testnet':
      return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org'
      };
    case 'betanet':
      return {
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org'
      };
    case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
        contractName: CONTRACT_NAME
      };
    case 'test':
    case 'ci':
      return {
        networkId: 'shared-test',
        nodeUrl: 'https://rpc.ci-testnet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near'
      };
    case 'ci-betanet':
      return {
        networkId: 'shared-test-staging',
        nodeUrl: 'https://rpc.ci-betanet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near'
      };
    default:
      throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`);
  }
}

module.exports = getConfig;

'''
'''--- src/fonts/OFL.txt ---
Copyright (c) 2016-2019 The Inter Project Authors (me@rsms.me)

This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at:
http://scripts.sil.org/OFL

-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide
development of collaborative font projects, to support the font creation
efforts of academic and linguistic communities, and to provide a free and
open framework in which fonts may be shared and improved in partnership
with others.

The OFL allows the licensed fonts to be used, studied, modified and
redistributed freely as long as they are not sold by themselves. The
fonts, including any derivative works, can be bundled, embedded, 
redistributed and/or sold with any software provided that any reserved
names are not used by derivative works. The fonts and derivatives,
however, cannot be released under any other type of license. The
requirement for fonts to remain under this license does not apply
to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright
Holder(s) under this license and clearly marked as such. This may
include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the
copyright statement(s).

"Original Version" refers to the collection of Font Software components as
distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting -- in part or in whole -- any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining
a copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components,
in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled,
redistributed and/or sold with any software, provided that each copy
contains the above copyright notice and this license. These can be
included either as stand-alone text files, human-readable headers or
in the appropriate machine-readable metadata fields within text or
binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font
Name(s) unless explicit written permission is granted by the corresponding
Copyright Holder. This restriction only applies to the primary font name as
presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
Software shall not be used to promote, endorse or advertise any
Modified Version, except to acknowledge the contribution(s) of the
Copyright Holder(s) and the Author(s) or with their explicit written
permission.

5) The Font Software, modified or unmodified, in part or in whole,
must be distributed entirely under this license, and must not be
distributed under any other license. The requirement for fonts to
remain under this license does not apply to any document created
using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.

'''
'''--- src/fonts/README.txt ---
Inter Variable Font
===================

This download contains Inter as both a variable font and static fonts.

Inter is a variable font with these axes:
  slnt
  wght

This means all the styles are contained in a single file:
  Inter-VariableFont_slnt,wght.ttf

If your app fully supports variable fonts, you can now pick intermediate styles
that aren’t available as static fonts. Not all apps support variable fonts, and
in those cases you can use the static font files for Inter:
  static/Inter-Thin.ttf
  static/Inter-ExtraLight.ttf
  static/Inter-Light.ttf
  static/Inter-Regular.ttf
  static/Inter-Medium.ttf
  static/Inter-SemiBold.ttf
  static/Inter-Bold.ttf
  static/Inter-ExtraBold.ttf
  static/Inter-Black.ttf

Get started
-----------

1. Install the font files you want to use

2. Use your app's font picker to view the font family and all the
available styles

Learn more about variable fonts
-------------------------------

  https://developers.google.com/web/fundamentals/design-and-ux/typography/variable-fonts
  https://variablefonts.typenetwork.com
  https://medium.com/variable-fonts

In desktop apps

  https://theblog.adobe.com/can-variable-fonts-illustrator-cc
  https://helpx.adobe.com/nz/photoshop/using/fonts.html#variable_fonts

Online

  https://developers.google.com/fonts/docs/getting_started
  https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Fonts/Variable_Fonts_Guide
  https://developer.microsoft.com/en-us/microsoft-edge/testdrive/demos/variable-fonts

Installing fonts

  MacOS: https://support.apple.com/en-us/HT201749
  Linux: https://www.google.com/search?q=how+to+install+a+font+on+gnu%2Blinux
  Windows: https://support.microsoft.com/en-us/help/314960/how-to-install-or-remove-a-font-in-windows

Android Apps

  https://developers.google.com/fonts/docs/android
  https://developer.android.com/guide/topics/ui/look-and-feel/downloadable-fonts

License
-------
Please read the full license text (OFL.txt) to understand the permissions,
restrictions and requirements for usage, redistribution, and modification.

You can use them freely in your products & projects - print or digital,
commercial or otherwise.

This isn't legal advice, please consider consulting a lawyer and see the full
license for all details.

'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <link rel="icon" href="./favicon.ico" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#000000" />
  <link rel="apple-touch-icon" href="./favicon.ico" />
<!--  <link rel="stylesheet" href="global.scss">-->
  <title>NEAR Crossword Puzzle</title>
  <meta property="og:title" content="NEAR Crossword Puzzle">
  <meta property="og:description" content="A learning opportunity with NEAR smart contracts and tools.">

</head>
<body>
<noscript>You need to enable JavaScript to run this app.</noscript>
<div id="root"></div>
<script src="./index.js"></script>
</body>
</html>

'''
'''--- src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom';
import * as nearAPI from 'near-api-js';
import App from './App';
import getConfig from './config.js';
import { viewMethodOnContract, mungeBlockchainCrossword } from './utils';

async function initCrossword() {
  const nearConfig = getConfig(process.env.NEAR_ENV || 'testnet');

  // create a keyStore for signing transactions using the user's key
  // which is located in the browser local storage after user logs in
  const keyStore = new nearAPI.keyStores.BrowserLocalStorageKeyStore();

  // Initializing connection to the NEAR testnet
  const near = await nearAPI.connect({ keyStore, ...nearConfig });

  // Initialize wallet connection
  const walletConnection = new nearAPI.WalletConnection(near);

  // Load in user's account data
  let currentUser;
  if (walletConnection.getAccountId()) {
    currentUser = walletConnection.getAccountId();
  }

  const chainData = await viewMethodOnContract(nearConfig, 'get_unsolved_puzzles', '{}');

  let data;
  let solutionHash;

  // There may not be any crossword puzzles to solve, check this.
  if (chainData.puzzles.length) {
    solutionHash = chainData.puzzles[0]['solution_hash'];
    data = mungeBlockchainCrossword(chainData.puzzles);
  } else {
    console.log("Oof, there's no crossword to play right now, zion.");
  }
  return { data, solutionHash, nearConfig, walletConnection, currentUser };
}

initCrossword()
  .then(({ data, solutionHash, nearConfig, walletConnection, currentUser }) => {
    ReactDOM.render(
      <App
        data={data}
        hash={solutionHash}
        nearConfig={nearConfig}
        walletConnection={walletConnection}
        currentUser={currentUser}
      />,
      document.getElementById('root'));
  });

'''
'''--- src/loader.js ---
import React from 'react'
import ExampleComponent from 'react-fullpage-custom-loader'

const defaultProps = {
  sentences: [
    'Transaction processing…',
  ],
  loaderType: 'fire', // a nice one
  loaderSize: 'big', // small, medium or big?
  color: '#f2f2f2', // your default color for the loader
  textStyles: { // Any CSS style!
    fontSize: 19,
    fontWeight: 'bold',
    height: '6em',
    color: '#f2f2f2'
  },
  wrapperBackgroundColor: 'linear-gradient(to bottom, #f2f2f2 0%, #111111 100%)', // any valid CSS background string works (gradients here!)
  counter: false, // We are going to show the counter below the text
  counterMax: 5, // Stop after 5 cycles
  counterDelay: 3000, // A cycle length in milliseconds
  counterChars: null, // if no chars are passed you get to see the counter number
  counterStyles: {
    color: 'white'
  }, // any text style to modify the counter
  fadeIn: true, // controlled on top level
  startFadeOut: false // controlled on top level
}

const SimpleDark = (props) => {
  return (
    <ExampleComponent
      {...defaultProps}
      {...props}
    />
  )
}

export default SimpleDark

'''
'''--- src/near-cli-command.js ---
const nearCLICommand = `
near call crossword.zion.testnet new_puzzle '{"solution_hash":"cbb4c3096c4bdf8ed58ea4c27edcbc38264bb7af4fa893e0ac2e5b13ff430923","answers":[{"num": 1,"start": {"x": 1,"y": 2},"direction": "Across","length": 10,"clue": "The company I work for is called ______ Technology Inc."},{"num": 2,"start": {"x": 5,"y": 1},"direction": "Down","length": 8,"clue": "One of our team favourite board games is ______ deal"},{"num": 3,"start": {"x": 4,"y": 4},"direction": "Across","length": 7,"clue": "Name of the most dramatic person in our team - hint=David"},{"num": 4,"start": {"x": 6,"y": 1},"direction": "Down","length": 4,"clue": "Name of the best web designer on earth"},{"num": 5,"start": {"x": 0,"y": 6},"direction": "Across","length": 8,"clue": "It is Irene fave Mandalorian character - one word, no hyphen"}, {"num": 6,"start": {"x": 10,"y": 6},"direction": "Down","length": 6,"clue": "The Bbox office is located by ______ Place"}, {"num": 7,"start": {"x": 4,"y": 8},"direction": "Across","length": 6,"clue": "What is the programming language primarily used by the data scientists in our team?"}]}' --accountId crossword.zion.testnet
`;
module.exports = nearCLICommand
'''
'''--- src/utils.js ---
// This function takes the input from the Rust smart contract
// and turns it into what the crossword library would like.
// Opportunity to enhance the library so this isn't necessary.
import * as nearAPI from 'near-api-js';
import bs58 from 'bs58';

// Our API could be improved here :)
// See: https://github.com/near/near-api-js/issues/612
async function viewMethodOnContract(nearConfig, method, params) {
  const paramBytes = Buffer.from(params, 'utf8');
  const base58Params = bs58.encode(paramBytes);

  const provider = new nearAPI.providers.JsonRpcProvider(nearConfig.nodeUrl);
  const rawResult = await provider.query(`call/${nearConfig.contractName}/${method}`, base58Params);
  return JSON.parse(rawResult.result.map((x) => String.fromCharCode(x)).join(''));
}

function parseSolutionSeedPhrase(data, gridData) {
  // JavaScript determining what the highest clue number is
  // Example: 10 if there are ten clues, some which have both across and down clues
  let totalClues = Object.keys(data.across).concat(Object.keys(data.down))
    .map(n => parseInt(n))
    .reduce((n, m) => Math.max(n, m));

  let seedPhrase = [];
  // Assume that crossword starts at 1 and goes to totalClues
  for (let i = 1; i <= totalClues; i++) {
    let word = '';
    // If a number has both across and down clues, do across first.
    let iString = i.toString(); // not strictly necessary
    if (data.across.hasOwnProperty(iString)) {
      const answerLength = data.across[i].answer.length;
      for (let j = 0; j < answerLength; j++) {
        word += gridData[data['across'][i].row][data['across'][i].col + j].guess;
      }
      seedPhrase.push(word);
    }
    word = ''; // Clear for items where there's both across and down
    if (data.down.hasOwnProperty(iString)) {
      const answerLength = data.down[i].answer.length;
      for (let j = 0; j < answerLength; j++) {
        word += gridData[data['down'][i].row + j][data['down'][i].col].guess;
      }
      seedPhrase.push(word);
    }
  }
  const finalSeedPhrase = seedPhrase.map(w => w.toLowerCase()).join(' ');
  console.log(`Crossword solution as seed phrase: %c${finalSeedPhrase}`, "color: #00C1DE;");
  return finalSeedPhrase;
}

/* Example of expected data for crossword library
  export const data = {
    across: {
      1: {
        clue: 'one plus one',
        answer: 'TWO',
        row: 0,
        col: 0,
      },
    },
    down: {
      2: {
        clue: 'three minus two',
        answer: 'ONE',
        row: 0,
        col: 2,
      },
    },
  };
*/

function mungeBlockchainCrossword(chainData) {
  const data = {
    across: {},
    down: {}
  };
  // Assume there is only one crossword puzzle, get the first
  const crosswordClues = chainData[0].answer;

  crosswordClues.forEach((clue) => {
    // In the smart contract it's stored as "Across" but the
    // React library uses "across"
    const direction = clue.direction.toLowerCase();
    data[direction][clue.num] = {};
    data[direction][clue.num]['clue'] = clue.clue;
    data[direction][clue.num]['answer'] = '?'.repeat(clue.length);
    data[direction][clue.num]['row'] = clue.start.y;
    data[direction][clue.num]['col'] = clue.start.x;
  });
  return data;
}

module.exports = {
  viewMethodOnContract,
  parseSolutionSeedPhrase,
  mungeBlockchainCrossword
};

'''
'''--- testnet-deploy.sh ---
#!/bin/bash

./build.sh

export NEAR_ACCT=xword.demo.testnet
export PARENT_ACCT=demo.testnet
near delete $NEAR_ACCT $PARENT_ACCT
near create-account $NEAR_ACCT --masterAccount $PARENT_ACCT
near deploy $NEAR_ACCT --wasmFile res/crossword_tutorial_chapter_2.wasm --initFunction new --initArgs '{"owner_id": "'$NEAR_ACCT'"}'

# We're able to determine the public key by visiting a site like:
# https://www.wolframalpha.com/input/?i=sha256+%22paras+rainbowbridge+mintbase+yoctonear+cli%22

near call $NEAR_ACCT new_puzzle 
'{"solution_hash":"cbb4c3096c4bdf8ed58ea4c27edcbc38264bb7af4fa893e0ac2e5b13ff430923","answers":[{"num": 1,"start": {"x": 1,"y": 2},"direction": "Across","length": 10,"clue": "The company I work for is called ______ Technology Inc."},{"num": 2,"start": {"x": 5,"y": 1},"direction": "Down","length": 8,"clue": "One of our team favourite board games is ______ deal"},{"num": 3,"start": {"x": 4,"y": 4},"direction": "Across","length": 7,"clue": "Name of the most dramatic person in our team - hint=David"},{"num": 4,"start": {"x": 6,"y": 1},"direction": "Down","length": 4,"clue": "Name of the best web designer on earth"},{"num": 5,"start": {"x": 0,"y": 6},"direction": "Across","length": 8,"clue": "It is Irene fave Mandalorian character - one word, no hyphen"}, {"num": 6,"start": {"x": 10,"y": 6},"direction": "Down","length": 6,"clue": "The Bbox office is located by ______ Place"}, {"num": 7,"start": {"x": 4,"y": 8},"direction": "Across","length": 6,"clue": "What is the programming language primarily used by the data scientists in our team?"}]}'
 --accountId $NEAR_ACCT

'''