*GitHub Repository "galactic3/generic_factory"*

'''--- Cargo.toml ---
[package]
name = "generic_factory"
version = "0.0.1"
authors = ["Alex Aunter <lxaunter@gmail.com"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-sys = "0.2.0"

[dev-dependencies]
near-sdk-sim = "3.2.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
# Generic factory contract

Generic contract factory that doesn't require factory recompilation for setting
the contract code. Code is loaded via custom method after the factory contract
is deployed. The code can only be loaded once, and only by the
current_account_id. Factory creates accounts without access keys so it's
impossible to upgrade the contract, unless this functionality is build into the
contract code.

# Usage example:

Deploy and set code:

Example:

```
./deploy.sh hello_generic_factory.testnet res/hello_contract.wasm
ACC_ROOT=hello_generic_factory.testnet
WASM_FILE=res/hello_contract.wasm
...
TxHash: BvwgFb6VofmwXr6P7ieTJQDJVzyY3TYHpx3Z6Vu6rCXk
```
See in explorer: https://explorer.testnet.near.org/transactions/BvwgFb6VofmwXr6P7ieTJQDJVzyY3TYHpx3Z6Vu6rCXk

After that, any account_id can call create subaccount with the provided code.

```
near call --accountId generic_factory_user.testnet hello_generic_factory.testnet create '{"name":"subaccount_without_args"}' --deposit 3.0
Scheduling a call: hello_generic_factory.testnet.create({"name":"subaccount_without_args"}) with attached 3 NEAR
Doing account.functionCall()
Transaction Id CakTui7iWspjF6iorvNbmTRf9Yb7d3SX8H4qCL3u2PnL
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/CakTui7iWspjF6iorvNbmTRf9Yb7d3SX8H4qCL3u2PnL
''
```

Optionally the user can provide init arguments to the contract

```
near call --accountId generic_factory_user.testnet hello_generic_factory.testnet create '{"name":"subaccount_with_args","init_function":"new","init_args":"{\"subject\":\"world\"}"}' --deposit 3.0
Scheduling a call: hello_generic_factory.testnet.create({"name":"subaccount_with_args","init_function":"new","init_args":"{\"subject\":\"world\"}"}) with attached 3 NEAR
Doing account.functionCall()
Transaction Id FuEBMVkNvN8NhJw9Hi54R3cGX4rP4TLmzm88ofrBZbJk
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/FuEBMVkNvN8NhJw9Hi54R3cGX4rP4TLmzm88ofrBZbJk
''
```
See in explorer: https://explorer.testnet.near.org/transactions/FuEBMVkNvN8NhJw9Hi54R3cGX4rP4TLmzm88ofrBZbJk

NOTE: currently the contract does NOT return the deposit in case of failure.
This should be fixed before the contract is ready to use.

'''
'''--- build.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)"

package_name=$(cat Cargo.toml | sed -ne 's/^name\s\+=\s\+"\(.*\)"$/\1/p' | sed -e 's/-/_/g')
RUSTFLAGS="-C link-arg=-s --remap-path-prefix ${CARGO_HOME:-$HOME/.cargo}=/usr/local/cargo" cargo build --target wasm32-unknown-unknown --release

res_dir=./res
mkdir -p $res_dir
cp target/wasm32-unknown-unknown/release/${package_name}.wasm $res_dir/${package_name}.wasm
touch -r target/wasm32-unknown-unknown/release/${package_name}.wasm $res_dir/${package_name}.wasm

'''
'''--- deploy.sh ---
#!/bin/zsh

set -e

if [[ "$#" -ne 2 ]]; then
  echo "usage: $0 <account> <wasm_file>"
  exit 1
fi

ACC_ROOT=$1
WASM_FILE=$2
echo "ACC_ROOT=$ACC_ROOT"
echo "WASM_FILE=$WASM_FILE"

near deploy -f --accountId $ACC_ROOT --wasmFile "$(dirname $0)/res/generic_factory.wasm"

script=$(cat <<EOF
const main = async () => {
  const accountId = "$ACC_ROOT";
  const contractName = accountId;
  const fs = require('fs');
  const account = await near.account(accountId);
  const code = fs.readFileSync("$WASM_FILE");

  const result = await account.signAndSendTransaction({
    receiverId: contractName,
    actions: [nearAPI.transactions.functionCall("set_code", code, 300_000_000_000_000, "0")]
  });
  console.log(result);
  console.log(JSON.parse(atob(result.receipts_outcome[0].outcome.status.SuccessValue)));
  console.log('TxHash: ' + result.transaction.hash);
};

main();
EOF
)

echo "$script" | near repl

'''
'''--- hello_contract/Cargo.toml ---
[package]
name = "hello_contract"
version = "0.0.1"
authors = ["Alex Aunter <lxaunter@gmail.com"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- hello_contract/build.sh ---
#!/bin/bash
set -e

cd "$(dirname $0)"

package_name=$(cat Cargo.toml | sed -ne 's/^name\s\+=\s\+"\(.*\)"$/\1/p' | sed -e 's/-/_/g')
RUSTFLAGS="-C link-arg=-s --remap-path-prefix ${CARGO_HOME:-$HOME/.cargo}=/usr/local/cargo" cargo build --target wasm32-unknown-unknown --release

res_dir=../res
mkdir -p $res_dir
cp target/wasm32-unknown-unknown/release/${package_name}.wasm $res_dir/${package_name}.wasm
touch -r target/wasm32-unknown-unknown/release/${package_name}.wasm $res_dir/${package_name}.wasm

'''
'''--- hello_contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{near_bindgen};

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct HelloContract {
    subject: String
}

#[near_bindgen]
impl HelloContract {
    #[init]
    pub fn new(subject: String) -> Self {
        Self { subject }
    }

    pub fn hello(&self) -> String {
        format!("Hello, {}!", &self.subject)
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;

    use std::convert::TryInto;

    use near_sdk::test_utils::{VMContextBuilder};
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    fn get_context() -> VMContext {
        VMContextBuilder::new()
            .signer_account_id("alice.near".try_into().unwrap())
            .is_view(true)
            .build()
    }

    #[test]
    fn test_hello() {
        let context = get_context();
        testing_env!(context);
        let contract = HelloContract::new("world".into());
        let res = contract.hello();
        assert_eq!(res, "Hello, world!");
    }
}

'''
'''--- src/lib.rs ---
use std::convert::TryInto;
use std::str;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{Base58CryptoHash, ValidAccountId, WrappedBalance};
use near_sdk::{
    env, ext_contract, is_promise_success, log, near_bindgen, AccountId, Balance, Gas, Promise,
};

const AFTER_CREATE_GAS: Gas = 10 * 10u64.pow(12);
const NO_DEPOSIT: Balance = 0;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct FactoryContract {}

#[ext_contract(ext_self)]
pub trait ExtSelf {
    fn after_create(&mut self, account_id: AccountId, amount: WrappedBalance);
}

unsafe fn read_register_as_string(register_id: u64) -> String {
    let len = near_sys::register_len(register_id);
    assert_ne!(len, u64::MAX, "register is not used");
    let res = vec![0u8; len as usize];
    near_sys::read_register(register_id, res.as_ptr() as _);
    str::from_utf8(&res).unwrap().to_string()
}

#[no_mangle]
pub extern "C" fn set_code() {
    env::setup_panic_hook();

    unsafe {
        near_sys::current_account_id(0);
        let current_account_id: String = read_register_as_string(0);
        near_sys::predecessor_account_id(0);
        let predecessor_account_id: String = read_register_as_string(0);
        // FIXME: Using env::current_account_id(), env::predecessor_account_id() fails with
        // WebAssembly trap: An `unreachable` opcode was executed.
        assert_eq!(
            current_account_id, predecessor_account_id,
            "expected current_account_id as caller",
        );

        // set key
        let key = "code".as_bytes();
        near_sys::write_register(1, key.len() as u64, key.as_ptr() as u64);

        assert_eq!(
            near_sys::storage_has_key(u64::MAX as _, 1 as _),
            0,
            "set_code has already been called",
        );

        // save code to the internal register
        near_sys::input(0);
        // save code to the state
        near_sys::storage_write(u64::MAX as _, 1 as _, u64::MAX as _, 0 as _, 2);
        // return true
        let result = near_sdk::serde_json::to_string(&true).unwrap().into_bytes();
        near_sys::value_return(result.len() as _, result.as_ptr() as _);
    }
}

#[near_bindgen]
impl FactoryContract {
    pub fn get_code_hash(&self) -> Option<Base58CryptoHash> {
        env::storage_read(&"code".as_bytes()).map(|code| {
            let result: [u8; 32] = env::sha256(&code).try_into().unwrap();
            result.into()
        })
    }

    #[payable]
    pub fn create(
        &mut self,
        name: String,
        init_function: Option<String>,
        init_args: Option<String>,
    ) -> Promise {
        let account_id: ValidAccountId = format!("{}.{}", name, env::current_account_id())
            .try_into()
            .unwrap();
        let code =
            env::storage_read(&"code".as_bytes()).expect("code not set, call set_code first");
        let promise = Promise::new(account_id.into())
            .create_account()
            .deploy_contract(code)
            .transfer(env::attached_deposit());

        assert!(env::prepaid_gas() >= AFTER_CREATE_GAS, "not enough gas");
        let promise = if init_function.is_some() && init_args.is_some() {
            promise.function_call(
                init_function.unwrap().into_bytes(),
                init_args.unwrap().into_bytes(),
                NO_DEPOSIT,
                // chosen empirically as the best value
                (env::prepaid_gas() - AFTER_CREATE_GAS) / 2,
            )
        } else {
            if init_function.is_some() || init_args.is_some() {
                panic!("expected both init_function and init_args")
            }
            promise
        };

        promise.then(ext_self::after_create(
            env::predecessor_account_id(),
            env::attached_deposit().into(),
            &env::current_account_id(),
            NO_DEPOSIT,
            AFTER_CREATE_GAS,
        ))
    }

    #[private]
    pub fn after_create(account_id: AccountId, amount: WrappedBalance) -> bool {
        let promise_success = is_promise_success();
        if promise_success {
            log!("Subcontract successfully created!");
            true
        } else {
            log!(
                "Subcontract creation failed, refunding {} to {}!",
                amount.0,
                account_id,
            );
            Promise::new(account_id).transfer(amount.0);
            false
        }
    }
}

'''
'''--- tests/main.rs ---
use near_sdk::json_types::Base58CryptoHash;
use near_sdk::serde_json::json;
use near_sdk::{Balance, Gas};
use near_sdk_sim::{init_simulator, to_yocto};

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    FACTORY_BYTES => "res/generic_factory.wasm",
    HELLO_BYTES => "res/hello_contract.wasm",
}

const SET_CODE_GAS: Gas = 30 * 10u64.pow(12);
const CREATE_GAS: Gas = 60 * 10u64.pow(12);
const NO_DEPOSIT: Balance = 0;

#[test]
fn test_deploy_set_code_create_call() {
    let root = init_simulator(None);
    // deploy works
    let factory = root.deploy(&FACTORY_BYTES, "factory".parse().unwrap(), to_yocto("10"));
    let user = root.create_user("user".into(), to_yocto("10"));

    // code not set, code_hash is none
    let res = root.view(factory.account_id(), "get_code_hash", &vec![]);
    assert!(res.is_ok());
    let res: Option<Base58CryptoHash> = res.unwrap_json();
    assert!(res.is_none());

    // create should fail before set_code
    let res = user.call(
        factory.account_id(),
        "create",
        &json!({
            "name": "subaccount",
            "init_function": "new",
            "init_args": json!({ "subject": "world" }).to_string(),
        })
        .to_string()
        .into_bytes(),
        CREATE_GAS,
        to_yocto("5"),
    );
    assert!(!res.is_ok());
    assert!(format!("{:?}", res.status()).contains("code not set, call set_code first"));

    // set_code by not current_account_id fails
    let res = user.call(
        factory.account_id(),
        "set_code",
        &HELLO_BYTES,
        SET_CODE_GAS,
        NO_DEPOSIT,
    );
    assert!(!res.is_ok());

    // set_code by current_account_id succeeds
    let res = factory.call(
        factory.account_id(),
        "set_code",
        &HELLO_BYTES,
        SET_CODE_GAS,
        NO_DEPOSIT,
    );
    assert!(res.is_ok());
    let res: bool = res.unwrap_json();
    assert_eq!(res, true, "expected set_code to return true");

    // set_code by current_account_id fails second time
    let res = factory.call(
        factory.account_id(),
        "set_code",
        &HELLO_BYTES,
        SET_CODE_GAS,
        NO_DEPOSIT,
    );
    assert!(!res.is_ok());

    // code not set, code_hash is none
    let res = root.view(factory.account_id(), "get_code_hash", &vec![]);
    assert!(res.is_ok());
    let res: Option<Base58CryptoHash> = res.unwrap_json();
    assert!(res.is_some());

    // create by random user works
    let factory_balance_before = factory.account().unwrap().amount;
    let res = user.call(
        factory.account_id(),
        "create",
        &json!({
            "name": "subaccount",
            "init_function": "new",
            "init_args": json!({ "subject": "world" }).to_string(),
        })
        .to_string()
        .into_bytes(),
        CREATE_GAS,
        to_yocto("5"),
    );
    assert!(res.is_ok());
    let res: bool = res.unwrap_json();
    assert_eq!(res, true, "expected create to return true");
    let subaccount = root.borrow_runtime().view_account("subaccount.factory");
    assert!(
        subaccount.unwrap().amount >= to_yocto("5"),
        "expected all deposit to be sent to subaccount"
    );

    let factory_balance_after = factory.account().unwrap().amount;
    assert!(
        factory_balance_after >= factory_balance_before,
        "expected factory balance to not decrease"
    );

    // creating again for the same account name should fail and return the money
    let factory_balance_before = factory.account().unwrap().amount;
    let amount_before = user.account().unwrap().amount;
    let res = user.call(
        factory.account_id(),
        "create",
        &json!({
            "name": "subaccount",
            "init_function": "new",
            "init_args": json!({ "subject": "world" }).to_string(),
        })
        .to_string()
        .into_bytes(),
        CREATE_GAS,
        to_yocto("3"),
    );
    assert!(res.is_ok());
    let res: bool = res.unwrap_json();
    assert_eq!(res, false, "expected create to return false");
    let amount_after = user.account().unwrap().amount;
    assert!(
        amount_after + to_yocto("0.01") >= amount_before,
        "expected attached deposit to be returned"
    );
    let factory_balance_after = factory.account().unwrap().amount;
    assert!(
        factory_balance_after >= factory_balance_before,
        "expected factory balance to not decrease"
    );

    // create should revert if init method fails
    let factory_balance_before = factory.account().unwrap().amount;
    let amount_before = user.account().unwrap().amount;
    let res = user.call(
        factory.account_id(),
        "create",
        &json!({
            "name": "subaccount_invalid_arg",
            "init_function": "new",
            "init_args": json!({ "not_the_expected_arg": "world" }).to_string(),
        })
        .to_string()
        .into_bytes(),
        CREATE_GAS,
        to_yocto("3"),
    );
    assert!(res.is_ok());
    let res: bool = res.unwrap_json();
    assert_eq!(res, false, "expected create to return false");
    let amount_after = user.account().unwrap().amount;
    assert!(
        amount_after + to_yocto("0.01") >= amount_before,
        "expected attached deposit to be returned"
    );
    // check that new account is indeed not created
    let subaccount = root
        .borrow_runtime()
        .view_account("subaccount_invalid_arg.factory");
    assert!(
        subaccount.is_none(),
        "expected subaccount to not be created"
    );
    let factory_balance_after = factory.account().unwrap().amount;
    assert!(
        factory_balance_after >= factory_balance_before,
        "expected factory balance to not decrease"
    );

    // init method was called with the correct args
    let res = root.view("subaccount.factory".into(), "hello", &vec![]);
    assert!(res.is_ok());
    let res: String = res.unwrap_json();
    assert_eq!(res, "Hello, world!");

    // create by random user without init params
    let res = user.call(
        factory.account_id(),
        "create",
        &json!({
            "name": "subaccount_without_args",
        })
        .to_string()
        .into_bytes(),
        CREATE_GAS,
        to_yocto("3"),
    );
    assert!(res.is_ok());

    // init method was not called, subject is empty string
    let res = root.view("subaccount_without_args.factory".into(), "hello", &vec![]);
    assert!(res.is_ok());
    let res: String = res.unwrap_json();
    assert_eq!(res, "Hello, !");
}

// - [DONE] check that create fails before set_code
// - [DONE] check that owner can set_code
// - [DONE] check that non owner cannot set_code
// - [DONE] check that create works after set_code
// - [DONE] check that anyone can create
// - [DONE] check that create calls init with correct attributes
// - [DONE] check that set_code cannot be called again
// - [DONE] check that get_code_hash works
// - [DONE] check that create forwards all deposited amount to the subaccount
// - [DONE] check that failed create does not decrease factory's balance
// - [DONE] check that successful create does not decrease factory's balance
// - [DONE] check that failed create does not decrease caller's balance significantly

'''