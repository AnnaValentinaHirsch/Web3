*GitHub Repository "nel349/NEARCON-2022"*

'''--- .eslintrc.js ---

module.exports = {
  env: {
    browser: true,
    es2021: true,
  },
  extends: [
    'plugin:react/recommended',
    // 'airbnb-base',
  ],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaFeatures: {
      jsx: true,
      tsx: true,
    },
    ecmaVersion: 'latest',
    sourceType: 'module',
  },
  plugins: [
    'react',
    '@typescript-eslint',
  ],
  rules: {
    'no-tabs': 0,
    // 'react/jsx-filename-extension': [2, { extensions: ['.js', '.jsx', '.ts', '.tsx'] }],
  },
  settings: {
    'import/resolver': {
      node: {
        extensions: ['.js', '.jsx', '.ts', '.tsx'],
        moduleDirectory: ['node_modules', 'src/'],
      },
    },
  },
};

'''
'''--- .expo-shared/assets.json ---
{
  "e997a5256149a4b76e6bfd6cbf519c5e5a0f1d278a3d8fa1253022b03c90473b": true,
  "af683c96e0ffd2cf81287651c9433fa44debc1220ca7cb431fe482747f34a505": true,
  "12bb71342c6255bbf50437ec8f4441c083f47cdb74bd89160c15e4f43e52a1cb": true,
  "40b842e832070c58deac6aa9e08fa459302ee3f9da492c7e77d93d2fbf4a56fd": true
}

'''
'''--- NEAR/lensWebViewSupport/.github/workflows/tests.yml ---
name: Tests
on: push
jobs:
  workflows:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: "16"
      - name: Install modules
        run: yarn
      - name: Run tests
        run: yarn test
'''
'''--- NEAR/lensWebViewSupport/.gitpod.yml ---
image:
  file: .gitpod.Dockerfile

tasks:
  - init: echo "welcome"
    command: npm i && npm run deploy && npm run start

ports:
  - port: 1234
    onOpen: open-browser

'''
'''--- NEAR/lensWebViewSupport/README.md ---
# Donation ðŸ’¸ 
[![](https://img.shields.io/badge/â‹ˆ%20Examples-Basics-green)](https://docs.near.org/tutorials/welcome)
[![](https://img.shields.io/badge/Gitpod-Ready-orange)](https://gitpod.io/#/https://github.com/near-examples/donation-js)
[![](https://img.shields.io/badge/Contract-js-yellow)](https://docs.near.org/develop/contracts/anatomy)
[![](https://img.shields.io/badge/Frontend-JS-yellow)](https://docs.near.org/develop/integrate/frontend)
[![](https://img.shields.io/badge/Testing-passing-green)](https://docs.near.org/develop/integrate/frontend)

Our Donation example enables to forward money to an account while keeping track of it. It is one of the simplest examples on making a contract receive and send money.

![](https://docs.near.org/assets/images/donation-7cf65e5e131274fd1ae9aa34bc465bb8.png)

# What This Example Shows

1. How to receive and transfer $NEAR on a contract.
2. How to divide a project into multiple modules.
3. How to handle the storage costs.
4. How to handle transaction results.
5. How to use a `Map`.

<br />

# Quickstart

Clone this repository locally or [**open it in gitpod**](https://gitpod.io/#/github.com/near-examples/donation-js). Then follow these steps:

### 1. Install Dependencies
```bash
npm install
```

### 2. Test the Contract
Deploy your contract in a sandbox and simulate interactions from users.

```bash
npm test
```

### 3. Deploy the Contract
Build the contract and deploy it in a testnet account
```bash
npm run deploy
```

### 4. Start the Frontend
Start the web application to interact with your smart contract 
```bash
npm start
```

---

# Learn More
1. Learn more about the contract through its [README](./contract/README.md).
2. Check [**our documentation**](https://docs.near.org/develop/welcome).
'''
'''--- NEAR/lensWebViewSupport/contract/README.md ---
# Donation Contract

The smart contract exposes methods to handle donating $NEAR to a `beneficiary`.

```ts
@call
donate() {
  // Get who is calling the method and how much $NEAR they attached
  let donor = near.predecessorAccountId(); 
  let donationAmount: bigint = near.attachedDeposit() as bigint;

  let donatedSoFar = this.donations.get(donor) === null? BigInt(0) : BigInt(this.donations.get(donor) as string)
  let toTransfer = donationAmount;

  // This is the user's first donation, lets register it, which increases storage
  if(donatedSoFar == BigInt(0)) {
    assert(donationAmount > STORAGE_COST, `Attach at least ${STORAGE_COST} yoctoNEAR`);

    // Subtract the storage cost to the amount to transfer
    toTransfer -= STORAGE_COST
  }

  // Persist in storage the amount donated so far
  donatedSoFar += donationAmount
  this.donations.set(donor, donatedSoFar.toString())

  // Send the money to the beneficiary
  const promise = near.promiseBatchCreate(this.beneficiary)
  near.promiseBatchActionTransfer(promise, toTransfer)

  // Return the total amount donated so far
  return donatedSoFar.toString()
}
```

<br />

# Quickstart

1. Make sure you have installed [node.js](https://nodejs.org/en/download/package-manager/) >= 16.
2. Install the [`NEAR CLI`](https://github.com/near/near-cli#setup)

<br />

## 1. Build and Deploy the Contract
You can automatically compile and deploy the contract in the NEAR testnet by running:

```bash
npm run deploy
```

Once finished, check the `neardev/dev-account` file to find the address in which the contract was deployed:

```bash
cat ./neardev/dev-account
# e.g. dev-1659899566943-21539992274727
```

The contract will be automatically initialized with a default `beneficiary`.

To initialize the contract yourself do:

```bash
# Use near-cli to initialize contract (optional)
near call <dev-account> init '{"beneficiary":"<account>"}' --accountId <dev-account>
```

<br />

## 2. Get Beneficiary
`beneficiary` is a read-only method (`view` method) that returns the beneficiary of the donations.

`View` methods can be called for **free** by anyone, even people **without a NEAR account**!

```bash
near view <dev-account> beneficiary
```

<br />

## 3. Get Number of Donations

`donate` forwards any attached money to the `beneficiary` while keeping track of it.

`donate` is a payable method for which can only be invoked using a NEAR account. The account needs to attach money and pay GAS for the transaction.

```bash
# Use near-cli to donate 1 NEAR
near call <dev-account> donate --amount 1 --accountId <account>
```

**Tip:** If you would like to `donate` using your own account, first login into NEAR using:

```bash
# Use near-cli to login your NEAR account
near login
```

and then use the logged account to sign the transaction: `--accountId <your-account>`.
'''
'''--- NEAR/lensWebViewSupport/contract/babel.config.json ---
{
  "plugins": [
    "near-sdk-js/lib/build-tools/near-bindgen-exporter",
    ["@babel/plugin-proposal-decorators", {"version": "legacy"}]
  ],
  "presets": ["@babel/preset-typescript"]
}
'''
'''--- NEAR/lensWebViewSupport/contract/build.sh ---
#!/bin/sh

echo ">> Building contract"

near-sdk-js build src/contract.ts build/contract.wasm
'''
'''--- NEAR/lensWebViewSupport/contract/deploy.sh ---
#!/bin/sh

# build the contract
npm run build

# deploy the contract
near dev-deploy --wasmFile build/contract.wasm
'''
'''--- NEAR/lensWebViewSupport/contract/package.json ---
{
  "name": "contract",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "type": "module",
  "scripts": {
    "build": "./build.sh",
    "deploy": "./deploy.sh",
    "test": "echo no unit testing"
  },
  "dependencies": {
    "near-cli": "^3.4.0",
    "near-sdk-js": "0.5.0"
  },
  "devDependencies": {
    "typescript": "^4.7.4"
  }
}

'''
'''--- NEAR/lensWebViewSupport/contract/src/contract.ts ---
import { NearBindgen, near, call, view, initialize, UnorderedMap } from 'near-sdk-js'
import { assert } from './utils'
import { Donation, STORAGE_COST } from './model'

@NearBindgen({})
class DonationContract {
  beneficiary: string = "v1.faucet.nonofficial.testnet";
  donations: UnorderedMap = new UnorderedMap('map-uid-1');

  @initialize({})
  init({ beneficiary }:{beneficiary: string}) {
    this.beneficiary = beneficiary
  }

  @call({payableFunction: true})
  donate() {
    // Get who is calling the method and how much $NEAR they attached
    let donor = near.predecessorAccountId(); 
    let donationAmount: bigint = near.attachedDeposit() as bigint;

    let donatedSoFar = this.donations.get(donor) === null? BigInt(0) : BigInt(this.donations.get(donor) as string)
    let toTransfer = donationAmount;
 
    // This is the user's first donation, lets register it, which increases storage
    if(donatedSoFar == BigInt(0)) {
      assert(donationAmount > STORAGE_COST, `Attach at least ${STORAGE_COST} yoctoNEAR`);

      // Subtract the storage cost to the amount to transfer
      toTransfer -= STORAGE_COST
    }

    // Persist in storage the amount donated so far
    donatedSoFar += donationAmount
    this.donations.set(donor, donatedSoFar.toString())
    near.log(`Thank you ${donor} for donating ${donationAmount}! You donated a total of ${donatedSoFar}`);

    // Send the money to the beneficiary
    const promise = near.promiseBatchCreate(this.beneficiary)
    near.promiseBatchActionTransfer(promise, toTransfer)

    // Return the total amount donated so far
    return donatedSoFar.toString()
  }

  @call({privateFunction: true})
  change_beneficiary(beneficiary) {
    this.beneficiary = beneficiary;
  }

  @view({})
  get_beneficiary(){ return this.beneficiary }

  @view({})
  get_targetPayee(){ return 'target Payee!! whooho' }

  @view({})
  number_of_donors() { return this.donations.length }

  @view({})
  get_donations({from_index = 0, limit = 50}: {from_index:number, limit:number}): Donation[] {
    let ret:Donation[] = []
    let end = Math.min(limit, this.donations.length)
    for(let i=from_index; i<end; i++){
      const account_id: string = this.donations.keys.get(i) as string
      const donation: Donation = this.get_donation_for_account({account_id})
      ret.push(donation)
    }
    return ret
  }

  @view({})
  get_donation_for_account({account_id}:{account_id:string}): Donation{
    return new Donation({
      account_id,
      total_amount: this.donations.get(account_id) as string
    })
  }
}
'''
'''--- NEAR/lensWebViewSupport/contract/src/model.ts ---
export const STORAGE_COST: bigint = BigInt("1000000000000000000000")

export class Donation {
  account_id: string;
  total_amount: string;

  constructor({account_id, total_amount}:{account_id: string, total_amount: string}) {
    this.account_id = account_id;
    this.total_amount = total_amount;
  }
}
'''
'''--- NEAR/lensWebViewSupport/contract/src/utils.ts ---
export function assert(statement, message) {
  if (!statement) {
    throw Error(`Assertion failed: ${message}`)
  }
}
'''
'''--- NEAR/lensWebViewSupport/contract/tsconfig.json ---
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "target": "es5",
    "noEmit": true
  },
  "exclude": [
    "node_modules"
  ],
}
'''
'''--- NEAR/lensWebViewSupport/frontend/assets/global.css ---
* {
  box-sizing: border-box;
}

html {
  --bg: #e7f3ff;
  --fg: #1e1e1e;
  --gray: #555;
  --light-gray: #ccc;
  --shadow: #e6e6e6;
  --success: rgb(90, 206, 132);
  --primary: #FF585D;
  --secondary: #0072CE;

  color: var(--fg);
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  line-height: 1.3;
}

body {
  margin: 0;
  background-color: var(--bg);
}

.donation-box {
  max-width: 24em;
  box-shadow: #bac4cd 0px 0px 18px;
  border-radius: 8px;
}

.column{
  width: 50%;
  float:left;
}

main {
  padding: 2em;
  text-align: justify;
  background-color: #f2f2f2;
  z-index: 1;
  border-radius: 8px;
}

.donation-box-head {
  text-align: center;
  background-color: #fff;
  margin: 0;
  border-radius: 8px 8px 0 0;
  padding: 1em 0em 2em 0em;
}

.logo {
  background-image: url(logo-black.svg);
  background-position: center 0em;
  background-repeat: no-repeat;
  position: relative;
  top: -2em;
  transform: translateX(-50%);
  background-color: #fff;
  padding: 15px 25px;
  height: 40px;
  border-radius: 50px;
  width: 50px;
  box-shadow: #bbb 0px 2px 5px;
}

a,
.link {
  color: var(--primary);
  text-decoration: none;
}
a:hover,
a:focus,
.link:hover,
.link:focus {
  text-decoration: underline;
}
a:active,
.link:active {
  color: var(--secondary);
}

.btn-outline-primary{
  width: 100%;
}

button, input {
  font: inherit;
  outline: none;
}

button.link {
  background: none;
  border: none;
  box-shadow: none;
  display: inline;
}

fieldset {
  border: none;
  padding: 2em 0;
}

form {
  margin: 0.2em -0.5em -1em -0.5em;
}

aside {
  animation: notify ease-in-out 10s;
  background-color: var(--shadow);
  border-radius: 5px;
  bottom: 0;
  font-size: 0.8em;
  margin: 1em;
  padding: 1em;
  position: fixed;
  transform: translateY(10em);
  right: 0;
}
aside footer {
  display: flex;
  font-size: 0.9em;
  justify-content: space-between;
  margin-top: 0.5em;
}
aside footer *:first-child {
  color: var(--success);
}
aside footer *:last-child {
  color: var(--gray);
}
@keyframes notify {
  0% { transform: translateY(10em) }
  5% { transform: translateY(0) }
  95% { transform: translateY(0) }
  100% { transform: translateY(10em) }
}

'''
'''--- NEAR/lensWebViewSupport/frontend/assets/logo-black.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#24272a"/><stop offset=".42" stop-color="#24272a" stop-opacity="0"/><stop offset=".59" stop-color="#24272a" stop-opacity="0"/><stop offset=".81" stop-color="#24272a"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#24272a"/></svg>
'''
'''--- NEAR/lensWebViewSupport/frontend/assets/logo-white.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#fff"/><stop offset=".42" stop-color="#fff" stop-opacity="0"/><stop offset=".59" stop-color="#fff" stop-opacity="0"/><stop offset=".81" stop-color="#fff"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#fff"/></svg>
'''
'''--- NEAR/lensWebViewSupport/frontend/index.js ---
import 'regenerator-runtime/runtime'
import { Contract } from './near-interface';
import { Wallet } from './near-wallet'

// When creating the wallet you can choose to create an access key, so the user
// can skip signing non-payable methods when interacting with the contract
const wallet = new Wallet({ createAccessKeyFor: process.env.CONTRACT_NAME })

// Abstract the logic of interacting with the contract to simplify your project
const contract = new Contract({ contractId: process.env.CONTRACT_NAME, walletToUse: wallet });

// Setup on page load
window.onload = async () => {
  const isSignedIn = await wallet.startUp();

  if (isSignedIn){
    signedInFlow()
  }else{
    signedOutFlow()
  }

  setTimeout(function () {
    window.ReactNativeWebView.postMessage(JSON.stringify(wallet.wallet))
    // alert('accounts: ' + wallet.getAccounts);
    // alert('wallet: ' + JSON.stringify(wallet.wallet));
    
  }, 2000)

  fetchBeneficiary()
  getAndShowDonations()

  try {
    const payee = await contract.getPayee()
    console.log('my payee: ' + payee)
  } catch (e) {
    alert(
      'Something went wrong! ' +
      'Maybe you need to sign out and back in? ' +
      'Check your browser console for more info.'
    )
    throw e
  }
}

// On submit, get the greeting and send it to the contract
document.querySelector('form').onsubmit = async (event) => {
  event.preventDefault()

  // get elements from the form using their id attribute
  const { fieldset, donation } = event.target.elements

  // disable the form while the value gets updated on-chain
  fieldset.disabled = true

  try {
    await contract.donate(donation.value)
  } catch (e) {
    alert(
      'Something went wrong! ' +
      'Maybe you need to sign out and back in? ' +
      'Check your browser console for more info.'
    )
    throw e
  }

  // re-enable the form, whether the call succeeded or failed
  fieldset.disabled = false
}

document.querySelector('#sign-in-button').onclick = () => { wallet.signIn() }
document.querySelector('#sign-out-button').onclick = () => { wallet.signOut() }

async function fetchBeneficiary() {
  // Get greeting from the contract
  const currentGreeting = payee

  // Set all elements marked as greeting with the current greeting
  document.querySelectorAll('[data-behavior=beneficiary]').forEach(el => {
    el.innerText = currentGreeting
    el.value = currentGreeting
  })
}

// Display the signed-out-flow container
function signedOutFlow() {
  document.querySelector('.signed-out-flow').style.display = 'block'
}

async function signedInFlow() {
  // Displaying the signed in flow container
  document.querySelectorAll('.signed-in-flow').forEach(elem => elem.style.display = 'block')

  // Check if there is a transaction hash in the URL
  const urlParams = new URLSearchParams(window.location.search);
  const txhash = urlParams.get("transactionHashes")

  if(txhash !== null){
    // Get result from the transaction
    let result = await contract.getDonationFromTransaction(txhash)
    document.querySelector('[data-behavior=donation-so-far]').innerText = result

    // show notification
    document.querySelector('[data-behavior=notification]').style.display = 'block'

    // remove notification again after css animation completes
    setTimeout(() => {
      document.querySelector('[data-behavior=notification]').style.display = 'none'
    }, 11000)
  }

}

async function getAndShowDonations(){
  document.getElementById('donations-table').innerHTML = 'Loading ...'

  // Load last 10 donations
  let donations = await contract.latestDonations()

  document.getElementById('donations-table').innerHTML = ''

  donations.forEach(elem => {
    let tr = document.createElement('tr')
    tr.innerHTML = `
      <tr>
        <th scope="row">${elem.account_id}</th>
        <td>${elem.total_amount}</td>
      </tr>
    `
    document.getElementById('donations-table').appendChild(tr)
  })
}

window.set_donation = async function(amount){
  let data = await fetch("https://api.coingecko.com/api/v3/simple/price?ids=near&vs_currencies=usd").then(response => response.json())
  const near2usd = data['near']['usd']
  const amount_in_near = amount / near2usd
  const rounded_two_decimals = Math.round(amount_in_near * 100) / 100
  document.querySelector('#donation').value = rounded_two_decimals
}
'''
'''--- NEAR/lensWebViewSupport/frontend/near-interface.js ---
/* Talking with a contract often involves transforming data, we recommend you to encapsulate that logic into a class */

import { utils } from 'near-api-js'

export class Contract {

  constructor({ contractId, walletToUse }) {
    this.contractId = contractId;
    this.wallet = walletToUse;
  }

  async getBeneficiary() {
    return await this.wallet.viewMethod({ contractId: this.contractId, method: "get_beneficiary" })
  }

  async getPayee() {
    return await this.wallet.viewMethod({ contractId: this.contractId, method: "get_targetPayee" })
  }

  async latestDonations() {
    const number_of_donors = await this.wallet.viewMethod({ contractId: this.contractId, method: "number_of_donors" })
    const min = number_of_donors > 10 ? number_of_donors - 9 : 0

    let donations = await this.wallet.viewMethod({ contractId: this.contractId, method: "get_donations", args: { from_index: min.toString(), limit: number_of_donors } })

    donations.forEach(elem => {
      elem.total_amount = utils.format.formatNearAmount(elem.total_amount);
    })

    return donations
  }

  async getDonationFromTransaction(txhash) {
    let donation_amount = await this.wallet.getTransactionResult(txhash);
    return utils.format.formatNearAmount(donation_amount);
  }

  async donate(amount) {
    let deposit = utils.format.parseNearAmount(amount.toString())
    let response = await this.wallet.callMethod({ contractId: this.contractId, method: "donate", deposit })
    return response
  }

}
'''
'''--- NEAR/lensWebViewSupport/frontend/near-wallet.js ---
/* A helper file that simplifies using the wallet selector */

// near api js
import { providers } from 'near-api-js';

// wallet selector UI
import '@near-wallet-selector/modal-ui/styles.css';
import { setupModal } from '@near-wallet-selector/modal-ui';
import LedgerIconUrl from '@near-wallet-selector/ledger/assets/ledger-icon.png';
import MyNearIconUrl from '@near-wallet-selector/my-near-wallet/assets/my-near-wallet-icon.png';

// wallet selector options
import { setupWalletSelector } from '@near-wallet-selector/core';
import { setupLedger } from '@near-wallet-selector/ledger';
import { setupMyNearWallet } from '@near-wallet-selector/my-near-wallet';

const THIRTY_TGAS = '30000000000000';
const NO_DEPOSIT = '0';

// Wallet that simplifies using the wallet selector
export class Wallet {
  walletSelector;
  wallet;
  network;
  createAccessKeyFor;

  constructor({ createAccessKeyFor = undefined, network = 'testnet' }) {
    // Login to a wallet passing a contractId will create a local
    // key, so the user skips signing non-payable transactions.
    // Omitting the accountId will result in the user being
    // asked to sign all transactions.
    this.createAccessKeyFor = createAccessKeyFor
    this.network = 'testnet'
  }

  // To be called when the website loads
  async startUp() {
    this.walletSelector = await setupWalletSelector({
      network: this.network,
      modules: [setupMyNearWallet({ iconUrl: MyNearIconUrl }),
      setupLedger({ iconUrl: LedgerIconUrl })],
    });

    const isSignedIn = this.walletSelector.isSignedIn();

    if (isSignedIn) {
      this.wallet = await this.walletSelector.wallet();
      this.accountId = this.walletSelector.store.getState().accounts[0].accountId;
    }

    return isSignedIn;
  }

  // Sign-in method
  signIn() {
    const description = 'Please select a wallet to sign in.';
    const modal = setupModal(this.walletSelector, { contractId: this.createAccessKeyFor, description });
    modal.show();
  }

  // Sign-out method
  signOut() {
    this.wallet.signOut();
    this.wallet = this.accountId = this.createAccessKeyFor = null;
    window.location.replace(window.location.origin + window.location.pathname);
  }

  // Make a read-only call to retrieve information from the network
  async viewMethod({ contractId, method, args = {} }) {
    const { network } = this.walletSelector.options;
    const provider = new providers.JsonRpcProvider({ url: network.nodeUrl });

    let res = await provider.query({
      request_type: 'call_function',
      account_id: contractId,
      method_name: method,
      args_base64: Buffer.from(JSON.stringify(args)).toString('base64'),
      finality: 'optimistic',
    });
    return JSON.parse(Buffer.from(res.result).toString());
  }

  // Call a method that changes the contract's state
  async callMethod({ contractId, method, args = {}, gas = THIRTY_TGAS, deposit = NO_DEPOSIT }) {
    // Sign a transaction with the "FunctionCall" action
    return await this.wallet.signAndSendTransaction({
      signerId: this.accountId,
      receiverId: contractId,
      actions: [
        {
          type: 'FunctionCall',
          params: {
            methodName: method,
            args,
            gas,
            deposit,
          },
        },
      ],
    });
  }

  // Get transaction result from the network
  async getTransactionResult(txhash) {
    const { network } = this.walletSelector.options;
    const provider = new providers.JsonRpcProvider({ url: network.nodeUrl });

    // Retrieve transaction result from the network
    const transaction = await provider.txStatus(txhash, 'unnused');
    return providers.getTransactionLastResult(transaction);
  }
}
'''
'''--- NEAR/lensWebViewSupport/frontend/package.json ---
{
  "name": "my-near-app",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "start": "./start.sh",
    "build": "parcel build index.html --public-url ./"
  },
  "devDependencies": {
    "env-cmd": "^10.1.0",
    "events": "^3.3.0",
    "nodemon": "^2.0.16",
    "parcel": "^2.7.0",
    "process": "^0.11.10"
  },
  "dependencies": {
    "@near-wallet-selector/core": "^7.0.0",
    "@near-wallet-selector/ledger": "^7.0.0",
    "@near-wallet-selector/math-wallet": "^7.0.0",
    "@near-wallet-selector/meteor-wallet": "^7.0.0",
    "@near-wallet-selector/modal-ui": "^7.0.0",
    "@near-wallet-selector/my-near-wallet": "^7.0.0",
    "@near-wallet-selector/near-wallet": "^7.0.0",
    "@near-wallet-selector/nightly": "^7.0.0",
    "@near-wallet-selector/nightly-connect": "^7.0.0",
    "@near-wallet-selector/sender": "^7.0.0",
    "@near-wallet-selector/wallet-connect": "^7.0.0",
    "near-api-js": "^0.44.2"
  }
}

'''
'''--- NEAR/lensWebViewSupport/frontend/start.sh ---
#!/bin/sh

GREEN='\033[1;32m'
NC='\033[0m' # No Color

CONTRACT_DIRECTORY=../contract
DEV_ACCOUNT_FILE="${CONTRACT_DIRECTORY}/neardev/dev-account.env"

start () {
  echo The app is starting!
  env-cmd -f $DEV_ACCOUNT_FILE parcel index.html --open
}

alert () {
  echo "======================================================"
  echo "It looks like you forgot to deploy your contract"
  echo ">> Run ${GREEN}'npm run deploy'${NC} from the 'root' directory"
  echo "======================================================"
}

if [ -f "$DEV_ACCOUNT_FILE" ]; then
  start
else
  alert
fi

'''
'''--- NEAR/lensWebViewSupport/integration-tests/package.json ---
{
  "name": "integration-tests",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "test": "ava"
  },
  "devDependencies": {
    "@types/bn.js": "^5.1.0",
    "@types/node": "^18.6.2",
    "ava": "^4.2.0",
    "near-workspaces": "^3.2.1",
    "ts-node": "^10.8.0",
    "typescript": "^4.7.2"
  },
  "dependencies": {}
}

'''
'''--- NEAR/lensWebViewSupport/integration-tests/src/main.ava.ts ---
import { Worker, NEAR, NearAccount } from "near-workspaces";
import anyTest, { TestFn } from "ava";

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async (t) => {
  // Init the worker and start a Sandbox server
  const worker = await Worker.init();

  const root = worker.rootAccount;

  // define users
  const beneficiary = await root.createSubAccount("beneficiary", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });

  const alice = await root.createSubAccount("alice", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });

  const bob = await root.createSubAccount("bob", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });

  const contract = await root.createSubAccount("contract", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });
  
  // Deploy the contract.
  await contract.deploy(process.argv[2]);

  // Initialize beneficiary
  await contract.call(contract, "init", {beneficiary: beneficiary.accountId})

  // Save state for test runs, it is unique for each test
  t.context.worker = worker;
  t.context.accounts = { root, contract, beneficiary, alice, bob };
});

test.afterEach(async (t) => {
  // Stop Sandbox server
  await t.context.worker.tearDown().catch((error) => {
    console.log("Failed to stop the Sandbox:", error);
  });
});

test("sends donations to the beneficiary", async (t) => {
  const { contract, alice, beneficiary } = t.context.accounts;

  const balance = await beneficiary.balance();
  const available = parseFloat(balance.available.toHuman());

  await alice.call(contract, "donate", {}, { attachedDeposit: NEAR.parse("1 N").toString() });

  const new_balance = await beneficiary.balance();
  const new_available = parseFloat(new_balance.available.toHuman());

  t.is(new_available, available + 1 - 0.001);
});

test("records the donation", async (t) => {
  const { contract, bob } = t.context.accounts;

  await bob.call(contract, "donate", {}, { attachedDeposit: NEAR.parse("2 N").toString() });

  const donation: Donation = await contract.view("get_donation_for_account", { account_id: bob.accountId });

  t.is(donation.account_id, bob.accountId);
  t.is(donation.total_amount, NEAR.parse("2 N").toString());
});

class Donation{
  account_id: string = "";
  total_amount: string = "";
}
'''
'''--- NEAR/lensWebViewSupport/package.json ---
{
  "name": "donation-js",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "start": "cd frontend && npm run start",
    "deploy": "cd contract && npm run deploy",
    "build": "npm run build:contract && npm run build:web",
    "build:web": "cd frontend && npm run build",
    "build:contract": "cd contract && npm run build",
    "test": "npm run build:contract && npm run test:unit && npm run test:integration",
    "test:unit": "cd contract && npm test",
    "test:integration": "cd integration-tests && npm test -- -- \"./contract/build/contract.wasm\"",
    "postinstall": "cd frontend && npm install && cd .. && cd integration-tests && npm install && cd .. && cd contract && npm install"
  },
  "devDependencies": {
    "near-cli": "^3.3.0"
  },
  "dependencies": {}
}
'''
'''--- README.md ---
# How to install app

app link: https://expo.dev/@nel349/test-dapp?serviceType=classic&distribution=expo-go

1. Install expo go in your phone from the app store(iOS) or play store(android)
2. For iphone users scan the QR in the above link the app using your camera app
3. For android users, open Expo go, tap on Scan QR code, scan the QR in the above link.
4. After scan, app should automatically install.

'''
'''--- app.config.ts ---
import {
    AndroidManifest,
    ConfigPlugin,
    withAndroidManifest,
} from '@expo/config-plugins';
import { ExpoConfig } from '@expo/config-types';
import xml2js from 'xml2js';

const queriesXml = `
<queries>
  <intent>
    <action android:name="android.intent.action.VIEW" />
    <data android:scheme="wc"/>
  </intent>
  <intent>
    <action android:name="android.intent.action.VIEW" />
    <data android:scheme="https"/>
  </intent>
  <intent>
    <action android:name="android.intent.action.VIEW" />
    <data android:scheme="wss"/>
  </intent>
</queries>`;

type KeyValuePair = {
  $: {
    [key: string]: string | undefined;
  }
};

type Intent = { 
  action?: KeyValuePair[],
  data?: KeyValuePair[]
};

type Queries = {
  intent?: Intent[];
};

type ParseResult = {
  queries: Queries;
}

type AndroidManifestWithQuery = AndroidManifest & {
  manifest: {
    $: {
      ['queries']?: any;
    }
  }
};

/**
 * Does not currently work as expected, need to run `expo prebuild`
 * to configure plugins, but this breaks the `Expo Go` app functionality
 * 
 * @param androidManifest A AndroidManifest file that has been updated
 *                        to accept queries as a parameter
 * @returns an updated AndroidManifest file
 * 
 * @see https://chafikgharbi.com/expo-android-manifest/
 * @see https://docs.expo.dev/workflow/customizing/
 * @see https://docs.expo.dev/workflow/configuration/
 * @see https://docs.expo.dev/guides/config-plugins/#modifying-the-androidmanifestxml
 */
const addQueryToManifest = (androidManifest: AndroidManifestWithQuery) => {
  const { manifest } = androidManifest;
  let packageQuery: Queries;

  xml2js.parseString(queriesXml, (err, result: ParseResult) => {
    packageQuery = result.queries

    if (!Array.isArray(manifest.$['queries'])) {
      manifest.$['queries'] = [];
    }

    manifest.$['queries'].push(packageQuery);
  });

  return androidManifest;
};

const withPackageVisibility: ConfigPlugin = (config) => {
  return withAndroidManifest(config, (config) => {
    config.modResults = addQueryToManifest(config.modResults);
    return config;
  });
};

const config: ExpoConfig = {
  name: 'test-dapp',
  slug: 'auroralens',
  owner: 'nel349',
  version: "1.0.0",
  orientation: "portrait",
  icon: "./assets/images/icon.png",
  scheme: "myapp",
  userInterfaceStyle: "automatic",
  splash: {
    image: "./assets/images/splash.png",
    resizeMode: "contain",
    backgroundColor: "#ffffff"
  },
  updates: {
    fallbackToCacheTimeout: 0
  },
  assetBundlePatterns: [
    "**/*"
  ],
  ios: {
    "supportsTablet": true
  },
  android: {
    package: "com.clxyder.testdapp",
    adaptiveIcon: {
      foregroundImage: "./assets/images/adaptive-icon.png",
      backgroundColor: "#ffffff"
    }
  },
  web: {
    favicon: "./assets/images/favicon.png"
  },
  plugins: [
    "./plugins/trust-local-certs.js",
    [
      "expo-image-picker",
      {
        "photosPermission": "The app accesses your photos to let you share them with your friends."
      }
    ]
  ]  
};

export default withPackageVisibility(config);

'''
'''--- babel.config.js ---
module.exports = function(api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo']
  };
};

'''
'''--- components/Nav.js ---
import React from 'react'
import { StyleSheet, Text, View } from 'react-native'
import { Icon } from 'react-native-elements'
import { Platform } from 'react-native'
import PropTypes from 'prop-types'

import { Colors } from '../constants'

const styles = StyleSheet.create({
  centerRow: {
    alignItems: 'center',
    backgroundColor: 'transparent',
    flex: 2,
    flexDirection: 'row',
    justifyContent: 'center',
  },
  container: {
    flexDirection: 'row',
    ...Platform.select({
      ios: {
        height: 55,
      },
      android: {
        height: 80,
      },
    }),
    justifyContent: 'center',
    marginLeft: 10,
    marginRight: 10,
  },
  icon: {
    justifyContent: 'flex-start',
    marginTop: 2.8,
  },
  iconContainer: {
    alignSelf: 'center',
  },
  leftRow: {
    backgroundColor: 'transparent',
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'flex-start',
  },
  logoutText: {
    color: Colors.blue,
    fontSize: 18,
    fontWeight: '400',
  },
  rightRow: {
    alignItems: 'center',
    backgroundColor: 'transparent',
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'flex-end',
  },
  titleText: {
    color: 'black',
    fontSize: 18,
    fontWeight: '400',
  },
})

const Search = ({ title, navigation, leftIcon }) => (
  <View style={{ backgroundColor: 'white' }}>
    <View style={styles.container}>
      <View style={styles.leftRow}>
        <Icon
          size={34}
          type="ionicon"
          name="ios-arrow-back"
          underlayColor="transparent"
          underlineColorAndroid="transparent"
          hitSlop={{ top: 15, bottom: 15, left: 15, right: 15 }}
          color={Colors.blue}
          iconStyle={styles.icon}
          containerStyle={styles.iconContainer}
          onPress={() => navigation.goBack(null)}
          {...leftIcon}
        />
      </View>
      <View style={styles.centerRow}>
        <Text style={styles.titleText} numberOfLines={1}>
          {title}
        </Text>
      </View>
      <View style={styles.rightRow}>
        <Text style={styles.logoutText}>Log out</Text>
      </View>
    </View>
  </View>
)

Search.propTypes = {
  title: PropTypes.string.isRequired,
  navigation: PropTypes.object.isRequired,
  leftIcon: PropTypes.object,
}

Search.defaultProps = {
  leftIcon: {},
}

export default Search

'''
'''--- components/NavAbsolute.js ---
import React, { Component } from 'react'
import { StyleSheet, Text, View } from 'react-native'
import { Icon } from 'react-native-elements'
import PropTypes from 'prop-types'

import { Colors } from '../constants'

const styles = StyleSheet.create({
  centerRow: {
    alignItems: 'flex-start',
    backgroundColor: 'transparent',
    flex: 3,
    flexDirection: 'column',
    justifyContent: 'center',
  },

  container: {
    backgroundColor: 'transparent',
    borderBottomWidth: 0,
    elevation: 0,
    flexDirection: 'row',
    height: 125,
    justifyContent: 'center',
    left: 0,
    marginLeft: 10,
    marginRight: 10,
    position: 'absolute',
    right: 0,
    zIndex: 100,
  },
  icon: {
    justifyContent: 'flex-start',
    marginTop: 2.8,
  },
  iconContainer: {
    alignSelf: 'center',
  },
  leftRow: {
    backgroundColor: 'transparent',
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'flex-start',
  },
  rightRow: {
    alignItems: 'flex-end',
    backgroundColor: 'transparent',
    flex: 2,
    flexDirection: 'row',
    justifyContent: 'flex-end',
    marginRight: 4,
  },
  titleText: {
    color: Colors.white,
    fontSize: 24,
    fontWeight: '600',
  },
  subTitleText: {
    color: Colors.white,
    fontSize: 14,
    fontWeight: '400',
  },
})

class Nav extends Component {
  static propTypes = {
    navigation: PropTypes.object.isRequired,
    title: PropTypes.string.isRequired,
    subTitle: PropTypes.string.isRequired,
  }

  state = {
    like: false,
  }

  onPressLike = () => {
    this.setState(state => ({
      like: !state.like,
    }))
  }

  render() {
    const { navigation, title, subTitle } = this.props

    return (
      <View>
        <View style={styles.container}>
          <View style={styles.leftRow}>
            <Icon
              size={34}
              name="arrow-back"
              type="material-icon"
              color={Colors.white}
              iconStyle={styles.icon}
              underlayColor="transparent"
              underlineColorAndroid="transparent"
              containerStyle={styles.iconContainer}
              hitSlop={{ top: 15, bottom: 15, left: 15, right: 15 }}
            />
          </View>
          <View style={styles.centerRow}>
            <Text style={styles.titleText} numberOfLines={1}>
              {title}
            </Text>
            <Text style={styles.subTitleText} numberOfLines={1}>
              {subTitle}
            </Text>
          </View>
          <View style={styles.rightRow}>
            <Icon
              size={40}
              type="entypo"
              name="heart-outlined"
              iconStyle={styles.icon}
              onPress={this.onPressLike}
              underlayColor="transparent"
              underlineColorAndroid="transparent"
              color={this.state.like ? Colors.pink : Colors.white}
              hitSlop={{ top: 15, bottom: 15, left: 15, right: 15 }}
              containerStyle={[styles.iconContainer, { marginRight: 12 }]}
            />
            <Icon
              size={32}
              type="feather"
              name="share-2"
              color={Colors.white}
              onPress={() => null}
              iconStyle={styles.icon}
              underlayColor="transparent"
              underlineColorAndroid="transparent"
              containerStyle={styles.iconContainer}
              hitSlop={{ top: 15, bottom: 15, left: 15, right: 15 }}
            />
          </View>
        </View>
      </View>
    )
  }
}

export default Nav

'''
'''--- components/__tests__/StyledText-test.js ---
import * as React from 'react';
import renderer from 'react-test-renderer';

import { MonoText } from '../StyledText';

it(`renders correctly`, () => {
  const tree = renderer.create(<MonoText>Snapshot test!</MonoText>).toJSON();

  expect(tree).toMatchSnapshot();
});

'''
'''--- components/index.js ---
export { default as Nav } from './Nav'
export { default as NavAbsolute } from './NavAbsolute'

'''
'''--- components/temp.ts ---
import { networkInterfaces } from 'os';

export const heyo = () => {
    const nets = networkInterfaces();
    const results = Object.create(null); // Or just '{}', an empty object
    for (const name of Object.keys(nets)) {
    const nete = nets[name];
     if (nets == undefined || nete == undefined) {
        return
     }
     
      for (const net of nete) {
        // Skip over non-IPv4 and internal (i.e. 127.0.0.1) addresses
        // 'IPv4' is in Node <= 17, from 18 it's a number 4 or 6
        const familyV4Value = typeof net.family === 'string' ? 'IPv4' : 4
        if (net.family === familyV4Value && !net.internal) {
          if (!results[name]) {
            results[name] = [];
          }
          results[name].push(net.address);
        }
      }
    }
    return results;
}

const ip = heyo().en0
console.log("this heyo: " + ip)

'''
'''--- constants/Colors.js ---
// https://developer.apple.com/ios/human-interface-guidelines/visual-design/color/

const colors = {
  red: '#FF3B30',
  orange: '#FF9500',
  yellow: '#FFCC00',
  green: '#4CD964',
  tealBlue: '#5AC8FA',
  blue: '#007AFF',
  purple: '#5856D6',
  pink: '#FF2D55',

  white: '#FFFFFF',
  customGray: '#EFEFF4',
  lightGray: '#E5E5EA',
  lightGray2: '#D1D1D6',
  midGray: '#C7C7CC',
  gray: '#8E8E93',
  black: '#000000',
}

export default colors

'''
'''--- constants/Colors.ts ---
const tintColorLight = '#2f95dc';
const tintColorDark = '#fff';

export default {
  light: {
    text: '#000',
    background: '#fff',
    tint: tintColorLight,
    tabIconDefault: '#ccc',
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: '#fff',
    background: '#000',
    tint: tintColorDark,
    tabIconDefault: '#ccc',
    tabIconSelected: tintColorDark,
  },
};

'''
'''--- constants/Layout.ts ---
import { Dimensions } from 'react-native';

const width = Dimensions.get('window').width;
const height = Dimensions.get('window').height;

export default {
  window: {
    width,
    height,
  },
  isSmallDevice: width < 375,
};

'''
'''--- constants/index.js ---
export { default as Colors } from './Colors'

'''
'''--- global.ts ---
import { Platform, LogBox } from "react-native";

export interface Global {
    btoa: any
    atob: any
    self: any
    Buffer: any
    process: any
    location: any
}
  
declare var global: Global
if (typeof global.self === 'undefined') {
    global.self = global
}

if (Platform.OS !== "web") {
    require("react-native-get-random-values");
    LogBox.ignoreLogs([
      "Warning: The provided value 'ms-stream' is not a valid 'responseType'.",
      "Warning: The provided value 'moz-chunked-arraybuffer' is not a valid 'responseType'.",
    ]);
  }

global.btoa = global.btoa || require('base-64').encode;
global.atob = global.atob || require('base-64').decode;

global.Buffer = require('buffer').Buffer

global.process = require('process')
global.process.env.NODE_ENV = __DEV__ ? 'development' : 'production';
global.process.version = 'v9.40';
  
global.location = {
    protocol: 'https',
}
'''
'''--- hooks/useCachedResources.ts ---
import { FontAwesome } from '@expo/vector-icons';
import * as Font from 'expo-font';
import * as SplashScreen from 'expo-splash-screen';
import { useEffect, useState } from 'react';

export default function useCachedResources() {
  const [isLoadingComplete, setLoadingComplete] = useState(false);

  // Load any resources or data that we need prior to rendering the app
  useEffect(() => {
    async function loadResourcesAndDataAsync() {
      try {
        SplashScreen.preventAutoHideAsync();

        // Load fonts
        await Font.loadAsync({
          ...FontAwesome.font,
          'space-mono': require('../assets/fonts/SpaceMono-Regular.ttf'),
        });
      } catch (e) {
        // We might want to provide this error information to an error reporting service
        console.warn(e);
      } finally {
        setLoadingComplete(true);
        SplashScreen.hideAsync();
      }
    }

    loadResourcesAndDataAsync();
  }, []);

  return isLoadingComplete;
}

'''
'''--- hooks/useColorScheme.ts ---
import { ColorSchemeName, useColorScheme as _useColorScheme } from 'react-native';

// The useColorScheme value is always either light or dark, but the built-in
// type suggests that it can be null. This will not happen in practice, so this
// makes it a bit easier to work with.
export default function useColorScheme(): NonNullable<ColorSchemeName> {
  return _useColorScheme() as NonNullable<ColorSchemeName>;
}

'''
'''--- index.js ---
/* eslint-disable eslint-comments/no-unlimited-disable */
/* eslint-disable */

const { Platform } = require("react-native");

if (Platform.OS !== "web") {
  require("./global");
}

const { registerRootComponent, scheme } = require("expo");
const { default: App } = require("./App");

const {
  default: AsyncStorage,
} = require("@react-native-async-storage/async-storage");
const { withWalletConnect } = require("@walletconnect/react-native-dapp");

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in the Expo client or in a native build,
// the environment is set up appropriately
registerRootComponent(
  withWalletConnect(App, {
    redirectUrl:
      Platform.OS === "web" ? window.location.origin : `${scheme}://`,
    storageOptions: {
      asyncStorage: AsyncStorage,
    },
  })
);

'''
'''--- lens_protocol/api-polygon/authenticate.js ---
import {
    createClient,
    STORAGE_KEY, authenticate as authenticateMutation, getChallenge, getDefaultProfile,
} from '.';

import { parseJwt } from './utils';

import WalletConnectProvider from '@walletconnect/web3-provider';
import { ethers } from 'ethers';

import AsyncStorage from '@react-native-async-storage/async-storage';
import { basicClient } from './index';

export const signIn = async (account, connector) => {
    try {
        //   setConnected(true);
        //   setUserAddress(account);
        console.log('before urqlClient');
        const urqlClient = basicClient;
        console.log('after urqlClient with address'  + JSON.stringify(urqlClient));
        const response = await urqlClient.query(getChallenge, {
            address: account,
        }).toPromise();

        console.log('HELOOW WITH ACCOUNT ', account);
        // const provider = new providers.Web3Provider(window.ethereum);

        const provider = new WalletConnectProvider({
            rpc: {
                // 1: "https://mainnet.mycustomnode.com",
                // 3: "https://ropsten.mycustomnode.com",
                // 100: "https://dai.poa.network",
                80001: 'https://polygon-mumbai.g.alchemy.com/v2/wDKjb83mAC3ok5MgMg1vWvc78NAa59zo',
            },
            chainId: 80001,
            connector,
            qrcode: false,
        });

        await provider.enable();
        const ethersProvider = new ethers.providers.Web3Provider(provider);

        const signer = ethersProvider.getSigner();
        //   setSigner(signertmp);

        //   console.log("signer: ", signer)

        const signature = await signer.signMessage(response.data.challenge.text);
        const authData = await urqlClient.mutation(authenticateMutation, {
            address: account, signature,
        }).toPromise();

        // console.log("after authData : ", authData)
        const { accessToken, refreshToken } = authData.data.authenticate;

        console.log('accessToken: ', accessToken);

        console.log('refreshToken: ', refreshToken);
        const accessTokenData = parseJwt(accessToken);
        //   getUserProfile(account);
        AsyncStorage.setItem(STORAGE_KEY, JSON.stringify({
            accessToken, refreshToken, exp: accessTokenData.exp, address: account
        }));

          return { account, signer}
    } catch (err) {
        console.log('error signIn: ', err);
    }
};

export const getUserProfile = async () => {
    const storageData = await AsyncStorage.getItem(STORAGE_KEY);
    const storageDataParsed = JSON.parse(storageData);
    // console.log("storageData in createClient= ", storageData);
    // console.log("storageData in createClient PARSED= ", storageDataParsed)
    if (storageDataParsed) {
        const { accessToken, address } = storageDataParsed;

        // console.log(` in getUserProfile= ${accessToken} and ${address} `);
        try {
            const urqlClient = await createClient();
            const response = await urqlClient.query(getDefaultProfile, {
                address,
            }).toPromise();

            // console.log('response in getUserProfile=  ', response);
            // return response.data.defaultProfile;
        } catch (err) {
            console.log('error fetching user profile...: ', err);
        }
    }
}
'''
'''--- lens_protocol/api-polygon/create-profiles.ts ---
import { gql, apolloClient } from './profile/apollo-client';
// this is showing you how you use it with react for example
// if your using node or something else you can import using
// @apollo/client/core!

const CREATE_PROFILE = `
mutation($request: CreateProfileRequest!) { 
  createProfile(request: $request) {
    ... on RelayerResult {
      txHash
    }
    ... on RelayError {
      reason
    }
    __typename
  }
}
`

const CREATE_FREE_FOLLOW_PROFILE =`
mutation CreateProfile ($handle: CreateHandle!, $profilePictureUri: Url!) {
  createProfile(request:{ 
                handle: $handle,
                profilePictureUri: $profilePictureUri,   
                followModule: {
                     freeFollowModule: true
                  }
                }) {
    ... on RelayerResult {
      txHash
    }
    ... on RelayError {
      reason
    }
    __typename
  }
}
`

export const createProfileRequest = async (createProfileRequest: any)  => {

  // console.log("link ", apolloClient.link.request().toString())
  return (await apolloClient()).mutate({
    mutation: gql(CREATE_PROFILE),
    variables: {
      request: createProfileRequest
    },
  });
}

// profiles created
/*
  handle1, handle2, normanlopez349, norman15, norman15666
*/

export const createProfileFreeFollowRequest = async (handle:string, profilePictureUri:string)  => {
    // console.log('attempting in createProfileFreeFollowRequest : ', createProfileRequest.handle, createProfileRequest.profilePictureUri);
  console.log("attempt in  createProfileFreeFollowRequest", handle, profilePictureUri)
  return (await apolloClient()).mutate({
    mutation: gql(CREATE_FREE_FOLLOW_PROFILE),
    variables: {
      handle: handle,
      profilePictureUri: profilePictureUri
    },
  });
}
'''
'''--- lens_protocol/api-polygon/index.js ---
/* eslint-disable global-require */
import { createClient as createUrqlClient } from 'urql';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { getProfiles, getPublications } from './queries';
import { createProfileRequest, createProfileFreeFollowRequest } from './create-profiles.ts';
import { generateRandomColor } from './utils';

export const APIURL = 'https://api-mumbai.lens.dev/'; //     ? "https://api.lens.dev": "https://api-mumbai.lens.dev/";

export const STORAGE_KEY = 'LH_STORAGE_KEY';
export const LENS_HUB_CONTRACT_ADDRESS = '0xDb46d1Dc155634FbC732f92E853b10B288AD5a1d';
export const PERIPHERY_CONTRACT_ADDRESS = '0xeff187b4190E551FC25a7fA4dFC6cf7fDeF7194f';

export const basicClient = new createUrqlClient({
  url: APIURL,
});

export const LENS_HUB_ABI = require('./lens_hub_abi/abi.json');

export async function fetchProfile(id) {
  try {
    const urqlClient = await createClient();
    const returnedProfile = await urqlClient.query(getProfiles, { id }).toPromise();
    const profileData = returnedProfile.data.profiles.items[0];
    profileData.color = generateRandomColor();
    const pubs = await urqlClient.query(getPublications, { id, limit: 50 }).toPromise();
    return {
      profile: profileData,
      publications: pubs.data.publications.items,
    };
  } catch (err) {
    console.log('error fetching profile...', err);
  }
}

export async function createProfile(handle, url) {
  try {
    const createProfileResult = await createProfileRequest({
      handle, profilePictureUri: url,
    });
    console.log('returned Profile: ', createProfileResult);
    const { txHash } = createProfileResult.data;
    return txHash;
  } catch (err) {
    console.log('error creating profile...', err);
    console.log(JSON.stringify(err, null, 2));
  }
  return null;
}

export async function createFreeFollowProfile(handle, url) {
  try {
    const createProfileResult = await createProfileFreeFollowRequest(handle, url);
    console.log('returned Profile: ', createProfileResult);
    const { txHash } = createProfileResult.data;
    return txHash;
  } catch (err) {
    console.log('error creating profile...', err);
    console.log(JSON.stringify(err, null, 2));
  }
  return null;
}

export async function createClient() {
  const storageData = await AsyncStorage.getItem(STORAGE_KEY);
  const storageDataParsed = JSON.parse(storageData);
  // console.log("storageData in createClient= ", storageData);
  // console.log("storageData in createClient PARSED= ", storageDataParsed)
  if (storageDataParsed) {
    try {
      // const { accessToken } = await refreshAuthToken();
      const { accessToken } = storageDataParsed;

      console.log('access token: in createClient', accessToken);
      const urqlClient = new createUrqlClient({
        url: APIURL,
        fetchOptions: {
          headers: {
            'x-access-token': `Bearer ${accessToken}`,
          },
        },
      });
      return urqlClient;
    } catch (err) {
      return basicClient;
    }
  } else {
    return basicClient;
  }
}

export {
  recommendProfiles,
  getProfiles,
  getDefaultProfile,
  getPublications,
  searchProfiles,
  searchPublications,
  explorePublications,
  doesFollow,
  getChallenge,
  timeline,
} from './queries';

export {
  followUser,
  authenticate,
  refresh,
  createUnfollowTypedData,
  broadcast,
  createProfileMetadataTypedData,
} from './mutations';

'''
'''--- lens_protocol/api-polygon/lens_hub_abi/abi.json ---
[
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "followNFTImpl",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "collectNFTImpl",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "CallerNotCollectNFT",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CallerNotFollowNFT",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CannotInitImplementation",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "EmergencyAdminCannotUnpause",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InitParamsInvalid",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Initialized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotGovernance",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotGovernanceOrEmergencyAdmin",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotOwnerOrApproved",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotProfileOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotProfileOwnerOrDispatcher",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Paused",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProfileCreatorNotWhitelisted",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProfileImageURILengthInvalid",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PublicationDoesNotExist",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PublishingPaused",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SignatureExpired",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SignatureInvalid",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroSpender",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "approved",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "burn",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "v",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "deadline",
              "type": "uint256"
            }
          ],
          "internalType": "struct DataTypes.EIP712Signature",
          "name": "sig",
          "type": "tuple"
        }
      ],
      "name": "burnWithSig",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pubId",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "collect",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "collector",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "profileId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "pubId",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            },
            {
              "components": [
                {
                  "internalType": "uint8",
                  "name": "v",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes32",
                  "name": "r",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "s",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "deadline",
                  "type": "uint256"
                }
              ],
              "internalType": "struct DataTypes.EIP712Signature",
              "name": "sig",
              "type": "tuple"
            }
          ],
          "internalType": "struct DataTypes.CollectWithSigData",
          "name": "vars",
          "type": "tuple"
        }
      ],
      "name": "collectWithSig",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "profileId",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "contentURI",
              "type": "string"
            },
            {
              "internalType": "uint256",
              "name": "profileIdPointed",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "pubIdPointed",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "referenceModuleData",
              "type": "bytes"
            },
            {
              "internalType": "address",
              "name": "collectModule",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "collectModuleInitData",
              "type": "bytes"
            },
            {
              "internalType": "address",
              "name": "referenceModule",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "referenceModuleInitData",
              "type": "bytes"
            }
          ],
          "internalType": "struct DataTypes.CommentData",
          "name": "vars",
          "type": "tuple"
        }
      ],
      "name": "comment",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "profileId",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "contentURI",
              "type": "string"
            },
            {
              "internalType": "uint256",
              "name": "profileIdPointed",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "pubIdPointed",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "referenceModuleData",
              "type": "bytes"
            },
            {
              "internalType": "address",
              "name": "collectModule",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "collectModuleInitData",
              "type": "bytes"
            },
            {
              "internalType": "address",
              "name": "referenceModule",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "referenceModuleInitData",
              "type": "bytes"
            },
            {
              "components": [
                {
                  "internalType": "uint8",
                  "name": "v",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes32",
                  "name": "r",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "s",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "deadline",
                  "type": "uint256"
                }
              ],
              "internalType": "struct DataTypes.EIP712Signature",
              "name": "sig",
              "type": "tuple"
            }
          ],
          "internalType": "struct DataTypes.CommentWithSigData",
          "name": "vars",
          "type": "tuple"
        }
      ],
      "name": "commentWithSig",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "handle",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "imageURI",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "followModule",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "followModuleInitData",
              "type": "bytes"
            },
            {
              "internalType": "string",
              "name": "followNFTURI",
              "type": "string"
            }
          ],
          "internalType": "struct DataTypes.CreateProfileData",
          "name": "vars",
          "type": "tuple"
        }
      ],
      "name": "createProfile",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "wallet",
          "type": "address"
        }
      ],
      "name": "defaultProfile",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pubId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "collectNFTId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "emitCollectNFTTransferEvent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "followNFTId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "emitFollowNFTTransferEvent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "exists",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "profileIds",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes[]",
          "name": "datas",
          "type": "bytes[]"
        }
      ],
      "name": "follow",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "follower",
              "type": "address"
            },
            {
              "internalType": "uint256[]",
              "name": "profileIds",
              "type": "uint256[]"
            },
            {
              "internalType": "bytes[]",
              "name": "datas",
              "type": "bytes[]"
            },
            {
              "components": [
                {
                  "internalType": "uint8",
                  "name": "v",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes32",
                  "name": "r",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "s",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "deadline",
                  "type": "uint256"
                }
              ],
              "internalType": "struct DataTypes.EIP712Signature",
              "name": "sig",
              "type": "tuple"
            }
          ],
          "internalType": "struct DataTypes.FollowWithSigData",
          "name": "vars",
          "type": "tuple"
        }
      ],
      "name": "followWithSig",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "getApproved",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pubId",
          "type": "uint256"
        }
      ],
      "name": "getCollectModule",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pubId",
          "type": "uint256"
        }
      ],
      "name": "getCollectNFT",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCollectNFTImpl",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pubId",
          "type": "uint256"
        }
      ],
      "name": "getContentURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        }
      ],
      "name": "getDispatcher",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getDomainSeparator",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        }
      ],
      "name": "getFollowModule",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        }
      ],
      "name": "getFollowNFT",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getFollowNFTImpl",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        }
      ],
      "name": "getFollowNFTURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getGovernance",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        }
      ],
      "name": "getHandle",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        }
      ],
      "name": "getProfile",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "pubCount",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "followModule",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "followNFT",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "handle",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "imageURI",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "followNFTURI",
              "type": "string"
            }
          ],
          "internalType": "struct DataTypes.ProfileStruct",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "handle",
          "type": "string"
        }
      ],
      "name": "getProfileIdByHandle",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pubId",
          "type": "uint256"
        }
      ],
      "name": "getPub",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "profileIdPointed",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "pubIdPointed",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "contentURI",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "referenceModule",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "collectModule",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "collectNFT",
              "type": "address"
            }
          ],
          "internalType": "struct DataTypes.PublicationStruct",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        }
      ],
      "name": "getPubCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pubId",
          "type": "uint256"
        }
      ],
      "name": "getPubPointer",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pubId",
          "type": "uint256"
        }
      ],
      "name": "getPubType",
      "outputs": [
        {
          "internalType": "enum DataTypes.PubType",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pubId",
          "type": "uint256"
        }
      ],
      "name": "getReferenceModule",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getState",
      "outputs": [
        {
          "internalType": "enum DataTypes.ProtocolState",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "symbol",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "newGovernance",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "collectModule",
          "type": "address"
        }
      ],
      "name": "isCollectModuleWhitelisted",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "followModule",
          "type": "address"
        }
      ],
      "name": "isFollowModuleWhitelisted",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "profileCreator",
          "type": "address"
        }
      ],
      "name": "isProfileCreatorWhitelisted",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "referenceModule",
          "type": "address"
        }
      ],
      "name": "isReferenceModuleWhitelisted",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "mintTimestampOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "profileId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "profileIdPointed",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "pubIdPointed",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "referenceModuleData",
              "type": "bytes"
            },
            {
              "internalType": "address",
              "name": "referenceModule",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "referenceModuleInitData",
              "type": "bytes"
            }
          ],
          "internalType": "struct DataTypes.MirrorData",
          "name": "vars",
          "type": "tuple"
        }
      ],
      "name": "mirror",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "profileId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "profileIdPointed",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "pubIdPointed",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "referenceModuleData",
              "type": "bytes"
            },
            {
              "internalType": "address",
              "name": "referenceModule",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "referenceModuleInitData",
              "type": "bytes"
            },
            {
              "components": [
                {
                  "internalType": "uint8",
                  "name": "v",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes32",
                  "name": "r",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "s",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "deadline",
                  "type": "uint256"
                }
              ],
              "internalType": "struct DataTypes.EIP712Signature",
              "name": "sig",
              "type": "tuple"
            }
          ],
          "internalType": "struct DataTypes.MirrorWithSigData",
          "name": "vars",
          "type": "tuple"
        }
      ],
      "name": "mirrorWithSig",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "v",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "deadline",
              "type": "uint256"
            }
          ],
          "internalType": "struct DataTypes.EIP712Signature",
          "name": "sig",
          "type": "tuple"
        }
      ],
      "name": "permit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        },
        {
          "components": [
            {
              "internalType": "uint8",
              "name": "v",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "deadline",
              "type": "uint256"
            }
          ],
          "internalType": "struct DataTypes.EIP712Signature",
          "name": "sig",
          "type": "tuple"
        }
      ],
      "name": "permitForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "profileId",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "contentURI",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "collectModule",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "collectModuleInitData",
              "type": "bytes"
            },
            {
              "internalType": "address",
              "name": "referenceModule",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "referenceModuleInitData",
              "type": "bytes"
            }
          ],
          "internalType": "struct DataTypes.PostData",
          "name": "vars",
          "type": "tuple"
        }
      ],
      "name": "post",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "profileId",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "contentURI",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "collectModule",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "collectModuleInitData",
              "type": "bytes"
            },
            {
              "internalType": "address",
              "name": "referenceModule",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "referenceModuleInitData",
              "type": "bytes"
            },
            {
              "components": [
                {
                  "internalType": "uint8",
                  "name": "v",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes32",
                  "name": "r",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "s",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "deadline",
                  "type": "uint256"
                }
              ],
              "internalType": "struct DataTypes.EIP712Signature",
              "name": "sig",
              "type": "tuple"
            }
          ],
          "internalType": "struct DataTypes.PostWithSigData",
          "name": "vars",
          "type": "tuple"
        }
      ],
      "name": "postWithSig",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        }
      ],
      "name": "setDefaultProfile",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "wallet",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "profileId",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint8",
                  "name": "v",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes32",
                  "name": "r",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "s",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "deadline",
                  "type": "uint256"
                }
              ],
              "internalType": "struct DataTypes.EIP712Signature",
              "name": "sig",
              "type": "tuple"
            }
          ],
          "internalType": "struct DataTypes.SetDefaultProfileWithSigData",
          "name": "vars",
          "type": "tuple"
        }
      ],
      "name": "setDefaultProfileWithSig",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "dispatcher",
          "type": "address"
        }
      ],
      "name": "setDispatcher",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "profileId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "dispatcher",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "uint8",
                  "name": "v",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes32",
                  "name": "r",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "s",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "deadline",
                  "type": "uint256"
                }
              ],
              "internalType": "struct DataTypes.EIP712Signature",
              "name": "sig",
              "type": "tuple"
            }
          ],
          "internalType": "struct DataTypes.SetDispatcherWithSigData",
          "name": "vars",
          "type": "tuple"
        }
      ],
      "name": "setDispatcherWithSig",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newEmergencyAdmin",
          "type": "address"
        }
      ],
      "name": "setEmergencyAdmin",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "followModule",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "followModuleInitData",
          "type": "bytes"
        }
      ],
      "name": "setFollowModule",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "profileId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "followModule",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "followModuleInitData",
              "type": "bytes"
            },
            {
              "components": [
                {
                  "internalType": "uint8",
                  "name": "v",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes32",
                  "name": "r",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "s",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "deadline",
                  "type": "uint256"
                }
              ],
              "internalType": "struct DataTypes.EIP712Signature",
              "name": "sig",
              "type": "tuple"
            }
          ],
          "internalType": "struct DataTypes.SetFollowModuleWithSigData",
          "name": "vars",
          "type": "tuple"
        }
      ],
      "name": "setFollowModuleWithSig",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        },
        {
          "internalType": "string",
          "name": "followNFTURI",
          "type": "string"
        }
      ],
      "name": "setFollowNFTURI",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "profileId",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "followNFTURI",
              "type": "string"
            },
            {
              "components": [
                {
                  "internalType": "uint8",
                  "name": "v",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes32",
                  "name": "r",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "s",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "deadline",
                  "type": "uint256"
                }
              ],
              "internalType": "struct DataTypes.EIP712Signature",
              "name": "sig",
              "type": "tuple"
            }
          ],
          "internalType": "struct DataTypes.SetFollowNFTURIWithSigData",
          "name": "vars",
          "type": "tuple"
        }
      ],
      "name": "setFollowNFTURIWithSig",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newGovernance",
          "type": "address"
        }
      ],
      "name": "setGovernance",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "profileId",
          "type": "uint256"
        },
        {
          "internalType": "string",
          "name": "imageURI",
          "type": "string"
        }
      ],
      "name": "setProfileImageURI",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "profileId",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "imageURI",
              "type": "string"
            },
            {
              "components": [
                {
                  "internalType": "uint8",
                  "name": "v",
                  "type": "uint8"
                },
                {
                  "internalType": "bytes32",
                  "name": "r",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "s",
                  "type": "bytes32"
                },
                {
                  "internalType": "uint256",
                  "name": "deadline",
                  "type": "uint256"
                }
              ],
              "internalType": "struct DataTypes.EIP712Signature",
              "name": "sig",
              "type": "tuple"
            }
          ],
          "internalType": "struct DataTypes.SetProfileImageURIWithSigData",
          "name": "vars",
          "type": "tuple"
        }
      ],
      "name": "setProfileImageURIWithSig",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum DataTypes.ProtocolState",
          "name": "newState",
          "type": "uint8"
        }
      ],
      "name": "setState",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "sigNonces",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "tokenByIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "tokenDataOf",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "uint96",
              "name": "mintTimestamp",
              "type": "uint96"
            }
          ],
          "internalType": "struct IERC721Time.TokenData",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "tokenOfOwnerByIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "tokenURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "collectModule",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "whitelist",
          "type": "bool"
        }
      ],
      "name": "whitelistCollectModule",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "followModule",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "whitelist",
          "type": "bool"
        }
      ],
      "name": "whitelistFollowModule",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "profileCreator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "whitelist",
          "type": "bool"
        }
      ],
      "name": "whitelistProfileCreator",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "referenceModule",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "whitelist",
          "type": "bool"
        }
      ],
      "name": "whitelistReferenceModule",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ]
  
'''
'''--- lens_protocol/api-polygon/mutations.js ---
const followUser = `
  mutation($request: FollowRequest!) { 
    createFollowTypedData(request: $request) {
      id
      expiresAt
      typedData {
        domain {
          name
          chainId
          version
          verifyingContract
        }
        types {
          FollowWithSig {
            name
            type
          }
        }
        value {
          nonce
          deadline
          profileIds
          datas
        }
      }
    }
  }
`;

const authenticate = `
  mutation Authenticate(
    $address: EthereumAddress!
    $signature: Signature!
  ) {
    authenticate(request: {
      address: $address,
      signature: $signature
    }) {
      accessToken
      refreshToken
    }
  }
`;

const refresh = `
  mutation Refresh(
    $refreshToken: Jwt!
  ) {
    refresh(request: {
      refreshToken: $refreshToken
    }) {
      accessToken
      refreshToken
    }
  }
`;

const broadcast = `
	mutation Broadcast($request: BroadcastRequest!) {
		broadcast(request: $request) {
			... on RelayerResult {
				txHash
			}
			... on RelayError {
				reason
			}
		}
	}
`;

/* UnfollowRequest
 * const unfollowRequestData = { profile: ProfileId! }
*/

const createUnfollowTypedData = `
  mutation($request: UnfollowRequest!) { 
    createUnfollowTypedData(request: $request) {
      id
      expiresAt
      typedData {
        domain {
          name
          chainId
          version
          verifyingContract
        }
        types {
          BurnWithSig {
            name
            type
          }
        }
        value {
          nonce
          deadline
          tokenId
        }
      }
    }
 }
`;

const createProfileMetadataTypedData = `
  mutation CreateSetProfileMetadataTypedData(
    $profileId: ProfileId!, $metadata: Url!
  ) 
  {
    createSetProfileMetadataTypedData(request: { profileId: $profileId, metadata: $metadata }) 
    {
      id
      expiresAt
      typedData {
        types {
          SetProfileMetadataURIWithSig {
            name
            type
          }
        }
        domain {
          name
          chainId
          version
          verifyingContract
        }
        value {
          nonce
          deadline
          profileId
          metadata
        }
      }
    }
  }
`;
const CREATE_SET_DEFAULT_PROFILE_TYPED_DATA = `
  mutation($request: CreateSetDefaultProfileRequest!) { 
    createSetDefaultProfileTypedData(request: $request) {
      id
      expiresAt
      typedData {
        types {
          SetDefaultProfileWithSig {
            name
            type
          }
        }
        domain {
          name
          chainId
          version
          verifyingContract
        }
        value {
          nonce
          deadline
          wallet
          profileId
        }
      }
    }
 }
 `;

export {
  followUser,
  authenticate,
  refresh,
  createUnfollowTypedData,
  broadcast,
  createProfileMetadataTypedData,
  CREATE_SET_DEFAULT_PROFILE_TYPED_DATA,
};

'''
'''--- lens_protocol/api-polygon/profile/apollo-client.ts ---
// this is showing you how you use it with react for example
// if your using node or something else you can import using
// @apollo/client/core!
import { ApolloClient, InMemoryCache, HttpLink, ApolloLink, from , DefaultOptions} from '@apollo/client'
// import {STORAGE_KEY} from '../../lens_protocol/api'
import AsyncStorage from '@react-native-async-storage/async-storage';
import { STORAGE_KEY } from '..';
export { gql } from '@apollo/client'

const httpLink = new HttpLink({ uri: 'https://api-mumbai.lens.dev/' });
let accessToken = '';

const defaultOptions: DefaultOptions = {
  watchQuery: {
    fetchPolicy: 'no-cache',
    errorPolicy: 'ignore',
  },
  query: {
    fetchPolicy: 'no-cache',
    errorPolicy: 'all',
  },
};

// example how you can pass in the x-access-token into requests using `ApolloLink`
const authLink = new ApolloLink((operation, forward) => {
  // Retrieve the authorization token from local storage.
  // if your using node etc you have to handle your auth different

  console.log("access token HEYOO1: ", accessToken)
  // Use the setContext method to set the HTTP headers.
  operation.setContext({
    headers: {
      'x-access-token': accessToken ? `Bearer ${accessToken}` : ''
    }
  });
  // Call the next link in the middleware chain.
  return forward(operation);
});

export async function apolloClient() {

  const storage = await AsyncStorage.getItem(STORAGE_KEY)
  if (storage != null)
  {
    const parsedStorage = JSON.parse(storage);
    accessToken = parsedStorage.accessToken
  }

  return new ApolloClient({
    link: from([authLink, httpLink]),
    cache: new InMemoryCache(),
    defaultOptions: defaultOptions,
  })
} 
'''
'''--- lens_protocol/api-polygon/profile/profiles.js ---
const createFreeFollowProfile = `
mutation CreateProfile 
{
    createProfile(request:{ 
                  handle: "devjoshstevens",
                  profilePictureUri: null,   
                  followModule: {
                       freeFollowModule: true
                    }
                  }) 
    {
      ... on RelayerResult 
        {
            txHash
        }
      ... on RelayError
        {
            reason
        }
      __typename
    }
}
`

const createNoFollowProfile = `
mutation CreateProfile {
    createProfile(request:{ 
                  handle: "devjoshstevens",
                  profilePictureUri: null,   
                  followModule: {
                       revertFollowModule: true
                    }
                  }) {
      ... on RelayerResult {
        txHash
      }
      ... on RelayError {
        reason
      }
      __typename
    }
  }
`

export {
    createFreeFollowProfile,
    createNoFollowProfile
}

'''
'''--- lens_protocol/api-polygon/queries.js ---
const recommendProfiles = `
  query RecommendedProfiles {
    recommendedProfiles {
        id
        name
        picture {
          ... on MediaSet {
            original {
              url
            }
          }
        }
        handle
        stats {
          totalFollowers
        }
    }
  }
`;

const getProfiles = `
  query Profiles($id: ProfileId!) {
    profiles(request: { profileIds: [$id], limit: 25 }) {
      items {
        id
        name
        bio
        attributes {
          displayType
          traitType
          key
          value
        }
        metadata
        isDefault
        picture {
          ... on NftImage {
            contractAddress
            tokenId
            uri
            verified
          }
          ... on MediaSet {
            original {
              url
              mimeType
            }
          }
          __typename
        }
        handle
        coverPicture {
          ... on NftImage {
            contractAddress
            tokenId
            uri
            verified
          }
          ... on MediaSet {
            original {
              url
              mimeType
            }
          }
          __typename
        }
        ownedBy
        dispatcher {
          address
          canUseRelay
        }
        stats {
          totalFollowers
          totalFollowing
          totalPosts
          totalComments
          totalMirrors
          totalPublications
          totalCollects
        }
      }
      pageInfo {
        prev
        next
        totalCount
      }
    }
  }
`;

const getDefaultProfile = `
query DefaultProfile($address: EthereumAddress!) {
  defaultProfile(request: { ethereumAddress: $address}) {
    id
    name
    bio
    isDefault
    attributes {
      displayType
      traitType
      key
      value
    }
    followNftAddress
    metadata
    handle
    picture {
      ... on NftImage {
        contractAddress
        tokenId
        uri
        chainId
        verified
      }
      ... on MediaSet {
        original {
          url
          mimeType
        }
      }
    }
    coverPicture {
      ... on NftImage {
        contractAddress
        tokenId
        uri
        chainId
        verified
      }
      ... on MediaSet {
        original {
          url
          mimeType
        }
      }
    }
    ownedBy
    dispatcher {
      address
      canUseRelay
    }
    stats {
      totalFollowers
      totalFollowing
      totalPosts
      totalComments
      totalMirrors
      totalPublications
      totalCollects
    }
    followModule {
      ... on FeeFollowModuleSettings {
        type
        contractAddress
        amount {
          asset {
            name
            symbol
            decimals
            address
          }
          value
        }
        recipient
      }
      ... on ProfileFollowModuleSettings {
       type
      }
      ... on RevertFollowModuleSettings {
       type
      }
    }
  }
}

`;

const getPublications = `
  query Publications($id: ProfileId!, $limit: LimitScalar) {
    publications(request: {
      profileId: $id,
      publicationTypes: [POST],
      limit: $limit
    }) {
      items {
        __typename 
        ... on Post {
          ...PostFields
        }
      }
    }
  }

  fragment PostFields on Post {
    id
    metadata {
      ...MetadataOutputFields
    }
    createdAt
  }

  fragment MetadataOutputFields on MetadataOutput {
    name
    description
    content
    media {
      original {
        ...MediaFields
      }
    }
    attributes {
      displayType
      traitType
      value
    }
  }

  fragment MediaFields on Media {
    url
    mimeType
  }
`;

const searchPublications = `query Search($query: Search!, $type: SearchRequestTypes!) {
  search(request: {
    query: $query,
    type: $type,
    limit: 10
  }) {
    ... on PublicationSearchResult {
      __typename 
     items {
       __typename 
       ... on Comment {
         ...CommentFields
       }
       ... on Post {
         ...PostFields
       }
     }
     pageInfo {
       prev
       totalCount
       next
     }
   }
  }
}

fragment MediaFields on Media {
  url
  mimeType
}

fragment MirrorBaseFields on Mirror {
  id
  profile {
    ...ProfileFields
  }
  stats {
    ...PublicationStatsFields
  }
  metadata {
    ...MetadataOutputFields
  }
  createdAt
  collectModule {
    ...CollectModuleFields
  }
  referenceModule {
    ... on FollowOnlyReferenceModuleSettings {
      type
    }
  }
  appId
}

fragment ProfileFields on Profile {
  profileId: id,
  name
  bio
  attributes {
     displayType
     traitType
     key
     value
  }
  metadata
  isDefault
  handle
  picture {
    ... on NftImage {
      contractAddress
      tokenId
      uri
      verified
    }
    ... on MediaSet {
      original {
        ...MediaFields
      }
    }
  }
  coverPicture {
    ... on NftImage {
      contractAddress
      tokenId
      uri
      verified
    }
    ... on MediaSet {
      original {
        ...MediaFields
      }
    }
  }
  ownedBy
  dispatcher {
    address
  }
  stats {
    totalFollowers
    totalFollowing
    totalPosts
    totalComments
    totalMirrors
    totalPublications
    totalCollects
  }
  followModule {
    ... on FeeFollowModuleSettings {
      type
      amount {
        asset {
          name
          symbol
          decimals
          address
        }
        value
      }
      recipient
    }
    ... on ProfileFollowModuleSettings {
     type
    }
    ... on RevertFollowModuleSettings {
     type
    }
  }
}

fragment PublicationStatsFields on PublicationStats { 
  totalAmountOfMirrors
  totalAmountOfCollects
  totalAmountOfComments
}

fragment MetadataOutputFields on MetadataOutput {
  name
  description
  content
  media {
    original {
      ...MediaFields
    }
  }
  attributes {
    displayType
    traitType
    value
  }
}

fragment Erc20Fields on Erc20 {
  name
  symbol
  decimals
  address
}

fragment CollectModuleFields on CollectModule {
  __typename
    ... on FreeCollectModuleSettings {
        type
    followerOnly
    contractAddress
  }
  ... on FeeCollectModuleSettings {
    type
    amount {
      asset {
        ...Erc20Fields
      }
      value
    }
    recipient
    referralFee
  }
  ... on LimitedFeeCollectModuleSettings {
    type
    collectLimit
    amount {
      asset {
        ...Erc20Fields
      }
      value
    }
    recipient
    referralFee
  }
  ... on LimitedTimedFeeCollectModuleSettings {
    type
    collectLimit
    amount {
      asset {
        ...Erc20Fields
      }
      value
    }
    recipient
    referralFee
    endTimestamp
  }
  ... on RevertCollectModuleSettings {
    type
  }
  ... on TimedFeeCollectModuleSettings {
    type
    amount {
      asset {
        ...Erc20Fields
      }
      value
    }
    recipient
    referralFee
    endTimestamp
  }
}

fragment PostFields on Post {
  id
  profile {
    ...ProfileFields
  }
  stats {
    ...PublicationStatsFields
  }
  metadata {
    ...MetadataOutputFields
  }
  createdAt
  collectModule {
    ...CollectModuleFields
  }
  referenceModule {
    ... on FollowOnlyReferenceModuleSettings {
      type
    }
  }
  appId
}

fragment CommentBaseFields on Comment {
  id
  profile {
    ...ProfileFields
  }
  stats {
    ...PublicationStatsFields
  }
  metadata {
    ...MetadataOutputFields
  }
  createdAt
  collectModule {
    ...CollectModuleFields
  }
  referenceModule {
    ... on FollowOnlyReferenceModuleSettings {
      type
    }
  }
  appId
}

fragment CommentFields on Comment {
  ...CommentBaseFields
  mainPost {
    ... on Post {
      ...PostFields
    }
    ... on Mirror {
      ...MirrorBaseFields
      mirrorOf {
        ... on Post {
           ...PostFields          
        }
        ... on Comment {
           ...CommentMirrorOfFields        
        }
      }
    }
  }
}

fragment CommentMirrorOfFields on Comment {
  ...CommentBaseFields
  mainPost {
    ... on Post {
      ...PostFields
    }
    ... on Mirror {
       ...MirrorBaseFields
    }
  }
}
`;

const searchProfiles = `
  query Search($query: Search!, $type: SearchRequestTypes!) {
    search(request: {
      query: $query,
      type: $type,
      limit: 10
    }) {
      ... on ProfileSearchResult {
        __typename 
        items {
          ... on Profile {
            ...ProfileFields
          }
        }
        pageInfo {
          prev
          totalCount
          next
        }
      }
    }
  }

  fragment MediaFields on Media {
    url
  }

  fragment ProfileFields on Profile {
    profileId: id,
    name
    bio
    attributes {
      displayType
      traitType
      key
      value
    }
    metadata
    isDefault
    handle
    picture {
      ... on NftImage {
        contractAddress
        tokenId
        uri
        verified
      }
      ... on MediaSet {
        original {
          ...MediaFields
        }
      }
    }

    stats {
      totalFollowers
      totalFollowing
    }
  }
`;

const explorePublications = `
  query {
    explorePublications(request: {
      sortCriteria: TOP_COMMENTED,
      publicationTypes: [POST, COMMENT, MIRROR],
      limit: 10
    }) {
      items {
        __typename 
        ... on Post {
          ...PostFields
        }
      }
    }
  }

  fragment ProfileFields on Profile {
    id
    name
    bio
    attributes {
      displayType
      traitType
      key
      value
    }
    metadata
    isDefault
    handle
    picture {
      ... on NftImage {
        contractAddress
        tokenId
        uri
        verified
      }
      ... on MediaSet {
        original {
          ...MediaFields
        }
        small {
          ...MediaFields
        }
        medium {
          ...MediaFields
        }
      }
    }
    coverPicture {
      ... on NftImage {
        contractAddress
        tokenId
        uri
        verified
      }
      ... on MediaSet {
        original {
          ...MediaFields
        }
        small {
         ...MediaFields
        }
        medium {
          ...MediaFields
        }
      }
    }
    ownedBy
    dispatcher {
      address
    }
    stats {
      totalFollowers
      totalFollowing
      totalPosts
      totalComments
      totalMirrors
      totalPublications
      totalCollects
    }
    followModule {
      ... on FeeFollowModuleSettings {
        type
        amount {
          asset {
            name
            symbol
            decimals
            address
          }
          value
        }
        recipient
      }
      ... on ProfileFollowModuleSettings {
       type
      }
      ... on RevertFollowModuleSettings {
       type
      }
    }
  }

  fragment MediaFields on Media {
    url
    width
    height
    mimeType
  }

  fragment PublicationStatsFields on PublicationStats { 
    totalAmountOfMirrors
    totalAmountOfCollects
    totalAmountOfComments
  }

  fragment MetadataOutputFields on MetadataOutput {
    name
    description
    content
    media {
      original {
        ...MediaFields
      }
      small {
        ...MediaFields
      }
      medium {
        ...MediaFields
      }
    }
    attributes {
      displayType
      traitType
      value
    }
  }

  fragment PostFields on Post {
    id
    profile {
      ...ProfileFields
    }
    stats {
      ...PublicationStatsFields
    }
    metadata {
      ...MetadataOutputFields
    }
    createdAt
    appId
  }
`;

const getChallenge = `
  query Challenge($address: EthereumAddress!) {
    challenge(request: { address: $address }) {
      text
    }
  }
`;

const doesFollow = `
  query($request: DoesFollowRequest!) {
    doesFollow(request: $request) { 
      followerAddress
      profileId
      follows
    }
  }
`;

const timeline = `
query Timeline($profileId: ProfileId!, $limit: LimitScalar) {
  timeline(request: { profileId: $profileId, limit: $limit }) {
    items {
      __typename 
      ... on Post {
        ...PostFields
      }
      ... on Comment {
        ...CommentFields
      }
      ... on Mirror {
        ...MirrorFields
      }
    }
    pageInfo {
      prev
      next
      totalCount
    }
  }
}

fragment MediaFields on Media {
  url
  mimeType
}

fragment ProfileFields on Profile {
  id
  name
  bio
  attributes {
    displayType
    traitType
    key
    value
  }
  isFollowedByMe
  isFollowing(who: null)
  followNftAddress
  metadata
  isDefault
  handle
  picture {
    ... on NftImage {
      contractAddress
      tokenId
      uri
      verified
    }
    ... on MediaSet {
      original {
        ...MediaFields
      }
    }
  }
  coverPicture {
    ... on NftImage {
      contractAddress
      tokenId
      uri
      verified
    }
    ... on MediaSet {
      original {
        ...MediaFields
      }
    }
  }
  ownedBy
  dispatcher {
    address
  }
  stats {
    totalFollowers
    totalFollowing
    totalPosts
    totalComments
    totalMirrors
    totalPublications
    totalCollects
  }
  followModule {
    ... on FeeFollowModuleSettings {
      type
      amount {
        asset {
          name
          symbol
          decimals
          address
        }
        value
      }
      recipient
    }
    ... on ProfileFollowModuleSettings {
     type
    }
    ... on RevertFollowModuleSettings {
     type
    }
  }
}

fragment PublicationStatsFields on PublicationStats { 
  totalAmountOfMirrors
  totalAmountOfCollects
  totalAmountOfComments
}

fragment MetadataOutputFields on MetadataOutput {
  name
  description
  content
  media {
    original {
      ...MediaFields
    }
  }
  attributes {
    displayType
    traitType
    value
  }
}

fragment Erc20Fields on Erc20 {
  name
  symbol
  decimals
  address
}

fragment CollectModuleFields on CollectModule {
  __typename
    ... on FreeCollectModuleSettings {
        type
    followerOnly
    contractAddress
  }
  ... on FeeCollectModuleSettings {
    type
    amount {
      asset {
        ...Erc20Fields
      }
      value
    }
    recipient
    referralFee
  }
  ... on LimitedFeeCollectModuleSettings {
    type
    collectLimit
    amount {
      asset {
        ...Erc20Fields
      }
      value
    }
    recipient
    referralFee
  }
  ... on LimitedTimedFeeCollectModuleSettings {
    type
    collectLimit
    amount {
      asset {
        ...Erc20Fields
      }
      value
    }
    recipient
    referralFee
    endTimestamp
  }
  ... on RevertCollectModuleSettings {
    type
  }
  ... on TimedFeeCollectModuleSettings {
    type
    amount {
      asset {
        ...Erc20Fields
      }
      value
    }
    recipient
    referralFee
    endTimestamp
  }
}

fragment PostFields on Post {
  id
  profile {
    ...ProfileFields
  }
  stats {
    ...PublicationStatsFields
  }
  metadata {
    ...MetadataOutputFields
  }
  createdAt
  collectModule {
    ...CollectModuleFields
  }
  referenceModule {
    ... on FollowOnlyReferenceModuleSettings {
      type
    }
  }
  appId
  collectedBy {
    ...WalletFields
  }
  hidden
  reaction(request: null)
  mirrors(by: null)
  hasCollectedByMe
}

fragment MirrorBaseFields on Mirror {
  id
  profile {
    ...ProfileFields
  }
  stats {
    ...PublicationStatsFields
  }
  metadata {
    ...MetadataOutputFields
  }
  createdAt
  collectModule {
    ...CollectModuleFields
  }
  referenceModule {
    ... on FollowOnlyReferenceModuleSettings {
      type
    }
  }
  appId
  hidden
  reaction(request: null)
  hasCollectedByMe
}

fragment MirrorFields on Mirror {
  ...MirrorBaseFields
  mirrorOf {
   ... on Post {
      ...PostFields          
   }
   ... on Comment {
      ...CommentFields          
   }
  }
}

fragment CommentBaseFields on Comment {
  id
  profile {
    ...ProfileFields
  }
  stats {
    ...PublicationStatsFields
  }
  metadata {
    ...MetadataOutputFields
  }
  createdAt
  collectModule {
    ...CollectModuleFields
  }
  referenceModule {
    ... on FollowOnlyReferenceModuleSettings {
      type
    }
  }
  appId
  collectedBy {
    ...WalletFields
  }
  hidden
  reaction(request: null)
  mirrors(by: null)
  hasCollectedByMe
}

fragment CommentFields on Comment {
  ...CommentBaseFields
  mainPost {
    ... on Post {
      ...PostFields
    }
    ... on Mirror {
      ...MirrorBaseFields
      mirrorOf {
        ... on Post {
           ...PostFields          
        }
        ... on Comment {
           ...CommentMirrorOfFields        
        }
      }
    }
  }
}

fragment CommentMirrorOfFields on Comment {
  ...CommentBaseFields
  mainPost {
    ... on Post {
      ...PostFields
    }
    ... on Mirror {
       ...MirrorBaseFields
    }
  }
}

fragment WalletFields on Wallet {
   address,
   defaultProfile {
    ...ProfileFields
   }
}
`;

/*
* const doesFollowRequest = {
*   followInfos: [{ followerAddress: EthereumAddress!, profileId: ProfileId! }]
*  }
*/

export {
  recommendProfiles,
  getProfiles,
  getDefaultProfile,
  getPublications,
  searchProfiles,
  searchPublications,
  explorePublications,
  doesFollow,
  getChallenge,
  timeline,
};

'''
'''--- lens_protocol/api-polygon/utils.js ---
/* eslint-disable no-console */
/* eslint-disable max-len */
/* eslint-disable consistent-return */
import { ethers, utils } from 'ethers';
import omitDeep from 'omit-deep';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { refresh as refreshMutation, CREATE_SET_DEFAULT_PROFILE_TYPED_DATA } from './mutations';
import {
  createClient, basicClient, STORAGE_KEY, LENS_HUB_CONTRACT_ADDRESS, LENS_HUB_ABI,
} from '.';

export function trimString(string, length) {
  if (!string) return null;
  return string.length < length ? string : `${string.substr(0, length - 1)}...`;
}

export function parseJwt(token) {
  const base64Url = token.split('.')[1];
  const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
  const jsonPayload = decodeURIComponent(atob(base64).split('').map((c) => `%${(`00${c.charCodeAt(0).toString(16)}`).slice(-2)}`).join(''));

  return JSON.parse(jsonPayload);
}

export async function refreshAuthToken() {
  console.log('Z: ');
  const {accessToken, address} = await AsyncStorage.getItem(STORAGE_KEY);
  console.log('A: ', accessToken);
  if (!accessToken) return;

  console.log('A');
  try {
    const authData = await basicClient.mutation(refreshMutation, {
      refreshToken: token.refreshToken,
    }).toPromise();
    console.log('b');
    if (!authData.data) return;

    const { accessToken, refreshToken } = authData.data.refresh;
    const { exp } = parseJwt(refreshToken);
    console.log('C');
    try {
      await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify({
        accessToken, refreshToken, exp, address
      }));
    } catch (err) {
      console.log('error: AsyncStorage _ ', err);
    }

    return {
      accessToken,
    };
  } catch (err) {
    console.log('error refreshAuthToken:', err);
  }
}

// export function getSigner() {
//   const provider = new ethers.providers.Web3Provider(window.ethereum);
//   return provider.getSigner();
// }

export function signedTypeData(domain, types, value, signer) {
  // eslint-disable-next-line no-underscore-dangle
  return signer._signTypedData(
    omitDeep(domain, '__typename'),
    omitDeep(types, '__typename'),
    omitDeep(value, '__typename'),
  );
}

export function splitSignature(signature) {
  return utils.splitSignature(signature);
}

export const lensHub = (signer) => new ethers.Contract(
  LENS_HUB_CONTRACT_ADDRESS,
  LENS_HUB_ABI,
  signer,
);

export async function setDefaultProfile(signer) {
  // console.log('my signer: inside set defaultProfile', signer);

  
  // const storageData = await AsyncStorage.getItem(STORAGE_KEY);
  // const storageDataParsed = JSON.parse(storageData);

  // console.log('storageDataParsed in  setDefaultProfile: ', storageDataParsed);

  // if (storageDataParsed) {
    // const {signer} = storageDataParsed

        console.log('signer setDefaultProfile: ', signer);

    const setDefaultProfileRequest = {
      profileId: '0x443c', // handle normanlopez349
    };
    const urqlClient = await createClient();
    const result = await urqlClient.mutation(CREATE_SET_DEFAULT_PROFILE_TYPED_DATA, {
      request: setDefaultProfileRequest,
    }).toPromise();
  
    // console.log('result setDefaultProfile: ', result);
  
    const { typedData } = result.data.createSetDefaultProfileTypedData;
  
    const signature = await signedTypeData(typedData.domain, typedData.types, typedData.value, signer);
    const { v, r, s } = splitSignature(signature);
  
    const tx = await lensHub(signer).setDefaultProfileWithSig({
      profileId: typedData.value.profileId,
      wallet: typedData.value.wallet,
      sig: {
        v,
        r,
        s,
        deadline: typedData.value.deadline,
      },
    });
    console.log('default profile tx hash ', tx.hash);

  // }  
}

export function generateRandomColor() {
  const maxVal = 0xFFFFFF; // 16777215
  let randomNumber = Math.random() * maxVal;
  randomNumber = Math.floor(randomNumber);
  randomNumber = randomNumber.toString(16);
  const randColor = randomNumber.padStart(6, 0);
  return `#${randColor.toUpperCase()}`;
}

export const baseMetadata = {
  version: '1.0.0',
  image: null,
  imageMimeType: null,
  mainContentFocus: 'TEXT',
  contentWarning: null,
  location: '',
  cover_picture: '',
  attributes: [
    {
      traitType: 'string',
      key: 'type',
      value: 'post',
    },
  ],
  media: [],
  appId: 'NaderDabitLensStarter',
};

'''
'''--- lens_protocol/aurora/authenticate.ts ---
import { ethers } from "ethers";
import WalletConnectProvider from '@walletconnect/web3-provider';

export const getSigner = async (connector: any) => {
    try {
        const provider = new WalletConnectProvider({
            rpc: {
                1313161555: 'https://testnet.aurora.dev',
            },
            chainId: 1313161555,
            connector,
            qrcode: false,
        });

        await provider.enable();
        const ethersProvider = new ethers.providers.Web3Provider(provider);
        const signer = ethersProvider.getSigner();
        return signer
    } catch (err) {
        console.log('error signIn: ', err);
    }
};
'''
'''--- lens_protocol/aurora/challenge.ts ---

import { gql } from 'urql';
import { apolloClient } from './index';

const getChallenge = `
query Query($request: ChallengeRequest!) {
    challenge(request: $request) {
      text
    }
  }
`

const request = {
      "address": "hey POSTMAN!!"
}

export async function fetchChallenge() {
    try {
      const returnedChallenge = await apolloClient.query(
        {
          query: gql(getChallenge),
          variables: {
            request
          },
        }
      )
      const challengeText = returnedChallenge.data.challenge.text;
      console.log("What was my challenge? " + JSON.stringify(challengeText))
    } catch (err) {
      console.log('error fetching profile...', err);
    }
}
// fetchChallenge();
'''
'''--- lens_protocol/aurora/client.ts ---
import { Client} from 'urql';
import { ApolloClient, InMemoryCache} from '@apollo/client'
export { gql } from '@apollo/client'
import 'cross-fetch/polyfill';

export const APIURL = 'https://iiomqabbrc.execute-api.us-east-1.amazonaws.com/prod'
export const apolloClient = new ApolloClient({
  uri: APIURL,
  cache: new InMemoryCache(),
})

export const basicClient = new Client({ url: APIURL});
'''
'''--- lens_protocol/aurora/index.ts ---
import { ethers } from 'ethers';
import { LENS_HUB_ABI } from '../api-polygon';
export { getSigner } from './authenticate';

export {basicClient, APIURL, apolloClient} from './client'

export const LENS_CREATE_PROFILE_CONTRACT_ADDRESS_AURORA = '0x5E10f82E63d4c3c5ce26e2258E168C148692211e'
export const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';

export const lensHub = (signer: any) => new ethers.Contract(
    LENS_CREATE_PROFILE_CONTRACT_ADDRESS_AURORA,
    LENS_HUB_ABI,
    signer,
  );
'''
'''--- lens_protocol/aurora/profiles.ts ---

import { gql } from 'urql';
import { apolloClient } from './index';

const request = {
    "ethereumAddress": "0xe0E040ADe1B1F23BbFaa2a22235Cc692310a40Ab"
};
const getDefaultProfile = `
query DefaultProfile($request: DefaultProfileRequest!) {
    defaultProfile(request: $request) {
      id
      handle
      coverPicture {
        ... on MediaSet {
          original {
            url
          }
        }
      }
    }
  }
  `
export async function fetchDefaultProfile(address:string) {
    try {
        const returnedDefaultProfile = await apolloClient.query(
            {
                query: gql(getDefaultProfile),
                variables: {
                    request: {"ethereumAddress": address}
                },
            }
        )
        const response = returnedDefaultProfile.data.defaultProfile;
        //   console.log("Default Profile? " + JSON.stringify(response))
        return response;
    } catch (err) {
        console.log('error fetching profile...', err);
    }
}
'''
'''--- metro.config.js ---
const crypto = require.resolve('crypto-browserify');
const url = require.resolve('url/');
module.exports = {
  resolver: {
    extraNodeModules: {
      crypto,
      url,
      fs: require.resolve('expo-file-system'),
      http: require.resolve('stream-http'),
      https: require.resolve('https-browserify'),
      net: require.resolve('react-native-tcp'),
      os: require.resolve('os-browserify/browser.js'),
      path: require.resolve('path-browserify'),
      stream: require.resolve('readable-stream'),
      vm: require.resolve('vm-browserify'),
    },
    sourceExts: ['jsx', 'js', 'ts', 'tsx', 'cjs'],
  },
};
'''
'''--- mocks/contact.json ---
{
  "name": "Darrell Schmeler",
  "username": "Leola_VonRueden",
  "address": {
    "streetA": "Abbott Shoals",
    "streetB": "505 Winona Place",
    "streetC": "4306 Hudson Street Suite 875",
    "streetD": "Suite 489",
    "city": "Ginatown",
    "state": "Massachusetts",
    "country": "Nepal",
    "zipcode": "41428-0189",
    "geo": {
      "lat": "-75.8513",
      "lng": "81.3262"
    }
  },
  "website": "destany.org",
  "bio":
    "Web & Mobile UI/UX designer, Motion designer following the latest ui & ux trends",
  "company": {
    "name": "Streich, Harber and Hilpert",
    "catchPhrase": "Team-oriented hybrid neural-net",
    "bs": "user-centric embrace vortals"
  },
  "avatar": "https://i.imgur.com/GfkNpVG.jpg",
  "avatarBackground":
    "https://i.imgur.com/rXVcgTZ.jpg",
  "tels": [
    { "id": 1, "name": "Mobile", "number": "+66 (089)-928-2134" },
    { "id": 2, "name": "Work", "number": "+41 (112)-435-9887" }
  ],
  "emails": [
    { "id": 1, "name": "Personal", "email": "elsie-goodman@mail.com" },
    { "id": 2, "name": "Work", "email": "elsie@work.com" }
  ],
  "posts": [
    {
      "id": 1,
      "words": "cupiditate qui cum",
      "sentence": "Ipsum laborum quasi debitis dolores veniam.",
      "sentences":
        "Impedit veritatis harum nihil dolores dolorem optio assumenda. Laborum saepe voluptas officia odit. Ut voluptas mollitia mollitia eum autem quisquam qui aut. Et ipsa hic harum molestias et quam qui cum. Sint sit soluta.",
      "paragraph":
        "Beatae voluptas ea magni quibusdam dolorem sit aut qui. Dolorem rerum et consequuntur inventore officia excepturi dolore architecto fuga. Quia consequatur asperiores rerum qui corporis dolorum. At harum velit adipisci iste odit modi veniam ut. Deserunt quibusdam velit non ea.",
      "image":
        "https://d25tv1xepz39hi.cloudfront.net/2016-12-19/files/foodphotoghacks_image8.jpg",
      "createdDate": "2017-11-21T02:33:53.770Z",
      "user": {
        "name": "Ronaldo",
        "username": "Ronaldo.Effertz",
        "avatar":
          "https://s3.amazonaws.com/uifaces/faces/twitter/samuelkraft/128.jpg",
        "email": "Ronaldo.Effertz.Deckow@hotmail.com"
      }
    },
    {
      "id": 2,
      "words": "est voluptatum aut",
      "sentence": "Omnis omnis aut dolor quaerat sunt et optio.",
      "sentences":
        "Nam numquam magni saepe. Deserunt aspernatur dolorem libero soluta sint molestias et sint sed. Maiores id quis assumenda voluptates quos ut saepe officia voluptatem. Ea placeat sed ut. Modi sed earum voluptas cumque unde eum doloribus ipsam.",
      "paragraph":
        "Quam aut reprehenderit asperiores aut. Sunt quis aspernatur incidunt. Illo et perferendis ex incidunt eos ut maxime dolorem voluptatem. Qui rem nihil quos cumque eum doloribus. Quae beatae tempore commodi.",
      "createdDate": "2017-11-20T18:04:58.858Z",
      "user": {
        "name": "Markus",
        "username": "Markus.Price68",
        "avatar":
          "https://s3.amazonaws.com/uifaces/faces/twitter/kikillo/128.jpg",
        "email": "Markus.Price68.Dicki@yahoo.com"
      }
    },
    {
      "id": 3,
      "words": "vitae voluptas quia",
      "sentence": "Voluptates dolor ad rem amet voluptas.",
      "sentences":
        "Rem ipsum quis. Animi ipsum ut at possimus. Beatae molestiae non odio soluta quidem ut suscipit.",
      "paragraph":
        "Veniam veritatis nihil illum rerum et. Temporibus facere sed delectus corporis alias. Et odio aliquid est. Quas sit et quia tempora sit eveniet quam.",
      "createdDate": "2017-03-24T10:56:15.461Z",
      "image": "https://touristmeetstraveler.com/wp-content/uploads/sushi.jpg",
      "user": {
        "name": "Magali",
        "username": "Magali16",
        "avatar":
          "https://s3.amazonaws.com/uifaces/faces/twitter/mastermindesign/128.jpg",
        "email": "Magali1664@gmail.com"
      }
    }
  ]
}

'''
'''--- navigation/LinkingConfiguration.ts ---
/**
 * Learn more about deep linking with React Navigation
 * https://reactnavigation.org/docs/deep-linking
 * https://reactnavigation.org/docs/configuring-links
 */

import { LinkingOptions } from '@react-navigation/native';
import * as Linking from 'expo-linking';

import { RootStackParamList } from '../types';

const linking: LinkingOptions<RootStackParamList> = {
  prefixes: [Linking.makeUrl('/')],
  config: {
    screens: {
      Root: {
        screens: {
          TabOne: {
            screens: {
              TabOneScreen: 'one',
            },
          },
          TabTwo: {
            screens: {
              TabTwoScreen: 'two',
            },
          },
        },
      },
      Modal: 'modal',
      NotFound: '*',
    },
  },
};

export default linking;

'''
'''--- package.json ---
{
  "name": "test-dapp",
  "version": "1.0.1",
  "main": "index.js",
  "scripts": {
    "start": "expo start --tunnel",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "eject": "expo eject",
    "test": "jest --watchAll"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@apollo/client": "^3.5.10",
    "@ethersproject/shims": "^5.7.0",
    "@expo/ngrok": "^2.5.0",
    "@expo/vector-icons": "^12.0.0",
    "@react-native-async-storage/async-storage": "~1.15.0",
    "@react-navigation/bottom-tabs": "^6.0.5",
    "@react-navigation/native": "^6.0.2",
    "@react-navigation/native-stack": "^6.1.0",
    "@react-navigation/stack": "^6.2.2",
    "@urql/exchange-auth": "^0.1.7",
    "@walletconnect/react-native-dapp": "^1.7.0",
    "@walletconnect/web3-provider": "^1.8.0",
    "@web3auth/base": "^2.1.2",
    "@web3auth/react-native-sdk": "^3.1.0",
    "@web3auth/web3auth": "^2.1.2",
    "axios": "^0.27.2",
    "base-64": "^1.0.0",
    "crypto-browserify": "^3.12.0",
    "ethers": "^5.6.9",
    "expo": "~44.0.0",
    "expo-asset": "~8.4.4",
    "expo-barcode-scanner": "~11.2.0",
    "expo-constants": "~13.0.0",
    "expo-font": "~10.0.4",
    "expo-image-picker": "~12.0.1",
    "expo-linking": "~3.0.0",
    "expo-splash-screen": "~0.14.0",
    "expo-status-bar": "~1.2.0",
    "expo-updates": "~0.11.7",
    "expo-web-browser": "~10.1.0",
    "graphql": "^16.6.0",
    "https-browserify": "^1.0.0",
    "node-libs-react-native": "^1.2.1",
    "omit-deep": "^0.3.0",
    "os-browserify": "^0.3.0",
    "path-browserify": "^1.0.1",
    "react": "18.2.0",
    "react-dom": "17.0.1",
    "react-native": "0.64.3",
    "react-native-elements": "^3.4.2",
    "react-native-gesture-handler": "~2.1.0",
    "react-native-get-random-values": "~1.7.0",
    "react-native-pager-view": "5.4.9",
    "react-native-qrcode-svg": "^6.1.2",
    "react-native-safe-area-context": "3.3.2",
    "react-native-screens": "~3.10.1",
    "react-native-select-dropdown": "^2.0.4",
    "react-native-tab-view": "^3.1.1",
    "react-native-tcp": "^4.0.0",
    "react-native-web": "0.17.1",
    "react-native-webview": "11.15.0",
    "readable-stream": "^3.6.0",
    "stream-http": "^3.2.0",
    "urql": "^3.0.1",
    "vm-browserify": "^1.1.2",
    "web3-auth": "^1.1.0",
    "xml2js": "^0.4.23"
  },
  "devDependencies": {
    "@babel/core": "^7.12.9",
    "@types/react": "^18.0.17",
    "@types/react-native": "~0.64.12",
    "@types/xml2js": "^0.4.11",
    "@typescript-eslint/eslint-plugin": "^5.33.1",
    "@typescript-eslint/parser": "^5.33.1",
    "eslint": "^8.22.0",
    "eslint-config-airbnb": "^19.0.4",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-jsx-a11y": "^6.6.1",
    "eslint-plugin-react": "^7.30.1",
    "eslint-plugin-react-hooks": "^4.6.0",
    "jest": "^26.6.3",
    "jest-expo": "~44.0.1",
    "react-test-renderer": "17.0.1",
    "typescript": "~4.3.5"
  },
  "resolutions": {
    "react-native-svg": "12.3.0",
    "react-native-qrcode-svg": "6.1.2",
    "@types/react": "18.0.19"
  },
  "private": true
}

'''
'''--- plugins/network_security_config.xml ---
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <base-config cleartextTrafficPermitted="true">
        <trust-anchors>
            <certificates src="system" />
            <certificates src="user" />
        </trust-anchors>
    </base-config>
</network-security-config>
'''
'''--- plugins/trust-local-certs.js ---
const {AndroidConfig, withAndroidManifest } = require('@expo/config-plugins');
const {Paths} = require('@expo/config-plugins/build/android');
const path = require('path');
const fs = require('fs');
const fsPromises = fs.promises;

const { getMainApplicationOrThrow} = AndroidConfig.Manifest

const withTrustLocalCerts = config => {
    return withAndroidManifest(config, async config => {
        config.modResults = await setCustomConfigAsync(config, config.modResults);
        return config;
    });
}

async function setCustomConfigAsync(
    config,
    androidManifest
) {

    const src_file_pat = path.join(__dirname, "network_security_config.xml");
    const res_file_path = path.join(await Paths.getResourceFolderAsync(config.modRequest.projectRoot),
        "xml", "network_security_config.xml");

    const res_dir = path.resolve(res_file_path, "..");

    if (!fs.existsSync(res_dir)) {
        await fsPromises.mkdir(res_dir);
    }

    try {
        await fsPromises.copyFile(src_file_pat, res_file_path);
    } catch (e) {
        throw e;
    }

    const mainApplication = getMainApplicationOrThrow(androidManifest);
    mainApplication.$["android:networkSecurityConfig"] = "@xml/network_security_config";

    return androidManifest;
}

module.exports = withTrustLocalCerts;
'''
'''--- screens/ExploreProfiles/RecommendedProfile.js ---
import React from 'react'
import { Dimensions, Image, View, Text, StyleSheet } from 'react-native'
import { Avatar } from 'react-native-elements'
import PropTypes from 'prop-types'

import { datetime } from '../../utils'

const styles = StyleSheet.create({
  container: {
    borderWidth: 0,
    justifyContent: 'space-between',
    marginBottom: 5,
    marginLeft: 12,
    marginRight: 12,
    marginTop: 10,
    padding: 0,
  },
  date: {
    color: 'gray',
    fontSize: 12.5,
  },
  postRow: {
    alignItems: 'center',
    flexDirection: 'row',
    paddingBottom: 6,
    paddingLeft: 15,
    paddingRight: 15,
    paddingTop: 6,
    width: Dimensions.get('window').width * 1,
  },
  postImage: {
    backgroundColor: 'rgba(0, 0, 0, 0.075)',
    height: 200,
  },
  userImage: {
    marginRight: 12,
  },
  wordRow: {
    marginBottom: 10,
    paddingLeft: 15,
    paddingRight: 15,
    paddingTop: 6,
  },
  wordText: {
    fontSize: 14,
    fontWeight: '500',
    lineHeight: 22,
  },
})

const RecommendedProfile = (profile) => {

  // console.log("profile in Post: ", profile)

  return (
    <View style={[styles.container]}>
      <View style={styles.postRow}>
        <View style={styles.userImage}>
          
        {profile.picture && profile.picture.original ?
          (<Avatar
            rounded
            size="medium"
            source={{
              uri: profile.picture.original.url ,
            }}
          />) : (
            <Avatar
            rounded
            size="medium"
            source={{
              uri: "./assets/images/placeholder_avatar.jpeg" ,
            }}
          />
          )
        } 
        </View>
        <View>
          <Text>{profile.name}</Text>
          <Text style={styles.date}>
            {profile.handle}
          </Text>
        </View>
      </View>
      {/* <View style={styles.wordRow}>
    <Text style={styles.wordText}>{sentences}</Text>
  </View> */}
      {/* {image && <Image style={styles.postImage} source={{uri: image}} />} */}
    </View>
  )
}

// Post.propTypes = {
//   containerStyle: PropTypes.oneOfType([PropTypes.object, PropTypes.number]),
//   image: PropTypes.string,
//   user: PropTypes.shape({
//     name: PropTypes.string.isRequired,
//     avatar: PropTypes.string.isRequired,
//   }).isRequired,
//   createdDate: PropTypes.string.isRequired,
//   sentences: PropTypes.string.isRequired,
// }

// Post.defaultProps = {
//   containerStyle: {},
//   image: null,
// }

export default RecommendedProfile

'''
'''--- screens/ExploreProfiles/styles.js ---
import { Dimensions, StyleSheet } from 'react-native'

export const styles = StyleSheet.create({
    container: {
        borderWidth: 0,
        justifyContent: 'space-between',
        marginBottom: 5,
        marginLeft: 12,
        marginRight: 12,
        marginTop: 10,
        padding: 0,
    },
    date: {
        color: 'gray',
        fontSize: 12.5,
    },
    postRow: {
        alignItems: 'center',
        flexDirection: 'row',
        paddingBottom: 6,
        paddingLeft: 15,
        paddingRight: 15,
        paddingTop: 6,
        width: Dimensions.get('window').width * 1,
    },
    postImage: {
        backgroundColor: 'rgba(0, 0, 0, 0.075)',
        height: 200,
    },
    userImage: {
        marginRight: 12,
    },
    wordRow: {
        marginBottom: 10,
        paddingLeft: 15,
        paddingRight: 15,
        paddingTop: 6,
    },
    wordText: {
        fontSize: 14,
        fontWeight: '500',
        lineHeight: 22,
    },
})

export const RecommendedProfileStyles = StyleSheet.create({
    container: {
        borderWidth: 0,
        justifyContent: 'space-between',
        marginBottom: 5,
        marginLeft: 12,
        marginRight: 12,
        marginTop: 10,
        padding: 0,
    },
    date: {
        color: 'gray',
        fontSize: 12.5,
    },
    postRow: {
        alignItems: 'center',
        flexDirection: 'row',
        paddingBottom: 6,
        paddingLeft: 15,
        paddingRight: 15,
        paddingTop: 6,
        width: Dimensions.get('window').width * 1,
    },
    postImage: {
        backgroundColor: 'rgba(0, 0, 0, 0.075)',
        height: 200,
    },
    userImage: {
        marginRight: 12,
    },
    wordRow: {
        marginBottom: 10,
        paddingLeft: 15,
        paddingRight: 15,
        paddingTop: 6,
    },
    wordText: {
        fontSize: 14,
        fontWeight: '500',
        lineHeight: 22,
    },
})

export const flatListStyles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: "#192338",
        paddingVertical: 50,
        position: "relative"
    },
    title: {
        fontSize: 20,
        color: "#fff",
        textAlign: "center",
        marginBottom: 10
    },
    loader: {
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
        backgroundColor: "#fff"
    },
    list: {
        paddingVertical: 5,
        margin: 3,
        flexDirection: "row",
        backgroundColor: "#192338",
        justifyContent: "flex-start",
        alignItems: "center",
        zIndex: -1
    },
    lightText: {
        color: "#f7f7f7",
        width: 200,
        paddingLeft: 15,
        fontSize: 12
    },
    line: {
        height: 0.5,
        width: "100%",
        backgroundColor: "rgba(1,1,255,1)"
        // color: "rgba(1,1,255,1)"
    },
    icon: {
        position: "absolute",
        bottom: 20,
        width: "100%",
        left: 290,
        zIndex: 1
    },
    numberBox: {
        position: "absolute",
        bottom: 75,
        width: 30,
        height: 30,
        borderRadius: 15,
        left: 330,
        zIndex: 3,
        backgroundColor: "#e3e3e3",
        justifyContent: "center",
        alignItems: "center"
    },
    number: { fontSize: 14, color: "#000" },
    selected: { backgroundColor: "#FA7B5F" },
});

export const modalStyles = StyleSheet.create({
    centeredView: {
      flex: 1,
      justifyContent: "center",
      alignItems: "center",
      marginTop: 22
    },
    modalView: {
      margin: 20,
      backgroundColor: "white",
      borderRadius: 20,
      padding: 35,
      alignItems: "center",
      shadowColor: "#000",
      shadowOffset: {
        width: 0,
        height: 2
      },
      shadowOpacity: 0.25,
      shadowRadius: 4,
      elevation: 5
    },
    button: {
      borderRadius: 20,
      marginTop: 10,
      padding: 10,
      elevation: 2
    },
    buttonOpen: {
      backgroundColor: "#F194FF",
    },
    buttonClose: {
      backgroundColor: "#2196F3",
    },
    textStyle: {
      color: "white",
      fontWeight: "bold",
      textAlign: "center"
    },
    modalText: {
      marginBottom: 15,
      textAlign: "center"
    }
  });
'''
'''--- screens/Profile/style.js ---
import { StyleSheet } from 'react-native'

export const styles = StyleSheet.create({
    cardContainer: {
      flex: 1,
    },
    container: {
      flex: 1,
    },
    headerContainer: {
      alignItems: 'center',
      backgroundColor: '#FFF',
      marginBottom: 10,
      marginTop: 45,
      paddingTop: 45
    },
    indicatorTab: {
      backgroundColor: 'transparent',
    },
    scroll: {
      backgroundColor: '#FFF',
    },
    sceneContainer: {
      marginTop: 10,
    },
    socialIcon: {
      marginLeft: 14,
      marginRight: 14,
    },
    socialRow: {
      flexDirection: 'row',
    },
    tabBar: {
      backgroundColor: '#EEE',
    },
    tabContainer: {
      flex: 1,
      marginBottom: 12,
    },
    tabLabelNumber: {
      color: 'gray',
      fontSize: 12.5,
      textAlign: 'center',
    },
    tabLabelText: {
      color: 'black',
      fontSize: 22.5,
      fontWeight: '600',
      textAlign: 'center',
    },
    userBioRow: {
      marginLeft: 40,
      marginRight: 40,
    },
    userBioText: {
      color: 'gray',
      fontSize: 13.5,
      textAlign: 'center',
    },
    userImage: {
      borderRadius: 60,
      height: 120,
      marginBottom: 10,
      width: 120,
    },
    userNameRow: {
      marginBottom: 10,
    },
    userNameText: {
      color: '#5B5A5A',
      fontSize: 18,
      fontWeight: 'bold',
      textAlign: 'center',
    },
    hyperlinked: {
      color: 'blue'
    },
    userRow: {
      alignItems: 'center',
      flexDirection: 'column',
      justifyContent: 'center',
      marginBottom: 12,
    },
  })
'''
'''--- tsconfig.json ---
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "jsx": "react",
    "strict": true
  }
}

'''
'''--- utils/datetime.js ---
const timeDifference = (current, previous) => {
  const milliSecondsPerMinute = 60 * 1000
  const milliSecondsPerHour = milliSecondsPerMinute * 60
  const milliSecondsPerDay = milliSecondsPerHour * 24
  const milliSecondsPerMonth = milliSecondsPerDay * 30
  const milliSecondsPerYear = milliSecondsPerDay * 365

  const elapsed = current - previous

  if (elapsed < milliSecondsPerMinute / 3) {
    return 'just now'
  }

  if (elapsed < milliSecondsPerMinute) {
    return 'less than 1 min'
  } else if (elapsed < milliSecondsPerHour) {
    return Math.round(elapsed / milliSecondsPerMinute) + ' min'
  } else if (elapsed < milliSecondsPerDay) {
    return Math.round(elapsed / milliSecondsPerHour) + ' h'
  } else if (elapsed < milliSecondsPerMonth) {
    let days = Math.round(elapsed / milliSecondsPerDay)
    return `${days} day${days > 1 ? 's' : ''}`
  } else if (elapsed < milliSecondsPerYear) {
    return Math.round(elapsed / milliSecondsPerMonth) + ' mo'
  } else {
    return Math.round(elapsed / milliSecondsPerYear) + ' years'
  }
}

const timeDifferenceForDate = date => {
  const now = new Date().getTime()
  const updated = new Date(date).getTime()

  return timeDifference(now, updated)
}

export { timeDifference, timeDifferenceForDate }

'''
'''--- utils/image.js ---
const mansonry = (items, propName) => {
  return items.reduce(
    (p, c, k) => {
      if (k > 1) {
        if (p.leftHeight <= p.rightHeight) {
          return {
            ...p,
            leftCol: [...p.leftCol, c],
            leftHeight: p.leftHeight + c[propName],
          }
        } else {
          return {
            ...p,
            rightCol: [...p.rightCol, c],
            rightHeight: p.rightHeight + c[propName],
          }
        }
      } else {
        return p
      }
    },
    {
      leftCol: [items[0]],
      rightCol: [items[1]],
      leftHeight: items[0].imageHeight,
      rightHeight: items[1].imageHeight,
    }
  )
}

export { mansonry }

'''
'''--- utils/index.js ---
import * as datetime from './datetime'
import * as image from './image'

export { datetime, image }

'''