*GitHub Repository "00labs/requestNetwork"*

'''--- packages/advanced-logic/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
};

'''
'''--- packages/currency/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
};

'''
'''--- packages/data-access/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
};

'''
'''--- packages/data-format/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
};

'''
'''--- packages/epk-decryption/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
};

'''
'''--- packages/epk-decryption/webpack.config.js ---
/**
 * This is to generate the umd bundle only
 * From https://github.com/0xProject/0x-monorepo/blob/development/packages/0x.js/webpack.config.js
 */
const path = require('path');
const TerserPlugin = require('terser-webpack-plugin');
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
const DuplicatePackageCheckerPlugin = require('duplicate-package-checker-webpack-plugin');

module.exports = {
  entry: {
    'epk-decryption.min': './src/index.ts',
  },
  mode: 'production',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js',
    libraryTarget: 'umd',
    library: 'EthereumPrivateKeyDecryptionProvider',
    umdNamedDefine: true,
  },
  resolve: {
    extensions: ['.ts', '.js', '.json'],
  },
  devtool: 'source-map',
  optimization: {
    minimizer: [new TerserPlugin({ sourceMap: true })],
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: [
          {
            loader: 'ts-loader',
            options: {
              configFile: 'tsconfig.build.json',
            },
          },
        ],
        exclude: /node_modules/,
      },
    ],
  },
  plugins: [
    new BundleAnalyzerPlugin({ analyzerMode: 'static', openAnalyzer: false }),
    new DuplicatePackageCheckerPlugin(),
  ],
};

'''
'''--- packages/epk-signature/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
};

'''
'''--- packages/epk-signature/webpack.config.js ---
/**
 * This is to generate the umd bundle only
 * From https://github.com/0xProject/0x-monorepo/blob/development/packages/0x.js/webpack.config.js
 */
const path = require('path');
const TerserPlugin = require('terser-webpack-plugin');
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
const DuplicatePackageCheckerPlugin = require('duplicate-package-checker-webpack-plugin');

module.exports = {
  entry: {
    'epk-signature.min': './src/index.ts',
  },
  mode: 'production',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js',
    libraryTarget: 'umd',
    library: 'EthereumPrivateKeySignatureProvider',
    umdNamedDefine: true,
  },
  resolve: {
    extensions: ['.ts', '.js', '.json'],
  },
  devtool: 'source-map',
  optimization: {
    minimizer: [new TerserPlugin({ sourceMap: true })],
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: [
          {
            loader: 'ts-loader',
            options: {
              configFile: 'tsconfig.build.json',
            },
          },
        ],
        exclude: /node_modules/,
      },
    ],
  },
  plugins: [
    new BundleAnalyzerPlugin({ analyzerMode: 'static', openAnalyzer: false }),
    new DuplicatePackageCheckerPlugin(),
  ],
};

'''
'''--- packages/ethereum-storage/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
};

'''
'''--- packages/ethereum-storage/scripts/init-ipfs.js ---
const shell = require('shelljs');
const fs = require('fs');
const path = require('path');

const argv = require('yargs')
  .usage('Usage: $0 [options]')
  // Allow the user to force IPFS config override
  .option('force', {
    alias: 'f',
    describe: 'Force the private IPFS config even if a config already exists',
    type: 'boolean',
  })
  // Get IPFS path from cli argument, environment variable or expected default path
  .option('path', {
    alias: 'p',
    describe:
      'The path to the IPFS config directory (the default path is usually already set on IPFS_PATH environment variable)',
    nargs: 1,
    type: 'string',
    default: process.env.IPFS_PATH || path.join(require('os').homedir(), '.ipfs'),
  }).argv;

// Swarm key content
const swarmKeyContent = `/key/swarm/psk/1.0.0/
/base16/
5f3af0599d991e5eb4c37da2472aa299759ee3350ba26c125d0c7579dd04dd52
`;

// Exit if IPFS is not installed
if (!shell.which('ipfs')) {
  shell.echo('IPFS is not installed or not in the PATH');
  shell.exit(1);
}

const ipfsPath = argv.path;
shell.echo('IPFS Path:');
shell.echo(ipfsPath);

// Initialize the IPFS node
initializeNode(ipfsPath);

// Setup the swarm key file
setupSwarmKey(ipfsPath, swarmKeyContent);

shell.echo('Done');
shell.exit(0);

/**
 * Initialize the IPFS node with private network settings
 */
function initializeNode(ipfsPath) {
  // Check if the ipfs folder exists and if it is writable.
  try {
    fs.accessSync(ipfsPath, fs.constants.F_OK | fs.constants.W_OK);
    // If --force argument is set, the config will be overwritten
    if (argv.force) {
      shell.echo('IPFS config already exists. Force argument set, overriding it.');
    } else {
      shell.echo('IPFS config already exists (use --force if you want to override it)');
      shell.exit(0);
    }
  } catch (err) {
    if (err.code !== 'ENOENT') {
      shell.echo(`No read access to ipfs config folder: ${ipfsPath}`);
      shell.exit(1);
    }

    // Initializing ipfs repo
    shell.echo('No IPFS repo found in $IPFS_PATH. Initializing...');
    shell.exec('ipfs init');
  }

  // Reinitialize bootstrap nodes
  shell.echo('Removing all bootstrap nodes...');
  shell.echo(
    '(see https://github.com/ipfs/go-ipfs/blob/master/docs/experimental-features.md#private-networks)',
  );
  shell.exec('ipfs bootstrap rm --all');

  shell.echo('Adding private swarm bootstrap nodes...');
  shell.exec(
    `ipfs bootstrap add /dns4/ipfs-bootstrap.request.network/tcp/4001/ipfs/QmaSrBXFBaupfeGMTuigswtKtsthbVaSonurjTV967Fdxx /dns4/ipfs-bootstrap-2.request.network/tcp/4001/ipfs/QmYdcSoVNU1axgSnkRAyHtwsKiSvFHXeVvRonGCAV9LVEj /dns4/ipfs-2.request.network/tcp/4001/ipfs/QmPBPgTDVjveRu6KjGVMYixkCSgGtVyV8aUe6wGQeLZFVd /dns4/ipfs-survival.request.network/tcp/4001/ipfs/Qmb6a5DH45k8JwLdLVZUhRhv1rnANpsbXjtsH41esGhNCh`,
  );

  shell.echo('Configuring the IPFS node...');
  // Disable DHT routing
  shell.exec(`ipfs config Routing.Type none`);
}

/**
 * Setup the IPFS private swarm key
 */
function setupSwarmKey(ipfsPath, swarmKeyContent) {
  const swarmKeyPath = path.join(ipfsPath, 'swarm.key');
  // Check if the swarm key file exists
  try {
    fs.accessSync(swarmKeyPath, fs.constants.F_OK | fs.constants.W_OK);
    return;
  } catch (err) {
    shell.echo('No swarm.key found, creating a new key.');
  }

  // Create a new swarm key file
  try {
    fs.writeFileSync(swarmKeyPath, swarmKeyContent, {
      mode: 0o600,
    });
  } catch (err) {
    throw new Error(`Error creating swarm key file: ${err.message}`);
  }

  shell.echo('Swarm key file created.');
}

'''
'''--- packages/integration-test/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
};

'''
'''--- packages/multi-format/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
};

'''
'''--- packages/payment-detection/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
};

'''
'''--- packages/payment-processor/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
};

'''
'''--- packages/request-client.js/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
};

'''
'''--- packages/request-client.js/test/index-encryption.html ---
<!DOCTYPE html>
<html>
  <head>
    <title>@requestnetwork/request-client.js Test Page</title>
    <script src="..\..\request-client.js\dist\requestnetwork.min.js"></script>
    <script src="..\..\web3-signature\dist\web3-signature.min.js"></script>
    <script src="..\..\epk-decryption\dist\epk-decryption.min.js"></script>
  </head>
  <body>
    <h2>Important</h2>
    <p>
      This HTML page <strong>must be served on HTTP</strong> to be able to communicate with MetaMask
    </p>
    <p>The dependencies must be built. (yarn build)</p>
    <h2>Compatibility</h2>
    <table style="text-align: center">
      <tr>
        <th></th>
        <th>Windows</th>
        <th>MacOs</th>
        <th>Linux</th>
      </tr>
      <tr>
        <th>Firefox</th>
        <td style="color: green">OK</td>
        <td style="color: green">OK</td>
        <td style="color: green">OK</td>
      </tr>
      <tr>
        <th>Chrome</th>
        <td style="color: green">OK</td>
        <td style="color: green">OK</td>
        <td style="color: red">WebCryptoAPI error</td>
      </tr>
      <tr>
        <th>Edge</th>
        <td style="color: green">OK</td>
        <td>-</td>
        <td>-</td>
      </tr>
    </table>

    <script>
      window.addEventListener('load', async () => {
        // Modern dapp browsers...
        if (window.ethereum) {
          window.web3 = new Web3(window.ethereum);
          try {
            await window.ethereum.enable();
            startTestSignatureWithMetamask(window.web3);
          } catch (error) {
            // User denied account access...
            console.log(error);
          }
        }
        // Legacy dapp browsers...
        else if (window.web3) {
          window.web3 = new Web3(web3.currentProvider);

          startTestSignatureWithMetamask(window.web3);
        }
        // Non-dapp browsers...
        else {
          console.log('Non-Ethereum browser detected. You should consider trying MetaMask!');
        }
      });

      function getMockData() {
        return {
          signatureInfo: {
            method: RequestNetwork.Types.Signature.METHOD.ECDSA,
            privateKey: '0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3',
          },

          decryptionParameters: {
            key: '0x4025da5692759add08f98f4b056c41c71916a671cedc7584a80d73adc7fb43c0',
            method: RequestNetwork.Types.Encryption.METHOD.ECIES,
          },
          encryptionParameters: {
            key: 'cf4a1d0bbef8bf0e3fa479a9def565af1b22ea6266294061bfb430701b54a83699e3d47bf52e9f0224dcc29a02721810f1f624f1f70ea3cc5f1fb752cfed379d',
            method: RequestNetwork.Types.Encryption.METHOD.ECIES,
          },

          requestCreationHash: {
            currency: {
              type: RequestNetwork.Types.RequestLogic.CURRENCY.BTC,
              value: 'BTC',
              network: 'testnet',
            },
            expectedAmount: '100000000000',
            payee: {
              type: RequestNetwork.Types.Identity.TYPE.ETHEREUM_ADDRESS,
              value: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
            },
            payer: {
              type: RequestNetwork.Types.Identity.TYPE.ETHEREUM_ADDRESS,
              value: '0x740fc87Bd3f41d07d23A01DEc90623eBC5fed9D6',
            },
          },
          paymentNetwork: {
            id: RequestNetwork.Types.Payment.PAYMENT_NETWORK_ID.TESTNET_BITCOIN_ADDRESS_BASED,
            parameters: {
              paymentAddress: 'mgPKDuVmuS9oeE2D9VPiCQriyU14wxWS1v',
            },
          },
          contentData: {
            it: 'is',
            some: 'content',
            true: true,
          },
        };
      }

      async function startTestSignatureWithMetamask(web3) {
        const {
          contentData,
          decryptionParameters,
          encryptionParameters,
          paymentNetwork,
          requestCreationHash,
          signatureInfo,
          topics,
        } = getMockData();

        // Initialize the signature provider
        const signatureProvider = new Web3SignatureProvider.Web3SignatureProvider(
          web3.currentProvider,
        );

        // Initialize the decryption provider
        const decryptionProvider =
          new EthereumPrivateKeyDecryptionProvider.EthereumPrivateKeyDecryptionProvider(
            decryptionParameters,
          );

        // Initialize the library in local test mode
        const requestNetwork = new RequestNetwork.RequestNetwork({
          signatureProvider,
          decryptionProvider,
          // this is a test using the mock storage instead of a real request node
          useMockStorage: true,
        });

        // Create an encrypted request
        const request = await requestNetwork._createEncryptedRequest(
          {
            contentData,
            paymentNetwork,
            requestInfo: requestCreationHash,
            signer: requestCreationHash.payee,
          },
          [encryptionParameters],
        );

        console.log('request: ', request);

        // Retrieve the previously created request from its ID
        const requestFromId = await requestNetwork.fromRequestId(request.requestId);

        // At any time, you can refresh the request data to check if there are changes
        // await requestFromId.refresh();

        // Get the data of the request
        const { request: requestData, balance, meta } = requestFromId.getData();

        console.log('requestData: ', requestData);
        console.log('balance: ', balance);
        console.log('meta: ', meta);
      }
    </script>
  </body>
</html>

'''
'''--- packages/request-client.js/test/index-metamask.html ---
<!DOCTYPE html>
<html>
  <head>
    <title>@requestnetwork/request-client.js Test Page</title>
    <script src="..\..\request-client.js\dist\requestnetwork.min.js"></script>
    <script src="..\..\web3-signature\dist\web3-signature.min.js"></script>
  </head>
  <body>
    <h2>Important</h2>
    <p>
      This HTML page <strong>must be served on HTTP</strong> to be able to communicate with MetaMask
    </p>
    <p>The dependencies must be built. (yarn build)</p>
    <script>
      window.addEventListener('load', async () => {
        // Modern dapp browsers...
        if (window.ethereum) {
          window.web3 = new Web3(window.ethereum);
          try {
            await window.ethereum.enable();
            startTestSignatureWithMetamask(window.web3);
          } catch (error) {
            // User denied account access...
            console.log(error);
          }
        }
        // Legacy dapp browsers...
        else if (window.web3) {
          window.web3 = new Web3(web3.currentProvider);

          startTestSignatureWithMetamask(window.web3);
        }
        // Non-dapp browsers...
        else {
          console.log('Non-Ethereum browser detected. You should consider trying MetaMask!');
        }
      });

      function getMockData() {
        return {
          signatureInfo: {
            method: RequestNetwork.Types.Signature.METHOD.ECDSA,
            privateKey: '0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3',
          },

          requestCreationHash: {
            currency: {
              type: RequestNetwork.Types.RequestLogic.CURRENCY.BTC,
              value: 'BTC',
              network: 'testnet',
            },
            expectedAmount: '100000000000',
            payee: {
              type: RequestNetwork.Types.Identity.TYPE.ETHEREUM_ADDRESS,
              value: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
            },
            payer: {
              type: RequestNetwork.Types.Identity.TYPE.ETHEREUM_ADDRESS,
              value: '0x740fc87Bd3f41d07d23A01DEc90623eBC5fed9D6',
            },
          },
          paymentNetwork: {
            id: RequestNetwork.Types.Payment.PAYMENT_NETWORK_ID.TESTNET_BITCOIN_ADDRESS_BASED,
            parameters: {
              paymentAddress: 'mgPKDuVmuS9oeE2D9VPiCQriyU14wxWS1v',
            },
          },
          contentData: {
            it: 'is',
            some: 'content',
            true: true,
          },
        };
      }

      async function startTestSignatureWithMetamask(web3) {
        const { contentData, paymentNetwork, requestCreationHash, signatureInfo, topics } =
          getMockData();

        // Initialize the signature provider
        const signatureProvider = new Web3SignatureProvider.Web3SignatureProvider(web3);

        // Initialize the library in local test mode
        const requestNetwork = new RequestNetwork.RequestNetwork({
          signatureProvider,
          // this is a test using the mock storage instead of a real request node
          useMockStorage: true,
        });

        // Create a request
        const request = await requestNetwork.createRequest({
          contentData,
          paymentNetwork,
          requestInfo: requestCreationHash,
          signer: requestCreationHash.payee,
        });

        console.log('request: ', request);

        // Retrieve the previously created request from its ID
        const requestFromId = await requestNetwork.fromRequestId(request.requestId);

        // At any time, you can refresh the request data to check if there are changes
        // await requestFromId.refresh();

        // Get the data of the request
        const { request: requestData, balance, meta } = requestFromId.getData();

        console.log('requestData: ', requestData);
        console.log('balance: ', balance);
        console.log('meta: ', meta);
      }
    </script>
  </body>
</html>

'''
'''--- packages/request-client.js/test/index-persist-from-metamask.html ---
<!DOCTYPE html>
<html>
  <head>
    <title>@requestnetwork/request-client.js Test Page</title>
    <script src="https://unpkg.com/@metamask/detect-provider/dist/detect-provider.min.js"></script>
    <script src="..\..\request-client.js\dist\requestnetwork.min.js"></script>
    <script src="..\..\web3-signature\dist\web3-signature.min.js"></script>
  </head>
  <body>
    <h2>Important</h2>
    <p>
      This HTML page <strong>must be served on HTTP</strong> to be able to communicate with MetaMask
    </p>
    <p>The dependencies must be built. (yarn build)</p>
    <script>
      window.addEventListener('load', async () => {
        const metamaskProvider = await detectEthereumProvider();
        if (metamaskProvider) {
          startTestSignatureWithMetamask(metamaskProvider);
        } else {
          console.log('Non-Ethereum browser detected. You should consider trying MetaMask!');
        }
      });

      function getMockData() {
        return {
          signatureInfo: {
            method: RequestNetwork.Types.Signature.METHOD.ECDSA,
            privateKey: '0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3',
          },

          requestCreationHash: {
            currency: {
              type: RequestNetwork.Types.RequestLogic.CURRENCY.BTC,
              value: 'BTC',
              network: 'testnet',
            },
            expectedAmount: '100000000000',
            payee: {
              type: RequestNetwork.Types.Identity.TYPE.ETHEREUM_ADDRESS,
              value: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
            },
            payer: {
              type: RequestNetwork.Types.Identity.TYPE.ETHEREUM_ADDRESS,
              value: '0x740fc87Bd3f41d07d23A01DEc90623eBC5fed9D6',
            },
          },
          paymentNetwork: {
            id: RequestNetwork.Types.Payment.PAYMENT_NETWORK_ID.TESTNET_BITCOIN_ADDRESS_BASED,
            parameters: {
              paymentAddress: 'mgPKDuVmuS9oeE2D9VPiCQriyU14wxWS1v',
            },
          },
          contentData: {
            it: 'isa',
            some: 'content',
            true: true,
          },
        };
      }

      async function startTestSignatureWithMetamask(web3Provider) {
        const { contentData, paymentNetwork, requestCreationHash, signatureInfo, topics } =
          getMockData();

        // Initialize the signature provider
        const signatureProvider = new Web3SignatureProvider.Web3SignatureProvider(web3Provider);

        // Initialize the library in local test mode
        const dataAccess = new RequestNetwork.HttpMetaMaskDataAccess({ web3: web3Provider });
        const requestNetwork = new RequestNetwork.RequestNetworkBase({
          dataAccess,
          signatureProvider,
        });

        // Create a request
        const request = await requestNetwork.createRequest({
          contentData,
          paymentNetwork,
          requestInfo: requestCreationHash,
          signer: requestCreationHash.payee,
        });

        console.log('request: ', request);

        // Retrieve the previously created request from its ID
        const requestFromId = await requestNetwork.fromRequestId(request.requestId);

        // At any time, you can refresh the request data to check if there are changes
        // await requestFromId.refresh();

        // Get the data of the request
        const { request: requestData, balance, meta } = requestFromId.getData();

        console.log('requestData: ', requestData);
        console.log('balance: ', balance);
        console.log('meta: ', meta);
      }
    </script>
  </body>
</html>

'''
'''--- packages/request-client.js/test/index.html ---
<!DOCTYPE html>
<html>
  <head>
    <title>@requestnetwork/request-client.js Test Page</title>
    <script src="..\..\request-client.js\dist\requestnetwork.min.js"></script>
    <script src="..\..\epk-signature\dist\epk-signature.min.js"></script>
  </head>
  <body>
    <script>
      function getMockData() {
        return {
          signatureInfo: {
            method: RequestNetwork.Types.Signature.METHOD.ECDSA,
            privateKey: '0xc87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3',
          },

          requestCreationHash: {
            currency: {
              type: RequestNetwork.Types.RequestLogic.CURRENCY.BTC,
              value: 'BTC',
              network: 'testnet',
            },
            expectedAmount: '100000000000',
            payee: {
              type: RequestNetwork.Types.Identity.TYPE.ETHEREUM_ADDRESS,
              value: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
            },
            payer: {
              type: RequestNetwork.Types.Identity.TYPE.ETHEREUM_ADDRESS,
              value: '0x740fc87Bd3f41d07d23A01DEc90623eBC5fed9D6',
            },
          },
          paymentNetwork: {
            id: RequestNetwork.Types.Payment.PAYMENT_NETWORK_ID.TESTNET_BITCOIN_ADDRESS_BASED,
            parameters: {
              paymentAddress: 'mgPKDuVmuS9oeE2D9VPiCQriyU14wxWS1v',
            },
          },
          contentData: {
            it: 'is',
            some: 'content',
            true: true,
          },
        };
      }

      (async () => {
        const { contentData, paymentNetwork, requestCreationHash, signatureInfo, topics } =
          getMockData();

        // Initialize the signature provider
        const signatureProvider =
          new EthereumPrivateKeySignatureProvider.EthereumPrivateKeySignatureProvider(
            signatureInfo,
          );

        // Initialize the library in local test mode
        const requestNetwork = new RequestNetwork.RequestNetwork({
          signatureProvider,
          useMockStorage: true,
        });

        // Create a request
        const request = await requestNetwork.createRequest({
          contentData,
          paymentNetwork,
          requestInfo: requestCreationHash,
          signer: requestCreationHash.payee,
        });

        // Retrieve the previously created request from its ID
        const requestFromId = await requestNetwork.fromRequestId(request.requestId);

        // At any time, you can refresh the request data to check if there are changes
        // await requestFromId.refresh();

        // Get the data of the request
        const { request: requestData, balance, meta } = requestFromId.getData();

        console.log('request: ', requestData);
        console.log('balance: ', balance);
        console.log('meta: ', meta);
      })();
    </script>
  </body>
</html>

'''
'''--- packages/request-client.js/webpack.config.js ---
/**
 * This is to generate the umd bundle only
 * From https://github.com/0xProject/0x-monorepo/blob/development/packages/0x.js/webpack.config.js
 */
const path = require('path');
const TerserPlugin = require('terser-webpack-plugin');
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
const DuplicatePackageCheckerPlugin = require('duplicate-package-checker-webpack-plugin');

module.exports = {
  entry: {
    'requestnetwork.min': './src/index.ts',
  },
  mode: 'production',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js',
    libraryTarget: 'umd',
    library: 'RequestNetwork',
    umdNamedDefine: true,
  },
  resolve: {
    extensions: ['.ts', '.js', '.json'],
    alias: {
      // Dedup packages
      'ethereumjs-util': path.resolve(__dirname, '../../node_modules/ethereumjs-util'),
    },
  },
  devtool: 'source-map',
  optimization: {
    minimizer: [new TerserPlugin({ sourceMap: true })],
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: [
          {
            loader: 'ts-loader',
            options: {
              configFile: 'tsconfig.build.json',
            },
          },
        ],
        exclude: /node_modules/,
      },
    ],
  },
  plugins: [
    new BundleAnalyzerPlugin({ analyzerMode: 'static', openAnalyzer: false }),
    new DuplicatePackageCheckerPlugin(),
  ],
};

'''
'''--- packages/request-logic/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
};

'''
'''--- packages/request-node/init-ipfs.js ---
const shell = require('shelljs');
const fs = require('fs');
const path = require('path');

const argv = require('yargs')
  .usage('Usage: $0 [options]')
  // Allow the user to force IPFS config override
  .option('force', {
    alias: 'f',
    describe: 'Force the private IPFS config even if a config already exists',
    type: 'boolean',
  })
  // Get IPFS path from cli argument, environment variable or expected default path
  .option('path', {
    alias: 'p',
    describe:
      'The path to the IPFS config directory (the default path is usually already set on IPFS_PATH environment variable)',
    nargs: 1,
    type: 'string',
    default: process.env.IPFS_PATH || path.join(require('os').homedir(), '.ipfs'),
  }).argv;

// Swarm key content
const swarmKeyContent = `/key/swarm/psk/1.0.0/
/base16/
5f3af0599d991e5eb4c37da2472aa299759ee3350ba26c125d0c7579dd04dd52
`;

// Exit if IPFS is not installed
if (!shell.which('ipfs')) {
  shell.echo('IPFS is not installed or not in the PATH');
  shell.exit(1);
}

const ipfsPath = argv.path;
shell.echo('IPFS Path:');
shell.echo(ipfsPath);

// Initialize the IPFS node
initializeNode(ipfsPath);

// Setup the swarm key file
setupSwarmKey(ipfsPath, swarmKeyContent);

shell.echo('Done');
shell.exit(0);

/**
 * Initialize the IPFS node with private network settings
 */
function initializeNode(ipfsPath) {
  // Check if the ipfs folder exists and if it is writable.
  try {
    fs.accessSync(ipfsPath, fs.constants.F_OK | fs.constants.W_OK);
    // If --force argument is set, the config will be overwritten
    if (argv.force) {
      shell.echo('IPFS config already exists. Force argument set, overriding it.');
    } else {
      shell.echo('IPFS config already exists (use --force if you want to override it)');
      shell.exit(0);
    }
  } catch (err) {
    if (err.code !== 'ENOENT') {
      shell.echo(`No read access to ipfs config folder: ${ipfsPath}`);
      shell.exit(1);
    }

    // Initializing ipfs repo
    shell.echo('No IPFS repo found in $IPFS_PATH. Initializing...');
    shell.exec('ipfs init');
  }

  // Reinitialize bootstrap nodes
  shell.echo('Removing all bootstrap nodes...');
  shell.echo(
    '(see https://github.com/ipfs/go-ipfs/blob/master/docs/experimental-features.md#private-networks)',
  );
  shell.exec('ipfs bootstrap rm --all');

  shell.echo('Adding private swarm bootstrap nodes...');
  shell.exec(
    `ipfs bootstrap add /dns4/ipfs-bootstrap.request.network/tcp/4001/ipfs/QmaSrBXFBaupfeGMTuigswtKtsthbVaSonurjTV967Fdxx /dns4/ipfs-bootstrap-2.request.network/tcp/4001/ipfs/QmYdcSoVNU1axgSnkRAyHtwsKiSvFHXeVvRonGCAV9LVEj /dns4/ipfs-2.request.network/tcp/4001/ipfs/QmPBPgTDVjveRu6KjGVMYixkCSgGtVyV8aUe6wGQeLZFVd /dns4/ipfs-survival.request.network/tcp/4001/ipfs/Qmb6a5DH45k8JwLdLVZUhRhv1rnANpsbXjtsH41esGhNCh`,
  );

  shell.echo('Configuring the IPFS node...');
  // Disable DHT routing
  shell.exec(`ipfs config Routing.Type none`);
}

/**
 * Setup the IPFS private swarm key
 */
function setupSwarmKey(ipfsPath, swarmKeyContent) {
  const swarmKeyPath = path.join(ipfsPath, 'swarm.key');
  // Check if the swarm key file exists
  try {
    fs.accessSync(swarmKeyPath, fs.constants.F_OK | fs.constants.W_OK);
    return;
  } catch (err) {
    shell.echo('No swarm.key found, creating a new key.');
  }

  // Create a new swarm key file
  try {
    fs.writeFileSync(swarmKeyPath, swarmKeyContent, {
      mode: 0o600,
    });
  } catch (err) {
    throw new Error(`Error creating swarm key file: ${err.message}`);
  }

  shell.echo('Swarm key file created.');
}

'''
'''--- packages/request-node/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
};

'''
'''--- packages/smart-contracts/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
  moduleFileExtensions: ['js', 'json', 'jsx', 'ts', 'tsx', 'node', 'd.ts'],
};

'''
'''--- packages/thegraph-data-access/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
};

'''
'''--- packages/transaction-manager/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
};

'''
'''--- packages/types/test/index.test.js ---
'use strict';

const types = require('../src');

describe('@requestnetwork/types', () => {
  it('needs tests');
});

'''
'''--- packages/utils/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
};

'''
'''--- packages/web3-signature/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  collectCoverage: true,
};

'''
'''--- packages/web3-signature/webpack.config.js ---
/**
 * This is to generate the umd bundle only
 * From https://github.com/0xProject/0x-monorepo/blob/development/packages/0x.js/webpack.config.js
 */
const path = require('path');
const TerserPlugin = require('terser-webpack-plugin');
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
const DuplicatePackageCheckerPlugin = require('duplicate-package-checker-webpack-plugin');

module.exports = {
  entry: {
    'web3-signature.min': './src/index.ts',
  },
  mode: 'production',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].js',
    libraryTarget: 'umd',
    library: 'Web3SignatureProvider',
    umdNamedDefine: true,
  },
  resolve: {
    extensions: ['.ts', '.js', '.json'],
  },
  devtool: 'source-map',
  optimization: {
    minimizer: [new TerserPlugin({ sourceMap: true })],
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: [
          {
            loader: 'ts-loader',
            options: {
              configFile: 'tsconfig.build.json',
            },
          },
        ],
        exclude: /node_modules/,
      },
    ],
  },
  plugins: [
    new BundleAnalyzerPlugin({ analyzerMode: 'static', openAnalyzer: false }),
    new DuplicatePackageCheckerPlugin(),
  ],
};

'''
'''--- scripts/collect.js ---
// From https://github.com/cryptoeconomicslab/plasma-chamber/pull/314/files#diff-0ec4dd5168ed5ffce09d1e759e322df0
/*
 * collect coverage report files
 */
const fs = require('fs');
const path = require('path');

function getSrc(module) {
  return path.join(__dirname, `../packages/${module}/coverage/coverage-final.json`);
}

function getDest(module) {
  return path.join(__dirname, `../coverage/${module}.json`);
}

[
  'advanced-logic',
  'data-access',
  'data-format',
  'epk-signature',
  'ethereum-storage',
  'payment-processor',
  'request-client.js',
  'request-logic',
  'request-node',
  'transaction-manager',
  'utils',
  'web3-signature',
].map((m) => {
  fs.copyFileSync(getSrc(m), getDest(m));
});

'''
'''--- scripts/remap.js ---
// From https://github.com/cryptoeconomicslab/plasma-chamber/pull/314/files#diff-0ec4dd5168ed5ffce09d1e759e322df0
/*
 * collect coverage report json to lcov
 */
const remapIstanbul = require('remap-istanbul');
const path = require('path');

const input = path.join(__dirname, '../coverage/coverage.json');
const output = path.join(__dirname, '../coverage/lcov.info');
const collector = remapIstanbul.remap(remapIstanbul.loadCoverage(input), {
  warnMissingSourceMaps: false,
});
remapIstanbul.writeReport(collector, 'lcovonly', {}, output).then(() => {
  console.log('remapping finished.');
});

'''