*GitHub Repository "mattlockyer/near-eth"*

'''--- .eslintrc.js ---
module.exports = {
	parserOptions: {
		ecmaVersion: 2020,
        sourceType: 'module',
        ecmaFeatures: {
            jsx: true,
        }
    },
	rules: {
        semi: [2, 'always'],
        indent: [2, 'tab'],
	}
};

'''
'''--- README.md ---
# Warning ðŸš¨ðŸš¨ðŸš¨

MOVED: https://github.com/NearDeFi/near-eth

'''
'''--- contract/Cargo.toml ---
[package]
name = "eth-near"
edition = "2018"
version = "0.1.0"
authors = ["Illia Polosukhin <ilblackdragon@gmail.com>", "Matt Lockyer <mattdlockyer@gmail.com>"]
license = "Apache2"
description = "Sign message with metamask, have actions executed on NEAR"
publish = false

[lib]
crate-type = ["cdylib"]

[dependencies]
wee_alloc = { version = "0.4.5", default-features = false }
hex = { version = "0.4.3", default-features = false, features = ["alloc"] }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- contract/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../out
cp target/wasm32-unknown-unknown/release/*.wasm ../out/main.wasm

'''
'''--- contract/src/lib.rs ---
#![no_std]
#![feature(core_intrinsics)]
#![feature(alloc_error_handler)]

const ECRECOVER_MESSAGE_SIZE: u64 = 32;
const ECRECOVER_SIGNATURE_LENGTH: u64 = 64;
const ECRECOVER_MALLEABILITY_FLAG: u64 = 1;
const ADDRESS_KEY: &str = "a";
const NONCE_KEY: &str = "n";
const REGISTER_0: u64 = 0;
const REGISTER_1: u64 = 1;
const REGISTER_2: u64 = 2;
const DOUBLE_QUOTE_BYTE: u8 = "\"".as_bytes()[0];
const R_BRACE: &str = "}";
const RECEIVER_ID: &str = "receiver_id";
const PUBLIC_KEY: &str = "public_key";

extern crate alloc;

use alloc::str::from_utf8_unchecked;
use alloc::vec;
use alloc::vec::Vec;

mod sys;
use sys::*;
mod parse;
use parse::*;
mod owner;
use owner::*;

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[panic_handler]
#[no_mangle]
pub unsafe fn on_panic(_info: &::core::panic::PanicInfo) -> ! {
    ::core::intrinsics::abort();
}

#[alloc_error_handler]
#[no_mangle]
pub unsafe fn on_alloc_error(_: core::alloc::Layout) -> ! {
    ::core::intrinsics::abort();
}

#[no_mangle]
pub unsafe fn setup() {
	assert_predecessor();
	input(REGISTER_0);
	let (_, data) = rread(REGISTER_0);
	swrite(ADDRESS_KEY, hex::decode(&get_string(&data, "address")).unwrap());
	let nonce: u64 = 0;
	swrite(NONCE_KEY, nonce.to_le_bytes().to_vec());
}

#[no_mangle]
pub unsafe fn execute() {
	assert_predecessor();
	//increase nonce
	let nonce = sread_u64(NONCE_KEY);
	let new_nonce = nonce + 1;
	swrite(NONCE_KEY, new_nonce.to_le_bytes().to_vec());

	let data = assert_valid_tx(nonce);

	let receiver_id = get_string(&data, RECEIVER_ID);
	let actions = get_actions(&data);

	let id = promise_batch_create(receiver_id.len() as u64, receiver_id.as_ptr() as u64);
	
	for action in actions {
		match from_utf8_unchecked(&get_string(&action, "type")) {
			"Transfer" => {
				let amount = get_u128(&action, "amount");
				promise_batch_action_transfer(
					id,
					amount.to_le_bytes().as_ptr() as u64
				);
			},
			"AddKey" => {
				let allowance = get_u128(&action, "allowance");
				let receiver_id = get_string(&action, RECEIVER_ID);
				let method_names = get_string(&action, "method_names");
				let mut public_key = vec![0];
				public_key.extend_from_slice(&hex::decode(get_string(&action, PUBLIC_KEY)).unwrap());
				promise_batch_action_add_key_with_function_call(
					id,
					public_key.len() as u64,
					public_key.as_ptr() as u64,
					0,
					allowance.to_le_bytes().as_ptr() as u64,
					receiver_id.len() as u64,
					receiver_id.as_ptr() as u64,
					method_names.len() as u64,
					method_names.as_ptr() as u64,
				)
			},
			"DeleteKey" => {
				let mut public_key = vec![0];
				public_key.extend_from_slice(&hex::decode(get_string(&action, PUBLIC_KEY)).unwrap());
				promise_batch_action_delete_key(
					id,
					public_key.len() as u64,
					public_key.as_ptr() as u64,
				);
			},
			"FunctionCall" => {
				let method_name = get_string(&action, "method_name");
				let args = get_json(&action, "args");
				let amount = get_u128(&action, "amount");
				let gas = get_u128(&action, "gas") as u64;
				promise_batch_action_function_call(
					id,
					method_name.len() as u64,
					method_name.as_ptr() as u64,
					args.len() as u64,
					args.as_ptr() as u64,
					amount.to_le_bytes().as_ptr() as u64,
					gas,
				);
			},
			_ => {

			}
		};
	}
}

/// views

#[no_mangle]
pub unsafe fn get_address() {
	return_bytes(hex::encode(&sread(ADDRESS_KEY)).as_bytes());
}

#[no_mangle]
pub unsafe fn get_nonce() {
	return_bytes(hex::encode(sread_u64(NONCE_KEY).to_be_bytes()).as_bytes());
}

'''
'''--- contract/src/owner.rs ---
use crate::*;

pub fn assert_predecessor() {
    unsafe {
        current_account_id(REGISTER_0);
        let (_, current_account) = rread(REGISTER_0);
        predecessor_account_id(REGISTER_1);
        let (_, predecessor_account) = rread(REGISTER_1);
        if current_account != predecessor_account {
            panic();
        }
    }
}

/// Checks that sig of keccak("\x19Ethereum Signed Message:\n32", keccak(msg)) matches ethereum pubkey and returns msg bytes
pub unsafe fn assert_valid_tx(nonce: u64) -> Vec<u8> {
	input(REGISTER_0);
	let (len, data) = rread(REGISTER_0);

	let mut sig_bytes = hex::decode(&data[10..140]).unwrap();
	sig_bytes[64] = sig_bytes[64] - 27;
	let msg = &data[148..len - 1];
	// log(&msg);

	// create ethereum signed message hash
	let mut msg_wrapped = Vec::new();
	msg_wrapped.extend_from_slice("\x19Ethereum Signed Message:\n32".as_bytes());
	
	write_register(REGISTER_0, msg.len() as u64, msg.as_ptr() as u64);
	keccak256(u64::MAX, REGISTER_0, REGISTER_2);
	let (_, keccak_hash_1) = rread(REGISTER_2);
	
	msg_wrapped.extend_from_slice(keccak_hash_1.as_slice());
	
	write_register(REGISTER_0, msg_wrapped.len() as u64, msg_wrapped.as_ptr() as u64);
	keccak256(u64::MAX, REGISTER_0, REGISTER_2);
	let (_, keccak_hash_2) = rread(REGISTER_2);
	
	let result = ecrecover(
		ECRECOVER_MESSAGE_SIZE,
		keccak_hash_2.as_ptr() as u64,
		ECRECOVER_SIGNATURE_LENGTH,
		sig_bytes.as_ptr() as u64,
		sig_bytes[64] as u64,
		ECRECOVER_MALLEABILITY_FLAG,
		REGISTER_1,
	);

	if result == (true as u64) {
		keccak256(u64::MAX, REGISTER_1, REGISTER_2);
		let (_, keccak_hash_bytes) = rread(REGISTER_2);
		let address_bytes = keccak_hash_bytes[12..].to_vec();
		let address_bytes_storage = sread(ADDRESS_KEY);
		if address_bytes != address_bytes_storage {
			panic();
		}

		let nonce_msg = get_u128(&msg, "nonce");
		if nonce != nonce_msg as u64 {
			panic();
		}

		Vec::from(msg)
	} else {
		panic();
		vec![]
	}
}
'''
'''--- contract/src/parse.rs ---
use crate::*;

pub unsafe fn get_string(bytes: &[u8], key: &str) -> Vec<u8> {
	let mut find = key.as_bytes().to_vec();
	find.extend_from_slice("\":\"".as_bytes());
	let string = from_utf8_unchecked(bytes);
	let one: Vec<&str> = string.split(from_utf8_unchecked(find.as_slice())).collect();
	let two: Vec<&str> = one[1].split("\"").collect();
	two[0].as_bytes().to_vec()
}

pub unsafe fn get_json(bytes: &[u8], key: &str) -> Vec<u8> {
	let mut find = key.as_bytes().to_vec();
	find.extend_from_slice("\":".as_bytes());
	let string = from_utf8_unchecked(bytes);
	let one: Vec<&str> = string.split(from_utf8_unchecked(find.as_slice())).collect();
	let two: Vec<&str> = one[1].split(R_BRACE).collect();
	let mut ret = vec![];
	ret.extend_from_slice(two[0].as_bytes());
	ret.extend_from_slice(R_BRACE.as_bytes());
	ret
}

pub unsafe fn get_u128(bytes: &[u8], key: &str) -> u128 {
	let amount_bytes = get_string(bytes, key);
	let len = amount_bytes.len() - 1;
	let mut amount: u128 = 0;
	for (i, byte) in amount_bytes.iter().enumerate() {
		amount += (*byte - 48) as u128 * 10u128.pow((len - i) as u32);
	}
	amount
}

pub unsafe fn get_actions(bytes: &[u8]) -> Vec<Vec<u8>> {
	let string = from_utf8_unchecked(bytes);
	let one: Vec<&str> = string.split("actions\":[{").collect();
	let two: Vec<&str> = one[1].split("]}").collect();
	let three: Vec<Vec<u8>> = two[0].split("},{").map(|m| {
		m.as_bytes().to_vec()
	}).collect();
	three
}
'''
'''--- contract/src/sys.rs ---
use crate::*;

pub unsafe fn log(message: &str) {
    log_utf8(message.len() as _, message.as_ptr() as _);
}

pub unsafe fn return_bytes(bytes: &[u8]) {
	let mut ret_data = vec![DOUBLE_QUOTE_BYTE];
	ret_data.extend_from_slice(bytes);
	ret_data.push(DOUBLE_QUOTE_BYTE);
	value_return(ret_data.len() as u64, ret_data.as_ptr() as u64);
}

pub unsafe fn swrite(key: &str, val: Vec<u8>) {
	storage_write(
		key.len() as u64,
		key.as_ptr() as u64,
		val.len() as u64,
		val.as_ptr() as u64,
		REGISTER_0
	);
}

pub unsafe fn sread(key: &str) -> Vec<u8> {
	storage_read(
		key.len() as u64,
		key.as_ptr() as u64,
		REGISTER_0,
	);
	let (_, data) = rread(REGISTER_0);
	data
}

pub unsafe fn sread_u64(key: &str) -> u64 {
	let mut word = [0u8; 8];
	word.copy_from_slice(&sread(key));
    u64::from_le_bytes(word)
}

pub unsafe fn rread(id: u64) -> (usize, Vec<u8>) {
	let len = register_len(id) as usize;
	let data = vec![0u8; len];
	read_register(id, data.as_ptr() as u64);
	(len, data)
}

#[allow(dead_code)]
extern "C" {
    pub fn current_account_id(register_id: u64);
    pub fn predecessor_account_id(register_id: u64);
    pub fn input(register_id: u64);
    pub fn panic();
    pub fn log_utf8(len: u64, ptr: u64);
	// promises
    pub fn promise_batch_create(account_id_len: u64, account_id_ptr: u64) -> u64;
    pub fn promise_batch_action_transfer(promise_index: u64, amount_ptr: u64);
	pub fn promise_batch_action_add_key_with_function_call(
		promise_index: u64, 
		public_key_len: u64, 
		public_key_ptr: u64, 
		nonce: u64, 
		allowance_ptr: u64, 
		receiver_id_len: u64, 
		receiver_id_ptr: u64, 
		method_names_len: u64, 
		method_names_ptr: u64
	);
	pub fn promise_batch_action_delete_key(
		promise_index: u64,
		public_key_len: u64,
		public_key_ptr: u64,
	);
    pub fn promise_batch_action_function_call(
        promise_index: u64,
        method_name_len: u64,
        method_name_ptr: u64,
        arguments_len: u64,
        arguments_ptr: u64,
        amount_ptr: u64,
        gas: u64,
    );
	// crypto
	pub fn ecrecover(
		hash_len: u64,
        hash_ptr: u64,
        sig_len: u64,
        sig_ptr: u64,
        v: u64,
        malleability_flag: u64,
        register_id: u64,
	) -> u64;
	pub fn keccak256(value_len: u64, value_ptr: u64, register_id: u64);
	// io / storage
    pub fn read_register(register_id: u64, ptr: u64);
    pub fn write_register(register_id: u64, data_len: u64, data_ptr: u64);
    pub fn register_len(register_id: u64) -> u64;
	pub fn storage_write(
		key_len: u64, 
		key_ptr: u64, 
		value_len: u64, 
		value_ptr: u64, 
		register_id: u64
	) -> u64;
	pub fn storage_read(
		key_len: u64, 
		key_ptr: u64, 
		register_id: u64
	) -> u64;
	// return to client
    pub fn value_return(value_len: u64, value_ptr: u64);
}
'''
'''--- package.json ---
{
	"name": "react-parcel-boilerplate",
	"version": "1.0.0",
	"description": "React Parcel Boilerplate",
	"author": "Matt Lockyer",
	"license": "ISC",
	"dependencies": {
		"ethers": "^5.5.4",
		"near-seed-phrase": "^0.2.0",
		"parcel": "^2.0.1",
		"react": "^17.0.2",
		"react-dom": "^17.0.2"
	},
	"devDependencies": {
		"@parcel/transformer-sass": "^2.0.1",
		"ava": "^3.15.0",
		"eslint": "^8.6.0",
		"near-api-js": "^0.44.2",
		"rimraf": "^3.0.2"
	},
	"browserslist": [
		"last 2 Chrome versions"
	],
	"scripts": {
		"prebuild": "yarn clean",
		"build": "parcel build src/index.html --no-source-maps",
		"clean": "rimraf ./dist",
		"start": "parcel src/index.html --open",
		"build-contract": "cd contract && ./build.sh && cd ..",
		"patch-config": "node ./utils/patch-config.js",
		"dev-deploy": "rm -rf neardev && (near dev-deploy || exit 0) && yarn patch-config",
		"test-build": "yarn build-contract && yarn test",
		"test-deploy": "yarn build-contract && yarn dev-deploy && yarn test",
		"test": "ava test/contract.test.js -vs --timeout=5m",
		"fix": "eslint test/ --fix"
	}
}

'''
'''--- src/App.js ---
import React, { useContext, useEffect } from 'react';

import { appStore, onAppMount } from './state/app';

import HelloMessage from './HelloMessage';

import './App.scss';

const App = () => {
	const { state, dispatch, update } = useContext(appStore);

	console.log('state', state);

	const onMount = () => {
		dispatch(onAppMount('world'));
	};
	useEffect(onMount, []);

	const handleClick = () => {
		update('clicked', !state.clicked);
	};

	return (
		<div className="root">
			<HelloMessage message={state.foo && state.foo.bar.hello} />
			<p>clicked: {JSON.stringify(state.clicked)}</p>
			<button onClick={handleClick}>Click Me</button>
		</div>
	);
};

export default App;

'''
'''--- src/HelloMessage.js ---
import React, { memo } from 'react';

const HelloMessage = memo(({ message }) => {
	console.log('rendered: HelloMessage component');
	return <p>Hello { message }</p>;
});

export default HelloMessage;
'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>React Parcel Boilerplate</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script type="module" src="./index.js"></script>
  </body>
</html>

'''
'''--- src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import { AppProvider } from './state/app.js';

ReactDOM.render(
	<AppProvider>
		<App />
	</AppProvider>,
	document.getElementById('root')
);

'''
'''--- src/state/app.js ---
import { State } from '../utils/state';

import { helloWorld } from './hello';

// example
const initialState = {
	app: {
		mounted: false
	}
};

export const { appStore, AppProvider } = State(initialState, 'app');

// example app function
export const onAppMount = (message) => async ({ update, getState, dispatch }) => {
	update('app', { mounted: true });
	update('clicked', false);
	update('data', { mounted: true });
	await update('', { data: { mounted: false } });

    console.log('getState', getState());
    
    // testing undefined, null
	await update('clicked', undefined);
	console.log('getState', getState());
	await update('clicked', null);
	console.log('getState', getState());

	update('foo.bar', { hello: true });
	update('foo.bar', { hello: false, goodbye: true });
	update('foo', { bar: { hello: true, goodbye: false } });
	update('foo.bar.goodbye', true);

	await new Promise((resolve) => setTimeout(() => {
		console.log('getState', getState());
		resolve();
	}, 2000));

	dispatch(helloWorld(message));
};

'''
'''--- src/state/hello.js ---
export const helloWorld = (message) => async ({ update }) => {
	update('foo.bar.hello', message);
};
'''
'''--- src/utils/state.js ---
import React, { createContext, useReducer } from 'react';

export const State = (initialState, prefix) => {
	let updatedState = initialState;
	const getState = () => updatedState;
	const store = createContext(initialState);
	const { Provider: InnerProvider } = store;

	const updateState = (state, newState, path = '') => {
		// console.log('updateState', state, path, newState) // debugging
		if (path.length === 0) {
			const retState = { ...state }
			if (newState === null) return null
			Object.entries(newState).map(([k, v]) => {
				retState[k] = state[k] && typeof v === 'object' && !Array.isArray(v) ?
					updateState(state[k], v) : v
			})
			return retState;
		}
		const pathArr = path.split('.');
		const first = pathArr[0];
		state = { ...state };
		if (!state[first]) {
			state[first] = {};
		}
		if (pathArr.length === 1) {
			state[first] = !!newState && typeof newState === 'object' && !Array.isArray(newState) ? {
				...state[first],
				...newState
			} : newState;
		} else {
			state[first] = {
				...state[first],
				...updateState(state[first], newState, pathArr.slice(1).join('.'))
			};
		}

		return state;
	};

	const Provider = ({ children }) => {
		const [state, dispatch] = useReducer((state, payload) => {
			const { path, newState } = payload;
			if (path === undefined) {
				return state;
			}
			updatedState = updateState(state, newState, path);
			return updatedState;
		}, initialState);

		const update = (path, newState) => {
			dispatch({ path, newState });
		};
		const wrappedDispatch = (fn) => fn({ update, getState, dispatch: wrappedDispatch });

		return <InnerProvider value={{ update, state, dispatch: wrappedDispatch }}>{children}</InnerProvider>;
	};

	if (prefix) {
		return {
			[prefix + 'Store']: store,
			[prefix.substr(0, 1).toUpperCase() + prefix.substr(1) + 'Provider']: Provider,
		};
	}
    
	return { store, Provider };
};

'''
'''--- test/contract.test.js ---
const fs = require('fs');
const test = require('ava');
const { generateSeedPhrase } = require('near-seed-phrase');
const nearAPI = require('near-api-js');
const {
	KeyPair,
	transactions: { deployContract, functionCall },
	utils: {
		PublicKey,
		format: { parseNearAmount }
	}
} = nearAPI;
const {
	getAccount, init,
	recordStart, recordStop,
	contractAccount,
	accountExists,
} = require('./test-utils');
const {
	connection,
	keyStore,
} = require('../utils/near-utils');
const getConfig = require("../utils/config");
const {
	networkId,
	contractId,
	gas,
	attachedDeposit,
	NEW_ACCOUNT_AMOUNT,
} = getConfig();

/// ETH Account Setup (assume this is the MetaMask user)
const { ethers } = require("ethers");

const privateKey = '0x0123456789012345678901234567890123456789012345678901234567890123';
const wallet = new ethers.Wallet(privateKey);

const privateKey2 = '0x1111111111111111111111111111111111111111111111111111111111111111';
const wallet2 = new ethers.Wallet(privateKey2);

const address = wallet.address.substring(2);
// "0x14791697260E4c9A71f18484C9f997B308e59325"
console.log('ETH ADDRESS:', address);

const keyPair = {
	publicKey: 'ed25519:2vwEmA557jXcRWjgq1L92RCRDumM6GCYpUgANby8gSD3',
	secretKey: 'ed25519:2Qmnk8KzUh53aRvRyUeCnk1m846pT9YrtaSPw6txzFDs8QmqrsoqC59txo72KAbC39WZyzK16QCzfwQzBErZCCow',
};

/// helper gens the args for each call
const gen_args = async (msg, w = wallet) => {
	console.log('\nargs\n', JSON.stringify(msg), '\n');

	const messageHash = ethers.utils.id(JSON.stringify(msg));
	const messageHashBytes = ethers.utils.arrayify(messageHash);
	const flatSig = await w.signMessage(messageHashBytes);

	const args = {
		sig: flatSig,
		msg
	};
	return args;
};

const DELETE_EXISTING = false;

/// all tests
let accountId, account, nonce;

test('implicit account w/ entropy from signature; setup', async (t) => {
	const { sig } = await gen_args({
		NEAR_ETH_PRIVATE_KEY: 'DO NOT SIGN THIS IF YOU HAVE ALREADY SET UP YOUR NEAR ACCOUNT USING THIS ETHEREUM ADDRESS'
	});
	let sigHash = ethers.utils.id(sig);
	/// use 32 bytes of entropy from the signature of the above message to create a NEAR keyPair
	const { seedPhrase, secretKey, publicKey } = generateSeedPhrase(sigHash.substring(2, 34));

	console.log(secretKey);

	accountId = PublicKey.fromString(publicKey).data.hexSlice();
	account = new nearAPI.Account(connection, accountId);
	const newKeyPair = KeyPair.fromString(secretKey);
	keyStore.setKey(networkId, accountId, newKeyPair);

	if (DELETE_EXISTING) {
		const exists = await accountExists(accountId);
		if (exists) {
			console.log('deleting existing account', accountId);
			await account.deleteAccount(contractId);
		}
		console.log('creating account', accountId);
		await contractAccount.sendMoney(accountId, NEW_ACCOUNT_AMOUNT);
	}

	const contractBytes = fs.readFileSync('./out/main.wasm');
	console.log('deploying contract and calling setup');
	console.log({ address });
	const actions = [
		deployContract(contractBytes),
		functionCall(
			'setup',
			{ address },
			gas
		),
	];
	// const state = await account.state()
	// if (state.code_hash === '11111111111111111111111111111111') {
	// 	actions.push(functionCall('new', { linkdrop_contract: network }, GAS))
	// }
	await account.signAndSendTransaction({ receiverId: accountId, actions });

	t.true(true);
});

test('get_address', async (t) => {
	const res = await account.viewFunction(
		accountId,
		'get_address'
	);
	console.log('get_address', res);
	t.is(res.toUpperCase(), address.toUpperCase());
});

test('get_nonce', async (t) => {
	nonce = parseInt(await account.viewFunction(
		accountId,
		'get_nonce'
	), 16).toString();
	console.log('get_nonce', nonce);
	t.is(nonce, '0');
});

test('execute fail wallet2', async (t) => {
	const args = await gen_args({
		receiver_id: accountId,
		nonce,
		action: 'hello',
	}, wallet2);

	try {
		await account.functionCall({
			contractId: accountId,
			methodName: 'execute',
			args,
			gas,
		});
		t.true(false);
	} catch (e) {
		if (!/explicit guest panic/.test(e)) {
			throw e;
		}
		t.true(true);
	}
});

test('execute actions fail incorrect nonce', async (t) => {
	const args = await gen_args({
		receiver_id: accountId,
		nonce: '1',
		action: 'hello',
	});

	try {
		await account.functionCall({
			contractId: accountId,
			methodName: 'execute',
			args,
			gas,
		});
		t.true(false);
	} catch (e) {
		if (!/explicit guest panic/.test(e)) {
			throw e;
		}
		t.true(true);
	}
});

test('execute fail from another account', async (t) => {
	const args = await gen_args({
		receiver_id: accountId,
		nonce,
		action: 'hello',
	});

	try {
		await contractAccount.functionCall({
			contractId: accountId,
			methodName: 'execute',
			args,
			gas,
		});
		t.true(false);
	} catch (e) {
		if (!/explicit guest panic/.test(e)) {
			throw e;
		}
		t.true(true);
	}
});

test('execute actions on account', async (t) => {
	const args = await gen_args({
		receiver_id: accountId,
		/// nonce will not have incremented because the above txs failed
		nonce,
		actions: [
			{
				type: 'Transfer',
				amount: parseNearAmount('0.00017'),
			},
			{
				type: 'DeleteKey',
				public_key: PublicKey.fromString(keyPair.publicKey).data.hexSlice(),
			},
			{
				type: 'AddKey',
				public_key: PublicKey.fromString(keyPair.publicKey).data.hexSlice(),
				allowance: parseNearAmount('1'),
				receiver_id: accountId,
				method_names: 'execute',
			}
		]
	});

	const res = await account.functionCall({
		contractId: accountId,
		methodName: 'execute',
		args,
		gas,
	});

	t.true(true);
});

test('execute actions on some contract', async (t) => {

	/// need a new nonce because the above tx succeeded and new nonce written
	nonce = parseInt(await account.viewFunction(
		accountId,
		'get_nonce'
	), 16).toString();

	/// use limited access key (just re-upped in prev tx)
	const newKeyPair = KeyPair.fromString(keyPair.secretKey);
	keyStore.setKey(networkId, accountId, newKeyPair);

	const args = await gen_args({
		receiver_id: 'testnet',
		nonce,
		actions: [
			{
				type: 'FunctionCall',
				method_name: 'create_account',
				args: {
					new_account_id: 'meow-' + Date.now() + '.testnet',
					new_public_key: newKeyPair.publicKey.toString(),
				},
				amount: parseNearAmount('0.02'),
				gas: '100000000000000',
			},
		]
	});

	const res = await account.functionCall({
		contractId: accountId,
		methodName: 'execute',
		args,
		gas,
	});

	t.true(true);
});

test('get_nonce 2', async (t) => {
	nonce = parseInt(await account.viewFunction(
		accountId,
		'get_nonce'
	), 16).toString();
	console.log('get_nonce', nonce);
	t.is(nonce, '2');
});

// test.beforeEach((t) => {
// });

let aliceId, bobId, alice, bob;
// test('users initialized', async (t) => {
// 	aliceId = 'alice.' + contractId;
// 	bobId = 'bob.' + contractId;
// 	alice = await getAccount(aliceId);
// 	bob = await getAccount(bobId);

// 	t.true(true);
// });
'''
'''--- test/test-utils.js ---
const fs = require('fs');
const BN = require('bn.js');
const nearAPI = require('near-api-js');
const { 
	KeyPair,
	utils: { format: {
		formatNearAmount
	} }
} = nearAPI;
const { connection, keyStore, contractAccount } = require('../utils/near-utils');
const getConfig = require("../utils/config");
const {
	networkId, contractId, gas,
	NEW_ACCOUNT_AMOUNT,
} = getConfig();

try {
	fs.mkdirSync('./neardev');
} catch(e) {}

const init = async (owner_id = contractId) => {
	/// try to call new on contract, swallow e if already initialized
	try {
		await contractAccount.functionCall({
			contractId,
			methodName: 'new',
			args: {
				owner_id
			},
			gas
		});
	} catch (e) {
		console.log('contract already initialized');
		if (!/initialized/.test(e.toString())) {
			throw e;
		}
	}
	return contractAccount;
};

const getAccount = async (accountId, fundingAmount = NEW_ACCOUNT_AMOUNT, secret) => {
	const account = new nearAPI.Account(connection, accountId);
	try {
		const secret = fs.readFileSync(`./neardev/${accountId}`, 'utf-8');
		const newKeyPair = KeyPair.fromString(secret);
		keyStore.setKey(networkId, accountId, newKeyPair);
		await account.state();
		return account;
	} catch(e) {
		if (!/no such file|does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return await createAccount(accountId, fundingAmount, secret);
};

const accountExists = async (accountId) => {
	try {
		const account = new nearAPI.Account(connection, accountId);
		await account.state();
		return true;
	} catch(e) {
		if (!/no such file|does not exist/.test(e.toString())) {
			throw e;
		}
		return false;
	}
};

const createAccount = async (accountId, fundingAmount = NEW_ACCOUNT_AMOUNT, secret) => {
	const newKeyPair = secret ? KeyPair.fromString(secret) : KeyPair.fromRandom('ed25519');
	fs.writeFileSync(`./neardev/${accountId}` , newKeyPair.toString(), 'utf-8');
	await contractAccount.createAccount(accountId, newKeyPair.publicKey, fundingAmount);
	keyStore.setKey(networkId, accountId, newKeyPair);
	return new nearAPI.Account(connection, accountId);
};

/// debugging

const getAccountBalance = (accountId) => (new nearAPI.Account(connection, accountId)).getAccountBalance();
const getAccountState = (accountId) => (new nearAPI.Account(connection, accountId)).state();
const stateCost = (balanceBefore, balanceAfter) => formatNearAmount(new BN(balanceAfter.stateStaked).sub(new BN(balanceBefore.stateStaked)).toString(), 8);
const bytesUsed = (stateBefore, stateAfter) => parseInt(stateAfter.storage_usage, 10) - parseInt(stateBefore.storage_usage);

/// analyzing

let data = {};
const recordStart = async (accountId) => {
	data[accountId] = {
		balance: await getAccountBalance(accountId),
		state: await getAccountState(accountId),
	};
};

const recordStop = async (accountId) => {
	const before = data[accountId];
	const after = {
		balance: await getAccountBalance(accountId),
		state: await getAccountState(accountId),
	};

	console.log('\nAnalysis:\n');
	console.log('State stake:', stateCost(before.balance, after.balance));
	console.log('Bytes used:', bytesUsed(before.state, after.state));
	console.log('\n');
};

module.exports = {
	init,
	contractAccount,
	accountExists,
	getAccount,
	createAccount,
	getAccountBalance,
	getAccountState,
	stateCost,
	bytesUsed,
	recordStart,
	recordStop,
};
'''
'''--- utils/config.js ---
const contractName = 'dev-1646280228849-34704860606975';

module.exports = function getConfig(network = 'testnet') {
	let config = {
		networkId: "testnet",
		nodeUrl: "https://rpc.testnet.near.org",
		walletUrl: "https://wallet.testnet.near.org",
		helperUrl: "https://helper.testnet.near.org",
		contractName,
	};

	switch (network) {
	case 'testnet':
		config = {
			explorerUrl: "https://explorer.testnet.near.org",
			...config,
			GAS: "200000000000000",
			gas: "200000000000000",
			attachedDeposit: '10000000000000000000000', // 0.01 N (1kb storage)
			NEW_ACCOUNT_AMOUNT: '1000000000000000000000000',
			NEW_CONTRACT_AMOUNT: '5000000000000000000000000',
			contractId: contractName,
			isBrowser: new Function("try {return this===window;}catch(e){ return false;}")(),
		};
		break;
	}

	return config;
};

'''
'''--- utils/near-utils.js ---
const fs = require("fs");
const nearAPI = require("near-api-js");
const getConfig = require("./config");
const { nodeUrl, walletUrl, networkId, contractId, isBrowser } = getConfig();

const {
	keyStores: { InMemoryKeyStore, BrowserLocalStorageKeyStore },
	Near,
	Account,
	Contract,
	KeyPair,
	utils: {
		format: { parseNearAmount },
	},
} = nearAPI;

let credentials, keyStore;

if (isBrowser) {
	keyStore = new BrowserLocalStorageKeyStore();
} else {
	/// nodejs (for tests)
	try {
		console.log(`Loading Credentials: ${process.env.HOME}/.near-credentials/${networkId}/${contractId}.json`);
		credentials = JSON.parse(
			fs.readFileSync(
				`${process.env.HOME}/.near-credentials/${networkId}/${contractId}.json`
			)
		);
	} catch(e) {
		console.warn(`Loading Credentials: ./neardev/${networkId}/${contractId}.json`);
		credentials = JSON.parse(
			fs.readFileSync(
				`./neardev/${networkId}/${contractId}.json`
			)
		);
	}
	keyStore = new InMemoryKeyStore();
	keyStore.setKey(
		networkId,
		contractId,
		KeyPair.fromString(credentials.private_key)
	);
}

const near = new Near({
	networkId,
	nodeUrl,
	walletUrl,
	deps: { keyStore },
});
const { connection } = near;
const contractAccount = new Account(connection, contractId);

module.exports = {
	near,
	credentials,
	keyStore,
	connection,
	contractId,
	contractAccount,
};

'''
'''--- utils/patch-config.js ---
const fs = require('fs');
const contractName = fs.readFileSync('./neardev/dev-account').toString()
const path = './utils/config.js'
 
fs.readFile(path, 'utf-8', function(err, data) {
    if (err) throw err;
 
    data = data.replace(/.*const contractName.*/gim, `const contractName = '${contractName}';`);
 
    fs.writeFile(path, data, 'utf-8', function(err) {
        if (err) throw err;
        console.log('Done!');
    })
})

'''