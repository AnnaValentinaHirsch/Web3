*GitHub Repository "ikachko/near-hackathon-2021"*

'''--- Cargo.toml ---
[package]
name = "near-orderbook"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.1"
serde = { version = "1.0", features = ["derive"] }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- README.md ---
# near-hackathon-2021
Order-based DEX with callable orders

'''
'''--- scripts/build.sh ---
cargo build --all --target wasm32-unknown-unknown --release
mkdir -p ./res/
cp target/wasm32-unknown-unknown/release/*.wasm ./res/

'''
'''--- scripts/deploy.sh ---
ACCOUNT=kkdex.testnet
# near deploy $ACCOUNT res/near_orderbook.wasm new "[10,\"kstasi.testnet\",true,10,10]"
near deploy $ACCOUNT res/near_orderbook.wasm new "[\"ft.examples.testnet\", \"keku.testnet\"]"

'''
'''--- src/level.rs ---
use super::order::LimitOrder;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::Vector;
use near_sdk::env;

type OrdersVec = Vector<LimitOrder>;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Level {
    pub volume: u128,
    pub orders: OrdersVec
}

impl Level {
    pub fn new() -> Self {
        Level {
            volume: 0,
            orders: OrdersVec::new(env::random_seed())
        }
    }

    pub fn get(&mut self, idx: u64) -> LimitOrder {
        self.orders.get(idx).unwrap()
    }

    pub fn empty(self) -> bool {
        self.orders.is_empty()
    }

    pub fn push(&mut self, order: LimitOrder) {
        self.volume += order.size;
        self.orders.push(&order)
    }

    pub fn pop(&mut self, id_t: &u128) -> (LimitOrder, Option<u64>) {
        let order = self.orders.pop().unwrap();
        let mut order_copy = order.clone();
        self.volume -= order.size;

        if order.callable != "" {
            return (order, Some(order_copy.execute_order(id_t)))
        }

        (order, None)
    }
}

'''
'''--- src/level_table.rs ---
use super::order::LimitOrder;
use super::level::Level;
use super::order::{BID, ASK};

use near_sdk::collections::UnorderedMap;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen};

type LevelsMap = UnorderedMap<u128, Level>;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct LevelTable {
    pub table: LevelsMap,
    table_side: bool,
    min_level: u128,
    max_level: u128,
}

impl Default for LevelTable {
    fn default() -> LevelTable {
        LevelTable {
            table: LevelsMap::new(b"t".to_vec()),
            table_side: bool::default(),
            min_level: 0u128,
            max_level: 0u128
        }
    }
}

impl LevelTable {
    pub fn new(side: bool) -> Self {
        LevelTable {
            table: LevelsMap::new(env::random_seed()),
            table_side: side,
            min_level: 80u128,
            max_level: 100u128
        }
    }

    pub fn add_order(&mut self, o: LimitOrder) {
        if o.side != self.table_side {
            return;
        }

        if !self.table.get(&o.price).unwrap().empty() {
            self.table.get(&o.price).unwrap().push(o);
        } else {
            let mut new_level = Level::new();
            let price = o.price;

            new_level.push(o);

            self.table.insert(
                &price,
                &new_level
            );

            if price > self.max_level {
                self.max_level = price
            }
            if price < self.min_level {
                self.min_level = price
            }
        }
    }

    pub fn get_min_level(&mut self) -> u128 {
        self.min_level
    }

    pub fn get_max_level(&mut self) -> u128 {
        self.max_level
    }

    pub fn get_level(&mut self, idx: u128) -> Level {
        self.table.get(&idx).unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};
    use near_sdk::test_utils::{VMContextBuilder};
    // use near_sdk::env::{Va}

    fn get_context(predecessor_account_id: String, storage_usage: u64) -> VMContext {
        VMContext {
            current_account_id: "kkdex.testnet".to_string(),
            signer_account_id: "kkdex.testnet".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    #[test]
    fn initialize() {
        
    }
}
'''
'''--- src/lib.rs ---
pub mod order;
pub mod level;
pub mod level_table;

use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde_json::json;

use level_table::LevelTable;
use order::{LimitOrder, BID, ASK};
use near_sdk::collections::{LookupMap, Vector};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, near_bindgen, AccountId, PromiseOrValue,
    serde_json, BorshStorageKey, Promise,
    PromiseIndex
};

use near_sdk::log;

// use std::Vector;

type BalanceMap = LookupMap<AccountId, u128>;
type PendingMap = LookupMap<u128, LimitOrder>;
type PromiseIdxVec = Vector<PromiseIndex>;

pub const A: bool = true;
pub const B: bool = false;
pub const EMPTY_PROMISE_CHAIN: u64 = 1_000_000_000;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum FtOnTransferArgs {
    LinkMainnetAccount { account_id: ValidAccountId },
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct OrderBook {
    tokenA_balance: BalanceMap,
    tokenB_balance: BalanceMap,

    tokenA_id: AccountId,
    tokenB_id: AccountId,

    bids: LevelTable,
    asks: LevelTable,

    pending: PendingMap,

    max_bid: u128,
    min_bid: u128,
    max_ask: u128,
    min_ask: u128,

}

impl Default for OrderBook {
    fn default() -> OrderBook {
        OrderBook {
            tokenA_balance: BalanceMap::new(b"ta".to_vec()),
            tokenB_balance: BalanceMap::new(b"tb".to_vec()),

            tokenA_id: AccountId::default(),
            tokenB_id: AccountId::default(),

            bids: LevelTable::default(),
            asks: LevelTable::default(),

            pending: PendingMap::new(b"s".to_vec()),

            max_bid: 0u128,
            min_bid: 0u128,
            max_ask: 0u128,
            min_ask: 0u128,
        }
    }
}

pub struct Trade {
    from: AccountId,
    to: AccountId,
    id_t: u128,
    it_m: u128,
    side: bool
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
   AccountBalance,
   LevelTableBid,
   LevelTableAsk,
   TokenABalance,
   TokenBBalance,
   Pending,
}

pub fn cmp(a: u128, b: u128, order: bool) -> bool {
    return match order {
        true => (a <= b),
        false => (a >= b)
    }
}

#[near_bindgen]
impl OrderBook {
    #[init]
    pub fn new(tokenA: AccountId, tokenB: AccountId) -> Self {
        OrderBook {
            tokenA_balance: BalanceMap::new(StorageKey::TokenABalance),
            tokenB_balance: BalanceMap::new(StorageKey::TokenBBalance),
            tokenA_id: tokenA,
            tokenB_id: tokenB,
            bids: LevelTable::new(BID),
            asks: LevelTable::new(ASK),
            pending: PendingMap::new(StorageKey::Pending),
            max_bid: 100,
            min_bid: 90,
            max_ask: 110,
            min_ask: 101,
        }
    }

    pub fn test_fill(&mut self, address_a: &AccountId, address_b: &AccountId) {
        self.tokenA_balance.insert(address_a, &1_000_000_000);
        self.tokenA_balance.insert(address_a, &1_000_000_000);
        self.tokenB_balance.insert(address_b, &1_000_000_000);
        self.tokenB_balance.insert(address_b, &1_000_000_000);
    }

    pub fn send_order(&mut self, side: bool, price: u128, size: u128, callable: String) {
        self.try_match(
            LimitOrder::new(
                callable,
                side,
                price,
                size
            )
        ); // Return status
    }

    pub fn send_order_raw(&mut self, mut o: LimitOrder) {
        self.try_match(o);
    }

    pub fn try_match(
        &mut self,
        mut order: LimitOrder,
    ) {
        let level_range;
        let table;
        let mut o = order.clone();

        // let mut order_promise = Promise::new(env::current_account_id());
        let mut order_promise = EMPTY_PROMISE_CHAIN;

        order.lock();

        level_range = match !order.side {
            BID => self.max_bid..=self.min_bid,
            ASK => self.min_ask..=self.max_ask,
        };

        table = match !order.side {
            BID => &mut self.bids,
            ASK => &mut self.asks,
        };

        self.pending.insert(&o.id, &o);

        for price in level_range {
            if order.size == 0 {
                return;
            }

            if cmp(order.price, price, order.side) && !table.get_level(price).empty() {
                let mut level_order = table.get_level(price).get(0);

                if level_order.size > order.size * price {
                    level_order.sub(order.size * price);
                    order.size = 0;
                } else {
                    let matched_size = level_order.size * price;

                    order.sub(matched_size);

                    let (mut order_m, promise) = table.get_level(price).pop(&order.id);

                    order_promise = match order_promise {
                        EMPTY_PROMISE_CHAIN => promise.unwrap(),
                        _ => env::promise_and(&[order_promise, promise.unwrap()])
                    };

                    self.pending.insert(
                        &order_m.id,
                        &order_m
                    );
                }
            }
        }

        if order_promise != EMPTY_PROMISE_CHAIN {
            env::promise_then(
                order_promise,
                env::current_account_id(),
                b"order_finalization",
                json!({"id_t": order.id}).to_string().as_bytes(),
                0,
                5_000_000_000_000
            );
        }
    }

    pub fn order_finalization(&mut self, id_t: &u128) {
        assert!(env::current_account_id() == env::predecessor_account_id());

        let taker_order = self.pending.get(&id_t).unwrap();

        if taker_order.size > 0 {
            log!("Order {} was filled partially. Remaining size {}", id_t, taker_order.size);
        } else {
            log!("Order {} filled completely", id_t);
        }
    }

    pub fn on_execute(&mut self, id_t: &u128, id_m: &u128, status: bool) {
        let mut order_t = self.pending.get(&id_t).unwrap();
        let order_m = self.pending.get(&id_m).unwrap();

        if status {
            let match_size = order_m.price * order_m.size;
            // transfer tokenA from taker to maker
            match order_t.side {
                BID => {
                    // Taker gives A to Maker
                    self.internal_transfer(
                        &order_t.address,
                        &order_m.address,
                        &order_m.size,
                        A
                    );
                    // Maker gives B to Taker
                    self.internal_transfer(
                        &order_m.address,
                        &order_t.address,
                        &match_size,
                        B
                    );
                },
                ASK => {
                    // Taker gives B to Maker
                    self.internal_transfer(
                        &order_t.address,
                        &order_m.address,
                        &order_m.size,
                        A
                    );
                    // Maker gives A to Taker
                    self.internal_transfer(
                        &order_m.address,
                        &order_t.address,
                        &match_size,
                        B
                    );
                }
            }
            order_t.size -= match_size;

            log!("Order {} executed successfully", id_m);
        } else {
            log!("Order {} failed execution", id_m);
        }

        self.pending.remove(&id_m);
    }

    pub fn internal_transfer(
        &mut self,
        from: &AccountId,
        to: &AccountId,
        value: &u128,
        token: bool
    ) {
        assert!(from != to);

        let token_balance = match token {
            A => &mut self.tokenA_balance,
            B => &mut self.tokenB_balance,
        };

        let new_from_balance = token_balance.get(&from).unwrap() - value;
        let new_to_balance = token_balance.get(&to).unwrap() + value;

        token_balance.insert(&from, &new_from_balance);
        token_balance.insert(&to, &new_to_balance);
    }

    pub fn internal_token_deposit(&mut self, sender: &AccountId, account_id: &AccountId, amount: u128) {
        let new_amount;

        if *account_id == self.tokenA_id {
            new_amount = self.tokenA_balance.get(&sender).unwrap_or(0) + amount;
            self.tokenA_balance.insert(&sender, &new_amount);
        } else {
            new_amount = self.tokenB_balance.get(&sender).unwrap_or(0) + amount;
            self.tokenB_balance.insert(&sender, &new_amount);
        }
    }

    pub fn push_order(&mut self, o: LimitOrder) {
        match o.side {
            BID => self.bids.add_order(o),
            ASK => self.asks.add_order(o),
        }
    }

    // pub fn log_orderbook(&mut self) {
    //     for idx in self.max_ask..=self.min_ask {
    //         log!("{}", self.asks.get_level(idx));
    //     }
    // }

    pub fn hello(&mut self) {
        log!("HELLO");
    }
}

const ERR_FAILED_TO_PARSE_FT_ON_TRANSFER_MSG: &str = "ERR_FAILED_TO_PARSE_FT_ON_TRANSFER_MSG";
const ERR_INVALID_FT_ACCOUNT_ID: &str = "ERR_INVALID_FT_ACCOUNT_ID";

#[near_bindgen]
impl FungibleTokenReceiver for OrderBook {
    #[allow(unused_variables)]
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        let args: FtOnTransferArgs =
            serde_json::from_str(&msg).expect(ERR_FAILED_TO_PARSE_FT_ON_TRANSFER_MSG);
        let token_account_id = env::predecessor_account_id();

        assert!(
            (
                (&self.tokenA_id == &token_account_id) || (&self.tokenB_id == &token_account_id)
            ),
            "{}",
            ERR_INVALID_FT_ACCOUNT_ID
        );

        match args {
            FtOnTransferArgs::LinkMainnetAccount { account_id } => {
                self.internal_token_deposit(sender_id.as_ref(), account_id.as_ref(), amount.0);
            }
        }
        PromiseOrValue::Value(0.into())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn test_create() {
        let mut order_book = OrderBook::new("a.testnet".to_string(), "b.testnet".to_string());
    
        let mut order = LimitOrder::new(
            "executor.testnet".to_string(),
            BID,
            100,
            1
        );

        order_book.send_order_raw(order);

    }
}

'''
'''--- src/order.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{near_bindgen, ext_contract, AccountId, Promise};
use near_sdk::env::{keccak256, signer_account_id};
use near_sdk::env;
use near_sdk::serde_json::{self, json};

use serde::{Serialize, Deserialize};

pub const BID: bool = true;
pub const ASK: bool = false;

#[ext_contract(ext_callable)]
trait Callable {
    fn execute(id_m: u128, id_t: u128);
}

// #[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Clone, Serialize, Deserialize)]
pub struct LimitOrder {
    pub timestamp: u64,
    pub address: String,
    pub callable: String,
    pub id: u128,
    pub side: bool,
    pub price: u128,
    pub size: u128,
    pub status: bool,
    pub pending: bool,
}

impl Default for LimitOrder {
    fn default() -> LimitOrder {
        LimitOrder {
            timestamp: 0u64,
            address: String::default(),
            callable: String::default(),
            id: 0u128,
            side: bool::default(),
            price: 0u128,
            size: 0u128,
            status: bool::default(),
            pending: bool::default(),
        }
    }
}

impl LimitOrder {
    pub fn new(
        c: AccountId,
        sd: bool,
        p: u128,
        sz: u128,
    ) -> Self {
        let c_copy = c.clone();
        let t = env::block_timestamp();
        let hash = keccak256((
            c.clone()
            + &t.to_string()
            + &p.to_string()
            + &sz.to_string()
            + &sd.to_string()
        ).as_bytes());

        LimitOrder {
            timestamp: t,
            address: signer_account_id(),
            id: u128::from_be_bytes(hash[..16].try_into().unwrap()),
            callable: c_copy,
            side: sd,
            price: p,
            size: sz,
            status: false,
            pending: false,
        }
    }

    pub fn execute_order(&mut self, id_t: &u128) -> u64 {
        env::promise_create(
            self.callable.clone(),
            b"execute",
            json!({"id_m": self.id, "id_t": *id_t}).to_string().as_bytes(),
            0,
            5_000_000_000_000
        )
    }

    pub fn lock(&mut self) {
        self.pending = true;
    }

    pub fn sub(&mut self, a: u128) {
        self.size -= a;
    }
}

'''