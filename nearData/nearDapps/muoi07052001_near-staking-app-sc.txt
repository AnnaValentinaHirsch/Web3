*GitHub Repository "muoi07052001/near-staking-app-sc"*

'''--- Cargo.toml ---
[package]
name = "staking-contract"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.1"

[dev-dependencies]
near-sdk-sim = "3.1.0"

[profile.release]
codegen-units = 1
# Tell 'rustc' to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- build.md ---
# How to build and test this contract

1. Deploy vbi-ft.wasm to an ft_contract_id (`ft.duongnh.testnet`)

   ```
   - near deploy --wasmFile token-test/vbi-ft.wasm ft.duongnh.testnet
   ```

2. Deploy out/staking-contract.wasm to staking_contract_id (`staking.duongnh.testnet`)

   ```
   - ./build.sh
   - near deploy --wasmFile out/staking-contract.wasm staking.duongnh.testnet
   ```

3. Init contract in `ft.duongnh.testnet`

   ```
   near call ft.duongnh.testnet new_default_meta '{"owner_id": "duongnh.testnet", "total_supply": "1000000000000000000000000000000000"}' --accountId duongnh.testnet
   ```

4. Init contract in `staking.duongnh.testnet`

   ```
   near call staking.duongnh.testnet new_default_config '{"owner_id": "duongnh.testnet", "ft_contract_id": "ft.duongnh.testnet"}' --accountId duongnh.testnet
   ```

5. Check pool info:

   ```
   near view staking.duongnh.testnet get_pool_info
   ```

6. Create an account in `staking.duongnh.testnet` (by call contract `storage_deposit`)

   ```
   near call staking.duongnh.testnet storage_deposit --accountId duongnh.testnet --deposit 0.01
   ```

7. Check account info: `duongnh.testnet`

   ```
   near view staking.duongnh.testnet get_account_info '{"account_id": "duongnh.testnet"}'
   ```

8. Create an account in `ft.duongnh.testnet` (by call contract `storage_deposit`)

   ```
   near call ft.duongnh.testnet storage_deposit '{"account_id": "staking.duongnh.testnet"}' --accountId ft.duongnh.t
   estnet --deposit 0.01
   ```

9. Transfer: (call contract `ft_transfer_call` in `ft.duongnh.testnet`)

   ```
   near call ft.duongnh.testnet ft_transfer_call '{"receiver_id": "staking.duongnh.testnet", "amount": "1000000000000000000000000", "msg": ""}' --accountId duongnh.testnet --depositYocto 1 --gas 60000000000000
   ```

10. Check account info again: `duongnh.testnet`

    ```
    near view staking.duongnh.testnet get_account_info '{"account_id": "duongnh.testnet"}'
    ```

11. Harvest reward:

    ```
    near call staking.duongnh.testnet harvest --accountId duongnh.testnet --depositYocto 1 --gas 60000000000000
    ```

12. Unstake:

    ```
    near call staking.duongnh.testnet unstake '{"amount": "1000000000000000000"}' --accountId duongnh.testnet --depositYocto 1
    ```

13. Withdraw (User can only withdraw after 1 epoch since unstake (~12 hours))

    ```
    near call staking.duongnh.testnet withdraw --accountId duongnh.testnet --depositYocto 1 --gas 300000000000000
    ```

14. Run simulation tests:

    ```

    ```

'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p out
cp target/wasm32-unknown-unknown/release/*.wasm out/staking-contract.wasm
'''
'''--- neardev/dev-account.env ---
CONTRACT_NAME=dev-1651747176393-59025191306373
'''
'''--- src/account.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct AccountV1 {
    pub stake_balance: Balance,
    // Để tính lượng reward cho user
    // Timeline: t1 ---------> t2 ----------> now
    // Balance: 100k          200k
    // Giả sử đến t2 user deposit thêm 100k
    // -> Cách tính reward = (Reward từ t1->t2 ứng với 100k (pre_reward)) + (reward từ t2->now ứng với 200k)
    pub pre_reward: Balance,
    pub last_block_balance_change: BlockHeight,
    // Cho phép user unstake, nhưng lượng Token unstake sẽ bị locked lại trong 1 epoch
    // VD: User unstake ở epoch 100 -> sang epoch 101 user mới đc rút về ví
    pub unstake_balance: Balance,
    // Thời điểm user unstake
    pub unstake_start_timestamp: Timestamp,
    pub unstake_available_epoch: EpochHeight,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Account {
    pub stake_balance: Balance,
    // Để tính lượng reward cho user
    // Timeline: t1 ---------> t2 ----------> now
    // Balance: 100k          200k
    // Giả sử đến t2 user deposit thêm 100k
    // -> Cách tính reward = (Reward từ t1->t2 ứng với 100k (pre_reward)) + (reward từ t2->now ứng với 200k)
    pub pre_reward: Balance,
    pub last_block_balance_change: BlockHeight,
    // Cho phép user unstake, nhưng lượng Token unstake sẽ bị locked lại trong 1 epoch
    // VD: User unstake ở epoch 100 -> sang epoch 101 user mới đc rút về ví
    pub unstake_balance: Balance,
    // Thời điểm user unstake
    pub unstake_start_timestamp: Timestamp,
    pub unstake_available_epoch: EpochHeight,
    pub new_account_data: U128,
}

#[derive(BorshDeserialize, BorshSerialize)]
pub enum UpgradableAccount {
    V1(AccountV1),
    Current(Account),
}

impl From<UpgradableAccount> for Account {
    fn from(upgradable_account: UpgradableAccount) -> Self {
        match upgradable_account {
            UpgradableAccount::Current(account) => account,
            UpgradableAccount::V1(account_v1) => Account {
                stake_balance: account_v1.stake_balance,
                pre_reward: account_v1.pre_reward,
                last_block_balance_change: account_v1.last_block_balance_change,
                unstake_balance: account_v1.unstake_balance,
                unstake_start_timestamp: account_v1.unstake_start_timestamp,
                unstake_available_epoch: account_v1.unstake_available_epoch,
                new_account_data: U128(100),
            },
        }
    }
}

impl From<Account> for UpgradableAccount {
    fn from(account: Account) -> Self {
        UpgradableAccount::Current(account)
    }
}

// Struct để hiển thị thông tin Account trả về client
#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountJson {
    pub account_id: AccountId,
    pub stake_balance: U128,
    pub unstake_balance: U128,
    pub reward: U128,
    // Nếu tgian từ lúc user request unstake đã vượt qua 1 epoch thì cho withdraw
    pub can_withdraw: bool,
    pub unstake_start_timestamp: Timestamp,
    pub unstake_available_epoch: EpochHeight,
    // Đối chiếu xem ở epoch htai thì user có thể withdraw chưa
    pub current_epoch: EpochHeight,
    pub new_account_data: U128,
}

impl AccountJson {
    pub fn from(account_id: AccountId, new_reward: Balance, account: Account) -> Self {
        AccountJson {
            account_id,
            stake_balance: U128(account.stake_balance),
            unstake_balance: U128(account.unstake_balance),
            // Timeline: t1 ---------> t2 ----------> now
            // Balance: 100k          200k
            // Giả sử đến t2 user deposit thêm 100k
            // pre_reward: Phần thưởng từ t1 - > t2
            // new_reward: Phần thưởng từ t2 -> now
            // reward từ t1 -> now = pre_reward + new_reward
            reward: U128(account.pre_reward + new_reward),
            can_withdraw: account.unstake_available_epoch <= env::epoch_height(),
            unstake_start_timestamp: account.unstake_start_timestamp,
            unstake_available_epoch: account.unstake_available_epoch,
            current_epoch: env::epoch_height(),
            new_account_data: account.new_account_data,
        }
    }
}

'''
'''--- src/config.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Clone, Copy)]
#[serde(crate = "near_sdk::serde")]
pub struct Config {
    pub reward_numerator: u32,
    pub reward_denumerator: u64,
}

impl Default for Config {
    fn default() -> Self {
        // APR 15% - 18%
        Self {
            reward_numerator: 715,
            reward_denumerator: 1_000_000_000,
        } // Reward per block
    }
}

'''
'''--- src/core_impl.rs ---
use crate::*;

pub const DEPOSIT_ONE_YOCTO: Balance = 1;
pub const NO_DEPOSIT: Balance = 0;
pub const FT_TRANSFER_GAS: Gas = 10_000_000_000_000;
pub const FT_HARVEST_CALLBACK_GAS: Gas = 10_000_000_000_000;
pub trait FungibleTokenReceiver {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

#[ext_contract(ext_ft_contract)]
pub trait FungibleToken {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
}

#[ext_contract(ext_self)]
pub trait ExtStakingContract {
    fn ft_transfer_callback(&mut self, amount: U128, account_id: AccountId);
    fn ft_withdraw_callback(&mut self, account_id: AccountId, old_account: Account); // Trong TH bị lỗi: sử dụng old_account để rollback lại token cho user
}

#[near_bindgen]
impl FungibleTokenReceiver for StakingContract {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        _msg: String,
    ) -> PromiseOrValue<U128> {
        self.internal_deposit_and_stake(sender_id, amount.0);

        // Nếu internal_deposit_and_stake() thành công -> Trả về U128(0) (dùng hết token của user để deposit, ko trả lại gì cả)
        PromiseOrValue::Value(U128(0))
        // Nếu internal_deposit_and_stake() lỗi -> gọi hàm ft_resolve_transfer() để rollback toàn bộ token cho users
    }
}

#[near_bindgen]
impl StakingContract {
    // Function unstake
    #[payable]
    pub fn unstake(&mut self, amount: U128) {
        assert_one_yocto();

        let account_id = env::predecessor_account_id();

        self.internal_unstake(account_id, amount.0); // amount.0 để chuyển về dạng u128
    }

    #[payable]
    pub fn withdraw(&mut self) -> Promise {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        // Thực hiện withdraw, trả về giá trị account trước khi withdraw (phòng khi lỗi thì có thể rollback)
        let old_account = self.internal_withdraw(account_id.clone());

        // Sau khi trừ unstake_balance -> thực hiện cross contract call để transfer ft token sang
        ext_ft_contract::ft_transfer(
            account_id.clone(),
            U128(old_account.unstake_balance),
            Some("Staking contract withdraw".to_string()),
            &self.ft_contract_id,
            DEPOSIT_ONE_YOCTO,
            FT_TRANSFER_GAS,
        )
        .then(ext_self::ft_withdraw_callback(
            account_id.clone(),
            old_account,
            &env::current_account_id(),
            NO_DEPOSIT,
            FT_HARVEST_CALLBACK_GAS,
        ))
    }

    // Function user sẽ call để rút token ra (yêu cầu user deposit 1 yoctoNEAR)
    #[payable]
    pub fn harvest(&mut self) -> Promise {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let upgradable_account = self.accounts.get(&account_id).unwrap();
        let account = Account::from(upgradable_account);

        // Calculate reward
        let new_reward: Balance = self.internal_calculate_account_reward(&account);
        let current_reward = account.pre_reward + new_reward;

        assert!(current_reward > 0, "ERR_REWARD_EQUAL_ZERO");

        // Transfer toàn bộ current_reward từ staking contract sang tài khoản của user
        ext_ft_contract::ft_transfer(
            account_id.clone(),
            U128(current_reward),
            Some("Staking contract harvest".to_string()),
            &self.ft_contract_id,
            DEPOSIT_ONE_YOCTO,
            FT_TRANSFER_GAS,
        )
        .then(ext_self::ft_transfer_callback(
            U128(current_reward),
            account_id.clone(),
            &env::current_account_id(),
            NO_DEPOSIT,
            FT_HARVEST_CALLBACK_GAS,
        ))
    }

    #[private]
    pub fn ft_transfer_callback(&mut self, amount: U128, account_id: AccountId) -> U128 {
        // Check env::promise_results_count() = 1. Vì chỉ có 1 contract. Nếu = 2 -> Bị duplicate hoặc bị lỗi
        assert_eq!(env::promise_results_count(), 1, "ERR_TOO_MANY_RESULT");

        // Check promise result[0]
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Failed => env::panic(b"ERROR_CALLBACK"),
            // TH thành công -> Cập nhập lại reward cho user
            PromiseResult::Successful(_value) => {
                let upgradable_account = self.accounts.get(&account_id).unwrap();
                let mut account = Account::from(upgradable_account);

                // Đưa reward của user về 0 rồi cập nhật lại các thông tin khác
                account.pre_reward = 0;
                account.last_block_balance_change = env::block_index();

                // Cập nhật lại thông tin account
                self.accounts
                    .insert(&account_id, &UpgradableAccount::from(account));

                self.total_paid_reward_balance += amount.0;
                amount
            }
        }
    }

    pub fn ft_withdraw_callback(&mut self, account_id: AccountId, old_account: Account) -> U128 {
        // Kiểm tra có kết quả ko
        assert_eq!(env::promise_results_count(), 1, "ERR_TOO_MANY_RESULTS");
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(_value) => U128(old_account.unstake_balance),
            // Nếu thất bại -> Rollback data (insert lại old_account)
            PromiseResult::Failed => {
                self.accounts
                    .insert(&account_id, &UpgradableAccount::from(old_account));
                U128(0)
            }
        }
    }
}

'''
'''--- src/enumeration.rs ---
use crate::*;

#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PoolJson {
    pub total_stake_balance: U128,
    pub total_reward: U128,
    pub total_stakers: U128,
    pub is_paused: bool,
    pub total_paid_reward_balance: U128,
}

#[near_bindgen]
impl StakingContract {
    pub fn get_account_info(&self, account_id: AccountId) -> AccountJson {
        let upgradable_account = self.accounts.get(&account_id).unwrap();

        let account = Account::from(upgradable_account);
        let new_reward = self.internal_calculate_account_reward(&account);
        AccountJson::from(account_id.clone(), new_reward, account)
    }

    // Lấy thông tin của 1 account dưới dạng JSON để trả về Front-end
    pub fn get_account_reward(&self, account_id: AccountId) -> Balance {
        let upgradable_account = self.accounts.get(&account_id).unwrap();

        let account = Account::from(upgradable_account);

        let new_reward = self.internal_calculate_account_reward(&account);

        account.pre_reward + new_reward
    }

    // Lấy thông tin của toàn bộ pool dưới dạng JSON để trả về Front-end
    pub fn get_pool_info(&self) -> PoolJson {
        PoolJson {
            total_stake_balance: U128(self.total_stake_balance),
            total_reward: U128(self.pre_reward + self.internal_calculate_global_reward()),
            total_stakers: U128(self.total_staker),
            is_paused: self.paused,
            total_paid_reward_balance: U128(self.total_paid_reward_balance),
        }
    }
}

'''
'''--- src/internal.rs ---
use crate::*;

#[near_bindgen]
impl StakingContract {
    pub(crate) fn internal_unstake(&mut self, account_id: AccountId, amount: u128) {
        // Check xem số lượng token user muốn unstake có < số lượng token user đang stake ko
        let upgradable_account = self.accounts.get(&account_id).unwrap();
        let mut account: Account = Account::from(upgradable_account);

        assert!(
            amount <= account.stake_balance,
            "ERR_AMOUNT_MUST_LESS_THAN_STAKE_BALANCE"
        );

        let new_reward = self.internal_calculate_account_reward(&account);

        // Update account data
        account.pre_reward += new_reward;
        account.stake_balance -= amount;
        account.last_block_balance_change = env::block_index();
        account.unstake_balance += amount;
        account.unstake_start_timestamp = env::block_timestamp();
        // Cho phép user withdraw ở 1 epoch sau khi unstake
        account.unstake_available_epoch = env::epoch_height() + 1;

        if account.stake_balance == 0 {
            self.total_staker -= 1;
        }

        self.accounts
            .insert(&account_id, &UpgradableAccount::from(account));

        // Thay đổi 1 số thông tin trong staking pool sau khi user unstake
        let new_contract_reward = self.internal_calculate_global_reward();
        self.pre_reward += new_contract_reward;
        self.last_block_balance_change = env::block_index();
        self.total_stake_balance -= amount;
    }

    pub(crate) fn internal_withdraw(&mut self, account_id: AccountId) -> Account {
        let upgradable_account = self.accounts.get(&account_id).unwrap();
        let account = Account::from(upgradable_account);

        assert!(
            account.unstake_balance > 0,
            "ERR_UNSTAKE_BALANCE_EQUAL_ZERO"
        );
        // Epoch ở thời điểm hiện tại phải > unstake epoch (cơ chế khoá unstake amount trong 1 epoch mới cho user withdraw)
        assert!(
            account.unstake_available_epoch <= env::epoch_height(),
            "ERR_DISABLED_WITHDRAW"
        );

        let new_account = Account {
            stake_balance: account.stake_balance,
            pre_reward: account.pre_reward,
            last_block_balance_change: account.last_block_balance_change,
            unstake_balance: 0, // Withdraw hết số unstake -> đưa unstake về 0
            unstake_start_timestamp: 0,
            unstake_available_epoch: 0,
            new_account_data: account.new_account_data,
        };

        self.accounts.insert(&account_id, &UpgradableAccount::from(new_account));

        account
    }

    pub(crate) fn internal_deposit_and_stake(&mut self, account_id: AccountId, amount: u128) {
        // Validate data
        let upgradable_account = self.accounts.get(&account_id);
        assert!(upgradable_account.is_some(), "ERR_ACCOUNT_NOT_FOUND");
        assert_eq!(self.paused, false, "ERR_CONTRACT_PAUSED");
        assert_eq!(
            self.ft_contract_id,
            env::predecessor_account_id(),
            "ERR_INVALID_FT_CONTRACT_ID"
        );

        let mut account = Account::from(upgradable_account.unwrap());

        // Nếu đây là deposit lần đầu của user -> staker_count += 1 (thêm 1 staker vào pool)
        if account.stake_balance == 0 {
            self.total_staker += 1;
        }

        // Nếu user đã từng deposit -> Phải tính lại rewward
        let new_reward = self.internal_calculate_account_reward(&account);

        // Update account data
        account.pre_reward += new_reward;
        account.stake_balance += amount;
        account.last_block_balance_change = env::block_index();

        self.accounts
            .insert(&account_id, &UpgradableAccount::from(account));

        // Update pool data
        let new_contract_reward = self.internal_calculate_global_reward();
        self.total_stake_balance += amount;
        self.pre_reward += new_contract_reward;
        self.last_block_balance_change = env::block_index();
    }

    // Thêm 1 account mới vào LookupMap 'accounts'
    pub(crate) fn internal_register_account(&mut self, account_id: AccountId) {
        let account = Account {
            stake_balance: 0,
            pre_reward: 0,
            last_block_balance_change: env::block_index(),
            unstake_balance: 0,
            unstake_start_timestamp: 0,
            unstake_available_epoch: 0,
            new_account_data: U128(0),
        };

        self.accounts
            .insert(&account_id, &UpgradableAccount::from(account));
    }

    // Tính new_reward của 1 account (từ thời điểm thay đổi lượng stake gần nhất đến htai)
    pub(crate) fn internal_calculate_account_reward(&self, account: &Account) -> Balance {
        // lấy block cuối cùng:
        // Nếu contract đã bị paused -> block cuối = self.pause_in_block (block tại thời điểm contract khoá)
        // Nếu contract chưa bị paused -> block cuối trong là block htai
        let lasted_block = if self.paused {
            self.pause_in_block
        } else {
            env::block_index()
        };

        // diff_block = block cuối - block gần nhất mà user thay đổi lượng token
        let diff_block = lasted_block - account.last_block_balance_change;
        let reward: Balance =
            (account.stake_balance * self.config.reward_numerator as u128 * diff_block as u128)
                / self.config.reward_denumerator as u128;

        reward
    }

    // Tính new_reward của cả pool (từ thời điểm thay đổi lượng stake gần nhất đến htai)
    pub(crate) fn internal_calculate_global_reward(&self) -> Balance {
        // lấy block cuối cùng:
        // Nếu contract đã bị paused -> block cuối = self.pause_in_block (block tại thời điểm contract khoá)
        // Nếu contract chưa bị paused -> block cuối trong là block htai
        let lasted_block = if self.paused {
            self.pause_in_block
        } else {
            env::block_index()
        };

        // diff_block = block cuối - block gần nhất mà user thay đổi lượng token
        let diff_block = lasted_block - self.last_block_balance_change;
        let reward: Balance =
            (self.total_stake_balance * self.config.reward_numerator as u128 * diff_block as u128)
                / self.config.reward_denumerator as u128;

        reward
    }
}

'''
'''--- src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, BlockHeight, BorshStorageKey, EpochHeight,
    Gas, PanicOnDefault, Promise, PromiseOrValue, PromiseResult, Timestamp,
};

pub use crate::account::AccountJson;
use crate::account::*;
use crate::config::*;
pub use crate::core_impl::*;
pub use crate::enumeration::*;
pub use crate::internal::*;
use crate::utils::*;

mod account;
mod config;
mod core_impl;
mod enumeration;
mod internal;
mod utils;

#[derive(BorshDeserialize, BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    AccountKey,
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct StakingContractV1 {
    pub owner_id: AccountId,
    pub ft_contract_id: AccountId,
    pub config: Config,               // Cấu hình công thức trả thưởng cho user
    pub total_stake_balance: Balance, // Số lượng user stake trong contract
    pub total_paid_reward_balance: Balance, // Số lượng thưởng trả cho user
    pub total_staker: Balance,        // Tổng số account đang stake trong contract
    pub pre_reward: Balance,
    pub last_block_balance_change: BlockHeight,
    pub accounts: LookupMap<AccountId, UpgradableAccount>, // Thông tin chi tiết của account map theo accountId
    pub paused: bool, // Khi mình đã hết lượng token để trả cho user -> pause contract lại, user ko thể deposit và reward ko thể đc trả nx
    pub pause_in_block: BlockHeight, // Khi owner thay đổi staking contract sang trạng thái pause -> lưu thông tin block tại thời điểm đấy
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
#[near_bindgen]
pub struct StakingContract {
    pub owner_id: AccountId,
    pub ft_contract_id: AccountId,
    pub config: Config,               // Cấu hình công thức trả thưởng cho user
    pub total_stake_balance: Balance, // Tổng số lượng token user đã stake trong contract
    pub total_paid_reward_balance: Balance, // Tổng số lượng thưởng đã trả cho user
    pub total_staker: Balance,        // Tổng số account đang stake trong contract
    pub pre_reward: Balance,
    pub last_block_balance_change: BlockHeight,
    pub accounts: LookupMap<AccountId, UpgradableAccount>, // Thông tin chi tiết của account map theo accountId
    pub paused: bool, // Khi mình đã hết lượng token để trả cho user -> pause contract lại, user ko thể deposit và reward ko thể đc trả nx
    pub pause_in_block: BlockHeight, // Khi owner thay đổi staking contract sang trạng thái pause -> lưu thông tin block tại thời điểm đấy
    pub new_data: U128,
}

#[near_bindgen]
impl StakingContract {
    #[init]
    pub fn new_default_config(owner_id: AccountId, ft_contract_id: AccountId) -> Self {
        Self::new(owner_id, ft_contract_id, Config::default())
    }

    #[init]
    pub fn new(owner_id: AccountId, ft_contract_id: AccountId, config: Config) -> Self {
        StakingContract {
            owner_id,
            ft_contract_id,
            config,
            total_stake_balance: 0,
            total_paid_reward_balance: 0,
            total_staker: 0,
            pre_reward: 0,
            last_block_balance_change: env::block_index(),
            accounts: LookupMap::new(StorageKey::AccountKey),
            paused: false,
            pause_in_block: 0,
            new_data: U128(0),
        }
    }

    #[payable]
    // Deposit vào storage để tạo account
    pub fn storage_deposit(&mut self, account_id: Option<AccountId>) {
        assert_at_least_on_yocto();
        let account = account_id.unwrap_or_else(|| env::predecessor_account_id()); // Nếu user ko truyền tham số account_id -> lấy predecessor_account_id (account của contract)
        let account_stake = self.accounts.get(&account);

        if account_stake.is_some() {
            // Nếu đã tồn tại account, refund toàn bộ token deposit
            // TH này, account đã ký rồi và mình ko sử dụng thêm data -> storage used = 0
            refund_deposit(0);
        } else {
            // Tạo account mới
            let before_storage_usage = env::storage_usage();
            self.internal_register_account(account.clone());

            let after_storage_usage = env::storage_usage();

            // Refund lại token deposit còn thừa (lượng deposit trừ đi phí tạo account mới)
            refund_deposit(after_storage_usage - before_storage_usage);
        }
    }

    // Check account đã đăng ký hay chưa
    // User đã đăng ký -> return 1
    // chưa đăng ký -> return 0
    // Sau này, nếu check user chưa đăng ký -> trc khi thực hiện function nào phải gọi thêm hàm storage_deposit, ngược lại thì bỏ qua
    pub fn storage_balance_of(&self, account_id: AccountId) -> U128 {
        let account = self.accounts.get(&account_id);

        if account.is_some() {
            U128(1)
        } else {
            U128(0)
        }
    }

    // Lấy thông tin pool có đang bị paused hay ko (do contract không đủ Near để duy trì storage_data)
    pub fn is_paused(&self) -> bool {
        self.paused
    }

    pub fn get_new_data(&self) -> U128 {
        self.new_data
    }

    // Migrate function: Dùng để update struct cho smart contract on-chain
    // Note: Sau khi migrate xong thì nên xoá hàm này đi (vì vđề bảo mật)
    #[private]
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        let contract_v1: StakingContractV1 = env::state_read().expect("Can not read state data!");

        StakingContract {
            owner_id: contract_v1.owner_id,
            ft_contract_id: contract_v1.ft_contract_id,
            config: contract_v1.config,
            total_stake_balance: contract_v1.total_stake_balance,
            total_paid_reward_balance: contract_v1.total_paid_reward_balance,
            total_staker: contract_v1.total_staker,
            pre_reward: contract_v1.pre_reward,
            last_block_balance_change: contract_v1.last_block_balance_change,
            accounts: contract_v1.accounts,
            paused: contract_v1.paused,
            pause_in_block: contract_v1.pause_in_block,
            new_data: U128(10),
        }
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use super::*; // import các thư viện trên
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{testing_env, MockedBlockchain};

    // Xây dựng mock context cho blockchain phục vụ unit tests
    fn get_context(is_view: bool) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(0)
            .signer_account_id(accounts(0))
            .predecessor_account_id(accounts(0))
            .is_view(is_view);

        builder
    }

    #[test]
    fn test_init_contract() {
        let context = get_context(false);
        test_env(context.build());

        let config = Config {
            reward_numerator: 500,
            reward_denumerator: 100000,
        };

        let contract =
            StakingContract::new(accounts(1).to_string(), "ft_contract".to_string(), config);

        assert_eq!(contract.owner_id, accounts(1).to_string());
        assert_eq!(contract.ft_contract_id, "ft_contract".to_string());
        assert_eq!(contract.reward_numerator, contract.config.reward_numerator);
        assert_eq!(contract.paused, false);
    }
}

'''
'''--- src/utils.rs ---
use crate::*;

pub(crate) fn assert_at_least_on_yocto() {
    assert!(
        env::attached_deposit() >= 1,
        "Required attached deposit of at least 1 yoctoNEAR"
    )
}

pub(crate) fn assert_one_yocto() {
    assert_eq!(
        env::attached_deposit(),
        1,
        "Required attached deposit of exactly 1 yoctoNEAR"
    )
}

pub(crate) fn refund_deposit(storage_used: u64) {
    // Phí yêu cầu trả = phí storage của 1 byte * số lượng byte storage sử dụng
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();

    assert!(attached_deposit >= required_cost, "Must attach {} yoctoNear to cover storage", required_cost);

    let refund = attached_deposit - required_cost;
    if refund > 0 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}
'''
'''--- tests/sim/main.rs ---
use near_sdk_sim::{init_simulator, to_yocto, UserAccount, DEFAULT_GAS, STORAGE_AMOUNT};
use staking_contract::AccountJson;
use near_sdk_sim::transaction::{ExecutionStatus};

near_sdk_sim::lazy_static_include::lazy_static_include_bytes!(
    FT_CONTRACT_WASM_FILE => "token-test/vbi-ft.wasm",
    STAKING_CONTRACT_WASM_FILE => "out/staking-contract/wasm"
);

const FT_CONTRACT_ID: &str = "ft_contract";
const FT_TOTAL_SUPPLY: &str = "100000000000000000000000000000"; // 1M token (Vì vbi-ft sử dụng decimal 24)
const STAKING_CONTRACT_ID: &str = "staking_contract";
const STAKING_FT_AMOUNT: &str = "50000000000000000000000000000";
const ALICE_DEPOSIT_AMOUNT: &str = "10000000000000000000000000000"; // = 1/5 số token của Alice

pub fn init() -> (UserAccount, UserAccount, UserAccount, UserAccount) {
    let root = init_simulator(None);
    // Tương tự việc sử dụng NEAR CLI và create 1 account
    let alice = root.create_user("alice".to_string(), to_yocto("100"));

    // Deploy and init FT token
    let ft_contract = root.deploy_and_init(
        &FT_CONTRACT_WASM_FILE,
        FT_CONTRACT_ID.to_string(),
        "new_default_meta",
        &json!({"owner_id": alice.account_id(), "total_supply": FT_TOTAL_SUPPLY})
            .to_string()
            .as_bytes(),
        STORAGE_AMOUNT,
        DEFAULT_GAS,
    );

    // Deploy and init Staking contract
    let staking_contract = root.deploy_and_init(
        &STAKING_CONTRACT_WASM_FILE,
        STAKING_CONTRACT_ID.to_string(),
        "new_default_config",
        &json!({"owner_id": alice.account_id(), "ft_contract_id": ft_contract.account_id()})
            .to_string()
            .as_bytes(),
        STORAGE_AMOUNT,
        DEFAULT_GAS,
    );

    // Storage deposit ft contract
    root.call(
        ft_contract.account_id(),
        "storage_deposit",
        &json!({"account_id": staking_contract.account_id()})
            .to_string()
            .as_bytes(),
        DEFAULT_GAS,
        to_yocto("0.01"),
    );

    // Khi init, owner id là alice -> toàn bộ token đang chuyển về alice
    // Muốn chuyển 50% token về cho staking contract thì phải alice call
    alice.call(
        ft_contract.account_id(),
        "ft_transfer",
        &json!({"receiver_id": staking_contract.account_id(), "amount": STAKING_FT_AMOUNT})
            .to_string()
            .as_bytes(),
        DEFAULT_GAS,
        1,
    );

    (root, alice, ft_contract, staking_contract)
}

#[test]
pub fn test_deposit_and_stake() {
    let (root, alice, ft_contract, staking_contract) = init();

    // Storage deposit
    alice.call(
        staking_contract.account_id(),
        "storage_deposit",
        &json!({}).to_string().as_bytes(),
        DEFAULT_GAS,
        to_yocto("0.01"),
    );

    // Thực hiện ft_transfer_call để deposit vào trong Staking contract
    // Deposit token
    alice.call(
        ft_contract.account_id(),
        "ft_transfer_call",
        &json!({"receiver_id": staking_contract.account_id(), "amount": ALICE_DEPOSIT_AMOUNT, "msg": ""})
            .to_string()
            .as_bytes(),
        DEFAULT_GAS,
        1,
    );

    // Get account info
    let account_json: AccountJson = root
        .view(
            staking_contract.account_id(),
            "get_account_info",
            &json!({"account_id": alice.account_id()})
                .to_string()
                .as_bytes(),
        )
        .unwrap_json();

    // Test cases
    assert_eq!(account_json.account_id, alice.account_id());
    assert_eq!(
        account_json.stake_balance,
        U128(10000000000000000000000000000)
    );
    assert!(account_json.reward.0 > 0);
    assert_eq!(account_json.unstake_balance.0, 0);
}

// Test: Ko deposit storage mà thực hiện ft_transfer_call thì sẽ có lỗi xảy ra
pub fn test_deposit_and_stake_without_storage() {
    let (root, alice, ft_contract, staking_contract) = init();

    // // Storage deposit
    // alice.call(
    //     staking_contract.account_id(),
    //     "storage_deposit",
    //     &json!({}).to_string().as_bytes(),
    //     DEFAULT_GAS,
    //     to_yocto("0.01"),
    // );

    // Thực hiện ft_transfer_call để deposit vào trong Staking contract
    // Deposit token
    let outcome = alice.call(
        ft_contract.account_id(),
        "ft_transfer_call",
        &json!({"receiver_id": staking_contract.account_id(), "amount": ALICE_DEPOSIT_AMOUNT, "msg": ""})
            .to_string()
            .as_bytes(),
        DEFAULT_GAS,
        1,
    );

    assert_eq!(outcome.promise_errors().len(), 1);

    // assert error type
    if let ExecutionStatus::Failure(error) = &outcome.promise_errors().remove(0).unwrap().outcome().status {
        println!("{Execute error: {}", error.to_string());
        assert!(error.to_string().contains("ERR_ACCOUNT_NOT_FOUND"));
    } else {
        unreachable!()
    }
}

'''