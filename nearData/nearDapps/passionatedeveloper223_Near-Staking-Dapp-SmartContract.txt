*GitHub Repository "passionatedeveloper223/Near-Staking-Dapp-SmartContract"*

'''--- README.md ---
# Staking-DApp

Staking application consists of two smart contracts and React a web application.The purpose of this application is to allow users to earn rewards by staking their savings in terms of fungible tokens resulting in the multiplication of their savings.

# Prerequisites

In order to successfully compile the codes and run the application on local server you will need:
- [Node v18](https://nodejs.org/en/download/current/)
- [NEAR CLI](https://docs.near.org/docs/tools/near-cli)
- [RUST](https://www.rust-lang.org/tools/install)
- Add the WASM (WebAssembly) target to the toolchain by executing ` rustup target add wasm32-unknown-unknown` in terminal or powershell 

# Build

In order to generate the wasm files for the contracts, navigate to `/src/shell_scripts` and run the `build.sh` script by typing `./build.sh` in the rtminal or powershell.

# Simulation Tests

In order to execute the simulation tests, navigate to the `src/shell_scripts` and run the `test.sh` script by typing `./test.sh`

# Test Staking Functionality Using CLI

In order to test the whole functionality of the application, please runt the following scripts in sequence
- `deposit_storage.sh` this script allows users to deposit 0.00859 NEAR to th FT contract so, their acocunting can be mainitained on the contract, on successful depoist 10,000 UNCT will be transferred to the specified account for testing purposes.
- `stake.sh` this script enables users to stake tokens for 3 minutes the list of APY can be retrieved by running the `get_apy.sh` ## You will need to change the `duration` and `staking_plan`
- `claim.sh` this script allows users to claim rewards but after staking for atleast 1 minute, users will wait for 1 minute to carry out subsequent claims
- `unstake.sh` this script allows stakers to withdraw thier tokens after the lock period ends.

## Note
 You will need a testnet account in order to interact with the smart contract an account can be created from [here]([wal](https://wallet.testnet.near.org)
 Please use the follwoing addresses for staking contract and fungible token contract respectively
 #### staking contract address = ncd_staking_contract.testnet
 #### fungible token contract address = ncd_ft_token.testnet

'''
'''--- src/Cargo.toml ---
[package]
name = "src"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dev-dependencies]
near-sdk = "4.0.0-pre.6"
near-sdk-sim = "4.0.0-pre.6"

ft = {path= "./ft_contract"}
ft_staking = {path= "./ft_staking_contract"}

[workspace]
# remember to include a member for each contract
members = [
 
  "ft_contract",
  "ft_staking_contract",  
]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort" 
overflow-checks = true
'''
'''--- src/ft_contract/Cargo.toml ---
[package]
name = "ft"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]
# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = {version = "4.0.0-pre.6", features = ["unstable"]}
near-contract-standards = "4.0.0-pre.6"

'''
'''--- src/ft_contract/src/lib.rs ---
/*!
Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::U128;
use near_sdk::{env, log, near_bindgen, AccountId, Balance, PanicOnDefault, PromiseOrValue};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId, total_supply: U128) -> Self {
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "Example NEAR fungible token".to_string(),
                symbol: "EXAMPLE".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(owner_id: AccountId, total_supply: U128, metadata: FungibleTokenMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        let mut this = Self {
            token: FungibleToken::new(b"a".to_vec()),
            metadata: LazyOption::new(b"m".to_vec(), Some(&metadata)),
        };
        this.token.internal_register_account(&owner_id);
        this.token.internal_deposit(&owner_id, total_supply.into());
        near_contract_standards::fungible_token::events::FtMint {
            owner_id: &owner_id,
            amount: &total_supply,
            memo: Some("Initial tokens supply is minted"),
        }
        .emit();
        this
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, Balance};

    use super::*;

    const TOTAL_SUPPLY: Balance = 1_000_000_000_000_000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into(), TOTAL_SUPPLY.into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.ft_total_supply().0, TOTAL_SUPPLY);
        assert_eq!(contract.ft_balance_of(accounts(1)).0, TOTAL_SUPPLY);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(2));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(2).into(), TOTAL_SUPPLY.into());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(contract.storage_balance_bounds().min.into())
            .predecessor_account_id(accounts(1))
            .build());
        // Paying for account registration, aka storage deposit
        contract.storage_deposit(None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(2))
            .build());
        let transfer_amount = TOTAL_SUPPLY / 3;
        contract.ft_transfer(accounts(1), transfer_amount.into(), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert_eq!(
            contract.ft_balance_of(accounts(2)).0,
            (TOTAL_SUPPLY - transfer_amount)
        );
        assert_eq!(contract.ft_balance_of(accounts(1)).0, transfer_amount);
    }
}

'''
'''--- src/ft_staking_contract/Cargo.toml ---
[package]
name = "ft_staking"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = "4.0.0-pre.6"
near-contract-standards = "4.0.0-pre.6"

[lib]
crate-type = ["cdylib", "rlib"]
'''
'''--- src/ft_staking_contract/src/ft_calls.rs ---
use core::panic;

use crate::*;

use near_sdk::collections::UnorderedMap;
use near_sdk::env::{attached_deposit, log};
use near_sdk::json_types::U128;
use near_sdk::{ext_contract, log, Balance, Gas, PromiseOrValue, PromiseResult};

const BASE_GAS: Gas = Gas(5_000_000_000_000);
const STORAGE_DEPOSIT_GAS: Gas = Gas(300_000_000_000_000);

//const THIRTY_DAYS: u64 = 2592000; //30 days in seconds
const ONE_MINUTE: u64 = 60; //30 days in seconds

const STORAGE_DEPOSIT: Balance = 8590000000000000000000;

const ONE_YOCTO: Balance = 100000000000000000000000;
const TEN_THOUSAND: u128 = 10000000000000000000000000000;
const NO_BALANCE: Balance = 0;

pub trait FTActionsReceiver {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;

    fn ft_unstake(&mut self, stake_id: U128);

    fn did_promise_succeded() -> bool;

    fn unstake_callback(&mut self, stake_id: StakeId, staker_id: AccountId);

    fn claim_reward(&mut self, stake_id: StakeId);

    fn claim_reward_callback(
        &mut self,
        stake_id: StakeId,
        claim_history: Option<ClaimHistory>,
        claim_count: u64,
    );

    fn deposit_for_storage(&mut self, ft_contract_id: AccountId);

    fn drop_ft(&mut self, account_id: AccountId, ft_contract_id: AccountId);

    fn drop_ft_callback(&mut self, account_id: AccountId, ft_contract_id: AccountId);
}

#[ext_contract(ext_ft)]
trait FTCallbackReceiver {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
    fn storage_deposit(account_id: Option<AccountId>);
}

#[ext_contract(this_contract)]
trait FTActionsSender {
    fn unstake_callback(&mut self, stake_id: StakeId, staker_id: AccountId);

    fn claim_reward_callback(
        &mut self,
        stake_id: StakeId,
        claim_history: Option<ClaimHistory>,
        claim_count: u64,
    );

    fn drop_ft_callback(&mut self, account_id: AccountId, ft_contract_id: AccountId);
}

#[near_bindgen]
impl FTActionsReceiver for Contract {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        let a: u128 = 0;
        let staking_id = self
            .staking_nonce
            .checked_add(1)
            .expect("Exceeded u128 capacity");

        log!("{} staking id", staking_id);
        let staked_at = env::block_timestamp() / 1000000000;
        let StakeArgs {
            ft_symbol,
            ft_account_id,
            decimal,
            duration,
            staked_by,
            staking_plan,
        } = near_sdk::serde_json::from_str(&msg).expect("Invalid Staking Arguments");

        let stake = Stake {
            stake_id: U128::from(staking_id),
            ft_symbol,
            ft_account_id,
            decimal,
            amount,
            duration,
            staked_at: staked_at,
            staked_by,
            staking_plan,
        };

        //fetch apy details from FT
        let ft = self.approved_fts.get(&stake.clone().ft_account_id).unwrap();
        let apy_map = ft.apy_against_duration.unwrap();
        let apy = apy_map.get(&stake.clone().staking_plan);
        //fetch minimum staking amount from APY
        let threshold: u128 = u128::from(apy.unwrap().clone().min_staking_amount);

        let calling_contrat = env::predecessor_account_id();
        assert!(
            self.approved_ft_token_ids.contains(&calling_contrat),
            "Only approved FT can be staked"
        );
        assert!(
            u128::from(amount) >= threshold,
            "Cannot stake less than {} tokens",
            threshold
        );
        assert!(
            stake.duration / ONE_MINUTE >= apy.unwrap().min_duration.into(),
            "Invalid Duration"
        );

        if let Some(mut staking_history) = self.staking_history.get(&sender_id) {
            log!("In IF");
            staking_history.push(stake);
            self.staking_history.insert(&sender_id, &staking_history);
        } else {
            log!("In ELSE");
            let mut staking_history: Vec<Stake> = Vec::new();
            staking_history.push(stake);
            self.staking_history.insert(&sender_id, &staking_history);
        }

        log!(
            "{:?} staked by {} with staking_id {}",
            amount,
            sender_id,
            staking_id
        );
        self.staking_nonce = staking_id;
        near_sdk::PromiseOrValue::Value(U128::from(a))
    }

    fn ft_unstake(&mut self, stake_id: StakeId) {
        // let stake_id = u128::from(stake_id);
        let staker_id: AccountId = env::predecessor_account_id().try_into().unwrap();
        let stake_history = self.staking_history.get(&staker_id);

        // assert!(self.whitelist_addresses.contains(&staker_id), "Only whitelisted members can unstake tokens");

        let stake = stake_history
            .unwrap()
            .into_iter()
            .find(|i| i.stake_id == stake_id)
            .expect("No staking data with this id found for caller");

        let current_time = env::block_timestamp() / 1000000000;
        let staked_at = stake.staked_at;
        let duration = stake.duration;
        let amount = stake.amount;
        let staked_by = stake.staked_by;
        let ft_contract: AccountId = stake.ft_account_id.try_into().unwrap();
        let memo: Option<String> = Some("Unstaking with reward".to_string());

        assert_eq!(
            staked_by.to_string(),
            staker_id.to_string(),
            "Only owner of the tokens can unstake"
        );

        assert!(
            current_time >= staked_at + duration,
            "Cannot withdraw before locked time"
        );
        ext_ft::ft_transfer(
            staker_id.clone(),
            U128::from(amount),
            memo,
            ft_contract,
            1,
            BASE_GAS,
        )
        .then(this_contract::unstake_callback(
            stake_id,
            staker_id,
            env::current_account_id(),
            0,
            BASE_GAS,
        ));

        //remove staking info from vector
    }

    fn did_promise_succeded() -> bool {
        if env::promise_results_count() != 1 {
            log!("Expected a result on the callback");
            return false;
        }
        match env::promise_result(0) {
            PromiseResult::Successful(_) => true,
            _ => false,
        }
    }

    fn unstake_callback(&mut self, stake_id: StakeId, staker_id: AccountId) {
        if Self::did_promise_succeded() {
            let mut staking_history = self.staking_history.get(&staker_id).unwrap();
            let index = &staking_history.iter().position(|i| i.stake_id == stake_id);

            let _ = &staking_history.remove(index.unwrap());

            self.staking_history.insert(&staker_id, &staking_history);

            log!(
                "Staking ID {} removed from {}",
                u128::from(stake_id),
                index.unwrap()
            );
        }
    }

    fn claim_reward(&mut self, stake_id: StakeId) {
        let staker_id: AccountId = env::predecessor_account_id().try_into().unwrap();
        let stake_history = self
            .staking_history
            .get(&staker_id)
            .expect("This user has not staked yet.");

        let stake = stake_history
            .into_iter()
            .find(|i| i.stake_id == stake_id)
            .expect("No staking data with this id found for caller");

        let current_time = env::block_timestamp() / 1000000000;
        //let current_time = 1653764399;
        let staked_at = stake.staked_at;
        // let duration = stake.duration / THIRTY_DAYS;
        let amount = u128::from(stake.amount);
        let staked_by = stake.staked_by;
        // let symbol = stake.ft_symbol;
        // let decimal = stake.decimal;

        let claim_history = self.claim_history.get(&stake_id);

        assert_eq!(
            staked_by.to_string(),
            staker_id.to_string(),
            "Only owner of the tokens can claim reward"
        );
        //  assert!(self.whitelist_addresses.contains(&staker_id), "Only whitelisted members can claim reward tokens");

        let difference: u64;
        if claim_history.is_none() {
            difference = (current_time - staked_at) / ONE_MINUTE;
            //difference = 1;
            log!("{}", difference);
            assert!(
                difference >= 1,
                "Reward can be claimed after staking for 1 minute"
            );
        } else {
            let claimed_at = claim_history.clone().unwrap().last_claimed_at;
            difference = (current_time - claimed_at) / ONE_MINUTE;
            //difference = 2;
            log!(
                "Current Time : {} Claimed at : {} Difference {}",
                current_time,
                claimed_at,
                difference
            );
            assert!(
                difference >= 1,
                "Reward can be claimed after 1 minute of the last claim"
            );
        }

        //get FT details
        let ft = self.approved_fts.get(&stake.ft_account_id).unwrap();
        let apy_map = ft.apy_against_duration.unwrap();
        let apy = apy_map.get(&stake.staking_plan).unwrap();

        //log!("{:?}", apy);
        //let ap = apy.interest_rate / apy.min_duration as u16;
        let ap = apy.interest_rate;

        let interest = (amount * (ap as u128)) / 100;
        log!("interest {}", interest);
        let mut actual_amount = (interest / 10) * difference as u128; //calculae the reward according to the number of months passed since the user staked
        log!("actual_amount {}", actual_amount);
        actual_amount = actual_amount / apy.min_duration as u128;
        log!("Actual amount for transfer {}", actual_amount);

        let memo: Option<String> = Some("Reward tokens".to_string());
        ext_ft::ft_transfer(
            staker_id.clone(),
            U128::from(actual_amount),
            memo,
            stake.ft_account_id,
            1,
            BASE_GAS,
        )
        .then(this_contract::claim_reward_callback(
            stake_id,
            claim_history.clone(),
            difference,
            env::current_account_id(),
            0,
            BASE_GAS,
        ));
    }

    fn claim_reward_callback(
        &mut self,
        stake_id: StakeId,
        claim_history: Option<ClaimHistory>,
        claim_count: u64,
    ) {
        if Self::did_promise_succeded() {
            let claim: ClaimHistory;
            let current_time = env::block_timestamp() / 1000000000;
            if claim_history.is_none() {
                let count = claim_count as u8;
                claim = ClaimHistory {
                    last_claimed_at: current_time,
                    claim_count: count,
                }
            } else {
                claim = ClaimHistory {
                    last_claimed_at: current_time,
                    claim_count: claim_history.unwrap().claim_count + 1,
                }
            }
            self.claim_history.insert(&stake_id, &claim);
        }
    }

    #[payable]
    fn deposit_for_storage(&mut self, ft_contract_id: AccountId) {
        let caller_id = env::predecessor_account_id();
        let balance = env::attached_deposit();
        assert_eq!(
            attached_deposit(),
            STORAGE_DEPOSIT,
            "must attach 0.00859 NEAR"
        );
        ext_ft::storage_deposit(
            Some(caller_id.clone()),
            ft_contract_id.clone(),
            balance,
            BASE_GAS,
        );

        if let Some(mut depositted_for_storage) = self.depositted_for_storage.get(&ft_contract_id) {
            depositted_for_storage.insert(&caller_id);
            self.depositted_for_storage
                .insert(&ft_contract_id, &depositted_for_storage);
        } else {
            let mut members: UnorderedSet<AccountId> = UnorderedSet::new(b"s");
            members.insert(&caller_id);
            self.depositted_for_storage
                .insert(&ft_contract_id, &members);
        }
        /*
        if self.depositted_for_storage.get(&ft_contract_id).is_some(){
            self.depositted_for_storage.get(&ft_contract_id).unwrap().insert(&caller_id);
        }else{
            let mut members: UnorderedSet<AccountId> = UnorderedSet::new(b"s");
            members.insert(&caller_id);
            self.depositted_for_storage.insert(&ft_contract_id, &members);

        } */
        log!("true")
    }

    fn drop_ft(&mut self, account_id: AccountId, ft_contract_id: AccountId) {
        let memo: String = "Airdrop".to_string();

         if let Some(registered_members) = self.registered_members.get(&ft_contract_id){
            if registered_members.contains(&account_id){
                panic!("already claimed drop");
            }
        }
        ext_ft::ft_transfer(
            account_id.clone(),
            U128::from(TEN_THOUSAND),
            Some(memo),
            ft_contract_id.clone(),
            1,
            BASE_GAS,
        )
        .then(this_contract::drop_ft_callback(
            account_id,
            ft_contract_id,
            env::current_account_id(),
            NO_BALANCE,
            BASE_GAS,
        ));
    }
    fn drop_ft_callback(&mut self, account_id: AccountId, ft_contract_id: AccountId) {
        //  log!("acct_id {}",account_id);
        if Self::did_promise_succeded() {
            if let Some(mut members) = self.registered_members.get(&ft_contract_id) {
                members.push(account_id);
                self.registered_members.insert(&ft_contract_id, &members);
                // log!("in if acct_id =  {} reg_mem = {:?}",account_id,members);
            } else {
                let mut members: Vec<AccountId> = Vec::new();
                members.push(account_id);
                self.registered_members.insert(&ft_contract_id, &members);
            }
        }
    }
}

'''
'''--- src/ft_staking_contract/src/internal.rs ---
use crate::*;

impl Contract{
    pub(crate) fn add_fts(
        approved_ft_token_ids: Vec<FT>,
        set: &mut LookupMap<AccountId, FT>,
        ft_accounts: &mut UnorderedSet<AccountId>,
        ft_apy: Vec<APY>,
    ) {
        for mut ft in approved_ft_token_ids {
            let  apy_map: HashMap<APYKey, APY> = Contract::insert_apy(ft_apy.clone());
            ft.apy_against_duration = Some(apy_map);
            set.insert(&ft.account_id, &ft);
            ft_accounts.insert(&ft.account_id);
        }
    }

    pub(crate) fn insert_apy(ft_apy: Vec<APY>)-> HashMap<APYKey,APY>{
        let mut temp :HashMap<APYKey,APY> = HashMap::new();

        for apy in &ft_apy {
            // let apy_key = ft.symbol.clone() + &apy.plan_name+&apy.min_duration.to_string();
            temp.insert(apy.apy_key.clone(), apy.clone());
        }
        temp
    }

    pub(crate) fn is_owner(&self) -> bool {
        &env::predecessor_account_id() == &self.owner_id
    }
    pub(crate) fn assert_owner(&self) {
        assert!(self.is_owner(), "Owner's method");
    }
}

'''
'''--- src/ft_staking_contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedSet};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, log, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault};
use std::cmp::min;
use std::collections::HashMap;

pub type APYKey = String; //6 months =  6months
pub type StakeId = U128;

mod ft_calls;
mod internal;

/* #[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    owner_id: AccountId,
    approved_ft_token_ids: UnorderedSet<AccountId>,
    approved_fts: LookupMap<AccountId, FT>,
    staking_history: LookupMap<AccountId, Vec<Stake>>,
    staking_nonce: u128,
    claim_history: LookupMap<StakeId, ClaimHistory>,
} */

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner_id: AccountId,
    pub approved_ft_token_ids: UnorderedSet<AccountId>,
    pub approved_fts: LookupMap<AccountId, FT>,
    pub staking_history: LookupMap<AccountId, Vec<Stake>>,
    pub staking_nonce: u128,
    pub claim_history: LookupMap<StakeId, ClaimHistory>,
    pub registered_members : LookupMap<AccountId, Vec<AccountId>>,
    depositted_for_storage : LookupMap<AccountId,UnorderedSet<AccountId>>
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct ContractV2 {
    pub owner_id: AccountId,
    pub approved_ft_token_ids: UnorderedSet<AccountId>,
    pub approved_fts: LookupMap<AccountId, FT>,
    staking_history: LookupMap<AccountId, Vec<Stake>>,
    staking_nonce: u128,
    claim_history: LookupMap<StakeId, ClaimHistory>,
    registered_members : LookupMap<AccountId, UnorderedSet<AccountId>>,
    depositted_for_storage : LookupMap<AccountId,UnorderedSet<AccountId>>
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Stake {
    stake_id: StakeId,
    ft_symbol: String,
    ft_account_id: AccountId,
    decimal: u8,
    amount: U128,
    duration: u64,  //in seconds
    staked_at: u64, //UNIX time : 1652793005
    staked_by: AccountId,
    staking_plan: String, //6months
}
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone,Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FT {
    pub account_id: AccountId,
    pub symbol: String,
    pub apy_against_duration: Option<HashMap<APYKey, APY>>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone,Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct APY {
    pub apy_key: APYKey,
    pub min_staking_amount: U128,
    pub min_duration: u8,   //Ex 3 for 3 months
    pub interest_rate: u16, // Ex: 10% = 1000
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone,Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct StakeArgs {
    ft_symbol: String,
    ft_account_id: AccountId,
    decimal: u8,
    duration: u64, //duration in milliseconds Ex 30 days = 2629800
    staked_by: AccountId,
    staking_plan: String, //Ex 6months
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone,Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ClaimHistory {
    last_claimed_at: u64,
    claim_count: u8,
}

#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKeys {
    ApproveFungibleTokens,
    AmountStaked,
    ClaimHistory,
    RegisteredMembers,
    DeposittedForStorage
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: AccountId, approved_ft_token_ids: Vec<FT>, ft_apy: Vec<APY>) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        let mut this = Self {
            owner_id: owner_id.into(),
            approved_ft_token_ids: UnorderedSet::new(StorageKeys::ApproveFungibleTokens),
            approved_fts: LookupMap::new(StorageKeys::ApproveFungibleTokens),
            staking_history: LookupMap::new(StorageKeys::AmountStaked),
            claim_history: LookupMap::new(StorageKeys::ClaimHistory),
            staking_nonce: 0,
            registered_members : LookupMap::new(StorageKeys::RegisteredMembers),
            depositted_for_storage : LookupMap::new(StorageKeys::DeposittedForStorage)
        };

        Contract::add_fts(
            approved_ft_token_ids,
            &mut this.approved_fts,
            &mut this.approved_ft_token_ids,
            ft_apy,
        );

        this
    }

    #[init(ignore_state)]
    pub fn migrate()->ContractV2{
        let prev: Contract = env::state_read().expect("ERR_NOT_INITIALIZED");

        assert_eq!(
            env::predecessor_account_id(),
            prev.owner_id,
            "Only Owner can call this function"
        );

        let this = ContractV2{
            owner_id : prev.owner_id,
            approved_ft_token_ids : prev.approved_ft_token_ids,
            approved_fts : prev.approved_fts,
            staking_history : prev.staking_history,
            claim_history : prev.claim_history,
            staking_nonce : prev.staking_nonce,
            registered_members : LookupMap::new(StorageKeys::RegisteredMembers),
            depositted_for_storage : LookupMap::new(StorageKeys::DeposittedForStorage)
        };

        this

    }

    pub fn get_staking_history(
        self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<Stake> {
        let mut stake_history = vec![];
        if self.staking_history.get(&account_id).is_none() {
            return stake_history;
        }
        let owner_stakes = self.staking_history.get(&account_id).unwrap();
        let start = u128::from(from_index.unwrap_or(U128(0)));
        let end = min(
            start + (limit.unwrap_or(0) as u128),
            owner_stakes.len().try_into().unwrap(),
        );

        for i in start..end {
            stake_history.push(owner_stakes[i as usize].clone());
        }

        self.staking_history.get(&account_id).unwrap()
    }

    pub fn get_claim_history(self, stake_id: StakeId) -> Option<ClaimHistory> {
        self.claim_history.get(&stake_id)
    }

    pub fn is_registered(&self,ft_contract_id:AccountId, account_id: AccountId)->bool{
        let registered_members = self.registered_members.get(&ft_contract_id);
            if registered_members.unwrap().contains(&account_id){
                true
            }else{
                false
            }
    }

    pub fn all_registered_memebers(&self, ft_contract_id:AccountId)->Vec<AccountId>{
        self.registered_members.get(&ft_contract_id).unwrap().to_vec()
    }

    pub fn all_storage_deposit (&self, ft_contract_id:AccountId)->Vec<AccountId>{
        self.depositted_for_storage.get(&ft_contract_id).unwrap().to_vec()
    }

   /*  pub fn insert_test (&mut self, ft_contract_id:AccountId, account_id: AccountId){
        let mut members: UnorderedSet<AccountId> = self.registered_members.get(&ft_contract_id).unwrap();
        members.insert(&account_id);
        self.registered_members.insert(&ft_contract_id, &members);
    } */

    pub fn has_depositted_for_storage(&self,account_id: AccountId,ft_contract_id:AccountId)->bool{
        if self.depositted_for_storage.get(&ft_contract_id).is_some(){
            if self.depositted_for_storage.get(&ft_contract_id).unwrap().contains(&account_id){
                true
            }else{
                false
            }
        }else{
            false
        }
    }

/*     pub fn remove_from_drop(&mut self, account_id: AccountId,ft_contract:AccountId){
        self.assert_owner();
        self.registered_members.get(&ft_contract).unwrap().remove(&account_id);
    } */

    pub fn get_apy(&self, ft_contract_id:AccountId)->Option<FT>{
        self.approved_fts.get(&ft_contract_id)
    }
}

#[cfg(test)]
mod staking_tests {

    use super::*;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, VMContext,log,Gas};
    use std::convert::TryInto;

    const ALICE:&str = "alice.testnet";

    const FT_CONTRACT:&str = "ft.testnet";
    //const CURRENT_ACOUNT_ID: AccountId = "contract.testnet".to_string();
    fn get_context(is_view: bool) -> VMContext {
        VMContextBuilder::new()
            .signer_account_id(AccountId::try_from(ALICE.to_string()).unwrap())
            .is_view(is_view)
            .build()
    }

    #[test]
    fn test_contract_instantiation() {
        let context = get_context(false);

        let apy_dur:HashMap<APYKey, APY> = HashMap::new();

        let amount1:U128 = U128::from(500_000_000_000_000_0000_000_000_000);
        let amount2:U128 = U128::from(1000_000_000_000_000_0000_000_000_000);
        let amount3:U128 = U128::from(2000_000_000_000_000_0000_000_000_000);
        let duration1 : String = "3months".to_string();
        let duration2 : String = "6months".to_string();
        let duration3 : String = "12months".to_string();
        let apy1 : APY = APY{
            apy_key : duration1,
            min_staking_amount : amount1,
            min_duration : 3,
            interest_rate: 250,
        };
        let apy2 : APY = APY{
            apy_key : duration2,
            min_staking_amount : amount2,
            min_duration : 6,
            interest_rate: 500,
        };
        let apy3 : APY = APY{
            apy_key : duration3,
            min_staking_amount : amount3,
            min_duration : 12,
            interest_rate: 1000,
        };
        let mut fts : Vec<FT> = Vec::new();

        let ft = FT{
            account_id : AccountId::try_from(FT_CONTRACT.to_string()).unwrap(),
            symbol : "FT".to_string(),
            apy_against_duration: None
        };
        fts.push(ft);

        let mut apys : Vec<APY> = Vec::new();
        apys.push(apy1);
        apys.push(apy2);
        apys.push(apy3);

        let contract = Contract::new(AccountId::try_from(ALICE.to_string()).unwrap(),fts,apys);

        log!("{:?}", contract.approved_fts);
    }

    #[test]
    fn test_registered_members_insertion(){
        let context = get_context(false);
        testing_env!(context.clone());

        let amount1:U128 = U128::from(500_000_000_000_000_0000_000_000_000);
        let amount2:U128 = U128::from(1000_000_000_000_000_0000_000_000_000);
        let amount3:U128 = U128::from(2000_000_000_000_000_0000_000_000_000);
        let duration1 : String = "3months".to_string();
        let duration2 : String = "6months".to_string();
        let duration3 : String = "12months".to_string();
        let apy1 : APY = APY{
            apy_key : duration1,
            min_staking_amount : amount1,
            min_duration : 3,
            interest_rate: 250,
        };
        let apy2 : APY = APY{
            apy_key : duration2,
            min_staking_amount : amount2,
            min_duration : 6,
            interest_rate: 500,
        };
        let apy3 : APY = APY{
            apy_key : duration3,
            min_staking_amount : amount3,
            min_duration : 12,
            interest_rate: 1000,
        };
        let mut fts : Vec<FT> = Vec::new();

        let ft = FT{
            account_id : AccountId::try_from(FT_CONTRACT.to_string()).unwrap(),
            symbol : "FT".to_string(),
            apy_against_duration: None
        };
        fts.push(ft.clone());

        let mut apys : Vec<APY> = Vec::new();
        apys.push(apy1);
        apys.push(apy2);
        apys.push(apy3);

        let mut contract = Contract::new(AccountId::try_from(ALICE.to_string()).unwrap(),fts,apys);

        let mut registered_members : Vec<AccountId> = Vec::new();
        registered_members.push(AccountId::try_from(ALICE.clone().to_string()).unwrap());
        contract.registered_members.insert(&ft.account_id, &registered_members);

       // contract.all_registered_memebers(ft.account_id);

    }

    #[test]
    fn test_depositted_for_storage_member_insertion(){

        let context = get_context(false);
        testing_env!(context.clone());

        let amount1:U128 = U128::from(500_000_000_000_000_0000_000_000_000);
        let amount2:U128 = U128::from(1000_000_000_000_000_0000_000_000_000);
        let amount3:U128 = U128::from(2000_000_000_000_000_0000_000_000_000);
        let duration1 : String = "3months".to_string();
        let duration2 : String = "6months".to_string();
        let duration3 : String = "12months".to_string();
        let apy1 : APY = APY{
            apy_key : duration1,
            min_staking_amount : amount1,
            min_duration : 3,
            interest_rate: 250,
        };
        let apy2 : APY = APY{
            apy_key : duration2,
            min_staking_amount : amount2,
            min_duration : 6,
            interest_rate: 500,
        };
        let apy3 : APY = APY{
            apy_key : duration3,
            min_staking_amount : amount3,
            min_duration : 12,
            interest_rate: 1000,
        };
        let mut fts : Vec<FT> = Vec::new();

        let ft = FT{
            account_id : AccountId::try_from(FT_CONTRACT.to_string()).unwrap(),
            symbol : "FT".to_string(),
            apy_against_duration: None
        };
        fts.push(ft.clone());

        let mut apys : Vec<APY> = Vec::new();
        apys.push(apy1);
        apys.push(apy2);
        apys.push(apy3);

        let mut contract = Contract::new(AccountId::try_from(ALICE.to_string()).unwrap(),fts,apys);

        let mut members : UnorderedSet<AccountId> = UnorderedSet::new(b"s");
        members.insert(&AccountId::try_from(ALICE.clone().to_string()).unwrap());
        contract.depositted_for_storage.insert(&ft.account_id, &members);

    }

    #[test]
    fn test_staking_history_insertion(){
        let context = get_context(false);
        testing_env!(context.clone());

        let amount1:U128 = U128::from(500_000_000_000_000_0000_000_000_000);
        let amount2:U128 = U128::from(1000_000_000_000_000_0000_000_000_000);
        let amount3:U128 = U128::from(2000_000_000_000_000_0000_000_000_000);
        let duration1 : String = "3months".to_string();
        let duration2 : String = "6months".to_string();
        let duration3 : String = "12months".to_string();
        let apy1 : APY = APY{
            apy_key : duration1,
            min_staking_amount : amount1,
            min_duration : 3,
            interest_rate: 250,
        };
        let apy2 : APY = APY{
            apy_key : duration2,
            min_staking_amount : amount2,
            min_duration : 6,
            interest_rate: 500,
        };
        let apy3 : APY = APY{
            apy_key : duration3,
            min_staking_amount : amount3,
            min_duration : 12,
            interest_rate: 1000,
        };
        let mut fts : Vec<FT> = Vec::new();

        let ft = FT{
            account_id : AccountId::try_from(FT_CONTRACT.to_string()).unwrap(),
            symbol : "FT".to_string(),
            apy_against_duration: None
        };
        fts.push(ft.clone());

        let mut apys : Vec<APY> = Vec::new();
        apys.push(apy1.clone());
        apys.push(apy2.clone());
        apys.push(apy3.clone());

        let mut contract = get_contract();

        let mut staking_history : Vec<Stake> = Vec::new();
        let stake = Stake{
            stake_id : U128::from(1),
            ft_symbol : ft.symbol,
            ft_account_id : ft.account_id.clone(),
            decimal : 24,
            amount : U128::from(500000000000000000000000000),
            duration : 180,
            staked_at : env::block_timestamp()/1000000000,
            staked_by : context.signer_account_id.clone().try_into().unwrap(),
            staking_plan : apy1.clone().apy_key

        };

        staking_history.push(stake);

        contract.staking_history.insert(&ft.account_id, &staking_history);
    }

    fn get_contract()->Contract{
        let context = get_context(false);
        testing_env!(context.clone());

        let amount1:U128 = U128::from(500_000_000_000_000_0000_000_000_000);
        let amount2:U128 = U128::from(1000_000_000_000_000_0000_000_000_000);
        let amount3:U128 = U128::from(2000_000_000_000_000_0000_000_000_000);
        let duration1 : String = "3months".to_string();
        let duration2 : String = "6months".to_string();
        let duration3 : String = "12months".to_string();
        let apy1 : APY = APY{
            apy_key : duration1,
            min_staking_amount : amount1,
            min_duration : 3,
            interest_rate: 250,
        };
        let apy2 : APY = APY{
            apy_key : duration2,
            min_staking_amount : amount2,
            min_duration : 6,
            interest_rate: 500,
        };
        let apy3 : APY = APY{
            apy_key : duration3,
            min_staking_amount : amount3,
            min_duration : 12,
            interest_rate: 1000,
        };
        let mut fts : Vec<FT> = Vec::new();

        let ft = FT{
            account_id : AccountId::try_from(FT_CONTRACT.to_string()).unwrap(),
            symbol : "FT".to_string(),
            apy_against_duration: None
        };
        fts.push(ft.clone());

        let mut apys : Vec<APY> = Vec::new();
        apys.push(apy1.clone());
        apys.push(apy2.clone());
        apys.push(apy3.clone());

        let  contract = Contract::new(AccountId::try_from(ALICE.to_string()).unwrap(),fts,apys);
        contract
    }
    #[test]
    fn test_claim_history_insertion(){
        let mut contract = get_contract();

        let claim_history = ClaimHistory{
            last_claimed_at : env::block_timestamp(),
            claim_count  :1
        };

        contract.claim_history.insert(&U128::from(1), &claim_history);
    }
}

'''
'''--- src/neardev/dev-account.env ---
CONTRACT_NAME=dev-1652788039377-63261585849977
'''
'''--- src/shell_scripts/build.sh ---
set -e
cd "`dirname $0`"
cargo build --all --target wasm32-unknown-unknown --release
'''
'''--- src/shell_scripts/claim_reward.sh ---
 echo "Please provide STAKING_CONTRACT_ADDRESS EX: ncd_staking_contract.testnet"
read STAKING_CONTRACT
echo "Please provide your testnet account id EX: johndoe.testnet"
read ACCOUNT
echo "Please provide STAKE_ID Ex: "1""
read STAKE_ID

near call $STAKING_CONTRACT claim_reward '{"stake_id": "'"$STAKE_ID"'"}' --accountId $ACCOUNT
'''
'''--- src/shell_scripts/deposit_storage.sh ---
# near call $CONTRACT_NAME deposit_for_storage '{"ft_contract_id" : "ncd_ft_token.testnet"}' --accountId  $ACCOUNT_ID --deposit 0.00859

echo "Please provide STAKING_CONTRACT_ADDRESS EX: ncd_staking_contract.testnet"
read STAKING_CONTRACT
echo "Please provide your testnet account id EX: johndoe.testnet"
read ACCOUNT
echo "Please provide your FT_CONTRACT_ADDRESS Ex: ncd_ft_token.testnet"
read FT_CONTRACT

near call $STAKING_CONTRACT deposit_for_storage '{"ft_contract_id":"ncd_ft_token.testnet"}' --accountId $ACCOUNT --deposit 0.00859

near call $STAKING_CONTRACT drop_ft '{"account_id":"'"$ACCOUNT"'", "ft_contract_id" : "'"$FT_CONTRACT"'"}' --account_id $ACCOUNT

'''
'''--- src/shell_scripts/get_apy.sh ---
echo "Please provide STAKING_CONTRACT_ADDRESS EX: ncd_staking_contract.testnet"
read STAKING_CONTRACT

echo "Please provide your FT_CONTRACT_ADDRESS Ex: ncd_ft_token.testnet"
read FT_CONTRACT

near view $STAKING_CONTRACT get_apy '{"ft_contract_id" : "'"$FT_CONTRACT"'"}'
'''
'''--- src/shell_scripts/stake.sh ---
echo "Please provide STAKING_CONTRACT_ADDRESS EX: ncd_staking_contract.testnet"
read STAKING_CONTRACT
echo "Please provide your testnet account id EX: johndoe.testnet"
read ACCOUNT
echo "Please provide your FT_CONTRACT_ADDRESS Ex: ncd_ft_token.testnet"
read FT_CONTRACT

near call $FT_CONTRACT ft_transfer_call '{"receiver_id": "ncd_staking_contract.testnet",
"amount": "250000000000000000000000000","msg": "{\"ft_symbol\":\"UNCT\",\"ft_account_id\":\"ncd_ft_token.testnet\",\"decimal\":24,\"duration\":180,\"staked_by\":\"'"$ACCOUNT"'\",\"staking_plan\":\"3minutes\"}"}' --accountId $ACCOUNT --depositYocto 1 --gas 300000000000000

near call $FT_CONTRACT ft_transfer_call '{"receiver_id": "ncd_staking_contract.testnet",
  "amount": "500000000000000000000000000","msg": "{\"ft_symbol\":\"UNCT\",\"ft_account_id\":\"ncd_ft_token.testnet\",\"decimal\":24,\"duration\":180,\"staked_by\":\"'"$ACCOUNT"'\",\"staking_plan\":\"3minutes\"}"}' --accountId $ACCOUNT --depositYocto 1 --gas 300000000000000
'''
'''--- src/shell_scripts/test.sh ---
cargo test -- --nocapture
'''
'''--- src/shell_scripts/unstake.sh ---
 
 echo "Please provide STAKING_CONTRACT_ADDRESS EX: ncd_staking_contract.testnet"
read STAKING_CONTRACT
echo "Please provide your testnet account id EX: johndoe.testnet"
read ACCOUNT
echo "Please provide STAKE_ID Ex: "1""
read STAKE_ID
 near call $STAKING_CONTRACT ft_unstake '{"stake_id" : "'"$STAKE_ID"'"}' --accountId $ACCOUNT 
'''
'''--- src/tests/sim/main.rs ---
mod tests;
mod utils;
'''
'''--- src/tests/sim/tests.rs ---
use near_sdk::json_types::U128;
use near_sdk_sim::{call, to_yocto, transaction::ExecutionStatus, view};
use std::{thread, time};

use crate::utils::{init, register_user};

#[test]
fn simulate_total_supply() {
    let initial_balance = to_yocto("100");

    let (_, ftt, _, _) = init(initial_balance);

    let total_supply: U128 = view!(ftt.ft_total_supply()).unwrap_json();
    assert_eq!(initial_balance, total_supply.0);
}
#[test]
fn simulate_token_transfer() {
    let amount = to_yocto("2000");
    let initial_balance = to_yocto("1000000");
    let (root, ft, _, alice) = init(initial_balance);
    //===> With Macro<========//
    call!(
        root,
        ft.ft_transfer(alice.account_id(), amount.into(), None),
        deposit = 1
    )
    .assert_success();

    let root_balance: U128 = view!(ft.ft_balance_of(root.account_id())).unwrap_json();
     println!("root balance {:?}", root_balance);
    let _alice_balance: U128 = view!(ft.ft_balance_of(alice.account_id())).unwrap_json();
    println!("alice balance {:?}", _alice_balance);
    assert_eq!(initial_balance - amount, root_balance.0);
}
#[test]
pub fn simulate_staking_fungible_tokens() {
    let amount = to_yocto("6000");
    let initial_balance = to_yocto("6000");
    let (root, ft, staking, _) = init(initial_balance);

    register_user(&staking.user_account);
    println!("Root balance before staking : {}",initial_balance);

    //===> With Macro<========//
    let res=call!(root,ft.ft_transfer_call(staking.account_id(),amount.into(),None,"{\"ft_symbol\":\"UNCT\",\"ft_account_id\":\"ft\",\"decimal\":24,\"duration\":7776000,\"staked_by\":\"root\",\"staking_plan\":\"3months\"}".to_string()),
    deposit =1);
    assert!(res.is_ok());

    let root_balance: U128 = view!(ft.ft_balance_of(root.account_id())).unwrap_json();
    let staking_balance: U128 = view!(ft.ft_balance_of(staking.account_id())).unwrap_json();

    println!("Root balance after staking : {:?}",root_balance);
    println!("Erorr : {:?}",res.promise_errors());
    // println!("staking_balance {:?}", staking_balance);

   // assert_eq!(initial_balance - amount, root_balance.0);
    //assert_eq!(amount, staking_balance.0);
}
#[test]
#[should_panic(expected = "Reward can be claimed after staking for 1 minute")]
pub fn simulate_claim_reward() {
    let amount = to_yocto("6000");
    let initial_balance = to_yocto("6000");
    let (root, ft, staking, alice) = init(initial_balance);

    register_user(&staking.user_account);

    let _root_balance: U128 = view!(ft.ft_balance_of(root.account_id())).unwrap_json();
    // println!("Root account balance {:?}", root_balance);
    call!(
        root,
        ft.ft_transfer(alice.account_id(), to_yocto("6000").into(), None),
        deposit = 1
    )
    .assert_success();
    let _alice_balance: U128 = view!(ft.ft_balance_of(alice.account_id())).unwrap_json();
    // println!("Alice balance from root = {:?}", _alice_balance);
    call!(alice,ft.ft_transfer_call(staking.account_id(),amount.into(),None,"{\"ft_symbol\":\"UNCT\",\"ft_account_id\":\"ft\",\"decimal\":24,\"duration\":15778800,\"staked_by\":\"alice\",\"staking_plan\":\"3months\"}".to_string()),
    deposit =1).assert_success();

    let _alice_balance: U128 = view!(ft.ft_balance_of(alice.account_id())).unwrap_json();
    // println!("Alice balance after stake = {:?}", _alice_balance);

    let root_balance: U128 = view!(ft.ft_balance_of(root.account_id())).unwrap_json();
    // println!("root balance  {:?}", root_balance);
    let staking_balance: U128 = view!(ft.ft_balance_of(staking.account_id())).unwrap_json();
    // println!("staking_balance {:?}", staking_balance);

    assert_eq!(initial_balance - amount, root_balance.0);
    assert_eq!(amount, staking_balance.0);

    let ten_millis = time::Duration::from_secs(10);
    // let num: U128 = "1".to_string();
    thread::sleep(ten_millis);
    // call!(alice, staking.ft_unstake(id)).assert_success();

    let _alice_balance: U128 = view!(ft.ft_balance_of(alice.account_id())).unwrap_json();
    // println!("Alice balance After Unstake = {:?}", _alice_balance);

    // let staking_balance: U128 = view!(ft.ft_balance_of(staking.account_id())).unwrap_json();
    println!("staking_balance {:?}", staking_balance);

    // let root_balance: U128 = view!(ft.ft_balance_of(root.account_id())).unwrap_json();

    // assert_eq!(amount, _alice_balance.0);
    let id: U128 = U128::from(1);
    call!(alice, staking.claim_reward(id)).assert_success();

    let _alice_balance: U128 = view!(ft.ft_balance_of(alice.account_id())).unwrap_json();
    // println!("Alice balance After Unstake = {:?}", _alice_balance);
}
#[test]
pub fn check_minimum_limit_staking() {
    let amount = to_yocto("3000");
    let initial_balance = to_yocto("3000");
    let (root, ft, staking, _) = init(initial_balance);

    register_user(&staking.user_account);

    //===> With Macro<========//
    let res=call!(root,ft.ft_transfer_call(staking.account_id(),amount.into(),None,"{\"ft_symbol\":\"UNCT\",\"ft_account_id\":\"ft\",\"decimal\":24,\"duration\":15778800,\"staked_by\":\"root\",\"staking_plan\":\"3months\"}".to_string()),
    deposit =1);
    assert!(res.is_ok());

    if let ExecutionStatus::Failure(execution_error) =
        &res.promise_errors().remove(0).unwrap().outcome().status
    {
        assert!(execution_error
            .to_string()
            .contains("Cannot stake less than 5000000000000000000000000000 tokens"));
    } else {
        unreachable!();
    }
    // println!("promise error starts{:#?}", res.promise_errors());
}

#[test]
pub fn check_min_staking_duration() {
    let amount = to_yocto("6000");
    let initial_balance = to_yocto("6000");
    let (root, ft, staking, _) = init(initial_balance);

    register_user(&staking.user_account);

    //===> With Macro<========//
    let res=call!(root,ft.ft_transfer_call(staking.account_id(),amount.into(),None,"{\"ft_symbol\":\"UNCT\",\"ft_account_id\":\"ft\",\"decimal\":24,\"duration\":1577880,\"staked_by\":\"root\",\"staking_plan\":\"3months\"}".to_string()),
    deposit =1);
    assert!(res.is_ok());

    if let ExecutionStatus::Failure(execution_error) =
        &res.promise_errors().remove(0).unwrap().outcome().status
    {
        assert!(execution_error.to_string().contains("Invalid Duration"));
    } else {
        unreachable!();
    }
    // println!("promise error starts{:#?}", res.promise_errors());
}

#[test]
pub fn validate_staking_arguments() {
    let amount = to_yocto("6000");
    let initial_balance = to_yocto("6000");
    let (root, ft, staking, _) = init(initial_balance);

    register_user(&staking.user_account);

    //===> With Macro<========//
    let res=call!(root,ft.ft_transfer_call(staking.account_id(),amount.into(),None,"{\"ft_symbol\":\"UNCT\",\"ft_account_\":\"ft\",\"decimal\":24,\"duration\":1577880,\"staked_by\":\"root\",\"staking_plan\":\"3months\"}".to_string()),
    deposit =1);
    assert!(res.is_ok());

    if let ExecutionStatus::Failure(execution_error) =
        &res.promise_errors().remove(0).unwrap().outcome().status
    {
        assert!(execution_error
            .to_string()
            .contains("Invalid Staking Argument"));
    } else {
        unreachable!();
    }
    // println!("promise error starts{:#?}", res.promise_errors());
}

#[test]
#[ignore]
#[should_panic]
pub fn check_approved_ft_tokens() {
    let amount = to_yocto("6000");
    let initial_balance = to_yocto("6000");
    let (root, ft, staking, _) = init(initial_balance);

    register_user(&staking.user_account);

    //===> With Macro<========//
    let res=call!(root,ft.ft_transfer_call(staking.account_id(),amount.into(),None,"{\"ft_symbol\":\"UNCT\",\"ft_account_id\":\"ftt\",\"decimal\":24,\"duration\":15552000,\"staked_by\":\"root\",\"staking_plan\":\"3months\"}".to_string()),
    deposit =1);
    println!("{:?}",res.promise_errors());
    assert!(res.is_ok());

    if let ExecutionStatus::Failure(execution_error) =
        &res.promise_errors().remove(0).unwrap().outcome().status
    {
        assert!(execution_error
            .to_string()
            .contains("Only approved FT can be staked"));
    } else {
        unreachable!();
    }
    // println!("promise error starts{:#?}", res.promise_errors());
}

#[test]
pub fn check_staking_plan_validity() {
    let amount = to_yocto("6000");
    let initial_balance = to_yocto("6000");
    let (root, ft, staking, _) = init(initial_balance);

    register_user(&staking.user_account);

    //===> With Macro<========//
    let res=call!(root,ft.ft_transfer_call(staking.account_id(),amount.into(),None,"{\"ft_symbol\":\"UNCT\",\"ft_account_id\":\"ft\",\"decimal\":24,\"duration\":15778800,\"staked_by\":\"alice\",\"staking_plan\":\"2months\"}".to_string()),
    deposit =1);
    println!("alice transaction receipt{:#?}", res.promise_results());
    assert!(res.is_ok());

    if let ExecutionStatus::Failure(execution_error) =
        &res.promise_errors().remove(0).unwrap().outcome().status
    {
        //Because with wrong plan there is no Apy exists.
        assert!(execution_error.to_string().contains("None"));
    } else {
        unreachable!();
    }
    // println!("promise error starts{:#?}", res.promise_errors());
}

#[test]
#[should_panic(expected = "No staking data with this id found for caller")]
pub fn check_stake_id_for_claim_reward() {
    let amount = to_yocto("6000");
    let initial_balance = to_yocto("6000");
    let (root, ft, staking, alice) = init(initial_balance);

    register_user(&staking.user_account);
    call!(
        root,
        ft.ft_transfer(alice.account_id(), to_yocto("6000").into(), None),
        deposit = 1
    )
    .assert_success();
    call!(alice,ft.ft_transfer_call(staking.account_id(),amount.into(),None,"{\"ft_symbol\":\"UNCT\",\"ft_account_id\":\"ft\",\"decimal\":24,\"duration\":15778800,\"staked_by\":\"alice\",\"staking_plan\":\"3months\"}".to_string()),
    deposit =1).assert_success();

    let root_balance: U128 = view!(ft.ft_balance_of(root.account_id())).unwrap_json();
    let staking_balance: U128 = view!(ft.ft_balance_of(staking.account_id())).unwrap_json();

    assert_eq!(initial_balance - amount, root_balance.0);
    assert_eq!(amount, staking_balance.0);

    let ten_millis = time::Duration::from_secs(10);
    thread::sleep(ten_millis);
    let id: U128 = U128::from(2);
    call!(alice, staking.claim_reward(id)).assert_success();
}

#[test]
#[should_panic(expected = "This user has not staked yet.")]
pub fn check_user_staked_for_claim_reward() {
    let initial_balance = to_yocto("6000");
    let (_, _, staking, alice) = init(initial_balance);

    let id: U128 = U128::from(2);
    call!(alice, staking.claim_reward(id)).assert_success();
}

#[test]
#[should_panic(expected = "Reward can be claimed after staking for 30 days")]
pub fn check_claim_reward_duration() {
    let amount = to_yocto("6000");
    let initial_balance = to_yocto("6000");
    let (root, ft, staking, alice) = init(initial_balance);

    register_user(&staking.user_account);
    call!(
        root,
        ft.ft_transfer(alice.account_id(), to_yocto("6000").into(), None),
        deposit = 1
    )
    .assert_success();
    call!(alice,ft.ft_transfer_call(staking.account_id(),amount.into(),None,"{\"ft_symbol\":\"UNCT\",\"ft_account_id\":\"ft\",\"decimal\":24,\"duration\":15778800,\"staked_by\":\"alice\",\"staking_plan\":\"3months\"}".to_string()),
    deposit =1).assert_success();

    let root_balance: U128 = view!(ft.ft_balance_of(root.account_id())).unwrap_json();
    let staking_balance: U128 = view!(ft.ft_balance_of(staking.account_id())).unwrap_json();

    assert_eq!(initial_balance - amount, root_balance.0);
    assert_eq!(amount, staking_balance.0);

    let ten_millis = time::Duration::from_secs(10);
    thread::sleep(ten_millis);
    let id: U128 = U128::from(1);

    call!(alice, staking.claim_reward(id)).assert_success();
}

#[test]
#[ignore = "Time Duration of Staked tokens is less than expected to claim reward"]
pub fn check_claim_reward_() {
    let amount = to_yocto("6000");
    let initial_balance = to_yocto("6000");
    let (root, ft, staking, alice) = init(initial_balance);

    register_user(&staking.user_account);
    call!(
        root,
        ft.ft_transfer(alice.account_id(), to_yocto("6000").into(), None),
        deposit = 1
    )
    .assert_success();
    call!(alice,ft.ft_transfer_call(staking.account_id(),amount.into(),None,"{\"ft_symbol\":\"UNCT\",\"ft_account_id\":\"ft\",\"decimal\":24,\"duration\":15778800,\"staked_by\":\"alice\",\"staking_plan\":\"3months\"}".to_string()),
    deposit =1).assert_success();

    let root_balance: U128 = view!(ft.ft_balance_of(root.account_id())).unwrap_json();
    let staking_balance: U128 = view!(ft.ft_balance_of(staking.account_id())).unwrap_json();

    assert_eq!(initial_balance - amount, root_balance.0);
    assert_eq!(amount, staking_balance.0);

    let ten_millis = time::Duration::from_secs(10);
    thread::sleep(ten_millis);
    let id: U128 = U128::from(1);

    call!(alice, staking.claim_reward(id)).assert_success();
}

//<=========================>//
//    UNSTAKING TEST CASES   //
//<=========================>//
#[test]
#[should_panic(expected = "No staking data with this id found for caller")]
pub fn check_stake_id_for_un_staking() {
    let amount = to_yocto("6000");
    let initial_balance = to_yocto("6000");
    let (root, ft, staking, alice) = init(initial_balance);

    register_user(&staking.user_account);

    call!(
        root,
        ft.ft_transfer(alice.account_id(), to_yocto("6000").into(), None),
        deposit = 1
    )
    .assert_success();
    call!(alice,ft.ft_transfer_call(staking.account_id(),amount.into(),None,"{\"ft_symbol\":\"UNCT\",\"ft_account_id\":\"ft\",\"decimal\":24,\"duration\":15778800,\"staked_by\":\"alice\",\"staking_plan\":\"3months\"}".to_string()),
    deposit =1).assert_success();

    let root_balance: U128 = view!(ft.ft_balance_of(root.account_id())).unwrap_json();
    let staking_balance: U128 = view!(ft.ft_balance_of(staking.account_id())).unwrap_json();

    assert_eq!(initial_balance - amount, root_balance.0);
    assert_eq!(amount, staking_balance.0);
    let id: U128 = U128::from(2);

    call!(alice, staking.ft_unstake(id)).assert_success();
}

#[test]
#[should_panic(expect = "Only owner can unstake tokens")]
pub fn check_who_can_unstake() {
    let amount = to_yocto("6000");
    let initial_balance = to_yocto("12000");
    let (root, ft, staking, alice) = init(initial_balance);

    register_user(&staking.user_account);
    call!(
        root,
        ft.ft_transfer(alice.account_id(), to_yocto("6000").into(), None),
        deposit = 1
    )
    .assert_success();
    call!(alice,ft.ft_transfer_call(staking.account_id(),amount.into(),None,"{\"ft_symbol\":\"UNCT\",\"ft_account_id\":\"ft\",\"decimal\":24,\"duration\":15778800,\"staked_by\":\"alice\",\"staking_plan\":\"3months\"}".to_string()),
    deposit =1).assert_success();
    call!(root,ft.ft_transfer_call(staking.account_id(),amount.into(),None,"{\"ft_symbol\":\"UNCT\",\"ft_account_id\":\"ft\",\"decimal\":24,\"duration\":15778800,\"staked_by\":\"root\",\"staking_plan\":\"3months\"}".to_string()),
    deposit =1).assert_success();

    let root_balance: U128 = view!(ft.ft_balance_of(root.account_id())).unwrap_json();
    let staking_balance: U128 = view!(ft.ft_balance_of(staking.account_id())).unwrap_json();

    assert_eq!(0, root_balance.0);
    assert_eq!(amount + amount, staking_balance.0);
    let id: U128 = U128::from(1);

    call!(root, staking.ft_unstake(id)).assert_success();
}

#[test]
#[should_panic(expected = "Cannot withdraw before locked time")]
pub fn check_duration_of_unstaking() {
    let amount = to_yocto("6000");
    let initial_balance = to_yocto("6000");
    let (root, ft, staking, alice) = init(initial_balance);

    register_user(&staking.user_account);
    call!(
        root,
        ft.ft_transfer(alice.account_id(), to_yocto("6000").into(), None),
        deposit = 1
    )
    .assert_success();
    call!(alice,ft.ft_transfer_call(staking.account_id(),amount.into(),None,"{\"ft_symbol\":\"UNCT\",\"ft_account_id\":\"ft\",\"decimal\":24,\"duration\":15778800,\"staked_by\":\"alice\",\"staking_plan\":\"3months\"}".to_string()),
    deposit =1).assert_success();

    let root_balance: U128 = view!(ft.ft_balance_of(root.account_id())).unwrap_json();
    let staking_balance: U128 = view!(ft.ft_balance_of(staking.account_id())).unwrap_json();

    assert_eq!(initial_balance - amount, root_balance.0);
    assert_eq!(amount, staking_balance.0);
    let id: U128 = U128::from(1);
    //Time duration will no meet
    call!(alice, staking.ft_unstake(id)).assert_success();
}
'''
'''--- src/tests/sim/utils.rs ---
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use ft::ContractContract as FungibleTokenContract;
use ft_staking::ContractContract;
use ft_staking::{APY,FT};

use near_sdk_sim::{deploy, init_simulator, to_yocto, ContractAccount, UserAccount};

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    // update `contract.wasm` for your contract's name
    CONTRACT_WASM_BYTES => "target/wasm32-unknown-unknown/release/ft.wasm",
    STAKING_WASM_BYTES => "target/wasm32-unknown-unknown/release/ft_staking.wasm",

}

const FT_ID: &str = "ft";
const ST_ID: &str = "staking";

pub fn register_user(user: &near_sdk_sim::UserAccount) {
    user.call(
        FT_ID.parse().unwrap(),
        "storage_deposit",
        &json!({
            "account_id": user.account_id()
        })
        .to_string()
        .into_bytes(),
        near_sdk_sim::DEFAULT_GAS / 2,
        near_sdk::env::storage_byte_cost() * 125, // attached deposit
    )
    .assert_success();
}

pub fn init(
    initial_balance: u128,
) -> (
    UserAccount,
    ContractAccount<FungibleTokenContract>,
    ContractAccount<ContractContract>,
    UserAccount,
) {
    let root = init_simulator(None);

    let ft = deploy!(
        contract: FungibleTokenContract,
        contract_id: FT_ID,
        bytes: &CONTRACT_WASM_BYTES,
        signer_account: root,
        init_method: new_default_meta(root.account_id(),initial_balance.into())
    );

    let alice = root.create_user("alice".parse().unwrap(), to_yocto("1000"));
    register_user(&alice);
    let apy_data: Vec<APY> = [
        APY {
            apy_key: "3months".to_string(),
            interest_rate: 250,
            min_duration: 3,
            min_staking_amount: U128::from(500000000000000000000000000),
        },
        APY {
            apy_key: "6months".to_string(),
            interest_rate: 500,
            min_duration: 6,
            min_staking_amount: U128::from(5000000000000000000000000000),
        },
    ]
    .to_vec();
    let approved_fts: Vec<FT> = [FT {
        account_id: ft.account_id(),
        symbol: "UNCT".to_string(),
        apy_against_duration: None,
    }]
    .to_vec();
    let staking = deploy!(
        contract: ContractContract,
        contract_id: ST_ID,
        bytes: &STAKING_WASM_BYTES,
        signer_account: alice,
        init_method: new(root.account_id(),approved_fts,apy_data)
    );

    (root, ft, staking, alice)
}
'''
'''--- webapp/README.md ---
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)

'''
'''--- webapp/package.json ---
{
  "name": "staking-dapp",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.9.0",
    "@emotion/styled": "^11.8.1",
    "@mui/icons-material": "^5.8.0",
    "@mui/material": "^5.8.0",
    "@testing-library/jest-dom": "^5.16.4",
    "@testing-library/react": "^13.2.0",
    "@testing-library/user-event": "^13.5.0",
    "assert": "^2.0.0",
    "near-api-js": "^0.44.2",
    "react": "^18.1.0",
    "react-dom": "^18.1.0",
    "react-scripts": "4.0.3",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts --openssl-legacy-provider start",
    "build": "react-scripts --openssl-legacy-provider build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "react-error-overlay": "^6.0.9"
  }
}

'''
'''--- webapp/public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- webapp/public/manifest.json ---
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

'''
'''--- webapp/public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- webapp/src/App.css ---
.App {
  text-align: center;
  color: aqua;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  height: 200px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

'''
'''--- webapp/src/App.js ---
import './App.css';
import Header from './components/Header';
import StakingComponent from './components/StakingComponent';
import NearProvider from './provider/NearProvider';

function App() {
  return (
    <div className="App">
    <NearProvider>
        <Header/>
      <StakingComponent/>
      </NearProvider>
      
    </div>
  );
}

export default App;

'''
'''--- webapp/src/App.test.js ---
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

'''
'''--- webapp/src/components/APYComponent.js ---
import { Grid, TableBody, Typography ,TableContainer,Table,Paper} from "@mui/material";
import { useContext, useEffect, useState } from "react";
import { NearContext } from "../provider/NearProvider";
import APYTableBody from "./APYTablebody";
import APYTableHead from "./APYTableHead";

export default function APYComponent(){
    const {getAPY,account} = useContext(NearContext)
    const [ftApy, setFtApy] = useState([])

    useEffect(()=>{
        const ftApys = async()=>{
            const response  = await getAPY()
            console.log("apys",response.apy_against_duration)
       let tempArr=[]
Object.values(response.apy_against_duration).map(item=>{
    tempArr=[...tempArr,item]
  
})
setFtApy(tempArr)
//console.log('tempArr', ftApy)

        }
        if (account){
            ftApys()
        }
    })
    return (
        <Grid container xs={12}>
            <Typography variant="h7" sx={{width:'100%'}}>APY Rates</Typography>
            <Grid item xs={12} marginTop="20px">
            <TableContainer component={Paper} sx={{maxWidth : '90%', marginTop :'10px'}}>
            <Table aria-label="simple table" size="small" >
                <APYTableHead/>
                <TableBody>
                    {ftApy?.map((apy)=>{
                        const {apy_key,interest_rate,min_duration,min_staking_amount} = apy
                        return  <APYTableBody key={apy_key} apyKey={apy_key} interestRate = {interest_rate} minDuration = {min_duration} minStakingAmount = {min_staking_amount}/>
                    })}
                </TableBody>
            </Table>
            </TableContainer>
            </Grid>
        </Grid>
    )
}
'''
'''--- webapp/src/components/APYTableHead.js ---
import { TableHead, TableRow, TableCell, Typography } from "@mui/material"
export default function APYTableHead(){

    return(
        <TableHead>
        <TableRow>
            <TableCell>
                <Typography>Staking Plan</Typography>
            </TableCell>
            <TableCell>
                <Typography>Min Tokens</Typography>
            </TableCell>
            <TableCell>
                <Typography>Lock Period (Mins)</Typography>
            </TableCell>
            <TableCell>
                <Typography>APY</Typography>
            </TableCell>
        </TableRow>
    </TableHead>
    )

 
}
'''
'''--- webapp/src/components/APYTablebody.js ---
import { TableCell, TableRow } from "@mui/material";
import { formatNearAmount, parseNearAmount } from "near-api-js/lib/utils/format";

export default function APYTableBody({apyKey,interestRate,minDuration,minStakingAmount}){
    const amount = formatNearAmount(minStakingAmount)
    const interest = (interestRate/10) + "%";
    const apy = minDuration +" "+"Minutes"
    return(
        <TableRow>
            <TableCell>
            {apy || "N/A"}
            </TableCell>
            <TableCell>
               {amount || "NA" }
            </TableCell>
            <TableCell>
                {minDuration || "NA"}
            </TableCell>
            <TableCell>
                {interest || "NA"}
            </TableCell>
        </TableRow>
    )
}
'''
'''--- webapp/src/components/AccountBalance.js ---
import { useEffect,useState } from "react";
import {  Grid, TextField, Typography , Button } from "@mui/material";
import { NearContext } from '../provider/NearProvider';
import { useContext } from 'react';
import { formatNearAmount } from "near-api-js/lib/utils/format";

export default function AccountBalance(){
    const [accountBalance,setAccountBalance]=useState(0)
    const { account, getFTBalance, getAirdrop } = useContext(NearContext)
    useEffect(() => {
        const getBalance = async () => {
            let balance=await getFTBalance()
            //balance = parseInt(balance)
            setAccountBalance(formatNearAmount(balance))
        }
        if(account){
            getBalance()
        }
    },[account,getFTBalance])
    return (
       
        <Grid container spacing={2}>
            <Grid item >
                <Typography variant="h7">Account Balance :</Typography>
            </Grid>
            <Grid item xs={3} container spacing={2}>
                {!account ? (
                
                <Grid item xs={6}>
                <Typography variant="h8">Connect wallet</Typography>
                </Grid>
                ) : (
                <>
                <Grid item xs={6}>
                {/* <Typography variant="h8">{accountBalance ?  parseFloat(accountBalance.replace(/\,/g,''), 10).toFixed(2) : "0"} UNCT</Typography> */}
                <Typography variant="h8">{typeof(accountBalance)==="string" ? parseFloat(accountBalance.replace(/\,/g,''), 10).toFixed(2) : typeof(accountBalance)==="number" ? accountBalance.toFixed(2):"0" } UNCT</Typography>
                                
                </Grid>
                <Grid item xs={6}>
                                <Button variant="outlined" onClick={() => {
                                    getAirdrop()
                }} type="primary">Get UNCT</Button>

                </Grid>
                        </>        
                )}
            </Grid>
        </Grid>
 
        )
}
    

'''
'''--- webapp/src/components/Header.js ---
import * as React from 'react';
import AppBar from '@mui/material/AppBar';
import Box from '@mui/material/Box';
import Toolbar from '@mui/material/Toolbar';
import Typography from '@mui/material/Typography';
import Button from '@mui/material/Button';
// import {login} from '../provider/NearProvider'
import { NearContext } from '../provider/NearProvider';
import { useContext } from 'react';

export default function ButtonAppBar() {
const {login,isConnecting,accountId,isSignedIn,isRegistered,logout} = useContext(NearContext)
const handleLoginChange =()=>{
   login();
   /* let abc = isRegistered()
   console.log("response", abc) */
  }
  return (
    <Box sx={{ flexGrow: 1, width : '100%' }}>
      <AppBar position="static">
        <Toolbar>
         {/*  <IconButton
            size="large"
            edge="start"
            color="inherit"
            aria-label="menu"
            sx={{ mr: 2 }}
          >
            <MenuIcon />
          </IconButton> */}
          <Typography variant="h6" component="div" sx={{width : "210px"}}>
            UNCT Staking Portal
          </Typography>
          <Box sx={{ display : 'flex' ,justifyContent : 'flex-end' ,width: '100%'}}>
        {isSignedIn ?   <Typography component = "div" >{accountId}</Typography>: <Button color="inherit" sx={{display:"visible"}} onClick={handleLoginChange}>Connect Wallet</Button>}

          </Box>
          {isSignedIn && (
              <Button color="inherit" sx={{whiteSpace:'no-wrap',width:'10%'}} onClick={logout}>
                Log Out
              </Button>
        )}
        </Toolbar>
        {/* <Typography variant="h6" component="div" sx={{justifyContent : 'flex-end'}}>Balance</Typography> */}
      </AppBar>
    </Box>
  );
}

'''
'''--- webapp/src/components/StakeForm.js ---
import {  Paper, TextField } from "@mui/material";
export default function StakingInformation({tokens,setTokens}){
    return(
        
        <Paper component='form' elevation={0}>
            <TextField onChange={(e)=>setTokens(e.target.value)} fullWidth label="Tokens to Stake" id="fullWidth" sx={{maxWidth : '50%'}}/>
        </Paper>
    )
}
'''
'''--- webapp/src/components/StakingComponent.js ---
import { Grid, Paper } from "@mui/material";
import AccountBalance from "./AccountBalance";
import APYComponent from "./APYComponent";
import StakingDuration from "./StakingDuration";
import StakingHistory from "./StakingHistory";

export default function StakingForm() {
    return (
        <Paper sx={{ marginTop: '10px' }} elevation={0}>
            <Grid container marginLeft="8px" marginRight="8px">
                {/* Balance item start */}
                <Grid item xs={12} marginTop="10px" >
                    <AccountBalance />
                </Grid>
                {/* Balance item End */}

                <Grid item xs={12} marginTop="10px" marginLeft="10px" marginRight="10px">
                    <APYComponent marginTop="10px"/>
                </Grid>

                {/* Duration Starts */}
                <Grid item xs={12} marginTop="20px">
                    <StakingDuration />
                </Grid>
                {/* Duration Ends */}

                {/* Textfield Start */}

                <Grid item xs={12}>
                   <StakingHistory/>
                </Grid>
            </Grid>
        </Paper>
    )

}

'''
'''--- webapp/src/components/StakingDuration.js ---
import { useState } from "react";
import { Button, Grid, Typography } from "@mui/material";
import StakingInformation from "./StakeForm";
import { NearContext } from '../provider/NearProvider';
import { useContext } from 'react';
import { parseNearAmount } from "near-api-js/lib/utils/format";

export default function StakingDuration() {
    const [duration,setDuration]=useState(0)
    const [tokens,setTokens]=useState(0)
const {stakeTokens,accountId} = useContext(NearContext)
    return (
        <>
        <Grid container xs={12} marginTop="20px">
            <Typography variant="h7" sx={{width : '100%'}}>Select Duration</Typography>

            <Grid item xs={12} marginTop="20px">
                <Grid container spacing={{xs:2}}>
                <Grid item xs={3} >
                <Button variant={duration===3 ? "contained" : 'text'} onClick={()=>setDuration(3)}>3 Minutes</Button>
            </Grid>
            <Grid item xs={3} >
                <Button variant={duration===6 ? "contained" : 'text'} onClick={()=>setDuration(6)}>6 Minutes</Button>
            </Grid>
            <Grid item xs={3} >
                <Button variant={duration===9 ? "contained" : 'text'} onClick={()=>setDuration(9)}>9 Minutes</Button>
            </Grid>
            <Grid item xs={3}>
                <Button variant={duration===12 ? "contained" : 'text'} onClick={()=>setDuration(12)}>12 Minutes</Button>
            </Grid>
                </Grid> 
            </Grid>

        </Grid>
        <Grid item xs={12} marginTop="20px" marginRight="16px">
                <StakingInformation tokens={tokens} setTokens={setTokens}/>
        </Grid>
        <Button onClick={()=>{
            const msg= {
                ft_symbol : "UNCT",
                ft_account_id:"ncd_ft_token.testnet",
                decimal : 24,
                duration: duration*60,
                staked_by : `${accountId}`,
                staking_plan: `${duration}minutes`
            }
            stakeTokens(parseNearAmount(tokens),JSON.stringify(msg))
        }} sx={{ margin: '10px' }}>Stake</Button>

        </>
    )
}
'''
'''--- webapp/src/components/StakingHistory.js ---
import { useEffect,useState } from "react";
import { Grid,Typography,TableContainer,Table,TableBody,Paper } from "@mui/material"
import StakingData from "./TableBody";
import TableHeadings from "./TableHead";
import { NearContext } from '../provider/NearProvider';
import { useContext } from 'react';
export default function StakingHistory(){
    const {getStakingHistory,account} = useContext(NearContext)
    const [history,setHistory]=useState([])
    useEffect(()=>{
        const getHistory=async()=>{
            const historyResponse=await getStakingHistory('0',10)
            setHistory(historyResponse)
        }
        if(account){
            getHistory()
        }else{
            setHistory([])
        }
    },[account])
    return (
        <Grid container xs={12}>
        <Typography variant="h7" sx={{width:'100%'}}>Staking History</Typography>
        <Grid item xs={12} marginTop="10px">
            <TableContainer component={Paper} sx={{maxWidth : '90%'}}>
                <Table aria-label="simple table" >
                    <TableHeadings />
                    <TableBody>
                        {history?.map((stake)=>{
                            const{stake_id,amount,staked_at,staking_plan}=stake
                            //console.log("stake : ",stake)
                           return <StakingData key={stake_id} stakeId={stake_id} amount={amount} stakedAt={staked_at} stakingPlan = {staking_plan}/>
                        })}
                    </TableBody>
                </Table>
            </TableContainer>
        </Grid>
    </Grid>
    )
}
'''
'''--- webapp/src/components/TableBody.js ---
import { Button, TableCell,TableRow } from "@mui/material"
import { formatNearAmount } from "near-api-js/lib/utils/format";
import { NearContext } from '../provider/NearProvider';
import { useContext } from 'react';
export default function StakingData({stakeId,amount,stakedAt,stakingPlan}){
    const {claimReward,unstakeTokens} = useContext(NearContext)
    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }
    const date=new Date(stakedAt*1000).toLocaleDateString("en-US", options)

    const RewardClaimer=async()=>{
        try {
            await claimReward(stakeId)
        window.location.reload()

        } catch (error) {
            alert("Reward can be claimed after staking for 1 minute")
        }
    }

    const TokenUnStaker=async()=>{
        try {
            await unstakeTokens(stakeId)
        window.location.reload()

        } catch (error) {
            alert("Cannot withdraw before locked time")
        }
    }

    return (
        <TableRow>
        <TableCell>
            {stakeId || "N/A"}
        </TableCell>
        <TableCell>
            {formatNearAmount(amount) || "N/A"}
        </TableCell>
        <TableCell>
            {date || "N/A"}
        </TableCell>
        <TableCell>
            {stakingPlan || "N/A"}
        </TableCell>
        <TableCell>
            <Button onClick={()=>RewardClaimer()}>Claim Reward</Button>
            <Button onClick={TokenUnStaker}>Unstake</Button>
        </TableCell>
    </TableRow>
    
    )
}
'''
'''--- webapp/src/components/TableHead.js ---
import { TableHead, TableRow, TableCell, Typography } from "@mui/material"
export default function TableHeadings() {
    return (
        <TableHead>
            <TableRow>
                <TableCell>
                    <Typography variant="h7">
                        Stake ID
                    </Typography>
                </TableCell>
                <TableCell alig>
                    <Typography variant="h7">
                        Amount Staked
                    </Typography>
                </TableCell>
                <TableCell>
                    <Typography variant="h7">Staked On</Typography>

                </TableCell>
                <TableCell>
                    <Typography variant="h7">Staked For</Typography>

                </TableCell>
                <TableCell>
                    <Typography variant="h7">
                        Actions
                    </Typography>
                </TableCell>
            </TableRow>
        </TableHead>
    )
}
'''
'''--- webapp/src/index.css ---
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

'''
'''--- webapp/src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
    <App />
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

'''
'''--- webapp/src/logo.svg ---
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>
'''
'''--- webapp/src/provider/NearProvider.js ---
import { createContext, useCallback, useEffect, useState } from "react";
import { connect, keyStores, WalletConnection, utils, Contract } from "near-api-js";
import { parseNearAmount } from "near-api-js/lib/utils/format";
/* import NFT from "../models/NFT";
import Purchasable from "../models/Purchasable";
import viewToMax from "../utils/viewToMax"; */

// --- Production: mainnet ---
// const config = {
//   networkId: "mainnet",
//   contractName: "mtvrs-app.near",
//   nodeUrl: "https://rpc.mainnet.near.org",
//   walletUrl: "https://wallet.mainnet.near.org",
//   helperUrl: "https://helper.mainnet.near.org",
//   explorerUrl: "https://explorer.mainnet.near.org",
// };

// --- Development: testnet ---
const config = {
  networkId: "testnet",
  contractName: "ncd_staking_contract.testnet",
  nodeUrl: "https://rpc.testnet.near.org",
  walletUrl: "https://wallet.testnet.near.org",
  helperUrl: "https://helper.testnet.near.org",
  explorerUrl: "https://explorer.testnet.near.org",
};

const GAS = "300000000000000"; // max gas for any transaction

export const NearContext = createContext({});

export default function NearProvider({ children }) {
  // Internal state
  const [, setNearConnection] = useState(null);
  const [walletConnection, setWalletConnection] = useState(null);
  const [accountId, setAccountId] = useState(null);

  // External state.
  const [isConnecting, setIsConnecting] = useState(true);
  const [isSignedIn, setIsSignedIn] = useState(false);
  const [isError, setIsError] = useState(false);
  const [isLoggingIn] = useState(false);
  const [account, setAccount] = useState(null);
  const [accountNearBalance, setAccountNearBalance] = useState(null);
  const [accountUsername, setAccountUsername] = useState(null);
  const [regInfo, setregInfo] = useState({})

  const loginKey = 'loginKey';

  useEffect(() => {
    const keyStore = new keyStores.BrowserLocalStorageKeyStore();
    const connectNear = async () => {
      try {
        const near = await connect({ ...config, keyStore });
        const walletConnection = new WalletConnection(near);
        setNearConnection(near);
        setWalletConnection(walletConnection);

        if (walletConnection.isSignedIn()) {
          const account = walletConnection.account();
          const name = walletConnection._authData.accountId;
          setAccountId(walletConnection.getAccountId());
          setIsSignedIn(true)
          setAccount(account)
          /*     let abc = isRegistered()
       console.log("response", abc) */
        } else {
          setIsSignedIn(false)

        }
      } catch (e) {
        console.error(e);
        setIsError(true);
      }
      setIsConnecting(false);
    };

    connectNear();
  }, []);

  useEffect(() => {
    if (account != null) {
      hasDeposittedForStorage()

    }

  }, [account])

  const getAccountAndNearBalance = useCallback(async () => {
    if (account == null) {
      setAccountNearBalance(null);
      return;
    }

    let balance;
    try {
      balance = await account.getAccountBalance();
    } catch (e) {
      console.error(e);
      setAccountNearBalance(null);
      return;
    }

    setAccountNearBalance(utils.format.formatNearAmount(balance.available, 2));
  }, [account]);

  useEffect(() => {
    // Fetch the near balance.
    getAccountAndNearBalance();
  }, [getAccountAndNearBalance]);

  const login = useCallback(() => {
    // console.log ("near amount", parseNearAmount("0.00859"))
    walletConnection?.requestSignIn({
      contractId: config.contractName,

    }
    );

  }, [walletConnection]);

  const logout = useCallback(() => {
    walletConnection?.signOut();
    setIsSignedIn(false);
    setAccountId(null);
    setAccount(null);
  }, [walletConnection]);

  /*   const getNftsForAccount = useCallback(async () => {
      if (account == null || accountId == null) {
        throw new Error("account must be defined");
      }
  
      const tokens = await viewToMax(
        account,
        config.contractName,
        "nft_tokens_for_owner",
        { account_id: accountId }
      );
  
      return (tokens ?? []).map(NFT.fromNear);
    }, [account, accountId]); */

  /*   const getMetadataForToken = useCallback(
      async (tokenType) => {
        if (account == null) {
          throw new Error("account must be defined");
        }
  
        const token = await account.viewFunction(
          config.contractName,
          "metadata_get",
          {
            token_type: tokenType,
          }
        );
  
        if (token == null) {
          return null;
        }
  
        const tokenList = await viewToMax(
          account,
          config.contractName,
          "minted_tokens_list",
          { token_type: tokenType },
          "offset"
        );
  
        const tokenMaxSupply = parseInt(token.copies);
        const numOfMintedTokens = tokenList?.length ?? 0;
  
        const isAvailable =
          !isNaN(tokenMaxSupply) && numOfMintedTokens < tokenMaxSupply;
  
        return Purchasable.fromNear(tokenType, token, isAvailable);
      },
      [account]
    ); */

  /*   const purchaseNFT = useCallback(
      async (tokenId, quantity) => {
        if (account == null) {
          throw new Error("Account must be defined");
        }
  
        return account.functionCall({
          contractId: config.contractName,
          methodName: "metamon_purchase",
          args: {
            token_type: tokenId,
          },
          gas: GAS,
          // TODO - Get price from master ali.
          attachedDeposit: parseNearAmount("10"),
        });
      },
      [account]
    ); */

  
  const isRegistered = useCallback(
    async () => {
      console.log("account_id and contract", account.accountId + " " + config.contractName)
      if (account == null) {
        throw new Error("Account must be defined");
      }
      return account.viewFunction({
        contractId: config.contractName,
        methodName: "is_registered",
        args: {
          ft_contract_id: "ncd_ft_token.testnet",
          account_id: account.accountId
        }
      });
      console.log('regInfo****', regInfo)
    },
    [account]
    // console.log("account : ",account)
  );

  const hasDeposittedForStorage = useCallback(
    async () => {
      let token;
      if (account != null) {
        token = await account?.viewFunction(
          config.contractName,
          "has_depositted_for_storage",
          {
            ft_contract_id: "ncd_ft_token.testnet",
            account_id: account.accountId
          }
        );
        console.log("has_depositted_for_storage", token)
        if (token === false) {
          depositForStorage()
        }

      }
      setregInfo(token)

    },
    [account]
  );

  const getStakingHistory = useCallback(
    async (fromIndex,limit)=>{
      if (account == null) {
        throw new Error("Account must be defined");
      }
      let history= await account?.viewFunction(
        config.contractName, "get_staking_history",
        {
          account_id : account.accountId,
          from_index : fromIndex,
          limit : limit
        }
        
        );
        return history
    },[account]
    )
    const getAPY =useCallback(
      
      async()=>{
        if (account == null) {
          throw new Error("Account must be defined");
        }
        const res = await account?.viewFunction(
          config.contractName, "get_apy",
          {
            ft_contract_id : "ncd_ft_token.testnet"
          }
        );
        return res
      },[account]
    )

  const depositForStorage = useCallback(
    async () => {
      if (account == null) {
        throw new Error("Account must be defined");
      }
      try {
        const resp = await account.functionCall({
          contractId: config.contractName,
          methodName: "deposit_for_storage",
          args: {
            ft_contract_id: "ncd_ft_token.testnet"
          }, gas: GAS,
          attachedDeposit: parseNearAmount("0.00859")
        })
        console.log('resp*****', resp)
      } catch (error) {
        console.log('error****', error)
      }

    }, [account]
  );

  const claimReward = useCallback(
    async (stakeId) => {
      if (account == null) {
        throw new Error("Account must be defined");
      }
      return account.functionCall({
        contractId: config.contractName,
        methodName: "claim_reward",
        args: {
          stake_id: stakeId
        },
        gas: GAS
      })
    }, [account]
  )

  const unstakeTokens = useCallback(
    async (stakeId) => {
      if (account == null) {
        throw new Error("Account must be defined");
      }
      return account.functionCall({
        contractId: config.contractName,
        methodName: "ft_unstake",
        args: {
          stake_id: stakeId
        }, gas: GAS
      })
    }, [account]
  )

  const getFTBalance = useCallback(
    async()=>{
      if (account === null){
        throw new Error("Account must be defined");
      }
      const ftContract =  new Contract(account,"ncd_ft_token.testnet",{
        viewMethods : ["ft_balance_of"],
        sender : account.accountId
      })
      let balance;
      balance = await ftContract?.ft_balance_of(
        {account_id : account.accountId}
      );
      return balance
    },[account]
  )

  const getAirdrop =useCallback(
    async()=>{
      try {
        if (account == null){
          throw new Error("Account must be defined");
        }
        const stakingContract =  new Contract(account,"ncd_staking_contract.testnet",{
          changeMethods : ["drop_ft"], sender : account.accountId
        })
        let response;
        response = await stakingContract?.drop_ft(
          {account_id : account.accountId, ft_contract_id : "ncd_ft_token.testnet"}
        );
        window.location.reload()
        return response
      } catch (error) {
        alert("Already claimed drop")
      }
    },[account]
  )

  const stakeTokens = useCallback(
    async(amt,message)=>{
      if (account == null){
        throw new Error("Account must be defined");
      }
      const res = await account.functionCall(
        {
          contractId : "ncd_ft_token.testnet",
          methodName : "ft_transfer_call",
          args:{
            receiver_id : "ncd_staking_contract.testnet",
            amount : amt,
            msg: message
          },gas : GAS,attachedDeposit: utils.format.parseNearAmount(
            "0.000000000000000000000001"
          )
        }
      )

  /*     const ftContract = new Contract(account, "ncd_ft_token.testnet", {
        changeMethods : ["ft_transfer_call"], sender : account.accountId
      })
      let response = await ftContract?.ft_transfer_call(
        {receiver_id : "ncd_staking_contract.testnet",amount: amt,msg : message,attachedDeposit: parseNearAmount("0.000000000000000000000001") }
      );
      return response */
      return res
    },[account]
  )

 /*  const res = await account.functionCall({
    contractId: contractName,
    methodName: change_methods.STAKE_TOKENS,
    args: {
      receiver_id: "staking_bkrt.testnet",
      amount: amount,
      msg: JSON.stringify({
        ft_symbol: "BKRT",
        ft_account_id: "ft_bkrt.testnet",
        decimal: 24,
        duration: duration,
        staked_by: walletAccountId,
        staking_plan: "BKRTPremium6",
      }),
    },

    gas: digits.GAS,
    // // TODO - Get price from master ali.
    attachedDeposit: utils.format.parseNearAmount(
      "0.000000000000000000000001"
    ),
  }); */

 

  /*   const stakeTokens = useCallback(
      async ()=>{
        if(account==null){
          throw new Error("Account must be defined");
        }
        return account.functionCall({
          contractId : ft_contract_id,
          methodName : "ft_transfer_call",
          args : {
            receiver_id : config.contractName,
  
          }
        })
      },[account]
    ) */

  const redeemSurprisePack = useCallback(
    (tokenId) => {
      if (account == null) {
        throw new Error("Account Must be defined");
      }

      return account.functionCall({
        contractId: config.contractName,
        methodName: "metamon_redeem_surprise_pack",
        args: {
          token_id: tokenId,
        },
        gas: GAS,
      });
    },
    [account]
  );

  const evolveToNextGeneration = useCallback(
    (firstTokenId, secondTokenId) => {
      if (
        firstTokenId == null ||
        secondTokenId == null ||
        firstTokenId === "" ||
        secondTokenId === "" ||
        firstTokenId === secondTokenId
      ) {
        throw new Error("Tokens must be unique and defined");
      }

      if (account == null) {
        throw new Error("Accoutn msut be defined");
      }

      return account.functionCall({
        contractId: config.contractName,
        methodName: "metamon_evolve",
        args: {
          token1_id: firstTokenId,
          token2_id: secondTokenId,
        },
        gas: GAS,
      });
    },
    [account]
  );
  return (
    
    <NearContext.Provider
      value={{
        accountUsername,
        isConnecting,
        isLoggingIn,
        isError,
        isSignedIn,
        login,
        logout,
        depositForStorage,
        isRegistered,
        accountNearBalance,
        getAccountAndNearBalance,
        redeemSurprisePack,
        evolveToNextGeneration,
        accountId,
        account,
        getFTBalance,
        getAirdrop,
        stakeTokens,
        getStakingHistory,
        unstakeTokens,
        claimReward,
        getAPY
      }}
    >
      {children}
    </NearContext.Provider>
  );
}
'''
'''--- webapp/src/reportWebVitals.js ---
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

'''
'''--- webapp/src/setupTests.js ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

'''