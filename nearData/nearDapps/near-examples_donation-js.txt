*GitHub Repository "near-examples/donation-js"*

'''--- .devcontainer/devcontainer.json ---
{
  "image": "mcr.microsoft.com/devcontainers/universal:2",
  "features": {
    "ghcr.io/devcontainers/features/rust:1": {},
    "ghcr.io/devcontainers/features/node:1": {
      "version":"20"
    }
  }
  
}

'''
'''--- .github/workflows/tests-rs.yml ---
name: Tests Contract RS
on: push
jobs:
  workflows:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - name: Install and test modules
        run: |
          cd ./contract-rs
          cargo test

'''
'''--- .github/workflows/tests-ts.yml ---
name: Tests Contract TS
on: push
jobs:
  workflows:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: "20"
      - name: Install and test modules
        run: |
          cd ./contract-ts
          yarn
          yarn test

'''
'''--- README.md ---
# Donation Contract Examples

This repository contains examples of donation contracts in both JavaScript and Rust,and an examples of a frontend interacting with a Counter smart contract. 

## Repositories

- [Donation TS Example](contract-ts)
- [Donation RS Example](contract-rs)
- [Donation Frontend Example](Frontend)

'''
'''--- contract-rs/Cargo.toml ---
[package]
name = "contract"
description = "Donation Contract Example for NEAR Protocol"
version = "0.1.0"
edition = "2021"
# TODO: Fill out the repository field to help NEAR ecosystem tools to discover your project.
# NEP-0330 is automatically implemented for all contracts built with https://github.com/near/cargo-near.
# Link to the repository will be available via `contract_source_metadata` view-function.
#repository = "https://github.com/xxx/xxx"

[lib]
crate-type = ["cdylib", "rlib"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[dependencies]
near-sdk = { version = "5.1.0", features = ["legacy"] }

[dev-dependencies]
near-sdk = { version = "5.0.0", features = ["unit-testing"] }
near-workspaces = { version = "0.10.0", features = ["unstable"] }
tokio = { version = "1.12.0", features = ["full"] }
serde_json = "1"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- contract-rs/README.md ---
# Donation Contract

The smart contract exposes multiple methods to handle donating NEAR Tokens to a
beneficiary set on initialization.

## How to Build Locally?

Install [`cargo-near`](https://github.com/near/cargo-near) and run:

```bash
cargo near build
```

## How to Test Locally?

```bash
cargo test
```

## How to Interact?

_In this example we will be using [NEAR CLI](https://github.com/near/near-cli)
to intract with the NEAR blockchain and the smart contract_

_If you want full control over of your interactions we recommend using the
[near-cli-rs](https://near.cli.rs)._

### Initialize

The contract will be automatically initialized with a default beneficiary. To
initialize the contract yourself do:

```bash
near call <deployed-to-account> init '{"beneficiary":"<account>"}' --accountId <deployed-to-account>
```

### Get Beneficiary

`get_beneficiary` is a read-only method (view method) that returns the
beneficiary of the donations.

View methods can be called for free by anyone, even people without a NEAR
account!

```bash
near view <deployed-to-account> get_beneficiary
```

### Change Beneficiary

`change_beneficiary` is a read-only method (view method) that returns the
beneficiary of the donations.

View methods can be called for free by anyone, even people without a NEAR
account!

```bash
near call <deployed-to-account> change_beneficiary {"new_beneficiary": "<new-baccount>"} --accountId <deployed-to-account>
```

### Donate

`donate` forwards any attached NEAR tokens to the `beneficiary` while keeping
track of it.

`donate` is a payable method for which can only be invoked using a NEAR account.
The account needs to attach NEAR Tokens and pay GAS for the transaction.

```bash
near call <deployed-to-account> donate --amount 1 --accountId <account>
```

```rust
#[payable]
    pub fn donate(&mut self) -> String {
        // Get who is calling the method and how much NEAR they attached
        let donor: AccountId = env::predecessor_account_id();
        let donation_amount = env::attached_deposit();

        require!(
            donation_amount > STORAGE_COST,
            format!(
                "Attach at least {} yoctoNEAR to cover for the storage cost",
                STORAGE_COST
            )
        );

        let mut donated_so_far: NearToken = self
            .donations
            .get(&donor)
            .unwrap_or(NearToken::from_near(0));

        let to_transfer = if donated_so_far.is_zero() {
            // This is the user's first donation, lets register it, which increases storage
            // Subtract the storage cost to the amount to transfer
            donation_amount.saturating_sub(STORAGE_COST).to_owned()
        } else {
            donation_amount
        };

        // Persist in storage the amount donated so far
        donated_so_far = donated_so_far.saturating_add(donation_amount);

        self.donations.insert(&donor, &donated_so_far);

        log!(
            "Thank you {} for donating {}! You donated a total of {}",
            donor.clone(),
            donation_amount,
            donated_so_far
        );

        // Send the NEAR to the beneficiary
        Promise::new(self.beneficiary.clone()).transfer(to_transfer);

        // Return the total amount donated so far
        donated_so_far.to_string()
    }
```

### Get Number of Donors

```bash
near view <deployed-to-account> number_of_donors
```

### Get Donations for Account

```bash
near view <deployed-to-account> get_donation_for_account '{"account_id":"<account>"}'
```

### Get Total Donations

```bash
near view <deployed-to-account> get_donations
```

## Useful Links

- [cargo-near](https://github.com/near/cargo-near) - NEAR smart contract
  development toolkit for Rust
- [near CLI-RS](https://near.cli.rs) - Iteract with NEAR blockchain from command
  line
- [NEAR Rust SDK Documentation](https://docs.near.org/sdk/rust/introduction)
- [NEAR Documentation](https://docs.near.org)
- [NEAR StackOverflow](https://stackoverflow.com/questions/tagged/nearprotocol)
- [NEAR Discord](https://near.chat)
- [NEAR Telegram Developers Community Group](https://t.me/neardev)
- NEAR DevHub: [Telegram](https://t.me/neardevhub),
  [Twitter](https://twitter.com/neardevhub)

'''
'''--- contract-rs/rust-toolchain.toml ---
[toolchain]
channel = "stable"
components = ["rustfmt"]
targets = ["wasm32-unknown-unknown"]

'''
'''--- contract-rs/src/donation.rs ---
use near_sdk::json_types::{U128, U64};
use near_sdk::{env, log, near, require, AccountId, NearToken, Promise};

pub const STORAGE_COST: NearToken = NearToken::from_millinear(1);

use crate::Contract;
use crate::ContractExt;

#[near(serializers = [json])]
pub struct Donation {
    pub account_id: AccountId,
    pub total_amount: U128,
}

#[near]
impl Contract {
    #[payable]
    pub fn donate(&mut self) -> String {
        // Get who is calling the method and how much NEAR they attached
        let donor: AccountId = env::predecessor_account_id();
        let donation_amount = env::attached_deposit();

        require!(
            donation_amount > STORAGE_COST,
            format!(
                "Attach at least {} yoctoNEAR to cover for the storage cost",
                STORAGE_COST
            )
        );

        let mut donated_so_far: NearToken = self
            .donations
            .get(&donor)
            .unwrap_or(NearToken::from_near(0));

        let to_transfer = if donated_so_far.is_zero() {
            // This is the user's first donation, lets register it, which increases storage
            // Subtract the storage cost to the amount to transfer
            donation_amount.saturating_sub(STORAGE_COST).to_owned()
        } else {
            donation_amount
        };

        // Persist in storage the amount donated so far
        donated_so_far = donated_so_far.saturating_add(donation_amount);

        self.donations.insert(&donor, &donated_so_far);

        log!(
            "Thank you {} for donating {}! You donated a total of {}",
            donor.clone(),
            donation_amount,
            donated_so_far
        );

        // Send the NEAR to the beneficiary
        Promise::new(self.beneficiary.clone()).transfer(to_transfer);

        // Return the total amount donated so far
        donated_so_far.to_string()
    }

    pub fn get_donation_for_account(&self, account_id: AccountId) -> Donation {
        let amount = self
            .donations
            .get(&account_id)
            .unwrap_or(NearToken::from_near(0))
            .as_yoctonear();

        Donation {
            account_id: account_id.clone(),
            total_amount: U128::from(amount),
        }
    }

    // Public Method - get total number of donors
    pub fn number_of_donors(&self) -> U64 {
        U64::from(self.donations.len())
    }

    // Public Method - paginate through all donations on the contract
    pub fn get_donations(&self, from_index: Option<u32>, limit: Option<u32>) -> Vec<Donation> {
        // where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = from_index.unwrap_or(0);

        self.donations
            .into_iter()
            .skip(start as usize)
            .take(limit.unwrap_or(10) as usize)
            .map(|(account_id, total_amount)| Donation {
                account_id,
                total_amount: U128::from(total_amount.as_yoctonear()),
            })
            .collect()
    }
}

'''
'''--- contract-rs/src/lib.rs ---
// Find all our documentation at https://docs.near.org
use near_sdk::collections::UnorderedMap;
use near_sdk::{near, AccountId, NearToken, PanicOnDefault};

mod donation;

#[near(contract_state)]
#[derive(PanicOnDefault)]
pub struct Contract {
    pub beneficiary: AccountId,
    pub donations: UnorderedMap<AccountId, NearToken>,
}

#[near]
impl Contract {
    #[init]
    #[private] // only callable by the contract's account
    pub fn init(beneficiary: AccountId) -> Self {
        Self {
            beneficiary,
            donations: UnorderedMap::new(b"d"),
        }
    }

    pub fn get_beneficiary(&self) -> &AccountId {
        &self.beneficiary
    }

    #[private] // only callable by the contract's account
    pub fn change_beneficiary(&mut self, new_beneficiary: AccountId) {
        self.beneficiary = new_beneficiary;
    }
}

/*
 * The rest of this file holds the inline tests for the code above
 * Learn more about Rust tests: https://doc.rust-lang.org/book/ch11-01-writing-tests.html
 */
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::testing_env;
    use near_sdk::NearToken;

    const BENEFICIARY: &str = "beneficiary";
    const ONE_NEAR: NearToken = NearToken::from_near(1);

    #[test]
    fn initializes() {
        let contract = Contract::init(BENEFICIARY.parse().unwrap());
        assert_eq!(
            contract.beneficiary,
            BENEFICIARY.parse::<AccountId>().unwrap().to_string()
        );
    }

    #[test]
    fn donate() {
        let mut contract = Contract::init(BENEFICIARY.parse().unwrap());

        // Make a donation
        set_context("donor_a", ONE_NEAR);
        contract.donate();
        let first_donation = contract.get_donation_for_account("donor_a".parse().unwrap());

        // Check the donation was recorded correctly
        assert_eq!(
            u128::from(first_donation.total_amount),
            ONE_NEAR.as_yoctonear()
        );

        // Make another donation
        set_context("donor_b", ONE_NEAR.saturating_mul(2));
        contract.donate();
        let second_donation = contract.get_donation_for_account("donor_b".parse().unwrap());

        // Check the donation was recorded correctly
        assert_eq!(
            u128::from(second_donation.total_amount),
            ONE_NEAR.saturating_mul(2).as_yoctonear()
        );

        // User A makes another donation on top of their original
        set_context("donor_a", ONE_NEAR);
        contract.donate();
        let first_donation = contract.get_donation_for_account("donor_a".parse().unwrap());

        // Check the donation was recorded correctly
        assert_eq!(
            u128::from(first_donation.total_amount),
            ONE_NEAR.saturating_mul(2).as_yoctonear()
        );

        assert_eq!(u64::from(contract.number_of_donors()), 2);
    }

    // Auxiliar fn: create a mock context
    fn set_context(predecessor: &str, amount: NearToken) {
        let mut builder = VMContextBuilder::new();
        builder.predecessor_account_id(predecessor.parse().unwrap());
        builder.attached_deposit(amount);

        testing_env!(builder.build());
    }
}

'''
'''--- contract-rs/tests/workspaces.rs ---
use near_sdk::{json_types::{U128, U64}, AccountId};
use near_workspaces::types::NearToken;
use serde_json::json;

const ONE_NEAR: NearToken = NearToken::from_near(1);
const STORAGE_COST: NearToken = NearToken::from_millinear(1);

#[tokio::test]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let sandbox = near_workspaces::sandbox().await?;
    let contract_wasm = near_workspaces::compile_project("./").await?;

    let contract = sandbox.dev_deploy(&contract_wasm).await?;
    let alice_account = sandbox.dev_create_account().await?;
    let bob_account = sandbox.dev_create_account().await?;
    let beneficiary_account = sandbox.dev_create_account().await?;

    let initial_balance = beneficiary_account.view_account().await?.balance;

    let outcome_init = contract
        .call("init")
        .args_json(json!({"beneficiary": beneficiary_account.id()}))
        .transact()
        .await?;

    assert!(outcome_init.is_success());

    let alice_first_donation_outcome = alice_account
        .call(contract.id(), "donate")
        .args_json({})
        .deposit(ONE_NEAR)
        .transact()
        .await?;

    assert!(alice_first_donation_outcome.is_success());

    let bob_first_donation_outcome = bob_account
        .call(contract.id(), "donate")
        .args_json({})
        .deposit(ONE_NEAR)
        .transact()
        .await?;

    assert!(bob_first_donation_outcome.is_success());

    let _ = alice_account
        .call(contract.id(), "donate")
        .args_json({})
        .deposit(ONE_NEAR.saturating_mul(3))
        .transact()
        .await?
        .into_result();

    let number_of_donors: U64 = contract
        .view("number_of_donors")
        .args_json({})
        .await?
        .json()?;

    #[derive(near_sdk::serde::Serialize, near_sdk::serde::Deserialize, Debug, PartialEq)]
    #[serde(crate = "near_sdk::serde")]
    struct Donation {
        account_id: AccountId,
        total_amount: U128,
    }

    let donation: Donation = contract
        .view("get_donation_for_account")
        .args_json(json!({"account_id": alice_account.id()}))
        .await?
        .json()?;

    assert_eq!(number_of_donors, U64::from(2));
    assert_eq!(u128::from(donation.total_amount), NearToken::from_near(4).as_yoctonear());

    let donation_vec: Vec<Donation> = contract
        .view("get_donations")
        .args_json(json!({}))
        .await?
        .json()?;

    assert_eq!(
        donation_vec,
        vec![
            Donation {
                account_id: alice_account.id().clone(),
                total_amount: U128::from(NearToken::from_near(4).as_yoctonear()),
            },
            Donation {
                account_id: bob_account.id().clone(),
                total_amount: U128::from(NearToken::from_near(1).as_yoctonear()),
            },
        ]
    );

    // total donation amount excluding the costs necesseary for storage
    let donation_amount = NearToken::from_near(5).saturating_sub(STORAGE_COST.saturating_mul(2));
    let expected_balance = initial_balance.saturating_add(donation_amount);

    assert_eq!(
        beneficiary_account.view_account().await?.balance,
        expected_balance
    );

    Ok(())
}

'''
'''--- contract-ts/README.md ---
# Donation Contract

The smart contract exposes methods to handle donating $NEAR to a `beneficiary`.

```ts
@call
donate() {
  // Get who is calling the method and how much $NEAR they attached
  let donor = near.predecessorAccountId(); 
  let donationAmount: bigint = near.attachedDeposit() as bigint;

  let donatedSoFar = this.donations.get(donor) === null? BigInt(0) : BigInt(this.donations.get(donor) as string)
  let toTransfer = donationAmount;

  // This is the user's first donation, lets register it, which increases storage
  if(donatedSoFar == BigInt(0)) {
    assert(donationAmount > STORAGE_COST, `Attach at least ${STORAGE_COST} yoctoNEAR`);

    // Subtract the storage cost to the amount to transfer
    toTransfer -= STORAGE_COST
  }

  // Persist in storage the amount donated so far
  donatedSoFar += donationAmount
  this.donations.set(donor, donatedSoFar.toString())

  // Send the money to the beneficiary
  const promise = near.promiseBatchCreate(this.beneficiary)
  near.promiseBatchActionTransfer(promise, toTransfer)

  // Return the total amount donated so far
  return donatedSoFar.toString()
}
```

<br />

# Quickstart

1. Make sure you have installed [node.js](https://nodejs.org/en/download/package-manager/) >= 16.
2. Install the [`NEAR CLI`](https://github.com/near/near-cli#setup)

<br />

## 1. Build and Deploy the Contract
You can automatically compile and deploy the contract in the NEAR testnet by running:

```bash
npm run deploy
```

Once finished, check the `neardev/dev-account` file to find the address in which the contract was deployed:

```bash
cat ./neardev/dev-account
# e.g. dev-1659899566943-21539992274727
```

The contract will be automatically initialized with a default `beneficiary`.

To initialize the contract yourself do:

```bash
# Use near-cli to initialize contract (optional)
near call <dev-account> init '{"beneficiary":"<account>"}' --accountId <dev-account>
```

<br />

## 2. Get Beneficiary
`beneficiary` is a read-only method (`view` method) that returns the beneficiary of the donations.

`View` methods can be called for **free** by anyone, even people **without a NEAR account**!

```bash
near view <dev-account> beneficiary
```

<br />

## 3. Get Number of Donations

`donate` forwards any attached money to the `beneficiary` while keeping track of it.

`donate` is a payable method for which can only be invoked using a NEAR account. The account needs to attach money and pay GAS for the transaction.

```bash
# Use near-cli to donate 1 NEAR
near call <dev-account> donate --amount 1 --accountId <account>
```

**Tip:** If you would like to `donate` using your own account, first login into NEAR using:

```bash
# Use near-cli to login your NEAR account
near login
```

and then use the logged account to sign the transaction: `--accountId <your-account>`.
'''
'''--- contract-ts/package.json ---
{
  "name": "donation",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "type": "module",
  "scripts": {
    "build": "near-sdk-js build src/contract.ts build/donation.wasm",
    "test": "$npm_execpath run build && ava -- ./build/donation.wasm"
  },
  "dependencies": {
    "near-cli": "^4.0.13",
    "near-sdk-js": "1.0.0"
  },
  "devDependencies": {
    "@ava/typescript": "^4.1.0",
    "ava": "^6.1.2",
    "near-workspaces": "^3.5.0",
    "ts-morph": "^21.0.1",
    "ts-node": "^10.9.2",
    "tsimp": "^2.0.11",
    "typescript": "^5.3.3"
  }
}

'''
'''--- contract-ts/sandbox-ts/main.ava.ts ---
import { Worker, NEAR, NearAccount } from "near-workspaces";
import anyTest, { TestFn } from "ava";
import { setDefaultResultOrder } from 'dns'; setDefaultResultOrder('ipv4first'); // temp fix for node >v17

// Global context
const test = anyTest as TestFn<{ worker: Worker, accounts: Record<string, NearAccount> }>;

test.beforeEach(async (t) => {
  // Init the worker and start a Sandbox server
  const worker = t.context.worker = await Worker.init();

  const root = worker.rootAccount;

  // define users
  const beneficiary = await root.createSubAccount("beneficiary", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });

  const alice = await root.createSubAccount("alice", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });

  const bob = await root.createSubAccount("bob", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });

  const contract = await root.createSubAccount("contract", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });
  
  // Deploy the contract.
  await contract.deploy(process.argv[2]);

  // Initialize beneficiary
  await contract.call(contract, "init", {beneficiary: beneficiary.accountId})

  // Save state for test runs, it is unique for each test
  t.context.accounts = { root, contract, beneficiary, alice, bob };
});

test.afterEach.always(async (t) => {
  // Stop Sandbox server
  await t.context.worker.tearDown().catch((error) => {
    console.log('Failed to stop the Sandbox:', error);
  });
});

test("sends donations to the beneficiary", async (t) => {
  const { contract, alice, beneficiary } = t.context.accounts;

  const balance = await beneficiary.balance();
  const available = parseFloat(balance.available.toHuman());

  await alice.call(contract, "donate", {}, { attachedDeposit: NEAR.parse("1 N").toString() });

  const new_balance = await beneficiary.balance();
  const new_available = parseFloat(new_balance.available.toHuman());

  t.is(new_available, available + 1 - 0.001);
});

test("records the donation", async (t) => {
  const { contract, bob } = t.context.accounts;

  await bob.call(contract, "donate", {}, { attachedDeposit: NEAR.parse("2 N").toString() });

  const donation: Donation = await contract.view("get_donation_for_account", { account_id: bob.accountId });

  t.is(donation.account_id, bob.accountId);
  t.is(donation.total_amount, NEAR.parse("2 N").toString());
});

class Donation{
  account_id: string = "";
  total_amount: string = "";
}
'''
'''--- contract-ts/src/contract.ts ---
import { NearBindgen, near, call, view, initialize, UnorderedMap, assert } from 'near-sdk-js'

import { Donation, STORAGE_COST } from './model'

@NearBindgen({requireInit: true})
class DonationContract {
  beneficiary: string = "";
  donations = new UnorderedMap<bigint>('uid-1');

  @initialize({ privateFunction: true })
  init({ beneficiary }: { beneficiary: string }) {
    this.beneficiary = beneficiary
  }

  @call({ payableFunction: true })
  donate() {
    // Get who is calling the method and how much $NEAR they attached
    let donor = near.predecessorAccountId();
    let donationAmount: bigint = near.attachedDeposit() as bigint;

    let donatedSoFar = this.donations.get(donor, {defaultValue: BigInt(0)})
    let toTransfer = donationAmount;

    // This is the user's first donation, lets register it, which increases storage
    if (donatedSoFar == BigInt(0)) {
      assert(donationAmount > STORAGE_COST, `Attach at least ${STORAGE_COST} yoctoNEAR`);

      // Subtract the storage cost to the amount to transfer
      toTransfer -= STORAGE_COST
    }

    // Persist in storage the amount donated so far
    donatedSoFar += donationAmount
    this.donations.set(donor, donatedSoFar)
    near.log(`Thank you ${donor} for donating ${donationAmount}! You donated a total of ${donatedSoFar}`);

    // Send the money to the beneficiary
    const promise = near.promiseBatchCreate(this.beneficiary)
    near.promiseBatchActionTransfer(promise, toTransfer)

    // Return the total amount donated so far
    return donatedSoFar.toString()
  }

  @call({ privateFunction: true })
  change_beneficiary(beneficiary) {
    this.beneficiary = beneficiary;
  }

  @view({})
  get_beneficiary(): string { return this.beneficiary }

  @view({})
  number_of_donors(): number { return this.donations.length }

  @view({})
  get_donations({ from_index = 0, limit = 50 }: { from_index: number, limit: number }): Donation[] {
    let ret: Donation[] = []

    for (const account_id of this.donations.keys({start:from_index,limit})) {
      const donation: Donation = this.get_donation_for_account({ account_id })
      ret.push(donation)
    }
    
    return ret
  }

  @view({})
  get_donation_for_account({ account_id }: { account_id: string }): Donation {
    return {
      account_id,
      total_amount: this.donations.get(account_id).toString()
    }
  }
}
'''
'''--- contract-ts/src/model.ts ---
export const STORAGE_COST: bigint = BigInt("1000000000000000000000")

export class Donation {
  account_id: string;
  total_amount: string;
}
'''
'''--- contract-ts/tsconfig.json ---
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "target": "ES5",
    "noEmit": true,
    "noImplicitAny": false,
  },
  "files": [
    "sandbox-ts/main.ava.ts",
    "src/contract.ts"
  ],
  "exclude": [
    "node_modules"
  ],
}
'''
'''--- frontend/.cypress/cypress.config.js ---
const { defineConfig } = require("cypress");

module.exports = defineConfig({
  e2e: {
    baseUrl: "http://localhost:1234",
    specPattern: ["e2e/*.cy.*"],
    supportFile: false,
    chromeWebSecurity: false,
    env: {
      seed: "give laugh youth nice fossil common neutral since best biology swift unhappy",
      accountId: "cypress-guest-book.testnet",
    },
  },
});
'''
'''--- frontend/.cypress/e2e/donation.cy.ts ---
const SEED = Cypress.env('seed')
const ACCOUNT_ID = Cypress.env('accountId')

context("Main Page", () => {
    beforeEach(() => {
        cy.visit("/");
    });

    it("should display home page correctly", () => {
        // should display the title
        cy.get("h4").contains("Latest Donations");
        // should have columns titled: "User" and "Total Donated Ⓝ"
        cy.get("th").contains("User");
        cy.get("th").contains("Total Donated Ⓝ");
        // should have a button to Sign in
        cy.get("button").contains("Sign in");
    });

    it("should be able to complete donation flow", () => {
        // should be able to click on the Sign in button
        cy.get("button").contains("Sign in").click();
        // Select element from left modal list titled: "MyNearWallet" and click on it
        cy.get("div").contains("MyNearWallet").click();
        // Wait for new page to load
        cy.wait(20000);
        // Click on the "Import Existing Account" button
        cy.get("button").contains("Import Existing Account").click();
        // Click on the "Recover Account" button
        cy.get("button").contains("Recover Account").click();
        // Fill in SEED from the environment variable into the input field
        cy.get("input").type(SEED);
        // Click on the "Find My Account" button
        cy.get("button").contains("Find My Account").click();
        // Wait for new page to load
        cy.wait(20000);
        // Click on the "Next" button
        cy.get("button").contains("Next").click();
        // Click on the "Connect" button
        cy.get("button").contains("Connect").click();
        // Wait for new page to load
        cy.wait(20000);

        // should be able to enter the amount to donate in input field with id: "donation"
        cy.get("input[id=donation]").type("10");
        // should be able to click the donate button
        cy.get("button").contains("Donate").click();
        // Wait for new page to load
        cy.wait(20000);
        // should be able to click "Approve" to confirm the donation
        cy.get("button").contains("Approve").click();
        // Wait for new page to load
        cy.wait(20000);
        // should display the donating account name on page
        cy.contains(ACCOUNT_ID);
    });
});
'''
'''--- frontend/.cypress/tsconfig.json ---
{
    "compilerOptions": {
      "target": "es5",
      "lib": ["es5", "dom"],
      "types": ["cypress"]
    },
    "include": ["**/*.ts"]
  }
'''
'''--- frontend/assets/global.css ---
* {
  box-sizing: border-box;
}

html {
  --bg: #e7f3ff;
  --fg: #1e1e1e;
  --gray: #555;
  --light-gray: #ccc;
  --shadow: #e6e6e6;
  --success: rgb(90, 206, 132);
  --primary: #FF585D;
  --secondary: #0072CE;

  color: var(--fg);
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  line-height: 1.3;
}

body {
  margin: 0;
  background-color: var(--bg);
}

.donation-box {
  max-width: 24em;
  box-shadow: #bac4cd 0px 0px 18px;
  border-radius: 8px;
}

.column{
  width: 50%;
  float:left;
}

main {
  padding: 2em;
  text-align: justify;
  background-color: #f2f2f2;
  z-index: 1;
  border-radius: 8px;
}

.donation-box-head {
  text-align: center;
  background-color: #fff;
  margin: 0;
  border-radius: 8px 8px 0 0;
  padding: 1em 0em 2em 0em;
}

.logo {
  background-image: url(logo-black.svg);
  background-position: center 0em;
  background-repeat: no-repeat;
  position: relative;
  top: -2em;
  transform: translateX(-50%);
  background-color: #fff;
  padding: 15px 25px;
  height: 40px;
  border-radius: 50px;
  width: 50px;
  box-shadow: #bbb 0px 2px 5px;
}

a,
.link {
  color: var(--primary);
  text-decoration: none;
}
a:hover,
a:focus,
.link:hover,
.link:focus {
  text-decoration: underline;
}
a:active,
.link:active {
  color: var(--secondary);
}

.btn-outline-primary{
  width: 100%;
}

button, input {
  font: inherit;
  outline: none;
}

button.link {
  background: none;
  border: none;
  box-shadow: none;
  display: inline;
}

fieldset {
  border: none;
  padding: 2em 0;
}

form {
  margin: 0.2em -0.5em -1em -0.5em;
}

aside {
  animation: notify ease-in-out 10s;
  background-color: var(--shadow);
  border-radius: 5px;
  bottom: 0;
  font-size: 0.8em;
  margin: 1em;
  padding: 1em;
  position: fixed;
  transform: translateY(10em);
  right: 0;
}
aside footer {
  display: flex;
  font-size: 0.9em;
  justify-content: space-between;
  margin-top: 0.5em;
}
aside footer *:first-child {
  color: var(--success);
}
aside footer *:last-child {
  color: var(--gray);
}
@keyframes notify {
  0% { transform: translateY(10em) }
  5% { transform: translateY(0) }
  95% { transform: translateY(0) }
  100% { transform: translateY(10em) }
}

'''
'''--- frontend/assets/logo-black.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#24272a"/><stop offset=".42" stop-color="#24272a" stop-opacity="0"/><stop offset=".59" stop-color="#24272a" stop-opacity="0"/><stop offset=".81" stop-color="#24272a"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#24272a"/></svg>
'''
'''--- frontend/assets/logo-white.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#fff"/><stop offset=".42" stop-color="#fff" stop-opacity="0"/><stop offset=".59" stop-color="#fff" stop-opacity="0"/><stop offset=".81" stop-color="#fff"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#fff"/></svg>
'''
'''--- frontend/index.html ---
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" crossorigin="anonymous"></script>
  <link rel="icon" href="./assets/favicon.ico" />
  <link rel="apple-touch-icon" href="./assets/favicon.ico" />
  <link rel="stylesheet" href="./assets/global.css">
  <title>Welcome to NEAR</title>
</head>

<body class="p-4 p-sm-5">

  <div class="row">
    <div class="col-sm-8 pe-2 pe-sm-5">
      <h4> Latest Donations </h4>

      <table class="table table-striped">
        <thead>
          <tr>
            <th scope="col">User</th>
            <th scope="col">Total Donated Ⓝ</th>
          </tr>
        </thead>
        <tbody id="donations-table"> </tbody>
      </table>

    </div>

    <div class="col-sm-4">
      <div class="donation-box mt-md-4">

        <div class="donation-box-head">
          <i class="logo"></i>
          <h4> Donate to <label
            for="beneficiary"
            data-behavior="beneficiary"
            style="color: var(--secondary); border-bottom: 2px solid var(--secondary);"
          >
          </label> </h4>
        </div>

        <main class="donation-body signed-out-flow" style="display: none">
          <p>
            Please sign in with your NEAR wallet to make a donation.
          </p>
          <p style="text-align: center; margin-top: 2.5em">
            <button id="sign-in-button" class="btn btn-primary">Sign in</button>
          </p>
        </main>
      
        <main class="signed-in-flow" class="donation-body" style="display: none">
          <div class="row">
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="set_donation(10)"> $ 10 </button></div>
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="set_donation(20)"> $ 20 </button></div>
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="set_donation(50)"> $ 50 </button></div>
            <div class="col-3 px-1"><button class="btn btn-outline-primary" onclick="set_donation(100)"> $ 100 </button></div>
          </div>
  
          <form>
            <fieldset id="fieldset">
              <label for="donation" class="form-label" >
                Donation amount (in Ⓝ)
              </label>
              <div class="input-group">
                <input id="donation" class="form-control" data-behavior="donation" />
                <span class="input-group-text">Ⓝ</span>
                <button class="btn btn-primary" >Donate</button>
              </div>
            </fieldset>
          </form>
        </main>
  
        <button class="link signed-in-flow" style="display: none; float: right" id="sign-out-button">
          Sign out
        </button>
      </div>

    </div>

  </div>

  <aside data-behavior="notification" style="display:none" class="bg-success p-2 text-white bg-opacity-75">
    Thank you! You have donated so far:
    <label for="donation-number" data-behavior="donation-so-far" > </label>Ⓝ
    <footer>
      <div>✔ Succeeded</div>
    </footer>
  </aside>

  <script src="index.js" type="module"></script>
</body>
</html>
'''
'''--- frontend/index.js ---
import 'regenerator-runtime/runtime'
import { Contract } from './near-interface';
import { Wallet } from './near-wallet'

const CONTRACT_NAME = "donation.near-examples.testnet"
// When creating the wallet you can choose to create an access key, so the user
// can skip signing non-payable methods when interacting with the contract
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_NAME })

// Abstract the logic of interacting with the contract to simplify your project
const contract = new Contract({ contractId: process.env.CONTRACT_NAME, walletToUse: wallet });

// Setup on page load
window.onload = async () => {
  const isSignedIn = await wallet.startUp();

  if (isSignedIn){
    signedInFlow()
  }else{
    signedOutFlow()
  }

  fetchBeneficiary()
  getAndShowDonations()
}

// On submit, get the greeting and send it to the contract
document.querySelector('form').onsubmit = async (event) => {
  event.preventDefault()

  // get elements from the form using their id attribute
  const { fieldset, donation } = event.target.elements

  // disable the form while the value gets updated on-chain
  fieldset.disabled = true

  try {
    await contract.donate(donation.value)
  } catch (e) {
    alert(
      'Something went wrong! ' +
      'Maybe you need to sign out and back in? ' +
      'Check your browser console for more info.'
    )
    throw e
  }

  // re-enable the form, whether the call succeeded or failed
  fieldset.disabled = false
}

document.querySelector('#sign-in-button').onclick = () => { wallet.signIn() }
document.querySelector('#sign-out-button').onclick = () => { wallet.signOut() }

async function fetchBeneficiary() {
  // Get greeting from the contract
  const currentGreeting = await contract.getBeneficiary()

  // Set all elements marked as greeting with the current greeting
  document.querySelectorAll('[data-behavior=beneficiary]').forEach(el => {
    el.innerText = currentGreeting
    el.value = currentGreeting
  })
}

// Display the signed-out-flow container
function signedOutFlow() {
  document.querySelector('.signed-out-flow').style.display = 'block'
}

async function signedInFlow() {
  // Displaying the signed in flow container
  document.querySelectorAll('.signed-in-flow').forEach(elem => elem.style.display = 'block')

  // Check if there is a transaction hash in the URL
  const urlParams = new URLSearchParams(window.location.search);
  const txhash = urlParams.get("transactionHashes")

  if(txhash !== null){
    // Get result from the transaction
    let result = await contract.getDonationFromTransaction(txhash)
    document.querySelector('[data-behavior=donation-so-far]').innerText = result

    // show notification
    document.querySelector('[data-behavior=notification]').style.display = 'block'

    // remove notification again after css animation completes
    setTimeout(() => {
      document.querySelector('[data-behavior=notification]').style.display = 'none'
    }, 11000)
  }

}

async function getAndShowDonations(){
  document.getElementById('donations-table').innerHTML = 'Loading ...'

  // Load last 10 donations
  let donations = await contract.latestDonations()

  document.getElementById('donations-table').innerHTML = ''

  donations.forEach(elem => {
    let tr = document.createElement('tr')
    tr.innerHTML = `
      <tr>
        <th scope="row">${elem.account_id}</th>
        <td>${elem.total_amount}</td>
      </tr>
    `
    document.getElementById('donations-table').appendChild(tr)
  })
}

window.set_donation = async function(amount){
  let data = await fetch("https://api.coingecko.com/api/v3/simple/price?ids=near&vs_currencies=usd").then(response => response.json())
  const near2usd = data['near']['usd']
  const amount_in_near = amount / near2usd
  const rounded_two_decimals = Math.round(amount_in_near * 100) / 100
  document.querySelector('#donation').value = rounded_two_decimals
}
'''
'''--- frontend/near-interface.js ---
/* Talking with a contract often involves transforming data, we recommend you to encapsulate that logic into a class */

import { utils } from 'near-api-js'

export class Contract {

  constructor({ contractId, walletToUse }) {
    this.contractId = contractId;
    this.wallet = walletToUse;
  }

  async getBeneficiary() {
    return await this.wallet.viewMethod({ contractId: this.contractId, method: "get_beneficiary" })
  }

  async latestDonations() {
    const number_of_donors = await this.wallet.viewMethod({ contractId: this.contractId, method: "number_of_donors" })
    const min = number_of_donors > 10 ? number_of_donors - 9 : 0

    let donations = await this.wallet.viewMethod({ contractId: this.contractId, method: "get_donations", args: { from_index: min.toString(), limit: number_of_donors } })

    donations.forEach(elem => {
      elem.total_amount = utils.format.formatNearAmount(elem.total_amount);
    })

    return donations
  }

  async getDonationFromTransaction(txhash) {
    let donation_amount = await this.wallet.getTransactionResult(txhash);
    return utils.format.formatNearAmount(donation_amount);
  }

  async donate(amount) {
    let deposit = utils.format.parseNearAmount(amount.toString())
    let response = await this.wallet.callMethod({ contractId: this.contractId, method: "donate", deposit })
    return response
  }

}
'''
'''--- frontend/near-wallet.js ---
/* A helper file that simplifies using the wallet selector */

// near api js
import { providers } from 'near-api-js';

// wallet selector UI
import '@near-wallet-selector/modal-ui/styles.css';
import { setupModal } from '@near-wallet-selector/modal-ui';
import LedgerIconUrl from '@near-wallet-selector/ledger/assets/ledger-icon.png';
import MyNearIconUrl from '@near-wallet-selector/my-near-wallet/assets/my-near-wallet-icon.png';

// wallet selector options
import { setupWalletSelector } from '@near-wallet-selector/core';
import { setupLedger } from '@near-wallet-selector/ledger';
import { setupMyNearWallet } from '@near-wallet-selector/my-near-wallet';

const THIRTY_TGAS = '30000000000000';
const NO_DEPOSIT = '0';

// Wallet that simplifies using the wallet selector
export class Wallet {
  walletSelector;
  wallet;
  network;
  createAccessKeyFor;

  constructor({ createAccessKeyFor = undefined, network = 'testnet' }) {
    // Login to a wallet passing a contractId will create a local
    // key, so the user skips signing non-payable transactions.
    // Omitting the accountId will result in the user being
    // asked to sign all transactions.
    this.createAccessKeyFor = createAccessKeyFor
    this.network = network
  }

  // To be called when the website loads
  async startUp() {
    this.walletSelector = await setupWalletSelector({
      network: this.network,
      modules: [setupMyNearWallet({ iconUrl: MyNearIconUrl }),
      setupLedger({ iconUrl: LedgerIconUrl })],
    });

    const isSignedIn = this.walletSelector.isSignedIn();

    if (isSignedIn) {
      this.wallet = await this.walletSelector.wallet();
      this.accountId = this.walletSelector.store.getState().accounts[0].accountId;
    }

    return isSignedIn;
  }

  // Sign-in method
  signIn() {
    const description = 'Please select a wallet to sign in.';
    const modal = setupModal(this.walletSelector, { contractId: this.createAccessKeyFor, description });
    modal.show();
  }

  // Sign-out method
  signOut() {
    this.wallet.signOut();
    this.wallet = this.accountId = this.createAccessKeyFor = null;
    window.location.replace(window.location.origin + window.location.pathname);
  }

  // Make a read-only call to retrieve information from the network
  async viewMethod({ contractId, method, args = {} }) {
    const { network } = this.walletSelector.options;
    const provider = new providers.JsonRpcProvider({ url: network.nodeUrl });

    let res = await provider.query({
      request_type: 'call_function',
      account_id: contractId,
      method_name: method,
      args_base64: Buffer.from(JSON.stringify(args)).toString('base64'),
      finality: 'optimistic',
    });
    return JSON.parse(Buffer.from(res.result).toString());
  }

  // Call a method that changes the contract's state
  async callMethod({ contractId, method, args = {}, gas = THIRTY_TGAS, deposit = NO_DEPOSIT }) {
    // Sign a transaction with the "FunctionCall" action
    const outcome = await this.wallet.signAndSendTransaction({
      signerId: this.accountId,
      receiverId: contractId,
      actions: [
        {
          type: 'FunctionCall',
          params: {
            methodName: method,
            args,
            gas,
            deposit,
          },
        },
      ],
    });

    return providers.getTransactionLastResult(outcome)
  }

  // Get transaction result from the network
  async getTransactionResult(txhash) {
    const { network } = this.walletSelector.options;
    const provider = new providers.JsonRpcProvider({ url: network.nodeUrl });

    // Retrieve transaction result from the network
    const transaction = await provider.txStatus(txhash, 'unnused');
    return providers.getTransactionLastResult(transaction);
  }
}
'''
'''--- frontend/package.json ---
{
  "name": "my-near-app",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "start": "parcel index.html",
    "build": "parcel build index.html --public-url ./",
    "test:e2e": "npm run start:headless & npm run cypress:run",
    "cypress:run": "cd .cypress && cypress run",
    "cypress:open": "cypress open --browser chromium"
  },
  "devDependencies": {
    "env-cmd": "^10.1.0",
    "events": "^3.3.0",
    "nodemon": "^2.0.16",
    "parcel": "^2.7.0",
    "process": "^0.11.10",
    "typescript": "^4.7.2",
    "ts-node": "^10.8.0",
    "cypress": "^11.2.0"
  },
  "dependencies": {
    "@near-wallet-selector/core": "^7.0.0",
    "@near-wallet-selector/ledger": "^7.0.0",
    "@near-wallet-selector/math-wallet": "^7.0.0",
    "@near-wallet-selector/meteor-wallet": "^7.0.0",
    "@near-wallet-selector/modal-ui": "^7.0.0",
    "@near-wallet-selector/my-near-wallet": "^7.0.0",
    "@near-wallet-selector/near-wallet": "^7.0.0",
    "@near-wallet-selector/nightly": "^7.0.0",
    "@near-wallet-selector/nightly-connect": "^7.0.0",
    "@near-wallet-selector/sender": "^7.0.0",
    "@near-wallet-selector/wallet-connect": "^7.0.0",
    "near-api-js": "^0.44.2"
  }
}
'''