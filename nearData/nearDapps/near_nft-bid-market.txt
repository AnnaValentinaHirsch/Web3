*GitHub Repository "near/nft-bid-market"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- Cargo.toml ---
[workspace]
members = ["market", "nft", "tests-workspaces"]
exclude = []

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- Links.md ---
# NFT contracts
| Item | Link |
| --- | --- |
| bid | https://github.com/near-examples/nft-market/blob/main/contracts/market-simple/src/sale.rs#L6-L9
| ipfs |
| public and private minting |
| metadata | https://nomicon.io/Standards/NonFungibleToken/Metadata.html
| royalties | https://nomicon.io/Standards/NonFungibleToken/Payout.html

# Sales contract
| Item | Link |
| --- | --- |
| general actions (put on sale, make and accept bids, cancel sale or bid) |
| support royalties |
| support protocol fees, origin fees | https://github.com/rarible/protocol-contracts/blob/master/exchange-v2/contracts/RaribleTransferManager.md |
| support sell/bid start and end dates |
| partially completed sales |

# Auctions contract
| Item | Link |
| --- | --- |
| English auctions ||
| specifying payment option and start / duration||
| support royalties ||
| fees distribution support (the same as for sales contract) | https://github.com/rarible/protocol-contracts/blob/master/exchange-v2/contracts/RaribleTransferManager.md |
| extending the auction if bid is created in last 15 min of auction||

'''
'''--- README.md ---
# NFT bidding market

'''
'''--- TestPlan.md ---
# Market

## market_core

### nft_on_approve
Creates a sale or an auction.
- Can only be called via cross-contract call
- `owner_id` must be the signer
- Panics if `owner_id` didn't pay for one more sale/auction
- Panics if the given `ft_token_id` is not supported by the market
- Panics if `msg` doesn't contain valid parameters for sale or auction
- Start time is set to `block_timestamp` if it is not specified explicitly
- Creates a new sale/auction
<!--
### nft_on_series_approve
Gives an approval to the market to mint the series.
- Can only be called via cross-contract call
- `owner_id` must be the signer
- Panics if `owner_id` didn't pay for one more sale/auction
- Panics if the given `ft_token_id` is not supported by the market
-->

## lib

### storage_deposit
Locks the deposit
- Must attach at least `STORAGE_PER_SALE`
- Adds the attached deposit

### storage_withdraw
Withdraws the deposit
- Panics unless 1 yoctoNEAR is attached
- Returns any spare storage deposit
- Saves the remaining deposit

### storage_amount
- Returns the minimal deposit for one sale (`STORAGE_PER_SALE`)

## sale

### offer
Creates an offer to buy NFT. If `attached_deposit` is sufficient, the purchase is made. Otherwise, the bid is created (if it exceeds the previous bid).
- Should panic if there is no sale with given `contract_and_token_id`
- Should panic if the sale is not in progress
- Should panic if the NFT owner tries to make a bid on his own sale
- Should panic if the deposit equal to 0
- Should panic if the NFT can't be bought by `ft_token_id`
- If the `attached_deposit` is equal to the price + fees
  -  panics if number of payouts plus number of bids exceeds 10
  -  NFT is transferred to the buyer 
  -  the sale is removed from the list of sales
  -  ft transferred to the previous owner
  -  protocol, royalty and origin fees are paid
  -  royalty paid from seller side
  -  previous bids refunded
- If the `attached_deposit` is not equal to the price + fees
  - should panic if `ft_token_id` is not supported 
  - panics if the bid smaller or equal to the previous one
  - panic if origin fee exceeds `ORIGIN_FEE_MAX`
  - a new bid should be added
  - if the number of stored bids exceeds `bid_history_length`, the earliest bid is removed and refunded
### accept_offer
Accepts the last offer for the particular sale and given `ft_token_id`.
- Should panic if there is no sale with the given `nft_contract_id` and `token_id`
- Should panic if the sale is not in progress
- Should panic if there are no bids with given fungible token
- Should panic if the last bid is out of time
- If none of this happens, the purchase should be made:
  - panic if number of payouts plus number of bids exceeds 10
  - NFT is transferred to the buyer
  - ft transferred to the previous owner
  - protocol and origins fees are paid
  - the previous owner also pays royalty
  - the sale is removed from list of sales
  - previous bids should be refunded
### update_price
Changes the price of the sale.
- Should panic unless 1 yoctoNEAR is attached
- Should panic if there is no sale with the given `nft_contract_id` and `token_id`
- Should panic unless it is called by the creator of the sale
- Should panic if `ft_token_id` is not supported
- Changes the price
### remove_sale
Removes the sale and refunds all bids.
- Should panic unless 1 yoctoNEAR is attached
- If the sale in progress, only the sale creator can remove the sale
- Sale removed
- Refunds all bids

## bids

### remove_bid
Allows a user to remove his bid.
- Should panic unless 1 yoctoNEAR is attached
- Should panic if there is no sale with the given `nft_contract_id` and `token_id`
- Should panic if there is no bids with `ft_token_id`
- Refunds a bid, removes it from the list
### cancel_bid
Allows to remove any finished bid. 
- Should panic if the bid isn't finished yet
- Should panic if the bid doesn't have end time
- Should panic if there is no sale with the given `nft_contract_id` and `token_id`
- Should panic if there is no bids with `ft_token_id`
- Should panic if there is no bid with given `owner_id` and `price`
- Refunds a bid, removes it from the list
### cancel_expired_bids
Cancels all expired bids for the given sale and `ft_token_id`.
- Should panic if there is no sale with the given `nft_contract_id` and `token_id`
- Should panic if there is no bids with `ft_token_id`
- Refunds all expired bids, removes them from the list

## auctions

### auction_add_bid
Adds a bid for the auction.
- Should panic if `ft_token_id` is not supported
- Should panic if the auction is not in progress
- Panics if auction is not active
- Should panic if the owner tries to bid on his own auction
- Should panic if the bid is smaller than the minimal deposit
- Should panic if the bid is smaller than the previous one + minimal step + fees
- Refunds a previous bid (if it exists)
- Extends an auction if the bid is added less than 15 minutes before the end
- The auction ends if the `attached_deposit` is bigger than the `buy_out_price` (plus fees)
### cancel_auction
Called by the owner to cancel the auction if it doesn't have bids.
- Should panic unless 1 yoctoNEAR is attached
- Can only be called by the creator of the auction
- Panics if auction is not active
- Panics if the auction already has a bid
- Removes the auction
### finish_auction
Cancels an auction if it's finished.
- Panics if the auction is not active
- Should panic if called before the auction ends
- Panics if there is no bid
- If none the above happens, the purchase should be made:
  -  panic if number of payouts plus number of bids exceeds 10
  -  NFT is transferred to the buyer
  -  ft transferred to the previous owner
  -  protocol and origins fees are paid
  -  the previous owner also pays royalty
  -  the auction is removed from list of auctions

## sale_views

### get_sale
- Returns sale if its active or nothing if not
### get_supply_sales
- Returns total amount of active sales
### get_sales
- Returns list of active sales
### get_supply_by_owner_id
- Returns total amount of active sales owned by owner_id
### get_sales_by_owner_id
- Returns list of active sales owned by owner_id
### get_supply_by_nft_contract_id
- Returns total amount of active sales of tokens from nft_contract_id
### get_sales_by_nft_contract_id
- Returns list of active sales of tokens from nft_contract_id
### get_supply_by_nft_token_type
- Returns total amount of active sales of tokens from nft_contract_id token series
### get_sales_by_nft_token_type
- Returns list of active sales of tokens from nft_contract_id token series
## auction_views

### get_auction
- Panics in case of incorrect `auction_id`
- Returns info about the auction
### get_auctions
- Returns vector of all auctions
### get_current_buyer
- Panics in case of incorrect `auction_id`
- Returns `None` if there is no bid, otherwise returns the current buyer
### get_current_bid
- Panics in case of incorrect `auction_id`
- Returns `None` if there is no bid, otherwise returns the amount of the last bid (with fees)
### check_auction_in_progress
- Panics in case of incorrect `auction_id`
- Returns `true` if the auction in progress, `false` otherwise
### get_minimal_next_bid
- Panics in case of incorrect `auction_id`
- Returns minimal next bid (without fees)

## fee

### price_with_fees
- Calculates the total price including the protocol and origin fees

# NFT

## lib

### nft_create_series
Creates a series.
- Can only be called by the autorized account (if authorization enabled)
- Panics if the title of the series is not specified
- Panics if the total royalty payout exceeds 50%
- Creates a new series with given metadata and royalty
- Refunds a deposit
### nft_mint
Mints a token from the series.
- Can only be called by the autorized account (if authorization enabled)
- Panics if there is no series `token_series_id`
- Panics if called not by the owner of the series or the approved account to mint this specific series
- Panics if the maximum number of tokens have already been minted
- Mints a new token
- Refunds a deposit
<!--
### nft_series_market_approve
Gives an approval to mint a series.
- Panics if there is no series `token_series_id`
- Can only be called by the owner of the series
- Panics if the number of copies (including already minted tokens) exceeds the maximum number of copies
- Refunds a deposit
- Creates a cross contract call to `nft_on_series_approve`
-->
## payouts

### nft_payout
Payout mapping for the given token, based on 'balance' and royalty
- Panics if `token_id` contains `token_series_id`, which doesn't exist
- Panics if the number of royalties exceeds `max_len_payout`
- Panics if the total royalty exceeds 100%
- Splits the `balance` among royalties and owner, returns payout
### nft_transfer_payout
`nft_transfer` with 'balance' for calculation of Payout mapping for the given token.
- Should panic unless 1 yoctoNEAR is attached
- Panics if `token_id` doesn't exist
- Panics if the number of royalties exceeds `max_len_payout`
- Panics if invalid `memo` is provided
- Panics if total payout exceeds `ROYALTY_TOTAL_VALUE`
- Returns payout, which contains royalties and payouts from `memo`

## permissions

### grant
Gives an approval to mint.
- Can only be called by the owner
- Adds a given account to the list of the autorized accounts
- Returns `true` if the new account has been added to the list, `false` otherwise
### deny
Takes back a permission to mint.
- Can only be called by the owner
- Removes a given account from the list of the autorized accounts
- Returns `true` if the account has been removed from the list, `false` if it hadn't been in the list
### set_private_minting
Turns on and off the private minting.
- Can only be called by the owner
- If `enabled` is true, turns on private minting
- If `enabled` is false, turns off private minting
### is_allowed
Tells whether an account has a permission to mint tokens.
- Returns true if private minting is not enabled
- If private minting is enabled, returns whether an account is among private minters

## series_views

### nft_get_series
- Panics if the series wasn't found
- Returns the series with given `token_series_id`
### nft_series
- Panics in case of incorrect `from_index` or `limit`
- Returns a vector of series
### nft_supply_for_series
- Panics if the series wasn't found
- Returns the number of tokens in the series
'''
'''--- build-all.sh ---

#!/bin/bash
set -e
cd "`dirname $0`"
dir='./res'
if [[ ! -e $dir ]]; then
    mkdir $dir
fi
RUSTFLAGS='-C link-arg=-s' cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm $dir
'''
'''--- deploy-testnet.sh ---
#!/bin/bash
rm -rvf res

set -e
sh build-all.sh # building all

rm -f .env
rm -rvf neardev

near dev-deploy /dev/null
source neardev/dev-account.env

CONTRACT_PARENT=$CONTRACT_NAME
MARKET_CONTRACT_ID=market.$CONTRACT_PARENT
NFT_CONTRACT_ID=nft.$CONTRACT_PARENT
ALICE=alice.$CONTRACT_PARENT

echo "CONTRACT_PARENT=$CONTRACT_PARENT" > .env
echo "MARKET_CONTRACT_ID=$MARKET_CONTRACT_ID" >> .env
echo "NFT_CONTRACT_ID=$NFT_CONTRACT_ID" >> .env
echo "ALICE=$ALICE" >> .env

set -e
near create-account $NFT_CONTRACT_ID --masterAccount $CONTRACT_PARENT --initialBalance "27"
near create-account $ALICE --masterAccount $CONTRACT_PARENT --initialBalance 20
near create-account $MARKET_CONTRACT_ID --masterAccount $CONTRACT_PARENT --initialBalance 50

# Set up
near deploy $NFT_CONTRACT_ID --wasmFile res/nft_contract.wasm
near deploy $MARKET_CONTRACT_ID --wasmFile res/nft_bid_market.wasm

'''
'''--- market/Cargo.toml ---
[package]
name = "nft-bid-market"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.5"
near-contract-standards = "4.0.0-pre.5"

[dev-dependencies]
near-sdk-sim = "4.0.0-pre.5"
nft-contract = { path = "../nft" }
'''
'''--- market/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp ../target/wasm32-unknown-unknown/release/nft_bid_market.wasm ../res/

'''
'''--- market/src/auction.rs ---
use std::collections::HashMap;

use crate::bid::{Bid, Origins};
use crate::fee::calculate_price_with_fees;
use crate::market_core::AuctionArgs;
use crate::sale::{
    ext_contract, ext_self, Payout, GAS_FOR_FT_TRANSFER, GAS_FOR_NFT_TRANSFER, GAS_FOR_ROYALTIES,
    NO_DEPOSIT,
};
use crate::*;
use near_sdk::{near_bindgen, promise_result_as_success};
// should check calculation
pub const EXTENSION_DURATION: u64 = 15 * 60 * NANOS_PER_SEC; // 15 minutes
pub const MAX_DURATION: u64 = 1000 * 60 * 60 * 24 * NANOS_PER_SEC; // 1000 days

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Auction {
    pub owner_id: AccountId,
    pub approval_id: u64,
    pub nft_contract_id: AccountId,
    pub token_id: String,
    pub bid: Option<Bid>,
    pub created_at: u64,
    pub ft_token_id: AccountId,
    pub minimal_step: u128,
    pub start_price: u128,
    pub buy_out_price: Option<u128>,

    pub start: u64,
    pub end: u64,

    pub origins: Origins,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AuctionJson {
    pub owner_id: AccountId,
    pub nft_contract_id: AccountId,
    pub token_id: String,
    pub bid: Option<Bid>,
    pub created_at: U64,
    pub ft_token_id: AccountId,
    pub minimal_step: U128,
    pub start_price: U128,
    pub buy_out_price: Option<U128>,

    pub start: U64,
    pub end: U64,
}

#[near_bindgen]
impl Market {
    // Called in nft_on_approve to create a new auction
    // Returns a pair of the auction_id and the auction itself
    pub(crate) fn start_auction(
        &mut self,
        args: AuctionArgs,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        nft_contract_id: AccountId,
    ) -> (u128, AuctionJson) {
        require!(
            args.duration.0 >= EXTENSION_DURATION && args.duration.0 <= MAX_DURATION,
            format!(
                "Incorrect duration. Should be at least {}",
                EXTENSION_DURATION
            )
        );
        let ft_token_id = self.token_type_to_ft_token_type(args.token_type);
        let start = args
            .start
            .map(|s| s.into())
            .unwrap_or_else(env::block_timestamp);
        require!(start >= env::block_timestamp(), "incorrect start time");
        let end = start + args.duration.0;
        let auction_id = self.market.next_auction_id;
        let origins = args.origins.unwrap_or_default();
        let auction = Auction {
            owner_id,
            approval_id,
            nft_contract_id,
            token_id,
            bid: None,
            created_at: env::block_timestamp(),
            ft_token_id,
            minimal_step: args.minimal_step.into(),
            start_price: args.start_price.into(),
            buy_out_price: args.buy_out_price.map(|p| p.into()),
            start,
            end,
            origins,
        };
        self.market.auctions.insert(&auction_id, &auction);
        self.market.next_auction_id += 1;

        let auction_json = self.json_from_auction(auction);

        // env::log_str(&near_sdk::serde_json::to_string(&(auction_id, auction)).unwrap());
        (auction_id, auction_json)
    }

    // Adds a bid to the corresponding auction
    // Supports buyout and time extension
    #[payable]
    pub fn auction_add_bid(
        &mut self,
        auction_id: U128,
        token_type: TokenType,
        origins: Option<Origins>,
    ) {
        let ft_token_id = self.token_type_to_ft_token_type(token_type);
        require!(
            self.market.ft_token_ids.contains(&ft_token_id),
            "token not supported"
        );
        require!(
            self.check_auction_in_progress(auction_id),
            "Auction is not in progress"
        );
        let mut auction = self
            .market
            .auctions
            .get(&auction_id.into())
            .unwrap_or_else(|| env::panic_str("auction not active"));
        require!(
            auction.owner_id != env::predecessor_account_id(),
            "Cannot bid on your own auction"
        );
            let deposit = env::attached_deposit();
        let min_deposit =
            calculate_price_with_fees(self.get_minimal_next_bid(auction_id), origins.as_ref());

        // Check that the bid is not smaller than the minimal allowed bid
        require!(
            deposit >= min_deposit,
            format!("Should bid at least {}", min_deposit)
        );
        //Return previous bid
        if let Some(previous_bid) = auction.bid {
            self.refund_bid(ft_token_id, previous_bid.owner_id, previous_bid.price);
        }
        // If the price is bigger than the buy_out_price, the auction end is set to the current time
        let mut bought_out = false;
        if let Some(buy_out_price) = auction.buy_out_price {
            if calculate_price_with_fees(buy_out_price.into(), origins.as_ref()) <= deposit {
                auction.end = env::block_timestamp();
                bought_out = true;
            }
        }
        // Create a bid
        let bid = Bid {
            owner_id: env::predecessor_account_id(),
            price: deposit.into(),
            start: env::block_timestamp().into(),
            end: None,
            origins: origins.unwrap_or_default(),
        };
        // Extend the auction if the bid is added EXTENSION_DURATION (15 min) before the auction end
        // and the token is not bought out
        auction.bid = Some(bid);
        if auction.end - env::block_timestamp() < EXTENSION_DURATION && !bought_out {
            auction.end = env::block_timestamp() + EXTENSION_DURATION;
        }
        self.market.auctions.insert(&auction_id.into(), &auction);
    }

    // Cancels the auction if it doesn't have a bid yet
    // Can be called by the auction owner
    #[payable]
    pub fn cancel_auction(&mut self, auction_id: U128) {
        assert_one_yocto();
        let auction = self
            .market
            .auctions
            .get(&auction_id.into())
            .unwrap_or_else(|| env::panic_str("Auction is not active"));
        require!(
            auction.owner_id == env::predecessor_account_id(),
            "Only the auction owner can cancel the auction"
        );
        require!(
            auction.bid.is_none(),
            "Can't cancel the auction after the first bid is made"
        );
        self.market.auctions.remove(&auction_id.into());
    }

    // Finishes the auction if it has reached its end
    // Can be called by anyone
    pub fn finish_auction(&mut self, auction_id: U128) -> Promise {
        let auction = self
            .market
            .auctions
            .remove(&auction_id.into())
            .unwrap_or_else(|| env::panic_str("Auction is not active"));
        require!(
            env::block_timestamp() > auction.end,
            "Auction can be finalized only after the end time"
        );
        let final_bid = auction
            .bid
            .unwrap_or_else(|| env::panic_str("Can finalize only if there is a bid"));
        let mut buyer = final_bid.origins;
        buyer.insert(env::current_account_id(), PROTOCOL_FEE as u32);
        let mut seller_fee = HashMap::with_capacity(auction.origins.len() + 1);
        seller_fee.extend(auction.origins.clone()); // TODO: dodge this clone
        seller_fee.insert(env::current_account_id(), PROTOCOL_FEE as u32);
        let fees = fee::Fees {
            buyer,
            seller: seller_fee,
        };
        ext_contract::nft_transfer_payout(
            final_bid.owner_id.clone(),
            auction.token_id.clone(),
            auction.approval_id,
            Some(near_sdk::serde_json::to_string(&fees).expect("Failed to sereailize")),
            final_bid.price,
            10,
            auction.nft_contract_id.clone(),
            1,
            GAS_FOR_NFT_TRANSFER,
        )
        .then(ext_self::resolve_finish_auction(
            auction.ft_token_id,
            final_bid.owner_id.clone(),
            final_bid.price,
            env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_ROYALTIES,
        ))
    }

    // self callback
    // If transfer of token succeded - count fees and transfer payouts
    // If failed - refund price to buyer
    #[private]
    pub fn resolve_finish_auction(
        &mut self,
        ft_token_id: AccountId,
        buyer_id: AccountId,
        price: U128,
    ) -> U128 {
        let payout_option = promise_result_as_success().and_then(|value| {
            near_sdk::serde_json::from_slice::<Payout>(&value)
                .ok()
                .and_then(|payout| {
                    if payout.payout.len() > 10 || payout.payout.is_empty() {
                        env::log_str("Cannot have more than 10 payouts and sale.bids refunds");
                        None
                    } else {
                        let mut remainder = price.0;
                        for &value in payout.payout.values() {
                            remainder = remainder.checked_sub(value.0)?;
                        }
                        if remainder <= 1 {
                            Some(payout)
                        } else {
                            None
                        }
                    }
                })
        });
        // is payout option valid?
        let payout = if let Some(payout_option) = payout_option {
            payout_option
        } else {
            if ft_token_id == "near".parse().unwrap() {
                Promise::new(buyer_id).transfer(u128::from(price));
            }
            // leave function and return all FTs in ft_resolve_transfer
            return price;
        };

        // NEAR payouts
        if ft_token_id == "near".parse().unwrap() {
            for (receiver_id, amount) in payout.payout {
                Promise::new(receiver_id).transfer(amount.0);
            }
            // refund all FTs (won't be any)
            price
        } else {
            // FT payouts
            for (receiver_id, amount) in payout.payout {
                ext_contract::ft_transfer(
                    receiver_id,
                    amount,
                    None,
                    ft_token_id.clone(),
                    1,
                    GAS_FOR_FT_TRANSFER,
                );
            }
            // keep all FTs (already transferred for payouts)
            U128(0)
        }
    }

    fn token_type_to_ft_token_type(&self, token_type: TokenType) -> AccountId {
        let token_type = if let Some(token_type) = token_type {
            AccountId::new_unchecked(token_type)
        } else {
            AccountId::new_unchecked("near".to_owned())
        };
        require!(
            self.market.ft_token_ids.contains(&token_type),
            "token not supported"
        );
        token_type
    }

    pub(crate) fn json_from_auction(&self, auction: Auction) -> AuctionJson {
        AuctionJson {
            owner_id: auction.owner_id,
            nft_contract_id: auction.nft_contract_id,
            token_id: auction.token_id,
            bid: auction.bid,
            created_at: auction.created_at.into(),
            ft_token_id: auction.ft_token_id,
            minimal_step: auction.minimal_step.into(),
            start_price: auction.start_price.into(),
            buy_out_price: auction.buy_out_price.map(|p| p.into()),
            start: auction.start.into(),
            end: auction.end.into(),
        }
    }
}

'''
'''--- market/src/auction_views.rs ---
use crate::auction::AuctionJson;
use crate::common::*;
use crate::*;

#[near_bindgen]
impl Market {
    pub fn get_current_buyer(&self, auction_id: U128) -> Option<AccountId> {
        let auction = self
            .market
            .auctions
            .get(&auction_id.into())
            .unwrap_or_else(|| env::panic_str("Auction does not exist"));
        if let Some(bid) = auction.bid {
            Some(bid.owner_id)
        } else {
            None
        }
    }

    pub fn check_auction_in_progress(&self, auction_id: U128) -> bool {
        let auction = self
            .market
            .auctions
            .get(&auction_id.into())
            .unwrap_or_else(|| env::panic_str("Auction does not exist"));
        auction.end >= env::block_timestamp() && auction.start < env::block_timestamp()
    }

    pub fn get_auction(&self, auction_id: U128) -> AuctionJson {
        let auction = self
            .market
            .auctions
            .get(&auction_id.into())
            .unwrap_or_else(|| env::panic_str("Auction does not exist"));
        self.json_from_auction(auction)
    }

    // Returns the minimum amount of the next auction bid (not including fees)
    pub fn get_minimal_next_bid(&self, auction_id: U128) -> U128 {
        let auction = self
            .market
            .auctions
            .get(&auction_id.into())
            .unwrap_or_else(|| env::panic_str("Auction does not exist"));
        let min_deposit = if let Some(ref bid) = auction.bid {
            let total_origins = fee::calculate_origins(&bid.origins);
            let actual_amount = fee::calculate_actual_amount(bid.price.0, total_origins); // TODO: need more tests here
            actual_amount + auction.minimal_step
        } else {
            auction.start_price
        };
        U128(min_deposit)
    }

    // Returns current bid amount (not including fees)
    pub fn get_current_bid(&self, auction_id: U128) -> Option<U128> {
        let auction = self
            .market
            .auctions
            .get(&auction_id.into())
            .unwrap_or_else(|| env::panic_str("Auction does not exist"));
        auction.bid.map(|bid| {
            {
                let total_origins = fee::calculate_origins(&bid.origins);
                let actual_amount = fee::calculate_actual_amount(bid.price.0, total_origins);
                actual_amount
            }
            .into()
        })
    }

    pub fn get_auctions(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<AuctionJson> {
        let auctions = &self.market.auctions;
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        auctions
            .values()
            .skip(start_index as usize)
            .take(limit)
            .map(|auction| self.json_from_auction(auction))
            .collect()
    }

    //pub fn get_bid_total_amount() -> U128;
}

'''
'''--- market/src/bid.rs ---
use std::collections::HashMap;

use near_sdk::assert_one_yocto;

use crate::fee::{calculate_actual_amount, calculate_origins};
use crate::sale::{
    ext_contract, ContractAndTokenId, FungibleTokenId, Sale, DELIMETER, GAS_FOR_FT_TRANSFER,
};
use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub struct Bid {
    pub owner_id: AccountId,
    pub price: U128,

    pub start: U64,
    pub end: Option<U64>,

    pub origins: Origins,
}

impl Bid {
    pub fn in_limits(&self) -> bool {
        let mut res_start = true;
        let mut res_end = true;
        let now = env::block_timestamp();
        res_start &= self.start.0 < now;
        if let Some(end) = self.end {
            res_end &= now < end.0;
        }
        res_end && res_start
    }
}

pub type Bids = HashMap<FungibleTokenId, Vec<Bid>>;
pub type Origins = HashMap<AccountId, u32>;

#[near_bindgen]
impl Market {
    // Adds a bid if it is higher than the last bid of this ft_token_id
    // Refunds the previous bid (of this ft_token_id)
    #[allow(clippy::too_many_arguments)]
    #[private]
    pub(crate) fn add_bid(
        &mut self,
        contract_and_token_id: ContractAndTokenId,
        amount: Balance,
        ft_token_id: AccountId,
        buyer_id: AccountId,
        sale: &mut Sale,
        start: U64,
        end: Option<U64>,
        origins: Option<Origins>,
    ) {
        require!(
            self.market.ft_token_ids.contains(&ft_token_id),
            format!("Token {} not supported by this market", ft_token_id)
        );
        let total_origins = if let Some(ref origins) = origins {
            calculate_origins(origins)
        } else {
            0
        };

        require!(total_origins < 4_700, "Max origins exceeded"); // TODO: FINDOUT MAX ORIGINS
        let actual_amount = calculate_actual_amount(amount, total_origins);

        // store a bid and refund any current bid lower
        let new_bid = Bid {
            owner_id: buyer_id,
            price: U128(amount),
            start,
            end,
            origins: origins.unwrap_or_default(),
        };

        let bids_for_token_id = sale
            .bids
            .entry(ft_token_id.clone())
            .or_insert_with(Vec::new);
        if let Some(current_bid) = bids_for_token_id.last() {
            let current_origins = calculate_origins(&current_bid.origins);
            let current_amount = calculate_actual_amount(current_bid.price.0, current_origins);
            require!(
                actual_amount > current_amount,
                format!(
                    "Can't pay less than or equal to current bid price: {}",
                    current_bid.price.0
                )
            );
        }

        bids_for_token_id.push(new_bid);
        if bids_for_token_id.len() > self.market.bid_history_length as usize {
            // Need to refund the earliest bid before removing it
            let early_bid = &bids_for_token_id[0];
            self.refund_bid(ft_token_id, early_bid.owner_id.clone(), early_bid.price);
            bids_for_token_id.remove(0);
        }

        self.market.sales.insert(&contract_and_token_id, sale);
    }

    #[payable]
    pub fn remove_bid(
        &mut self,
        nft_contract_id: AccountId,
        token_id: TokenId,
        ft_token_id: AccountId,
        price: U128,
    ) {
        assert_one_yocto();
        let owner_id = env::predecessor_account_id();
        self.internal_remove_bid(nft_contract_id, &ft_token_id, token_id, &owner_id, price);
        self.refund_bid(ft_token_id, owner_id, price);
    }

    // Cancels the bid if it has ended
    // Refunds it
    pub fn cancel_bid(
        &mut self,
        nft_contract_id: AccountId,
        token_id: TokenId,
        ft_token_id: AccountId,
        owner_id: AccountId,
        price: U128,
    ) {
        let bid = self
            .internal_remove_bid(nft_contract_id, &ft_token_id, token_id, &owner_id, price)
            .expect("No such bid");
        if let Some(end) = bid.end {
            let is_finished = env::block_timestamp() >= end.0;
            require!(is_finished, "The bid hasn't ended yet");
            self.refund_bid(ft_token_id, owner_id, price);
        } else {
            panic!("The bid doesn't have an end");
        }
    }

    // Cancel all expired bids
    pub fn cancel_expired_bids(
        &mut self,
        nft_contract_id: AccountId,
        token_id: TokenId,
        ft_token_id: AccountId,
    ) {
        let contract_and_token_id = format!("{}{}{}", &nft_contract_id, DELIMETER, token_id);
        let mut sale = self
            .market
            .sales
            .get(&contract_and_token_id)
            .expect("No sale");
        let bid_vec = sale.bids.get_mut(&ft_token_id).expect("No token");
        let mut sale = self
            .market
            .sales
            .get(&contract_and_token_id)
            .expect("No sale");
        bid_vec.retain(|bid_from_vec| {
            let mut not_finished = true;
            if let Some(end) = bid_from_vec.end {
                //is_finished &= env::block_timestamp() >= end.0;
                if env::block_timestamp() >= end.0 {
                    self.refund_bid(
                        ft_token_id.clone(),
                        bid_from_vec.owner_id.clone(),
                        bid_from_vec.price,
                    );
                    not_finished = false;
                };
            }
            not_finished
        });
        if bid_vec.is_empty() {
            // If there is no bids left, should remove ft_token_id from the HashMap
            sale.bids.remove(&ft_token_id);
        } else {
            // If there are some bids left, add a vector of valid bids
            sale.bids.insert(ft_token_id.clone(), bid_vec.to_vec());
        };
        self.market.sales.insert(&contract_and_token_id, &sale);
    }
}

impl Market {
    pub(crate) fn refund_all_bids(&mut self, bids_map: &Bids) {
        for (ft, bids) in bids_map {
            for bid in bids {
                self.refund_bid((*ft).clone(), bid.owner_id.clone(), bid.price);
            }
        }
    }

    pub(crate) fn refund_bid(&mut self, bid_ft: FungibleTokenId, owner_id: AccountId, price: U128) {
        if bid_ft.as_str() == "near" {
            Promise::new(owner_id).transfer(u128::from(price));
        } else {
            ext_contract::ft_transfer(owner_id, price, None, bid_ft, 1, GAS_FOR_FT_TRANSFER);
        }
    }
}

'''
'''--- market/src/common.rs ---
pub use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{LazyOption, LookupSet, LookupMap, UnorderedMap, UnorderedSet},
    env::{self, STORAGE_PRICE_PER_BYTE},
    json_types::{U128, U64},
    near_bindgen, require,
    serde::{Deserialize, Serialize},
    AccountId, Balance, BorshStorageKey, PanicOnDefault,
    CryptoHash, Promise,
    assert_one_yocto,
};

pub use near_contract_standards::non_fungible_token::{
    metadata::{NFTContractMetadata, TokenMetadata, NFT_METADATA_SPEC},
    refund_deposit, NonFungibleToken, Token, TokenId,
};

pub const NANOS_PER_SEC: u64 = 1_000_000_000;
'''
'''--- market/src/fee.rs ---
use crate::*;
use crate::{bid::Origins, common::*};
use std::collections::HashMap;

pub const PAYOUT_TOTAL_VALUE: u128 = 10_000;
pub const PROTOCOL_FEE: u128 = 300; // 10_000 is 100%, so 300 is 3%

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Fees {
    pub buyer: HashMap<AccountId, u32>,
    pub seller: HashMap<AccountId, u32>,
}

pub fn calculate_origins(origins: &Origins) -> u32 {
    let mut total: u32 = 0;
    for val in origins.values() {
        total += val;
    }
    total
}

pub fn calculate_actual_amount(amount: u128, total_origins: u32) -> u128 {
    let origin_fee = amount * (total_origins as u128 + PROTOCOL_FEE)
        / (PAYOUT_TOTAL_VALUE + total_origins as u128 + PROTOCOL_FEE);
    amount - origin_fee
}

pub fn calculate_price_with_fees(price: U128, origins: Option<&Origins>) -> u128 {
    let total_origins = if let Some(origins) = origins {
        calculate_origins(origins)
    } else {
        0
    };
    price.0 * (PAYOUT_TOTAL_VALUE + PROTOCOL_FEE + total_origins as u128) / PAYOUT_TOTAL_VALUE
}

#[near_bindgen]
impl Market {
    pub fn price_with_fees(&self, price: U128, origins: Option<Origins>) -> U128 {
        calculate_price_with_fees(price, origins.as_ref()).into()
    }
}

// pub fn with_fees(price: u128) -> u128 {
//     price * (PAYOUT_TOTAL_VALUE + PROTOCOL_FEE) / PAYOUT_TOTAL_VALUE
// }

// pub fn get_fee(price: u128) -> u128 {
//     price * PROTOCOL_FEE / PAYOUT_TOTAL_VALUE
// }

// pub fn calculate_origins(price: u128, origins: Origins) -> HashMap<AccountId, u128> {
//     let mut map = HashMap::with_capacity(origins.len());
//     for (origin, p) in origins {
//         map.insert(origin, price * p / PAYOUT_TOTAL_VALUE);
//     }
//     map
// }

// pub fn calculate_origin_fee(price: u128, origins: &Origins) -> u128 {
//     let mut total = 0;
//     for p in origins.values() {
//         total += p.0;
//     }
//     price * total / (PAYOUT_TOTAL_VALUE + total)
// }
// #[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
// //#[serde(crate = "near_sdk::serde")]
// pub struct Fees {
//     pub protocol_fee: u128,
//     pub origins: UnorderedMap<AccountId, u128>,
//     pub royalty: u128,
// }

// impl Fees {
//     //Should be called in add_bid to check that the buyer attached enough deposit to pay the price + fee.
//     pub fn total_amount_fee_side(&self, price: U128) -> U128 {
//         U128(price.0 + self.calculate_protocol_fee(price).0 + self.calculate_origin_fee(price).0)
//     }

//     pub fn calculate_protocol_fee(&self, price: U128) -> U128 {
//         U128(price.0 * self.protocol_fee / 10_000 as u128)
//     }

//     pub fn calculate_origin_fee(&self, price: U128) -> U128 {
//         //    let accounts_and_fees = self.origins.get(&token).unwrap();
//         //    let mut total_origin: u128 = 0;
//         //    for (_account, fee) in accounts_and_fees.iter() {
//         //        total_origin += fee;
//         //    }
//         //    U128(price.0*total_origin)

//         let mut total_origin: u128 = 0;
//         for (_account, fee) in self.origins.iter() {
//             total_origin += fee;
//         }

//         U128(price.0 * total_origin / 10_000 as u128)
//     }

//     pub fn calculate_royalty(&self, price: U128) -> U128 {
//         U128(price.0 * self.royalty / 10_000 as u128)
//     }
// }

// //Fee side here is the account which buys nft. It pays with NEAR (or FT?).
// //It pays protocol_fees and origins.
// //Non-fee side pays protocol_fees, origins and royalty.

// //doTransfersWithFees on the fee side
// //transferPayouts on the non-fee side

'''
'''--- market/src/hack.rs ---
use crate::*;

#[near_bindgen]
impl Market {

    pub fn hack_finish_sale(&mut self, nft_contract_token: ContractAndTokenId) {
        let mut sale = self.market.sales.get(&nft_contract_token).expect("no sale");
        sale.end = Some(env::block_timestamp());
        self.market.sales.insert(&nft_contract_token, &sale);
    }

    pub fn hack_finish_bid(&mut self, nft_contract_token: ContractAndTokenId) {
        let mut sale = self.market.sales.get(&nft_contract_token).expect("no sale");
        let bid = sale
            .bids
            .get_mut(&("near".parse().unwrap()))
            .expect("no bids")
            .last_mut();
        if let Some(bid) = bid {
            bid.end = Some(U64(env::block_timestamp()))
        }
        self.market.sales.insert(&nft_contract_token, &sale);
    }

    pub fn hack_finish_auction(&mut self, auction_id: U128) {
        let mut auction = self.market.auctions.get(&auction_id.into()).expect("no auction");
        auction.end = env::block_timestamp();
        self.market.auctions.insert(&auction_id.into(), &auction);
    }
}

'''
'''--- market/src/inner.rs ---
use crate::bid::Bid;
use crate::common::*;
use crate::sale::{Sale, DELIMETER};
use crate::Market;

impl Market {
    pub(crate) fn internal_remove_sale(
        &mut self,
        nft_contract_id: AccountId,
        token_id: TokenId,
    ) -> Sale {
        let contract_and_token_id = format!("{}{}{}", &nft_contract_id, DELIMETER, token_id);
        let sale = self
            .market
            .sales
            .remove(&contract_and_token_id)
            .expect("No sale");

        let mut by_owner_id = self
            .market
            .by_owner_id
            .get(&sale.owner_id)
            .expect("No sale by_owner_id");
        by_owner_id.remove(&contract_and_token_id);
        if by_owner_id.is_empty() {
            self.market.by_owner_id.remove(&sale.owner_id);
        } else {
            self.market.by_owner_id.insert(&sale.owner_id, &by_owner_id);
        }

        let mut by_nft_contract_id = self
            .market
            .by_nft_contract_id
            .get(&nft_contract_id)
            .expect("No sale by nft_contract_id");
        by_nft_contract_id.remove(&token_id);
        if by_nft_contract_id.is_empty() {
            self.market.by_nft_contract_id.remove(&nft_contract_id);
        } else {
            self.market
                .by_nft_contract_id
                .insert(&nft_contract_id, &by_nft_contract_id);
        }

        // here AccountId is used as "token type", idk why so (adsick)
        if let Some(token_type) = sale.token_type.to_owned() {
            let mut by_nft_token_type = self
                .market
                .by_nft_token_type
                .get(&token_type)
                .expect("No sale by nft_token_type");
            by_nft_token_type.remove(&contract_and_token_id);
            if by_nft_token_type.is_empty() {
                self.market.by_nft_token_type.remove(&token_type);
            } else {
                self.market
                    .by_nft_token_type
                    .insert(&token_type, &by_nft_token_type);
            }
        }

        sale
    }

    pub(crate) fn internal_remove_bid(
        &mut self,
        nft_contract_id: AccountId,
        ft_token_id: &AccountId,
        token_id: TokenId,
        owner_id: &AccountId,
        price: U128
    ) -> Option<Bid> {
        let contract_and_token_id = format!("{}{}{}", &nft_contract_id, DELIMETER, token_id);
        let sale = self
            .market
            .sales
            .get(&contract_and_token_id)
            .expect("No sale");
        let bid_vec = sale.bids.get(ft_token_id).expect("No token");

        let mut sale = self
            .market
            .sales
            .get(&contract_and_token_id)
            .expect("No sale");
        for (index, bid_from_vec) in bid_vec.iter().enumerate() {
            if &(bid_from_vec.owner_id) == owner_id && bid_from_vec.price == price {
                if bid_vec.len() == 1 {
                    //If the vector contained only one bid, should remove ft_token_id from the HashMap
                    sale.bids.remove(ft_token_id);
                } else {
                    //If there are several bids for this ft_token_id, should remove one bid
                    sale.bids
                        .get_mut(ft_token_id)
                        .expect("No token")
                        .remove(index);
                };
                self.market.sales.insert(&contract_and_token_id, &sale);
                //break; // shouldn't allow bids with equal price 
                return Some((*bid_from_vec).clone());
            };
        }
        None
    }
}

'''
'''--- market/src/lib.rs ---
mod auction;
mod auction_views;
mod bid;
mod common;
mod fee;
mod inner;
mod market_core;
mod sale;
mod sale_views;
mod token;

mod hack; // TODO: remove

use common::*;

use crate::sale::{Sale, SaleConditions, TokenType,
    ContractAndTokenId, FungibleTokenId};
use crate::auction::Auction;
pub use crate::sale::{SaleJson, BID_HISTORY_LENGTH_DEFAULT};
pub use crate::market_core::{ArgsKind, SaleArgs, AuctionArgs};
pub use crate::auction::{AuctionJson, EXTENSION_DURATION};
pub use crate::fee::{Fees, PAYOUT_TOTAL_VALUE, PROTOCOL_FEE};

const STORAGE_PER_SALE: u128 = 1000 * STORAGE_PRICE_PER_BYTE;

/// Helper structure to for keys of the persistent collections.
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    Sales,
    ByOwnerId,
    ByOwnerIdInner { account_id_hash: CryptoHash },
    ByNFTContractId,
    ByNFTContractIdInner { account_id_hash: CryptoHash },
    ByNFTTokenType,
    ByNFTTokenTypeInner { token_type_hash: CryptoHash },
    FTTokenIds,
    StorageDeposits,
    OriginFees,
    Auctions,
    AuctionId,
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct MarketSales {
    pub owner_id: AccountId,
    pub sales: UnorderedMap<ContractAndTokenId, Sale>,
    pub by_owner_id: LookupMap<AccountId, UnorderedSet<ContractAndTokenId>>,
    pub by_nft_contract_id: LookupMap<AccountId, UnorderedSet<TokenId>>,
    pub by_nft_token_type: LookupMap<String, UnorderedSet<ContractAndTokenId>>,
    pub ft_token_ids: UnorderedSet<FungibleTokenId>,
    pub storage_deposits: LookupMap<AccountId, Balance>,
    pub bid_history_length: u8,

    pub auctions: UnorderedMap<u128, Auction>,
    pub next_auction_id: u128,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Market {
    non_fungible_token_account_ids: LookupSet<AccountId>,
    market: MarketSales,
}

#[near_bindgen]
impl Market {
    #[init]
    pub fn new(nft_ids: Vec<AccountId>, owner_id: AccountId) -> Self {
        let mut non_fungible_token_account_ids = LookupSet::new(b"n");
        non_fungible_token_account_ids.extend(nft_ids);
        let mut tokens = UnorderedSet::new(StorageKey::FTTokenIds);
        tokens.insert(&AccountId::new_unchecked("near".to_owned()));
        let market = MarketSales {
            owner_id,
            sales: UnorderedMap::new(StorageKey::Sales),
            by_owner_id: LookupMap::new(StorageKey::ByOwnerId),
            by_nft_contract_id: LookupMap::new(StorageKey::ByNFTContractId),
            by_nft_token_type: LookupMap::new(StorageKey::ByNFTTokenType),
            ft_token_ids: tokens,
            storage_deposits: LookupMap::new(StorageKey::StorageDeposits),
            bid_history_length: BID_HISTORY_LENGTH_DEFAULT,
            auctions: UnorderedMap::new(StorageKey::Auctions),
            next_auction_id: 0,
        };
        Self {
            non_fungible_token_account_ids,
            market,
        }
    }

    #[payable]
    pub fn storage_withdraw(&mut self) {
        assert_one_yocto();
        let owner_id = env::predecessor_account_id();
        let mut amount = self.market.storage_deposits.remove(&owner_id).unwrap_or(0);
        let sales = self.market.by_owner_id.get(&owner_id);
        let len = sales.map(|s| s.len()).unwrap_or_default();
        let diff = u128::from(len) * STORAGE_PER_SALE;
        amount -= diff;
        if amount > 0 {
            Promise::new(owner_id.clone()).transfer(amount);
        }
        if diff > 0 {
            self.market.storage_deposits.insert(&owner_id, &diff);
        }
    }

    #[payable]
    pub fn storage_deposit(&mut self, account_id: Option<AccountId>) {
        let storage_account_id = account_id.unwrap_or_else(env::predecessor_account_id);
        let deposit = env::attached_deposit();
        assert!(
            deposit >= STORAGE_PER_SALE,
            "Requires minimum deposit of {}",
            STORAGE_PER_SALE
        );
        let mut balance: u128 = self
            .market
            .storage_deposits
            .get(&storage_account_id)
            .unwrap_or(0);
        balance += deposit;
        self.market
            .storage_deposits
            .insert(&storage_account_id, &balance);
    }

    pub fn storage_amount(&self) -> U128 {
        U128(STORAGE_PER_SALE)
    }
}

'''
'''--- market/src/market_core.rs ---
use near_sdk::serde_json::json;
use crate::*;
use crate::bid::Origins;

pub trait NonFungibleTokenApprovalReceiver {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleArgs {
    pub sale_conditions: SaleConditions,
    pub token_type: TokenType,

    pub start: Option<U64>,
    pub end: Option<U64>,

    pub origins: Option<Origins>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AuctionArgs {
    pub token_type: TokenType,
    pub minimal_step: U128,
    pub start_price: U128,

    pub start: Option<U64>,
    pub duration: U64,
    pub buy_out_price: Option<U128>,

    pub origins: Option<Origins>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum ArgsKind {
    Sale(SaleArgs),
    Auction(AuctionArgs),
}

#[near_bindgen]
impl NonFungibleTokenApprovalReceiver for Market {
    // nft_on_approve is called via cross-contract call in order to create a new sale or auction
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    ) {
        // make sure that the method is called in a cross contract call and the signer is owner_id

        let nft_contract_id = env::predecessor_account_id();
        let signer_id = env::signer_account_id();
        require!(
            nft_contract_id != signer_id,
            "nft_on_approve should only be called via cross-contract call"
        );
        require!(owner_id == signer_id, "owner_id should be signer_id");

        // check that the signer's storage is enough to cover one more sale

        let storage_amount = self.storage_amount().0;
        let owner_paid_storage = self.market.storage_deposits.get(&signer_id).unwrap_or(0);
        let signer_storage_required =
            (self.get_supply_by_owner_id(signer_id).0 + 1) as u128 * storage_amount;
        assert!(
            owner_paid_storage >= signer_storage_required,
            "Insufficient storage paid: {}, for {} sales at {} rate of per sale",
            owner_paid_storage,
            signer_storage_required / STORAGE_PER_SALE,
            STORAGE_PER_SALE
        );

        // Parse the msg to find Sale or Auction arguments

        let args: ArgsKind = near_sdk::serde_json::from_str(&msg).expect("Not valid args");
        match args {
            ArgsKind::Sale(sale_args) => {
                let sale_json = self.start_sale(
                    sale_args,
                    token_id,
                    owner_id,
                    approval_id,
                    nft_contract_id,
                );
                env::log_str(&near_sdk::serde_json::to_string(&sale_json).unwrap());
            }
            ArgsKind::Auction(auction_args) => {
                let (id, auction_json) = self.start_auction(
                    auction_args,
                    token_id,
                    owner_id,
                    approval_id,
                    nft_contract_id,
                );
                env::log_str(&json!({
                    "auction_id": U128(id),
                    "auction_json": auction_json
                }).to_string())
            }
        }
    }

    /*
    fn nft_on_series_approve(&mut self, token_series: TokenSeriesSale) {
        let nft_contract_id = env::predecessor_account_id();
        let signer_id = env::signer_account_id();
        require!(
            nft_contract_id != signer_id,
            "nft_on_approve should only be called via cross-contract call"
        );
        require!(
            token_series.owner_id == signer_id,
            "owner_id should be signer_id"
        );

        let storage_amount = self.storage_amount().0;
        let owner_paid_storage = self.market.storage_deposits.get(&signer_id).unwrap_or(0);
        let signer_storage_required =
            (self.get_supply_by_owner_id(signer_id).0 + 1) as u128 * storage_amount;
        assert!(
            owner_paid_storage >= signer_storage_required,
            "Insufficient storage paid: {}, for {} sales at {} rate of per sale",
            owner_paid_storage,
            signer_storage_required / STORAGE_PER_SALE,
            STORAGE_PER_SALE
        );

        for (ft_token_id, _price) in token_series.sale_conditions.clone() {
            if !self.market.ft_token_ids.contains(&ft_token_id) {
                env::panic_str(&format!(
                    "Token {} not supported by this market",
                    ft_token_id
                ));
            }
        }

        let contract_and_series_id =
            format!("{}{}{}", nft_contract_id, DELIMETER, token_series.series_id);

        // extra for views

        let mut by_owner_id = self
            .market
            .by_owner_id
            .get(&token_series.owner_id)
            .unwrap_or_else(|| {
                UnorderedSet::new(
                    StorageKey::ByOwnerIdInner {
                        account_id_hash: hash_account_id(&token_series.owner_id),
                    }
                    .try_to_vec()
                    .unwrap(),
                )
            });

        let owner_occupied_storage = u128::from(by_owner_id.len()) * STORAGE_PER_SALE;
        require!(
            owner_paid_storage > owner_occupied_storage,
            "User has more sales than storage paid"
        );
        by_owner_id.insert(&contract_and_series_id);
        self.market
            .by_owner_id
            .insert(&token_series.owner_id, &by_owner_id);

        self.market.series_sales.insert(
            &contract_and_series_id,
            &SeriesSale {
                owner_id: token_series.owner_id,
                nft_contract_id: env::predecessor_account_id(),
                series_id: token_series.series_id,
                sale_conditions: token_series.sale_conditions,
                created_at: env::block_timestamp(),
                copies: token_series.copies,
            },
        );
    }
    */
}

'''
'''--- market/src/sale.rs ---
#![allow(clippy::too_many_arguments)]
use std::collections::HashMap;

use near_sdk::ext_contract;
use near_sdk::serde_json::json;
use near_sdk::{promise_result_as_success, Gas};

use crate::fee::calculate_price_with_fees;
use crate::market_core::SaleArgs;
use crate::*;
use common::*;
use near_contract_standards::non_fungible_token::hash_account_id;

use bid::{Bids, Origins};
pub type TokenSeriesId = String;

pub const GAS_FOR_FT_TRANSFER: Gas = Gas(5_000_000_000_000);
pub const GAS_FOR_ROYALTIES: Gas = Gas(115_000_000_000_000);
pub const GAS_FOR_NFT_TRANSFER: Gas = Gas(30_000_000_000_000);
// pub const GAS_FOR_MINT: Gas = Gas(20_000_000_000_000);
pub const BID_HISTORY_LENGTH_DEFAULT: u8 = 5;
pub(crate) const NO_DEPOSIT: Balance = 0;
pub static DELIMETER: &str = "||";

pub type SaleConditions = HashMap<FungibleTokenId, U128>;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
}

pub type ContractAndTokenId = String;
pub type FungibleTokenId = AccountId;
pub type TokenType = Option<String>;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Sale {
    pub owner_id: AccountId,
    pub approval_id: u64,
    pub nft_contract_id: AccountId,
    pub token_id: String,
    pub sale_conditions: SaleConditions,
    pub bids: Bids,
    pub created_at: u64,
    pub token_type: TokenType,

    pub start: Option<u64>,
    pub end: Option<u64>,

    pub origins: Origins,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleJson {
    pub owner_id: AccountId,
    pub nft_contract_id: AccountId,
    pub token_id: String,
    pub sale_conditions: SaleConditions,
    pub bids: Bids,
    pub created_at: U64,
    pub token_type: TokenType,

    pub start: Option<U64>,
    pub end: Option<U64>,
    pub origins: Origins,
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct SeriesSale {
    pub owner_id: AccountId,
    pub nft_contract_id: AccountId,
    pub series_id: String,
    pub sale_conditions: SaleConditions,
    pub created_at: u64,
    pub copies: u64,
}

impl Sale {
    pub fn in_limits(&self) -> bool {
        let mut res = true;
        let now = env::block_timestamp();
        if let Some(start) = self.start {
            res &= start < now;
        }
        if let Some(end) = self.end {
            res &= now < end;
        }
        res
    }

    pub fn extend(&mut self, time: u64) -> bool {
        if let Some(end) = self.end {
            self.end = Some(end + time);
            true
        } else {
            false
        }
    }
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PurchaseArgs {
    pub nft_contract_id: AccountId,
    pub token_id: TokenId,
}

#[near_bindgen]
impl Market {
    pub(crate) fn start_sale(
        &mut self,
        args: SaleArgs,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        nft_contract_id: AccountId,
    ) -> SaleJson {
        let SaleArgs {
            sale_conditions,
            token_type,
            start,
            end,
            origins,
        } = args;

        // check that the offered ft token is supported

        for ft_token_id in sale_conditions.keys() {
            if !self.market.ft_token_ids.contains(ft_token_id) {
                env::panic_str(&format!(
                    "Token {} not supported by this market",
                    ft_token_id
                ));
            }
            //*price = U128::from(calculate_price_with_fees(*price, None));
        }

        // Create a new sale with given arguments and empty list of bids

        let bids = HashMap::new();
        let contract_and_token_id = format!("{}{}{}", nft_contract_id, DELIMETER, token_id);
        let start = start.map(|s| s.into()).unwrap_or_else(env::block_timestamp);
        let sale = Sale {
            owner_id: owner_id.clone(),
            approval_id,
            nft_contract_id: nft_contract_id.clone(),
            token_id: token_id.clone(),
            sale_conditions,
            bids,
            created_at: env::block_timestamp(),
            token_type: token_type.clone(),
            start: Some(start),
            end: end.map(|e| e.into()),
            origins: origins.unwrap_or_default(),
        };
        self.market.sales.insert(&contract_and_token_id, &sale);

        // extra for views

        let mut by_owner_id = self.market.by_owner_id.get(&owner_id).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::ByOwnerIdInner {
                    account_id_hash: hash_account_id(&owner_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        // Check that the paid storage amount is enough
        let owner_paid_storage = self
            .market
            .storage_deposits
            .get(&env::signer_account_id())
            .unwrap_or(0);
        let owner_occupied_storage = u128::from(by_owner_id.len()) * STORAGE_PER_SALE;
        assert!(
            owner_paid_storage > owner_occupied_storage,
            "User has more sales than storage paid"
        );
        by_owner_id.insert(&contract_and_token_id);
        self.market.by_owner_id.insert(&owner_id, &by_owner_id);

        let mut by_nft_contract_id = self
            .market
            .by_nft_contract_id
            .get(&nft_contract_id)
            .unwrap_or_else(|| {
                UnorderedSet::new(
                    StorageKey::ByNFTContractIdInner {
                        account_id_hash: hash_account_id(&nft_contract_id),
                    }
                    .try_to_vec()
                    .unwrap(),
                )
            });
        by_nft_contract_id.insert(&token_id);
        self.market
            .by_nft_contract_id
            .insert(&nft_contract_id, &by_nft_contract_id);

        if let Some(token_type) = token_type {
            assert!(
                token_id.contains(token_type.as_str()),
                "TokenType should be substr of TokenId"
            );
            let mut by_nft_token_type = self
                .market
                .by_nft_token_type
                .get(&token_type)
                .unwrap_or_else(|| {
                    UnorderedSet::new(
                        StorageKey::ByNFTTokenTypeInner {
                            token_type_hash: hash_account_id(&AccountId::new_unchecked(
                                token_type.clone(),
                            )),
                        }
                        .try_to_vec()
                        .unwrap(),
                    )
                });
            by_nft_token_type.insert(&contract_and_token_id);
            self.market
                .by_nft_token_type
                .insert(&token_type, &by_nft_token_type);
        }

        self.json_from_sale(sale)
    }

    /// TODO remove without redirect to wallet? panic reverts
    #[payable]
    pub fn remove_sale(&mut self, nft_contract_id: AccountId, token_id: String) {
        assert_one_yocto();
        let sale = self.internal_remove_sale(nft_contract_id, token_id);
        let owner_id = env::predecessor_account_id();
        if sale.in_limits() {
            assert_eq!(
                owner_id, sale.owner_id,
                "Until the sale is finished, it can only be removed by the sale owner"
            );
        };
        self.refund_all_bids(&sale.bids);
    }

    #[payable]
    pub fn update_price(
        &mut self,
        nft_contract_id: AccountId,
        token_id: String,
        ft_token_id: FungibleTokenId,
        price: U128,
    ) {
        assert_one_yocto();
        let contract_id: AccountId = nft_contract_id;
        let contract_and_token_id = format!("{}{}{}", contract_id, DELIMETER, token_id);
        let mut sale = self
            .market
            .sales
            .get(&contract_and_token_id)
            .expect("No sale");
        assert_eq!(
            env::predecessor_account_id(),
            sale.owner_id,
            "Must be sale owner"
        );
        if !self.market.ft_token_ids.contains(&ft_token_id) {
            env::panic_str(&format!(
                "Token '{}' is not supported by this market",
                ft_token_id
            ));
        }
        sale.sale_conditions.insert(ft_token_id, price);
        self.market.sales.insert(&contract_and_token_id, &sale);
    }

    // Offer to buy the nft
    // Buy nft if the attached deposit equal to the price, otherwise adds a bid
    #[payable]
    pub fn offer(
        &mut self,
        nft_contract_id: AccountId,
        token_id: String,
        ft_token_id: AccountId,
        start: Option<U64>,
        duration: Option<U64>,
        origins: Option<Origins>,
    ) {
        let contract_id: AccountId = nft_contract_id;
        let contract_and_token_id = format!("{}{}{}", contract_id, DELIMETER, token_id);
        let mut sale = self
            .market
            .sales
            .get(&contract_and_token_id)
            .expect("No sale");
        // Check that the sale is in progress
        require!(
            sale.in_limits(),
            "Either the sale is finished or it hasn't started yet"
        );

        let buyer_id = env::predecessor_account_id();
        require!(sale.owner_id != buyer_id, "Cannot bid on your own sale.");
        let price = *sale
            .sale_conditions
            .get(&ft_token_id)
            .unwrap_or_else(|| env::panic_str("Not supported ft"));

        let deposit = env::attached_deposit();
        require!(deposit > 0, "Attached deposit must be greater than 0");

        if deposit == calculate_price_with_fees(price, origins.as_ref()) {
            self.process_purchase(
                contract_id,
                token_id,
                ft_token_id,
                U128(deposit),
                buyer_id,
                origins.unwrap_or_default(),
            );
        } else {
            let start = start.unwrap_or(env::block_timestamp().into());
            let end = duration.map(|d| U64(d.0 + start.0));
            self.add_bid(
                contract_and_token_id,
                deposit,
                ft_token_id,
                buyer_id,
                &mut sale,
                start,
                end,
                origins,
            );
        }
    }

    // Accepts the last (highest) offer
    pub fn accept_offer(
        &mut self,
        nft_contract_id: AccountId,
        token_id: String,
        ft_token_id: AccountId,
    ) {
        let contract_id: AccountId = nft_contract_id;
        let contract_and_token_id = format!("{}{}{}", contract_id, DELIMETER, token_id);
        // Check that the sale is in progress and remove bid before proceeding to process purchase
        let mut sale = self
            .market
            .sales
            .get(&contract_and_token_id)
            .expect("No sale");
        require!(
            sale.in_limits(),
            "Either the sale is finished or it hasn't started yet"
        );
        let bids_for_token_id = sale.bids.remove(&ft_token_id).expect("No bids");
        let bid = &bids_for_token_id[bids_for_token_id.len() - 1];
        require!(bid.in_limits(), "Out of time limit of the bid");
        self.market.sales.insert(&contract_and_token_id, &sale);
        // panics at `self.internal_remove_sale` and reverts above if predecessor is not sale.owner_id
        self.process_purchase(
            contract_id,
            token_id,
            ft_token_id,
            bid.price,
            bid.owner_id.clone(),
            bid.origins.clone(),
        );
    }

    #[private]
    pub fn process_purchase(
        &mut self,
        nft_contract_id: AccountId,
        token_id: String,
        ft_token_id: AccountId,
        price: U128,
        buyer_id: AccountId,
        origins: Origins,
    ) -> Promise {
        let sale = self.internal_remove_sale(nft_contract_id.clone(), token_id.clone());
        let mut buyer = origins;
        buyer.insert(env::current_account_id(), PROTOCOL_FEE as u32);
        let mut seller_fee = HashMap::with_capacity(sale.origins.len() + 1);
        seller_fee.extend(sale.origins.clone()); // TODO: dodge this clone
        seller_fee.insert(env::current_account_id(), PROTOCOL_FEE as u32);
        let fees = fee::Fees {
            buyer,
            seller: seller_fee,
        };
        ext_contract::nft_transfer_payout(
            buyer_id.clone(),
            token_id,
            sale.approval_id,
            Some(near_sdk::serde_json::to_string(&fees).expect("Failed to sereailize")),
            price,
            10,
            nft_contract_id,
            1,
            GAS_FOR_NFT_TRANSFER,
        )
        .then(ext_self::resolve_purchase(
            ft_token_id,
            buyer_id,
            sale,
            price,
            env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_ROYALTIES,
        ))
    }

    // self callback
    // If transfer of token succeded - count fees and transfer payouts
    // If failed - refund price to buyer
    #[private]
    pub fn resolve_purchase(
        &mut self,
        ft_token_id: AccountId,
        buyer_id: AccountId,
        sale: Sale,
        price: U128,
    ) -> U128 {
        // checking for payout information
        let payout_option = promise_result_as_success().and_then(|value| {
            // None means a bad payout from bad NFT contract
            near_sdk::serde_json::from_slice::<Payout>(&value)
                .ok()
                .and_then(|payout| {
                    // gas to do 10 FT transfers (and definitely 10 NEAR transfers)
                    if payout.payout.len() + sale.bids.len() > 10 || payout.payout.is_empty() {
                        env::log_str("Cannot have more than 10 royalties and sale.bids refunds");
                        None
                    } else {
                        let mut remainder = price.0;
                        for &value in payout.payout.values() {
                            remainder = remainder.checked_sub(value.0)?;
                        }
                        if remainder <= 1 {
                            Some(payout)
                        } else {
                            None
                        }
                    }
                })
        });
        // is payout option valid?
        let payout = if let Some(payout_option) = payout_option {
            payout_option
        } else {
            if ft_token_id == "near".parse().unwrap() {
                Promise::new(buyer_id.clone()).transfer(u128::from(price));
            }
            // leave function and return all FTs in ft_resolve_transfer
            env::log_str(
                &json!({
                    "type": "resolve_purchase_fail",
                    "params": {
                        "owner_id": sale.owner_id,
                        "nft_contract_id": sale.nft_contract_id,
                        "token_id": sale.token_id,
                        "ft_token_id": ft_token_id,
                        "price": price,
                        "buyer_id": buyer_id,
                    }
                })
                .to_string(),
            );
            return price;
        };
        // Going to payout everyone, first return all outstanding bids (accepted offer bid was already removed)
        self.refund_all_bids(&sale.bids); // TODO: maybe should do this outside of this call, to lower gas for this call

        // NEAR payouts
        if ft_token_id == "near".parse().unwrap() {
            for (receiver_id, amount) in payout.payout {
                Promise::new(receiver_id).transfer(amount.0);
            }
            price
        } else {
            // FT payouts
            for (receiver_id, amount) in payout.payout {
                ext_contract::ft_transfer(
                    receiver_id,
                    amount,
                    None,
                    ft_token_id.clone(),
                    1,
                    GAS_FOR_FT_TRANSFER,
                );
            }
            // keep all FTs (already transferred for payouts)
            U128(0)
        }
    }

    // For lazy-mint situations easier resolver
    #[private]
    pub fn resolve_token_buy(&mut self, buyer_id: AccountId, deposit: U128, price: U128) -> U128 {
        let payout_option = promise_result_as_success().and_then(|value| {
            // None means a bad payout from bad NFT contract
            near_sdk::serde_json::from_slice::<Payout>(&value)
                .ok()
                .and_then(|payout| {
                    let mut remainder = price.0;
                    for &value in payout.payout.values() {
                        remainder = remainder.checked_sub(value.0)?;
                    }
                    if remainder <= 1 {
                        Some(payout)
                    } else {
                        None
                    }
                })
        });
        let payout = if let Some(payout_option) = payout_option {
            payout_option
        } else {
            Promise::new(buyer_id).transfer(u128::from(deposit));
            return price;
        };
        for (receiver_id, amount) in payout.payout {
            Promise::new(receiver_id).transfer(amount.0);
        }
        price
    }
}

/// self call

#[ext_contract(ext_self)]
trait ExtSelf {
    fn resolve_purchase(
        &mut self,
        ft_token_id: AccountId,
        buyer_id: AccountId,
        sale: Sale,
        price: U128,
    ) -> Promise;

    fn resolve_finish_auction(&mut self, ft_token_id: AccountId, buyer_id: AccountId, price: U128);

    fn resolve_mint(
        &mut self,
        nft_contract_id: AccountId,
        buyer_id: AccountId,
        deposit: U128,
        price: U128,
    ) -> Promise;

    fn resolve_token_buy(&mut self, buyer_id: AccountId, deposit: U128, price: U128) -> Promise;
}

/// external contract calls

#[ext_contract(ext_contract)]
trait ExtContract {
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        memo: Option<String>,
        balance: U128,
        max_len_payout: u32,
    ) -> Promise;
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
    fn nft_mint(&mut self, token_series_id: TokenSeriesId, receiver_id: AccountId);
    fn nft_payout(&self, token_id: String, balance: U128, max_len_payout: u32) -> Payout;
}

'''
'''--- market/src/sale_views.rs ---
use crate::common::*;
use crate::*;

use crate::sale::{SaleJson, DELIMETER};
use std::cmp::min;

#[near_bindgen]
impl Market {
    /// views
    pub fn get_supply_sales(&self) -> U64 {
        U64(self.market.sales.len())
    }

    pub fn get_sales(
        &self,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<SaleJson> {
        let sales = &self.market.sales;
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        sales
            .values()
            .skip(start_index as usize)
            .take(limit)
            .map(|sale| self.json_from_sale(sale))
            .collect()
    }

    pub fn get_supply_by_owner_id(&self, account_id: AccountId) -> U64 {
        let by_owner_id = self.market.by_owner_id.get(&account_id);
        if let Some(by_owner_id) = by_owner_id {
            U64(by_owner_id.len())
        } else {
            U64(0)
        }
    }

    pub fn get_sales_by_owner_id(
        &self,
        account_id: AccountId,
        from_index: U64,
        limit: u64,
    ) -> Vec<SaleJson> {
        let mut tmp = vec![];
        let by_owner_id = self.market.by_owner_id.get(&account_id);
        let sales = if let Some(by_owner_id) = by_owner_id {
            by_owner_id
        } else {
            return vec![];
        };
        let keys = sales.as_vector();
        let start = u64::from(from_index);
        let end = min(start + limit, sales.len());
        for i in start..end {
            let sale = self.market.sales.get(&keys.get(i).unwrap()).unwrap();
            tmp.push(self.json_from_sale(sale));
        }
        tmp
    }

    pub fn get_supply_by_nft_contract_id(&self, nft_contract_id: AccountId) -> U64 {
        let by_nft_contract_id = self.market.by_nft_contract_id.get(&nft_contract_id);
        if let Some(by_nft_contract_id) = by_nft_contract_id {
            U64(by_nft_contract_id.len())
        } else {
            U64(0)
        }
    }

    pub fn get_sales_by_nft_contract_id(
        &self,
        nft_contract_id: AccountId,
        from_index: U64,
        limit: u64,
    ) -> Vec<SaleJson> {
        let mut tmp = vec![];
        let by_nft_contract_id = self.market.by_nft_contract_id.get(&nft_contract_id);
        let sales = if let Some(by_nft_contract_id) = by_nft_contract_id {
            by_nft_contract_id
        } else {
            return vec![];
        };
        let keys = sales.as_vector();
        let start = u64::from(from_index);
        let end = min(start + limit, sales.len());
        for i in start..end {
            let sale = self
                .market
                .sales
                .get(&format!(
                    "{}{}{}",
                    &nft_contract_id,
                    DELIMETER,
                    &keys.get(i).unwrap()
                ))
                .unwrap();
            let sale_json = self.json_from_sale(sale);
            tmp.push(sale_json);
        }
        tmp
    }

    pub fn get_supply_by_nft_token_type(&self, token_type: String) -> U64 {
        let by_nft_token_type = self.market.by_nft_token_type.get(&token_type);
        if let Some(by_nft_token_type) = by_nft_token_type {
            U64(by_nft_token_type.len())
        } else {
            U64(0)
        }
    }

    pub fn get_sales_by_nft_token_type(
        &self,
        token_type: String,
        from_index: U64,
        limit: u64,
    ) -> Vec<SaleJson> {
        let mut tmp = vec![];
        let by_nft_token_type = self.market.by_nft_token_type.get(&token_type);
        let sales = if let Some(by_nft_token_type) = by_nft_token_type {
            by_nft_token_type
        } else {
            return vec![];
        };
        let keys = sales.as_vector();
        let start = u64::from(from_index);
        let end = min(start + limit, sales.len());
        for i in start..end {
            let sale = self.market.sales.get(&keys.get(i).unwrap()).unwrap();
            let sale_json = self.json_from_sale(sale);
            tmp.push(sale_json);
        }
        tmp
    }

    pub fn get_sale(&self, nft_contract_id: AccountId, token_id: TokenId) -> Option<SaleJson> {
        let contract_and_token_id = format!("{}{}{}", &nft_contract_id, DELIMETER, token_id);
        self.market
            .sales
            .get(&contract_and_token_id)
            .map(|sale| self.json_from_sale(sale))
    }

    pub(crate) fn json_from_sale(&self, sale: Sale) -> SaleJson {
        SaleJson {
            owner_id: sale.owner_id,
            nft_contract_id: sale.nft_contract_id,
            token_id: sale.token_id,
            sale_conditions: sale.sale_conditions,
            bids: sale.bids,
            created_at: sale.created_at.into(),
            token_type: sale.token_type,

            start: sale.start.map(|s| s.into()),
            end: sale.end.map(|e| e.into()),
            origins: sale.origins,
        }
    }
}

'''
'''--- market/src/token.rs ---

use near_contract_standards::non_fungible_token::metadata::TokenMetadata;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::AccountId;
use std::collections::HashMap;

use crate::sale::{SaleConditions, TokenSeriesId};

/// Note that token IDs for NFTs are strings on NEAR. It's still fine to use autoincrementing numbers as unique IDs if desired, but they should be stringified. This is to make IDs more future-proof as chain-agnostic conventions and standards arise, and allows for more flexibility with considerations like bridging NFTs across chains, etc.
pub type TokenId = String;

/// In this implementation, the Token struct takes two extensions standards (metadata and approval) as optional fields, as they are frequently used in modern NFTs.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct Token {
    pub token_id: TokenId,
    pub owner_id: AccountId,
    pub metadata: Option<TokenMetadata>,
    pub approved_account_ids: Option<HashMap<AccountId, u64>>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenSeriesSale {
    pub sale_conditions: SaleConditions,
    pub series_id: TokenSeriesId,
    pub owner_id: AccountId,
    pub copies: u64,
}
'''
'''--- market/test.sh ---
#!/bin/bash
set -e

cargo test -- --nocapture

'''
'''--- market/tests/nft_contract.rs ---
#![allow(clippy::ref_in_deref)]
mod utils;
use std::collections::HashMap;

use near_contract_standards::non_fungible_token::Token;
use near_sdk_sim::{call, to_yocto, transaction::ExecutionStatus, view};
use nft_contract::{common::TokenMetadata, TokenSeriesJson};
use utils::init;

#[test]
fn nft_create_series_negative() {
    let (root, _, nft) = init();
    let user1 = root.create_user("user1".parse().unwrap(), to_yocto("1000"));
    let user2 = root.create_user("user2".parse().unwrap(), to_yocto("1000"));
    // Only authorized account can create series
    call!(root, nft.set_private_minting(true));
    let token_metadata = TokenMetadata {
        title: Some("some title".to_string()),
        description: None,
        media: Some("ipfs://QmTqZsmhZLLbi8vxZwm21wjKRFRBUQFzMFtTiyh3DJ2CCz".to_string()),
        media_hash: None,
        copies: Some(7),
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    };
    let res = call!(
        user1,
        nft.nft_create_series(token_metadata.clone(), None),
        deposit = to_yocto("0.005")
    );
    if let ExecutionStatus::Failure(execution_error) =
        &res.promise_errors().remove(0).unwrap().outcome().status
    {
        assert!(execution_error
            .to_string()
            .contains("Access to mint is denied for this contract"));
    } else {
        panic!("Expected failure");
    }
    call!(root, nft.grant(user1.account_id()));

    // Title of the series should be specified
    let res = call!(
        user1,
        nft.nft_create_series(
            TokenMetadata {
                title: None,
                ..token_metadata.clone()
            },
            None
        ),
        deposit = to_yocto("0.005")
    );
    if let ExecutionStatus::Failure(execution_error) =
        &res.promise_errors().remove(0).unwrap().outcome().status
    {
        assert!(execution_error
            .to_string()
            .contains("title is missing from token metadata"));
    } else {
        panic!("Expected failure");
    }

    // Royalty can't exceed 50%
    let royalty = HashMap::from([(user1.account_id(), 500), (user2.account_id(), 5000)]);
    let res = call!(
        user1,
        nft.nft_create_series(token_metadata, Some(royalty)),
        deposit = to_yocto("0.005")
    );
    if let ExecutionStatus::Failure(execution_error) =
        &res.promise_errors().remove(0).unwrap().outcome().status
    {
        assert!(execution_error
            .to_string()
            .contains("maximum royalty cap exceeded"));
    } else {
        panic!("Expected failure");
    }
}

#[test]
fn nft_create_series_positive() {
    let (root, _, nft) = init();
    let user1 = root.create_user("user1".parse().unwrap(), to_yocto("1000"));
    let user2 = root.create_user("user2".parse().unwrap(), to_yocto("1000"));
    let royalty = HashMap::from([(user1.account_id(), 500), (user2.account_id(), 2000)]);

    let token_metadata = TokenMetadata {
        title: Some("some title".to_string()),
        description: None,
        media: Some("ipfs://QmTqZsmhZLLbi8vxZwm21wjKRFRBUQFzMFtTiyh3DJ2CCz".to_string()),
        media_hash: None,
        copies: Some(7),
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    };
    call!(
        user1,
        nft.nft_create_series(token_metadata.clone(), None),
        deposit = to_yocto("0.005")
    )
    .assert_success();
    call!(root, nft.set_private_minting(true));
    // with private minting
    call!(root, nft.grant(user2.account_id()));
    let series_id: String = call!(
        user2,
        nft.nft_create_series(token_metadata.clone(), Some(royalty.clone())),
        deposit = to_yocto("1")
    )
    .unwrap_json();
    assert!(user2.account().unwrap().amount > to_yocto("999")); // make sure that deposit is refunded
    let series_json: TokenSeriesJson = view!(nft.nft_get_series(series_id)).unwrap_json();
    //assert_eq!(series_json.royalty, royalty);
    assert_eq!(
        series_json,
        TokenSeriesJson {
            metadata: token_metadata,
            owner_id: user2.account_id(),
            royalty,
        }
    )
}

#[test]
fn nft_mint_negative() {
    let (root, _, nft) = init();
    let user1 = root.create_user("user1".parse().unwrap(), to_yocto("1000"));
    let user2 = root.create_user("user2".parse().unwrap(), to_yocto("1000"));
    let token_metadata = TokenMetadata {
        title: Some("some title".to_string()),
        description: None,
        media: Some("ipfs://QmTqZsmhZLLbi8vxZwm21wjKRFRBUQFzMFtTiyh3DJ2CCz".to_string()),
        media_hash: None,
        copies: Some(1),
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    };
    let series_id: String = call!(
        user1,
        nft.nft_create_series(token_metadata, None),
        deposit = to_yocto("0.005")
    )
    .unwrap_json();
    // Only authorized account can mint
    call!(root, nft.set_private_minting(true));
    let res = call!(
        user1,
        nft.nft_mint(series_id.clone(), user1.account_id(), None),
        deposit = to_yocto("2")
    );
    if let ExecutionStatus::Failure(execution_error) =
        &res.promise_errors().remove(0).unwrap().outcome().status
    {
        assert!(execution_error
            .to_string()
            .contains("Access to mint is denied for this contract"));
    } else {
        panic!("Expected failure");
    }
    call!(root, nft.set_private_minting(false));

    // wrong series_id
    let res = call!(
        user1,
        nft.nft_mint("200".to_string(), user1.account_id(), None),
        deposit = to_yocto("2")
    );
    if let ExecutionStatus::Failure(execution_error) =
        &res.promise_errors().remove(0).unwrap().outcome().status
    {
        assert!(execution_error
            .to_string()
            .contains("Token series does not exist"));
    } else {
        panic!("Expected failure");
    }

    // only owner allowed to mint this series
    let res = call!(
        user2,
        nft.nft_mint(series_id.clone(), user1.account_id(), None),
        deposit = to_yocto("2")
    );
    if let ExecutionStatus::Failure(execution_error) =
        &res.promise_errors().remove(0).unwrap().outcome().status
    {
        assert!(execution_error.to_string().contains("permission denied"));
    } else {
        panic!("Expected failure");
    }

    // Try to exceed max tokens
    call!(
        user1,
        nft.nft_mint(series_id.clone(), user1.account_id(), None),
        deposit = to_yocto("2")
    )
    .assert_success();
    let res = call!(
        user1,
        nft.nft_mint(series_id, user1.account_id(), None),
        deposit = to_yocto("2")
    );
    if let ExecutionStatus::Failure(execution_error) =
        &res.promise_errors().remove(0).unwrap().outcome().status
    {
        assert!(execution_error.to_string().contains("Max token minted"));
    } else {
        panic!("Expected failure");
    }
}

#[test]
fn nft_mint_positive() {
    let (root, _, nft) = init();
    let user1 = root.create_user("user1".parse().unwrap(), to_yocto("1000"));
    let user2 = root.create_user("user2".parse().unwrap(), to_yocto("1000"));
    let mut token_metadata = TokenMetadata {
        title: Some("some title".to_string()),
        description: None,
        media: Some("ipfs://QmTqZsmhZLLbi8vxZwm21wjKRFRBUQFzMFtTiyh3DJ2CCz".to_string()),
        media_hash: None,
        copies: Some(1),
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    };
    let series_id: String = call!(
        user1,
        nft.nft_create_series(token_metadata.clone(), None),
        deposit = to_yocto("0.005")
    )
    .unwrap_json();
    let token_id: String = call!(
        user1,
        nft.nft_mint(series_id, user2.account_id(), None),
        deposit = to_yocto("2")
    )
    .unwrap_json();
    assert!(user1.account().unwrap().amount > to_yocto("999")); // refunded deposit (1000-2 should be 998, but we have 999+)
    let minted_token: Token = view!(nft.nft_token(token_id.clone())).unwrap_json();
    let minted_token_metadata = minted_token.metadata.as_ref().unwrap();
    token_metadata.issued_at = minted_token_metadata.issued_at.clone();
    token_metadata.copies = None;
    assert_eq!(
        minted_token,
        Token {
            token_id,
            owner_id: user2.account_id,
            metadata: Some(token_metadata),
            approved_account_ids: Some(Default::default())
        }
    );
}

'''
'''--- market/tests/testing.rs ---
#![allow(clippy::ref_in_deref)]
use near_contract_standards::non_fungible_token::metadata::TokenMetadata;
use near_sdk::serde_json::json;
use near_sdk_sim::{call, to_yocto, transaction::ExecutionStatus, view};
use nft_bid_market::{AuctionJson, EXTENSION_DURATION};
use std::collections::HashMap;

mod utils;
use utils::{init, prod_block};

#[test]
fn test_fees_transfers() {
    let (root, market, nft) = init();
    let origin1 = root.create_user("origin1".parse().unwrap(), to_yocto("1000"));
    let origin2 = root.create_user("origin2".parse().unwrap(), to_yocto("1000"));
    let origin3 = root.create_user("origin3".parse().unwrap(), to_yocto("1000"));
    let user1 = root.create_user("user1".parse().unwrap(), to_yocto("1000"));
    let user2 = root.create_user("user2".parse().unwrap(), to_yocto("1000"));
    let user3 = root.create_user("user3".parse().unwrap(), to_yocto("1000"));

    let token_metadata = TokenMetadata {
        title: Some("some title".to_string()),
        description: None,
        media: Some("ipfs://QmTqZsmhZLLbi8vxZwm21wjKRFRBUQFzMFtTiyh3DJ2CCz".to_string()),
        media_hash: None,
        copies: Some(7),
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    };
    let royalty = HashMap::from([(user1.account_id(), 500)]);
    call!(
        user1,
        nft.nft_create_series(token_metadata, Some(royalty)),
        deposit = to_yocto("0.005")
    )
    .assert_success();

    for _ in 0..5 {
        call!(
            user1,
            nft.nft_mint("1".to_string(), user1.account_id(), None),
            deposit = to_yocto("0.01")
        )
        .assert_success();
    }

    call!(
        user1,
        market.storage_deposit(None),
        deposit = to_yocto("0.1")
    )
    .assert_success();
    let origins = HashMap::from([(origin1.account_id(), 100u32)]);
    for i in 1..3 {
        let token_id = format!("1:{}", i);
        call!(
            user1,
            nft.nft_approve(
                token_id,
                market.account_id(),
                Some(
                    json!({
                        "Auction": {
                            "token_type": "near",
                            "minimal_step": "100",
                            "start_price": "10000",
                            "start": null,
                            "duration": "900000000000",
                            "buy_out_price": "10000000000",
                            "origins": origins,
                        }
                    })
                    .to_string()
                )
            ),
            deposit = to_yocto("1")
        )
        .assert_success();
    }

    call!(user1, market.cancel_auction(0.into()), deposit = 1).assert_success();
    let time_during_bid = root.borrow_runtime().current_block().block_timestamp
        + root.borrow_runtime().genesis.block_prod_time; // +1 block
    call!(
        user2,
        market.auction_add_bid(1.into(), Some("near".to_string()), None),
        deposit = 10400
    )
    .assert_success();
    let res = call!(user1, market.finish_auction(1.into()));
    if let ExecutionStatus::Failure(execution_error) =
        &res.promise_errors().remove(0).unwrap().outcome().status
    {
        assert!(execution_error
            .to_string()
            .contains("Auction can be finalized only after the end time"));
    } else {
        panic!("Expected failure");
    }
    let auction_json: AuctionJson = view!(market.get_auction(1.into())).unwrap_json();
    assert!(auction_json.end.0 - time_during_bid == EXTENSION_DURATION);
    let blocks_needed = (auction_json.end.0
        - root.borrow_runtime().current_block().block_timestamp)
        / root.borrow_runtime().genesis.block_prod_time;
    let mut i = 0;
    while root.borrow_runtime().current_block().block_timestamp < auction_json.end.0 {
        i += 1;
        prod_block(&root);
    }
    call!(user1, market.finish_auction(1.into())).assert_success();
    assert!(i == blocks_needed);
}

'''
'''--- market/tests/utils.rs ---
use near_sdk_sim::{UserAccount, ContractAccount, runtime::GenesisConfig, init_simulator, deploy, to_yocto};
use nft_contract::{NftContract, common::TokenMetadata};
use nft_bid_market::MarketContract;
near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    MARKET_WASM_BYTES => "../res/nft_bid_market.wasm",
    NFT_WASM_BYTES => "../res/nft_contract.wasm",
}

const NFT_ID: &str = "nft";
const MARKET_ID: &str = "market";

pub fn init() -> (
    UserAccount,
    ContractAccount<MarketContract>,
    ContractAccount<NftContract>,
) {
    let g_config = GenesisConfig {
        block_prod_time: 1_000_000_000 * 60, // 1 mins/block
        ..Default::default()
    };
    let root = init_simulator(Some(g_config));

    let market = deploy!(
        contract: MarketContract,
        contract_id: MARKET_ID,
        bytes: &MARKET_WASM_BYTES,
        signer_account: root,
        init_method: new(vec![NFT_ID.parse().unwrap()], root.account_id())
    );

    let nft = deploy!(
        contract: NftContract,
        contract_id: NFT_ID,
        bytes: &NFT_WASM_BYTES,
        signer_account: root,
        deposit: to_yocto("200"),
        init_method: new_default_meta(root.account_id())
    );

    (root, market, nft)
}

pub fn prod_block(root: &UserAccount) {
    let mut runtime = root.borrow_runtime_mut();
    runtime.produce_block().unwrap();
}
'''
'''--- nft/Cargo.toml ---
[package]
name = "nft-contract"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.5"
near-contract-standards = "4.0.0-pre.5"
serde_with = "1"
serde = "1"
'''
'''--- nft/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp ../target/wasm32-unknown-unknown/release/nft_contract.wasm ../res/

'''
'''--- nft/src/common.rs ---
pub use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{LazyOption, LookupSet, LookupMap, UnorderedMap, UnorderedSet},
    env,
    json_types::{U128, U64},
    near_bindgen, require,
    serde::{Deserialize, Serialize},
    AccountId, Balance, BorshStorageKey, PanicOnDefault,
};

pub use near_contract_standards::non_fungible_token::{
    metadata::{NFTContractMetadata, TokenMetadata, NFT_METADATA_SPEC},
    refund_deposit, NonFungibleToken, Token, TokenId,
};
'''
'''--- nft/src/event.rs ---
use near_sdk::AccountId;
use serde::{Deserialize, Serialize};
use serde_with::skip_serializing_none;

#[derive(Serialize, Debug)]
#[serde(tag = "standard")]
#[serde(rename_all = "snake_case")]
pub enum NearEvent<'a> {
    #[serde(borrow)]
    Nep171(Nep171Event<'a>),
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Nep171Event<'a> {
    pub version: &'static str,
    #[serde(flatten)]
    #[serde(borrow)]
    pub event_kind: Nep171EventKind<'a>,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[allow(clippy::enum_variant_names)]
pub enum Nep171EventKind<'a> {
    #[serde(borrow)]
    NftMint(Vec<NftMintData<'a>>),
    #[serde(borrow)]
    NftTransfer(Vec<NftTransferData<'a>>),
    #[serde(borrow)]
    NftBurn(Vec<NftBurnData<'a>>),
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize, Debug)]
pub struct NftMintData<'a> {
    #[serde(borrow)]
    pub owner_id: &'a str,
    #[serde(borrow)]
    pub token_ids: Vec<&'a str>,
    #[serde(borrow)]
    pub memo: Option<&'a str>,
}

impl<'a> NftMintData<'a> {
    pub fn new(
        owner_id: &'a AccountId,
        token_ids: Vec<&'a str>,
        memo: Option<&'a str>,
    ) -> NftMintData<'a> {
        Self { owner_id: owner_id.as_str(), token_ids, memo }
    }
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize, Debug)]
pub struct NftTransferData<'a> {
    #[serde(borrow)]
    pub old_owner_id: &'a str,
    #[serde(borrow)]
    pub new_owner_id: &'a str,
    #[serde(borrow)]
    pub token_ids: Vec<&'a str>,
    #[serde(borrow)]
    pub authorized_id: Option<&'a str>,
    #[serde(borrow)]
    pub memo: Option<&'a str>,
}

impl<'a> NftTransferData<'a> {
    pub fn new(
        old_owner_id: &'a AccountId,
        new_owner_id: &'a AccountId,
        token_ids: Vec<&'a str>,
        authorized_id: Option<&'a AccountId>,
        memo: Option<&'a str>,
    ) -> NftTransferData<'a> {
        Self {
            authorized_id: authorized_id.map(|id| id.as_str()),
            old_owner_id: old_owner_id.as_str(),
            new_owner_id: new_owner_id.as_str(),
            token_ids,
            memo,
        }
    }
}

#[skip_serializing_none]
#[derive(Serialize, Deserialize, Debug)]
pub struct NftBurnData<'a> {
    #[serde(borrow)]
    pub owner_id: &'a str,
    #[serde(borrow)]
    pub token_ids: Vec<&'a str>,
    #[serde(borrow)]
    pub authorized_id: Option<&'a str>,
    #[serde(borrow)]
    pub memo: Option<&'a str>,
}

impl<'a> NftBurnData<'a> {
    pub fn new(
        owner_id: &'a AccountId,
        token_ids: Vec<&'a str>,
        authorized_id: Option<&'a AccountId>,
        memo: Option<&'a str>,
    ) -> NftBurnData<'a> {
        Self {
            owner_id: owner_id.as_str(),
            token_ids,
            authorized_id: authorized_id.map(|id| id.as_str()),
            memo,
        }
    }
}

impl<'a> NearEvent<'a> {
    pub fn new_171(version: &'static str, event_kind: Nep171EventKind<'a>) -> Self {
        NearEvent::Nep171(Nep171Event { version, event_kind })
    }

    pub fn new_171_v1(event_kind: Nep171EventKind<'a>) -> Self {
        NearEvent::new_171("1.0.0", event_kind)
    }

    #[must_use = "don't forget to .emit() the event"]
    pub fn nft_burn(data: Vec<NftBurnData<'a>>) -> Self {
        NearEvent::new_171_v1(Nep171EventKind::NftBurn(data))
    }

    #[must_use = "don't forget to .emit() the event"]
    pub fn nft_transfer(data: Vec<NftTransferData<'a>>) -> Self {
        NearEvent::new_171_v1(Nep171EventKind::NftTransfer(data))
    }

    #[must_use = "don't forget to .emit() the event"]
    pub fn nft_mint(data: Vec<NftMintData<'a>>) -> Self {
        NearEvent::new_171_v1(Nep171EventKind::NftMint(data))
    }

    pub(crate) fn to_json_string(&self) -> String {
        near_sdk::serde_json::to_string(self).unwrap()
    }

    pub fn to_json_event_string(&self) -> String {
        format!("EVENT_JSON:{}", self.to_json_string())
    }

    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub fn emit(self) {
        near_sdk::env::log_str(&self.to_json_event_string());
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::AccountId;

    fn bob() -> AccountId {
        AccountId::new_unchecked("bob".to_string())
    }

    fn alice() -> AccountId {
        AccountId::new_unchecked("alice".to_string())
    }

    #[test]
    fn nft_mint() {
        let owner_id = &bob();
        let token_ids = vec!["0", "1"];
        let mint_log = NftMintData::new(owner_id, token_ids, None);
        let event_log = NearEvent::nft_mint(vec![mint_log]);
        assert_eq!(
            near_sdk::serde_json::to_string(&event_log).unwrap(),
            r#"{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"bob","token_ids":["0","1"]}]}"#
        );
    }

    #[test]
    fn nft_mints() {
        let owner_id = &bob();
        let token_ids = vec!["0", "1"];
        let mint_log = NftMintData::new(owner_id, token_ids, None);
        let alice = AccountId::new_unchecked("alice".to_string());
        let event_log = NearEvent::nft_mint(vec![
            mint_log,
            NftMintData::new(&alice, vec!["2", "3"], Some("has memo")),
        ]);
        assert_eq!(
            event_log.to_json_string(),
            r#"{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"bob","token_ids":["0","1"]},{"owner_id":"alice","token_ids":["2","3"],"memo":"has memo"}]}"#
        );
    }

    #[test]
    fn nft_burn() {
        let owner_id = &bob();
        let token_ids = vec!["0", "1"];
        let burn_data = NftBurnData::new(owner_id, token_ids, None, None);
        let log = NearEvent::nft_burn(vec![burn_data]).to_json_string();
        assert_eq!(
            log,
            r#"{"standard":"nep171","version":"1.0.0","event":"nft_burn","data":[{"owner_id":"bob","token_ids":["0","1"]}]}"#
        );
    }

    #[test]
    fn nft_burns() {
        let owner_id = &bob();
        let token_ids = vec!["0", "1"];
        let log = NearEvent::nft_burn(vec![
            NftBurnData::new(&alice(), vec!["2", "3"], Some(&bob()), Some(&"has memo".to_string())),
            NftBurnData::new(owner_id, token_ids, None, None),
        ])
        .to_json_string();
        assert_eq!(
            log,
            r#"{"standard":"nep171","version":"1.0.0","event":"nft_burn","data":[{"owner_id":"alice","token_ids":["2","3"],"authorized_id":"bob","memo":"has memo"},{"owner_id":"bob","token_ids":["0","1"]}]}"#
        );
    }

    #[test]
    fn nft_transfer() {
        let old_owner_id = &bob();
        let new_owner_id = &alice();
        let token_ids = vec!["0", "1"];
        let log = NearEvent::nft_transfer(vec![NftTransferData::new(
            old_owner_id,
            new_owner_id,
            token_ids,
            None,
            None,
        )])
        .to_json_string();
        assert_eq!(
            log,
            r#"{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"old_owner_id":"bob","new_owner_id":"alice","token_ids":["0","1"]}]}"#
        );
    }

    #[test]
    fn nft_transfers() {
        let old_owner_id = &bob();
        let new_owner_id = &alice();
        let token_ids = vec!["0", "1"];
        let log = NearEvent::nft_transfer(vec![
            NftTransferData::new(
                new_owner_id,
                old_owner_id,
                vec!["2", "3"],
                Some(&bob()),
                Some("has memo"),
            ),
            NftTransferData::new(old_owner_id, new_owner_id, token_ids, None, None),
        ])
        .to_json_string();
        assert_eq!(
            log,
            r#"{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"old_owner_id":"alice","new_owner_id":"bob","token_ids":["2","3"],"authorized_id":"bob","memo":"has memo"},{"old_owner_id":"bob","new_owner_id":"alice","token_ids":["0","1"]}]}"#
        );
    }
}
'''
'''--- nft/src/lib.rs ---
mod nft_core;
mod token;

pub mod common;
pub mod event;
mod permissions;
mod series_views;
use crate::permissions::ContractAutorize;
use common::*;

mod token_series;
use event::NearEvent;
use near_contract_standards::non_fungible_token::refund_deposit_to_account;
use near_sdk::{ext_contract, Promise};
use permissions::PrivateMint;
use token_series::{TokenSeries, TokenSeriesId, TokenSeriesSale, TOKEN_DELIMETER};

mod payouts;
use crate::{event::NftMintData, payouts::MAXIMUM_ROYALTY};

use std::collections::HashMap;

pub use token_series::TokenSeriesJson;
pub use payouts::Payout;

// Since Near doesn't support multitoken(yet) by default we need to create some workaround
// In this nft implementation every token is part of TokenSeries
// Token series is tokens, that share same metadata.
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Nft {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,

    token_series_by_id: UnorderedMap<TokenSeriesId, TokenSeries>,
    private_mint: PrivateMint,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,

    TokensBySeriesInner { token_series: String },
    TokensPerOwner { account_hash: Vec<u8> },
    Minters,
}

#[near_bindgen]
impl Nft {
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "Example NEAR non-fungible token".to_string(),
                symbol: "EXAMPLE".to_string(),
                icon: None,
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
            Default::default(),
            false,
        )
    }

    #[init]
    pub fn new(
        owner_id: AccountId,
        metadata: NFTContractMetadata,
        private_minters: Vec<AccountId>,
        private_minting_enabled: bool,
    ) -> Self {
        require!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        let mut minters = LookupSet::new(StorageKey::Minters);
        minters.extend(private_minters);
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
            token_series_by_id: UnorderedMap::new(b"s"),
            private_mint: PrivateMint::new(private_minting_enabled, minters),
        }
    }

    // public mint,
    // mints NFT with metadata of token series
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_series_id: TokenSeriesId,
        receiver_id: AccountId,
        refund_id: Option<AccountId>,
    ) -> TokenId {
        self.private_mint
            .panic_if_not_allowed(&env::predecessor_account_id());
        let refund_id = refund_id.unwrap_or_else(env::predecessor_account_id);
        let initial_storage_usage = env::storage_usage();

        let mut token_series = self
            .token_series_by_id
            .get(&token_series_id)
            .expect("Token series does not exist");
        require!(
            env::predecessor_account_id().eq(&token_series.owner_id),
            "permission denied"
        );
        require!(
            token_series.tokens.len() < token_series.metadata.copies.unwrap_or(u64::MAX),
            "Max token minted"
        );
        let token_id = format!(
            "{}{}{}",
            token_series_id,
            TOKEN_DELIMETER,
            token_series.tokens.len() + 1
        );
        let metadata = TokenMetadata {
            title: None,       // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
            description: None, // free-form description
            media: None, // URL to associated media, preferably to decentralized, content-addressed storage
            media_hash: None, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
            copies: None, // number of copies of this set of metadata in existence when token was minted.
            issued_at: Some(env::block_timestamp().to_string()), // ISO 8601 datetime when token was issued or minted
            expires_at: None,     // ISO 8601 datetime when token expires
            starts_at: None,      // ISO 8601 datetime when token starts being valid
            updated_at: None,     // ISO 8601 datetime when token was last updated
            extra: None, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
            reference: None, // URL to an off-chain JSON file with more info.
            reference_hash: None, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
        };

        // implementation from NonFungibleToken::internal_mint_with_refund()
        // Core behavior: every token must have an owner
        self.tokens.owner_by_id.insert(&token_id, &receiver_id);
        // Metadata extension: Save metadata, keep variable around to return later.
        // Note that check above already panicked if metadata extension in use but no metadata
        // provided to call.
        self.tokens
            .token_metadata_by_id
            .as_mut()
            .and_then(|by_id| by_id.insert(&token_id, &metadata));

        // Enumeration extension: Record tokens_per_owner for use with enumeration view methods.
        if let Some(tokens_per_owner) = &mut self.tokens.tokens_per_owner {
            let mut token_ids = tokens_per_owner.get(&receiver_id).unwrap_or_else(|| {
                UnorderedSet::new(StorageKey::TokensPerOwner {
                    account_hash: env::sha256(receiver_id.as_bytes()),
                })
            });
            token_ids.insert(&token_id);
            tokens_per_owner.insert(&receiver_id, &token_ids);
        }
        token_series.tokens.insert(&token_id);
        self.token_series_by_id
            .insert(&token_series_id, &token_series);

        refund_deposit_to_account(env::storage_usage() - initial_storage_usage, refund_id);

        // Event
        let mint_log = NftMintData::new(&receiver_id, vec![&token_id], None);
        NearEvent::nft_mint(vec![mint_log]).emit();

        token_id
    }

    // Create series with given metadata and royalty
    #[payable]
    pub fn nft_create_series(
        &mut self,
        token_metadata: TokenMetadata,
        royalty: Option<HashMap<AccountId, u32>>,
    ) -> TokenSeriesId {
        self.private_mint
            .panic_if_not_allowed(&env::predecessor_account_id());
        let initial_storage_usage = env::storage_usage();
        let owner_id = env::predecessor_account_id();
        let token_series_id = (self.token_series_by_id.len() + 1).to_string();
        require!(
            token_metadata.title.is_some(),
            "title is missing from token metadata"
        );
        let mut total_payouts = 0;
        let royalty_res: HashMap<AccountId, u32> = if let Some(royalty) = royalty {
            total_payouts = royalty.values().sum();
            royalty
        } else {
            HashMap::new()
        };
        require!(
            total_payouts <= MAXIMUM_ROYALTY,
            format!("maximum royalty cap exceeded {}", MAXIMUM_ROYALTY)
        );

        self.token_series_by_id.insert(
            &token_series_id,
            &TokenSeries {
                metadata: token_metadata,
                owner_id,
                tokens: UnorderedSet::new(
                    StorageKey::TokensBySeriesInner {
                        token_series: token_series_id.clone(),
                    }
                    .try_to_vec()
                    .unwrap(),
                ),
                royalty: royalty_res,
            },
        );

        refund_deposit(env::storage_usage() - initial_storage_usage);

        token_series_id
    }

    /* Lazy_mint if needed
       #[payable]
       pub fn nft_series_market_approve(
           &mut self,
           token_series_id: TokenId,
           sale_conditions: token_series::SaleConditions,
           copies: u64,
           approved_market_id: AccountId,
       ) -> Promise {
           let initial_storage_usage = env::storage_usage();
           let mut token_series = self
               .token_series_by_id
               .get(&token_series_id)
               .expect("Series not found");
           require!(
               env::predecessor_account_id().eq(&token_series.owner_id),
               "Not token owner"
           );
           require!(
               token_series.metadata.copies.unwrap_or(u64::MAX) - token_series.tokens.len() >= copies,
               "Too many copies"
           );
           token_series.approved_market_id = Some(approved_market_id.clone());
           self.token_series_by_id
               .insert(&token_series_id, &token_series);
           refund_deposit(env::storage_usage() - initial_storage_usage);
           ext_contract::nft_on_series_approve(
               TokenSeriesSale {
                   sale_conditions,
                   series_id: token_series_id,
                   owner_id: token_series.owner_id,
                   copies,
               },
               approved_market_id,
               0,
               env::prepaid_gas() - GAS_FOR_NFT_APPROVE,
           )
       }
    */
}

near_contract_standards::impl_non_fungible_token_approval!(Nft, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Nft, tokens);

#[ext_contract(ext_contract)]
trait ExtContract {
    fn nft_on_series_approve(&mut self, token_series: TokenSeriesSale);
}

'''
'''--- nft/src/nft_core.rs ---
use crate::*;
use crate::event::NftTransferData;
use near_contract_standards::non_fungible_token::{core::NonFungibleTokenCore, Token};

#[near_bindgen]
impl NonFungibleTokenCore for Nft {
    fn nft_transfer(
        &mut self,
        receiver_id: near_sdk::AccountId,
        token_id: near_contract_standards::non_fungible_token::TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    ) {
        let old_owner_id =
            self.tokens.owner_by_id.get(&token_id).unwrap_or_else(|| env::panic_str("Token not found"));
        let authorized_id = if old_owner_id != env::predecessor_account_id() {
            Some(env::predecessor_account_id())
        } else {
            None
        };
        self.tokens
            .nft_transfer(receiver_id.clone(), token_id.clone(), approval_id, memo.clone());
        NearEvent::nft_transfer(vec![NftTransferData::new(
            &old_owner_id,
            &receiver_id,
            vec![&token_id],
            authorized_id.as_ref(),
            memo.as_deref(),
        )]).emit();
    }

    fn nft_transfer_call(
        &mut self,
        receiver_id: near_sdk::AccountId,
        token_id: near_contract_standards::non_fungible_token::TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> near_sdk::PromiseOrValue<bool> {
        self.tokens
            .nft_transfer_call(receiver_id, token_id, approval_id, memo, msg)
    }

    fn nft_token(
        &self,
        token_id: near_contract_standards::non_fungible_token::TokenId,
    ) -> Option<Token> {
        let owner_id = self.tokens.owner_by_id.get(&token_id)?;
        let mut token_id_iter = token_id.split(TOKEN_DELIMETER);
        let token_series_id = token_id_iter.next().unwrap().parse().unwrap();
        let mut series_metadata = self
            .token_series_by_id
            .get(&token_series_id)
            .unwrap()
            .metadata;
        let token_metadata = self
            .tokens
            .token_metadata_by_id
            .as_ref()
            .unwrap()
            .get(&token_id)
            .unwrap();
        let approved_account_ids = self
            .tokens
            .approvals_by_id
            .as_ref()
            .and_then(|by_id| by_id.get(&token_id).or_else(|| Some(HashMap::new())));
        series_metadata.issued_at = token_metadata.issued_at;
        series_metadata.copies = None;
        Some(Token {
            token_id,
            owner_id,
            metadata: Some(series_metadata),
            approved_account_ids,
        })
    }
}

'''
'''--- nft/src/payouts.rs ---
use std::collections::HashMap;

use near_contract_standards::non_fungible_token::core::NonFungibleTokenCore;
use near_sdk::assert_one_yocto;
use near_sdk::json_types::U128;

use crate::*;

pub const ROYALTY_TOTAL_VALUE: u128 = 10_000;
pub const MAXIMUM_ROYALTY: u32 = 5_000;
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
}

#[derive(Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Fees {
    pub buyer: HashMap<AccountId, u32>,
    pub seller: HashMap<AccountId, u32>,
}

pub trait Payouts {
    /// Given a `token_id` and NEAR-denominated balance, return the `Payout`.
    /// struct for the given token. Panic if the length of the payout exceeds
    /// `max_len_payout.`
    fn nft_payout(&self, token_id: String, balance: U128, max_len_payout: u32) -> Payout;
    /// Given a `token_id` and NEAR-denominated balance, transfer the token
    /// and return the `Payout` struct for the given token. Panic if the
    /// length of the payout exceeds `max_len_payout.`
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: String,
        approval_id: u64,
        memo: Option<String>,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout;
}

#[near_bindgen]
impl Payouts for Nft {
    // Payout mapping for the given token, based on 'balance' and royalty
    fn nft_payout(&self, token_id: String, balance: U128, max_len_payout: u32) -> Payout {
        let token_owner = self.tokens.owner_by_id.get(&token_id).expect("no token id");

        let mut token_id_iter = token_id.split(TOKEN_DELIMETER);
        let token_series_id = token_id_iter.next().unwrap().to_owned();
        let royalty = self
            .token_series_by_id
            .get(&token_series_id)
            .expect("no type")
            .royalty;
        require!(royalty.len() as u32 <= max_len_payout, "Too many recievers");
        let mut total_payout = 0;
        let balance = Balance::from(balance);
        let mut payout: Payout = Payout {
            payout: HashMap::new(),
        };
        for (k, v) in royalty.iter() {
            if *k != token_owner {
                payout
                    .payout
                    .insert(k.clone(), royalty_to_payout(*v, balance));
                total_payout += v;
            }
        }
        require!(
            total_payout <= ROYALTY_TOTAL_VALUE as u32,
            "Royalty total value should be < 10000"
        );
        payout.payout.insert(
            token_owner,
            royalty_to_payout(ROYALTY_TOTAL_VALUE as u32 - total_payout, balance),
        );
        payout
    }

    // nft_transfer with 'balance' for calculation of Payout mapping for the given token
    // extra: lazy minting? for series
    #[payable]
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: String,
        approval_id: u64,
        memo: Option<String>,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout {
        assert_one_yocto();

        let token_owner = self.tokens.owner_by_id.get(&token_id).expect("no token id");

        let mut token_id_iter = token_id.split(TOKEN_DELIMETER);
        let token_series_id = token_id_iter.next().unwrap().to_owned();
        let royalty = self
            .token_series_by_id
            .get(&token_series_id)
            .expect("no type")
            .royalty;
        require!(royalty.len() as u32 <= max_len_payout, "Too many recievers");

        let mut total_payout = 0;
        let mut max_payout = ROYALTY_TOTAL_VALUE as u32;
        let balance = Balance::from(balance);
        let mut initial_price = balance;
        let mut payout: Payout = Payout {
            payout: HashMap::new(),
        };
        if let Some(fees) = memo {
            let Fees { buyer, seller } =
                near_sdk::serde_json::from_str(&fees).expect("invalid FeesArgs");
            let mut buyer_value = 0;
            for v in buyer.values() {
                buyer_value += v;
            }
            max_payout += buyer_value;
            let buyer_fee =
                balance * buyer_value as u128 / (ROYALTY_TOTAL_VALUE + buyer_value as u128);
            initial_price = balance - buyer_fee;

            for (k, v) in buyer.iter() {
                if *k != token_owner {
                    payout
                        .payout
                        .insert(k.clone(), royalty_to_payout(*v, initial_price));
                    total_payout += v;
                }
            }
            for (k, v) in seller.iter() {
                if *k != token_owner {
                    let val = payout.payout.entry(k.clone()).or_insert(U128(0)); // Protocol fee would repeat and origins can repeat
                    (*val).0 += royalty_to_payout(*v, initial_price).0;
                    total_payout += v;
                }
            }
        }
        for (k, v) in royalty.iter() {
            if *k != token_owner {
                let val = payout.payout.entry(k.clone()).or_insert(U128(0));
                (*val).0 += royalty_to_payout(*v, initial_price).0;
                total_payout += v;
            }
        }
        require!(
            total_payout <= max_payout as u32,
            format!("Royalty total value should be < {}", max_payout)
        );
        payout.payout.insert(
            token_owner,
            royalty_to_payout(max_payout - total_payout, initial_price),
        );
        require!(
            payout.payout.len() as u32 <= max_len_payout,
            "Too many recievers"
        );
        self.nft_transfer(receiver_id, token_id, Some(approval_id), None);
        payout
    }
}

fn royalty_to_payout(a: u32, b: Balance) -> U128 {
    U128(a as u128 * b / ROYALTY_TOTAL_VALUE)
}

'''
'''--- nft/src/permissions.rs ---
use crate::*;
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env, AccountId,
};

pub trait ContractAutorize {
    fn is_allowed(&self, account_id: &AccountId) -> bool;
    fn panic_if_not_allowed(&self, account_id: &AccountId);
    fn grant(&mut self, account_id: AccountId) -> bool;
    fn deny(&mut self, account_id: AccountId) -> bool;
    fn set_authorization(&mut self, enabled: bool);
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct PrivateMint {
    enabled: bool,
    private_minters: LookupSet<AccountId>,
}

impl PrivateMint {
    pub fn new(enabled: bool, private_minters: LookupSet<AccountId>) -> Self {
        Self {
            enabled,
            private_minters,
        }
    }
}

impl ContractAutorize for PrivateMint {
    fn is_allowed(&self, account_id: &AccountId) -> bool {
        !self.enabled || self.private_minters.contains(account_id)
    }

    fn panic_if_not_allowed(&self, account_id: &AccountId) {
        if !self.is_allowed(account_id) {
            env::panic_str("Access to mint is denied for this contract");
        }
    }

    fn grant(&mut self, account_id: AccountId) -> bool {
        self.private_minters.insert(&account_id)
    }

    fn deny(&mut self, account_id: AccountId) -> bool {
        self.private_minters.remove(&account_id)
    }

    fn set_authorization(&mut self, enabled: bool) {
        self.enabled = enabled;
    }
}

#[near_bindgen]
impl Nft {
    pub fn is_allowed(&self, account_id: AccountId) -> bool {
        self.private_mint.is_allowed(&account_id)
    }

    pub fn grant(&mut self, account_id: AccountId) -> bool {
        require!(
            env::predecessor_account_id() == self.tokens.owner_id,
            "only owner can grant"
        );
        self.private_mint.grant(account_id)
    }

    pub fn deny(&mut self, account_id: AccountId) -> bool {
        require!(
            env::predecessor_account_id() == self.tokens.owner_id,
            "only owner can deny"
        );
        self.private_mint.deny(account_id)
    }

    pub fn set_private_minting(&mut self, enabled: bool) {
        require!(
            env::predecessor_account_id() == self.tokens.owner_id,
            "only owner can enable/disable private minting"
        );
        self.private_mint.set_authorization(enabled);
    }
}

'''
'''--- nft/src/series_views.rs ---
use crate::token_series::TokenSeriesJson;
use crate::*;

#[near_bindgen]
impl Nft {
    pub fn nft_get_series(&self, token_series_id: TokenSeriesId) -> TokenSeriesJson {
        let token_series = self.token_series_by_id.get(&token_series_id).expect("no series");
        TokenSeriesJson {
            metadata: token_series.metadata,
            owner_id: token_series.owner_id,
            royalty: token_series.royalty,
        }
    }

    pub fn nft_series(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<TokenSeriesJson> {
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        assert!(
            (self.token_series_by_id.len() as u128) > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        assert_ne!(limit, 0, "Cannot provide limit of 0.");

        self.token_series_by_id
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|(_token_series_id, token_series)| TokenSeriesJson {
                // token_series_id, do we need it?
                metadata: token_series.metadata,
                owner_id: token_series.owner_id,
                royalty: token_series.royalty,
            })
            .collect()
    }

    pub fn nft_supply_for_series(&self, token_series_id: TokenSeriesId) -> U128 {
        U128::from(
            self.token_series_by_id
                .get(&token_series_id)
                .unwrap_or_else(|| env::panic_str("Could not find token series"))
                .tokens
                .len() as u128,
        )
    }
}

'''
'''--- nft/src/token.rs ---

use near_contract_standards::non_fungible_token::metadata::TokenMetadata;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::AccountId;
use std::collections::HashMap;

/// Note that token IDs for NFTs are strings on NEAR. It's still fine to use autoincrementing numbers as unique IDs if desired, but they should be stringified. This is to make IDs more future-proof as chain-agnostic conventions and standards arise, and allows for more flexibility with considerations like bridging NFTs across chains, etc.
pub type TokenId = String;

/// In this implementation, the Token struct takes two extensions standards (metadata and approval) as optional fields, as they are frequently used in modern NFTs.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct Token {
    pub token_id: TokenId,
    pub owner_id: AccountId,
    pub metadata: Option<TokenMetadata>,
    pub approved_account_ids: Option<HashMap<AccountId, u64>>,
}
'''
'''--- nft/src/token_series.rs ---
use near_contract_standards::non_fungible_token::metadata::TokenMetadata;

use crate::common::*;

use std::collections::HashMap;

use crate::token::TokenId;

pub type TokenSeriesId = String;
pub const TOKEN_DELIMETER: char = ':';

// note, keep it all pub for now, but later switch to all private fields.

#[derive(BorshDeserialize, BorshSerialize)]
pub struct TokenSeries {
    pub metadata: TokenMetadata,
    pub owner_id: AccountId,
    pub tokens: UnorderedSet<TokenId>,
    pub royalty: HashMap<AccountId, u32>,
}

#[derive(Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub struct TokenSeriesJson {
    pub metadata: TokenMetadata,
    pub owner_id: AccountId,
    pub royalty: HashMap<AccountId, u32>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SeriesMintArgs {
    pub token_series_id: TokenSeriesId,
    pub receiver_id: AccountId,
}

pub type SaleConditions = HashMap<AccountId, U128>;

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenSeriesSale {
    pub sale_conditions: SaleConditions,
    pub series_id: TokenSeriesId,
    pub owner_id: AccountId,
    pub copies: u64,
}

'''
'''--- nft/test.sh ---
#!/bin/bash
set -e

cargo test -- --nocapture

'''
'''--- quick-reference.md ---
# Setup

## Installing the Rust toolchain

Install Rustup, configure your current shell and add `wasm` target to your toolchain by running:
```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env
rustup target add wasm32-unknown-unknown
```

## Installing the `near-cli`

Make sure you have the latest version of `npm` and `NodeJS` installed.

Install near-cli globally by running:
```bash
npm install -g near-cli
```

# NFT bid market

NFT bid market consists of two contracts: _NFT_ and _Market_.

_NFT contract_ allows to create and manage a token or token series. 
It supports Metadata, Approval Management and Royalties [standards](https://nomicon.io/Standards/NonFungibleToken/README.html).

_Market contract_ handles sales, bids and auctions.

To build both contracts and deploy it on dev account:
```bash
sh deploy-testnet.sh
source .env
```

Now we have `CONTRACT_PARENT` and three subaccounts: `MARKET_CONTRACT_ID`, `NFT_CONTRACT_ID` and `ALICE` ready to go.

Initialize contracts:
```bash
near call $NFT_CONTRACT_ID new_default_meta '{"owner_id": "'$CONTRACT_PARENT'"}' --accountId $NFT_CONTRACT_ID
near call $MARKET_CONTRACT_ID new '{"nft_ids": ["'$NFT_CONTRACT_ID'"], "owner_id": "'$CONTRACT_PARENT'"}' --accountId $MARKET_CONTRACT_ID
```

## NFT contract

_NFT contract_ supports [standards](https://nomicon.io/Standards/NonFungibleToken/README.html) for Metadata, Approval Management and Royalties. It also manages private minting.

Suppose `CONTRACT_PARENT` wants to sell a series of NFTs.
The first step is to create the series and mint several NFTs:
```bash
near call $NFT_CONTRACT_ID nft_create_series '{"token_metadata": {"title": "some title", "media": "ipfs://QmTqZsmhZLLbi8vxZwm21wjKRFRBUQFzMFtTiyh3DJ2CCz", "copies": 10}, "royalty": {"'$CONTRACT_PARENT'": 500}}' --accountId $CONTRACT_PARENT --deposit 0.005

near call $NFT_CONTRACT_ID nft_mint '{"token_series_id": "1", "receiver_id": "'$CONTRACT_PARENT'"}' --accountId $CONTRACT_PARENT --deposit 0.01
near call $NFT_CONTRACT_ID nft_mint '{"token_series_id": "1", "receiver_id": "'$CONTRACT_PARENT'"}' --accountId $CONTRACT_PARENT --deposit 0.01
near call $NFT_CONTRACT_ID nft_mint '{"token_series_id": "1", "receiver_id": "'$CONTRACT_PARENT'"}' --accountId $CONTRACT_PARENT --deposit 0.01
near call $NFT_CONTRACT_ID nft_mint '{"token_series_id": "1", "receiver_id": "'$CONTRACT_PARENT'"}' --accountId $CONTRACT_PARENT --deposit 0.01
near call $NFT_CONTRACT_ID nft_mint '{"token_series_id": "1", "receiver_id": "'$CONTRACT_PARENT'"}' --accountId $CONTRACT_PARENT --deposit 0.01
near call $NFT_CONTRACT_ID nft_mint '{"token_series_id": "1", "receiver_id": "'$CONTRACT_PARENT'"}' --accountId $CONTRACT_PARENT --deposit 0.01
near call $NFT_CONTRACT_ID nft_mint '{"token_series_id": "1", "receiver_id": "'$CONTRACT_PARENT'"}' --accountId $CONTRACT_PARENT --deposit 0.01
near call $NFT_CONTRACT_ID nft_mint '{"token_series_id": "1", "receiver_id": "'$CONTRACT_PARENT'"}' --accountId $CONTRACT_PARENT --deposit 0.01
```
Now he has eight NFTs.
<!--
Instead of minting NFTs by himself, `CONTRACT_PARENT` can cover the storage for NFTs and give the market an approval to mint tokens.
After this `MARKET_CONTRACT_ID` will be able to mint a new NFT.
```bash
near call $MARKET_CONTRACT_ID storage_deposit --accountId $CONTRACT_PARENT --deposit 0.01

near call $NFT_CONTRACT_ID nft_series_market_approve '{"token_series_id": "1", "sale_conditions": {"near": "1200"}, "copies": 1, "approved_market_id": "'$MARKET_CONTRACT_ID'"}' --accountId $CONTRACT_PARENT --deposit 1

near call $NFT_CONTRACT_ID nft_mint '{"token_series_id": "1", "receiver_id": "'$CONTRACT_PARENT'"}' --accountId $MARKET_CONTRACT_ID --deposit 1

near view $NFT_CONTRACT_ID nft_token '{"token_id": "1:9"}'
```
-->
### List of view methods for nft token series

The contract supports methods for Metadata, Approval Management and Royalties according to the [standards](https://nomicon.io/Standards/NonFungibleToken/README.html). Below we list only additional methods.

To get metadata, owner_id and royalty of the series:
```bash
near view $NFT_CONTRACT_ID nft_get_series '{"token_series_id": "1"}'
```

To get the number of NFTs which have alredy been minted from the series:
```bash
near view $NFT_CONTRACT_ID nft_supply_for_series '{"token_series_id": "1"}'
```

To get a list of all series (with pagination or without it):
```bash
near view $NFT_CONTRACT_ID nft_series '{"from_index": "0", "limit": 10}'
near view $NFT_CONTRACT_ID nft_series
```

## Market contract

Using _Market contract_ a user can put his NFT on a sale or an auction.
He specifies the conditions on which he wants to sell NFT, such as FT type and price, start and end (or duration for auction), origins.
Other users create bids, offering to buy (or buying) the NFT. Bids for sales can have start/end time.

### Workflow for creating and using sales

Before creating a sale the user needs to cover the storage (0.01 per one sale):
```bash
near call $MARKET_CONTRACT_ID storage_deposit --accountId $CONTRACT_PARENT --deposit 0.1
```

`CONTRACT_PARENT` puts three NFTs on sale using [approval management](https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement.html):
```bash
near call $NFT_CONTRACT_ID nft_approve '{"token_id": "1:1", "account_id": "'$MARKET_CONTRACT_ID'", 
"msg": "{\"Sale\": {\"sale_conditions\": {\"near\": \"10000\"}, \"token_type\": \"1\", \"start\": null, \"end\": null, \"origins\": {\"'$NFT_CONTRACT_ID'\": 100}} }"}' --accountId $CONTRACT_PARENT --deposit 1
near call $NFT_CONTRACT_ID nft_approve '{"token_id": "1:2", "account_id": "'$MARKET_CONTRACT_ID'", 
"msg": "{\"Sale\": {\"sale_conditions\": {\"near\": \"10000\"}, \"token_type\": \"1\", \"start\": null, \"end\": null, \"origins\": null} }"}' --accountId $CONTRACT_PARENT --deposit 1
near call $NFT_CONTRACT_ID nft_approve '{"token_id": "1:3", "account_id": "'$MARKET_CONTRACT_ID'", 
"msg": "{\"Sale\": {\"sale_conditions\": {\"near\": \"10000\"}, \"token_type\": \"1\", \"start\": null, \"end\": null, \"origins\": null} }"}' --accountId $CONTRACT_PARENT --deposit 1
near call $NFT_CONTRACT_ID nft_approve '{"token_id": "1:4", "account_id": "'$MARKET_CONTRACT_ID'", 
"msg": "{\"Sale\": {\"sale_conditions\": {\"near\": \"10000\"}, \"token_type\": \"1\", \"start\": null, \"end\": null, \"origins\": null} }"}' --accountId $CONTRACT_PARENT --deposit 1
near call $NFT_CONTRACT_ID nft_approve '{"token_id": "1:5", "account_id": "'$MARKET_CONTRACT_ID'", 
"msg": "{\"Sale\": {\"sale_conditions\": {\"near\": \"10000\"}, \"token_type\": \"1\", \"start\": null, \"end\": \"3153600000000000000\", \"origins\": null} }"}' --accountId $CONTRACT_PARENT --deposit 1

near view $MARKET_CONTRACT_ID get_sales
```

`CONTRACT_PARENT` could have set the specific start time, since he hadn't done it, the auction started as soon as the command was complete.
Only the last sale has end time.
Only the first sale has origin fee. It will be paid by `CONTRACT_PARENT` to `NFT_CONTRACT_ID` after the NFT is sold. The number `100` in the method corresponds to 1% origin fee.
`CONTRACT_PARENT` specified the price to be `10000` yoctoNEAR for each token. It doesn't include protocol and origin fees. To see the full price you can call `price_with_fees`:
```bash
near view $MARKET_CONTRACT_ID price_with_fees '{"price": "10000", "origins": null}'
```
Here `price` is the amount you want to pay and `origins` you want to add to your bid.

Seller can withdraw the unused storage deposit:
```bash
near call $MARKET_CONTRACT_ID storage_withdraw --accountId $CONTRACT_PARENT --depositYocto 1
```

Any other account (in our case it is `ALICE`) can buy or offer to buy any of these NFTs. 
The difference is in the deposit which she attaches to `offer`. 
If `ALICE` calls `offer` to buy the first NFT and the attached deposit is equal to the price (`10300` including protocol fee), she automatically buys it.
If `ALICE` calls `offer` on the second NFT, but attaches less deposit than the price, she will only offer to buy the token.
`ALICE` gets the second NFT only after `CONTRACT_PARENT` accepts the offer using `accept_offer`.
```bash
near call $MARKET_CONTRACT_ID offer '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:1", "ft_token_id": "near"}' --accountId $ALICE --depositYocto 10300 --gas 200000000000000
near view $NFT_CONTRACT_ID nft_token '{"token_id": "1:1"}'

near call $MARKET_CONTRACT_ID offer '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:2", "ft_token_id": "near"}' --accountId $ALICE --depositYocto 10200 --gas 200000000000000
near view $NFT_CONTRACT_ID nft_token '{"token_id": "1:2"}'
near call $MARKET_CONTRACT_ID accept_offer '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:2", "ft_token_id": "near"}' --accountId $CONTRACT_PARENT --gas 200000000000000
near view $NFT_CONTRACT_ID nft_token '{"token_id": "1:2"}'
```

`ALICE` can attach an origin fee to her offer:
```bash
near view $MARKET_CONTRACT_ID price_with_fees '{"price": "10000", "origins": {"'$NFT_CONTRACT_ID'": 150}}'
near call $MARKET_CONTRACT_ID offer '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:3", "ft_token_id": "near", "origins": {"'$NFT_CONTRACT_ID'": 150}}' --accountId $ALICE --depositYocto 10450 --gas 200000000000000
near view $NFT_CONTRACT_ID nft_token '{"token_id": "1:3"}'
```
Here the final price is `10450` due to 3% protocol fee and 1.5% origin fee.
Origin fee is paid by `ALICE` to `$NFT_CONTRACT_ID` when the purchase is made.

If `CONTRACT_PARENT` wants to increase or decrease the price of the third NFT, he can call `update_price`.
```bash
near call $MARKET_CONTRACT_ID update_price '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:4", "ft_token_id": "near", "price": "12000"}' --accountId $CONTRACT_PARENT --depositYocto 1

near view $MARKET_CONTRACT_ID get_sale '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:4"}'
```

Bids for sales can be deleted. If `ALICE` adds a bid and then decides to remove it, she could call `remove_bid`. This would remove her bid and return her money, even before the bid ends:
```bash
near call $MARKET_CONTRACT_ID offer '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:4", "ft_token_id": "near"}' --accountId $ALICE --depositYocto 10000 --gas 200000000000000
near view $MARKET_CONTRACT_ID get_sale '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:4"}'

near call $MARKET_CONTRACT_ID remove_bid '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:4", "ft_token_id": "near", "price": "10000"}' --accountId $ALICE --depositYocto 1
near view $MARKET_CONTRACT_ID get_sale '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:4"}'
```

Suppose some purchasers had added some bids and later they expired.
After this anyone can refund them:
```bash
near call $MARKET_CONTRACT_ID offer '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:4", "ft_token_id": "near", "start": null, "duration": "100000000"}' --accountId $ALICE --depositYocto 500 --gas 200000000000000
near call $MARKET_CONTRACT_ID offer '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:4", "ft_token_id": "near", "start": null, "duration": "100000000"}' --accountId $ALICE --depositYocto 600 --gas 200000000000000
near call $MARKET_CONTRACT_ID offer '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:4", "ft_token_id": "near", "start": null, "duration": "100000000"}' --accountId $ALICE --depositYocto 800 --gas 200000000000000
near view $MARKET_CONTRACT_ID get_sale '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:4"}'

near call $MARKET_CONTRACT_ID cancel_expired_bids '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:4", "ft_token_id": "near"}' --accountId $NFT_CONTRACT_ID
near view $MARKET_CONTRACT_ID get_sale '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:4"}'
```
For this example we created bids with duration equal to 0.1 second and canceled them.

It is possible to refund a specific bid (if it is ended):
```bash
near call $MARKET_CONTRACT_ID offer '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:4", "ft_token_id": "near", "start": null, "duration": "100000000"}' --accountId $ALICE --depositYocto 700 --gas 200000000000000
near view $MARKET_CONTRACT_ID get_sale '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:4"}'

near call $MARKET_CONTRACT_ID cancel_bid '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:4", "ft_token_id": "near", "owner_id": "'$ALICE'", "price": "700"}' --accountId $NFT_CONTRACT_ID
near view $MARKET_CONTRACT_ID get_sale '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:4"}'
```

`CONTRACT_PARENT` can call `remove_sale` to remove his sale and refund all the bids:
```bash
near call $MARKET_CONTRACT_ID remove_sale '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:4"}' --accountId $CONTRACT_PARENT --depositYocto 1

near view $MARKET_CONTRACT_ID get_sales
```
When the sale is in progress, only `CONTRACT_PARENT` can call it. 
If the sale ends and no bid is accepted, anyone can call `remove_sale`.

If the sale is finished, you cannot call `offer` or `accept_offer`.
> `offer` and `accept_offer` should fail after `hack_finish_sale`.
```bash
near call $MARKET_CONTRACT_ID offer '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:5", "ft_token_id": "near", "start": null, "duration": "100000000"}' --accountId $ALICE --depositYocto 300 --gas 200000000000000
near view $MARKET_CONTRACT_ID get_sale '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:5"}'

near call $MARKET_CONTRACT_ID hack_finish_sale '{"nft_contract_id": "'$NFT_CONTRACT_ID'" "token_id": "1:5"}' --accountId $ALICE

near call $MARKET_CONTRACT_ID offer '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:5", "ft_token_id": "near", "start": null, "duration": "100000000"}' --accountId $ALICE --depositYocto 400 --gas 200000000000000
near call $MARKET_CONTRACT_ID accept_offer '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:5", "ft_token_id": "near"}' --accountId $CONTRACT_PARENT --gas 200000000000000

near view $NFT_CONTRACT_ID nft_token '{"token_id": "1:5"}'
near view $MARKET_CONTRACT_ID get_sale '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:5"}'
```
> Here we called `hack_finish_sale` in order to finish the sale ahead of time. It is done for demonstration purposes. All content of `hack.rs` should be deleted later.

If `ALICE` decides to sell one of her NFTs, the royalty fee will be taken from the price:
```bash
near call $MARKET_CONTRACT_ID storage_deposit --accountId $ALICE --deposit 0.1

near call $NFT_CONTRACT_ID nft_approve '{"token_id": "1:1", "account_id": "'$MARKET_CONTRACT_ID'", 
"msg": "{\"Sale\": {\"sale_conditions\": {\"near\": \"10000\"}, \"token_type\": \"1\", \"start\": null, \"end\": null, \"origins\": null} }"}' --accountId $ALICE --deposit 1
near view $MARKET_CONTRACT_ID get_sale '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:1"}'

near call $MARKET_CONTRACT_ID offer '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:1", "ft_token_id": "near", "start": null, "duration": "100000000"}' --accountId $NFT_CONTRACT_ID --depositYocto 10300 --gas 300000000000000
near view $NFT_CONTRACT_ID nft_token '{"token_id": "1:1"}'
```

### List of view methods for sales
To find number of sales:
```bash
near view $MARKET_CONTRACT_ID get_supply_sales
```

To show all sales (with pagination or without it):
```bash
near view $MARKET_CONTRACT_ID get_sales
near view $MARKET_CONTRACT_ID get_sales '{"from_index": "0", "limit": 10}'
```

To get the sale:
```bash
near view $MARKET_CONTRACT_ID get_sale '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "1:1"}'
```

To find number of sales for given owner:
```bash
near view $MARKET_CONTRACT_ID get_supply_by_owner_id '{"account_id": "'$CONTRACT_PARENT'"}'
```

To get sales for the given owner:
```bash
near view $MARKET_CONTRACT_ID get_sales_by_owner_id '{"account_id": "'$CONTRACT_PARENT'", "from_index": "0", "limit": 10}'
```

To find number of sales for given nft contract:
```bash
near view $MARKET_CONTRACT_ID get_supply_by_nft_contract_id '{"nft_contract_id": "'$NFT_CONTRACT_ID'"}'
```

To get sales for the given nft contract:
```bash
near view $MARKET_CONTRACT_ID get_sales_by_nft_contract_id '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "from_index": "0", "limit": 10}'
```

To find number of sales for token type:
```bash
near view $MARKET_CONTRACT_ID get_supply_by_nft_token_type '{"token_type": "near"}'
```

To get sales for token type:
```bash
near view $MARKET_CONTRACT_ID get_sales_by_nft_token_type '{"token_type": "near", "from_index": "0", "limit": 10}'
```

To get the full price with a protocol and origins fee:
```bash
near view $MARKET_CONTRACT_ID price_with_fees '{"price": "10000", "origins": null}'
```
<sub> This method is not specific for sales. Can be used in context of auctions.

### Workflow for creating and using auction

`CONTRACT_PARENT` puts three NFTs on auction:
```bash
near call $MARKET_CONTRACT_ID storage_deposit --accountId $CONTRACT_PARENT --deposit 0.03

near call $NFT_CONTRACT_ID nft_approve '{"token_id": "1:6", "account_id": "'$MARKET_CONTRACT_ID'", 
"msg": "{\"Auction\": {\"token_type\": \"near\", \"minimal_step\": \"100\", \"start_price\": \"10000\", \"start\": null, \"duration\": \"900000000000\", \"buy_out_price\": \"10000000000\", \"origins\": {\"'$NFT_CONTRACT_ID'\": 100}} }"}' --accountId $CONTRACT_PARENT --deposit 1
near call $NFT_CONTRACT_ID nft_approve '{"token_id": "1:7", "account_id": "'$MARKET_CONTRACT_ID'", 
"msg": "{\"Auction\": {\"token_type\": \"near\", \"minimal_step\": \"100\", \"start_price\": \"10000\", \"start\": null, \"duration\": \"900000000000\", \"buy_out_price\": \"10000000000\", \"origins\": {\"'$NFT_CONTRACT_ID'\": 100}} }"}' --accountId $CONTRACT_PARENT --deposit 1
near call $NFT_CONTRACT_ID nft_approve '{"token_id": "1:8", "account_id": "'$MARKET_CONTRACT_ID'", 
"msg": "{\"Auction\": {\"token_type\": \"near\", \"minimal_step\": \"100\", \"start_price\": \"10000\", \"start\": null, \"duration\": \"900000000000\", \"buy_out_price\": \"10000000000\", \"origins\": {\"'$NFT_CONTRACT_ID'\": 100}} }"}' --accountId $CONTRACT_PARENT --deposit 1

near view $MARKET_CONTRACT_ID get_auctions
near view $MARKET_CONTRACT_ID price_with_fees '{"price": "10000", "origins": null}'
```

The duration `900000000000` corresponds to 15 minutes.
You can't set the duration lower than that. `CONTRACT_PARENT` can set the specific start time, otherwise the auction starts as soon as the command is complete.
There is a `buy_out_price`, meaning that anyone can buy the NFT for this price. `CONTRACT_PARENT` could have disabled this feature by setting `buy_out_price` to `null`.
The parameters `start_price`, `minimal_step` and `buy_out_price` do not include fees, to get the final amounts we can call `price_with_fees`.

`CONTRACT_PARENT` can cancel his auction before it has reached its end. It is possible only in case there is no bid for this auction:
```bash
near call $MARKET_CONTRACT_ID cancel_auction '{"auction_id": "0"}' --accountId $CONTRACT_PARENT --depositYocto 1

near view $MARKET_CONTRACT_ID get_auctions
```

`ALICE` can create a bid on the ongoing auction:
```bash
near call $MARKET_CONTRACT_ID auction_add_bid '{"auction_id": "1", "token_type": "near"}' --accountId $ALICE --depositYocto 10300

near view $MARKET_CONTRACT_ID get_auction '{"auction_id": "1"}'
```
In our case, this call happens less than 15 minutes before the end of the auction, thus the auction is extended.

A bid for an auction can't be deleted.

If `ALICE` calls `auction_add_bid` with deposit more or equal to buyout price (with fees), she automatically buys it. In this case the auction ends ahead of time.
```bash
near call $MARKET_CONTRACT_ID auction_add_bid '{"auction_id": "2", "token_type": "near"}' --accountId $ALICE --depositYocto 10300000000

near view $MARKET_CONTRACT_ID get_auction '{"auction_id": "2"}'
```

After auction ends anyone can finish it. It will transfer NFTs to those who bought it:
```bash
near call $MARKET_CONTRACT_ID hack_finish_auction '{"auction_id": "1"}' --accountId $ALICE

near call $MARKET_CONTRACT_ID finish_auction '{"auction_id": "1"}' --accountId $ALICE --gas 200000000000000
near call $MARKET_CONTRACT_ID finish_auction '{"auction_id": "2"}' --accountId $ALICE --gas 200000000000000

near view $NFT_CONTRACT_ID nft_token '{"token_id": "1:7"}'
near view $NFT_CONTRACT_ID nft_token '{"token_id": "1:8"}'

near view $MARKET_CONTRACT_ID get_auctions
```
> Here we called `hack_finish_auction` in order to finish the auction ahead of time. It is done for demonstration purposes. All content of `hack.rs` should be deleted later.

### List of view methods for auctions

To show all auctions (with pagination or without it):
```bash
near view $MARKET_CONTRACT_ID get_auctions '{"from_index": "0", "limit": 10}'
near view $MARKET_CONTRACT_ID get_auctions
```

To get the auction:
```bash
near view $MARKET_CONTRACT_ID get_auction '{"auction_id": "0"}'
```

To get the creator of the latest bid:
```bash
near view $MARKET_CONTRACT_ID get_current_buyer '{"auction_id": "0"}'
```

To check whether the auction in progress:
```bash
near view $MARKET_CONTRACT_ID check_auction_in_progress '{"auction_id": "0"}'
```

To get the minimal bid one could bid (including protocol and origin fees):
```bash
near view $MARKET_CONTRACT_ID get_minimal_next_bid '{"auction_id": "0"}'
```

To get the amount of the latest bid (with protocol and origin fees):
```bash
near view $MARKET_CONTRACT_ID get_current_bid '{"auction_id": "0"}'
```

To get the full price with a protocol and origins fee:
```bash
near view $MARKET_CONTRACT_ID price_with_fees '{"price": "10000", "origins": null}'
```
<sub> This method is not specific for auctions. Can be used in context of sales.
'''
'''--- tests-workspaces/Cargo.toml ---
[package]
name = "tests-workspaces"
version = "0.1.0"
edition = "2018"

[dev-dependencies]
workspaces = "0.1.1"
near-jsonrpc-primitives = "0.5"
near-primitives = "0.5"
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.1.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.10.0", features = ["full"] }
nft-bid-market = { path = "../market"}
nft-contract = { path = "../nft" }
near-contract-standards = "4.0.0-pre.5"
'''
'''--- tests-workspaces/src/auction.rs ---
use std::{
    time::{Duration, SystemTime, UNIX_EPOCH},
};

//use crate::utils::{init_market, init_nft, mint_token, check_outcome_success, check_outcome_fail};
use near_units::{parse_gas, parse_near};
use crate::utils::{init_market, init_nft, create_subaccount, create_series, deposit,
    mint_token, check_outcome_success, check_outcome_fail
};
use nft_bid_market::{ArgsKind, AuctionArgs, AuctionJson};
//use workspaces::{Contract, Account, Worker};

const THIRTY_SECONDS: Duration = Duration::from_secs(30);
const FIFTEEN_MINUTES: Duration = Duration::from_secs(60 * 15);

#[tokio::test]
async fn nft_on_approve_auction_positive() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(
        &worker,
        worker.root_account().id(),
        vec![nft.id()]
    ).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;

    let series = create_series(
        &worker,
        nft.id().clone(),
        &user1,
        owner.id().clone()
    ).await?;
    let token1 = mint_token(
        &worker,
        nft.id().clone(),
        &user1,
        user1.id(),
        &series
    ).await?;

    deposit(&worker, market.id().clone(), &user1).await;
    let outcome = user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Auction(AuctionArgs {
                token_type: None,
                minimal_step: 100.into(),
                start_price: 10000.into(),
                start: None,
                duration: 900000000000.into(),
                buy_out_price: Some(10000000000.into()),
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_success(outcome.status).await;
    Ok(())
}

/*
    - Should panic if `ft_token_id` is not supported
    - TODO: Should panic if the auction is not in progress
    - Panics if auction is not active
    - Should panic if the owner tries to bid on his own auction
    - Should panic if the bid is smaller than the minimal deposit
    - Should panic if the bid is smaller than the previous one + minimal step + fees
*/
#[tokio::test]
async fn auction_add_bid_negative() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(
        &worker,
        worker.root_account().id(),
        vec![nft.id()]
    ).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;
    let user2 = create_subaccount(&worker, &owner, "user2").await?;

    let series = create_series(
        &worker,
        nft.id().clone(),
        &user1,
        owner.id().clone()
    ).await?;
    let token1 = mint_token(
        &worker,
        nft.id().clone(),
        &user1,
        user1.id(),
        &series
    ).await?;

    deposit(&worker, market.id().clone(), &user1).await;
    user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Auction(AuctionArgs {
                token_type: None,
                minimal_step: 100.into(),
                start_price: 10000.into(),
                start: None,
                duration: 900000000000.into(),
                buy_out_price: Some(10000000000.into()),
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;

    // Should panic if `ft_token_id` is not supported
    let outcome = user2
        .call(&worker, market.id().clone(), "auction_add_bid")
        .args_json(serde_json::json!({
            "auction_id": "0".to_string(),
            "token_type": "not_near".to_string(),
        }))?
        .deposit(10300)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "token not supported").await;

    // Panics if auction is not active
    let outcome = user2
        .call(&worker, market.id().clone(), "auction_add_bid")
        .args_json(serde_json::json!({
            "auction_id": "1".to_string(),
        }))?
        .deposit(10300)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Auction does not exist").await;

    // Should panic if the owner tries to bid on his own auction
    let outcome = user1
        .call(&worker, market.id().clone(), "auction_add_bid")
        .args_json(serde_json::json!({
            "auction_id": "0".to_string(),
        }))?
        .deposit(10300)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Cannot bid on your own auction").await;

    // Should panic if the bid is smaller than the minimal deposit
    let outcome = user2
        .call(&worker, market.id().clone(), "auction_add_bid")
        .args_json(serde_json::json!({
            "auction_id": "0".to_string(),
        }))?
        .deposit(10200)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Should bid at least 10300").await;

    // Should panic if the bid is smaller than the previous one
    user2
        .call(&worker, market.id().clone(), "auction_add_bid")
        .args_json(serde_json::json!({
            "auction_id": "0".to_string(),
        }))?
        .deposit(10300)
        .transact()
        .await?;
    let outcome = user2
        .call(&worker, market.id().clone(), "auction_add_bid")
        .args_json(serde_json::json!({
            "auction_id": "0".to_string(),
        }))?
        .deposit(10350)
        .transact()
        .await?;
    //println!("outcome: {:?}", outcome);
    check_outcome_fail(outcome.status, "Should bid at least 10403").await;

    Ok(())
}

/*
    - TODO: Refunds a previous bid (if it exists)
    - Extends an auction if the bid is added less than 15 minutes before the end
    - The auction ends if the `attached_deposit` is bigger than the `buy_out_price` (plus fees)
*/
#[tokio::test]
async fn auction_add_bid_positive() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(
        &worker,
        worker.root_account().id(),
        vec![nft.id()]
    ).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;
    let user2 = create_subaccount(&worker, &owner, "user2").await?;

    let series = create_series(
        &worker,
        nft.id().clone(),
        &user1,
        owner.id().clone()
    ).await?;
    let token1 = mint_token(
        &worker,
        nft.id().clone(),
        &user1,
        user1.id(),
        &series
    ).await?;

    deposit(&worker, market.id().clone(), &user1).await;

    user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Auction(AuctionArgs {
                token_type: None,
                minimal_step: 100.into(),
                start_price: 10000.into(),
                start: None,
                duration: 900000000000.into(),
                buy_out_price: Some(10000000000.into()),
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;

    // Extends an auction if the bid is added less than 15 minutes before the end
    let auction: AuctionJson = market
        .view(
            &worker,
            "get_auction",
            serde_json::json!({ "auction_id": "0".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    let right_before_bid = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards");
    user2
        .call(&worker, market.id().clone(), "auction_add_bid")
        .args_json(serde_json::json!({
            "auction_id": "0".to_string(),
        }))?
        .deposit(10300)
        .transact()
        .await?;
    let auction_bought_out: AuctionJson = market
        .view(
            &worker,
            "get_auction",
            serde_json::json!({ "auction_id": "0".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert!(auction.end.0 < auction_bought_out.end.0, "The auction wasn't extended");
    assert!(Duration::from_nanos(auction_bought_out.end.0) - (right_before_bid  + FIFTEEN_MINUTES) < THIRTY_SECONDS);

    // The auction ends if the `attached_deposit` is bigger than the `buy_out_price` (plus fees)
    let auction: AuctionJson = market
        .view(
            &worker,
            "get_auction",
            serde_json::json!({ "auction_id": "0".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    let right_before_bid = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards");
    user2
        .call(&worker, market.id().clone(), "auction_add_bid")
        .args_json(serde_json::json!({
            "auction_id": "0".to_string(),
        }))?
        .deposit(10300000000)
        .transact()
        .await?;
    let auction_bought_out: AuctionJson = market
        .view(
            &worker,
            "get_auction",
            serde_json::json!({ "auction_id": "0".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    let in_progress: bool = market
        .view(
            &worker,
            "check_auction_in_progress",
            serde_json::json!({ "auction_id": "0".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert!(auction.end.0 > auction_bought_out.end.0, "The end time wasn't decreased");
    assert!(!in_progress, "The auction didn't end");
    assert!(Duration::from_nanos(auction_bought_out.end.0) - right_before_bid < THIRTY_SECONDS);
    Ok(())
}

/*
    - Should panic unless 1 yoctoNEAR is attached
    - Can only be called by the creator of the auction
    - Panics if auction is not active
    - Panics if the auction already has a bid
*/
#[tokio::test]
async fn cancel_auction_negative() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(
        &worker,
        worker.root_account().id(),
        vec![nft.id()]
    ).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;
    let user2 = create_subaccount(&worker, &owner, "user2").await?;

    let series = create_series(
        &worker,
        nft.id().clone(),
        &user1,
        owner.id().clone()
    ).await?;
    let token1 = mint_token(
        &worker,
        nft.id().clone(),
        &user1,
        user1.id(),
        &series
    ).await?;

    deposit(&worker, market.id().clone(), &user1).await;

    user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Auction(AuctionArgs {
                token_type: None,
                minimal_step: 100.into(),
                start_price: 10000.into(),
                start: None,
                duration: 900000000000.into(),
                buy_out_price: Some(10000000000.into()),
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    
    // Should panic unless 1 yoctoNEAR is attached
    let outcome = user1
        .call(&worker, market.id().clone(), "cancel_auction")
        .args_json(serde_json::json!({
            "auction_id": "0".to_string()
        }))?
        .deposit(2)
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Requires attached deposit of exactly 1 yoctoNEAR").await;

    // Panics if auction is not active
    let outcome = user1
        .call(&worker, market.id().clone(), "cancel_auction")
        .args_json(serde_json::json!({
            "auction_id": "1".to_string()
        }))?
        .deposit(1)
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Auction is not active").await;

    // Can only be called by the creator of the auction
    let outcome = user2
        .call(&worker, market.id().clone(), "cancel_auction")
        .args_json(serde_json::json!({
            "auction_id": "0".to_string()
        }))?
        .deposit(1)
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Only the auction owner can cancel the auction").await;

    // Panics if the auction already has a bid
    user2
        .call(&worker, market.id().clone(), "auction_add_bid")
        .args_json(serde_json::json!({
            "auction_id": "0".to_string(),
        }))?
        .deposit(10300)
        .transact()
        .await?;
    let outcome = user1
        .call(&worker, market.id().clone(), "cancel_auction")
        .args_json(serde_json::json!({
            "auction_id": "0".to_string()
        }))?
        .deposit(1)
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Can't cancel the auction after the first bid is made").await;

    let vector_auctions: Vec<AuctionJson> = market.view(
        &worker,
        "get_auctions",
        serde_json::json!({"from_index": null, "limit": null})
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert!(!vector_auctions.is_empty(), "Deleted the auction");
    Ok(())
}

/*
    - Removes the auction
*/
#[tokio::test]
async fn cancel_auction_positive() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(
        &worker,
        worker.root_account().id(),
        vec![nft.id()]
    ).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;

    let series = create_series(
        &worker,
        nft.id().clone(),
        &user1,
        owner.id().clone()
    ).await?;
    let token1 = mint_token(
        &worker,
        nft.id().clone(),
        &user1,
        user1.id(),
        &series
    ).await?;

    deposit(&worker, market.id().clone(), &user1).await;

    user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Auction(AuctionArgs {
                token_type: None,
                minimal_step: 100.into(),
                start_price: 10000.into(),
                start: None,
                duration: 900000000000.into(),
                buy_out_price: Some(10000000000.into()),
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;

    let outcome = user1
        .call(&worker, market.id().clone(), "cancel_auction")
        .args_json(serde_json::json!({
            "auction_id": "0".to_string()
        }))?
        .deposit(1)
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_success(outcome.status).await;
    let vector_auctions: Vec<AuctionJson> = market.view(
        &worker,
        "get_auctions",
        serde_json::json!({})
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert!(vector_auctions.is_empty(), "Did not delete the auction");
    Ok(())
}

/*
    -  TODO: NFT is transferred to the buyer
    -  TODO: ft transferred to the previous owner
    -  TODO: protocol and origins fees are paid
    -  TODO: the previous owner also pays royalty
    -  TODO: the auction is removed from list of auctions
*/
#[tokio::test]
async fn finish_auction_positive() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(
        &worker,
        worker.root_account().id(),
        vec![nft.id()]
    ).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;

    let series = create_series(
        &worker,
        nft.id().clone(),
        &user1,
        owner.id().clone()
    ).await?;
    let token1 = mint_token(
        &worker,
        nft.id().clone(),
        &user1,
        user1.id(),
        &series
    ).await?;

    deposit(&worker, market.id().clone(), &user1).await;

    user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Auction(AuctionArgs {
                token_type: None,
                minimal_step: 100.into(),
                start_price: 10000.into(),
                start: None,
                duration: 900000000000.into(),
                buy_out_price: Some(10000000000.into()),
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;

    /*let outcome = user1
        .call(&worker, market.id().clone(), "finish_auction")
        .args_json(serde_json::json!({
            "auction_id": "1".to_string()
        }))?
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    println!("{:?}", outcome.status);
    check_outcome_success(outcome.status).await; */

    Ok(())
}

/*
    - Panics if the auction is not active
    - Should panic if called before the auction ends
    - TODO: Panics if there is no bid
    - TODO: panic if number of payouts plus number of bids exceeds 10
*/
#[tokio::test]
async fn finish_auction_negative() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(
        &worker,
        worker.root_account().id(),
        vec![nft.id()]
    ).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;

    let series = create_series(
        &worker,
        nft.id().clone(),
        &user1,
        owner.id().clone()
    ).await?;
    let token1 = mint_token(
        &worker,
        nft.id().clone(),
        &user1,
        user1.id(),
        &series
    ).await?;

    deposit(&worker, market.id().clone(), &user1).await;

    user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Auction(AuctionArgs {
                token_type: None,
                minimal_step: 100.into(),
                start_price: 10000.into(),
                start: None,
                duration: 900000000000.into(),
                buy_out_price: Some(10000000000.into()),
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;

    // Panics if the auction is not active
    let outcome = user1
        .call(&worker, market.id().clone(), "finish_auction")
        .args_json(serde_json::json!({
            "auction_id": "1".to_string()
        }))?
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    println!("{:?}", outcome.status);
    check_outcome_fail(outcome.status, "Auction is not active").await;

    // Should panic if called before the auction ends
    let outcome = user1
        .call(&worker, market.id().clone(), "finish_auction")
        .args_json(serde_json::json!({
            "auction_id": "0".to_string()
        }))?
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    println!("{:?}", outcome.status);
    check_outcome_fail(outcome.status, "Auction can be finalized only after the end time").await;

    // Panics if there is no bid

    Ok(())
}

'''
'''--- tests-workspaces/src/auction_views.rs ---
use std::{
    time::{Duration, SystemTime, UNIX_EPOCH},
};

use near_units::{parse_gas, parse_near};
use crate::utils::{init_market, init_nft, create_subaccount, create_series, deposit,
    mint_token, check_outcome_success
};
use nft_bid_market::{ArgsKind, AuctionArgs, AuctionJson};
use nft_contract::common::AccountId;
use nft_contract::common::{U64, U128};

#[tokio::test]
async fn view_auction_get_auction() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(
        &worker,
        worker.root_account().id(),
        vec![nft.id()]
    ).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;

    let series = create_series(
        &worker,
        nft.id().clone(),
        &user1,
        owner.id().clone()
    ).await?;
    let token1 = mint_token(
        &worker,
        nft.id().clone(),
        &user1,
        user1.id(),
        &series
    ).await?;

    deposit(&worker, market.id().clone(), &user1).await;
    user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Auction(AuctionArgs {
                token_type: None,
                minimal_step: 100.into(),
                start_price: 10000.into(),
                start: None,
                duration: 900000000000.into(),
                buy_out_price: Some(10000000000.into()),
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;

    // Check that method fails in case of wrong `auction_id` 
    let outcome = market
        .view(
            &worker,
            "get_auction",
            serde_json::json!({ "auction_id": "1".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await;
    //println!("{}, {}", outcome.result, outcome.logs);
    match outcome {
        Err(err) => {
            println!("{}", err); 
            /*assert!(
                err.to_string().contains("Auction does not exist"),
                "wrong error"
            );*/
        },
        Ok(_) => panic!("Expected failure"),
    };

    // Check that method works in case of correct `auction_id` 
    let auction: AuctionJson = market
        .view(
            &worker,
            "get_auction",
            serde_json::json!({ "auction_id": "0".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    
    assert_eq!(auction.owner_id, AccountId::new_unchecked("user1.test.near".to_owned()));
    assert_eq!(auction.token_id, "1:1".to_string());
    assert_eq!(auction.ft_token_id, AccountId::new_unchecked("near".to_owned()));
    assert_eq!(auction.minimal_step.0, 100);
    assert_eq!(auction.start_price.0, 10000);
    assert_eq!(auction.buy_out_price.unwrap().0, 10000000000);
    
    Ok(())
}

#[tokio::test]
async fn view_auction_get_auctions() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(
        &worker,
        worker.root_account().id(),
        vec![nft.id()]
    ).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;
    let user2 = create_subaccount(&worker, &owner, "user2").await?;

    let series1 = create_series(
        &worker,
        nft.id().clone(),
        &user1,
        owner.id().clone()
    ).await?;
    let token1 = mint_token(
        &worker,
        nft.id().clone(),
        &user1,
        user1.id(),
        &series1
    ).await?;

    let series2 = create_series(
        &worker,
        nft.id().clone(),
        &user2,
        owner.id().clone()
    ).await?;
    let token2 = mint_token(
        &worker,
        nft.id().clone(),
        &user2,
        user2.id(),
        &series2
    ).await?;

    deposit(&worker, market.id().clone(), &user1).await;
    deposit(&worker, market.id().clone(), &user2).await;

    user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Auction(AuctionArgs {
                token_type: None,
                minimal_step: 100.into(),
                start_price: 10000.into(),
                start: None,
                duration: 900000000000.into(),
                buy_out_price: Some(10000000000.into()),
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    user2
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token2,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Auction(AuctionArgs {
                token_type: None,
                minimal_step: 110.into(),
                start_price: 100000.into(),
                start: None,
                duration: 900000000000.into(),
                buy_out_price: Some(1000000000.into()),
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;

    let auctions: Vec<AuctionJson> = market
        .view(
            &worker,
            "get_auctions",
            serde_json::json!({ "from_index": null, "limit": null })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert!(auctions.len() == 2, "wrong length");
    let auction1 = &auctions[0];
    let auction2 = &auctions[1];

    assert_eq!(auction1.owner_id, AccountId::new_unchecked("user1.test.near".to_owned()));
    assert_eq!(auction1.token_id, "1:1".to_string());
    assert_eq!(auction1.ft_token_id, AccountId::new_unchecked("near".to_owned()));
    assert_eq!(auction1.minimal_step.0, 100);
    assert_eq!(auction1.start_price.0, 10000);
    assert_eq!(auction1.buy_out_price.unwrap().0, 10000000000);

    assert_eq!(auction2.owner_id, AccountId::new_unchecked("user2.test.near".to_owned()));
    assert_eq!(auction2.token_id, "2:1".to_string());
    assert_eq!(auction2.ft_token_id, AccountId::new_unchecked("near".to_owned()));
    assert_eq!(auction2.minimal_step.0, 110);
    assert_eq!(auction2.start_price.0, 100000);
    assert_eq!(auction2.buy_out_price.unwrap().0, 1000000000);

    Ok(())
}

#[tokio::test]
async fn view_auction_get_current_buyer() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(
        &worker,
        worker.root_account().id(),
        vec![nft.id()]
    ).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;
    let user2 = create_subaccount(&worker, &owner, "user2").await?;

    let series = create_series(
        &worker,
        nft.id().clone(),
        &user1,
        owner.id().clone()
    ).await?;
    let token1 = mint_token(
        &worker,
        nft.id().clone(),
        &user1,
        user1.id(),
        &series
    ).await?;

    deposit(&worker, market.id().clone(), &user1).await;
    user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Auction(AuctionArgs {
                token_type: None,
                minimal_step: 100.into(),
                start_price: 10000.into(),
                start: None,
                duration: 900000000000.into(),
                buy_out_price: Some(10000000000.into()),
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;

    // Check that method fails in case of wrong `auction_id` 
    let outcome = market
        .view(
            &worker,
            "get_current_buyer",
            serde_json::json!({ "auction_id": "1".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await;
    match outcome {
        Err(err) => {
            println!("{}", err); 
            /*assert!(
                err.to_string().contains("Auction does not exist"),
                "wrong error"
            );*/
        },
        Ok(_) => panic!("Expected failure"),
    };

    let current_buyer: Option<AccountId> = market
        .view(
            &worker,
            "get_current_buyer",
            serde_json::json!({ "auction_id": "0".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert!(current_buyer.is_none(), "Should be None");

    let outcome = user2
        .call(&worker, market.id().clone(), "auction_add_bid")
        .args_json(serde_json::json!({
            "auction_id": "0".to_string(),
        }))?
        .deposit(10300)
        .transact()
        .await?;
    check_outcome_success(outcome.status).await;
    let current_buyer: Option<AccountId> = market
        .view(
            &worker,
            "get_current_buyer",
            serde_json::json!({ "auction_id": "0".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert!(current_buyer.is_some(), "Should be some account");
    assert_eq!(
        current_buyer.unwrap(),
        AccountId::new_unchecked("user2.test.near".to_owned()),
        "wrong account"
    );

    Ok(())
}

#[tokio::test]
async fn view_auction_get_current_bid() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(
        &worker,
        worker.root_account().id(),
        vec![nft.id()]
    ).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;
    let user2 = create_subaccount(&worker, &owner, "user2").await?;

    let series = create_series(
        &worker,
        nft.id().clone(),
        &user1,
        owner.id().clone()
    ).await?;
    let token1 = mint_token(
        &worker,
        nft.id().clone(),
        &user1,
        user1.id(),
        &series
    ).await?;

    deposit(&worker, market.id().clone(), &user1).await;
    user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Auction(AuctionArgs {
                token_type: None,
                minimal_step: 100.into(),
                start_price: 10000.into(),
                start: None,
                duration: 900000000000.into(),
                buy_out_price: Some(10000000000.into()),
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;

    // Check that method fails in case of wrong `auction_id` 
    let outcome = market
        .view(
            &worker,
            "get_current_bid",
            serde_json::json!({ "auction_id": "1".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await;
    match outcome {
        Err(err) => {
            println!("{}", err); 
            /*assert!(
                err.to_string().contains("Auction does not exist"),
                "wrong error"
            );*/
        },
        Ok(_) => panic!("Expected failure"),
    };

    let current_bid: Option<U128> = market
        .view(
            &worker,
            "get_current_bid",
            serde_json::json!({ "auction_id": "0".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert!(current_bid.is_none(), "Should not be any bids");

    // add a bid with deposit 10300
    // 300 yocto is protocol see
    let outcome = user2
        .call(&worker, market.id().clone(), "auction_add_bid")
        .args_json(serde_json::json!({
            "auction_id": "0".to_string(),
        }))?
        .deposit(10300)
        .transact()
        .await?;
    check_outcome_success(outcome.status).await;
    let current_bid: Option<U128> = market
        .view(
            &worker,
            "get_current_bid",
            serde_json::json!({ "auction_id": "0".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert!(current_bid.is_some(), "Should be a bid");
    assert_eq!(
        current_bid.unwrap().0, 
        10000,
        "wrong amount"
    );

    Ok(())
}

#[tokio::test]
async fn view_auction_get_minimal_next_bid() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(
        &worker,
        worker.root_account().id(),
        vec![nft.id()]
    ).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;
    let user2 = create_subaccount(&worker, &owner, "user2").await?;

    let series = create_series(
        &worker,
        nft.id().clone(),
        &user1,
        owner.id().clone()
    ).await?;
    let token1 = mint_token(
        &worker,
        nft.id().clone(),
        &user1,
        user1.id(),
        &series
    ).await?;

    deposit(&worker, market.id().clone(), &user1).await;
    user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Auction(AuctionArgs {
                token_type: None,
                minimal_step: 100.into(),
                start_price: 10000.into(),
                start: None,
                duration: 900000000000.into(),
                buy_out_price: Some(10000000000.into()),
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;

    // Check that method fails in case of wrong `auction_id` 
    let outcome = market
        .view(
            &worker,
            "get_minimal_next_bid",
            serde_json::json!({ "auction_id": "1".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await;
    match outcome {
        Err(err) => {
            println!("{}", err); 
            /*assert!(
                err.to_string().contains("Auction does not exist"),
                "wrong error"
            );*/
        },
        Ok(_) => panic!("Expected failure"),
    };
    
    let min_bid: U128 = market
        .view(
            &worker,
            "get_minimal_next_bid",
            serde_json::json!({ "auction_id": "0".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(min_bid.0, 10000, "Should be initial price");

    // add a bid with deposit 103000
    // this bid without fees is equal to 100000
    // the next bid (without fees) is equal to 100100
    let outcome = user2
        .call(&worker, market.id().clone(), "auction_add_bid")
        .args_json(serde_json::json!({
            "auction_id": "0".to_string(),
        }))?
        .deposit(103000)
        .transact()
        .await?;
    check_outcome_success(outcome.status).await;
    let min_bid: U128 = market
        .view(
            &worker,
            "get_minimal_next_bid",
            serde_json::json!({ "auction_id": "0".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(min_bid.0, 100100, "wrong next bid");

    Ok(())
}

#[tokio::test]
async fn view_auction_check_auction_in_progress() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(
        &worker,
        worker.root_account().id(),
        vec![nft.id()]
    ).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;

    let series = create_series(
        &worker,
        nft.id().clone(),
        &user1,
        owner.id().clone()
    ).await?;
    let token1 = mint_token(
        &worker,
        nft.id().clone(),
        &user1,
        user1.id(),
        &series
    ).await?;
    let token2 = mint_token(
        &worker,
        nft.id().clone(),
        &user1,
        user1.id(),
        &series
    ).await?;
    deposit(&worker, market.id().clone(), &user1).await;

    // create an auction that starts now
    user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Auction(AuctionArgs {
                token_type: None,
                minimal_step: 100.into(),
                start_price: 10000.into(),
                start: None,
                duration: 900000000000.into(),
                buy_out_price: Some(10000000000.into()),
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;

    // Check that method fails in case of wrong `auction_id` 
    let outcome = market
        .view(
            &worker,
            "check_auction_in_progress",
            serde_json::json!({ "auction_id": "1".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await;
    match outcome {
        Err(err) => {
            println!("{}", err); 
            /*assert!(
                err.to_string().contains("Auction does not exist"),
                "wrong error"
            );*/
        },
        Ok(_) => panic!("Expected failure"),
    };
    
    let in_progress: bool = market
        .view(
            &worker,
            "check_auction_in_progress",
            serde_json::json!({ "auction_id": "0".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert!(in_progress, "The auction should be in progress");

    // create an auction which starts one minute after now
    let since_the_epoch = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards");
    let waiting_time = Duration::from_secs(60);
    let epoch_plus_waiting_time = (since_the_epoch + waiting_time).as_nanos();
    user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token2,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Auction(AuctionArgs {
                token_type: None,
                minimal_step: 100.into(),
                start_price: 10000.into(),
                start: Some(U64(epoch_plus_waiting_time as u64)),
                duration: 900000000000.into(),
                buy_out_price: Some(10000000000.into()),
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    let in_progress: bool = market
        .view(
            &worker,
            "check_auction_in_progress",
            serde_json::json!({ "auction_id": "1".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert!(!in_progress, "The auction already started");

    // TODO: check `check_auction_in_progress` if auction is ended
    
    Ok(())
}
'''
'''--- tests-workspaces/src/bid.rs ---
use std::collections::HashMap;

use crate::utils::{
    check_outcome_fail, check_outcome_success, create_series, create_subaccount, deposit,
    init_market, init_nft, mint_token, nft_approve, offer, offer_with_duration,
};
use near_units::parse_gas;
use nft_bid_market::SaleJson;
use nft_contract::common::{AccountId, U128, U64};

/*
- TODO: Refunds a bid, removes it from the list
*/
#[tokio::test]
async fn remove_bid_positive() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;
    let user2 = create_subaccount(&worker, &owner, "user2").await?;

    let series = create_series(&worker, nft.id().clone(), &user1, owner.id().clone()).await?;
    let token1 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;
    deposit(&worker, market.id().clone(), &user1).await;
    let sale_conditions = HashMap::from([("near".parse().unwrap(), 10000.into())]);
    nft_approve(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user1,
        token1.clone(),
        sale_conditions.clone(),
        series.clone(),
    )
    .await;
    let price: U128 = 900.into();
    offer(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user2,
        token1.clone(),
        price,
    )
    .await;

    // Check that one bid is removed after `remove_bid`
    let sale: Option<SaleJson> = market
        .view(
            &worker,
            "get_sale",
            serde_json::json!({
                "nft_contract_id": nft.id(),
                "token_id": token1
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert!(
        sale.unwrap()
            .bids
            .get(&AccountId::new_unchecked("near".to_owned()))
            .unwrap()
            .len()
            == 1,
        "No bids"
    );

    let outcome = user2
        .call(&worker, market.id().clone(), "remove_bid")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id().clone(),
            "token_id": token1.clone(),
            "ft_token_id": "near",
            "price": price,
        }))?
        .deposit(1)
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_success(outcome.status).await;

    let sale: Option<SaleJson> = market
        .view(
            &worker,
            "get_sale",
            serde_json::json!({
                "nft_contract_id": nft.id(),
                "token_id": token1
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert!(
        sale.unwrap()
            .bids
            .get(&AccountId::new_unchecked("near".to_owned()))
            .is_none(),
        "Bid is not removed"
    );

    Ok(())
}

/*
- Should panic unless 1 yoctoNEAR is attached
- Should panic if there is no sale with the given `nft_contract_id` and `token_id`
- Should panic if there is no bids with `ft_token_id`
*/
#[tokio::test]
async fn remove_bid_negative() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;
    let user2 = create_subaccount(&worker, &owner, "user2").await?;

    let series = create_series(&worker, nft.id().clone(), &user1, owner.id().clone()).await?;
    let token1 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;
    deposit(&worker, market.id().clone(), &user1).await;
    let sale_conditions = HashMap::from([("near".parse().unwrap(), 10000.into())]);
    nft_approve(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user1,
        token1.clone(),
        sale_conditions.clone(),
        series.clone(),
    )
    .await;
    let price: U128 = 900.into();
    offer(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user2,
        token1.clone(),
        price,
    )
    .await;

    // Should panic unless 1 yoctoNEAR is attached
    let outcome = user2
        .call(&worker, market.id().clone(), "remove_bid")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id().clone(),
            "token_id": token1.clone(),
            "ft_token_id": "near",
            "price": price,
        }))?
        .deposit(2)
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(
        outcome.status,
        "Requires attached deposit of exactly 1 yoctoNEAR",
    )
    .await;

    // Should panic if there is no sale with the given `nft_contract_id` and `token_id`
    let outcome = user2
        .call(&worker, market.id().clone(), "remove_bid")
        .args_json(serde_json::json!({
            "nft_contract_id": "some_other_nft_contract".to_string(),
            "token_id": token1.clone(),
            "ft_token_id": "near",
            "price": price,
        }))?
        .deposit(1)
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "No sale").await;

    let outcome = user2
        .call(&worker, market.id().clone(), "remove_bid")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id().clone(),
            "token_id": "1:10",
            "ft_token_id": "near",
            "price": price,
        }))?
        .deposit(1)
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "No sale").await;

    // Should panic if there is no bids with `ft_token_id`
    let outcome = user2
        .call(&worker, market.id().clone(), "remove_bid")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id().clone(),
            "token_id": token1.clone(),
            "ft_token_id": "not_near",
            "price": price,
        }))?
        .deposit(1)
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "No token").await;

    Ok(())
}

/*
TODO: Refunds a bid, removes it from the list
*/
#[tokio::test]
async fn cancel_bid_positive() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;
    let user2 = create_subaccount(&worker, &owner, "user2").await?;
    let user3 = create_subaccount(&worker, &owner, "user3").await?;

    let series = create_series(&worker, nft.id().clone(), &user1, owner.id().clone()).await?;
    let token1 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;
    deposit(&worker, market.id().clone(), &user1).await;
    let sale_conditions = HashMap::from([("near".parse().unwrap(), 10000.into())]);
    nft_approve(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user1,
        token1.clone(),
        sale_conditions.clone(),
        series.clone(),
    )
    .await;
    let price: U128 = 900.into();
    offer_with_duration(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user2,
        token1.clone(),
        price,
        U64(100000000),
    )
    .await;

    // Check that one bid is removed after `cancel_bid`
    let sale: Option<SaleJson> = market
        .view(
            &worker,
            "get_sale",
            serde_json::json!({
                "nft_contract_id": nft.id(),
                "token_id": token1
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert!(
        sale.unwrap()
            .bids
            .get(&AccountId::new_unchecked("near".to_owned()))
            .unwrap()
            .len()
            == 1,
        "No bids"
    );

    let outcome = user3
        .call(&worker, market.id().clone(), "cancel_bid")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id().clone(),
            "token_id": token1.clone(),
            "ft_token_id": "near",
            "owner_id": user2.id(),
            "price": price,
        }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_success(outcome.status).await;

    let sale: Option<SaleJson> = market
        .view(
            &worker,
            "get_sale",
            serde_json::json!({
                "nft_contract_id": nft.id(),
                "token_id": token1
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert!(
        sale.unwrap()
            .bids
            .get(&AccountId::new_unchecked("near".to_owned()))
            .is_none(),
        "Bid is not removed"
    );

    Ok(())
}

/*
- Should panic if the bid isn't finished yet
- Should panic if the bid doesn't have end time
- Should panic if there is no sale with the given `nft_contract_id` and `token_id`
- Should panic if there is no bids with `ft_token_id`
- Should panic if there is no bid with given `owner_id` and `price`
*/
#[tokio::test]
async fn cancel_bid_negative() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;
    let user2 = create_subaccount(&worker, &owner, "user2").await?;
    let user3 = create_subaccount(&worker, &owner, "user3").await?;

    let series = create_series(&worker, nft.id().clone(), &user1, owner.id().clone()).await?;
    let token1 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;
    deposit(&worker, market.id().clone(), &user1).await;
    let sale_conditions = HashMap::from([("near".parse().unwrap(), 10000.into())]);
    nft_approve(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user1,
        token1.clone(),
        sale_conditions.clone(),
        series.clone(),
    )
    .await;

    // Should panic if the bid isn't finished yet
    let price: U128 = 900.into();
    offer_with_duration(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user2,
        token1.clone(),
        price,
        U64(1000000000000),
    )
    .await;

    let outcome = user3
        .call(&worker, market.id().clone(), "cancel_bid")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id().clone(),
            "token_id": token1.clone(),
            "ft_token_id": "near",
            "owner_id": user2.id(),
            "price": price,
        }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "The bid hasn't ended yet").await;

    // Should panic if the bid doesn't have end time
    let price: U128 = 950.into();
    offer(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user2,
        token1.clone(),
        price,
    )
    .await;

    let outcome = user3
        .call(&worker, market.id().clone(), "cancel_bid")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id().clone(),
            "token_id": token1.clone(),
            "ft_token_id": "near",
            "owner_id": user2.id(),
            "price": price,
        }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "The bid doesn't have an end").await;

    // Should panic if the bid isn't finished yet
    let price: U128 = 900.into();
    offer_with_duration(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user2,
        token1.clone(),
        price,
        U64(1000000000000),
    )
    .await;

    let outcome = user3
        .call(&worker, market.id().clone(), "cancel_bid")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id().clone(),
            "token_id": token1.clone(),
            "ft_token_id": "near",
            "owner_id": user2.id(),
            "price": price,
        }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "The bid hasn't ended yet").await;

    // Should panic if there is no sale with the given `nft_contract_id` and `token_id`
    let price: U128 = 1000.into();
    offer_with_duration(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user2,
        token1.clone(),
        price,
        U64(100000000),
    )
    .await;

    let outcome = user3
        .call(&worker, market.id().clone(), "cancel_bid")
        .args_json(serde_json::json!({
            "nft_contract_id": "another_nft_contract_id".to_string(),
            "token_id": token1.clone(),
            "ft_token_id": "near",
            "owner_id": user2.id(),
            "price": price,
        }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "No sale").await;

    let outcome = user3
        .call(&worker, market.id().clone(), "cancel_bid")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id().clone(),
            "token_id": "another_token_id".to_string(),
            "ft_token_id": "near",
            "owner_id": user2.id(),
            "price": price,
        }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "No sale").await;

    // Should panic if there is no bids with `ft_token_id`
    let outcome = user3
        .call(&worker, market.id().clone(), "cancel_bid")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id().clone(),
            "token_id": token1.clone(),
            "ft_token_id": "not_near",
            "owner_id": user2.id(),
            "price": price,
        }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "No token").await;

    // Should panic if there is no bid with given `owner_id` and `price`
    let outcome = user3
        .call(&worker, market.id().clone(), "cancel_bid")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id().clone(),
            "token_id": token1.clone(),
            "ft_token_id": "near",
            "owner_id": user1.id(),
            "price": price,
        }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "No such bid").await;

    let outcome = user3
        .call(&worker, market.id().clone(), "cancel_bid")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id().clone(),
            "token_id": token1.clone(),
            "ft_token_id": "near",
            "owner_id": user2.id(),
            "price": "1100".to_string(),
        }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "No such bid").await;

    Ok(())
}

/*
- TODO: Refunds all expired bids, removes them from the list
*/
#[tokio::test]
async fn cancel_expired_bids_positive() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;
    let user2 = create_subaccount(&worker, &owner, "user2").await?;
    let user3 = create_subaccount(&worker, &owner, "user3").await?;

    let series = create_series(&worker, nft.id().clone(), &user1, owner.id().clone()).await?;
    let token1 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;
    deposit(&worker, market.id().clone(), &user1).await;
    let sale_conditions = HashMap::from([("near".parse().unwrap(), 10000.into())]);
    nft_approve(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user1,
        token1.clone(),
        sale_conditions.clone(),
        series.clone(),
    )
    .await;
    offer_with_duration(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user2,
        token1.clone(),
        U128(900),
        U64(100000000),
    )
    .await;
    offer(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user2,
        token1.clone(),
        U128(950),
    )
    .await;
    offer_with_duration(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user2,
        token1.clone(),
        U128(1000),
        U64(100000000),
    )
    .await;

    // check that two bids are removed after `cancel_expired_bids`
    let sale: Option<SaleJson> = market
        .view(
            &worker,
            "get_sale",
            serde_json::json!({
               "nft_contract_id": nft.id(),
               "token_id": token1
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert!(
        sale.unwrap()
            .bids
            .get(&AccountId::new_unchecked("near".to_owned()))
            .unwrap()
            .len()
            == 3,
        "No bids"
    );

    let outcome = user3
        .call(&worker, market.id().clone(), "cancel_expired_bids")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id().clone(),
            "token_id": token1.clone(),
            "ft_token_id": "near",
        }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_success(outcome.status).await;

    let sale: Option<SaleJson> = market
        .view(
            &worker,
            "get_sale",
            serde_json::json!({
                "nft_contract_id": nft.id(),
                "token_id": token1
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert!(
        sale.unwrap()
            .bids
            .get(&AccountId::new_unchecked("near".to_owned()))
            .unwrap()
            .len()
            == 1,
        "Had to remove 2 bids"
    );

    Ok(())
}

/*
- Should panic if there is no sale with the given `nft_contract_id` and `token_id`
- Should panic if there is no bids with `ft_token_id`
*/
#[tokio::test]
async fn cancel_expired_bids_negative() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;
    let user2 = create_subaccount(&worker, &owner, "user2").await?;
    let user3 = create_subaccount(&worker, &owner, "user3").await?;

    let series = create_series(&worker, nft.id().clone(), &user1, owner.id().clone()).await?;
    let token1 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;
    deposit(&worker, market.id().clone(), &user1).await;
    let sale_conditions = HashMap::from([("near".parse().unwrap(), 10000.into())]);
    nft_approve(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user1,
        token1.clone(),
        sale_conditions.clone(),
        series.clone(),
    )
    .await;
    offer_with_duration(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user2,
        token1.clone(),
        U128(900),
        U64(100000000),
    )
    .await;
    offer(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user2,
        token1.clone(),
        U128(950),
    )
    .await;
    offer_with_duration(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user2,
        token1.clone(),
        U128(1000),
        U64(100000000),
    )
    .await;

    // Should panic if there is no sale with the given `nft_contract_id` and `token_id`
    let outcome = user3
        .call(&worker, market.id().clone(), "cancel_expired_bids")
        .args_json(serde_json::json!({
            "nft_contract_id": "another_nft_contract".to_string(),
            "token_id": token1.clone(),
            "ft_token_id": "near",
        }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "No sale").await;

    let outcome = user3
        .call(&worker, market.id().clone(), "cancel_expired_bids")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id().clone(),
            "token_id": "another_token".to_string(),
            "ft_token_id": "near",
        }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "No sale").await;

    // Should panic if there is no bids with `ft_token_id`
    let outcome = user3
        .call(&worker, market.id().clone(), "cancel_expired_bids")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id().clone(),
            "token_id": token1.clone(),
            "ft_token_id": "not_near",
        }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "No token").await;

    Ok(())
}

'''
'''--- tests-workspaces/src/fee.rs ---
use std::collections::HashMap;

use near_units::parse_near;
use nft_bid_market::{PAYOUT_TOTAL_VALUE, PROTOCOL_FEE};
use nft_contract::common::{AccountId, U128};

use crate::utils::init_market;

#[tokio::test]
async fn price_with_fees() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let market = init_market(&worker, worker.root_account().id(), vec![]).await?;
    let price_without_fees = U128(23456788765);
    let price_with_fees: U128 = market
        .view(
            &worker,
            "price_with_fees",
            serde_json::json!({ "price": price_without_fees })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(
        price_with_fees,
        U128(price_without_fees.0 * (PAYOUT_TOTAL_VALUE + PROTOCOL_FEE) / PAYOUT_TOTAL_VALUE)
    );

    let origins: HashMap<AccountId, u32> = HashMap::from([
        ("user1".parse().unwrap(), 100),
        ("user2".parse().unwrap(), 200),
        ("user3".parse().unwrap(), 300),
        ("user4".parse().unwrap(), 400),
        ("user5".parse().unwrap(), 500),
        ("user6".parse().unwrap(), 600),
    ]);
    let origins_sum: u32 = origins.values().sum();
    let price_without_fees = U128(parse_near!("5 N"));
    let price_with_fees: U128 = market
        .view(
            &worker,
            "price_with_fees",
            serde_json::json!({
                "price": price_without_fees,
                "origins": origins
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(
        price_with_fees,
        U128(
            price_without_fees.0 * (PAYOUT_TOTAL_VALUE + PROTOCOL_FEE + origins_sum as u128)
                / PAYOUT_TOTAL_VALUE
        )
    );
    Ok(())
}

'''
'''--- tests-workspaces/src/lib.rs ---
#![cfg(test)]

mod utils;
mod sale;
mod nft;
mod auction;
mod bid;
mod market;
mod permissions;
mod auction_views;
mod sale_views;
mod series_views;
mod fee;

'''
'''--- tests-workspaces/src/market.rs ---
use std::collections::HashMap;

use near_units::parse_near;

use crate::utils::{
    check_outcome_fail, check_outcome_success, create_series_raw, init_market, init_nft,
    mint_token, nft_approve,
};

#[tokio::test]
async fn storage_deposit() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    // Negative
    let outcome = user
        .call(&worker, market.id().clone(), "storage_deposit")
        .deposit(20)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Requires minimum deposit of").await;

    // Positive
    let outcome = user
        .call(&worker, market.id().clone(), "storage_deposit")
        .deposit(parse_near!("0.01 N"))
        .transact()
        .await?;
    check_outcome_success(outcome.status).await;
    Ok(())
}

#[tokio::test]
async fn storage_withdraw() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();
    let outcome = user
        .call(&worker, market.id().clone(), "storage_deposit")
        .deposit(parse_near!("5 N"))
        .transact()
        .await?;
    check_outcome_success(outcome.status).await;
    let series = create_series_raw(
        &worker,
        nft.id().clone(),
        &user,
        Some(4),
        HashMap::from([(user.id(), 500)]),
    )
    .await?;
    let token = mint_token(&worker, nft.id().clone(), &user, user.id(), &series).await?;
    let sale_conditions = HashMap::from([("near".parse().unwrap(), 42000.into())]);
    nft_approve(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user,
        token.clone(),
        sale_conditions.clone(),
        series.clone(),
    )
    .await;

    // Negative
    // - requires 1 yocto
    let outcome = user
        .call(&worker, market.id().clone(), "storage_withdraw")
        .transact()
        .await?;
    check_outcome_fail(
        outcome.status,
        "Requires attached deposit of exactly 1 yoctoNEAR",
    )
    .await;

    // Positive
    // - deposit refunded
    let outcome = user
        .call(&worker, market.id().clone(), "storage_withdraw")
        .deposit(1)
        .transact()
        .await?;
    check_outcome_success(outcome.status).await;

    // TODO: check balances
    Ok(())
}

'''
'''--- tests-workspaces/src/nft.rs ---
use std::collections::HashMap;

use crate::utils::{
    check_outcome_fail, create_series_raw, init_nft, mint_token,
    nft_transfer_payout_helper,
};
use near_contract_standards::non_fungible_token::{metadata::TokenMetadata, Token};
use near_units::{parse_gas, parse_near};
use nft_bid_market::Fees;
use nft_contract::TokenSeriesJson;

/*
- Can only be called by the autorized account (if authorization enabled)
- Panics if the title of the series is not specified
- Panics if the total royalty payout exceeds 50%
*/
#[tokio::test]
async fn nft_create_series_negative() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let user1 = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();
    let user2 = owner
        .create_subaccount(&worker, "user2")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    // Only authorized account can create series
    owner
        .call(&worker, nft.id().clone(), "set_private_minting")
        .args_json(serde_json::json!({
            "enabled": true,
        }))?
        .transact()
        .await?;
    let token_metadata = TokenMetadata {
        title: Some("some title".to_string()),
        description: None,
        media: Some("ipfs://QmTqZsmhZLLbi8vxZwm21wjKRFRBUQFzMFtTiyh3DJ2CCz".to_string()),
        media_hash: None,
        copies: Some(7),
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    };
    let outcome = user1
        .call(&worker, nft.id().clone(), "nft_create_series")
        .args_json(serde_json::json!({
            "token_metadata": token_metadata,
            "royalty": null
        }))?
        .deposit(parse_near!("0.005 N"))
        .transact()
        .await?;
    if let near_primitives::views::FinalExecutionStatus::Failure(err) = outcome.status {
        assert!(err
            .to_string()
            .contains("Access to mint is denied for this contract"))
    } else {
        panic!("Expected failure")
    };
    owner
        .call(&worker, nft.id().clone(), "grant")
        .args_json(serde_json::json!({
            "account_id": user1.id()
        }))?
        .transact()
        .await?;

    // Title of the series should be specified
    let outcome = user1
        .call(&worker, nft.id().clone(), "nft_create_series")
        .args_json(serde_json::json!({
            "token_metadata": TokenMetadata{
                title: None,
                ..token_metadata.clone()},
            "royalty": null
        }))?
        .deposit(parse_near!("0.005 N"))
        .transact()
        .await?;
    if let near_primitives::views::FinalExecutionStatus::Failure(err) = outcome.status {
        assert!(err
            .to_string()
            .contains("title is missing from token metadata"))
    } else {
        panic!("Expected failure")
    };

    // Royalty can't exceed 50%
    let royalty = HashMap::from([(user1.id(), 500), (user2.id(), 5000)]);
    let outcome = user1
        .call(&worker, nft.id().clone(), "nft_create_series")
        .args_json(serde_json::json!({
            "token_metadata": token_metadata,
            "royalty": royalty,
        }))?
        .deposit(parse_near!("0.005 N"))
        .transact()
        .await?;
    if let near_primitives::views::FinalExecutionStatus::Failure(err) = outcome.status {
        assert!(err.to_string().contains("maximum royalty cap exceeded"))
    } else {
        panic!("Expected failure")
    };
    Ok(())
}

/*
- Creates a new series with given metadata and royalty
- Refunds a deposit
 */
#[tokio::test]
async fn nft_create_series_positive() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let user1 = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();
    let user2 = owner
        .create_subaccount(&worker, "user2")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();
    let royalty = HashMap::from([(user1.id(), 500), (user2.id(), 2000)]);
    let token_metadata = TokenMetadata {
        title: Some("some title".to_string()),
        description: None,
        media: Some("ipfs://QmTqZsmhZLLbi8vxZwm21wjKRFRBUQFzMFtTiyh3DJ2CCz".to_string()),
        media_hash: None,
        copies: Some(7),
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    };
    let series1: String = user1
        .call(&worker, nft.id().clone(), "nft_create_series")
        .args_json(serde_json::json!({
            "token_metadata": token_metadata,
            "royalty": royalty,
        }))?
        .deposit(parse_near!("2 N"))
        .transact()
        .await?
        .json()?;

    owner
        .call(&worker, nft.id().clone(), "set_private_minting")
        .args_json(serde_json::json!({
            "enabled": true,
        }))?
        .transact()
        .await?;

    owner
        .call(&worker, nft.id().clone(), "grant")
        .args_json(serde_json::json!({
            "account_id": user2.id()
        }))?
        .transact()
        .await?;
    let series2: String = user2
        .call(&worker, nft.id().clone(), "nft_create_series")
        .args_json(serde_json::json!({
            "token_metadata": token_metadata,
            "royalty": royalty,
        }))?
        .deposit(parse_near!("0.005 N"))
        .transact()
        .await?
        .json()?;
    let series1_json: TokenSeriesJson = nft
        .view(
            &worker,
            "nft_get_series",
            serde_json::json!({ "token_series_id": series1 })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(series1_json.owner_id.as_str(), user1.id().as_ref());
    let series2_json: TokenSeriesJson = nft
        .view(
            &worker,
            "nft_get_series",
            serde_json::json!({ "token_series_id": series2 })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(series2_json.owner_id.as_str(), user2.id().as_ref());

    assert_eq!(series1_json.metadata, series2_json.metadata);
    // TODO: check balance of user1 after workspaces updated
    Ok(())
}

/*
- Can only be called by the autorized account (if authorization enabled)
- Panics if there is no series `token_series_id`
- Panics if called not by the owner of the series or the approved account to mint this specific series
- Panics if the maximum number of tokens have already been minted
 */
#[tokio::test]
async fn nft_mint_negative() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let user1 = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();
    let user2 = owner
        .create_subaccount(&worker, "user2")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();
    let user3 = owner
        .create_subaccount(&worker, "user3")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();
    let token_metadata = TokenMetadata {
        title: Some("some title".to_string()),
        description: None,
        media: Some("ipfs://QmTqZsmhZLLbi8vxZwm21wjKRFRBUQFzMFtTiyh3DJ2CCz".to_string()),
        media_hash: None,
        copies: Some(1),
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    };
    let royalty = HashMap::from([(user1.id(), 500), (user2.id(), 2000)]);
    let series_id: String = user1
        .call(&worker, nft.id().clone(), "nft_create_series")
        .args_json(serde_json::json!({
            "token_metadata": token_metadata,
            "royalty": royalty,
        }))?
        .deposit(parse_near!("2 N"))
        .transact()
        .await?
        .json()?;

    // Only authorized account can mint
    owner
        .call(&worker, nft.id().clone(), "set_private_minting")
        .args_json(serde_json::json!({
            "enabled": true,
        }))?
        .transact()
        .await?;
    let outcome = user1
        .call(&worker, nft.id().clone(), "nft_mint")
        .args_json(serde_json::json!({
            "token_series_id": series_id,
            "receiver_id": user1.id()
        }))?
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    if let near_primitives::views::FinalExecutionStatus::Failure(err) = outcome.status {
        assert!(err
            .to_string()
            .contains("Access to mint is denied for this contract"))
    } else {
        panic!("Expected failure")
    };

    owner
        .call(&worker, nft.id().clone(), "set_private_minting")
        .args_json(serde_json::json!({
            "enabled": false,
        }))?
        .transact()
        .await?;

    // wrong series_id
    let outcome = user1
        .call(&worker, nft.id().clone(), "nft_mint")
        .args_json(serde_json::json!({
            "token_series_id": "3",
            "receiver_id": user1.id()
        }))?
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    if let near_primitives::views::FinalExecutionStatus::Failure(err) = outcome.status {
        assert!(err.to_string().contains("Token series does not exist"))
    } else {
        panic!("Expected failure")
    };

    // only owner can mint
    let outcome = user3
        .call(&worker, nft.id().clone(), "nft_mint")
        .args_json(serde_json::json!({
            "token_series_id": series_id,
            "receiver_id": user1.id()
        }))?
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    if let near_primitives::views::FinalExecutionStatus::Failure(err) = outcome.status {
        assert!(err.to_string().contains("permission denied"))
    } else {
        panic!("Expected failure")
    };

    // Exceed max tokens
    user1
        .call(&worker, nft.id().clone(), "nft_mint")
        .args_json(serde_json::json!({
            "token_series_id": series_id,
            "receiver_id": user1.id()
        }))?
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    let outcome = user1
        .call(&worker, nft.id().clone(), "nft_mint")
        .args_json(serde_json::json!({
            "token_series_id": series_id,
            "receiver_id": user1.id()
        }))?
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    if let near_primitives::views::FinalExecutionStatus::Failure(err) = outcome.status {
        assert!(err.to_string().contains("Max token minted"))
    } else {
        panic!("Expected failure")
    };
    Ok(())
}

/*
- Mints a new token
- Refunds a deposit
 */
#[tokio::test]
async fn nft_mint_positive() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let user1 = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();
    let user2 = owner
        .create_subaccount(&worker, "user2")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();
    let mut token_metadata = TokenMetadata {
        title: Some("some title".to_string()),
        description: None,
        media: Some("ipfs://QmTqZsmhZLLbi8vxZwm21wjKRFRBUQFzMFtTiyh3DJ2CCz".to_string()),
        media_hash: None,
        copies: Some(1),
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    };
    let royalty = HashMap::from([(user1.id(), 500), (user2.id(), 2000)]);
    let series_id: String = user1
        .call(&worker, nft.id().clone(), "nft_create_series")
        .args_json(serde_json::json!({
            "token_metadata": token_metadata,
            "royalty": royalty,
        }))?
        .deposit(parse_near!("2 N"))
        .transact()
        .await?
        .json()?;

    let token_id: String = user1
        .call(&worker, nft.id().clone(), "nft_mint")
        .args_json(serde_json::json!({
            "token_series_id": series_id,
            "receiver_id": user2.id()
        }))?
        .deposit(parse_near!("1 N"))
        .transact()
        .await?
        .json()?;
    let minted_token: Token = nft
        .view(
            &worker,
            "nft_token",
            serde_json::json!({ "token_id": token_id })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    let minted_token_metadata = minted_token.metadata.as_ref().unwrap();
    token_metadata.issued_at = minted_token_metadata.issued_at.clone();
    token_metadata.copies = None;
    assert_eq!(
        minted_token,
        Token {
            token_id,
            owner_id: user2.id().as_ref().parse().unwrap(),
            metadata: Some(token_metadata),
            approved_account_ids: Some(Default::default())
        }
    );
    Ok(())
}

/*
- Should panic unless 1 yoctoNEAR is attached
- Panics if `token_id` which doesn't exist
- Panics if the number of royalties exceeds `max_len_payout`
- Panics if invalid `memo` is provided
- Panics if total payout exceeds `ROYALTY_TOTAL_VALUE`
*/
#[tokio::test]
async fn nft_transfer_payout_negative() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let user1 = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();
    let user2 = owner
        .create_subaccount(&worker, "user2")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    let user3 = owner
        .create_subaccount(&worker, "user3")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    let series = create_series_raw(
        &worker,
        nft.id().clone(),
        &user1,
        Some(4),
        HashMap::from([
            (user1.id(), 500),
            (&"acc1.near".parse().unwrap(), 100),
            (&"acc2.near".parse().unwrap(), 100),
            (&"acc3.near".parse().unwrap(), 100),
            (&"acc4.near".parse().unwrap(), 100),
            (&"acc5.near".parse().unwrap(), 100),
            (&"acc6.near".parse().unwrap(), 100),
        ]),
    )
    .await?;
    let token1 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;
    user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": user2.id(),
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;

    let approval_id: u64 = {
        let token: Token = nft
            .view(
                &worker,
                "nft_token",
                serde_json::json!({ "token_id": token1 })
                    .to_string()
                    .into_bytes(),
            )
            .await?
            .json()?;
        let approval_account_ids = token.approved_account_ids.unwrap();
        *approval_account_ids
            .get(&user2.id().as_ref().parse().unwrap())
            .unwrap()
    };
    // 1 yoctoNEAR not attached
    let outcome = user2
        .call(&worker, nft.id().clone(), "nft_transfer_payout")
        .args_json(serde_json::json!({
            "receiver_id": user3.id(),
            "token_id": token1,
            "approval_id": approval_id,
            "balance": "10000",
            "max_len_payout": 10,
        }))?
        .transact()
        .await?;
    check_outcome_fail(
        outcome.status,
        "Requires attached deposit of exactly 1 yoctoNEAR",
    )
    .await;

    // `token_id` contains `token_series_id`, which doesn't exist
    let outcome = user2
        .call(&worker, nft.id().clone(), "nft_transfer_payout")
        .args_json(serde_json::json!({
            "receiver_id": user3.id(),
            "token_id": "2:1",
            "approval_id": approval_id,
            "balance": "10000",
            "max_len_payout": 10,
        }))?
        .deposit(1)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "no token id").await;

    // number of royalties exceeds `max_len_payout`
    let outcome = user2
        .call(&worker, nft.id().clone(), "nft_transfer_payout")
        .args_json(serde_json::json!({
            "receiver_id": user3.id(),
            "token_id": token1,
            "approval_id": approval_id,
            "balance": "10000",
            "max_len_payout": 5,
        }))?
        .deposit(1)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Too many recievers").await;

    // invalid `memo` is provided
    let outcome = user2
        .call(&worker, nft.id().clone(), "nft_transfer_payout")
        .args_json(serde_json::json!({
            "receiver_id": user3.id(),
            "token_id": token1,
            "approval_id": approval_id,
            "memo": "some_wrong_memo",
            "balance": "10000",
            "max_len_payout": 10,
        }))?
        .deposit(1)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "invalid FeesArgs").await;

    // if total payout exceeds `ROYALTY_TOTAL_VALUE`
    let fees = Fees {
        buyer: HashMap::from([
            ("acc1.near".parse().unwrap(), 100),
            ("acc2.near".parse().unwrap(), 100),
            ("acc3.near".parse().unwrap(), 100),
            ("acc4.near".parse().unwrap(), 100),
            ("acc5.near".parse().unwrap(), 100),
            ("acc6.near".parse().unwrap(), 100),
        ]),
        seller: HashMap::from([
            ("acc7.near".parse().unwrap(), 100),
            ("acc8.near".parse().unwrap(), 100),
            ("acc9.near".parse().unwrap(), 100),
            ("acc10.near".parse().unwrap(), 100),
            ("acc11.near".parse().unwrap(), 100),
            ("acc12.near".parse().unwrap(), 100),
        ]),
    };
    let outcome = user2
        .call(&worker, nft.id().clone(), "nft_transfer_payout")
        .args_json(serde_json::json!({
            "receiver_id": user3.id(),
            "token_id": token1,
            "approval_id": approval_id,
            "memo": serde_json::json!(fees).to_string(),
            "balance": "10000",
            "max_len_payout": 10,
        }))?
        .deposit(1)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Too many recievers").await;
    Ok(())
}

// - Returns payout, which contains royalties and payouts from `memo`
// Checking calculations here
#[tokio::test]
async fn nft_transfer_payout_positive() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let user1 = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();
    let user2 = owner
        .create_subaccount(&worker, "user2")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    let user3 = owner
        .create_subaccount(&worker, "user3")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    let parsed_near = parse_near!("2.01 N").into();
    let payouts = nft_transfer_payout_helper(
        &worker,
        &nft,
        &user1,
        &user2,
        &user3,
        HashMap::from([(user1.id(), 500)]),
        Fees {
            buyer: HashMap::from([(user2.id().as_ref().parse().unwrap(), 300)]),
            seller: HashMap::from([(user2.id().as_ref().parse().unwrap(), 300)]),
        },
        parsed_near,
    )
    .await;

    let sum: u128 = payouts.payout.values().map(|val| val.0).sum();
    assert!(parsed_near.0 - sum <= 1);

    let parsed_near = parse_near!("1.23 N").into();
    let payouts = nft_transfer_payout_helper(
        &worker,
        &nft,
        &user1,
        &user2,
        &user3,
        HashMap::from([(user1.id(), 500)]),
        Fees {
            buyer: HashMap::from([(user2.id().as_ref().parse().unwrap(), 300)]),
            seller: HashMap::from([(user2.id().as_ref().parse().unwrap(), 300)]),
        },
        parsed_near,
    )
    .await;

    let sum: u128 = payouts.payout.values().map(|val| val.0).sum();
    assert!(parsed_near.0 - sum <= 1);

    let parsed_near = parse_near!("3.45 N").into();
    let payouts = nft_transfer_payout_helper(
        &worker,
        &nft,
        &user1,
        &user2,
        &user3,
        HashMap::from([(user1.id(), 500)]),
        Fees {
            buyer: HashMap::from([(user2.id().as_ref().parse().unwrap(), 300), (user1.id().as_ref().parse().unwrap(), 500)]),
            seller: HashMap::from([(user2.id().as_ref().parse().unwrap(), 300)]),
        },
        parsed_near,
    )
    .await;

    let sum: u128 = payouts.payout.values().map(|val| val.0).sum();
    assert!(parsed_near.0 - sum <= 1);
    Ok(())
}

'''
'''--- tests-workspaces/src/permissions.rs ---
use workspaces::{Account, DevNetwork, Worker, Contract};
use nft_contract::common::AccountId;

use crate::utils::{init_nft, create_subaccount, 
    check_outcome_success, check_outcome_fail
};

pub async fn set_private_minting(
    worker: &Worker<impl DevNetwork>,
    nft: workspaces::AccountId,
    user: &Account,
    enabled: bool 
) {
    user.call(worker, nft, "set_private_minting")
        .args_json(serde_json::json!({
            "enabled": enabled,
        }))
        .unwrap()
        .transact()
        .await
        .unwrap();
}

pub async fn grant(
    worker: &Worker<impl DevNetwork>,
    nft: workspaces::AccountId,
    user: &Account,
    account_id: AccountId 
) -> anyhow::Result<bool> {
    let result = user.call(worker, nft, "grant")
        .args_json(serde_json::json!({
            "account_id": account_id,
        }))?
        .transact()
        .await?
        .json()?;
    Ok(result)
}

pub async fn is_allowed(
    worker: &Worker<impl DevNetwork>,
    nft: &Contract,
    account_id: AccountId 
) -> anyhow::Result<bool> {
    let result: bool = nft
        .view(
            worker,
            "is_allowed",
            serde_json::json!({
                "account_id": account_id,
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    Ok(result)
}

/*
- Can only be called by the owner
- Adds a given account to the list of the autorized accounts
- Returns `true` if the new account has been added to the list, `false` otherwise
*/
#[tokio::test]
async fn permissions_grant() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;
    
    set_private_minting(&worker, nft.id().clone(), &owner, true).await;

    // Can only be called by the owner
    let outcome = user1.call(&worker, nft.id().clone(), "grant")
        .args_json(serde_json::json!({
            "account_id": AccountId::new_unchecked("user1".to_owned()),
        }))?
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "only owner can grant").await;
    
    // Adds a given account to the list of the autorized accounts
    let outcome = owner.call(&worker, nft.id().clone(), "grant")
        .args_json(serde_json::json!({
            "account_id": AccountId::new_unchecked("user1".to_owned()),
        }))?
        .transact()
        .await?;
    check_outcome_success(outcome.clone().status).await;

    // Returns `true` if the new account has been added to the list
    assert!(outcome.json()?, "Returned false");
    assert!(
        is_allowed(
            &worker,
            &nft,
            AccountId::new_unchecked("user1".to_owned())
        ).await?,
        "The user is not authorized"
    );

    // `user1` is already in the list, thus `false` is returned
    let outcome = owner.call(&worker, nft.id().clone(), "grant")
        .args_json(serde_json::json!({
            "account_id": AccountId::new_unchecked("user1".to_owned()),
        }))?
        .transact()
        .await?;
    check_outcome_success(outcome.clone().status).await;
    assert!(!outcome.json()?, "Returned true");

    Ok(())
}

/*
- Can only be called by the owner
- Removes a given account from the list of the autorized accounts
- Returns `true` if the account has been removed from the list, `false` if it hadn't been in the list
*/
#[tokio::test]
async fn permissions_deny() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;
    
    set_private_minting(&worker, nft.id().clone(), &owner, true).await;
    grant(
        &worker,
        nft.id().clone(),
        &owner,
        AccountId::new_unchecked("user1".to_owned())
    ).await?;

    // Can only be called by the owner
    let outcome = user1.call(&worker, nft.id().clone(), "deny")
        .args_json(serde_json::json!({
            "account_id": AccountId::new_unchecked("user1".to_owned()),
        }))?
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "only owner can deny").await;

    // Called by the owner
    let outcome = owner.call(&worker, nft.id().clone(), "deny")
        .args_json(serde_json::json!({
            "account_id": AccountId::new_unchecked("user1".to_owned()),
        }))?
        .transact()
        .await?;
    check_outcome_success(outcome.clone().status).await;

    // Returns `true` if the account has been removed from the list
    assert!(outcome.json()?, "Returned false");
    let result = is_allowed(
        &worker,
        &nft,
        AccountId::new_unchecked("user1".to_owned())
    ).await?;
    assert!(!result, "Not authorized");

    // `user1` is not in the list, thus `false` is returned
    let outcome = owner.call(&worker, nft.id().clone(), "deny")
        .args_json(serde_json::json!({
            "account_id": AccountId::new_unchecked("user1".to_owned()),
        }))?
        .transact()
        .await?;
    check_outcome_success(outcome.clone().status).await;
    assert!(!outcome.json()?, "Returned true");

    Ok(())
}

/*
- Can only be called by the owner
- If `enabled` is true, turns on private minting
- If `enabled` is false, turns off private minting
*/
#[tokio::test]
async fn permissions_set_private_minting() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;

    // Can only be called by the owner
    let outcome = user1.call(&worker, nft.id().clone(), "set_private_minting")
        .args_json(serde_json::json!({
            "enabled": true,
        }))?
        .transact()
        .await?;
    check_outcome_fail(
        outcome.status,
        "only owner can enable/disable private minting"
    ).await;
    assert!(
        is_allowed(
            &worker,
            &nft,
            AccountId::new_unchecked("user1".to_owned())
        ).await?,
        "The authorization is turned on"
    );

    // If `enabled` is true, turns on private minting
    let outcome = owner.call(&worker, nft.id().clone(), "set_private_minting")
        .args_json(serde_json::json!({
            "enabled": true,
        }))?
        .transact()
        .await?;
    check_outcome_success(outcome.status).await;
    assert!(
        !is_allowed(
            &worker,
            &nft,
            AccountId::new_unchecked("user1".to_owned())
        ).await?,
        "The authorization is turned off"
    );

    // If `enabled` is false, turns off private minting
    let outcome = owner.call(&worker, nft.id().clone(), "set_private_minting")
        .args_json(serde_json::json!({
            "enabled": false,
        }))?
        .transact()
        .await?;
    check_outcome_success(outcome.status).await;
    assert!(
        is_allowed(
            &worker,
            &nft,
            AccountId::new_unchecked("user1".to_owned())
        ).await?,
        "The authorization is turned on"
    );
    
    Ok(())
}

/*
- Returns true if private minting is not enabled
- If private minting is enabled, returns whether an account is among private minters
*/
#[tokio::test]
async fn permissions_is_allowed() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    
    // Returns true if private minting is not enabled
    let result = is_allowed(
        &worker,
        &nft,
        AccountId::new_unchecked("user1".to_owned())
    ).await?;
    assert!(result, "Not authorized");

    // If private minting is enabled and `user1` not authorized, returns false 
    set_private_minting(&worker, nft.id().clone(), &owner, true).await;
    let result = is_allowed(
        &worker,
        &nft,
        AccountId::new_unchecked("user1".to_owned())
    ).await?;
    assert!(!result, "Not authorized");

    // If private minting is enabled and `user1` authorized, returns true 
    grant(
        &worker,
        nft.id().clone(),
        &owner, AccountId::new_unchecked("user1".to_owned())
    ).await?;
    let result = is_allowed(
        &worker,
        &nft,
        AccountId::new_unchecked("user1".to_owned())
    ).await?;
    assert!(result, "Authorized");

    Ok(())
}

'''
'''--- tests-workspaces/src/sale.rs ---
use std::{
    collections::HashMap,
    time::{Duration, SystemTime, UNIX_EPOCH},
};

use crate::utils::{
    check_outcome_fail, create_series, create_series_raw, deposit, init_market, init_nft,
    mint_token, nft_approve, offer,
};
use near_contract_standards::non_fungible_token::Token;
use near_units::{parse_gas, parse_near};
use nft_bid_market::{ArgsKind, SaleArgs, SaleJson, BID_HISTORY_LENGTH_DEFAULT};
use nft_contract::common::{AccountId, U128, U64};

/*
- Can only be called via cross-contract call
- `owner_id` must be the signer
- Panics if `owner_id` didn't pay for one more sale/auction
- Panics if the given `ft_token_id` is not supported by the market
- Panics if `msg` doesn't contain valid parameters for sale or auction
 */
#[tokio::test]
async fn nft_on_approve_negative() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user1 = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    let series: String = user1
        .call(&worker, nft.id().clone(), "nft_create_series")
        .args_json(serde_json::json!({
        "token_metadata":
        {
            "title": "some title",
            "media": "ipfs://QmTqZsmhZLLbi8vxZwm21wjKRFRBUQFzMFtTiyh3DJ2CCz",
            "copies": 10
        },
        "royalty":
        {
            owner.id().as_ref(): 1000
        }}))?
        .deposit(parse_near!("0.005 N"))
        .transact()
        .await?
        .json()?;
    let token1 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;

    // try to call nft_on_approve without cross contract call
    let outcome = user1
        .call(&worker, market.id().clone(), "nft_on_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "owner_id": user1.id(),
            "approval_id": 1,
            "msg": serde_json::json!(ArgsKind::Sale(SaleArgs {
                sale_conditions: HashMap::from([("near".parse().unwrap(), 10000.into())]),
                token_type: Some(series.clone()),
                start: None,
                end: None,
                origins: None,
            })).to_string()
        }))?
        .transact()
        .await?;
    check_outcome_fail(
        outcome.status,
        "nft_on_approve should only be called via cross-contract call",
    )
    .await;

    // TODO: to test `owner_id` must be the signer need to create another contract

    // fail without storage deposit
    let outcome = user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Sale(SaleArgs {
                sale_conditions: HashMap::from([("near".parse().unwrap(), 10000.into())]),
                token_type: Some(series.clone()),
                start: None,
                end: None,
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Insufficient storage paid").await;

    // not supported ft
    deposit(&worker, market.id().clone(), &user1).await;
    let outcome = user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Sale(SaleArgs {
                sale_conditions: HashMap::from([("ft.near".parse().unwrap(), 10000.into())]),
                token_type: Some(series),
                start: None,
                end: None,
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Token ft.near not supported by this market").await;

    // bad message, sale/auction shouldn't be added
    let outcome = user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!({
                    "a": "b"
            }).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Not valid args").await;

    Ok(())
}

/*
- Start time is set to `block_timestamp` if it is not specified explicitly
- Creates a new sale/auction
 */
#[tokio::test]
async fn nft_on_approve_positive() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user1 = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    let series: String = user1
        .call(&worker, nft.id().clone(), "nft_create_series")
        .args_json(serde_json::json!({
        "token_metadata":
        {
            "title": "some title",
            "media": "ipfs://QmTqZsmhZLLbi8vxZwm21wjKRFRBUQFzMFtTiyh3DJ2CCz",
            "copies": 10
        },
        "royalty":
        {
            owner.id().as_ref(): 1000
        }}))?
        .deposit(parse_near!("0.005 N"))
        .transact()
        .await?
        .json()?;
    let token1 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;

    deposit(&worker, market.id().clone(), &user1).await;
    user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Sale(SaleArgs {
                sale_conditions: HashMap::from([("near".parse().unwrap(), 10000.into())]),
                token_type: Some(series.clone()),
                start: None,
                end: None,
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    let since_the_epoch = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards");
    let sale_json: SaleJson = market
        .view(
            &worker,
            "get_sale",
            serde_json::json!({
               "nft_contract_id": nft.id(),
               "token_id": token1
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let time_passed = since_the_epoch - Duration::from_nanos(sale_json.start.unwrap().0);
    assert!(time_passed < Duration::from_secs(60)); // shouldn't be 60 secs even in worse case
    Ok(())
}

/**
    - Should panic if there is no sale with given `contract_and_token_id`
    - Should panic if the sale is not in progress
    - Should panic if the NFT owner tries to make a bid on his own sale
    - Should panic if the deposit equal to 0
    - Should panic if the NFT can't be bought by `ft_token_id`
- If the `attached_deposit` is equal to the price + fees
  -  panics if number of payouts plus number of bids exceeds 10
- If the `attached_deposit` is not equal to the price + fees
  - should panic if `ft_token_id` is not supported
  - panics if the bid smaller or equal to the previous one
  - panic if origin fee exceeds ORIGIN_FEE_MAX
    */
#[tokio::test]
async fn offer_negative() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user1 = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    let user2 = owner
        .create_subaccount(&worker, "user2")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    // No sale with given `contract_and_token_id`
    let outcome = user1
        .call(&worker, market.id().clone(), "offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": "1:1",
            "ft_token_id": "near",
        }))?
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "No sale").await;

    // Sale is not in progress
    let series = create_series(&worker, nft.id().clone(), &user1, owner.id().clone()).await?;
    let token1 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;

    deposit(&worker, market.id().clone(), &user1).await;
    let since_the_epoch = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards");
    let waiting_time = Duration::from_secs(15);
    let epoch_plus_waiting_time = (since_the_epoch + waiting_time).as_nanos();
    let sale_conditions = HashMap::from([("near".parse().unwrap(), 10000.into())]);
    user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Sale(SaleArgs {
                sale_conditions: sale_conditions.clone(),
                token_type: Some(series.clone()),
                start: Some(U64(epoch_plus_waiting_time as u64)),
                end: None,
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    let outcome = user2
        .call(&worker, market.id().clone(), "offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
        }))?
        .transact()
        .await?;
    check_outcome_fail(
        outcome.status,
        "Either the sale is finished or it hasn't started yet",
    )
    .await;

    tokio::time::sleep(waiting_time).await;
    let price: U128 = market
        .view(
            &worker,
            "price_with_fees",
            serde_json::json!({
                "price": sale_conditions.get(&AccountId::new_unchecked("near".to_string())).unwrap(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    // NFT owner tries to make a bid on his own sale
    let outcome = user1
        .call(&worker, market.id().clone(), "offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
        }))?
        .deposit(price.into())
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Cannot bid on your own sale.").await;

    // Deposit equal to 0
    let outcome = user2
        .call(&worker, market.id().clone(), "offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
        }))?
        .deposit(0)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Attached deposit must be greater than 0").await;

    // Not supported ft
    let outcome = user2
        .call(&worker, market.id().clone(), "offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "nearcoin",
        }))?
        .deposit(1000)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Not supported ft").await;

    // the bid smaller or equal to the previous one
    user2
        .call(&worker, market.id().clone(), "offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
        }))?
        .deposit(500)
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    let outcome = user2
        .call(&worker, market.id().clone(), "offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
        }))?
        .deposit(400) // less
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(
        outcome.status,
        "Can't pay less than or equal to current bid price:",
    )
    .await;
    let outcome = user2
        .call(&worker, market.id().clone(), "offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
        }))?
        .deposit(500) // equal
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(
        outcome.status,
        "Can't pay less than or equal to current bid price:",
    )
    .await;

    // Exceeding ORIGIN_FEE_MAX
    let outcome = user2
        .call(&worker, market.id().clone(), "offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
            "origins": {
                "user1": 4701,
            }
        }))?
        .deposit(2000) // equal
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Max origins exceeded").await;

    // number of payouts plus number of bids exceeds 10
    let too_much_origins: HashMap<AccountId, u32> = HashMap::from([
        ("acc1.near".parse().unwrap(), 100),
        ("acc2.near".parse().unwrap(), 100),
        ("acc3.near".parse().unwrap(), 100),
        ("acc4.near".parse().unwrap(), 100),
        ("acc5.near".parse().unwrap(), 100),
        ("acc6.near".parse().unwrap(), 100),
        ("acc7.near".parse().unwrap(), 100),
        ("acc8.near".parse().unwrap(), 100),
        ("acc9.near".parse().unwrap(), 100),
        ("acc10.near".parse().unwrap(), 100),
        ("acc11.near".parse().unwrap(), 100),
        ("acc12.near".parse().unwrap(), 100),
    ]);
    let price: U128 = market
        .view(
            &worker,
            "price_with_fees",
            serde_json::json!({
                "price": sale_conditions.get(&AccountId::new_unchecked("near".to_string())).unwrap(),
                "origins": too_much_origins
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    let outcome = user2
        .call(&worker, market.id().clone(), "offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
        }))?
        .deposit(price.into())
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    // Promise of offer returning empty value, because of panic on nft_transfer_payout, but
    // TODO: we need to check Failure on nft contract when workspaces add feature to check not only FinalExecutionStatus
    if let near_primitives::views::FinalExecutionStatus::SuccessValue(empty_string) = outcome.status
    {
        assert!(empty_string.is_empty())
    } else {
        panic!("Expected failure {:?}", outcome.status)
    };

    Ok(())
}

/*
- If the `attached_deposit` is equal to the price + fees
    -  NFT is transferred to the buyer
    -  the sale is removed from the list of sales
    -  ft transferred to the previous owner
    -  protocol, royalty and origin fees are paid
    -  royalty paid from seller side
    -  previous bids refunded
- If the `attached_deposit` is not equal to the price + fees
  - a new bid should be added
  - if the number of stored bids exceeds `bid_history_length`, the earliest bid is removed and refunded
*/
#[tokio::test]
async fn offer_positive() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user1 = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    let user2 = owner
        .create_subaccount(&worker, "user2")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    let series = create_series(&worker, nft.id().clone(), &user1, owner.id().clone()).await?;
    let token1 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;

    deposit(&worker, market.id().clone(), &user1).await;
    let sale_conditions = HashMap::from([("near".parse().unwrap(), 10000.into())]);
    nft_approve(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user1,
        token1.clone(),
        sale_conditions.clone(),
        series.clone(),
    )
    .await;
    let price: U128 = market
        .view(
            &worker,
            "price_with_fees",
            serde_json::json!({
                "price": sale_conditions.get(&AccountId::new_unchecked("near".to_string())).unwrap(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    let before_sell: Option<SaleJson> = market
        .view(
            &worker,
            "get_sale",
            serde_json::json!({
               "nft_contract_id": nft.id(),
               "token_id": token1
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    user2
        .call(&worker, market.id().clone(), "offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
        }))?
        .deposit(price.into())
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;

    let token: Token = nft
        .view(
            &worker,
            "nft_token",
            serde_json::json!({ "token_id": token1 })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;

    // NFT is transferred to the buyer
    assert_eq!(token.owner_id.as_str(), user2.id().as_ref());
    // the sale is removed from the list of sales
    let after_sell: Option<SaleJson> = market
        .view(
            &worker,
            "get_sale",
            serde_json::json!({
               "nft_contract_id": nft.id(),
               "token_id": token1
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;

    assert!(
        after_sell.is_none(),
        "Sale is still active, when it shouldn't"
    );
    assert!(
        before_sell.is_some(),
        "Sale is not active, when it should be"
    );

    // Check if bids can be added
    let token2 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;
    let sale_conditions = HashMap::from([("near".parse().unwrap(), 10000.into())]);
    nft_approve(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user1,
        token2.clone(),
        sale_conditions.clone(),
        series.clone(),
    )
    .await;
    let initial_price = 100;
    user2
        .call(&worker, market.id().clone(), "offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token2,
            "ft_token_id": "near",
        }))?
        .deposit(initial_price)
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    let sale_json: SaleJson = market
        .view(
            &worker,
            "get_sale",
            serde_json::json!({
               "nft_contract_id": nft.id(),
               "token_id": token2
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    let bids = sale_json
        .bids
        .get(&AccountId::new_unchecked("near".to_string()))
        .unwrap();
    assert!(bids.get(0).is_some(), "Bid not added");

    let first_bid = bids.get(0).unwrap();
    // Earliest bid should be removed
    for i in 1..=BID_HISTORY_LENGTH_DEFAULT {
        user2
            .call(&worker, market.id().clone(), "offer")
            .args_json(serde_json::json!({
                "nft_contract_id": nft.id(),
                "token_id": token2,
                "ft_token_id": "near",
            }))?
            .deposit(initial_price * (i + 1) as u128)
            .gas(parse_gas!("300 Tgas") as u64)
            .transact()
            .await?;
        let sale_json: SaleJson = market
            .view(
                &worker,
                "get_sale",
                serde_json::json!({
                   "nft_contract_id": nft.id(),
                   "token_id": token2
                })
                .to_string()
                .into_bytes(),
            )
            .await?
            .json()?;
        let bids = sale_json
            .bids
            .get(&AccountId::new_unchecked("near".to_string()))
            .unwrap();
        if i < BID_HISTORY_LENGTH_DEFAULT {
            assert_eq!(bids.get(0).unwrap(), first_bid);
        }
    }
    // new bid removed last bid
    let sale_json: SaleJson = market
        .view(
            &worker,
            "get_sale",
            serde_json::json!({
               "nft_contract_id": nft.id(),
               "token_id": token2
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    let bids = sale_json
        .bids
        .get(&AccountId::new_unchecked("near".to_string()))
        .unwrap();

    assert_ne!(bids.get(0).unwrap(), first_bid);
    Ok(())
}

/*
- Should panic if there is no sale with the given `nft_contract_id` and `token_id`
- Should panic if there are no bids with given fungible token
- Should panic if the sale is not in progress
- Should panic if the last bid is out of time
 */
#[tokio::test]
async fn accept_offer_negative() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user1 = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    let user2 = owner
        .create_subaccount(&worker, "user2")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();
    let series = create_series_raw(
        &worker,
        nft.id().clone(),
        &user1,
        Some(4),
        HashMap::from([(user1.id(), 500)]),
    )
    .await?;
    let token1 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;
    deposit(&worker, market.id().clone(), &user1).await;

    // No sale with the given `nft_contract_id` and `token_id`
    let outcome = user1
        .call(&worker, market.id().clone(), "accept_offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
        }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "No sale").await;

    // no bids with given fungible token
    let sale_conditions = HashMap::from([("near".parse().unwrap(), 42000.into())]);
    let since_the_epoch = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards");
    let waiting_time = Duration::from_secs(10);
    let epoch_plus_waiting_time = (since_the_epoch + waiting_time).as_nanos();
    user1
        .call(&worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token1,
            "account_id": market.id(),
            "msg": serde_json::json!(ArgsKind::Sale(SaleArgs {
                sale_conditions: sale_conditions.clone(),
                token_type: Some(series.clone()),
                start: None,
                end: Some(U64(epoch_plus_waiting_time as u64)),
                origins: None,
            })).to_string()
        }))?
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await?;
    let outcome = user1
        .call(&worker, market.id().clone(), "accept_offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
        }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "No bids").await;

    // last bid is out of time
    user2
        .call(&worker, market.id().clone(), "offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
            "duration": "1",
        }))?
        .deposit(200)
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    tokio::time::sleep(Duration::from_nanos(1)).await;
    let outcome = user1
        .call(&worker, market.id().clone(), "accept_offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
        }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Out of time limit of the bid").await;
    // Sale is not in progress
    tokio::time::sleep(waiting_time).await;
    let outcome = user1
        .call(&worker, market.id().clone(), "accept_offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
        }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    check_outcome_fail(
        outcome.status,
        "Either the sale is finished or it hasn't started yet",
    )
    .await;
    Ok(())
}

// - Nft transfered to the buyer
#[tokio::test]
async fn accept_offer_positive() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user1 = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    let user2 = owner
        .create_subaccount(&worker, "user2")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();
    let series = create_series_raw(
        &worker,
        nft.id().clone(),
        &user1,
        Some(4),
        HashMap::from([(user1.id(), 500)]),
    )
    .await?;
    let token1 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;
    deposit(&worker, market.id().clone(), &user1).await;
    let sale_conditions = HashMap::from([("near".parse().unwrap(), 42000.into())]);
    nft_approve(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user1,
        token1.clone(),
        sale_conditions.clone(),
        series.clone(),
    )
    .await;
    user2
        .call(&worker, market.id().clone(), "offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
        }))?
        .deposit(200)
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    user1
        .call(&worker, market.id().clone(), "accept_offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
        }))?
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await?;
    let token_data: Token = nft
        .view(
            &worker,
            "nft_token",
            serde_json::json!({ "token_id": token1 })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(token_data.owner_id.as_ref(), user2.id().as_ref());
    Ok(())
}

/*
- Should panic unless 1 yoctoNEAR is attached
- Should panic if there is no sale with the given `nft_contract_id` and `token_id`
- Should panic unless it is called by the creator of the sale
- Should panic if `ft_token_id` is not supported
*/
#[tokio::test]
async fn update_price_negative() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user1 = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    let user2 = owner
        .create_subaccount(&worker, "user2")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();
    let series = create_series_raw(
        &worker,
        nft.id().clone(),
        &user1,
        Some(4),
        HashMap::from([(user1.id(), 500)]),
    )
    .await?;
    let token1 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;
    deposit(&worker, market.id().clone(), &user1).await;
    let sale_conditions = HashMap::from([("near".parse().unwrap(), 42000.into())]);
    nft_approve(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user1,
        token1.clone(),
        sale_conditions.clone(),
        series.clone(),
    )
    .await;

    // not attaching 1 yocto
    let outcome = user1
        .call(&worker, market.id().clone(), "update_price")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
            "price": "10000",
        }))?
        .transact()
        .await?;
    check_outcome_fail(
        outcome.status,
        "Requires attached deposit of exactly 1 yoctoNEAR",
    )
    .await;

    // no sale with given nft_contract_id:token_id
    let outcome = user1
        .call(&worker, market.id().clone(), "update_price")
        .args_json(serde_json::json!({
            "nft_contract_id": market.id(),
            "token_id": token1,
            "ft_token_id": "near",
            "price": "10000",
        }))?
        .deposit(1)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "No sale").await;

    // called not by the owner
    let outcome = user2
        .call(&worker, market.id().clone(), "update_price")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
            "price": "10000",
        }))?
        .deposit(1)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "Must be sale owner").await;

    // ft must be supported
    let outcome = user1
        .call(&worker, market.id().clone(), "update_price")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "nearcoin",
            "price": "10000",
        }))?
        .deposit(1)
        .transact()
        .await?;
    check_outcome_fail(outcome.status, "is not supported by this market").await;
    Ok(())
}

// Changes the price
#[tokio::test]
async fn update_price_positive() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user1 = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    let series = create_series_raw(
        &worker,
        nft.id().clone(),
        &user1,
        Some(4),
        HashMap::from([(user1.id(), 500)]),
    )
    .await?;
    let token1 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;
    deposit(&worker, market.id().clone(), &user1).await;
    let sale_conditions = HashMap::from([("near".parse().unwrap(), 42000.into())]);
    nft_approve(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user1,
        token1.clone(),
        sale_conditions.clone(),
        series.clone(),
    )
    .await;
    user1
        .call(&worker, market.id().clone(), "update_price")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1,
            "ft_token_id": "near",
            "price": "10000",
        }))?
        .deposit(1)
        .transact()
        .await?;

    let sale_json: SaleJson = market
        .view(
            &worker,
            "get_sale",
            serde_json::json!({
               "nft_contract_id": nft.id(),
               "token_id": token1
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(
        sale_json.sale_conditions.get(&"near".parse().unwrap()),
        Some(&U128(10000))
    );
    Ok(())
}

/*
- Should panic unless 1 yoctoNEAR is attached
- If the sale in progress, only the sale creator can remove the sale
 */
#[tokio::test]
async fn remove_sale_negative() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user1 = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    let user2 = owner
        .create_subaccount(&worker, "user2")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    let series = create_series_raw(
        &worker,
        nft.id().clone(),
        &user1,
        Some(4),
        HashMap::from([(user1.id(), 500)]),
    )
    .await?;
    let token1 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;
    deposit(&worker, market.id().clone(), &user1).await;
    let sale_conditions = HashMap::from([("near".parse().unwrap(), 42000.into())]);
    nft_approve(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user1,
        token1.clone(),
        sale_conditions.clone(),
        series.clone(),
    )
    .await;

    // 1 yocto is needed
    let outcome = user1
        .call(&worker, market.id().clone(), "remove_sale")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1
        }))?
        .transact()
        .await?;
    check_outcome_fail(
        outcome.status,
        "Requires attached deposit of exactly 1 yoctoNEAR",
    )
    .await;

    // Can be removed only by the owner of the sale, if not finished
    let outcome = user2
        .call(&worker, market.id().clone(), "remove_sale")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1
        }))?
        .deposit(1)
        .transact()
        .await?;
    check_outcome_fail(
        outcome.status,
        "Until the sale is finished, it can only be removed by the sale owner",
    )
    .await;
    Ok(())
}

/*
- Sale removed
- Refunds all bids
*/
#[tokio::test]
async fn remove_sale_positive() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user1 = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    let user2 = owner
        .create_subaccount(&worker, "user2")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();

    let series = create_series_raw(
        &worker,
        nft.id().clone(),
        &user1,
        Some(4),
        HashMap::from([(user1.id(), 500)]),
    )
    .await?;
    let token1 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;
    deposit(&worker, market.id().clone(), &user1).await;
    let sale_conditions = HashMap::from([("near".parse().unwrap(), 42000.into())]);
    nft_approve(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user1,
        token1.clone(),
        sale_conditions.clone(),
        series.clone(),
    )
    .await;
    offer(
        &worker,
        nft.id().clone(),
        market.id().clone(),
        &user2,
        token1.clone(),
        4000.into(),
    )
    .await;
    user1
        .call(&worker, market.id().clone(), "remove_sale")
        .args_json(serde_json::json!({
            "nft_contract_id": nft.id(),
            "token_id": token1
        }))?
        .deposit(1)
        .transact()
        .await?;
    let sale_json: Option<SaleJson> = market
        .view(
            &worker,
            "get_sale",
            serde_json::json!({
               "nft_contract_id": nft.id(),
               "token_id": token1
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert!(sale_json.is_none());
    Ok(())
}

'''
'''--- tests-workspaces/src/sale_views.rs ---
use std::collections::HashMap;

use near_units::{parse_gas, parse_near};
use nft_bid_market::SaleJson;
use nft_contract::common::U64;

use crate::utils::{create_series, deposit, init_market, init_nft, mint_token, nft_approve, offer};

#[tokio::test]
async fn sale_views() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;
    let market = init_market(&worker, worker.root_account().id(), vec![nft.id()]).await?;

    let user1 = owner
        .create_subaccount(&worker, "user1")
        .initial_balance(parse_near!("100 N"))
        .transact()
        .await?
        .unwrap();

    let user2 = owner
        .create_subaccount(&worker, "user2")
        .initial_balance(parse_near!("100 N"))
        .transact()
        .await?
        .unwrap();

    let series1 = create_series(&worker, nft.id().clone(), &user1, owner.id().clone()).await?;
    let mut tokens_series1 = vec![];
    for _ in 0..3 {
        tokens_series1
            .push(mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series1).await?);
    }
    let series2 = create_series(&worker, nft.id().clone(), &user2, owner.id().clone()).await?;
    let mut tokens_series2 = vec![];
    for _ in 0..2 {
        tokens_series2
            .push(mint_token(&worker, nft.id().clone(), &user2, user2.id(), &series2).await?);
    }
    deposit(&worker, market.id().clone(), &user1).await;
    deposit(&worker, market.id().clone(), &user2).await;
    let sale_conditions = HashMap::from([("near".parse().unwrap(), 10000.into())]);
    for token1 in tokens_series1.iter() {
        nft_approve(
            &worker,
            nft.id().clone(),
            market.id().clone(),
            &user1,
            token1.clone(),
            sale_conditions.clone(),
            series1.clone(),
        )
        .await;
    }
    for token2 in tokens_series2.iter() {
        nft_approve(
            &worker,
            nft.id().clone(),
            market.id().clone(),
            &user2,
            token2.clone(),
            sale_conditions.clone(),
            series2.clone(),
        )
        .await;
    }

    let supply_sales: U64 = market
        .view(&worker, "get_supply_sales", vec![])
        .await?
        .json()?;
    assert_eq!(
        supply_sales.0 as usize,
        tokens_series1.len() + tokens_series2.len()
    );

    let sales: Vec<SaleJson> = market
        .view(
            &worker,
            "get_sales",
            serde_json::json!({}).to_string().into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(sales.len(), tokens_series1.len() + tokens_series2.len());
    assert!(
        tokens_series1.contains(&sales[1].token_id) || tokens_series2.contains(&sales[1].token_id)
    );

    let supply_by_owner: U64 = market
        .view(
            &worker,
            "get_supply_by_owner_id",
            serde_json::json!({
                "account_id": user1.id()
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(supply_by_owner.0 as usize, tokens_series1.len());

    let sales_user2: Vec<SaleJson> = market
        .view(
            &worker,
            "get_sales_by_owner_id",
            serde_json::json!({
                "account_id": user2.id(),
                "from_index": "0",
                "limit": 10,
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(sales_user2.len(), tokens_series2.len());
    assert!(tokens_series2.contains(&sales_user2[1].token_id));

    let supply_by_nft_contract: U64 = market
        .view(
            &worker,
            "get_supply_by_nft_contract_id",
            serde_json::json!({
                "nft_contract_id": nft.id()
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(
        supply_by_nft_contract.0 as usize,
        tokens_series1.len() + tokens_series2.len()
    );

    let sales_nft_contract_id: Vec<SaleJson> = market
        .view(
            &worker,
            "get_sales_by_nft_contract_id",
            serde_json::json!({
                "nft_contract_id": nft.id(),
                "from_index": "0",
                "limit": 10,
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(
        sales_nft_contract_id.len(),
        tokens_series1.len() + tokens_series2.len()
    );
    assert!(
        tokens_series1.contains(&sales_nft_contract_id[1].token_id)
            || tokens_series2.contains(&sales_nft_contract_id[1].token_id)
    );

    let supply_by_nft_token_type: U64 = market
        .view(
            &worker,
            "get_supply_by_nft_token_type",
            serde_json::json!({ "token_type": series1 })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(supply_by_nft_token_type.0 as usize, tokens_series1.len());

    let sales_nft_token_type: Vec<SaleJson> = market
        .view(
            &worker,
            "get_sales_by_nft_token_type",
            serde_json::json!({
                "token_type": series2,
                "from_index": "0",
                "limit": 10,
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(sales_nft_token_type.len(), tokens_series2.len());
    assert!(tokens_series2.contains(&sales_nft_token_type[1].token_id));

    // check if removing also works correct
    {
        // case1: removed after sale
        let removed_token = tokens_series1[1].clone();
        let sale_json: Option<SaleJson> = market
            .view(
                &worker,
                "get_sale",
                serde_json::json!({
                   "nft_contract_id": nft.id(),
                   "token_id": removed_token
                })
                .to_string()
                .into_bytes(),
            )
            .await?
            .json()?;
        assert!(sale_json.is_some());
        offer(
            &worker,
            nft.id().clone(),
            market.id().clone(),
            &user2,
            tokens_series1[1].clone(),
            500.into(),
        )
        .await;
        user1
            .call(&worker, market.id().clone(), "accept_offer")
            .args_json(serde_json::json!({
                "nft_contract_id": nft.id(),
                "token_id": tokens_series1[1],
                "ft_token_id": "near",
            }))?
            .gas(parse_gas!("300 Tgas") as u64)
            .transact()
            .await?;
        tokens_series1.remove(1);
        let sale_json: Option<SaleJson> = market
            .view(
                &worker,
                "get_sale",
                serde_json::json!({
                   "nft_contract_id": nft.id(),
                   "token_id": removed_token
                })
                .to_string()
                .into_bytes(),
            )
            .await?
            .json()?;
        assert!(sale_json.is_none());
        // case2: removed after sale removed
        user2
            .call(&worker, market.id().clone(), "remove_sale")
            .args_json(serde_json::json!({
                "nft_contract_id": nft.id(),
                "token_id": tokens_series2[1]
            }))?
            .deposit(1)
            .transact()
            .await?;
        tokens_series2.remove(1);
    }

    // back to tests
    let supply_sales: U64 = market
        .view(&worker, "get_supply_sales", vec![])
        .await?
        .json()?;
    assert_eq!(
        supply_sales.0 as usize,
        tokens_series1.len() + tokens_series2.len()
    );

    let sales: Vec<SaleJson> = market
        .view(
            &worker,
            "get_sales",
            serde_json::json!({}).to_string().into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(sales.len(), tokens_series1.len() + tokens_series2.len());
    assert!(
        tokens_series1.contains(&sales[1].token_id) || tokens_series2.contains(&sales[1].token_id)
    );

    let supply_by_owner: U64 = market
        .view(
            &worker,
            "get_supply_by_owner_id",
            serde_json::json!({
                "account_id": user1.id()
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(supply_by_owner.0 as usize, tokens_series1.len());

    let sales_user2: Vec<SaleJson> = market
        .view(
            &worker,
            "get_sales_by_owner_id",
            serde_json::json!({
                "account_id": user2.id(),
                "from_index": "0",
                "limit": 10,
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(sales_user2.len(), tokens_series2.len());
    assert!(tokens_series2.contains(&sales_user2[0].token_id));

    let supply_by_nft_contract: U64 = market
        .view(
            &worker,
            "get_supply_by_nft_contract_id",
            serde_json::json!({
                "nft_contract_id": nft.id()
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(
        supply_by_nft_contract.0 as usize,
        tokens_series1.len() + tokens_series2.len()
    );

    let sales_nft_contract_id: Vec<SaleJson> = market
        .view(
            &worker,
            "get_sales_by_nft_contract_id",
            serde_json::json!({
                "nft_contract_id": nft.id(),
                "from_index": "0",
                "limit": 10,
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(
        sales_nft_contract_id.len(),
        tokens_series1.len() + tokens_series2.len()
    );
    assert!(
        tokens_series1.contains(&sales_nft_contract_id[1].token_id)
            || tokens_series2.contains(&sales_nft_contract_id[1].token_id)
    );

    let supply_by_nft_token_type: U64 = market
        .view(
            &worker,
            "get_supply_by_nft_token_type",
            serde_json::json!({ "token_type": series1 })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(supply_by_nft_token_type.0 as usize, tokens_series1.len());

    let sales_nft_token_type: Vec<SaleJson> = market
        .view(
            &worker,
            "get_sales_by_nft_token_type",
            serde_json::json!({
                "token_type": series2,
                "from_index": "0",
                "limit": 10,
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(sales_nft_token_type.len(), tokens_series2.len());
    assert!(tokens_series2.contains(&sales_nft_token_type[0].token_id));
    Ok(())
}

'''
'''--- tests-workspaces/src/series_views.rs ---
use crate::utils::{
    init_nft, create_subaccount, 
    create_series, mint_token
};
use nft_contract::TokenSeriesJson;
use nft_contract::common::{AccountId, U128};

/*
- Panics if the series wasn't found
- Returns the series with given `token_series_id`
*/
#[tokio::test]
async fn series_views_nft_get_series() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;

    let _series = create_series(&worker, nft.id().clone(), &user1, owner.id().clone()).await?;

    // Check that method fails in case of wrong `token_series_id` 
    let outcome = nft
        .view(
            &worker,
            "nft_get_series",
            serde_json::json!({ "token_series_id": "42".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await;
    match outcome {
        Err(err) => {
            println!("{}", err); 
        },
        Ok(_) => panic!("Expected failure"),
    };

    let token_series: TokenSeriesJson = nft
        .view(
            &worker,
            "nft_get_series",
            serde_json::json!({ "token_series_id": "1".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;

    assert_eq!(token_series.owner_id, AccountId::new_unchecked("user1.test.near".to_owned()));
    assert_eq!(token_series.metadata.title, Some("some title".to_string()));
    assert_eq!(token_series.metadata.media, Some("ipfs://QmTqZsmhZLLbi8vxZwm21wjKRFRBUQFzMFtTiyh3DJ2CCz".to_string()));
    assert_eq!(token_series.metadata.copies, Some(10));

    Ok(())
}

/*
- Panics in case of incorrect `from_index` or `limit`
- Returns a vector of series
*/
#[tokio::test]
async fn series_views_nft_series() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;
    let user2 = create_subaccount(&worker, &owner, "user2").await?;

    let _series1 = create_series(&worker, nft.id().clone(), &user1, owner.id().clone()).await?;
    
    // Check that method fails in case of wrong `from_index` 
    let outcome = nft
        .view(
            &worker,
            "nft_series",
            serde_json::json!({ "from_index": "42".to_string(), "limit": 43 })
                .to_string()
                .into_bytes(),
        )
        .await;
    match outcome {
        Err(err) => {
            println!("{}", err); 
        },
        Ok(_) => panic!("Expected failure"),
    };

    // Check that method fails in case of wrong `limit`
    let outcome = nft
        .view(
            &worker,
            "nft_series",
            serde_json::json!({ "from_index": "1".to_string(), "limit": 0 })
                .to_string()
                .into_bytes(),
        )
        .await;
    match outcome {
        Err(err) => {
            println!("{}", err); 
        },
        Ok(_) => panic!("Expected failure"),
    };

    let vec_token_series: Vec<TokenSeriesJson> = nft
        .view(
            &worker,
            "nft_series",
            serde_json::json!({  })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(vec_token_series.len(), 1);
    let token = &vec_token_series[0];
    assert_eq!(token.owner_id, AccountId::new_unchecked("user1.test.near".to_owned()));
    assert_eq!(token.metadata.title, Some("some title".to_string()));
    assert_eq!(token.metadata.media, Some("ipfs://QmTqZsmhZLLbi8vxZwm21wjKRFRBUQFzMFtTiyh3DJ2CCz".to_string()));
    assert_eq!(token.metadata.copies, Some(10));

    let _series2 = create_series(&worker, nft.id().clone(), &user1, owner.id().clone()).await?;
    let _series3 = create_series(&worker, nft.id().clone(), &user2, owner.id().clone()).await?;

    let vec_token_series: Vec<TokenSeriesJson> = nft
        .view(
            &worker,
            "nft_series",
            serde_json::json!({  })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(vec_token_series.len(), 3);
    Ok(())
}

/*
- Panics if the series wasn't found
- Returns the number of tokens in the series
*/
#[tokio::test]
async fn series_views_nft_supply_for_series() -> anyhow::Result<()> {
    let worker = workspaces::sandbox();
    let owner = worker.root_account();
    let nft = init_nft(&worker, owner.id()).await?;

    let user1 = create_subaccount(&worker, &owner, "user1").await?;

    let series = create_series(&worker, nft.id().clone(), &user1, owner.id().clone()).await?;

    // Check that method fails in case of wrong `token_series_id` 
    let outcome = nft
        .view(
            &worker,
            "nft_supply_for_series",
            serde_json::json!({ "token_series_id": "42".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await;
    match outcome {
        Err(err) => {
            println!("{}", err); 
        },
        Ok(_) => panic!("Expected failure"),
    };

    let supply: U128 = nft
        .view(
            &worker,
            "nft_supply_for_series",
            serde_json::json!({ "token_series_id": "1".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(supply.0, 0);

    let _token1 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;

    let supply: U128 = nft
        .view(
            &worker,
            "nft_supply_for_series",
            serde_json::json!({ "token_series_id": "1".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(supply.0, 1);

    let _token2 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;
    let _token3 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;
    let _token4 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;
    let _token5 = mint_token(&worker, nft.id().clone(), &user1, user1.id(), &series).await?;

    let supply: U128 = nft
        .view(
            &worker,
            "nft_supply_for_series",
            serde_json::json!({ "token_series_id": "1".to_string() })
                .to_string()
                .into_bytes(),
        )
        .await?
        .json()?;
    assert_eq!(supply.0, 5);

    Ok(())
}

'''
'''--- tests-workspaces/src/utils.rs ---
use near_contract_standards::non_fungible_token::Token;
use near_units::parse_gas;
use near_units::parse_near;
use nft_bid_market::Fees;
use nft_bid_market::{ArgsKind, SaleArgs};
use nft_contract::common::TokenMetadata;
use nft_contract::common::{AccountId, U128, U64};
use nft_contract::Payout;
use std::collections::HashMap;
use workspaces::prelude::*;
use workspaces::{Account, Contract, DevNetwork, Worker};

use near_primitives::views::FinalExecutionStatus;

const NFT_WASM_FILEPATH: &str = "../res/nft_contract.wasm";
const MARKET_WASM_FILEPATH: &str = "../res/nft_bid_market.wasm";

pub async fn init_nft(
    worker: &workspaces::Worker<impl DevNetwork>,
    root_id: &workspaces::AccountId,
) -> anyhow::Result<workspaces::Contract> {
    let wasm = std::fs::read(NFT_WASM_FILEPATH)?;
    let contract = worker.dev_deploy(wasm).await?;
    let outcome = contract
        .call(worker, "new_default_meta")
        .args_json(serde_json::json!({
            "owner_id": root_id,
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;
    match outcome.status {
        near_primitives::views::FinalExecutionStatus::SuccessValue(_) => (),
        _ => panic!(),
    };
    Ok(contract)
}

pub async fn init_market(
    worker: &workspaces::Worker<impl DevNetwork>,
    root_id: &workspaces::AccountId,
    nft_ids: Vec<&workspaces::AccountId>,
) -> anyhow::Result<workspaces::Contract> {
    let wasm = std::fs::read(MARKET_WASM_FILEPATH)?;
    let contract = worker.dev_deploy(wasm).await?;
    let outcome = contract
        .call(worker, "new")
        .args_json(serde_json::json!({
            "nft_ids": nft_ids,
            "owner_id": root_id,
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;
    match outcome.status {
        near_primitives::views::FinalExecutionStatus::SuccessValue(_) => (),
        _ => panic!(),
    };
    Ok(contract)
}

pub async fn mint_token(
    worker: &workspaces::Worker<impl DevNetwork>,
    nft_id: workspaces::AccountId,
    minter_id: &workspaces::Account,
    receiver_id: &workspaces::AccountId,
    series: &str,
) -> anyhow::Result<String> {
    let token_id = minter_id
        .call(worker, nft_id, "nft_mint")
        .args_json(serde_json::json!({
            "token_series_id": series,
            "receiver_id": receiver_id.as_ref()
        }))?
        .deposit(parse_near!("0.01 N"))
        .transact()
        .await?
        .json()?;
    Ok(token_id)
}

pub async fn check_outcome_success(status: FinalExecutionStatus) {
    assert!(
        matches!(
            status,
            near_primitives::views::FinalExecutionStatus::SuccessValue(_)
        ),
        "Panic: {:?}",
        status
    );
}

pub async fn check_outcome_fail(status: FinalExecutionStatus, expected_err: &str) {
    if let near_primitives::views::FinalExecutionStatus::Failure(err) = status {
        assert!(
            err.to_string().contains(expected_err),
            "actual error: {}",
            err
        )
    } else {
        panic!("Expected failure, got: {:?}", status);
    };
}

pub async fn create_subaccount(
    worker: &Worker<impl DevNetwork>,
    owner: &Account,
    user_id: &str,
) -> anyhow::Result<Account> {
    let user = owner
        .create_subaccount(worker, user_id)
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .unwrap();
    Ok(user)
}

pub async fn create_series(
    worker: &Worker<impl DevNetwork>,
    nft: workspaces::AccountId,
    user: &Account,
    owner: workspaces::AccountId,
) -> anyhow::Result<String> {
    let series: String = user
        .call(worker, nft, "nft_create_series")
        .args_json(serde_json::json!({
        "token_metadata":
        {
            "title": "some title",
            "media": "ipfs://QmTqZsmhZLLbi8vxZwm21wjKRFRBUQFzMFtTiyh3DJ2CCz",
            "copies": 10
        },
        "royalty":
        {
            owner.as_ref(): 1000
        }}))?
        .deposit(parse_near!("0.005 N"))
        .transact()
        .await?
        .json()?;
    Ok(series)
}

pub async fn deposit(
    worker: &Worker<impl DevNetwork>,
    market: workspaces::AccountId,
    user: &Account,
) {
    user.call(worker, market, "storage_deposit")
        .deposit(parse_near!("1 N"))
        .transact()
        .await
        .unwrap();
}

pub async fn nft_approve(
    worker: &Worker<impl DevNetwork>,
    nft: workspaces::AccountId,
    market: workspaces::AccountId,
    user: &Account,
    token: String,
    sale_conditions: HashMap<AccountId, U128>,
    series: String,
) {
    user.call(worker, nft.clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token,
            "account_id": market,
            "msg": serde_json::json!(ArgsKind::Sale(SaleArgs {
                sale_conditions,
                token_type: Some(series),
                start: None,
                end: None,
                origins: None,
            })).to_string()
        }))
        .unwrap()
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await
        .unwrap();
}

pub async fn price_with_fees(
    worker: &Worker<impl DevNetwork>,
    market: &Contract,
    sale_conditions: HashMap<AccountId, U128>,
) -> anyhow::Result<U128> {
    let price: U128 = market
        .view(
            worker,
            "price_with_fees",
            serde_json::json!({
                "price": sale_conditions.get(&AccountId::new_unchecked("near".to_string())).unwrap(),
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    Ok(price)
}

pub async fn offer(
    worker: &Worker<impl DevNetwork>,
    nft: workspaces::AccountId,
    market: workspaces::AccountId,
    user: &Account,
    token: String,
    price: U128,
) {
    user.call(worker, market.clone(), "offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft,
            "token_id": token,
            "ft_token_id": "near",
        }))
        .unwrap()
        .deposit(price.into())
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await
        .unwrap();
}

pub async fn create_series_raw(
    worker: &Worker<impl DevNetwork>,
    nft: workspaces::AccountId,
    owner: &Account,
    copies: Option<u64>,
    royalty: HashMap<&workspaces::AccountId, u64>,
) -> anyhow::Result<String> {
    let token_metadata = TokenMetadata {
        title: Some("some title".to_string()),
        description: None,
        media: Some("ipfs://QmTqZsmhZLLbi8vxZwm21wjKRFRBUQFzMFtTiyh3DJ2CCz".to_string()),
        media_hash: None,
        copies,
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    };
    Ok(owner
        .call(worker, nft, "nft_create_series")
        .args_json(serde_json::json!({
                "token_metadata": token_metadata,
                "royalty": royalty
        }))?
        .deposit(parse_near!("0.005 N"))
        .transact()
        .await?
        .json()?)
}

pub async fn offer_with_duration(
    worker: &Worker<impl DevNetwork>,
    nft: workspaces::AccountId,
    market: workspaces::AccountId,
    user: &Account,
    token: String,
    price: U128,
    duration: U64,
) {
    user.call(worker, market.clone(), "offer")
        .args_json(serde_json::json!({
            "nft_contract_id": nft,
            "token_id": token,
            "ft_token_id": "near",
            "duration": duration
        }))
        .unwrap()
        .deposit(price.into())
        .gas(parse_gas!("300 Tgas") as u64)
        .transact()
        .await
        .unwrap();
}

pub async fn nft_transfer_payout_helper(
    worker: &Worker<impl DevNetwork>,
    nft: &Contract,
    user1: &Account,
    user2: &Account,
    user3: &Account,
    royalty: HashMap<&workspaces::AccountId, u64>,
    fees: Fees,
    balance: U128,
) -> Payout {
    let series = create_series_raw(worker, nft.id().clone(), user1, Some(4), royalty)
        .await
        .unwrap();

    let token_id = mint_token(worker, nft.id().clone(), user1, user1.id(), &series)
        .await
        .unwrap();
    user1
        .call(worker, nft.id().clone(), "nft_approve")
        .args_json(serde_json::json!({
            "token_id": token_id,
            "account_id": user2.id(),
        }))
        .unwrap()
        .deposit(parse_near!("1 N"))
        .gas(parse_gas!("200 Tgas") as u64)
        .transact()
        .await
        .unwrap();
    let approval_id: u64 = {
        let token: Token = nft
            .view(
                worker,
                "nft_token",
                serde_json::json!({ "token_id": token_id })
                    .to_string()
                    .into_bytes(),
            )
            .await
            .unwrap()
            .json()
            .unwrap();
        let approval_account_ids = token.approved_account_ids.unwrap();
        *approval_account_ids
            .get(&user2.id().as_ref().parse().unwrap())
            .unwrap()
    };
    user2
        .call(worker, nft.id().clone(), "nft_transfer_payout")
        .args_json(serde_json::json!({
            "receiver_id": user3.id(),
            "token_id": token_id,
            "approval_id": approval_id,
            "memo": serde_json::json!(fees).to_string(),
            "balance": balance,
            "max_len_payout": 10,
        }))
        .unwrap()
        .deposit(1)
        .transact()
        .await
        .unwrap()
        .json()
        .unwrap()
}

'''