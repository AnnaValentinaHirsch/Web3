*GitHub Repository "kwklly/kms-COIN"*

'''--- README.md ---
# @dsrv/kms
dsrv key management store

## Usage
```html
<script src="node_modules/argon2-browser/lib/argon2.js"></script>
```
```javascript
import { KMS, COIN, createKeyStore } from "@dsrv/kms";

// create key store
const mnemonic = "....";
const password = "strong password";
const keyStore = await createKeyStore(mnemonic.split(" "), password);

/*
{
  t: 9,
  m: 262144,
  s: '89aaLUkbh3E3yvBvatitUsmznTMd2p7jU1cri5D5xBnu',
  j: [
    'eyJlbmMiOiJBMjU2R0NNIiwiYWxnIjoiUEJFUzItSFMyNTYrQTEyOEtXIiwia2lkIjoiT1lBd0hGRW4zYmFKSWJkLXoyc09VMFhnRjVLRmtfb2ZBeWQwWmxMM0FjMCIsInAycyI6IlBqNHpCdS1aMC1laVVPcGx5emh5dXciLCJwMmMiOjgxOTJ9',
    'A7jjx9G1jwylhRqmk9WLgc29_G_0Bn36buUSXC1u6zRq0jLzAEKOpg',
    '9COzNxXnCc_T1Jtg',
    'VD5EXQ',
    'BboSFxRBdGQlNyHqG8hOxw'
  ]
}
*/

// get account
const kms = new KMS({
  keyStore,
  transport: null,
});
const account = await kms.getAccount({
  type: COIN.MINA,
  account: 0,
  index: 0,
  password
});

/*
B62qpgyAmA5yNgY4buNhTxTKYTvkqSFf442KkHzYHribCFjDmXcfHHm
*/

```

## Test keysore
1. yarn build
2. modify test/mnemonic.json
3. node test/keystore

## Test ledger nano s, nano x
1. yarn build
2. node test/ledger/mina o node test/ledger/cosmos

'''
'''--- package.json ---
{
  "name": "@dsrv/kms",
  "version": "0.0.6",
  "description": "blockchain key managament system",
  "main": "./lib/index.js",
  "types": "./lib/index.d.ts",
  "files": [
    "src/**/*",
    "lib/**/*"
  ],
  "scripts": {
    "build": "tsc",
    "prettier": "prettier --write --config ./.prettierrc \"**/*.{ts,tsx}\"",
    "lint": "eslint './src/**/*.{ts,tsx}'",
    "lint:fix": "eslint --fix './src/**/*.{ts,tsx}'"
  },
  "repository": "https://github.com/dsrvlabs/kms.git",
  "keywords": [
    "dsrv",
    "blockchain",
    "ledger",
    "signer",
    "kms",
    "key management system",
    "keystore",
    "store",
    "mnemonic",
    "bip39",
    "bip32",
    "bip44"
  ],
  "author": "daoauth",
  "license": "MIT",
  "dependencies": {
    "@ledgerhq/errors": "^5.50.0",
    "@ledgerhq/hw-app-tezos": "^6.0.2",
    "@ledgerhq/hw-transport-node-hid": "^5.49.0",
    "@ledgerhq/hw-transport-webusb": "^5.49.0",
    "@o1labs/client-sdk": "^1.0.1",
    "@onflow/ledger": "^0.1.0",
    "@onflow/util-encode-key": "^0.0.2",
    "@polkadot/util-crypto": "^6.7.1",
    "@solana/web3.js": "^1.18.0",
    "@terra-money/ledger-terra-js": "^1.1.0",
    "@zondax/ledger-polkadot": "^0.14.0",
    "argon2-browser": "^1.17.0",
    "base58check": "^2.0.0",
    "bech32": "^2.0.0",
    "bignumber.js": "^9.0.1",
    "bip32": "^2.0.6",
    "bip39": "^3.0.3",
    "blake2b": "^2.1.3",
    "bn.js": "^4.12.0",
    "bs58": "^4.0.1",
    "bs58check": "^2.1.2",
    "crypto-js": "^3.1.9-1",
    "elliptic": "^6.5.4",
    "ethereumjs-util": "^7.0.10",
    "ledger-cosmos-js": "^2.1.8",
    "mina-ledger-js": "^1.0.6",
    "near-api-js": "^0.41.0",
    "near-hd-key": "^1.2.1",
    "near-ledger-js": "^0.1.2",
    "node-jose": "^2.0.0",
    "rlp": "^2.2.6",
    "secp256k1": "^4.0.2",
    "tweetnacl": "^1.0.3"
  },
  "devDependencies": {
    "@types/bs58": "^4.0.1",
    "@types/bs58check": "^2.1.0",
    "@types/crypto-js": "^3.1.9-1",
    "@types/elliptic": "^6.4.12",
    "@types/ledgerhq__hw-transport-node-hid": "^4.22.2",
    "@types/ledgerhq__hw-transport-webusb": "^4.70.1",
    "@types/node-jose": "^1.1.5",
    "@types/secp256k1": "^4.0.2",
    "@typescript-eslint/eslint-plugin": "^4.22.0",
    "@typescript-eslint/parser": "^4.22.0",
    "argon2": "^0.28.2",
    "eslint": "^7.24.0",
    "eslint-config-airbnb-base": "^14.2.1",
    "eslint-config-prettier": "^8.2.0",
    "eslint-plugin-import": "^2.22.1",
    "eslint-plugin-prettier": "^3.4.0",
    "prettier": "^2.2.1",
    "typescript": "^4.2.4"
  }
}

'''
'''--- src/blockchains/celo/hw/index.ts ---
/** ******************************************************************************
 *   Ledger Node JS API
 *   (c) 2016-2017 Ledger
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ******************************************************************************* */
// @flow

// FIXME drop:
import type Transport from "@ledgerhq/hw-transport";
import { BigNumber } from "bignumber.js";
import { encode, decode } from "rlp";
import { splitPath, foreach } from "./utils";

const { EthAppPleaseEnableContractData } = require("@ledgerhq/errors");

export type StarkQuantizationType =
  | "eth"
  | "erc20"
  | "erc721"
  | "erc20mintable"
  | "erc721mintable";

const starkQuantizationTypeMap = {
  eth: 1,
  erc20: 2,
  erc721: 3,
  erc20mintable: 4,
  erc721mintable: 5,
};

function hexBuffer(str: string): Buffer {
  return Buffer.from(str.startsWith("0x") ? str.slice(2) : str, "hex");
}

function maybeHexBuffer(
  str: string | null | undefined
): Buffer | null | undefined {
  if (!str) return null;
  return hexBuffer(str);
}

const remapTransactionRelatedErrors = (e: any) => {
  if (e && e.statusCode === 0x6a80) {
    return new EthAppPleaseEnableContractData(
      "Please enable Contract data on the Ethereum app Settings"
    );
  }
  return e;
};

/**
 * Celo API
 *
 * @example
 * import Celo from "@ledgerhq/hw-app-eth";
 * const celo = new Celo(transport)
 */
export default class Ledger {
  transport: Transport<any>;

  constructor(transport: Transport<any>, scrambleKey: string = "w0w") {
    this.transport = transport;
    transport.decorateAppAPIMethods(
      this,
      [
        "getAddress",
        "provideERC20TokenInformation",
        "signTransaction",
        "signPersonalMessage",
        "getAppConfiguration",
        "signEIP712HashedMessage",
        "starkGetPublicKey",
        "starkSignOrder",
        "starkSignOrder_v2",
        "starkSignTransfer",
        "starkSignTransfer_v2",
        "starkProvideQuantum",
        "starkProvideQuantum_v2",
        "starkUnsafeSign",
        "eth2GetPublicKey",
        "eth2SetWithdrawalIndex",
      ],
      scrambleKey
    );
  }

  /**
   * get Celo address for a given BIP 32 path.
   * @param path a path in BIP 32 format
   * @option boolDisplay optionally enable or not the display
   * @option boolChaincode optionally enable or not the chaincode request
   * @return an object with a publicKey, address and (optionally) chainCode
   * @example
   * eth.getAddress("44'/52752'/0'/0/0").then(o => o.address)
   */
  getAddress(
    path: string,
    boolDisplay?: boolean,
    boolChaincode?: boolean
  ): Promise<{
    publicKey: string;
    address: string;
    chainCode?: string;
  }> {
    const paths = splitPath(path);
    const buffer = Buffer.alloc(1 + paths.length * 4);
    buffer[0] = paths.length;
    paths.forEach((element, index) => {
      buffer.writeUInt32BE(element, 1 + 4 * index);
    });
    return this.transport
      .send(
        0xe0,
        0x02,
        boolDisplay ? 0x01 : 0x00,
        boolChaincode ? 0x01 : 0x00,
        buffer
      )
      .then((response) => {
        const publicKeyLength = response[0];
        const addressLength = response[1 + publicKeyLength];
        const publicKey = response
          .slice(1, 1 + publicKeyLength)
          .toString("hex");
        const address = `0x${response
          .slice(
            1 + publicKeyLength + 1,
            1 + publicKeyLength + 1 + addressLength
          )
          .toString("ascii")}`;
        if (boolChaincode) {
          return {
            publicKey,
            address,
            chainCode: response
              .slice(
                1 + publicKeyLength + 1 + addressLength,
                1 + publicKeyLength + 1 + addressLength + 32
              )
              .toString("hex"),
          };
        }
        return {
          publicKey,
          address,
        };
      });
  }

  /**
   * This commands provides a trusted description of an ERC 20 token
   * to associate a contract address with a ticker and number of decimals.
   *
   * It shall be run immediately before performing a transaction involving a contract
   * calling this contract address to display the proper token information to the user if necessary.
   *
   * @param {*} info: a blob from "erc20.js" utilities that contains all token information.
   *
   * @example
   * import { byContractAddress } from "@ledgerhq/hw-app-eth/erc20"
   * const zrxInfo = byContractAddress("0xe41d2489571d322189246dafa5ebde1f4699f498")
   * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)
   * const signed = await appEth.signTransaction(path, rawTxHex)
   */
  provideERC20TokenInformation({ data }: { data: Buffer }): Promise<boolean> {
    return this.transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(
      () => true,
      (e) => {
        if (e && e.statusCode === 0x6d00) {
          // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.
          // we return a flag to know if the call was effective or not
          return false;
        }
        throw e;
      }
    );
  }

  /**
   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign
   * @example
   eth.signTransaction("44'/52752'/0'/0/0", "e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080").then(result => ...)
   */
  signTransaction(
    path: string,
    rawTxHex: string
  ): Promise<{
    s: string;
    v: string;
    r: string;
  }> {
    const paths = splitPath(path);
    let offset = 0;
    const rawTx = Buffer.from(rawTxHex, "hex");
    const toSend = [];
    let response: any;
    // Check if the TX is encoded following EIP 155
    const rlpTx = decode(rawTx);
    let rlpOffset = 0;
    if (rlpTx.length > 6) {
      const rlpVrs = encode(rlpTx.slice(-3));
      rlpOffset = rawTx.length - (rlpVrs.length - 1);
    }
    while (offset !== rawTx.length) {
      const maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;
      let chunkSize =
        offset + maxChunkSize > rawTx.length
          ? rawTx.length - offset
          : maxChunkSize;
      if (rlpOffset !== 0 && offset + chunkSize === rlpOffset) {
        // Make sure that the chunk doesn't end right on the EIP 155 marker if set
        chunkSize -= 1;
      }
      const buffer = Buffer.alloc(
        offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize
      );
      if (offset === 0) {
        buffer[0] = paths.length;
        paths.forEach((element, index) => {
          buffer.writeUInt32BE(element, 1 + 4 * index);
        });
        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);
      } else {
        rawTx.copy(buffer, 0, offset, offset + chunkSize);
      }
      toSend.push(buffer);
      offset += chunkSize;
    }
    return foreach(toSend, (data, i) =>
      this.transport
        .send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data)
        .then((apduResponse) => {
          response = apduResponse;
        })
    ).then(
      () => {
        const v = response.slice(0, 1).toString("hex");
        const r = response.slice(1, 1 + 32).toString("hex");
        const s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
        return { v, r, s };
      },
      (e) => {
        throw remapTransactionRelatedErrors(e);
      }
    );
  }

  /**
   */
  getAppConfiguration(): Promise<{
    arbitraryDataEnabled: number;
    erc20ProvisioningNecessary: number;
    starkEnabled: number;
    starkv2Supported: number;
    version: string;
  }> {
    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then((response: any) => {
      return {
        // eslint-disable-next-line no-bitwise
        arbitraryDataEnabled: response[0] & 0x01,
        // eslint-disable-next-line no-bitwise
        erc20ProvisioningNecessary: response[0] & 0x02,
        // eslint-disable-next-line no-bitwise
        starkEnabled: response[0] & 0x04,
        // eslint-disable-next-line no-bitwise
        starkv2Supported: response[0] & 0x08,
        version: `${response[1]}.${response[2]}.${response[3]}`,
      };
    });
  }

  /**
  * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.
  * @example
eth.signPersonalMessage("44'/60'/0'/0/0", Buffer.from("test").toString("hex")).then(result => {
  var v = result['v'] - 27;
  v = v.toString(16);
  if (v.length < 2) {
    v = "0" + v;
  }
  console.log("Signature 0x" + result['r'] + result['s'] + v);
})
   */
  signPersonalMessage(
    path: string,
    messageHex: string
  ): Promise<{
    v: number;
    s: string;
    r: string;
  }> {
    const paths = splitPath(path);
    let offset = 0;
    const message = Buffer.from(messageHex, "hex");
    const toSend = [];
    let response: any;
    while (offset !== message.length) {
      const maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;
      const chunkSize =
        offset + maxChunkSize > message.length
          ? message.length - offset
          : maxChunkSize;
      const buffer = Buffer.alloc(
        offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize
      );
      if (offset === 0) {
        buffer[0] = paths.length;
        paths.forEach((element, index) => {
          buffer.writeUInt32BE(element, 1 + 4 * index);
        });
        buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);
        message.copy(
          buffer,
          1 + 4 * paths.length + 4,
          offset,
          offset + chunkSize
        );
      } else {
        message.copy(buffer, 0, offset, offset + chunkSize);
      }
      toSend.push(buffer);
      offset += chunkSize;
    }
    return foreach(toSend, (data, i) =>
      this.transport
        .send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data)
        .then((apduResponse) => {
          response = apduResponse;
        })
    ).then(() => {
      const v = response[0];
      const r = response.slice(1, 1 + 32).toString("hex");
      const s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
      return { v, r, s };
    });
  }

  /**
  * Sign a prepared message following web3.eth.signTypedData specification. The host computes the domain separator and hashStruct(message)
  * @example
  eth.signEIP712HashedMessage("44'/60'/0'/0/0", Buffer.from("0101010101010101010101010101010101010101010101010101010101010101").toString("hex"), Buffer.from("0202020202020202020202020202020202020202020202020202020202020202").toString("hex")).then(result => {
  var v = result['v'] - 27;
  v = v.toString(16);
  if (v.length < 2) {
    v = "0" + v;
  }
  console.log("Signature 0x" + result['r'] + result['s'] + v);
})
   */
  signEIP712HashedMessage(
    path: string,
    domainSeparatorHex: string,
    hashStructMessageHex: string
  ): Promise<{
    v: number;
    s: string;
    r: string;
  }> {
    const domainSeparator = hexBuffer(domainSeparatorHex);
    const hashStruct = hexBuffer(hashStructMessageHex);
    const paths = splitPath(path);
    const buffer = Buffer.alloc(1 + paths.length * 4 + 32 + 32, 0);
    let offset = 0;
    buffer[0] = paths.length;
    paths.forEach((element, index) => {
      buffer.writeUInt32BE(element, 1 + 4 * index);
    });
    offset = 1 + 4 * paths.length;
    domainSeparator.copy(buffer, offset);
    offset += 32;
    hashStruct.copy(buffer, offset);
    return this.transport
      .send(0xe0, 0x0c, 0x00, 0x00, buffer)
      .then((response) => {
        const v = response[0];
        const r = response.slice(1, 1 + 32).toString("hex");
        const s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
        return { v, r, s };
      });
  }

  /**
   * get Stark public key for a given BIP 32 path.
   * @param path a path in BIP 32 format
   * @option boolDisplay optionally enable or not the display
   * @return the Stark public key
   */
  starkGetPublicKey(path: string, boolDisplay?: boolean): Promise<Buffer> {
    const paths = splitPath(path);
    const buffer = Buffer.alloc(1 + paths.length * 4);
    buffer[0] = paths.length;
    paths.forEach((element, index) => {
      buffer.writeUInt32BE(element, 1 + 4 * index);
    });
    return this.transport
      .send(0xf0, 0x02, boolDisplay ? 0x01 : 0x00, 0x00, buffer)
      .then((response) => {
        return response.slice(0, response.length - 2);
      });
  }

  /**
   * sign a Stark order
   * @param path a path in BIP 32 format
   * @option sourceTokenAddress contract address of the source token (not present for ETH)
   * @param sourceQuantization quantization used for the source token
   * @option destinationTokenAddress contract address of the destination token (not present for ETH)
   * @param destinationQuantization quantization used for the destination token
   * @param sourceVault ID of the source vault
   * @param destinationVault ID of the destination vault
   * @param amountSell amount to sell
   * @param amountBuy amount to buy
   * @param nonce transaction nonce
   * @param timestamp transaction validity timestamp
   * @return the signature
   */
  starkSignOrder(
    path: string,
    sourceTokenAddress: string | null | undefined = null,
    sourceQuantization: BigNumber,
    destinationTokenAddress: string | null | undefined = null,
    destinationQuantization: BigNumber,
    sourceVault: number,
    destinationVault: number,
    amountSell: BigNumber,
    amountBuy: BigNumber,
    nonce: number,
    timestamp: number
  ): Promise<{ r: string; s: string }> {
    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);
    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);
    const paths = splitPath(path);
    const buffer = Buffer.alloc(
      1 + paths.length * 4 + 20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4,
      0
    );
    let offset = 0;
    buffer[0] = paths.length;
    paths.forEach((element, index) => {
      buffer.writeUInt32BE(element, 1 + 4 * index);
    });
    offset = 1 + 4 * paths.length;
    if (sourceTokenAddressHex) {
      sourceTokenAddressHex.copy(buffer, offset);
    }
    offset += 20;
    Buffer.from(sourceQuantization.toString(16).padStart(64, "0"), "hex").copy(
      buffer,
      offset
    );
    offset += 32;
    if (destinationTokenAddressHex) {
      destinationTokenAddressHex.copy(buffer, offset);
    }
    offset += 20;
    Buffer.from(
      destinationQuantization.toString(16).padStart(64, "0"),
      "hex"
    ).copy(buffer, offset);
    offset += 32;
    buffer.writeUInt32BE(sourceVault, offset);
    offset += 4;
    buffer.writeUInt32BE(destinationVault, offset);
    offset += 4;
    Buffer.from(amountSell.toString(16).padStart(16, "0"), "hex").copy(
      buffer,
      offset
    );
    offset += 8;
    Buffer.from(amountBuy.toString(16).padStart(16, "0"), "hex").copy(
      buffer,
      offset
    );
    offset += 8;
    buffer.writeUInt32BE(nonce, offset);
    offset += 4;
    buffer.writeUInt32BE(timestamp, offset);
    return this.transport
      .send(0xf0, 0x04, 0x01, 0x00, buffer)
      .then((response) => {
        const r = response.slice(1, 1 + 32).toString("hex");
        const s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
        return { r, s };
      });
  }

  /**
   * sign a Stark order using the Starkex V2 protocol
   * @param path a path in BIP 32 format
   * @option sourceTokenAddress contract address of the source token (not present for ETH)
   * @param sourceQuantizationType quantization type used for the source token
   * @option sourceQuantization quantization used for the source token (not present for erc 721 or mintable erc 721)
   * @option sourceMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the source token
   * @option destinationTokenAddress contract address of the destination token (not present for ETH)
   * @param destinationQuantizationType quantization type used for the destination token
   * @option destinationQuantization quantization used for the destination token (not present for erc 721 or mintable erc 721)
   * @option destinationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the destination token
   * @param sourceVault ID of the source vault
   * @param destinationVault ID of the destination vault
   * @param amountSell amount to sell
   * @param amountBuy amount to buy
   * @param nonce transaction nonce
   * @param timestamp transaction validity timestamp
   * @return the signature
   */
  // eslint-disable-next-line camelcase
  starkSignOrder_v2(
    path: string,
    sourceTokenAddress: string | null | undefined = null,
    sourceQuantizationType: StarkQuantizationType,
    sourceQuantization: BigNumber | null | undefined = null,
    sourceMintableBlobOrTokenId: BigNumber | null | undefined = null,
    destinationTokenAddress: string | null | undefined = null,
    destinationQuantizationType: StarkQuantizationType,
    destinationQuantization: BigNumber | null | undefined = null,
    destinationMintableBlobOrTokenId: BigNumber | null | undefined = null,
    sourceVault: number,
    destinationVault: number,
    amountSell: BigNumber,
    amountBuy: BigNumber,
    nonce: number,
    timestamp: number
  ): Promise<{ r: string; s: string }> {
    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);
    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);
    if (!(sourceQuantizationType in starkQuantizationTypeMap)) {
      throw new Error(
        `eth.starkSignOrderv2 invalid source quantization type=${sourceQuantizationType}`
      );
    }
    if (!(destinationQuantizationType in starkQuantizationTypeMap)) {
      throw new Error(
        `eth.starkSignOrderv2 invalid destination quantization type=${destinationQuantizationType}`
      );
    }
    const paths = splitPath(path);
    const buffer = Buffer.alloc(
      1 +
        paths.length * 4 +
        1 +
        20 +
        32 +
        32 +
        1 +
        20 +
        32 +
        32 +
        4 +
        4 +
        8 +
        8 +
        4 +
        4,
      0
    );
    let offset = 0;
    buffer[0] = paths.length;
    paths.forEach((element, index) => {
      buffer.writeUInt32BE(element, 1 + 4 * index);
    });
    offset = 1 + 4 * paths.length;
    buffer[offset] = starkQuantizationTypeMap[sourceQuantizationType];
    offset += 1;
    if (sourceTokenAddressHex) {
      sourceTokenAddressHex.copy(buffer, offset);
    }
    offset += 20;
    if (sourceQuantization) {
      Buffer.from(
        sourceQuantization.toString(16).padStart(64, "0"),
        "hex"
      ).copy(buffer, offset);
    }
    offset += 32;
    if (sourceMintableBlobOrTokenId) {
      Buffer.from(
        sourceMintableBlobOrTokenId.toString(16).padStart(64, "0"),
        "hex"
      ).copy(buffer, offset);
    }
    offset += 32;
    buffer[offset] = starkQuantizationTypeMap[destinationQuantizationType];
    offset += 1;
    if (destinationTokenAddressHex) {
      destinationTokenAddressHex.copy(buffer, offset);
    }
    offset += 20;
    if (destinationQuantization) {
      Buffer.from(
        destinationQuantization.toString(16).padStart(64, "0"),
        "hex"
      ).copy(buffer, offset);
    }
    offset += 32;
    if (destinationMintableBlobOrTokenId) {
      Buffer.from(
        destinationMintableBlobOrTokenId.toString(16).padStart(64, "0"),
        "hex"
      ).copy(buffer, offset);
    }
    offset += 32;
    buffer.writeUInt32BE(sourceVault, offset);
    offset += 4;
    buffer.writeUInt32BE(destinationVault, offset);
    offset += 4;
    Buffer.from(amountSell.toString(16).padStart(16, "0"), "hex").copy(
      buffer,
      offset
    );
    offset += 8;
    Buffer.from(amountBuy.toString(16).padStart(16, "0"), "hex").copy(
      buffer,
      offset
    );
    offset += 8;
    buffer.writeUInt32BE(nonce, offset);
    offset += 4;
    buffer.writeUInt32BE(timestamp, offset);
    return this.transport
      .send(0xf0, 0x04, 0x03, 0x00, buffer)
      .then((response) => {
        const r = response.slice(1, 1 + 32).toString("hex");
        const s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
        return { r, s };
      });
  }

  /**
   * sign a Stark transfer
   * @param path a path in BIP 32 format
   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)
   * @param transferQuantization quantization used for the token to be transferred
   * @param targetPublicKey target Stark public key
   * @param sourceVault ID of the source vault
   * @param destinationVault ID of the destination vault
   * @param amountTransfer amount to transfer
   * @param nonce transaction nonce
   * @param timestamp transaction validity timestamp
   * @return the signature
   */
  starkSignTransfer(
    path: string,
    transferTokenAddress: string | null | undefined = null,
    transferQuantization: BigNumber,
    targetPublicKey: string,
    sourceVault: number,
    destinationVault: number,
    amountTransfer: BigNumber,
    nonce: number,
    timestamp: number
  ): Promise<{ r: string; s: string }> {
    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);
    const targetPublicKeyHex = hexBuffer(targetPublicKey);
    const paths = splitPath(path);
    const buffer = Buffer.alloc(
      1 + paths.length * 4 + 20 + 32 + 32 + 4 + 4 + 8 + 4 + 4,
      0
    );
    let offset = 0;
    buffer[0] = paths.length;
    paths.forEach((element, index) => {
      buffer.writeUInt32BE(element, 1 + 4 * index);
    });
    offset = 1 + 4 * paths.length;
    if (transferTokenAddressHex) {
      transferTokenAddressHex.copy(buffer, offset);
    }
    offset += 20;
    Buffer.from(
      transferQuantization.toString(16).padStart(64, "0"),
      "hex"
    ).copy(buffer, offset);
    offset += 32;
    targetPublicKeyHex.copy(buffer, offset);
    offset += 32;
    buffer.writeUInt32BE(sourceVault, offset);
    offset += 4;
    buffer.writeUInt32BE(destinationVault, offset);
    offset += 4;
    Buffer.from(amountTransfer.toString(16).padStart(16, "0"), "hex").copy(
      buffer,
      offset
    );
    offset += 8;
    buffer.writeUInt32BE(nonce, offset);
    offset += 4;
    buffer.writeUInt32BE(timestamp, offset);
    return this.transport
      .send(0xf0, 0x04, 0x02, 0x00, buffer)
      .then((response) => {
        const r = response.slice(1, 1 + 32).toString("hex");
        const s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
        return { r, s };
      });
  }

  /**
   * sign a Stark transfer or conditional transfer using the Starkex V2 protocol
   * @param path a path in BIP 32 format
   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)
   * @param transferQuantizationType quantization type used for the token to be transferred
   * @option transferQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)
   * @option transferMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the token to be transferred
   * @param targetPublicKey target Stark public key
   * @param sourceVault ID of the source vault
   * @param destinationVault ID of the destination vault
   * @param amountTransfer amount to transfer
   * @param nonce transaction nonce
   * @param timestamp transaction validity timestamp
   * @option conditionalTransferAddress onchain address of the condition for a conditional transfer
   * @option conditionalTransferFact fact associated to the condition for a conditional transfer
   * @return the signature
   */
  // eslint-disable-next-line camelcase
  starkSignTransfer_v2(
    path: string,
    transferTokenAddress: string | null | undefined = null,
    transferQuantizationType: StarkQuantizationType,
    transferQuantization: BigNumber | null | undefined = null,
    transferMintableBlobOrTokenId: BigNumber | null | undefined = null,
    targetPublicKey: string,
    sourceVault: number,
    destinationVault: number,
    amountTransfer: BigNumber,
    nonce: number,
    timestamp: number,
    conditionalTransferAddress: string | null | undefined = null,
    conditionalTransferFact: BigNumber | null | undefined = null
  ): Promise<{ r: string; s: string }> {
    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);
    const targetPublicKeyHex = hexBuffer(targetPublicKey);
    const conditionalTransferAddressHex = maybeHexBuffer(
      conditionalTransferAddress
    );
    if (!(transferQuantizationType in starkQuantizationTypeMap)) {
      throw new Error(
        `eth.starkSignTransferv2 invalid quantization type=${transferQuantizationType}`
      );
    }
    const paths = splitPath(path);
    const buffer = Buffer.alloc(
      1 +
        paths.length * 4 +
        1 +
        20 +
        32 +
        32 +
        32 +
        4 +
        4 +
        8 +
        4 +
        4 +
        (conditionalTransferAddressHex ? 32 + 20 : 0),
      0
    );
    let offset = 0;
    buffer[0] = paths.length;
    paths.forEach((element, index) => {
      buffer.writeUInt32BE(element, 1 + 4 * index);
    });
    offset = 1 + 4 * paths.length;
    buffer[offset] = starkQuantizationTypeMap[transferQuantizationType];
    offset += 1;
    if (transferTokenAddressHex) {
      transferTokenAddressHex.copy(buffer, offset);
    }
    offset += 20;
    if (transferQuantization) {
      Buffer.from(
        transferQuantization.toString(16).padStart(64, "0"),
        "hex"
      ).copy(buffer, offset);
    }
    offset += 32;
    if (transferMintableBlobOrTokenId) {
      Buffer.from(
        transferMintableBlobOrTokenId.toString(16).padStart(64, "0"),
        "hex"
      ).copy(buffer, offset);
    }
    offset += 32;
    targetPublicKeyHex.copy(buffer, offset);
    offset += 32;
    buffer.writeUInt32BE(sourceVault, offset);
    offset += 4;
    buffer.writeUInt32BE(destinationVault, offset);
    offset += 4;
    Buffer.from(amountTransfer.toString(16).padStart(16, "0"), "hex").copy(
      buffer,
      offset
    );
    offset += 8;
    buffer.writeUInt32BE(nonce, offset);
    offset += 4;
    buffer.writeUInt32BE(timestamp, offset);
    if (conditionalTransferAddressHex && conditionalTransferFact) {
      offset += 4;
      Buffer.from(
        conditionalTransferFact.toString(16).padStart(64, "0"),
        "hex"
      ).copy(buffer, offset);
      offset += 32;
      conditionalTransferAddressHex.copy(buffer, offset);
    }
    return this.transport
      .send(
        0xf0,
        0x04,
        conditionalTransferAddressHex ? 0x05 : 0x04,
        0x00,
        buffer
      )
      .then((response) => {
        const r = response.slice(1, 1 + 32).toString("hex");
        const s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
        return { r, s };
      });
  }

  /**
   * provide quantization information before singing a deposit or withdrawal Stark powered contract call
   *
   * It shall be run following a provideERC20TokenInformation call for the given contract
   *
   * @param operationContract contract address of the token to be transferred (not present for ETH)
   * @param operationQuantization quantization used for the token to be transferred
   */
  starkProvideQuantum(
    operationContract: string | null | undefined = null,
    operationQuantization: BigNumber
  ): Promise<boolean> {
    const operationContractHex = maybeHexBuffer(operationContract);
    const buffer = Buffer.alloc(20 + 32, 0);
    if (operationContractHex) {
      operationContractHex.copy(buffer, 0);
    }
    Buffer.from(
      operationQuantization.toString(16).padStart(64, "0"),
      "hex"
    ).copy(buffer, 20);
    return this.transport.send(0xf0, 0x08, 0x00, 0x00, buffer).then(
      () => true,
      (e) => {
        if (e && e.statusCode === 0x6d00) {
          // this case happen for ETH application versions not supporting Stark extensions
          return false;
        }
        throw e;
      }
    );
  }

  /**
   * provide quantization information before singing a deposit or withdrawal Stark powered contract call using the Starkex V2 protocol
   *
   * It shall be run following a provideERC20TokenInformation call for the given contract
   *
   * @param operationContract contract address of the token to be transferred (not present for ETH)
   * @param operationQuantizationType quantization type of the token to be transferred
   * @option operationQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)
   * @option operationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) of the token to be transferred
   */
  // eslint-disable-next-line camelcase
  starkProvideQuantum_v2(
    operationContract: string | null | undefined = null,
    operationQuantizationType: StarkQuantizationType,
    operationQuantization?: BigNumber,
    operationMintableBlobOrTokenId?: BigNumber
  ): Promise<boolean> {
    const operationContractHex = maybeHexBuffer(operationContract);
    if (!(operationQuantizationType in starkQuantizationTypeMap)) {
      throw new Error(
        `eth.starkProvideQuantumV2 invalid quantization type=${operationQuantizationType}`
      );
    }
    const buffer = Buffer.alloc(20 + 32 + 32, 0);
    let offset = 0;
    if (operationContractHex) {
      operationContractHex.copy(buffer, offset);
    }
    offset += 20;
    if (operationQuantization) {
      Buffer.from(
        operationQuantization.toString(16).padStart(64, "0"),
        "hex"
      ).copy(buffer, offset);
    }
    offset += 32;
    if (operationMintableBlobOrTokenId) {
      Buffer.from(
        operationMintableBlobOrTokenId.toString(16).padStart(64, "0"),
        "hex"
      ).copy(buffer, offset);
    }
    return this.transport
      .send(
        0xf0,
        0x08,
        starkQuantizationTypeMap[operationQuantizationType],
        0x00,
        buffer
      )
      .then(
        () => true,
        (e) => {
          if (e && e.statusCode === 0x6d00) {
            // this case happen for ETH application versions not supporting Stark extensions
            return false;
          }
          throw e;
        }
      );
  }

  /**
   * sign the given hash over the Stark curve
   * It is intended for speed of execution in case an unknown Stark model is pushed and should be avoided as much as possible.
   * @param path a path in BIP 32 format
   * @param hash hexadecimal hash to sign
   * @return the signature
   */
  starkUnsafeSign(
    path: string,
    hash: string
  ): Promise<{ r: string; s: string }> {
    const hashHex = hexBuffer(hash);
    const paths = splitPath(path);
    const buffer = Buffer.alloc(1 + paths.length * 4 + 32);
    let offset = 0;
    buffer[0] = paths.length;
    paths.forEach((element, index) => {
      buffer.writeUInt32BE(element, 1 + 4 * index);
    });
    offset = 1 + 4 * paths.length;
    hashHex.copy(buffer, offset);
    return this.transport
      .send(0xf0, 0x0a, 0x00, 0x00, buffer)
      .then((response) => {
        const r = response.slice(1, 1 + 32).toString("hex");
        const s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
        return { r, s };
      });
  }

  /**
   * get an Ethereum 2 BLS-12 381 public key for a given BIP 32 path.
   * @param path a path in BIP 32 format
   * @option boolDisplay optionally enable or not the display
   * @return an object with a publicKey
   * @example
   * eth.eth2GetPublicKey("12381/3600/0/0").then(o => o.publicKey)
   */
  eth2GetPublicKey(
    path: string,
    boolDisplay?: boolean
  ): Promise<{
    publicKey: string;
  }> {
    const paths = splitPath(path);
    const buffer = Buffer.alloc(1 + paths.length * 4);
    buffer[0] = paths.length;
    paths.forEach((element, index) => {
      buffer.writeUInt32BE(element, 1 + 4 * index);
    });
    return this.transport
      .send(0xe0, 0x0e, boolDisplay ? 0x01 : 0x00, 0x00, buffer)
      .then((response) => {
        return {
          publicKey: response.slice(0, -2).toString("hex"),
        };
      });
  }

  /**
   * Set the index of a Withdrawal key used as withdrawal credentials in an ETH 2 deposit contract call signature
   *
   * It shall be run before the ETH 2 deposit transaction is signed. If not called, the index is set to 0
   *
   * @param withdrawalIndex index path in the EIP 2334 path m/12381/3600/withdrawalIndex/0
   * @return True if the method was executed successfully
   */
  eth2SetWithdrawalIndex(withdrawalIndex: number): Promise<boolean> {
    const buffer = Buffer.alloc(4, 0);
    buffer.writeUInt32BE(withdrawalIndex, 0);
    return this.transport.send(0xe0, 0x10, 0x00, 0x00, buffer).then(
      () => true,
      (e) => {
        if (e && e.statusCode === 0x6d00) {
          // this case happen for ETH application versions not supporting ETH 2
          return false;
        }
        throw e;
      }
    );
  }
}

'''
'''--- src/blockchains/celo/hw/utils.ts ---
/** ******************************************************************************
 *   Ledger Node JS API
 *   (c) 2016-2017 Ledger
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ******************************************************************************* */

// TODO use bip32-path library
export function splitPath(path: string): number[] {
  const result: number[] = [];
  const components = path.split("/");
  components.forEach((element) => {
    let number = parseInt(element, 10);
    if (Number.isNaN(number)) {
      return; // FIXME shouldn't it throws instead?
    }
    if (element.length > 1 && element[element.length - 1] === "'") {
      number += 0x80000000;
    }
    result.push(number);
  });
  return result;
}

// eslint-disable-next-line no-unused-vars
export async function foreach<T, A>(
  arr: T[],
  // eslint-disable-next-line no-unused-vars
  callback: (t: T, n: number) => Promise<A>
): Promise<A[]> {
  function iterate(index: number, array: any[], result: any[]): any {
    if (index >= array.length) {
      return result;
    }
    return callback(array[index], index).then((res) => {
      result.push(res);
      return iterate(index + 1, array, result);
    });
  }
  await Promise.resolve();
  return iterate(0, arr, []);
}

'''
'''--- src/blockchains/celo/keyStore.ts ---
import { BIP32Interface } from "bip32";
import { privateToAddress, toChecksumAddress } from "ethereumjs-util";
// import { RawTx } from "../../types";

export class KEYSTORE {
  static getAccount(node: BIP32Interface): string {
    const { privateKey } = node;
    return privateKey
      ? toChecksumAddress(`0x${privateToAddress(privateKey).toString("hex")}`)
      : "";
  }

  /*
  static signTx(node: BIP32Interface, rawTx: RawTx): { [key: string]: any } {
    // ...
  }
  */

  /*
  export signMessage(node: BIP32Interface, msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/celo/ledger.ts ---
import TransportWebUSB from "@ledgerhq/hw-transport-webusb";
import TransportNodeHid from "@ledgerhq/hw-transport-node-hid";
import Ledger from "./hw";
import { BIP44 } from "../../types";

// LEDGER
export class LEDGER {
  static async getAccount(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid
  ): Promise<string> {
    try {
      const instance = new Ledger(transport);
      const response = await instance.getAddress(
        `44'/${path.type}'/${path.account}'/0/${path.index}`
      );
      return response.address;
    } catch (error) {
      // eslint-disable-next-line no-console
      console.log(error);
    }
    return "";
  }

  /*
  static async signTx(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    rawTx: RawTx
  ): Promise<{ [key: string]: any }> {
    // ...
  }

  export function signMessage(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/cosmos/keyStore.ts ---
import { BIP32Interface } from "bip32";
import CryptoJS from "crypto-js";
import { bech32 } from "bech32";
// import { RawTx } from "../../types";

export class KEYSTORE {
  static bech32ify(address: string, prefix: string) {
    const words = bech32.toWords(Buffer.from(address, "hex"));
    return bech32.encode(prefix, words);
  }

  static getAccount(node: BIP32Interface): string {
    const message = CryptoJS.enc.Hex.parse(node.publicKey.toString("hex"));
    const temp = CryptoJS.RIPEMD160(CryptoJS.SHA256(message) as any).toString();
    const address = KEYSTORE.bech32ify(temp, "cosmos");
    return address;
  }

  /*
  static signTx(node: BIP32Interface, rawTx: RawTx): { [key: string]: any } {
    // ...
  }
  */

  /*
  export signMessage(node: BIP32Interface, msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/cosmos/ledger.ts ---
import TransportWebUSB from "@ledgerhq/hw-transport-webusb";
import TransportNodeHid from "@ledgerhq/hw-transport-node-hid";
import * as secp256k1 from "secp256k1";
import { BIP44, RawTx } from "../../types";

const CosmosApp = require("ledger-cosmos-js").default;

// LEDGER
export class LEDGER {
  static async getAccount(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid
  ): Promise<string> {
    const instance = new CosmosApp(transport);
    const response = await instance.getAddressAndPubKey(
      [44, path.type, path.account, 0, path.index],
      "cosmos"
    );
    return response.bech32_address;
  }

  static async signTx(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    rawTx: RawTx
  ): Promise<{ [key: string]: any }> {
    const instance = new CosmosApp(transport);
    const response = await instance.sign(
      [44, path.type, path.account, 0, path.index],
      JSON.stringify({ ...rawTx })
    );
    // TODO: test
    const signature = secp256k1.signatureImport(
      Buffer.from(response.signature)
    );
    return { signature };
  }

  /*
  export function signMessage(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/flow/keyStore.ts ---
import { BIP32Interface } from "bip32";

const EC = require("elliptic").ec;

export class KEYSTORE {
  static getAccount(node: BIP32Interface): string {
    const { privateKey } = node;
    const ec = new EC("secp256k1");
    const keyPair = ec.keyFromPrivate(privateKey);
    return keyPair.getPublic().encode("hex", false).slice(2);
  }
  /*
  static signTx(node: BIP32Interface, rawTx: RawTx): { [key: string]: any } {
    // ...
  }
  */

  /*
  export signMessage(node: BIP32Interface, msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/flow/ledger.ts ---
import TransportWebUSB from "@ledgerhq/hw-transport-webusb";
import TransportNodeHid from "@ledgerhq/hw-transport-node-hid";
import { BIP44 } from "../../types";

const FlowApp = require("@onflow/ledger").default;

// LEDGER
export class LEDGER {
  static async getAccount(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid
  ): Promise<string> {
    const instance = new FlowApp(transport);
    const response = await instance.getAddressAndPubKey(
      `m/44'/1'/${path.type}/0/${path.index}`
    );
    return response.address;
  }

  /*
  static async signTx(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    rawTx: RawTx
  ): Promise<{ [key: string]: any }> {
    // ...
  }

  export function signMessage(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/kusama/keyStore.ts ---
import { BIP32Interface } from "bip32";
import { naclKeypairFromSeed, encodeAddress } from "@polkadot/util-crypto";

export class KEYSTORE {
  static getAccount(node: BIP32Interface): string {
    const ss58Format = 2;
    const pk = node.privateKey
      ? new Uint8Array(node.privateKey.buffer)
      : new Uint8Array(32);
    return encodeAddress(
      `0x${Buffer.from(naclKeypairFromSeed(pk).publicKey).toString("hex")}`,
      ss58Format
    );
  }
  /*
  static signTx(node: BIP32Interface, rawTx: RawTx): { [key: string]: any } {
    // ...
  }
  */

  /*
  export signMessage(node: BIP32Interface, msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/kusama/ledger.ts ---
import TransportWebUSB from "@ledgerhq/hw-transport-webusb";
import TransportNodeHid from "@ledgerhq/hw-transport-node-hid";
import { newKusamaApp } from "@zondax/ledger-polkadot";
import { BIP44 } from "../../types";

// LEDGER
export class LEDGER {
  static async getAccount(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid
  ): Promise<string> {
    const instance = newKusamaApp(transport);
    const response = await instance.getAddress(
      0x80000000 + path.account,
      0x80000000,
      0x80000000 + path.index
    );
    return response.address;
  }

  /*
  static async signTx(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    rawTx: RawTx
  ): Promise<{ [key: string]: any }> {
    // ...
  }

  export function signMessage(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/mina/keyStore.ts ---
import { BIP32Interface } from "bip32";
import * as CodaSDK from "@o1labs/client-sdk";
import { RawTx } from "../../types";

const base58check = require("base58check");
const { TxType, Networks } = require("mina-ledger-js");

export class KEYSTORE {
  private static getPrivateKey(node: BIP32Interface): string {
    const privateKey = base58check.encode(
      node.privateKey ? `01${node.privateKey.toString("hex")}` : "",
      "5a"
    );
    return privateKey;
  }

  static getAccount(node: BIP32Interface): string {
    const privateKey = KEYSTORE.getPrivateKey(node);
    return CodaSDK.derivePublicKey(privateKey);
  }

  static signTx(node: BIP32Interface, rawTx: RawTx): { [key: string]: any } {
    const privateKey = KEYSTORE.getPrivateKey(node);
    const publicKey = KEYSTORE.getAccount(node);

    if (rawTx.isPayment) {
      const signedPayment = CodaSDK.signPayment(
        {
          from: rawTx.from,
          to: rawTx.to,
          amount: rawTx.amount,
          fee: rawTx.fee,
          nonce: rawTx.nonce,
        },
        {
          privateKey,
          publicKey,
        }
      );
      return {
        ...signedPayment,
        payload: {
          ...signedPayment.payload,
          txType: TxType.PAYMENT,
          networkId: rawTx.isDevNet ? Networks.DEVNET : Networks.MAINNET,
        },
      };
    }
    const signedStakeDelegation = CodaSDK.signStakeDelegation(
      {
        from: rawTx.from,
        to: rawTx.to,
        fee: rawTx.fee,
        nonce: rawTx.nonce,
      },
      {
        privateKey,
        publicKey,
      }
    );
    return {
      ...signedStakeDelegation,
      payload: {
        ...signedStakeDelegation.payload,
        txType: TxType.DELEGATION,
        networkId: rawTx.isDevNet ? Networks.DEVNET : Networks.MAINNET,
      },
    };
  }
  /*
  export signMessage(node: BIP32Interface, msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/mina/ledger.ts ---
import TransportWebUSB from "@ledgerhq/hw-transport-webusb";
import TransportNodeHid from "@ledgerhq/hw-transport-node-hid";
import { BIP44, RawTx } from "../../types";

const BN = require("bn.js");
const { MinaLedgerJS, TxType, Networks } = require("mina-ledger-js");

// LEDGER
export class LEDGER {
  static async getAccount(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid
  ): Promise<string> {
    const instance = new MinaLedgerJS(transport);
    const response = await instance.getAddress(path.account);
    return response.publicKey;
  }

  static async signTx(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    rawTx: RawTx
  ): Promise<{ [key: string]: any }> {
    const instance = new MinaLedgerJS(transport);
    const payload = {
      txType: rawTx.isDelegation ? TxType.DELEGATION : TxType.PAYMENT,
      networkId: rawTx.isDevNet ? Networks.DEVNET : Networks.MAINNET,
      amount: parseInt(rawTx.amount, 10),
      fee: parseInt(rawTx.fee, 10),
      nonce: parseInt(rawTx.nonce, 10),
      memo: rawTx.memo || "",
    };
    const response = await instance.signTransaction({
      ...payload,
      senderAccount: path.account,
      senderAddress: rawTx.from,
      receiverAddress: rawTx.to,
    });
    return {
      publicKey: rawTx.from,
      signature: {
        field: new BN(response.signature.substring(0, 64), 16).toString(10),
        scalar: new BN(response.signature.substring(64, 128), 16).toString(10),
      },
      payload: {
        ...payload,
        from: rawTx.from,
        to: rawTx.to,
      },
    };
  }

  /*
  export function signMessage(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/near/keyStore.ts ---
import { encode } from "bs58";
import nacl from "tweetnacl";
import { derivePath } from "near-hd-key";
import { BIP44, RawTx } from "../../types";

const nearAPI = require("near-api-js");
const sha256 = require('js-sha256');

export class KEYSTORE {
  static getAccount(seed: Buffer, path: BIP44): string {
    const { key } = derivePath(
      `m/44'/${path.type}'/${path.account}'/0'/${path.index}'`,
      seed.toString("hex")
    );
    const keyPair = nacl.sign.keyPair.fromSeed(key);
    return `ed25519:${encode(Buffer.from(keyPair.publicKey))}`;
  }

  private static getPrivateKey(seed: Buffer, path: BIP44): string {
    const { key } = derivePath(
      `m/44'/${path.type}'/${path.account}'/0'/${path.index}'`,
      seed.toString("hex")
    );
    const keyPair = nacl.sign.keyPair.fromSeed(key);
    return `${encode(Buffer.from(keyPair.secretKey))}`
  }

  static async signTx(seed: Buffer, path: BIP44, rawTx: RawTx) {
    const privateKey = KEYSTORE.getPrivateKey(seed, path);
    const sender = rawTx.sender;
    const receiver = rawTx.receiver;
    const networkId = rawTx.networkId;
    const amount = nearAPI.utils.format.parseNearAmount(rawTx.amount);
    const provider = new nearAPI.providers
        .JsonRpcProvider(`https://rpc.${networkId}.near.org`);
    const keyPair = nearAPI.utils.key_pair.KeyPairEd25519.fromString(privateKey);
    const publicKey = keyPair.getPublicKey();
    const accessKey = await provider.query(
        `access_key/${sender}/${publicKey.toString()}`, ''
    );
    const nonce = ++accessKey.nonce;
    var actions = [nearAPI.transactions.transfer(amount)];
    if (rawTx.isStake) {
      const validator = await nearAPI.utils.PublicKey.fromString(rawTx.validator);
      actions = [nearAPI.transactions.stake(amount, validator)];
    }
    const recentBlockHash = nearAPI.utils.serialize.base_decode(accessKey.block_hash);
    const transaction = nearAPI.transactions.createTransaction(
        sender, 
        publicKey, 
        receiver, 
        nonce, 
        actions, 
        recentBlockHash
    );
    const serializedTx = nearAPI.utils.serialize.serialize(
        nearAPI.transactions.SCHEMA, 
        transaction
    );
    const serializedTxHash = new Uint8Array(sha256.sha256.array(serializedTx));
    const signature = keyPair.sign(serializedTxHash);
    const signedTransaction = new nearAPI.transactions.SignedTransaction({
        transaction,
        signature: new nearAPI.transactions.Signature({ 
        keyType: transaction.publicKey.keyType, 
        data: signature.signature 
        })
    });
    const verify = keyPair.verify(serializedTxHash, signature.signature);
    if (rawTx.isStake) {
      return {
        ...signedTransaction,
        verifyStakeSignature: verify,
      }
    }
    return {
      ...signedTransaction,
      verifyTransferSignature: verify,
    };
  }

  /*
  export signMessage(node: BIP32Interface, msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/near/ledger.ts ---
import TransportWebUSB from "@ledgerhq/hw-transport-webusb";
import TransportNodeHid from "@ledgerhq/hw-transport-node-hid";
import { encode } from "bs58";
import { BIP44, RawTx } from "../../types";

const App = require("near-ledger-js");
const nearAPI = require("near-api-js");

// LEDGER
export class LEDGER {
  static async getAccount(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid
  ): Promise<string> {
    transport.setScrambleKey("NEAR");
    const client = await App.createClient(transport);
    const response = await client.getPublicKey(
      `44'/${path.type}'/${path.account}'/0'/${path.index}'`
    );
    return response ? `ed25519:${encode(response)}` : "";
  }

  static async signTx(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    rawTx: RawTx
  ): Promise<{ [key: string]: any }> {
    const client = await App.createClient(transport);
    const rawPublicKey = await client.getPublicKey(`44'/${path.type}'/${path.account}'/0'/${path.index}'`);
    const publicKey = new nearAPI.utils.PublicKey({
      keyType: nearAPI.utils.key_pair.KeyType.ED25519,
      data: rawPublicKey,
    }); 
    const sender = rawTx.sender;
    const receiver = rawTx.receiver;
    const networkId = rawTx.networkId;
    const amount = nearAPI.utils.format.parseNearAmount(rawTx.amount);
    const provider = new nearAPI.providers
        .JsonRpcProvider(`https://rpc.${networkId}.near.org`);
    const accessKey = await provider.query(
        `access_key/${sender}/${publicKey.toString()}`, ''
    );
    const nonce = ++accessKey.nonce;
    var actions = [nearAPI.transactions.transfer(amount)];
    if (rawTx.isStake) {
      const validator = await nearAPI.utils.PublicKey.fromString(rawTx.validator);
      actions = [nearAPI.transactions.stake(amount, validator)];
    }
    const recentBlockHash = nearAPI.utils.serialize.base_decode(accessKey.block_hash);
    const transaction = nearAPI.transactions.createTransaction(
      sender, 
      publicKey, 
      receiver, 
      nonce, 
      actions, 
      recentBlockHash);
    const response = await client.sign(
      transaction.encode(), `44'/${path.type}'/${path.account}'/0'/${path.index}'`
    );
    return response
  }

  /*
  export function signMessage(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/polkadot/keyStore.ts ---
import { derivePath } from "near-hd-key";
import { naclKeypairFromSeed, encodeAddress } from "@polkadot/util-crypto";
import { BIP44 } from "../../types";

export class KEYSTORE {
  static getAccount(seed: Buffer, path: BIP44): string {
    const ss58Format = 0;
    const { key } = derivePath(
      `m/44'/${path.type}'/${path.account}'/0'/${path.index}'`,
      seed.toString("hex")
    );
    return encodeAddress(
      `0x${Buffer.from(naclKeypairFromSeed(key).publicKey).toString("hex")}`,
      ss58Format
    );
  }
  /*
  static signTx(node: BIP32Interface, rawTx: RawTx): { [key: string]: any } {
    // ...
  }
  */

  /*
  export signMessage(node: BIP32Interface, msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/polkadot/ledger.ts ---
import TransportWebUSB from "@ledgerhq/hw-transport-webusb";
import TransportNodeHid from "@ledgerhq/hw-transport-node-hid";
import { newPolkadotApp } from "@zondax/ledger-polkadot";
import { BIP44 } from "../../types";

// LEDGER
export class LEDGER {
  static async getAccount(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid
  ): Promise<string> {
    const instance = newPolkadotApp(transport);
    const response = await instance.getAddress(
      0x80000000 + path.account,
      0x80000000,
      0x80000000 + path.index
    );
    return response.address;
  }

  /*
  static async signTx(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    rawTx: RawTx
  ): Promise<{ [key: string]: any }> {
    // ...
  }

  export function signMessage(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/solana/hw/index.ts ---
// https://github.com/solana-labs/wallet-provider/blob/master/packages/wallet-ledger/src/core.ts
import type Transport from "@ledgerhq/hw-transport";
import type { Transaction } from "@solana/web3.js";

import { PublicKey } from "@solana/web3.js";

const INS_GET_PUBKEY = 0x05;
const INS_SIGN_MESSAGE = 0x06;

const P1_NON_CONFIRM = 0x00;
const P1_CONFIRM = 0x01;

const P2_EXTEND = 0x01;
const P2_MORE = 0x02;

const MAX_PAYLOAD = 255;

const LEDGER_CLA = 0xe0;

/*
 * Helper for chunked send of large payloads
 */
async function ledgerSend(
  transport: Transport,
  instruction: number,
  p1: number,
  payload: Buffer
) {
  let p2 = 0;
  let payloadOffset = 0;

  if (payload.length > MAX_PAYLOAD) {
    while (payload.length - payloadOffset > MAX_PAYLOAD) {
      const chunk = payload.slice(payloadOffset, payloadOffset + MAX_PAYLOAD);
      payloadOffset += MAX_PAYLOAD;
      /*
      console.log(
        "send",
        // eslint-disable-next-line no-bitwise
        (p2 | P2_MORE).toString(16),
        chunk.length.toString(16),
        chunk
      );
      */
      // eslint-disable-next-line no-await-in-loop
      const reply = await transport.send(
        LEDGER_CLA,
        instruction,
        p1,
        // eslint-disable-next-line no-bitwise
        p2 | P2_MORE,
        chunk
      );
      if (reply.length !== 2) {
        throw new Error("Received unexpected reply payload");
      }
      // eslint-disable-next-line no-bitwise
      p2 |= P2_EXTEND;
    }
  }

  const chunk = payload.slice(payloadOffset);
  // console.log("send", p2.toString(16), chunk.length.toString(16), chunk);
  const reply = await transport.send(LEDGER_CLA, instruction, p1, p2, chunk);

  return reply.slice(0, reply.length - 2);
}

// eslint-disable-next-line no-bitwise
const BIP32_HARDENED_BIT = (1 << 31) >>> 0;
function harden(n: number = 0) {
  // eslint-disable-next-line no-bitwise
  return (n | BIP32_HARDENED_BIT) >>> 0;
}

export function getSolanaDerivationPath(account?: number, change?: number) {
  let length;
  if (account !== undefined) {
    if (change !== undefined) {
      length = 4;
    } else {
      length = 3;
    }
  } else {
    length = 2;
  }

  const derivationPath = Buffer.alloc(1 + length * 4);
  // eslint-disable-next-line
  var offset = 0;
  offset = derivationPath.writeUInt8(length, offset);
  offset = derivationPath.writeUInt32BE(harden(44), offset); // Using BIP44
  offset = derivationPath.writeUInt32BE(harden(501), offset); // Solana's BIP44 path

  if (length > 2) {
    offset = derivationPath.writeUInt32BE(harden(account), offset);
    if (length === 4) {
      // @FIXME: https://github.com/project-serum/spl-token-wallet/issues/59
      // eslint-disable-next-line no-unused-vars
      offset = derivationPath.writeUInt32BE(harden(change), offset);
    }
  }

  return derivationPath;
}

export async function signTransaction(
  transport: Transport,
  transaction: Transaction,
  derivationPath: Buffer = getSolanaDerivationPath()
) {
  const messageBytes = transaction.serializeMessage();
  // eslint-disable-next-line no-use-before-define
  return signBytes(transport, messageBytes, derivationPath);
}

export async function signBytes(
  transport: Transport,
  bytes: Buffer,
  derivationPath: Buffer = getSolanaDerivationPath()
) {
  const numPaths = Buffer.alloc(1);
  numPaths.writeUInt8(1, 0);

  const payload = Buffer.concat([numPaths, derivationPath, bytes]);

  // @FIXME: must enable blind signing in Solana Ledger App per https://github.com/project-serum/spl-token-wallet/issues/71
  // See also https://github.com/project-serum/spl-token-wallet/pull/23#issuecomment-712317053
  return ledgerSend(transport, INS_SIGN_MESSAGE, P1_CONFIRM, payload);
}

export async function getPublicKey(
  transport: Transport,
  derivationPath: Buffer = getSolanaDerivationPath()
) {
  const publicKeyBytes = await ledgerSend(
    transport,
    INS_GET_PUBKEY,
    P1_NON_CONFIRM,
    derivationPath
  );

  return new PublicKey(publicKeyBytes);
}

'''
'''--- src/blockchains/solana/keyStore.ts ---
import nacl from "tweetnacl";
import { encode } from "bs58";
import { derivePath } from "near-hd-key";
import { BIP44 } from "../../types";

export class KEYSTORE {
  static getAccount(seed: Buffer, path: BIP44): string {
    const { key } = derivePath(
      `m/44'/${path.type}'/${path.account}'/${path.index}'`,
      seed.toString("hex")
    );
    const { publicKey } = nacl.sign.keyPair.fromSeed(key);
    return encode(publicKey);
  }
  /*
  static signTx(node: BIP32Interface, rawTx: RawTx): { [key: string]: any } {
    // ...
  }
  */

  /*
  export signMessage(node: BIP32Interface, msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/solana/ledger.ts ---
import TransportWebUSB from "@ledgerhq/hw-transport-webusb";
import TransportNodeHid from "@ledgerhq/hw-transport-node-hid";
import { getPublicKey, getSolanaDerivationPath } from "./hw";
import { BIP44 } from "../../types";

// LEDGER
export class LEDGER {
  static async getAccount(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid
  ): Promise<string> {
    const response = await getPublicKey(
      transport,
      getSolanaDerivationPath(path.account, path.index)
    );
    return response.toBase58();
  }

  /*
  static async signTx(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    rawTx: RawTx
  ): Promise<{ [key: string]: any }> {
    // ...
  }

  export function signMessage(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/terra/keyStore.ts ---
import { BIP32Interface } from "bip32";
import CryptoJS from "crypto-js";
import { bech32 } from "bech32";
// import { RawTx } from "../../types";

export class KEYSTORE {
  static bech32ify(address: string, prefix: string) {
    const words = bech32.toWords(Buffer.from(address, "hex"));
    return bech32.encode(prefix, words);
  }

  static getAccount(node: BIP32Interface): string {
    const message = CryptoJS.enc.Hex.parse(node.publicKey.toString("hex"));
    const temp = CryptoJS.RIPEMD160(CryptoJS.SHA256(message) as any).toString();
    const address = KEYSTORE.bech32ify(temp, "terra");
    return address;
  }

  /*
  static signTx(node: BIP32Interface, rawTx: RawTx): { [key: string]: any } {
    // ...
  }
  */

  /*
  export signMessage(node: BIP32Interface, msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/terra/ledger.ts ---
import TransportWebUSB from "@ledgerhq/hw-transport-webusb";
import TransportNodeHid from "@ledgerhq/hw-transport-node-hid";
import TerraApp, { AddressResponse } from "@terra-money/ledger-terra-js";
import * as secp256k1 from "secp256k1";
import { BIP44, RawTx } from "../../types";

// LEDGER
export class LEDGER {
  static async getAccount(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid
  ): Promise<string> {
    const instance = new TerraApp(transport);
    await instance.initialize();
    const response = (await instance.getAddressAndPubKey(
      [44, path.type, path.account, 0, path.index],
      "terra"
    )) as AddressResponse;
    return response.bech32_address;
  }

  static async signTx(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    rawTx: RawTx
  ): Promise<{ [key: string]: any }> {
    const instance = new TerraApp(transport);
    const response = await instance.sign(
      [44, path.type, path.account, 0, path.index],
      JSON.stringify({ ...rawTx })
    );
    // TODO: test
    const signature = secp256k1.signatureImport(
      Buffer.from(response.signature.data)
    );
    return { signature };
  }

  /*
  export function signMessage(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/tezos/hw/index.ts ---
// https://github.com/LedgerHQ/ledgerjs/blob/master/packages/hw-app-tezos/src/Tezos.ts
import bs58check from "bs58check";

const blake2b = require("blake2b");

export const encodeAddress = (publicKey: Buffer) => {
  const pkhB58Prefix = Buffer.from([6, 161, 159]);
  const key = publicKey;
  const keyHashSize = 20;
  let hash = blake2b(keyHashSize);
  hash.update(key);
  hash.digest((hash = Buffer.alloc(keyHashSize)));
  const address = bs58check.encode(Buffer.concat([pkhB58Prefix, hash]));
  return address;
};

'''
'''--- src/blockchains/tezos/keyStore.ts ---
import nacl from "tweetnacl";
import { derivePath } from "near-hd-key";
import { BIP44 } from "../../types";
import { encodeAddress } from "./hw";

// import { RawTx } from "../../types";

export class KEYSTORE {
  static getAccount(seed: Buffer, path: BIP44): string {
    const { key } = derivePath(
      `m/44'/${path.type}'/${path.account}'/${path.index}'`,
      seed.toString("hex")
    );
    const keyPair = nacl.sign.keyPair.fromSeed(key);
    return encodeAddress(Buffer.from(keyPair.publicKey));
  }

  /*
  static signTx(node: BIP32Interface, rawTx: RawTx): { [key: string]: any } {
    // ...
  }
  */

  /*
  export signMessage(node: BIP32Interface, msg: string) {
    // ...
  }
  */
}

'''
'''--- src/blockchains/tezos/ledger.ts ---
import TransportWebUSB from "@ledgerhq/hw-transport-webusb";
import TransportNodeHid from "@ledgerhq/hw-transport-node-hid";
import Tezos from "@ledgerhq/hw-app-tezos";
import { BIP44 } from "../../types";
// import { RawTx } from "../../types";

// LEDGER
export class LEDGER {
  static async getAccount(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid
  ): Promise<string> {
    const instance = new Tezos(transport as any);
    const response = await instance.getAddress(
      `44'/${path.type}'/${path.account}'/${path.index}'`
    );
    // console.log(response);
    return response.address;
  }
  /*
  static async signTx(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    rawTx: RawTx
  ): Promise<{ [key: string]: any }> {
    // ...
  }

  export function signMessage(
    path: BIP44,
    transport: TransportWebUSB | TransportNodeHid,
    msg: string) {
    // ...
  }
  */
}

'''
'''--- src/index.ts ---
import TransportWebUSB from "@ledgerhq/hw-transport-webusb";
import TransportNodeHid from "@ledgerhq/hw-transport-node-hid";
import { COIN, BIP44, RawTx } from "./types";
import {
  createKeyStore,
  getAccountFromKeyStore,
  signTxFromKeyStore,
} from "./keyStore";
import { getAccountFromLedger, signTxFromLedger } from "./ledger";

export { createKeyStore, COIN, BIP44, RawTx };

interface KeyStore {
  t: number;
  m: number;
  s: string;
  j: string[];
}

interface Ledger {
  keyStore: KeyStore | null;
  transport: TransportWebUSB | TransportNodeHid | null;
}

export class KMS {
  private keyStore: KeyStore | null;

  private transport: TransportWebUSB | TransportNodeHid | null;

  constructor(ledger: Ledger) {
    this.keyStore = ledger.keyStore;
    this.transport = ledger.transport;
  }

  async getAccount(path: BIP44): Promise<string> {
    if (this.keyStore) {
      const account = await getAccountFromKeyStore(
        path,
        this.keyStore,
        path.password || ""
      );
      return account;
    }
    if (this.transport) {
      const account = await getAccountFromLedger(path, this.transport);
      return account;
    }
    return "";
  }

  async signTx(path: BIP44, rawTx: RawTx): Promise<{ [key: string]: any }> {
    if (this.keyStore) {
      const signedTx = await signTxFromKeyStore(
        path,
        this.keyStore,
        path.password || "",
        rawTx
      );
      return signedTx;
    }
    if (this.transport) {
      const response = await signTxFromLedger(path, this.transport, rawTx);
      return response;
    }
    return {};
  }
}

export async function CreateKMS(
  keyStoreJson: KeyStore | null = null
): Promise<KMS> {
  const ledger: Ledger = {
    keyStore: null,
    transport: null,
  };
  if (keyStoreJson) {
    ledger.keyStore = keyStoreJson;
  } else {
    ledger.transport = await TransportWebUSB.create();
  }
  return new KMS(ledger);
}

'''
'''--- src/keyStore.ts ---
import { randomBytes } from "crypto";
import { encode, decode } from "bs58";
import { JWK, JWE, util } from "node-jose";
import { mnemonicToSeedSync } from "bip39";
import { fromSeed } from "bip32";
import { COIN, BIP44, RawTx } from "./types";
import { KEYSTORE as mina } from "./blockchains/mina/keyStore";
import { KEYSTORE as celo } from "./blockchains/celo/keyStore";
import { KEYSTORE as cosmos } from "./blockchains/cosmos/keyStore";
import { KEYSTORE as terra } from "./blockchains/terra/keyStore";
import { KEYSTORE as solana } from "./blockchains/solana/keyStore";
import { KEYSTORE as polkadot } from "./blockchains/polkadot/keyStore";
import { KEYSTORE as kusama } from "./blockchains/kusama/keyStore";
import { KEYSTORE as near } from "./blockchains/near/keyStore";
import { KEYSTORE as flow } from "./blockchains/flow/keyStore";
import { KEYSTORE as tezos } from "./blockchains/tezos/keyStore";

export interface KeyStore {
  t: number;
  m: number;
  s: string;
  j: string[];
}

const LENGTH = 32;
async function getAlgo2HashKey(
  password: string,
  keyStore: KeyStore
): Promise<JWK.Key | null> {
  const { argon2 } = window as { [key: string]: any };
  if (argon2 && argon2.hash) {
    const buf = await argon2.hash({
      pass: password,
      time: keyStore.t,
      mem: keyStore.m,
      salt: decode(keyStore.s),
    });
    const key = await JWK.asKey({
      kty: "oct",
      k: util.base64url.encode(buf.toString("hex")),
    });
    return key;
  }
  return null;
}

export async function createKeyStore(
  mnemonic: string[],
  password: string,
  time: number = 9,
  mem: number = 262144
): Promise<KeyStore | null> {
  const encoder = new TextEncoder();
  const opt = { t: time, m: mem, s: encode(randomBytes(LENGTH)), j: [] };
  const key = await getAlgo2HashKey(password, opt);
  if (key) {
    const jwe = await JWE.createEncrypt(
      { format: "compact", contentAlg: "A256GCM" },
      key
    )
      .update(encoder.encode(mnemonic.join(" ")))
      .final();
    return { ...opt, j: jwe.split(".") };
  }
  return null;
}

export async function getAccountFromKeyStore(
  path: BIP44,
  keyStore: KeyStore,
  password: string
): Promise<string> {
  try {
    const key = await getAlgo2HashKey(password, keyStore);
    if (key && keyStore) {
      const mnemonic = await JWE.createDecrypt(key).decrypt(
        keyStore.j.join(".")
      );
      const seed = mnemonicToSeedSync(mnemonic.plaintext.toString());
      const node = fromSeed(seed);
      const child = node.derivePath(
        `m/44'/${path.type}'/${path.account}'/0/${path.index}`
      );
      switch (path.type) {
        // blockchains
        case COIN.MINA: {
          const account = mina.getAccount(child);
          return account;
        }
        case COIN.CELO: {
          const account = celo.getAccount(child);
          return account;
        }
        case COIN.COSMOS: {
          const account = cosmos.getAccount(child);
          return account;
        }
        case COIN.TERRA: {
          const account = terra.getAccount(child);
          return account;
        }
        case COIN.SOLANA: {
          const account = solana.getAccount(seed, path);
          return account;
        }
        case COIN.POLKADOT: {
          const account = polkadot.getAccount(seed, path);
          return account;
        }
        case COIN.KUSAMA: {
          const account = kusama.getAccount(child);
          return account;
        }
        case COIN.NEAR: {
          const account = near.getAccount(seed, path);
          return account;
        }
        case COIN.FLOW: {
          const account = flow.getAccount(child);
          return account;
        }
        case COIN.TEZOS: {
          const account = tezos.getAccount(seed, path);
          return account;
        }
        // add blockchains....
        // blockchains
        default:
          break;
      }
    }

    return "";
  } catch (error) {
    // eslint-disable-next-line no-console
    console.log(error);
    return "";
  }
}

export async function signTxFromKeyStore(
  path: BIP44,
  keyStore: KeyStore,
  password: string,
  rawTx: RawTx
): Promise<{ [key: string]: any }> {
  try {
    const key = await getAlgo2HashKey(password, keyStore);
    if (key && keyStore) {
      const mnemonic = await JWE.createDecrypt(key).decrypt(
        keyStore.j.join(".")
      );
      const seed = mnemonicToSeedSync(mnemonic.plaintext.toString());
      const node = fromSeed(seed);
      const child = node.derivePath(
        `m/44'/${path.type}'/${path.account}'/0/${path.index}`
      );

      switch (path.type) {
        // blockchains
        case COIN.MINA: {
          const response = mina.signTx(child, rawTx);
          return { ...response };
        }
        // add blockchains....
        // blockchains
        default:
          break;
      }
    }

    return {};
  } catch (error) {
    // eslint-disable-next-line no-console
    console.error(error);
    return {};
  }
}

'''
'''--- src/ledger.ts ---
import TransportWebUSB from "@ledgerhq/hw-transport-webusb";
import TransportNodeHid from "@ledgerhq/hw-transport-node-hid";
import { COIN, BIP44, RawTx } from "./types";
import { LEDGER as mina } from "./blockchains/mina/ledger";
import { LEDGER as terra } from "./blockchains/terra/ledger";
import { LEDGER as flow } from "./blockchains/flow/ledger";
import { LEDGER as solana } from "./blockchains/solana/ledger";
import { LEDGER as near } from "./blockchains/near/ledger";
import { LEDGER as kusama } from "./blockchains/kusama/ledger";
import { LEDGER as polkadot } from "./blockchains/polkadot/ledger";
import { LEDGER as cosmos } from "./blockchains/cosmos/ledger";
import { LEDGER as celo } from "./blockchains/celo/ledger";
import { LEDGER as tezos } from "./blockchains/tezos/ledger";

export async function getAccountFromLedger(
  path: BIP44,
  transport: TransportWebUSB | TransportNodeHid
): Promise<string> {
  try {
    switch (path.type) {
      // blockchains
      case COIN.MINA: {
        const publicKey = await mina.getAccount(path, transport);
        return publicKey;
      }
      case COIN.TERRA: {
        const publicKey = await terra.getAccount(path, transport);
        return publicKey;
      }
      case COIN.FLOW: {
        const publicKey = await flow.getAccount(path, transport);
        return publicKey;
      }
      case COIN.SOLANA: {
        const publicKey = await solana.getAccount(path, transport);
        return publicKey;
      }
      case COIN.NEAR: {
        const publicKey = await near.getAccount(path, transport);
        return publicKey;
      }
      case COIN.KUSAMA: {
        const publicKey = await kusama.getAccount(path, transport);
        return publicKey;
      }
      case COIN.POLKADOT: {
        const publicKey = await polkadot.getAccount(path, transport);
        return publicKey;
      }
      case COIN.COSMOS: {
        const publicKey = await cosmos.getAccount(path, transport);
        return publicKey;
      }
      case COIN.CELO: {
        const publicKey = await celo.getAccount(path, transport);
        return publicKey;
      }
      case COIN.TEZOS: {
        const publicKey = await tezos.getAccount(path, transport);
        return publicKey;
      }
      // add blockchains....
      // blockchains
      default:
        break;
    }
    return "";
  } catch (error) {
    // eslint-disable-next-line no-console
    console.error(error);
    return "";
  }
}

export async function signTxFromLedger(
  path: BIP44,
  transport: TransportWebUSB | TransportNodeHid,
  rawTx: RawTx
): Promise<{ [key: string]: any }> {
  try {
    switch (path.type) {
      // blockchains
      case COIN.MINA: {
        const response = await mina.signTx(path, transport, rawTx);
        return { ...response };
      }
      case COIN.TERRA: {
        const response = await terra.signTx(path, transport, rawTx);
        return { ...response };
      }
      case COIN.COSMOS: {
        const response = await cosmos.signTx(path, transport, rawTx);
        return { ...response };
      }
      case COIN.NEAR: {
        const response = await near.signTx(path, transport, rawTx);
        return { ...response };
      }
      // add blockchains....
      // blockchains
      default:
        break;
    }
    return {};
  } catch (error) {
    // eslint-disable-next-line no-console
    console.error(error);
    return {};
  }
}

'''
'''--- src/types.ts ---
export interface BIP44 {
  type: number;
  account: number;
  index: number;
  password?: string;
}

export interface RawTx {
  [key: string]: any;
}

export const COIN = {
  MINA: 12586,
  TERRA: 330,
  FLOW: 539,
  SOLANA: 501,
  NEAR: 397,
  KUSAMA: 434,
  POLKADOT: 354,
  COSMOS: 118,
  CELO: 52752,
  TEZOS: 1729,
} as const;

'''
'''--- test/keystore.js ---
const { hash } = require("argon2");
const { JWK, JWE, util } = require("node-jose");
const { encode, decode } = require("bs58");
const { randomBytes } = require("crypto");
const { mnemonicToSeedSync } = require("bip39");
const { fromSeed } = require("bip32");
const { COIN } = require("../lib");
const mina = require("../lib/blockchains/mina/keyStore");
const celo = require("../lib/blockchains/celo/keyStore");
const cosmos = require("../lib/blockchains/cosmos/keyStore");
const terra = require("../lib/blockchains/terra/keyStore");
const solana = require("../lib/blockchains/solana/keyStore");
const near = require("../lib/blockchains/near/keyStore");
const tezos = require("../lib/blockchains/tezos/keyStore");
const flow = require("../lib/blockchains/flow/keyStore");
// const polkadot = require("../lib/blockchains/polkadot/keyStore");
// const kusama = require("../lib/blockchains/kusama/keyStore");

const MNEMONIC = require("./mnemonic.json");

const LENGTH = 32;

async function getAlgo2HashKey(password, keyStore) {
  const buf = await hash(password, {
    timeCost: keyStore.t,
    memoryCost: keyStore.m,
    salt: decode(keyStore.s),
    saltLength: LENGTH,
    hashLength: LENGTH,
    raw: true,
  });
  const key = await JWK.asKey({
    kty: "oct",
    k: util.base64url.encode(buf.toString("hex")),
  });
  return key;
}

async function createKeyStore(password) {
  const mnemonic = MNEMONIC.bip44.split(" ");
  const encoder = new TextEncoder();
  const opt = { t: 2, m: 2048, s: encode(randomBytes(LENGTH)), j: [] };
  const key = await getAlgo2HashKey(password, opt);
  const jwe = await JWE.createEncrypt(
    { format: "compact", contentAlg: "A256GCM" },
    key
  )
    .update(encoder.encode(mnemonic.join(" ")))
    .final();
  return { ...opt, j: jwe.split(".") };
}

async function getAccountFromKeyStore(path, keyStore, password) {
  try {
    const key = await getAlgo2HashKey(password, keyStore);
    const mnemonic = await JWE.createDecrypt(key).decrypt(keyStore.j.join("."));
    const seed = mnemonicToSeedSync(mnemonic.plaintext.toString());
    const node = fromSeed(seed);
    const child = node.derivePath(
      `m/44'/${path.type}'/${path.account}'/0/${path.index}`
    );
    switch (path.type) {
      // blockchains
      case COIN.MINA: {
        const account = mina.KEYSTORE.getAccount(child);
        return account;
      }
      case COIN.CELO: {
        const account = celo.KEYSTORE.getAccount(child);
        return account;
      }
      case COIN.COSMOS: {
        const account = cosmos.KEYSTORE.getAccount(child);
        return account;
      }
      case COIN.TERRA: {
        const account = terra.KEYSTORE.getAccount(child);
        return account;
      }
      case COIN.SOLANA: {
        const account = solana.KEYSTORE.getAccount(seed, path);
        return account;
      }
      case COIN.NEAR: {
        const account = near.KEYSTORE.getAccount(seed, path);
        return account;
      }
      case COIN.TEZOS: {
        const account = tezos.KEYSTORE.getAccount(seed, path);
        return account;
      }
      case COIN.FLOW: {
        const account = flow.KEYSTORE.getAccount(child);
        return account;
      }
      /*
      case COIN.POLKADOT: {
        const account = polkadot.KEYSTORE.getAccount(seed, path);
        return account;
      }
      case COIN.KUSAMA: {
        const account = kusama.KEYSTORE.getAccount(child);
        return account;
      }
      */
      // add blockchains....
      // blockchains
      default:
        break;
    }
    return "";
  } catch (error) {
    // eslint-disable-next-line no-console
    console.log(error);
    return "";
  }
}

async function run() {
  const PASSWORD = MNEMONIC.password;
  const accounts = {};
  const keyStore = await createKeyStore(PASSWORD);
  const chains = [
    ["MINA", COIN.MINA],
    ["NEAR", COIN.NEAR],
    ["SOLANA", COIN.SOLANA],
    ["CELO", COIN.CELO],
    ["COSMOS", COIN.COSMOS],
    ["TERRA", COIN.TERRA],
    ["TEZOS", COIN.TEZOS],
    ["FLOW", COIN.FLOW],
    /*
    ["POLKADOT", COIN.POLKADOT],
    ["KUSAMA", COIN.KUSAMA],
    */
  ];
  for (let i = 0; i < chains.length; i += 1) {
    // eslint-disable-next-line no-await-in-loop
    const temp = await getAccountFromKeyStore(
      { type: chains[i][1], account: 0, index: 0 },
      keyStore,
      PASSWORD
    );
    accounts[chains[i][0]] = temp;
  }
  // eslint-disable-next-line no-console
  console.log(accounts);
}

run();

'''
'''--- test/keystore/_getAccount.js ---
const { hash } = require("argon2");
const { JWK, JWE, util } = require("node-jose");
const { encode, decode } = require("bs58");
const { randomBytes } = require("crypto");
const { mnemonicToSeedSync } = require("bip39");
const { fromSeed } = require("bip32");
const { COIN } = require("../../lib");
const mina = require("../../lib/blockchains/mina/keyStore");
const celo = require("../../lib/blockchains/celo/keyStore");
const cosmos = require("../../lib/blockchains/cosmos/keyStore");
const terra = require("../../lib/blockchains/terra/keyStore");
const solana = require("../../lib/blockchains/solana/keyStore");
const near = require("../../lib/blockchains/near/keyStore");
// const flow = require("../../lib/blockchains/flow/keyStore");
// const polkadot = require("../../lib/blockchains/polkadot/keyStore");
// const kusama = require("../../lib/blockchains/kusama/keyStore");

const MNEMONIC = require("../mnemonic.json");

const LENGTH = 32;

async function getAlgo2HashKey(password, keyStore) {
  const buf = await hash(password, {
    timeCost: keyStore.t,
    memoryCost: keyStore.m,
    salt: decode(keyStore.s),
    saltLength: LENGTH,
    hashLength: LENGTH,
    raw: true,
  });
  const key = await JWK.asKey({
    kty: "oct",
    k: util.base64url.encode(buf.toString("hex")),
  });
  return key;
}

async function createKeyStore(password) {
  const mnemonic = MNEMONIC.bip44.split(" ");
  const encoder = new TextEncoder();
  const opt = { t: 2, m: 2048, s: encode(randomBytes(LENGTH)), j: [] };
  const key = await getAlgo2HashKey(password, opt);
  const jwe = await JWE.createEncrypt(
    { format: "compact", contentAlg: "A256GCM" },
    key
  )
    .update(encoder.encode(mnemonic.join(" ")))
    .final();
  return { ...opt, j: jwe.split(".") };
}

async function getAccountFromKeyStore(path, keyStore, password) {
  try {
    const key = await getAlgo2HashKey(password, keyStore);
    const mnemonic = await JWE.createDecrypt(key).decrypt(keyStore.j.join("."));
    const seed = mnemonicToSeedSync(mnemonic.plaintext.toString());
    const node = fromSeed(seed);
    const child = node.derivePath(
      `m/44'/${path.type}'/${path.account}'/0/${path.index}`
    );
    switch (path.type) {
      // blockchains
      case COIN.MINA: {
        const account = mina.KEYSTORE.getAccount(child);
        return account;
      }
      case COIN.CELO: {
        const account = celo.KEYSTORE.getAccount(child);
        return account;
      }
      case COIN.COSMOS: {
        const account = cosmos.KEYSTORE.getAccount(child);
        return account;
      }
      case COIN.TERRA: {
        const account = terra.KEYSTORE.getAccount(child);
        return account;
      }
      case COIN.SOLANA: {
        const account = solana.KEYSTORE.getAccount(seed, path);
        return account;
      }
      case COIN.NEAR: {
        const account = near.KEYSTORE.getAccount(seed, path);
        return account;
      }
      /*
      case COIN.FLOW: {
        const account = flow.KEYSTORE.getAccount(seed, path);
        return account;
      }
      case COIN.POLKADOT: {
        const account = polkadot.KEYSTORE.getAccount(seed, path);
        return account;
      }
      case COIN.KUSAMA: {
        const account = kusama.KEYSTORE.getAccount(child);
        return account;
      }
      */
      // add blockchains....
      // blockchains
      default:
        break;
    }
    return "";
  } catch (error) {
    // eslint-disable-next-line no-console
    console.log(error);
    return "";
  }
}

exports.getAccount = async function getAccount(path, keyStore, password) {
  const account = await getAccountFromKeyStore(path, keyStore, password);
  // eslint-disable-next-line no-console
  console.log("account - ", account);
  return account;
};

exports.getAlgo2HashKey = getAlgo2HashKey;
exports.createKeyStore = createKeyStore;

'''
'''--- test/keystore/mina.js ---
const { JWE } = require("node-jose");
const { mnemonicToSeedSync } = require("bip39");
const { fromSeed } = require("bip32");
const CodaSDK = require("@o1labs/client-sdk");

const { COIN } = require("../../lib");
const mina = require("../../lib/blockchains/mina/keyStore");

const {
  createKeyStore,
  getAccount,
  getAlgo2HashKey,
} = require("./_getAccount");

const MNEMONIC = require("../mnemonic.json");

const TYPE = COIN.MINA;
const INDEX = 0;

async function getDerivePath(path, keyStore, password) {
  const key = await getAlgo2HashKey(password, keyStore);
  const mnemonic = await JWE.createDecrypt(key).decrypt(keyStore.j.join("."));
  const seed = mnemonicToSeedSync(mnemonic.plaintext.toString());
  const node = fromSeed(seed);
  return node.derivePath(
    `m/44'/${path.type}'/${path.account}'/0/${path.index}`
  );
}

async function signTx(path, keyStore, password, account) {
  try {
    const isPayment = false;
    const response = mina.KEYSTORE.signTx(
      await getDerivePath(path, keyStore, password),
      {
        from: account,
        to: "B62qoBEWahYw3CzeFLBkekmT8B7Z1YsfhNcP32cantDgApQ97RNUMhT",
        amount: 3000000,
        fee: 1000000000,
        nonce: 1,
        isPayment,
      }
    );
    // eslint-disable-next-line no-console
    console.log("response - ", response);
    if (response.payload.txType === 0) {
      // eslint-disable-next-line no-console
      console.log(
        "verifyPaymentSignature - ",
        CodaSDK.verifyPaymentSignature(response)
      );
    } else {
      // eslint-disable-next-line no-console
      console.log(
        "verifyStakeDelegationSignature - ",
        CodaSDK.verifyStakeDelegationSignature(response)
      );
    }
  } catch (error) {
    // eslint-disable-next-line no-console
    console.log(error);
  }
}

async function run() {
  const PASSWORD = MNEMONIC.password;
  const keyStore = await createKeyStore(PASSWORD);
  const account = await getAccount(
    { type: TYPE, account: 0, index: INDEX },
    keyStore,
    PASSWORD
  );
  await signTx(
    { type: TYPE, account: 0, index: INDEX },
    keyStore,
    PASSWORD,
    account
  );
}

run();

'''
'''--- test/keystore/near.js ---
const { JWE } = require("node-jose");
const { mnemonicToSeedSync } = require("bip39");
const { COIN } = require("../../lib");
const near = require("../../lib/blockchains/near/keyStore");

const {
  createKeyStore,
  getAccount,
  getAlgo2HashKey,
} = require("./_getAccount");

const MNEMONIC = require("../mnemonic.json");
const TYPE = COIN.NEAR;
const INDEX = 1;

async function getSeed(keyStore, password) {
  const key = await getAlgo2HashKey(password, keyStore);
  const mnemonic = await JWE.createDecrypt(key).decrypt(keyStore.j.join("."));
  const seed = mnemonicToSeedSync(mnemonic.plaintext.toString());
  return seed
}

async function signTx(seed, path) {
  try {
    const isStake = true;
    const response = await near.KEYSTORE.signTx( 
      seed,
      path,
      {
        sender: "kms.testnet",
        receiver: "kms.testnet",
        networkId: "testnet",
        amount: "1.7",
        isStake,
        validator: "ed25519:DiogP36wBXKFpFeqirrxN8G2Mq9vnakgBvgnHdL9CcN3", 
      }
    );
    console.log("response - ", response);

  } catch (error) {
    console.log(error);
  }
}

async function run() {
  const PASSWORD = MNEMONIC.password;
  const keyStore = await createKeyStore(PASSWORD);
  const SEED = await getSeed(
    keyStore,
    PASSWORD
  );
  await getAccount(
    { type: TYPE, account: 0, index: INDEX },
    keyStore,
    PASSWORD
  );
  await signTx(
    SEED, 
    { type: TYPE, account: 0, index: INDEX }
  );
}

run();

'''
'''--- test/ledger.js ---
const TransportNodeHid = require("@ledgerhq/hw-transport-node-hid").default;
const { getAccount } = require("./ledger/_getAccount");
const { COIN } = require("../lib");

const TYPE = COIN.NEAR;
const INDEX = 0;

async function run() {
  const transport = await TransportNodeHid.create(1000);
  await getAccount(transport, TYPE, INDEX);
  transport.close();
}

run();

'''
'''--- test/ledger/_getAccount.js ---
const { KMS } = require("../../lib");

exports.getAccount = async function getAccount(transport, type, index) {
  const kms = new KMS({
    keyStore: null,
    transport,
  });

  const account = await kms.getAccount({
    type,
    account: 0,
    index,
  });
  // eslint-disable-next-line no-console
  console.log("account - ", account);
  return account;
};

'''
'''--- test/ledger/cosmos.js ---
const TransportNodeHid = require("@ledgerhq/hw-transport-node-hid").default;
const { KMS, COIN } = require("../../lib");
const { getAccount } = require("./_getAccount");

const TYPE = COIN.COSMOS;
const INDEX = 0;

async function signTx(transport, type, index) {
  const kms = new KMS({
    keyStore: null,
    transport,
  });
  try {
    const response = await kms.signTx(
      {
        type,
        account: 0,
        index,
      },
      {
        account_number: "6571",
        chain_id: "cosmoshub-2",
        fee: { amount: [{ amount: "5000", denom: "uatom" }], gas: "200000" },
        memo: "Delegated with Ledger from union.market",
        msgs: [
          {
            type: "cosmos-sdk/MsgDelegate",
            value: {
              amount: { amount: "1000000", denom: "uatom" },
              delegator_address:
                "cosmos102hty0jv2s29lyc4u0tv97z9v298e24t3vwtpl",
              validator_address:
                "cosmosvaloper1grgelyng2v6v3t8z87wu3sxgt9m5s03xfytvz7",
            },
          },
        ],
        sequence: "0",
      }
    );
    // eslint-disable-next-line no-console
    console.log("response - ", response);
  } catch (error) {
    // eslint-disable-next-line no-console
    console.log(error);
  }
}

async function run() {
  const transport = await TransportNodeHid.create(1000);
  await getAccount(transport, TYPE, INDEX);
  await signTx(transport, TYPE, INDEX);
  transport.close();
}

run();

'''
'''--- test/ledger/mina.js ---
const TransportNodeHid = require("@ledgerhq/hw-transport-node-hid").default;
const CodaSDK = require("@o1labs/client-sdk");
const { KMS, COIN } = require("../../lib");
const { getAccount } = require("./_getAccount");

const TYPE = COIN.MINA;
const INDEX = 0;

async function signTx(transport, type, index, account) {
  const kms = new KMS({
    keyStore: null,
    transport,
  });
  try {
    const response = await kms.signTx(
      {
        type,
        account: 0,
        index,
      },
      {
        from: account,
        to: "B62qoBEWahYw3CzeFLBkekmT8B7Z1YsfhNcP32cantDgApQ97RNUMhT",
        amount: 3000000,
        fee: 1000000000,
        nonce: 1,
      }
    );
    // eslint-disable-next-line no-console
    console.log("response - ", response);
    if (response.payload.txType === 0) {
      // eslint-disable-next-line no-console
      console.log(
        "verifyPaymentSignature - ",
        CodaSDK.verifyPaymentSignature(response)
      );
    } else {
      // eslint-disable-next-line no-console
      console.log(
        "verifyStakeDelegationSignature - ",
        CodaSDK.verifyStakeDelegationSignature(response)
      );
    }
  } catch (error) {
    // eslint-disable-next-line no-console
    console.log(error);
  }
}

async function run() {
  const transport = await TransportNodeHid.create(1000);
  const account = await getAccount(transport, TYPE, INDEX);
  await signTx(transport, TYPE, INDEX, account);
  transport.close();
}

run();

'''
'''--- test/ledger/near.js ---
const TransportNodeHid = require("@ledgerhq/hw-transport-node-hid").default;
const { KMS, COIN } = require("../../lib");
const { getAccount } = require("./_getAccount");

const TYPE = COIN.NEAR;
const INDEX = 1;

async function signTx(transport, type, index) {
  const kms = new KMS({
    keyStore: null,
    transport,
  });
  try {
    const isStake = false;
    const response = await kms.signTx(
      {
        type,
        account: 0,
        index,
      },
      {
        sender: "kms.testnet",
        receiver: "kms.testnet",
        networkId: "testnet",
        amount: "1.4",
        isStake,
        validator: "ed25519:DiogP36wBXKFpFeqirrxN8G2Mq9vnakgBvgnHdL9CcN3",
      }
    );
    console.log("response - ", response);

  } catch (error) {
    console.log(error);
  }
}

async function run() {
  const transport = await TransportNodeHid.create(1000);
  await getAccount(transport, TYPE, INDEX);
  await signTx(transport, TYPE, INDEX);
  transport.close();
}

run();
'''
'''--- test/mnemonic.sample.json ---
{
  "bip44": "....",
  "password": "strong password"
}
'''
'''--- tsconfig.json ---

{
  "compilerOptions": {
    "lib": ["dom", "es2015", "es2016"],
    "target": "es5",
    "module": "commonjs",
    "moduleResolution": "node",
    "jsx": "preserve",
    "composite": true,
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "strict": true,
    "declaration": true,
    "sourceMap": true,
    "skipLibCheck": true,
    "noImplicitAny": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "rootDir": "src",
    "outDir": "lib"
  },
  "include": ["src", "types/"]
}
'''