*GitHub Repository "mtoan2111/GeFi-Hub"*

'''--- README.md ---
Kiến trúc code trong match

```js
/** 
* Vector chứa các trận đấu đang chờ 
* PersistentVector ~ List ~ Danh sách liên kết đơn/đôi
**/
const waitingMatch = new PersistentVector<Match>("w");
```

```js
/**
* Vector chứa các trận đấu đang diễn ra
* Khi 1 trận đấu đang ở waiting mà đủ người chơi, trận đấu sẽ chuyển sang trạng thái running
* Trình tự: Remove match from waitingMatch Vertor -> Insert to RunningMatch Vector
**/
const runningMatch = new PersistentVector<Match>("r");
```

```js
/**
* Vector chứa các trận đấu đã diễn ra
* Khi 1 trận đấu đang ở running mà đã có kết quả, dữ liệu trận đấu sẽ được lưu vào finishedMatch
* Trình tự: Remove match from runningMatch vector -> Insert to FinishedMatch Vector
**/
const finishedMatch = new PersistentVector<Match>("f");
```

```js
/**
* Vector chứa lịch sử thi đấu của người chơi
* Khi runningMatch hoàn thành, trận đấu sẽ kết thúc
* Hệ thống sẽ ghi nhận người thắng/ thua và lưu vào danh sách lịch sử của người chơi
**/
const historyMatch = new PersistentMap<String, PersistentVector<History>>("h")
```
'''
'''--- asconfig.json ---
{
    "extends": "near-sdk-as/asconfig.json",
    "options": {
        "binaryFile": "out/main.wasm"
    }
}

'''
'''--- assembly/__test__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- assembly/__test__/main.spec.ts ---

'''
'''--- assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- assembly/controller/game.controller.ts ---
import { Game } from "../model/game.model";

export function gm_register(name: String, symbol: String, icon: String | null, space: String, token: String): void {}

'''
'''--- assembly/controller/space.controller.ts ---
import { Context, Storage } from "near-sdk-core";
import { Space } from "../model/space.model";
import { SpaceStorage } from "../storage/space.storage";

export function sp_register(name: String, symbol: String, icon: String | null): Space | null {
    const ownerId = Context.sender;
    if (SpaceStorage.contain(ownerId) && SpaceStorage.contains(ownerId, name)) {
        return SpaceStorage.get(ownerId, name);
    }

    const new_space = new Space(name, symbol, icon);
    SpaceStorage.set(ownerId, new_space);
    return new_space;
}

export function sp_unregisters(): Space[] | null {
    const ownerId = Context.sender;
    return SpaceStorage.deletes(ownerId);
}

export function sp_unregister(name: String): Space | null {
    const ownerId = Context.sender;
    return SpaceStorage.delete(ownerId, name);
}

export function sp_update(name: String, symbol: String, icon: String | null): bool {
    const ownerId = Context.sender;
    const space = SpaceStorage.get(ownerId, name);
    if (space == null) {
        return false;
    }
    
    space.update_symbol(symbol);
    space.update_icon(icon);
    space.save();

    return true;
}

'''
'''--- assembly/controller/token.controller.ts ---
import { Context } from "near-sdk-core";
import { Token } from "../model/token.model";
import { TokenStorage } from "../storage/token.storage";

export function tk_register(name: String, symbol: String, icon: String | null, rate: f64): Token | null {
    const ownerId = Context.sender;
    if (TokenStorage.contain(ownerId) && TokenStorage.contains(ownerId, name)) {
        return TokenStorage.get(ownerId, name);
    }

    const new_token = new Token(name, symbol, icon);
    new_token.update_rate(rate);
    new_token.save();
    return new_token;
}

export function tk_unregisters(): Token[] | null {
    const ownerId = Context.sender;
    return TokenStorage.deletes(ownerId);
}

export function tk_unregister(name: String): Token | null {
    const ownerId = Context.sender;
    return TokenStorage.delete(ownerId, name);
}

export function tk_update(name: String, symbol: String, icon: String | null): bool {
    const ownerId = Context.sender;
    const token = TokenStorage.get(ownerId, name);
    if (token == null) {
        return false;
    }

    token.update_symbol(symbol);
    token.update_icon(icon);
    token.save();

    return true;
}

'''
'''--- assembly/helper/pagination.helper.ts ---
import { logging, math } from "near-sdk-core";

const PAGE_SIZE = 3;

// export type PaginationResult<T> = {
//     page: i32;
//     total: i32;
//     data: T[]
// }

@nearBindgen
export class PaginationResult<T> {
    constructor(public page: i32, public total: i32, public data: T[]) {}
}

export function pagination<T>(args: T[], page: i32): PaginationResult<T> {
    if (page < 1) {
        page = 1;
    }

    const maxPage = floor(args.length / PAGE_SIZE) + 1;
    if (page > maxPage) {
        page = maxPage;
    }

    const startIndex = args.length - (page - 1) * PAGE_SIZE - 1;
    const endIndex = max(0, startIndex - PAGE_SIZE);

    let resultDatas = new Array<T>(PAGE_SIZE);
    for (let i = startIndex; i >= endIndex; i--) {
        resultDatas[startIndex - i] = args[i];
    }
    return new PaginationResult(page, args.length, resultDatas);
}

'''
'''--- assembly/helper/response.helper.ts ---
export function ErrorResponse(code: string): String {
    return `{"code": ${code}}`;
}

'''
'''--- assembly/helper/transform.helper.ts ---
import { u128 } from "near-sdk-as";
import { NEAR_RATE, NEAR_YOCTO } from "../model/fee.model";

export function GeFiTransformer(value: u128): u128 {
    const decimalDeposit: u128 = u128.div(value, u128.from(NEAR_YOCTO));
    const tokenEarner: u128 = u128.mul(decimalDeposit, u128.from(NEAR_RATE));
    return tokenEarner;
}

export function GeFiInversion(value: u128): u128 {
    const tokenInvert: u128 = u128.div(value, u128.from(NEAR_RATE));
    const yoctoWithDraw: u128 = u128.mul(tokenInvert, u128.from(NEAR_YOCTO));
    return yoctoWithDraw;
}

'''
'''--- assembly/index.ts ---

'''
'''--- assembly/model/game.model.ts ---
import { Space } from "./space.model";
import { Token } from "./token.model";

@nearBindgen
export class Game {
    public token: Token;
    constructor(public name: String, public symbol: String, public icon: String | null, public space: Space) {}

    update_token(token: Token) {
        if (!this.token.compare(token)) {
            this.token = token;
        }
    }
}

'''
'''--- assembly/model/space.model.ts ---
import { Context } from "near-sdk-core";
import { SpaceStorage } from "../storage/space.storage";

@nearBindgen
export class Space {
    public owner: String;
    constructor(public name: String, public symbol: String, public icon: String | null) {
        this.owner = Context.sender;
    }

    update_symbol(symbol: String) {
        if (symbol != this.symbol) {
            this.symbol = symbol;
        }
    }

    update_icon(icon: String | null) {
        if (icon != this.icon) {
            this.icon = icon;
        }
    }

    save() {
        SpaceStorage.set(this.owner, this);
    }
}

'''
'''--- assembly/model/token.model.ts ---
import { u128 } from "near-sdk-core";
import { TokenStorage } from "../storage/token.storage";

@nearBindgen
export class Token {
    private rate: f64;
    constructor(public name: String, public symbol: String, public icon: String | null) {
        this.rate = 0;
    }

    update_rate(value: f64) {
        if (this.rate != value && value > 0) {
            this.rate = value;
        }
    }

    update_symbol(symbol: String) {
        if (this.symbol != symbol) {
            this.symbol = symbol;
        }
    }

    update_icon(icon: String | null) {
        if (this.icon != icon) {
            this.icon = icon;
        }
    }

    compare(cp_token: Token): bool {
        if (this.name != cp_token.name) {
            return false;
        }

        if (this.symbol != cp_token.symbol) {
            return false;
        }

        if (this.icon != cp_token.icon) {
            return false;
        }

        if (this.rate != cp_token.rate) {
            return false;
        }

        return true;
    }

    save() {
        TokenStorage.set(this.name, this);
    }
}

'''
'''--- assembly/storage/game.storage.ts ---
import { PersistentUnorderedMap } from "near-sdk-core";
import { Game } from "../model/game.model";
import { Space } from "../model/space.model";

const gefi_Games = new PersistentUnorderedMap<String, PersistentUnorderedMap<String, Game>>("gGm");
/**
 * spaces(games())
 */

export class GameStorage {
    static get(space: String, name: String): Game | null {
        if (!gefi_Games.contains(space)) {
            return null;
        }
        const pm_games: PersistentUnorderedMap<String, Game> = gefi_Games.getSome(space);
        if (!pm_games.contains(space)) {
            return null;
        }

        return pm_games.getSome(space);
    }

    static gets(space: String): Game[] {
        if (!gefi_Games.contains(space)) {
            return new Array<Game>(0);
        }
        return gefi_Games.getSome(space).values();
    }

    static set(space: String, game: Game): void {
        if (!gefi_Games.contains(space)) {
            const pm_spaces = new PersistentUnorderedMap<String, Game>(`${space}::${game.name}`);
            pm_spaces.set(game.name, game);
            gefi_Games.set(space, pm_spaces);
            return;
        }
        const pm_spaces = gefi_Games.getSome(space);
        pm_spaces.set(game.name, game);
        gefi_Games.set(space, pm_spaces);
    }

    static contain(owner: String): bool {
        return gefi_Games.contains(owner);
    }

    static contains(owner: String, space: String): bool {
        if (!gefi_Games.contains(owner)) {
            return false;
        }
        return gefi_Games.getSome(owner).contains(space);
    }

    static delete(owner: String, space: String): Game | null {
        if (!gefi_Games.contains(owner)) {
            return null;
        }
        const pm_spaces = gefi_Games.getSome(owner);
        if (!pm_spaces.contains(space)) {
            return null;
        }
        const dl_space = pm_spaces.getSome(space);
        gefi_Games.delete(owner);
        return dl_space;
    }

    static deletes(owner: String): Game[] | null {
        if (!gefi_Games.contains(owner)) {
            return null;
        }
        const dl_spaces = gefi_Games.getSome(owner).values();
        gefi_Games.delete(owner);
        return dl_spaces;
    }
}

'''
'''--- assembly/storage/space.storage.ts ---
import { PersistentUnorderedMap } from "near-sdk-core";
import { Space } from "../model/space.model";

const gefi_Spaces = new PersistentUnorderedMap<String, PersistentUnorderedMap<String, Space>>("gSp");

export class SpaceStorage {
    static get(owner: String, space: String): Space | null {
        if (!gefi_Spaces.contains(owner)) {
            return null;
        }
        const pm_spaces: PersistentUnorderedMap<String, Space> = gefi_Spaces.getSome(owner);
        if (!pm_spaces.contains(space)) {
            return null;
        }

        return pm_spaces.getSome(space);
    }

    static gets(owner: String): Space[] {
        if (!gefi_Spaces.contains(owner)) {
            return new Array<Space>(0);
        }
        return gefi_Spaces.getSome(owner).values();
    }

    static set(owner: String, space: Space): void {
        if (!gefi_Spaces.contains(owner)) {
            const pm_spaces = new PersistentUnorderedMap<String, Space>(`${owner}::${space}`);
            pm_spaces.set(space.name, space);
            gefi_Spaces.set(owner, pm_spaces);
            return;
        }
        const pm_spaces = gefi_Spaces.getSome(owner);
        pm_spaces.set(space.name, space);
        gefi_Spaces.set(owner, pm_spaces);
    }

    static contain(owner: String): bool {
        return gefi_Spaces.contains(owner);
    }

    static contains(owner: String, space: String): bool {
        if (!gefi_Spaces.contains(owner)) {
            return false;
        }
        return gefi_Spaces.getSome(owner).contains(space);
    }

    static delete(owner: String, space: String): Space | null {
        if (!gefi_Spaces.contains(owner)) {
            return null;
        }
        const pm_spaces = gefi_Spaces.getSome(owner);
        if (!pm_spaces.contains(space)) {
            return null;
        }
        const dl_space = pm_spaces.getSome(space);
        gefi_Spaces.delete(owner);
        return dl_space;
    }

    static deletes(owner: String): Space[] | null {
        if (!gefi_Spaces.contains(owner)) {
            return null;
        }
        const dl_spaces = gefi_Spaces.getSome(owner).values();
        gefi_Spaces.delete(owner);
        return dl_spaces;
    }
}

'''
'''--- assembly/storage/token.storage.ts ---
import { PersistentUnorderedMap } from "near-sdk-core";
import { Token } from "../model/token.model";

const gefi_Tokens = new PersistentUnorderedMap<String, PersistentUnorderedMap<String, Token>>("gtk");

export class TokenStorage {
    static get(owner: String, token: String): Token | null {
        if (!gefi_Tokens.contains(owner)) {
            return null;
        }
        const pm_Tokens: PersistentUnorderedMap<String, Token> = gefi_Tokens.getSome(owner);
        if (!pm_Tokens.contains(token)) {
            return null;
        }

        return pm_Tokens.getSome(token);
    }

    static gets(owner: String): Token[] {
        if (!gefi_Tokens.contains(owner)) {
            return new Array<Token>(0);
        }
        return gefi_Tokens.getSome(owner).values();
    }

    static set(owner: String, token: Token): void {
        if (!gefi_Tokens.contains(owner)) {
            const pm_Tokens = new PersistentUnorderedMap<String, Token>(`${owner}::${token}`);
            pm_Tokens.set(token.name, token);
            gefi_Tokens.set(owner, pm_Tokens);
            return;
        }
        const pm_Tokens = gefi_Tokens.getSome(owner);
        pm_Tokens.set(token.name, token);
        gefi_Tokens.set(owner, pm_Tokens);
    }

    static contain(owner: String): bool {
        return gefi_Tokens.contains(owner);
    }

    static contains(owner: String, token: String): bool {
        if (!gefi_Tokens.contains(owner)) {
            return false;
        }
        return gefi_Tokens.getSome(owner).contains(token);
    }

    static delete(owner: String, token: String): Token | null {
        if (!gefi_Tokens.contains(owner)) {
            return null;
        }
        const pm_Tokens = gefi_Tokens.getSome(owner);
        if (!pm_Tokens.contains(token)) {
            return null;
        }
        const dl_Token = pm_Tokens.getSome(token);
        gefi_Tokens.delete(owner);
        return dl_Token;
    }

    static deletes(owner: String): Token[] | null {
        if (!gefi_Tokens.contains(owner)) {
            return null;
        }
        const dl_Tokens = gefi_Tokens.getSome(owner).values();
        gefi_Tokens.delete(owner);
        return dl_Tokens;
    }
}

'''
'''--- assembly/tsconfig.json ---
{
    "extends": "../node_modules/assemblyscript/std/assembly.json",
    "include": [
      "./**/*.ts",
      "../node_modules/**/*/as_types.d.ts"
    ]
  }
  
'''
'''--- assembly/user.ts ---
// import { Context, logging, PersistentMap, PersistentSet, PersistentUnorderedMap, PersistentVector, u128 } from "near-sdk-as";
// import { AccountId, History, NEAR_RATE, NEAR_YOCTO, User } from "./model";

// export let users = new PersistentUnorderedMap<String, User>("um");
// export let userHistories = new PersistentMap<String, PersistentSet<History>>("uh");
// // let userId = new PersistentSet<String>("us");

// export function createUser(alias: string, bio: string, avatar: string): User {
//     if (users.contains(Context.sender)) {
//         //Todo
//         /**
//          * Nếu attachedDeposit lớn hơn 0 thì topup vào tài khoản user
//          */
//         if (u128.gt(Context.attachedDeposit, u128.from("0"))) {
//             topUp();
//         }
//         return users.getSome(Context.sender);
//     }

//     const user = new User(alias, bio, avatar);
//     users.set(Context.sender, user);
//     return user;
// }

// export function updateUser(alias: string, bio: string, avatar: string): boolean {
//     if (users.contains(Context.sender)) {
//         let user = users.getSome(Context.sender);
//         user.alias = alias;
//         user.bio = bio;
//         user.avatar = avatar;
//         users.set(Context.sender, user);
//         return true;
//     }
//     return false;
// }

// export function getUser(id: AccountId): User | null {
//     if (users.contains(id)) {
//         return users.getSome(id);
//     }
//     return null;
// }

// export function getUsers(): User[] {
//     return users.values();
// }

// export function deleteUser(id: AccountId): boolean {
//     if (users.contains(id)) {
//         users.delete(id);
//         return true;
//     }
//     return false;
// }

// export function getHistory(id: AccountId): History[] {
//     if (userHistories.contains(id)) {
//         return userHistories.getSome(id).values();
//     }
//     return new Array<History>(0);
// }

// export function topUp(): User {
//     let user: User;
//     const attachedDeposite: u128 = Context.attachedDeposit;
//     const floatDeposit: u128 = u128.div(attachedDeposite, u128.from(NEAR_YOCTO));
//     if (users.contains(Context.sender)) {
//         user = users.getSome(Context.sender);
//         const newToken = u128.add(user.token, u128.mul(floatDeposit, u128.from(NEAR_RATE)));
//         user.token = newToken;
//         users.set(Context.sender, user);
//     } else {
//         user = new User(Context.sender, "", "");
//         const newToken = u128.mul(floatDeposit, u128.from(NEAR_RATE));
//         user.token = newToken;
//         users.set(Context.sender, user);
//     }
//     return user;
// }

// export function withDraw(): void{
// }
'''
'''--- cmds_test.txt ---
npx asb && near deploy

near call neutrino.testnet createUser '{"alias": "Hieu", "bio":"Hieu", "avatar": "Hieu"}'  --account-id neutrino.testnet --deposit 10

near call neutrino.testnet createMatch '{"mode": 1, "bet":1000}'  --account-id neutrino.testnet

near call neutrino.testnet getMatch  --account-id neutrino.testnet

near call neutrino.testnet getUser  '{"id": "neutrino.testnet"}' --account-id neutrino.testnet

near call neutrino.testnet topUp  --account-id neutrino.testnet

near call neutrino.testnet updateMatch '{"id": "C1tbALg81eAv864kXLhRtnboYsioa39jJvS3iD6ZWjJ7K6xw", "state":2, "result":0, "winner":"neutrino.testnet"}'  --account-id neutrino.testnet

near call neutrino.testnet joinMatch '{"id":"C1tbALg81eAv864kXLhRtnboYsioa39jJvS3iD6ZWjJ7K6xw", "accountId":"gefitesth.testnet"}' --accountId gefitesth.testnet

--gas=300000000000000

near call mtoan2193.testnet createUser '{"alias": "ToanNm", "bio":"toan", "avatar": ""}' --accountId mtoan2111.testnet
near call mtoan2193.testnet createMatch '{"mode": 1, "bet":"1000"}'  --account-id mtoan2111.testnet
near call mtoan2193.testnet getMatch '{}' --accountId mtoan2111.testnet
near call mtoan2193.testnet joinMatch '{"id":"qCsqqzSCyFzHgKCED2yfi7NDBDA4p8ioif579rQG3VzZxNY9J", "accountId": "mtoan2193.testnet"}' --accountId mtoan2193.testnet
near call mtoan2193.testnet updateMatch '{"id":"qCsqqzSCyFzHgKCED2yfi7NDBDA4p8ioif579rQG3VzZxNY9J", "state":2, "result": 0, "winner": "mtoan2193.testnet"}' --accountId mtoan2193.testnet  --gas=300000000000000

Windows

near call neutrino.testnet createUser '{\"alias\": \"Hieu\", \"bio\":\"Hieu\", \"avatar\": \"Hieu\"}'  --account-id neutrino.testnet --deposit 20 --gas=300000000000000
near call neutrino.testnet createMatch '{\"mode\": 1, \"bet\":\"1000\"}'  --account-id neutrino.testnet --gas=300000000000000
near call neutrino.testnet joinMatch '{\"id\":\"C1tbALg81eAv864kXLhRtnboYsioa39jJvS3iD6ZWjJ7K6xw\"}' --accountId gefitesth.testnet --gas=300000000000000
near call neutrino.testnet getUser  '{\"id\": \"neutrino.testnet\"}' --account-id neutrino.testnet --gas=300000000000000
near call neutrino.testnet startMatch '{\"id\":\"C1tbALg81eAv864kXLhRtnboYsiobhTsxSqaLYEBN8bp2Piw\"}' --accountId neutrino.testnet --gas=300000000000000
near call neutrino.testnet getMatch  --account-id neutrino.testnet --gas=300000000000000

near call neutrino.testnet finishMatch '{\"id\": \"C1tbALg81eAv864kXLhRtnboYsiobhTsxSqaLYEBN8bp2Piw\", \"result\":0, \"winner\":\"gefitesth.testnet\"}' --accountId neutrino.testnet --gas=300000000000000
near call neutrino.testnet cancelMatch '{\"id\":\"C1tbALg81eAv864kXLhRtnboYsiobhTxpraR924mhyaDuWMQ\"}'  --account-id neutrino.testnet --gas=300000000000000

'''
'''--- package.json ---
{
  "name": "match",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "env-cmd": "^10.1.0",
    "near-cli": "^2.1.1",
    "near-sdk-as": "^3.2.3",
    "nodemon": "^2.0.12",
    "regenerator-runtime": "^0.13.9",
    "source-map-support": "^0.5.19"
  }
}

'''
'''--- src/config.js ---
// const CONTRACT_NAME = "neutrino.testnet";
const CONTRACT_NAME = "mtoan2193.testnet";

function getConfig(env) {
    switch (env) {
        case "production":
            return {
                networkId: "mainnet",
                nodeUrl: "https://rpc.mainnet.near.org",
                contractName: CONTRACT_NAME,
                walletUrl: "https://wallet.mainnet.near.org",
                helperUrl: "https://helper.mainnet.near.org",
            };
        case "development":
        case "testnet":
            return {
                networkId: "default",
                nodeUrl: "https://rpc.testnet.near.org",
                contractName: CONTRACT_NAME,
                walletUrl: "https://wallet.testnet.near.org",
                helperUrl: "https://helper.testnet.near.org",
            };
        case "betanet":
            return {
                networkId: "betanet",
                nodeUrl: "https://rpc.betanet.near.org",
                contractName: CONTRACT_NAME,
                walletUrl: "https://wallet.betanet.near.org",
                helperUrl: "https://helper.betanet.near.org",
            };
        case "local":
            return {
                networkId: "local",
                nodeUrl: "http://localhost:3030",
                keyPath: `${process.env.HOME}/.near/validator_key.json`,
                walletUrl: "http://localhost:4000/wallet",
                contractName: CONTRACT_NAME,
            };
        default:
            throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`);
    }
}

module.exports = getConfig;

'''