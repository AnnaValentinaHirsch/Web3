*GitHub Repository "Peersyst/sequelize-typescript-auto-migrations"*

'''--- .vscode/launch.json ---
{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [
    {
      "type": "pwa-node",
      "request": "launch",
      "name": "Make /example",
      "skipFiles": [
        "<node_internals>/**"
      ],
      "cwd": "${workspaceFolder}/example",
      "outputCapture": "std",
      "runtimeExecutable": "ts-node",
      "runtimeArgs": [ 
        "../bin/sequelize-ts.ts",
        "create"
      ],
      "outFiles": [
        "${workspaceFolder}/**/*.js"
      ]
    },
    {
      "type": "pwa-node",
      "request": "launch",
      "name": "Run /example",
      "skipFiles": [
        "<node_internals>/**"
      ],
      "cwd": "${workspaceFolder}/example",
      "outputCapture": "std",
      "runtimeExecutable": "ts-node",
      "runtimeArgs": [ 
        "../bin/sequelize-ts.ts",
        "run"
      ],
      "outFiles": [
        "${workspaceFolder}/**/*.js"
      ]
    }
  ]
}
'''
'''--- README.md ---
# sequelize-auto-migrations
Migration generator &amp;&amp; runner for sequelize

This package provide two tools:
* `sequelize-ts create` - tool for create new migrations
* `sequelize-ts run` - tool for apply created by first tool migrations

## Install
`todo`

## Usage
* Init sequelize, with sequelize-cli, using `sequelize init`
* Create your models
* Create initial migration - run:

`sequelize-ts create --name <migration name>`
* Change models and run it again, model difference will be saved to the next migration

To preview new migration, without any changes, you can run:

`sequelize-ts create --preview`

`sequelize-ts create` tool creates `_current.json` file in `migrations` dir, that is used to calculate difference to the next migration. Do not remove it!

To create and then execute migration, use:
`sequelize-ts create --name <name> -x`

## Executing migrations
* There is simple command to perform all created migrations (from selected revision):

`sequelize-ts run`
* To select a revision, use `--rev <x>`
* If migration fails, you can continue, use `--pos <x>`
* To prevent execution next migrations, use `--one`

For more information, use `sequelize-ts create --help`, `runmigration --help`

## TODO:
* Migration action sorting procedure need some fixes. When many foreign keys in tables, there is a bug with action order. Now, please check it manually (`--preview` option)
* Need to check (and maybe fix) field types: `BLOB`, `RANGE`, `ARRAY`, `GEOMETRY`, `GEOGRAPHY`
* Downgrade is not supported, add it
* This module tested with postgresql (I use it with my projects). Test with mysql and sqlite.

'''
'''--- bin/cmds/create.ts ---
#!/usr/bin/env node
import { js_beautify } from "js-beautify";
import { Sequelize } from "sequelize-typescript";
import * as path from "path";
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "fs";
import {
  executeMigration,
  getMigration,
  parseDifference,
  reverseModels,
  sortActions,
  writeMigration,
} from "../../lib/migrate";
import { each, uniqueId } from "lodash";
import { importSequelizeModel } from "../../lib/import";
import { build } from "../../lib/options";
import { BaseOptions } from "../../lib/types";

interface CreateOptions extends BaseOptions {
  name: string;
  preview: boolean;
  execute: boolean;
  comment?: string;
}

export const command = "create";

export const description = "create a new migration with your current models";

export const builder = {
  name: {
    describe: "describe your newly generated migration",
    type: "string",
    default: uniqueId(),
  },
  preview: {
    describe: "print current changes instead of writing to a file",
    type: "boolean",
    default: false,
  },
  comment: {
    describe: "a longer description for inside of the file",
    type: "string",
  },
  execute: {
    describe: "run the migration right after creating it",
    type: "boolean",
    default: false,
  },
  "migrations-path": {
    type: "string",
    describe: "The path to the migrations folder",
  },
  "models-path": {
    type: "string",
    describe: "The path to the models folder",
  },
  project: {
    type: "string",
    describe: "Relative path to tsconfig file",
  },
};

export const handler = async (args: CreateOptions) => {
  // Support Windows
  if (!process.env.PWD) {
    process.env.PWD = process.cwd();
  }

  const options = build(args);

  if (!existsSync(options.modelsDirectory)) {
    console.log(options.modelsDirectory);
    console.log(
      "Can't find models directory. Use `sequelize init` to create it"
    );
    return;
  }

  if (!existsSync(options.migrationsDirectory)) {
    console.log("Can't find migrations directory. Creating an empty one");
    mkdirSync(options.migrationsDirectory);
  }

  // current state
  const currentState = {
    tables: {},
    revision: null,
  };

  // load last state
  let previousState = {
    revision: 0,
    version: 1,
    tables: {},
  };

  try {
    previousState = JSON.parse(
      readFileSync(
        path.join(options.migrationsDirectory, "_current.json")
      ).toString()
    );
  } catch (e) {}

  //console.log(path.join(migrationsDir, '_current.json'), JSON.parse(fs.readFileSync(path.join(migrationsDir, '_current.json') )))

  const sequelize: Sequelize = await importSequelizeModel(options);

  let models = sequelize.models;

  currentState.tables = reverseModels(sequelize, models);

  let actions = parseDifference(previousState.tables, currentState.tables);

  // sort actions
  sortActions(actions);

  let migration = getMigration(actions);

  if (migration.commandsUp.length === 0) {
    console.log("No changes found");
    process.exit(0);
  }

  // log migration actions
  each(migration.consoleOut, (v) => {
    console.log("[Actions] " + v);
  });

  if (args.preview) {
    console.log("Migration result:");
    console.log(
      js_beautify("[ \n" + migration.commandsUp.join(", \n") + " \n];\n")
    );
    process.exit(0);
  }

  // backup _current file
  if (existsSync(path.join(options.migrationsDirectory, "_current.json"))) {
    writeFileSync(
      path.join(options.migrationsDirectory, "_current_bak.json"),
      readFileSync(path.join(options.migrationsDirectory, "_current.json"))
    );
  }

  // save current state
  currentState.revision = previousState.revision + 1;
  writeFileSync(
    path.join(options.migrationsDirectory, "_current.json"),
    JSON.stringify(currentState, null, 4)
  );

  // write migration to file
  let info = writeMigration(
    currentState.revision,
    migration,
    options.migrationsDirectory,
    args.name ? args.name : "noname",
    args.comment ? args.comment : ""
  );

  console.log(
    `New migration to revision ${currentState.revision} has been saved to file '${info.filename}'`
  );

  if (args.execute) {
    executeMigration(sequelize.getQueryInterface(), info.filename, 0, (err) => {
      if (!err) console.log("Migration has been executed successfully");
      else console.log("Errors, during migration execution", err);
      process.exit(0);
    });
  } else {
    process.exit(0);
  }
};

'''
'''--- bin/cmds/run.ts ---
#!/usr/bin/env node
const path = require("path");
const Async = require("async");

import { existsSync, readdirSync } from "fs";
import { executeMigration } from "../../lib/migrate";
import { build } from "../../lib/options";
import { importSequelizeModel } from "../../lib/import";
import { BaseOptions } from "../../lib/types";

interface RunOptions extends BaseOptions {
  one?: boolean;
  pos: number;
  rev: number;
}

export const command = "run";

export const description = "run migrations to your database";

export const builder = {
  rev: {
    alias: "r",
    describe: "which revision to start migrating from",
    default: 0,
    type: "number",
  },
  pos: {
    alias: "p",
    describe: "which operation to start migrating from",
    type: "number",
    default: 0,
  },
  one: {
    describe: "run a single migration revision",
    defaultValue: false,
    type: "boolean",
  },
  "migrations-path": {
    describe: "override the .sequelizerc directory for migrations",
    type: "string",
  },
  "models-path": {
    describe: "override the .sequelizerc directory for models",
    type: "string",
  },
  project: {
    describe: "relative path to which tsconfig.json to use",
    type: "string",
  },
};

export const handler = async (options: RunOptions) => {
  // Windows support
  if (!process.env.PWD) {
    process.env.PWD = process.cwd();
  }

  let baseOptions = build(options);

  if (!existsSync(baseOptions.modelsDirectory)) {
    console.log(baseOptions.modelsDirectory);
    console.log(
      "Can't find models directory. Use `sequelize init` to create it"
    );
    return;
  }

  if (!existsSync(baseOptions.migrationsDirectory)) {
    console.log(
      "Can't find migrations directory. Use `makemigration` to create your initial migration"
    );
    return;
  }

  const sequelize = await importSequelizeModel(baseOptions);
  const queryInterface = sequelize.getQueryInterface();

  // execute all migration from
  let fromRevision = options.rev;
  let fromPos = options.pos;
  let stop = options.one;

  let migrationFiles = readdirSync(baseOptions.migrationsDirectory)
    // filter JS files
    .filter((file) => {
      return file.indexOf(".") !== 0 && file.slice(-3) === ".ts";
    })
    // sort by revision
    .sort((a, b) => {
      let revA = parseInt(path.basename(a).split("-", 2)[0]),
        revB = parseInt(path.basename(b).split("-", 2)[0]);
      if (revA < revB) return -1;
      if (revA > revB) return 1;
      return 0;
    })
    // remove all migrations before fromRevision
    .filter((file) => {
      let rev = parseInt(path.basename(file).split("-", 2)[0]);
      return rev >= fromRevision;
    });

  console.log("Migrations to execute:");
  migrationFiles.forEach((file) => {
    console.log("\t" + file);
  });

  Async.eachSeries(
    migrationFiles,
    (file, cb) => {
      console.log("Execute migration from file: " + file);
      executeMigration(
        queryInterface,
        path.join(baseOptions.migrationsDirectory, file),
        fromPos,
        (err) => {
          if (stop) {
            return cb("Stopped");
          }
          cb(err);
        }
      );
      // set pos to 0 for next migration
      fromPos = 0;
    },
    function (err) {
      console.log(err);
      process.exit(0);
    }
  );
};

'''
'''--- bin/sequelize-ts.ts ---
#!/usr/bin/env node
import "reflect-metadata";
import * as createCommand from "./cmds/create";
import * as runCommand from "./cmds/run";

require("yargs/yargs")(process.argv.slice(2))
  .command(createCommand)
  .command(runCommand)
  .demandCommand()
  .help().argv;

'''
'''--- example/config/config.json ---
{
  "storage": "database.sqlite",
  "dialect": "sqlite"
}
'''
'''--- example/models/account.ts ---
import {
  AutoIncrement,
  Column,
  DataType,
  Default,
  Model,
  PrimaryKey,
  Table,
} from "sequelize-typescript";

@Table({
  tableName: "account",
  timestamps: false,
  underscored: true,
})
export class Account extends Model {
  @AutoIncrement
  @PrimaryKey
  @Column
  id: number;

  @Default(1000)
  @Column(DataType.BIGINT)
  testParam: string;

  @Default("abc")
  @Column
  firstName: string;

  @Default("")
  @Column
  lastName: string;

  @Column
  nickname: string;

  @Column
  gender: "male" | "female" | "other";

  @Column(DataType.DATEONLY)
  birthDate: Date;

  @Column
  lastLoginDate: Date;

  @Column
  createdAt: Date;

  @Column
  email: string;

  @Column
  password: string;

  @Column
  isDeleted: boolean;

  @Column
  isBlocked: boolean;
}

'''
'''--- example/models/city.ts ---
import {
  AutoIncrement,
  Column,
  Model,
  PrimaryKey,
  Table,
} from "sequelize-typescript";

@Table({
  tableName: "city",
})
export class City extends Model {
  @AutoIncrement
  @PrimaryKey
  @Column
  id: number;

  @Column
  title: string;

  @Column
  display: string;
}

'''
'''--- example/models/country.ts ---
import {
  AllowNull,
  AutoIncrement,
  Column,
  Index,
  Model,
  PrimaryKey,
  Table,
} from "sequelize-typescript";

@Table({
  tableName: "country",
  underscored: true,
  timestamps: false,
})
export class Country extends Model {
  @AutoIncrement
  @PrimaryKey
  @Column
  id: number;

  @Index
  @AllowNull(false)
  @Column
  title: string;

  @Index
  @AllowNull(false)
  @Column
  display: boolean;
}

'''
'''--- example/models/geo.ts ---
import {
  AllowNull,
  AutoIncrement,
  Column,
  DataType,
  Model,
  PrimaryKey,
  Table,
} from "sequelize-typescript";

@Table({
  tableName: "geo",
})
export class Geo extends Model {
  @AutoIncrement
  @PrimaryKey
  @Column
  id: number;

  @AllowNull(false)
  @Column(DataType.GEOMETRY)
  geometry_1: number;

  @AllowNull(false)
  @Column(DataType.GEOMETRY("POINT"))
  geometry_2: number;

  @AllowNull(false)
  @Column(DataType.GEOMETRY("POINT", 4326))
  geometry_3: number;
}

'''
'''--- example/models/index.ts ---
import { Sequelize } from "sequelize-typescript";
import { Account } from "./account";
import { City } from "./city";
import { Country } from "./country";
import { Geo } from "./geo";
import { PurchaseProducts } from "./purchaseProducts";

const config = require("../config/config.json");

const sequelize = new Sequelize(config);

sequelize.addModels([Account, City, Country, Geo, PurchaseProducts]);

export default {
  sequelize,
  Sequelize,
};

'''
'''--- example/models/purchaseProducts.ts ---
import {
  AllowNull,
  AutoIncrement,
  Column,
  DataType,
  Model,
  PrimaryKey,
  Table,
} from "sequelize-typescript";

@Table({
  tableName: "purchaseProducts",
})
export class PurchaseProducts extends Model {
  @AutoIncrement
  @PrimaryKey
  @Column(DataType.INTEGER.UNSIGNED)
  id: number;

  @AllowNull(false)
  @Column(DataType.DECIMAL(6, 2))
  price: number;
}

'''
'''--- example/package.json ---
{
  "name": "example",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
  },
  "author": "",
  "license": "MIT",
  "dependencies": {
    "reflect-metadata": "^0.1.13",
    "sequelize": "^6.6.2",
    "sequelize-typescript": "^2.1.0",
    "sqlite3": "^4.0.4"
  }
}
'''
'''--- index.ts ---
export * from "./lib/migrate";

'''
'''--- lib/compiler.ts ---
import { register } from "ts-node";
import { BaseOptions } from "./types";

export function useTypescriptResolver(options: BaseOptions) {
  return register({
    project: options.project,
  });
}

'''
'''--- lib/import.ts ---
import { Sequelize } from "sequelize-typescript";
import { useTypescriptResolver } from "./compiler";
import { BaseOptions } from "./types";
import { resolve } from "path";
import fs from "fs";

export async function importSequelizeModel(
  options: BaseOptions
): Promise<Sequelize> {
  const { modelsDirectory } = options;

  // Asserts that ts-node is initialized
  useTypescriptResolver(options);

  if (!fs.existsSync(modelsDirectory)) {
    console.log("Models dir doesn't exist");
    return;
  }

  let modelsImportPath = resolve(modelsDirectory);

  if (fs.lstatSync(modelsDirectory).isDirectory()) {
    if (!fs.existsSync(resolve(modelsDirectory, "index.ts"))) {
      console.log("Models dir is a file and doesn't have index.ts");
      return;
    }
    else modelsImportPath = resolve(modelsDirectory, "index.ts");
  }

  let modelsImport: any = await import(resolve(modelsImportPath));
  if ("default" in modelsImport) {
    modelsImport = modelsImport.default;
  }

  if (!("sequelize" in modelsImport)) {
    console.log("Could not find sequelize from import path.");
    return;
  }

  return modelsImport.sequelize;
}

'''
'''--- lib/migrate.ts ---
import { DataTypes } from "sequelize";
import Sequelize, { DataType } from "sequelize-typescript";
import { js_beautify } from "js-beautify";
import { diff } from "deep-diff";
import { clone, each, extend } from "lodash";

const hash = require("object-hash");
const fs = require("fs");
const path = require("path");
const log = console.log;

export const reverseSequelizeColType = function (col, prefix = "DataType.") {
  const attributeKey = col["type"].key;
  const attrObj = col.type;
  const options = col["type"]["options"] ? col["type"]["options"] : {};

  switch (attributeKey) {
    // CHAR(length, binary)
    case DataTypes.CHAR.key:
      if (options.binary) return prefix + "CHAR.BINARY";
      return prefix + "CHAR(" + options.length + ")";

    // STRING(length, binary).BINARY
    case DataTypes.STRING.key:
      return (
        prefix +
        "STRING" +
        (options.length ? "(" + options.length + ")" : "") +
        (options.binary ? ".BINARY" : "")
      );

    // TEXT(length)
    case DataTypes.TEXT.key:
      if (!options.length) return prefix + "TEXT";
      return prefix + "TEXT(" + options.length.toLowerCase() + ")";

    // NUMBER(length, decimals).UNSIGNED.ZEROFILL
    case DataTypes.NUMBER.key:
    case DataTypes.TINYINT.key:
    case DataTypes.SMALLINT.key:
    case DataTypes.MEDIUMINT.key:
    case DataTypes.BIGINT.key:
    case DataTypes.FLOAT.key:
    case DataTypes.REAL.key:
    case DataTypes.DOUBLE.key:
    case DataTypes.DECIMAL.key:
    case DataTypes.INTEGER.key: {
      let ret = attributeKey;
      if (options.length) {
        ret += "(" + options.length;
        if (options.decimals) ret += ", " + options.decimals;
        ret += ")";
      }

      if (options.precision) {
        ret += "(" + options.precision;
        if (options.scale) ret += ", " + options.scale;
        ret += ")";
      }

      ret = [ret];

      if (options.zerofill) ret.push("ZEROFILL");

      if (options.unsigned) ret.push("UNSIGNED");

      return prefix + ret.join(".");
    }

    case DataTypes.ENUM.key:
      return prefix + "ENUM('" + options.values.join("', '") + "')";

    case DataTypes.BLOB.key:
      if (!options.length) return prefix + "BLOB";
      return prefix + "BLOB(" + options.length.toLowerCase() + ")";

    case DataTypes.ENUM.key:
      return prefix + "ENUM('" + options.values.join("', '") + "')";

    case DataTypes.GEOMETRY.key:
      if (options.type) {
        if (options.srid)
          return (
            prefix + "GEOMETRY('" + options.type + "', " + options.srid + ")"
          );
        else return prefix + "GEOMETRY('" + options.type + "')";
      }
      return prefix + "GEOMETRY";

    case DataTypes.GEOGRAPHY.key:
      return prefix + "GEOGRAPHY";

    case DataTypes.ARRAY.key:
      const _type = attrObj.toString();
      let arrayType;
      if (_type === "INTEGER[]" || _type === "STRING[]") {
        arrayType = prefix + _type.replace("[]", "");
      } else {
        arrayType =
          col.seqType === "Sequelize.ARRAY(Sequelize.INTEGER)"
            ? prefix + "INTEGER"
            : prefix + "STRING";
      }
      return prefix + `ARRAY(${arrayType})`;

    case DataTypes.RANGE.key:
      console.warn(attributeKey + " type not supported, you should make it by");
      return prefix + attrObj.toSql();

    // BOOLEAN
    // TIME
    // DATE
    // DATEONLY
    // HSTORE
    // JSONB
    // UUID
    // UUIDV1
    // UUIDV4
    // VIRTUAL
    // INET
    // MACADDR
    default:
      return prefix + attributeKey;
  }
};

export const reverseSequelizeDefValueType = function (
  defaultValue,
  prefix = "Sequelize."
) {
  if (typeof defaultValue === "object") {
    if (defaultValue.constructor && defaultValue.constructor.name) {
      return { internal: true, value: prefix + defaultValue.constructor.name };
    }
  }

  if (typeof defaultValue === "function")
    return { notSupported: true, value: "" };

  return { value: defaultValue };
};

export const parseIndex = function (idx) {
  delete idx.parser;
  if (idx.type == "") delete idx.type;

  let options: any = {};

  if (idx.name) {
    options.name = options.indexName = idx.name; // The name of the index. Default is __
  }

  // @todo: UNIQUE|FULLTEXT|SPATIAL
  if (idx.unique) {
    options.type = options.indicesType = "UNIQUE";
  }

  if (idx.method) {
    options.indexType = idx.type; // Set a type for the index, e.g. BTREE. See the documentation of the used dialect
  }

  if (idx.parser && idx.parser != "") {
    options.parser = idx.parser; // For FULLTEXT columns set your parser
  }

  idx.options = options;

  idx.hash = hash(idx);

  //    log ('PI:', JSON.stringify(idx, null, 4));
  return idx;
};

export const reverseModels = function (sequelize, models) {
  let tables = {};

  delete models.default;

  for (let model in models) {
    let attributes = models[model].attributes || models[model].rawAttributes;

    for (let column in attributes) {
      delete attributes[column].Model;
      delete attributes[column].fieldName;
      // delete attributes[column].field;

      for (let property in attributes[column]) {
        if (property.startsWith("_")) {
          delete attributes[column][property];
          continue;
        }

        if (property === "defaultValue") {
          let _val = reverseSequelizeDefValueType(attributes[column][property]);
          if (_val.notSupported) {
            log(
              `[Not supported] Skip defaultValue column of attribute ${model}:${column}`
            );
            delete attributes[column][property];
            continue;
          }
          attributes[column][property] = _val;
        }

        // remove getters, setters...
        if (typeof attributes[column][property] == "function")
          delete attributes[column][property];
      }

      if (typeof attributes[column]["type"] === "undefined") {
        if (!attributes[column]["seqType"]) {
          log(
            `[Not supported] Skip column with undefined type ${model}:${column}`
          );
          delete attributes[column];
          continue;
        } else {
          if (
            ![
              "Sequelize.ARRAY(Sequelize.INTEGER)",
              "Sequelize.ARRAY(Sequelize.STRING)",
            ].includes(attributes[column]["seqType"])
          ) {
            delete attributes[column];
            continue;
          }
          attributes[column]["type"] = {
            key: DataType.ARRAY.key,
          };
        }
      }

      let seqType = reverseSequelizeColType(attributes[column]);

      // No virtual types in migration
      if (seqType === "Sequelize.VIRTUAL") {
        log(
          `[SKIP] Skip Sequelize.VIRTUAL column "${column}"", defined in model "${model}"`
        );
        delete attributes[column];
        continue;
      }

      if (!seqType) {
        if (
          typeof attributes[column]["type"]["options"] !== "undefined" &&
          typeof attributes[column]["type"]["options"].toString === "function"
        )
          seqType = attributes[column]["type"]["options"].toString(sequelize);

        if (typeof attributes[column]["type"].toString === "function")
          seqType = attributes[column]["type"].toString(sequelize);
      }

      attributes[column]["seqType"] = seqType;

      delete attributes[column].type;
      delete attributes[column].values; // ENUM
    }

    tables[models[model].tableName] = {
      tableName: models[model].tableName,
      schema: attributes,
    };

    if (models[model].options.indexes.length > 0) {
      let idx_out = {};
      for (let _i in models[model].options.indexes) {
        let index = parseIndex(models[model].options.indexes[_i]);
        idx_out[index.hash + ""] = index;
        delete index.hash;

        // make it immutable
        Object.freeze(index);
      }
      models[model].options.indexes = idx_out;
    }

    if (typeof models[model].options.charset !== "undefined") {
      tables[models[model].tableName].charset = models[model].options.charset;
    }

    tables[models[model].tableName].indexes = models[model].options.indexes;
  }

  return tables;
};

export const parseDifference = function (previousState, currentState) {
  let actions = [];
  let difference = diff(previousState, currentState);

  if (!difference) return actions;

  for (let df of difference) {
    switch (df.kind) {
      // add new
      case "N":
        {
          // new table created
          if (df.path.length === 1) {
            let depends = [];
            let tableName = df.rhs.tableName;
            each(df.rhs.schema, (v) => {
              if (v.references) {
                depends.push(v.references.model);
              }
            });

            let options: any = {};
            if (typeof df.rhs.charset !== "undefined") {
              options.charset = df.rhs.charset;
            }

            actions.push({
              actionType: "createTable",
              tableName: tableName,
              attributes: df.rhs.schema,
              options: options,
              depends: depends,
            });

            // create indexes
            if (df.rhs.indexes)
              for (let _i in df.rhs.indexes) {
                actions.push(
                  extend(
                    {
                      actionType: "addIndex",
                      tableName: tableName,
                      depends: [tableName],
                    },
                    clone(df.rhs.indexes[_i])
                  )
                );
              }
            break;
          }

          let tableName = df.path[0];
          let depends = [tableName];

          if (df.path[1] === "schema") {
            // if (df.path.length === 3) - new field
            if (df.path.length === 3) {
              // new field
              if (df.rhs && df.rhs.references)
                depends.push(df.rhs.references.model);

              actions.push({
                actionType: "addColumn",
                tableName: tableName,
                attributeName: df.path[2],
                options: df.rhs,
                depends: depends,
              });
              break;
            }

            // if (df.path.length > 3) - add new attribute to column (change col)
            if (df.path.length > 3) {
              if (df.path[1] === "schema") {
                // new field attributes
                let options = currentState[tableName].schema[df.path[2]];
                if (options.references) {
                  depends.push(options.references.nodel);
                }

                actions.push({
                  actionType: "changeColumn",
                  tableName: tableName,
                  attributeName: df.path[2],
                  options: options,
                  depends: depends,
                });
                break;
              }
            }
          }

          // new index
          if (df.path[1] === "indexes") {
            if (!df.rhs) {
              continue;
            }

            let tableName = df.path[0];
            let index = clone(df.rhs);
            index.actionType = "addIndex";
            index.tableName = tableName;
            index.depends = [tableName];
            actions.push(index);
            break;
          }
        }
        break;

      // drop
      case "D":
        {
          let tableName = df.path[0];
          let depends = [tableName];

          if (df.path.length === 1) {
            // drop table
            actions.push({
              actionType: "dropTable",
              tableName: tableName,
              depends: [],
            });
            break;
          }

          if (df.path[1] === "schema") {
            // if (df.path.length === 3) - drop field
            if (df.path.length === 3) {
              // drop column
              actions.push({
                actionType: "removeColumn",
                tableName: tableName,
                columnName: df.path[2],
                depends: [tableName],
                options: df.lhs,
              });
              break;
            }

            // if (df.path.length > 3) - drop attribute from column (change col)
            if (df.path.length > 3) {
              // new field attributes
              let options = currentState[tableName].schema[df.path[2]];
              if (options.references) {
                depends.push(options.references.nodel);
              }
              actions.push({
                actionType: "changeColumn",
                tableName: tableName,
                attributeName: df.path[2],
                options: options,
                depends: depends,
              });
              break;
            }
          }

          if (df.path[1] === "indexes") {
            //                    log(df)
            actions.push({
              actionType: "removeIndex",
              tableName: tableName,
              fields: df.lhs.fields,
              options: df.lhs.options,
              depends: [tableName],
            });
            break;
          }
        }
        break;

      // edit
      case "E":
        {
          let tableName = df.path[0];
          let depends = [tableName];

          if (df.path[1] === "schema") {
            // new field attributes
            let options = currentState[tableName].schema[df.path[2]];
            if (options.references) depends.push(options.references.nodel);

            actions.push({
              actionType: "changeColumn",
              tableName: tableName,
              attributeName: df.path[2],
              options: options,
              depends: depends,
            });
          }

          // updated index
          // only support updating and dropping indexes
          if (df.path[1] === "indexes") {
            let tableName = df.path[0];
            let keys = Object.keys(df.rhs);

            for (let k in keys) {
              let key = keys[k];
              actions.push({
                actionType: "addIndex",
                tableName: tableName,
                fields: df.rhs[key].fields,
                options: df.rhs[key].options,
                depends: [tableName],
              });
              break;
            }

            keys = Object.keys(df.lhs);
            for (let k in keys) {
              let key = keys[k];
              actions.push({
                actionType: "removeIndex",
                tableName: tableName,
                fields: df.lhs[key].fields,
                options: df.lhs[key].options,
                depends: [tableName],
              });
              break;
            }
          }
        }
        break;

      // array change indexes
      case "A":
        {
          log(
            "[Not supported] Array model changes! Problems are possible. Please, check result more carefully!"
          );
          log("[Not supported] Difference: ");
          log(JSON.stringify(df, null, 4));
        }
        break;

      default:
        // code
        break;
    }
  }
  return actions;
};

export const sortActions = function (actions) {
  const orderedActionTypes = [
    "removeIndex",
    "removeColumn",
    "dropTable",
    "createTable",
    "addColumn",
    "changeColumn",
    "addIndex",
  ];

  //test
  //actions = shuffleArray(actions);

  actions.sort((a, b) => {
    if (
      orderedActionTypes.indexOf(a.actionType) <
      orderedActionTypes.indexOf(b.actionType)
    )
      return -1;
    if (
      orderedActionTypes.indexOf(a.actionType) >
      orderedActionTypes.indexOf(b.actionType)
    )
      return 1;

    if (a.depends.length === 0 && b.depends.length > 0) return -1; // a < b
    if (b.depends.length === 0 && a.depends.length > 0) return 1; // b < a

    return 0;
  });

  for (let k = 0; k <= actions.length; k++)
    for (let i = 0; i < actions.length; i++) {
      if (!actions[i].depends) continue;
      if (actions[i].depends.length === 0) continue;

      let a = actions[i];

      for (let j = 0; j < actions.length; j++) {
        if (!actions[j].depends) continue;
        if (actions[j].depends.length === 0) continue;

        let b = actions[j];

        if (a.actionType != b.actionType) continue;

        if (b.depends.indexOf(a.tableName) !== -1 && i > j) {
          let c = actions[i];
          actions[i] = actions[j];
          actions[j] = c;
        }
      }
    }
};

export const getMigration = function (actions) {
  let propertyToStr = (obj) => {
    let vals = [];
    for (let k in obj) {
      if (k === "seqType") {
        vals.push('"type": ' + obj[k]);
        continue;
      }

      if (k === "defaultValue") {
        if (obj[k].internal) {
          vals.push('"defaultValue": ' + obj[k].value);
          continue;
        }
        if (obj[k].notSupported) continue;

        let x = {};
        x[k] = obj[k].value;
        vals.push(JSON.stringify(x).slice(1, -1));
        continue;
      }

      let x = {};
      x[k] = obj[k];
      vals.push(JSON.stringify(x).slice(1, -1));
    }

    return "{ " + vals.reverse().join(", ") + " }";
  };

  let getAttributes = (attrs) => {
    let ret = [];
    for (let attrName in attrs) {
      ret.push(`      "${attrName}": ${propertyToStr(attrs[attrName])}`);
    }
    return " { \n" + ret.join(", \n") + "\n     }";
  };

  let commandsUp = [];
  let consoleOut = [];

  for (let _i in actions) {
    let action = actions[_i];
    switch (action.actionType) {
      case "createTable":
        {
          let resUp = `{ fn: "createTable", params: [
    "${action.tableName}",
    ${getAttributes(action.attributes)},
    ${JSON.stringify(action.options)}
] }`;
          commandsUp.push(resUp);

          consoleOut.push(
            `createTable "${action.tableName}", deps: [${action.depends.join(
              ", "
            )}]`
          );
        }
        break;

      case "dropTable":
        {
          let res = `{ fn: "dropTable", params: ["${action.tableName}"] }`;
          commandsUp.push(res);

          consoleOut.push(`dropTable "${action.tableName}"`);
        }
        break;

      case "addColumn":
        {
          let resUp = `{ fn: "addColumn", params: [
    "${action.tableName}",
    "${
      action.options && action.options.field
        ? action.options.field
        : action.attributeName
    }",
    ${propertyToStr(action.options)}
] }`;

          commandsUp.push(resUp);

          consoleOut.push(
            `addColumn "${action.attributeName}" to table "${action.tableName}"`
          );
        }
        break;

      case "removeColumn":
        {
          let res = `{ fn: "removeColumn", params: ["${action.tableName}", "${
            action.options && action.options.field
              ? action.options.field
              : action.columnName
          }"] }`;
          commandsUp.push(res);

          consoleOut.push(
            `removeColumn "${
              action.options && action.options.field
                ? action.options.field
                : action.columnName
            }" from table "${action.tableName}"`
          );
        }
        break;

      case "changeColumn":
        {
          let res = `{ fn: "changeColumn", params: [
    "${action.tableName}",
    "${
      action.options && action.options.field
        ? action.options.field
        : action.attributeName
    }",
    ${propertyToStr(action.options)}
] }`;
          commandsUp.push(res);

          consoleOut.push(
            `changeColumn "${action.attributeName}" on table "${action.tableName}"`
          );
        }
        break;

      case "addIndex":
        {
          let res = `{ fn: "addIndex", params: [
    "${action.tableName}",
    ${JSON.stringify(action.fields)},
    ${JSON.stringify(action.options)}
] }`;
          commandsUp.push(res);

          let nameOrAttrs =
            action.options &&
            action.options.indexName &&
            action.options.indexName != ""
              ? `"${action.options.indexName}"`
              : JSON.stringify(action.fields);
          consoleOut.push(
            `addIndex ${nameOrAttrs} to table "${action.tableName}"`
          );
        }
        break;

      case "removeIndex": {
        //                log(action)
        let nameOrAttrs =
          action.options &&
          action.options.indexName &&
          action.options.indexName != ""
            ? `"${action.options.indexName}"`
            : JSON.stringify(action.fields);

        let res = `{ fn: "removeIndex", params: [
    "${action.tableName}",
    ${nameOrAttrs}
] }`;
        commandsUp.push(res);

        consoleOut.push(
          `removeIndex ${nameOrAttrs} from table "${action.tableName}"`
        );
      }

      default:
      // code
    }
  }

  return { commandsUp, consoleOut };
};

export function writeMigration(
  revision,
  migration,
  migrationsDir,
  name = "",
  comment = ""
) {
  let _commands =
    "const migrationCommands = [ \n" +
    migration.commandsUp.join(", \n") +
    " \n];\n";
  let _actions = " * " + migration.consoleOut.join("\n * ");

  _commands = js_beautify(_commands);
  let info = {
    revision,
    name,
    created: new Date(),
    comment,
  };

  let template = `'use strict';

import Sequelize, { DataType } from "sequelize-typescript";

/**
 * Actions summary:
 *
${_actions}
 *
 **/

export const info = ${JSON.stringify(info, null, 4)};

${_commands}

export const up = (queryInterface, Sequelize, pos = 0) =>  {
  let index = pos;
  return new Promise<void>(function(resolve, reject) {
    function next() {
      if (index < migrationCommands.length) {
        let command = migrationCommands[index];
        console.log("[#" + index + "] execute: " + command.fn);
        index++;

        queryInterface[command.fn]
          .apply(queryInterface, command.params)
          .then(next, reject);
      } else {
        resolve();
      }
    }
    next();
  });
};
`;

  name = name.replace(" ", "_");
  let filename = path.join(
    migrationsDir,
    revision + (name != "" ? `-${name}` : "") + ".ts"
  );

  fs.writeFileSync(filename, template);

  return { filename, info };
}

export const executeMigration = function (queryInterface, filename, pos, cb) {
  let mig = require(filename);

  if (!mig) return cb("Can't require file " + filename);

  if (pos > 0) {
    console.log("Set position to " + pos);
    mig.pos = pos;
  }

  mig.up(queryInterface, Sequelize).then(
    () => {
      cb();
    },
    (err) => {
      cb(err);
    }
  );
};

module.exports = {
  writeMigration,
  getMigration,
  sortActions,
  parseDifference,
  reverseModels,
  executeMigration,
};

'''
'''--- lib/options.ts ---
import { CommandLineOptions } from "command-line-args";
import { BaseOptions } from "./types";
import { join } from "path";
import { existsSync } from "fs";

export function build(options: CommandLineOptions): BaseOptions {
  const { migrationsDirectory, modelsDirectory } = readSequelizercOptions();

  return {
    project: options["project"],
    migrationsDirectory: options["migrations-path"] || migrationsDirectory,
    modelsDirectory: options["models-path"] || modelsDirectory,
  };
}

const readSequelizercOptions = () => {
  let sequelizercConfigs = [];
  let sequelizercPath = join(process.env.PWD, ".sequelizerc");

  if (existsSync(sequelizercPath)) {
    console.log("sqlrc exists");
    sequelizercConfigs = require(sequelizercPath);
  }

  if (!process.env.PWD) {
    process.env.PWD = process.cwd();
  }

  return {
    migrationsDirectory:
      sequelizercConfigs["migrations-path"] ||
      join(process.env.PWD, "migrations"),
    modelsDirectory:
      sequelizercConfigs["models-path"] || join(process.env.PWD, "models"),
  };
};

'''
'''--- lib/types.ts ---
export interface BaseOptions {
  /**
   * Relative path to tsconfig.json
   */
  project: string;

  modelsDirectory: string;
  migrationsDirectory: string;
}

export interface Options {}

export interface MigrationCommand {
  fn:
    | "createTable"
    | "dropTable"
    | "addColumn"
    | "removeColumn"
    | "changeColumn"
    | "addIndex"
    | "removeIndex";

  // TODO(velddev): Properly parse this type.
  params: unknown[];
}

'''
'''--- package.json ---
{
  "name": "@top-gg/sequelize-typescript-auto-migrations",
  "version": "0.0.2",
  "description": "Sequelize migrations generator && runner for sequelize-typescript",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "private": false,
  "bin": {
    "sequelize-ts": "./dist/bin/sequelize-ts.js"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "tsc"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/top-gg/sequelize-auto-migrations.git"
  },
  "keywords": [
    "sequelize",
    "typescript",
    "migrations",
    "migration",
    "database",
    "db",
    "sql"
  ],
  "author": "velddev",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/top-gg/sequelize-typescript-auto-migrations/issues"
  },
  "homepage": "https://github.com/top-gg/sequelize-typescript-auto-migrations#readme",
  "dependencies": {
    "async": "^2.5.1",
    "command-line-args": "^5.0.2",
    "deep-diff": "^0.3.8",
    "js-beautify": "^1.8.9",
    "lodash": "^4.17.11",
    "object-hash": "^1.3.1",
    "reflect-metadata": "^0.1.13",
    "sequelize": "^6.6.2",
    "sequelize-typescript": "^2.1.0",
    "ts-node": "^9.1.1",
    "typescript": "^4.2.4",
    "yargs": "^16.2.0"
  },
  "devDependencies": {
    "@types/command-line-args": "^5.0.0",
    "@types/js-beautify": "^1.13.1",
    "@types/lodash": "^4.14.168",
    "@types/yargs": "^16.0.1"
  },
  "publishConfig": {
    "access": "public"
  }
}
'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "outDir": "dist",
    "allowJs": true,
    "skipLibCheck": true,
    "strict": false,
    "forceConsistentCasingInFileNames": false,
    "downlevelIteration": true,
    "esModuleInterop": true,
    "module": "commonjs",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": false,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "removeComments": true,
    "declaration": true,
    "jsx": "preserve"
  },
  "include": [
    "**/*.d.ts",
    "**/*.ts",
    "**/*.js*", "bin/cmds/runmigration.xs",
  ],
  "exclude": [
    "dist",
    "example",
    "node_modules",
  ]
}

'''