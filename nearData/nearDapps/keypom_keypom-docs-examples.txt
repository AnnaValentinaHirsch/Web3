*GitHub Repository "keypom/keypom-docs-examples"*

'''--- README.md ---
# keypom-docs-examples
Scripts referenced in the documentation tutorials

https://docs.keypom.xyz/

'''
'''--- advanced-tutorials/dao-onboarding-skeleton/configurations.js ---
// DAO
const DEV_CONTRACT = "dev-1682299128062-34098852204866";

// DAO BOT
const DAO_BOT_CONTRACT = "dev-1682481900002-78543887295736";

module.exports = {
    DEV_CONTRACT,
    DAO_BOT_CONTRACT
};
'''
'''--- advanced-tutorials/dao-onboarding-skeleton/createDaoDrop.js ---
const path = require("path");
const homedir = require("os").homedir();
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Account } = require("@near-js/accounts");
const { parseNearAmount } = require("@near-js/utils");
const { Near } = require("@near-js/wallet-account");

const keypom = require("@keypom/core");
const { DAO_CONTRACT, DAO_BOT_CONTRACT, DAO_BOT_CONTRACT_MAINNET, DAO_CONTRACT_MAINNET } = require("./configurations");

const {
    initKeypom,
    getEnv,
    createDrop,
    formatLinkdropUrl,
} = keypom

async function createDaoDrop() {
    // Change this to your account ID
    const FUNDER_ACCOUNT_ID = "minqi.testnet";
    const NETWORK_ID = "testnet";

}

createDaoDrop()

module.exports = {
    createDaoDrop,
}

'''
'''--- advanced-tutorials/dao-onboarding-skeleton/package.json ---
{
  "name": "dao-onboarding",
  "version": "1.0.0",
  "description": "Keypom DAO onboarding",
  "main": "index.js",
  "author": "Min Qian Lu",
  "license": "MIT",
  "dependencies": {
    "keypom-js": "^1.4.3"
  },
  "scripts": {
    "daotest": "node sputnikPreTest && node daoScript"
  }
}

'''
'''--- advanced-tutorials/dao-onboarding-skeleton/view-roles.js ---
const path = require("path");
const homedir = require("os").homedir();
const { KeyPair, keyStores, connect, Account } = require("near-api-js");
var assert = require('assert');

const keypom = require("keypom-js");
const { DAO_CONTRACT, DAO_BOT_CONTRACT } = require("./configurations");
const {
	initKeypom,
	getEnv,
	createDrop,
    parseNearAmount,
    formatLinkdropUrl,
} = keypom

// Change this to your account ID
const FUNDER_ACCOUNT_ID = "minqi.testnet";
const NETWORK_ID = "testnet";

// Parsing user roles
const getUserRoles = (policyInfo, accountId) => {
}

async function viewRoles(){
    getUserRoles()
}

viewRoles()
'''
'''--- advanced-tutorials/dao-onboarding/configurations.js ---
// DAO
const DAO_CONTRACT = "moondao.sputnikv2.testnet";

// DAO BOT
const DAO_BOT_CONTRACT = "keypom-dao-bot.testnet";

// DAO
const DAO_CONTRACT_MAINNET = "keypom-test.sputnik-dao.near";

// DAO BOT
const DAO_BOT_CONTRACT_MAINNET = "dao-bot.keypom.near";

module.exports = {
    DAO_CONTRACT,
    DAO_BOT_CONTRACT,
    DAO_BOT_CONTRACT_MAINNET,
    DAO_CONTRACT_MAINNET
};
'''
'''--- advanced-tutorials/dao-onboarding/createDaoDrop-mainnet.js ---
const path = require("path");
const homedir = require("os").homedir();
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Account } = require("@near-js/accounts");
const { parseNearAmount } = require("@near-js/utils");
const { Near } = require("@near-js/wallet-account");

const keypom = require("@keypom/core");
const { DAO_CONTRACT, DAO_BOT_CONTRACT, DAO_BOT_CONTRACT_MAINNET, DAO_CONTRACT_MAINNET } = require("./configurations");

const {
	initKeypom,
	getEnv,
	createDrop,
    formatLinkdropUrl,
} = keypom

async function createDaoDrop() {
    // Change this to your account ID
    const FUNDER_ACCOUNT_ID = "mintlu.near";
    const NETWORK_ID = "mainnet";

    // Initiate connection to the NEAR blockchain.
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);  

    let nearConfig = {
        networkId: NETWORK_ID,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
        walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
        helperUrl: `https://helper.${NETWORK_ID}.near.org`,
        explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
    };  

    let near = new Near(nearConfig);
    const fundingAccount = new Account(near.connection, FUNDER_ACCOUNT_ID)
    
    // If a NEAR connection is not passed in and is not already running, initKeypom will create a new connection
    // Here we are connecting to the testnet network
    await initKeypom({
        near,
        network: NETWORK_ID,
    });

    const TERA_GAS = 1000000000000;
    let {keys, dropId} = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        config: {
            usesPerKey: 1
        },
        requiredGas: (200*TERA_GAS).toString(),  
        depositPerUseNEAR: "0.001",
        fcData: {
            methods: [
                [
                    {
                        // receiverId: DAO_BOT_CONTRACT_MAINNET,
                        receiverId: "test-dao-bot.near",
                        methodName: "new_auto_registration",
                        args: JSON.stringify({
                            dao_contract: DAO_CONTRACT_MAINNET,
                            proposal: {
                                description: "Auto-Registering New Member",
                                kind: {
                                    AddMemberToRole:{
                                        role: "new-onboardee-role"
                                    }
                                }
                            },
                            human_only: true
                        }),
                        accountIdField: "proposal.kind.AddMemberToRole.member_id",
                        funderIdField: "funder",
                        attachedDeposit: parseNearAmount("0.1"),
                    }
                ],
            ]   
        },
        useBalance: true
    })

    const {contractId: KEYPOM_CONTRACT} = getEnv()
    let links = formatLinkdropUrl({
        customURL: "https://wallet.near.org/linkdrop/CONTRACT_ID/SECRET_KEY",
        secretKeys: keys.secretKeys,
        contractId: KEYPOM_CONTRACT,
    })
    console.log(`
    
    Auto-Registration Links: 
    
    ${links}
    
    `)

    return keys
}

createDaoDrop()

module.exports = {
    createDaoDrop,
}

'''
'''--- advanced-tutorials/dao-onboarding/createDaoDrop.js ---
const path = require("path");
const homedir = require("os").homedir();
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Account } = require("@near-js/accounts");
const { parseNearAmount } = require("@near-js/utils");
const { Near } = require("@near-js/wallet-account");

const keypom = require("@keypom/core");
const { DAO_CONTRACT, DAO_BOT_CONTRACT, DAO_BOT_CONTRACT_MAINNET, DAO_CONTRACT_MAINNET } = require("./configurations");

const {
    initKeypom,
    getEnv,
    createDrop,
    formatLinkdropUrl,
} = keypom

async function createDaoDrop() {
    // Change this to your account ID
    const FUNDER_ACCOUNT_ID = "minqi.testnet";
    const NETWORK_ID = "testnet";

    // Initiate connection to the NEAR blockchain.
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);  

    let nearConfig = {
        networkId: NETWORK_ID,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
        walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
        helperUrl: `https://helper.${NETWORK_ID}.near.org`,
        explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
    };  

    let near = new Near(nearConfig);
    const fundingAccount = new Account(near.connection, FUNDER_ACCOUNT_ID)
    
    // If a NEAR connection is not passed in and is not already running, initKeypom will create a new connection
    // Here we are connecting to the testnet network
    await initKeypom({
        near,
        network: NETWORK_ID,
    });

    const TERA_GAS = 1000000000000;
    let {keys, dropId} = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        config: {
            usesPerKey: 1
        },
        depositPerUseNEAR: "0.1",
        requiredGas: (120*TERA_GAS).toString(),
        fcData: {
            methods: [
                [
                    {
                        receiverId: DAO_BOT_CONTRACT,
                        methodName: "new_auto_registration",
                        args: JSON.stringify({
                            dao_contract: DAO_CONTRACT,
                            proposal: {
                                description: "Auto-Registering New Member",
                                kind: {
                                    AddMemberToRole:{
                                        role: "new-onboardee-role"
                                    }
                                }
                            }
                        }),
                        accountIdField: "proposal.kind.AddMemberToRole.member_id",
                        funderIdField: "funder",
                        // Attached deposit of 0.1 $NEAR for when the receiver makes this function call
                        attachedDeposit: parseNearAmount("0.1"),
                    }
                ],
            ]   
        }   
    })

    const {contractId: KEYPOM_CONTRACT} = getEnv()
    let links = formatLinkdropUrl({
        customURL: "https://testnet.mynearwallet.com/linkdrop/CONTRACT_ID/SECRET_KEY",
        secretKeys: keys.secretKeys,
        contractId: KEYPOM_CONTRACT,
    })
    console.log(`
    
    Auto-Registration Links: 
    
    ${links}
    
    `)

    return keys
}

createDaoDrop()

module.exports = {
    createDaoDrop,
}

'''
'''--- advanced-tutorials/dao-onboarding/package.json ---
{
  "name": "dao-onboarding",
  "version": "1.0.0",
  "description": "Keypom DAO onboarding",
  "main": "index.js",
  "author": "Min Qian Lu",
  "license": "MIT",
  "dependencies": {
    "keypom-js": "^1.4.3"
  },
  "scripts": {
    "daotest": "node sputnikPreTest && node daoScript"
  }
}

'''
'''--- advanced-tutorials/dao-onboarding/pre-security/createDaoDrop.js ---
const path = require("path");
const homedir = require("os").homedir();
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Account } = require("@near-js/accounts");
const { parseNearAmount } = require("@near-js/utils");
const { Near } = require("@near-js/wallet-account");

const keypom = require("@keypom/core");
const { DAO_CONTRACT, DAO_BOT_CONTRACT, DAO_BOT_CONTRACT_MAINNET, DAO_CONTRACT_MAINNET } = require("./configurations");

const {
    initKeypom,
    getEnv,
    createDrop,
    formatLinkdropUrl,
} = keypom

async function createDaoDrop() {
    // Change this to your account ID
    const FUNDER_ACCOUNT_ID = "minqi.testnet";
    const NETWORK_ID = "testnet";

    // Initiate connection to the NEAR blockchain.
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);  

    let nearConfig = {
        networkId: NETWORK_ID,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
        walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
        helperUrl: `https://helper.${NETWORK_ID}.near.org`,
        explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
    };  

    let near = new Near(nearConfig);
    const fundingAccount = new Account(near.connection, FUNDER_ACCOUNT_ID)
    
    // If a NEAR connection is not passed in and is not already running, initKeypom will create a new connection
    // Here we are connecting to the testnet network
    await initKeypom({
        near,
        network: NETWORK_ID,
    });

    const TERA_GAS = 1000000000000;
    let {keys, dropId} = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        config: {
            usesPerKey: 1
        },
        depositPerUseNEAR: "0.1",
        requiredGas: (120*TERA_GAS).toString(),
        fcData: {
            methods: [
                [
                    {
                        receiverId: DAO_BOT_CONTRACT,
                        methodName: "new_auto_registration",
                        args: JSON.stringify({
                            dao_contract: DAO_CONTRACT,
                            proposal: {
                                description: "Auto-Registering New Member",
                                kind: {
                                    AddMemberToRole:{
                                        role: "new-onboardee-role"
                                    }
                                }
                            }
                        }),
                        accountIdField: "proposal.kind.AddMemberToRole.member_id",
                        // Attached deposit of 0.1 $NEAR for when the receiver makes this function call
                        attachedDeposit: parseNearAmount("0.1")
                    }
                ],
            ]   
        }   
    })

    const {contractId: KEYPOM_CONTRACT} = getEnv()
    let links = formatLinkdropUrl({
        customURL: "https://testnet.mynearwallet.com/linkdrop/CONTRACT_ID/SECRET_KEY",
        secretKeys: keys.secretKeys,
        contractId: KEYPOM_CONTRACT,
    })
    console.log(`
    
    Auto-Registration Links: 
    
    ${links}
    
    `)

    return keys
}

createDaoDrop()

module.exports = {
    createDaoDrop,
}

'''
'''--- advanced-tutorials/dao-onboarding/test.js ---
const path = require("path");
const homedir = require("os").homedir();
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Account } = require("@near-js/accounts");
const { parseNearAmount } = require("@near-js/utils");
const { Near } = require("@near-js/wallet-account");

const keypom = require("@keypom/core");
const { DAO_CONTRACT, DAO_BOT_CONTRACT, DAO_BOT_CONTRACT_MAINNET, DAO_CONTRACT_MAINNET } = require("./configurations");

const {
	initKeypom,
	getEnv,
	createDrop,
    formatLinkdropUrl,
} = keypom

async function createDaoDrop() {
    // Change this to your account ID
    const FUNDER_ACCOUNT_ID = "mintlu.near";
    const NETWORK_ID = "mainnet";

    // Initiate connection to the NEAR blockchain.
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);  

    let nearConfig = {
        networkId: NETWORK_ID,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
        walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
        helperUrl: `https://helper.${NETWORK_ID}.near.org`,
        explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
    };  

    let near = new Near(nearConfig);
    const fundingAccount = new Account(near.connection, FUNDER_ACCOUNT_ID)
    
    // If a NEAR connection is not passed in and is not already running, initKeypom will create a new connection
    // Here we are connecting to the testnet network
    await initKeypom({
        near,
        network: NETWORK_ID,
    });

    const numKeys = await keypom.getKeyTotalSupply();

   // Query for the first 50 keys on the contract
    const keyInfo = await keypom.getKeys({
      start: 0,
      limit: 300
    });

    console.log('keyInfo: ', keyInfo)
}

createDaoDrop()

module.exports = {
    createDaoDrop,
}

'''
'''--- advanced-tutorials/dao-onboarding/test/dao.test.js ---
const test = require('ava');
const BN = require('bn.js');
const nearAPI = require("near-api-js");
const { getUserBalance, getCurMethodData, canUserAddKeys, addToSaleAllowlist, removeFromSaleAllowlist, addToSaleBlocklist, removeFromSaleBlocklist, updateSale, getDropSupplyForOwner } = require('../../../../core/lib');
const {
	Near,
	KeyPair,
	utils: { format: {
		parseNearAmount
	} },
	keyStores: { InMemoryKeyStore },
    Account
} = nearAPI;

const keypom = require("../../../../core/lib");
const {
	execute,
	initKeypom,
	getEnv,
	createDrop,
	getDrops,
	claim,
	deleteKeys,
	deleteDrops,
	addKeys,
	generateKeys,
	withdrawBalance,
	addToBalance
} = keypom

/// funding account
const accountId = process.env.TEST_ACCOUNT_ID
const secretKey = process.env.TEST_ACCOUNT_PRVKEY

console.log('accountId', accountId)

/// mocking browser for tests

const _ls = {}
window = {
	localStorage: {
		getItem: (k) => _ls[k],
		setItem: (k, v) => _ls[k] = v,
		removeItem: (k) => delete _ls[k],
	},
}
localStorage = window.localStorage

/// for testing of init NEAR here and pass in to initKeypom
const networks = {
	mainnet: {
		networkId: 'mainnet',
		viewAccountId: 'near',
		nodeUrl: 'https://rpc.mainnet.near.org',
		walletUrl: 'https://wallet.near.org',
		helperUrl: 'https://helper.mainnet.near.org'
	},
	testnet: {
		networkId: 'testnet',
		viewAccountId: 'testnet',
		nodeUrl: 'https://rpc.testnet.near.org',
		walletUrl: 'https://wallet.testnet.near.org',
		helperUrl: 'https://helper.testnet.near.org'
	}
}
const network = 'testnet'
const networkConfig = typeof network === 'string' ? networks[network] : network
const keyStore = new InMemoryKeyStore()
const near = new Near({
	...networkConfig,
	deps: { keyStore },
});

test('one', async (t) => {
    const fundingAccount = new Account(near.connection, "minqi.testnet")

    let viewReturn = await fundingAccount.viewFunction(
        "moondao.sputnikv2.testnet",
		'get_policy'
    )
	
	console.log(viewReturn)

	t.true(true)
});
'''
'''--- advanced-tutorials/dao-onboarding/view-roles.js ---
const path = require("path");
const homedir = require("os").homedir();
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Account } = require("@near-js/accounts");
const { connect, Near } = require("@near-js/wallet-account");
var assert = require('assert');

const keypom = require("@keypom/core");
const { DAO_CONTRACT, DAO_BOT_CONTRACT } = require("./configurations");
const {
	initKeypom,
	getEnv,
	createDrop,
    parseNearAmount,
    formatLinkdropUrl,
} = keypom

// Change this to your account ID
const FUNDER_ACCOUNT_ID = "minqi.testnet";
const NETWORK_ID = "testnet";

// Parsing user roles
const getUserRoles = (policyInfo, accountId) => {
    let roles = [];

    // Loop through each element in res.roles
    for (const role of policyInfo.roles) {
        const roleKind = role.kind;
        //console.log('roleKind: ', roleKind)
        const roleName = role.name;
        //console.log('roleName: ', roleName)

        if (roleKind === 'Everyone') {
            roles.push('All')
            continue
        }
        
        let groupMembers = roleKind['Group'];

        if (groupMembers.includes(accountId)) {
            roles.push(roleName)
        }
    }

    return roles
}

async function viewRoles(account){
    // Initiate connection to the NEAR blockchain.
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);  

    let nearConfig = {
        networkId: NETWORK_ID,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
        walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
        helperUrl: `https://helper.${NETWORK_ID}.near.org`,
        explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
    };  

    let near = new Near(nearConfig);
    const fundingAccount = new Account(near.connection, FUNDER_ACCOUNT_ID)
    
    // get policy and parse
    let viewReturn = await fundingAccount.viewFunction(
        DAO_CONTRACT,
		'get_policy'
    )

    let roles = getUserRoles(viewReturn, account)
    console.log(roles);
}

viewRoles()

module.exports = {
    viewRoles,
}
'''
'''--- advanced-tutorials/ticket-app-mainnet/App.css ---
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

'''
'''--- advanced-tutorials/ticket-app-mainnet/components/qrcode.js ---
import { useState, useEffect } from "react";
import { QRCodeCanvas } from "qrcode.react";

const QrCode = ({ link }) => {
  const qrcode = (
    <QRCodeCanvas
      id="qrCode"
      value={link}
      size={300}
      fgColor={"#000000"}
      bgColor={"#F8F8FF"}
      level={"H"}
    />
  );
  return (
    <div className="qrcode__container">
      <div>{qrcode}</div>
    </div>
  );
};

export default QrCode;
'''
'''--- advanced-tutorials/ticket-app-mainnet/components/scanner.js ---
import React from "react";
import { useZxing } from "react-zxing";
import { useState, useEffect } from "react";
import logo from "../static/img/green-check.png"
import xLogo from "../static/img/red-x.png"
import "../styles.css";
import { allowEntry } from "../utils/allowEntry";

export const Scanner = () => {
  // Stage enum
  const Stage = {
    preClaim: "Pre-claim",
    claiming: "Claiming",
    successClaim: "Success",
    failClaim: "Fail"
  }

  // Data enum
  const Data = {
    empty: "Empty",
    captured: "Captured",
  }

  // State Variables
  const [result, setResult] = useState("");
  const [splitRes, setSplitRes] = useState([]);
  const [resPrivKey, setResPrivkey] = useState("")
  const [password, setPassword] = useState("NULL")
  const [masterStatus, setMasterStatus] = useState({ stage: Stage.preClaim, data: Data.empty })

  // Scanner and getting results of scan
  const { ref } = useZxing({
    onResult(result) {
      setResult(result.getText());
      setSplitRes([...result.getText().split("/")]);
      setResPrivkey(result.getText().split("/")[1])

      //indicate new data
      let tempMaster = {
        stage: Stage.claiming,
        data: Data.captured
      }
      setMasterStatus(tempMaster)
    },
  });

  // Functions that only run when scanner is mounted 
  // Get password
  useEffect(() => {
    let PASSWORD = "NULL"
    PASSWORD = prompt("Enter base password for drop")
    setPassword(PASSWORD)
  }, [])

  // Claiming the drop using password
  useEffect(() => {
    function timeout(delay) {
      return new Promise(res => setTimeout(res, delay));
    }

    async function scannerClaim() {
      let isAllowedIn = await allowEntry({
        privKey: resPrivKey,
        basePassword: password
      })

      // Successful Claim
      if (isAllowedIn) {
        setMasterStatus({
          stage: Stage.successClaim,
          data: Data.captured
        })
      } else { // Failed Claim
        setMasterStatus({
          stage: Stage.failClaim,
          data: Data.captured
        })
      }

      // Wait 3s, then flip go back to pre-claim
      await timeout(3000)
      setMasterStatus({
        stage: Stage.preClaim,
        data: Data.empty
      })
    }
    // Only claim if there is data present
    if (masterStatus.data === Data.captured) {
      scannerClaim()
    }

  }, [masterStatus.data])

  switch (masterStatus.stage) {
    case Stage.preClaim:
      return (
        <>
          <div className="content">
            <div style={{ border: "0.5rem solid white" }}><video ref={ref} /></div>
            <h2>Scan a linkdrop QR code to claim</h2>
            <h4>To re-enter password, refresh the page</h4>
          </div>
        </>
      );
    case Stage.claiming:
      return (
        <>
          <div className="content">
            <div style={{ border: "0.5rem solid yellow" }}><video ref={ref} /></div>
            <h2>Claiming</h2>
            <h4>Note this should take a few seconds</h4>
          </div>
        </>
      );
    case Stage.successClaim:
      return (
        <>
          <div className="content">
            <div style={{ border: "0.5rem solid green" }}><video ref={ref} /></div>
            <h2>Claimed!</h2>
            <img src={logo} alt="green check" width="50" height="60" className="img_center"></img>
          </div>
        </>
      );
    case Stage.failClaim:
      return (
        <>
          <div className="content">
            <div style={{ border: "0.5rem solid red" }}><video ref={ref} /></div>
            <h2>Could Not Be Claimed!</h2>
            <h3>Ensure Password is Correct</h3>
            <h4>To re-enter password, refresh the page</h4>
            <img src={xLogo} alt="red x" width="50" height="60" className="img_center"></img>
          </div>
        </>
      );
    default:
      let errorMsg = `Error: masterState.stage is ${masterStatus.stage}`
      return (
        <>
          <div className="content">
            <h2>{errorMsg}</h2>
            <img src={xLogo} alt="red x" width="50" height="60" className="img_center"></img>
          </div>
        </>
      );
  }
};

'''
'''--- advanced-tutorials/ticket-app-mainnet/css/global.css ---
* {
  box-sizing: border-box;
}

html {
  --bg: #efefef;
  --fg: #1e1e1e;
  --gray: #555;
  --light-gray: #ccc;
  --shadow: #e6e6e6;
  --success: rgb(90, 206, 132);
  --primary: #FF585D;
  --secondary: #0072CE;

  background-color: var(--bg);
  color: var(--fg);
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  font-size: calc(0.9em + 0.5vw);
  line-height: 1.3;
}

body {
  margin: 0;
  padding: 1em;
}

main {
  margin: 0 auto;
  max-width: 26em;
  text-align: justify;
}

h1 {
  background-image: url(../img/logo-black.svg);
  background-position: center 1em;
  background-repeat: no-repeat;
  background-size: auto 1.5em;
  margin-top: 0;
  padding: 3.5em 0 0.5em;
  text-align: center;
}

a,
.link {
  color: var(--primary);
  text-decoration: none;
}
a:hover,
a:focus,
.link:hover,
.link:focus {
  text-decoration: underline;
}
a:active,
.link:active {
  color: var(--secondary);
}

button, input {
  font: inherit;
  outline: none;
}

button {
  background-color: var(--secondary);
  border-radius: 5px;
  border: none;
  color: #efefef;
  cursor: pointer;
  padding: 0.3em 0.75em;
  transition: transform 30ms;
}
button:hover, button:focus {
  box-shadow: 0 0 10em rgba(255, 255, 255, 0.2) inset;
}
button:active {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.1) inset;
}
button.link {
  background: none;
  border: none;
  box-shadow: none;
  display: inline;
}
[disabled] button, button[disabled] {
  box-shadow: none;
  background-color: var(--light-gray);
  color: gray;
  cursor: not-allowed;
  transform: none;
}
[disabled] button {
  text-indent: -900em;
  width: 2em;
  position: relative;
}
[disabled] button:after {
  content: " ";
  display: block;
  width: 0.8em;
  height: 0.8em;
  border-radius: 50%;
  border: 2px solid #fff;
  border-color: var(--fg) transparent var(--fg) transparent;
  animation: loader 1.2s linear infinite;
  position: absolute;
  top: 0.45em;
  right: 0.5em;
}
@keyframes loader {
  0% { transform: rotate(0deg) }
  100% { transform: rotate(360deg) }
}

fieldset {
  border: none;
  padding: 2em 0;
}

input {
  background-color: var(--shadow);
  border: none;
  border-radius: 5px 0 0 5px;
  caret-color: var(--primary);
  color: inherit;
  padding: 0.25em 1em;
}
input::selection {
  background-color: var(--secondary);
  color: #efefef;
}
input:focus {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.02) inset;
}

code {
  color: var(--gray);
}

li {
  padding-bottom: 1em;
}

aside {
  animation: notify ease-in-out 10s;
  background-color: var(--shadow);
  border-radius: 5px;
  bottom: 0;
  font-size: 0.8em;
  margin: 1em;
  padding: 1em;
  position: fixed;
  transform: translateY(10em);
  right: 0;
}
aside footer {
  display: flex;
  font-size: 0.9em;
  justify-content: space-between;
  margin-top: 0.5em;
}
aside footer *:first-child {
  color: var(--success);
}
aside footer *:last-child {
  color: var(--gray);
}
@keyframes notify {
  0% { transform: translateY(10em) }
  5% { transform: translateY(0) }
  95% { transform: translateY(0) }
  100% { transform: translateY(10em) }
}

@media (prefers-color-scheme: dark) {
  html {
    --bg: #1e1e1e;
    --fg: #efefef;
    --gray: #aaa;
    --shadow: #2a2a2a;
    --light-gray: #444;
  }
  h1 {
    background-image: url(../img/logo-white.svg);
  }
  input:focus {
    box-shadow: 0 0 10em rgba(255, 255, 255, 0.02) inset;
  }
}

'''
'''--- advanced-tutorials/ticket-app-mainnet/index.css ---
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

'''
'''--- advanced-tutorials/ticket-app-mainnet/index.html ---
<body>
    <div id="root"></div>
    <script type="module" src="./index.js"></script>
</body>
'''
'''--- advanced-tutorials/ticket-app-mainnet/index.js ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './state/App';
import { BrowserRouter } from "react-router-dom";
import { Buffer } from "buffer"; global.Buffer = Buffer;

// CREATED WITH V1-4 30 uses with pw and every 2nd minting nft
//ed25519:4Yc94z2jETj2c4iMRuAexRZsYadYtXBoHsmUuN9XUtwj
// https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/t5PWmHyFh5bKFpycSzEApJ4GMjofGZM3pvYpzkNkm6Wa1cDMaotfbYQ67Jwjtrqp9hu8aa1j32Zf9BJEzK1CMLM

// CREATED WITH V1-4, 1000 uses simple drop no pw
// Public Keys and Linkdrops:  {
// 'ed25519:GUeRZniVhEA4DRfikBoiZFZyEdzja3jo3jFLvyLeRd32'
//'https://wallet.testnet.near.org/linkdrop/v1-4.keypom.testnet/4aJGvd5za9nTWJcZBVAgEyaaU6kymPSyoXhtJLfNNx5XA1aWSXxDAqBnrPDBcm7PT5hCwk8L3nDExBYWKoB7HEix'

               
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  // <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>,
  // </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals

// 10 keys, 2 each with null 1st and nft mint second. tabbed entry indicates key in use or depleted
// --- 'ed25519:6Ug2EqRAFSPk5o18aMc7F27EUJjtYwqgKcQvWobUtHZC': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/qKfzzz2y15p91HzSh5xxZA6GGx2V3DmNEAzgtbo5HZVn7PsqaRj6g3P6i5KQ28bKy2R2E61WA5f6jXzNJFmKziN',
// --- 'ed25519:6V4PTNFKgqQet3b5ckB1wwEtT389CDD5rik4SVMTu6kP': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/rtQ9LyqNcbGGJknZeZDk7w37dApUk1GnHCVRb7d5AaqxuytMUf6bh6HQsE3C2uWCakFaa2Z4QJipkFs6WwZafB5',
// 'ed25519:sBb3B1FsjxFHFJCWfMKchyaZWsSsK1U52iwvF9EXmCk': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/3yCwKjw6jSMk4Dbn939mpLVrGBDH4mFd7yRcS8M5Us1LgEhwePMXQ7XczASt7L6qYDHBnvmP1wWnGcF6sgZzo28Y',
// 'ed25519:FUteBnVMTquBS2Fq8NL4krcCX4Bbj7opiLGSnnHHbYvB': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/rwT4ZetJdHdBhGnV7iMD8zqJ4o9bjjBwNJYFcV32CgaQBXDNbHMcp3Df4rP3iCER28ZwrFhKNDaTGhJYPCoFNaT',
// 'ed25519:DW6Ux6XJhYLajej5VB8svyZ5MGeCMozeazxRSuA4CHtm': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/c5B7yjwTHwkquKjYT5z2hGvXsHS3kdKvy2v5NChdJVaQGeJfTsMhs3VM7tfq28f7FqLBNZNJSUQB2nUuesRMmCu',
// 'ed25519:2nbNNfo1tm5pcMniq8r6HSkq2gLhK9M1iCwGZ59JPhQF': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/5QN4aFbfMwAtm8ubasKX6VbqH7i4K33HznfLTpRpQYKv9oG2dBNbRg1pYooYbC7kSbJ3qgA6pSySwEha71XvN5oH',
// 'ed25519:FY7Ws3yW7TmbEhJGkpcM8tx4Lowt5Z6wqC9z8fJYXUGS': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/2Uj5a2e9AjWG6p8SqMNCEJGKAW5QiVjtgmqGShDWYE3GY5oYWz9mzC19vPyLUmAXNuhxCN9r6TF3D6vhdYTahVUn',
// 'ed25519:Gd7v5NaL2fCwNsMdDiRiwtXBBhe9LHo1CSoRCDs1unev': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/3J744n3zT29Dc4GzrnGbdNiwMM5cZv9eJdCd6WxAbJQy48RSfMWvnzbwcn6tgBYYPYtqcEeGhxU4pVdjmCx3yBZc',
// 'ed25519:DULssBcpvFpnMQ4sPnGrpqSrqyuTnHErFTzNfJERvf7e': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/25J9zdomMM9uDttmJRefwJwSpKsv7VRccvbqym8QEUu3PnjiRhye5h8U9hUdnq7bp72x56eABLNXYaThqVNVeWnL',
// 'ed25519:3CSopDVtq4uGno5tAes3Ld1tBE8jM1qJmMTsYt86PMxy': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/3JPaXXbdiDr3JVXx6qR1bce2byrTbgBeVKzYCWZ7jSwuKgangetNiYG5NY4NtUzxbaV1LDLtqqDoMuvE19zNa9jb'

// OLD
// https://wallet.testnet.near.org/linkdrop/v1-3.keypom.testnet/2TJ9RbP3UtNyJGTD9EKdabavTMSJC97hcnGQjXwbC7uRPn7TZaUspoXEKzFEThgyJqatyCVung3yySQGGEBumXd2
// curPks:  [ 'ed25519:4X3TdmDCEuVg6ifBoU3v3r75XqUk6w37HiapucsQ497W' ]

'''
'''--- advanced-tutorials/ticket-app-mainnet/near-apac-ticket-checker.js ---
const path = require("path");
const homedir = require("os").homedir();
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Account } = require("@near-js/accounts");
const { parseNearAmount } = require("@near-js/utils");
const { Near } = require("@near-js/wallet-account");

const keypom = require("@keypom/core");

const {
	initKeypom,
    getDrops,
    getKeysForDrop,
	getEnv,
	createDrop,
    formatLinkdropUrl,
} = keypom

async function createDaoDrop() {
    // Change this to your account ID
    const FUNDER_ACCOUNT_ID = "nearapac.near";
    const NETWORK_ID = "mainnet";

    // Initiate connection to the NEAR blockchain.
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);  

    let nearConfig = {
        networkId: NETWORK_ID,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
        walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
        helperUrl: `https://helper.${NETWORK_ID}.near.org`,
        explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
    };  

    let near = new Near(nearConfig);
    const fundingAccount = new Account(near.connection, FUNDER_ACCOUNT_ID)
    
    // If a NEAR connection is not passed in and is not already running, initKeypom will create a new connection
    // Here we are connecting to the testnet network
    await initKeypom({
        near,
        network: NETWORK_ID,
    });

    const drops = await getDrops({
        accountId: FUNDER_ACCOUNT_ID,
        start: 0,
        limit: 300,
        withKeys: false
    })    

    console.log(drops.length)
    let ticketDrops = []
    for(let i = 0; i < drops.length; i++){
        if(drops[i].fc.methods[0] == null && drops[i].fc.methods[1][0].receiver_id == "nft-v2.keypom.mainnet"){
            ticketDrops.push(drops[i].drop_id)
        }
    }

    let ticketsScanned = 0
    let unusedTickets = 0
    let fullyUsedTickets = 0
    for(let i = 0; i < ticketDrops.length; i++){
        console.log(`Analyzing drop number ${i}: ${ticketDrops[i]}`)
        const keys = await getKeysForDrop({
            dropId: ticketDrops[i]
        })
        console.log(`Drop ${ticketDrops[i]} returned ${keys.length} keys`)
        let localScanned = 0
        let localUnused = 0
        let localFullyUsed = 0
        for(let j = 0; j < keys.length; j++){
            if(keys[j].remaining_uses == 1){
                ticketsScanned++
                localScanned++
            }else if(keys[j].remaining_uses == 2){
                unusedTickets++
                localUnused++
            }
        }
        // ASSUME EACH DROP HAS 50 KEYS, ANY LESS WILL BE CONSIDERED FULLY SCANNED
        if(keys.length < 50){
            localFullyUsed += 50-keys.length
            fullyUsedTickets += 50-keys.length
        }

        console.log(`FOR DROP ID: ${ticketDrops[i]}, ${localScanned} tickets were scanned, ${localFullyUsed} tickets were fully used and  ${localUnused} tickets were unused`)
        console.log(`TOTAL IS NOW: ${ticketsScanned} scanned, ${fullyUsedTickets} fully used, and ${unusedTickets} unused`)
    }

}

createDaoDrop()

module.exports = {
    createDaoDrop,
}

'''
'''--- advanced-tutorials/ticket-app-mainnet/package.json ---
{
  "name": "ticket-app",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "parcel index.html --open",
    "build": "parcel build index.html --public-url ./",
    "create-ticket-drop": "node utils/createTickDrop.js",
    "test-ticket-drop": "node utils/testTickDrop.js"
  },
  "dependencies": {
    "@keypom/core": "^1.0.0",
    "@keypom/selector": "^1.0.0",
    "parcel": "^2.6.0",
    "qrcode.react": "^3.1.0",
    "react-router-dom": "^6.8.2",
    "react-zxing": "^1.1.3"
  },
  "devDependencies": {
    "@babel/core": "~7.18.2",
    "@babel/preset-env": "~7.18.2",
    "@babel/preset-react": "~7.17.12",
    "assert": "^2.0.0",
    "buffer": "^5.5.0",
    "crypto-browserify": "^3.12.0",
    "env-cmd": "~10.1.0",
    "events": "^3.1.0",
    "https-browserify": "^1.0.0",
    "nodemon": "~2.0.16",
    "os-browserify": "^0.3.0",
    "process": "^0.11.10",
    "punycode": "^1.4.1",
    "querystring-es3": "^0.2.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "stream-browserify": "^3.0.0",
    "stream-http": "^3.2.0",
    "ts-node": "^10.8.0",
    "typescript": "^4.7.2",
    "url": "^0.11.0"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- advanced-tutorials/ticket-app-mainnet/state/App.js ---
import QrCode from "../components/qrcode";
import KeyInfo from "./keyInfo";
// import "./styles.css";
import React from "react";
import { useState, useEffect } from "react";
import { BrowserRouter, Route, Routes } from 'react-router-dom';
import { Scanner } from "../components/scanner";
import "../styles.css";
import { initKeypom, formatLinkdropUrl } from "@keypom/core";
import { Near } from "@near-js/wallet-account";
import { BrowserLocalStorageKeyStore } from "@near-js/keystores-browser";

const NETWORK_ID = "mainnet";
async function connectNear(privateKey, contractId){
  const myKeyStore = new BrowserLocalStorageKeyStore();
  const connectionConfig = {
     networkId: NETWORK_ID,
     keyStore: myKeyStore,
     nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
     walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
     helperUrl: `https://helper.${NETWORK_ID}.near.org`,
     explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
  };

  const nearConnection = new Near(connectionConfig);
  await initKeypom({
      near: nearConnection,
      network: NETWORK_ID,
      keypomContractId: contractId
  });
}

let contractId;
let privKey;
let qrText;
function setup() {
  // Setting contract id, priv key and link state variables.
  const urlSplit = window.location.href.split("/");

  if (urlSplit.length > 3) {
    contractId = urlSplit[3]
    privKey = urlSplit[4]
    qrText =  `${contractId}/${privKey}`
  }

  if (contractId) {
    connectNear(contractId)
  }
}

setup()

function App() {
  //state variables
  const [curUse, setCurUse] = useState(0);
  const [pubKey, setPubKey] = useState("");
  
  const homepath = `/${contractId}/${privKey}`
  const scannerpath = `/${contractId}/scanner`

  // rendering stuff
  if(curUse == 1){
    // QR code
    console.log("scenario 1, QR code")
    return (
      <div className="content">
          <Routes>
            <Route path={scannerpath} element={ <Scanner/> } />
            <Route path={homepath} element={
            <>
              <h1>🎟️This is your ticket🔑</h1>
              <h4>Screenshot and show me at the door</h4>
              <br></br>
              <QrCode link={qrText} />
              <br></br>
              <KeyInfo contractId={contractId} privKey={privKey} curUse={curUse} setCurUse={setCurUse} pubKey={pubKey} setPubKey={setPubKey} />
            </>}/>
          </Routes>
      </div>
    );
  }
  else if(curUse==2){
    // Direct user to claim POAP
    let link = formatLinkdropUrl({
      customURL: "https://mynearwallet.com/linkdrop/CONTRACT_ID/SECRET_KEY",
      secretKeys: privKey
    });
    return (
      <div className="content">
          <Routes>
            <Route path={scannerpath} element={ <Scanner/> } />
            <Route path={homepath} element={
            <>
              <h1>You're all set! Enjoy the event</h1>
              <a href={link} target="_blank" rel="noopener noreferrer"><button className="onboard_button">Claim your POAP</button></a>
              <KeyInfo contractId={contractId} privKey={privKey} curUse={curUse} setCurUse={setCurUse} pubKey={pubKey} setPubKey={setPubKey} />
            </>}/>
          </Routes>
      </div>
    );
  }
  else if(curUse==0 && !contractId && !privKey){
    // Event Landing Page
    return (
      <div className="content">
        <h1>Welcome to the Keypom Party!</h1>
          <div>Drinks are on the house tonight!</div>
          <Routes>
            <Route path={scannerpath} element={ <Scanner/> } />
            <Route path={homepath} element={  <KeyInfo contractId={contractId} privKey={privKey} curUse={curUse} setCurUse={setCurUse} pubKey={pubKey} setPubKey={setPubKey} /> }></Route>
          </Routes>
      </div>
    );
  }
  else if(curUse==0){
    // Key has been depleted, show resources for NEAR
    return (
      <div className="content">
          <Routes>
            <Route path={scannerpath} element={ <Scanner/> } />
            <Route path={homepath} element={
            <>
              <h1>Now that you have a wallet...</h1>
              <a href={"https://near.org/learn/#anker_near"} target="_blank" rel="noopener noreferrer"><button className="onboard_button">Continue your journey into NEAR</button></a>
              <KeyInfo contractId={contractId} privKey={privKey} curUse={curUse} setCurUse={setCurUse} pubKey={pubKey} setPubKey={setPubKey} />
            </>}/>
          </Routes>
      </div>
    );
  }
  
  
}

export default App
// ReactDOM.render(<AppRouter />, document.getElementById("root"));

'''
'''--- advanced-tutorials/ticket-app-mainnet/state/keyInfo.js ---
import { initKeypom, getPubFromSecret, getKeyInformation, getDropInformation } from "@keypom/core";
import React from 'react'
import { useState, useEffect } from "react";

const KeyInfo = ({ contractId, privKey, curUse, setCurUse, pubKey, setPubKey }) => {
    
    // These functions will run anytime the component is re-rendered 
    useEffect(() => {
        async function getUsesRemaining(privKey){
            let tempKey = await getPubFromSecret(privKey)
            setPubKey(tempKey)
            const resKeyInfo = await getKeyInformation({publicKey: tempKey})
            if(resKeyInfo){
                setCurUse(resKeyInfo.cur_key_use)
            }
            else{
                setCurUse(0)
            }
        }
        async function main(privKey){
            await getUsesRemaining(privKey)
        }
        main(privKey)
        
    });

    if(curUse==1){
        console.log(pubKey)
        return (
            <div>
              <div>Public Key: {pubKey}</div>
              <div>Current Key Use: {curUse}</div>
            </div>
          )
    }
    else{
        console.log(curUse)
        return
    }
   
}

export default KeyInfo

'''
'''--- advanced-tutorials/ticket-app-mainnet/styles.css ---
/* src/styles.css */
*,
*:before,
*:after {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
:root {
  --font-color: 230 25% 7%;
}
body {
  color: hsl(var(--font-color));
  background-color: #626262;
}
img {
  max-width: 100%;
  display: block;
  color:aqua
}
.section {
  padding: 2em 0;
  /* display: flex; */
  min-height: 100vh;
  align-items: center;
  
}
.content {
  position: absolute;
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
  transform: translate(-50%, -50%);
  text-align: center;
}

.container {
  margin-inline: auto;
  max-width: 75rem;
  width: 85%;
  /* top: 50%;
  left: 50%;
  -moz-transform: translateX(-50%) translateY(-50%);
  -webkit-transform: translateX(-50%) translateY(-50%);
  transform: translateX(-50%) translateY(-50%); */
}
.input__group {
  /* display: flex; */
  margin-top: 2em;
}
.img_center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
.button span {
  cursor: pointer;
  display: inline-block;
  position: relative;
  transition: 0.5s;
}

.button span:after {
  content: '\00bb';
  position: absolute;
  opacity: 0;
  top: 0;
  right: -20px;
  transition: 0.5s;
}

.button:hover span {
  padding-right: 25px;
}

.button:hover span:after {
  opacity: 1;
  right: 0;
}
.button:active {
  background-color: #3e8e41;
  box-shadow: 0 5px #666;
  transform: translateY(8px);
}
input {
  width: 100%;
  padding: 1em 0.75em;
  border: 1px solid #444343;
  border-radius: 3px;
  margin-bottom: 2em;
  margin-top: 0.75em;
}
.button {
  padding:0.6em 2em;
  border-radius: 8px;
  color:#fff;
  background-color:#2e7d32;
  font-size:1.1em;
  border:0;
  cursor:pointer;
  margin:1em;
  transition: all 0.5s;
}
.onboard_button {
  padding:0.6em 2em;
  border-radius: 16px;
  color:#fff;
  background-color:#8852a5;
  font-size:1.1em;
  border:0;
  cursor:pointer;
  margin:1em;
  transition: all 0.5s;
}
.onboard_button:active {
  background-color: #7d2eab;
  box-shadow: 0 5px #666;
  transform: translateY(8px);
}

@media screen and (min-width: 768px) {
  .section {
    padding: 0;
  }
  input {
    margin: 0;
  }
  .qrcode__container {
    /* display: flex; */
    align-items: center;
  }
  .input__group {
    margin-left: 3em;
  }
  input {
    margin-bottom: 2em;
    margin-top: 0.75em;
    font-size: 1rem;
  }
}
'''
'''--- advanced-tutorials/ticket-app-mainnet/utils/allowEntry.js ---
const keypom = require("@keypom/core");
const {
	getPubFromSecret,
	getKeyInformation,
	hashPassword,
    claim
} = keypom

async function allowEntry({privKey, basePassword}) {
    try {
        // Check 1: Key existence
        var publicKey = getPubFromSecret(privKey)
        var keyInfo = await getKeyInformation({publicKey})
        // If key does not exist, the user should not be admitted
        if(keyInfo == null) {
            console.log(`Key does not exist. Admission denied`);
            return false;
        }

        var curUse = keyInfo.cur_key_use 

        // Ticket was already scanned
        if (curUse !== 1) {
            console.log(`Key has already been scanned. Admission denied`);
            return false;
        }

        // Create password using base + pubkey + key use as string
        let passwordForClaim = await hashPassword(basePassword + publicKey + curUse.toString())
        // Claim with created password
        await claim({
            secretKey: privKey,
            password: passwordForClaim
        })

        // Check 3: Check if claim was successful by validating that curUse incremented
        keyInfo = await getKeyInformation({publicKey})

        if (keyInfo.cur_key_use !== 2) {
            console.log(`Claim has failed, check password`)
            return false;
        }
    } catch(err) {
        console.log(`Unknown Error: ${err}. Admission denied`)
        return false;
    }

    return true
}

module.exports = {
    allowEntry
}
'''
'''--- advanced-tutorials/ticket-app-mainnet/utils/createTickDrop.js ---
const path = require("path");
const homedir = require("os").homedir();
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { parseNearAmount } = require("@near-js/utils");
const { Account } = require("@near-js/accounts");
const { connect, Near } = require("@near-js/wallet-account");
var assert = require('assert');

const keypom = require("@keypom/core");
const {
	initKeypom,
	getEnv,
	createDrop,
    createNFTSeries,
    formatLinkdropUrl
} = keypom

// Change this to your account ID
const FUNDER_ACCOUNT_ID = "mintlu.near";
const NETWORK_ID = "mainnet";
async function createTickDrop() {
    // Initiate connection to the NEAR blockchain.
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);  

    let nearConfig = {
        networkId: NETWORK_ID,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
        walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
        helperUrl: `https://helper.${NETWORK_ID}.near.org`,
        explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
    };  

    let near = new Near(nearConfig);
    const fundingAccount = new Account(near.connection, FUNDER_ACCOUNT_ID)
    
    // If a NEAR connection is not passed in and is not already running, initKeypom will create a new connection
    // Here we are connecting to the testnet network
    await initKeypom({
        near,
        network: NETWORK_ID,
    });

    // Create drop with 10 keys and 2 key uses each
    let {keys, dropId} = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        config: {
            usesPerKey: 2
        },
        depositPerUseNEAR: "0.01",
        basePassword: "event-password",
        passwordProtectedUses: [1],
        useBalance: true,
        fcData: {
            methods: [
                null,
                [
                    {
                        receiverId: `nft-v2.keypom.${NETWORK_ID == "mainnet" ? "near" : "testnet"}`,
                        methodName: "nft_mint",
                        args: "",
                        dropIdField: "mint_id",
                        accountIdField: "receiver_id",
                        attachedDeposit: parseNearAmount("0.1")
                    }
                ],
            ]   
        }, 
    })

    await createNFTSeries({
        account: fundingAccount,
        dropId,
        metadata: {
            title: "Moon NFT Ticket!",
            description: "A cool NFT POAP for the best dog in the world.",
            media: "bafybeibwhlfvlytmttpcofahkukuzh24ckcamklia3vimzd4vkgnydy7nq",
            copies: 1
        },
        useBalance: true
    }); 

    const {contractId: KEYPOM_CONTRACT} = getEnv()
    let tickets = formatLinkdropUrl({
        customURL: "http://localhost:1234/CONTRACT_ID/SECRET_KEY",
        secretKeys: keys.secretKeys,
        contractId: KEYPOM_CONTRACT,
    })
    console.log(`Public Keys: ${keys.publicKeys}`)
    console.log(`
    
    Ticket Links: 
    
    ${tickets}
    
    `)

    return keys
}

createTickDrop()

module.exports = {
    createTickDrop
}

'''
'''--- advanced-tutorials/ticket-app-mainnet/utils/temp.js ---
const path = require("path");
const homedir = require("os").homedir();
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { parseNearAmount } = require("@near-js/utils");
const { Account } = require("@near-js/accounts");
const { Near } = require("@near-js/wallet-account");

const keypom = require("@keypom/core");
const {
  initKeypom,
  getEnv,
  createDrop,
    createNFTSeries,
    formatLinkdropUrl
} = keypom

// Change this to your account ID
const FUNDER_ACCOUNT_ID = "minqi.testnet";
const NETWORK_ID = "testnet";
async function createTickDrop() {
    // Initiate connection to the NEAR blockchain.
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

    let nearConfig = {
        networkId: NETWORK_ID,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
        walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
        helperUrl: `https://helper.${NETWORK_ID}.near.org`,
        explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
    };

    let near = new Near(nearConfig);
    const fundingAccount = new Account(near.connection, FUNDER_ACCOUNT_ID)

    // If a NEAR connection is not passed in and is not already running, initKeypom will create a new connection
    // Here we are connecting to the testnet network
    await initKeypom({
        near,
        network: NETWORK_ID,
    });

    const contractNetworkId = NETWORK_ID === "mainnet" ? "near" : NETWORK_ID;

    // ONCE SERIES IS CREATED, THIS WILL WORK
    let { keys, dropId: MAIN_DROP_ID } = await createDrop({
        account: fundingAccount,
        numKeys: 4,
        config: {
            usesPerKey: 2
        },
        depositPerUseNEAR: "0.1",
        basePassword: "event-password",
        passwordProtectedUses: [1],
        fcData: {
            methods: [
                null,
                [
                    {
                        receiverId: `nft-v2.keypom.${contractNetworkId}`,
                        methodName: "nft_mint",
                        args: "",
                        dropIdField: "mint_id",
                        accountIdField: "receiver_id",
                        attachedDeposit: parseNearAmount("0.1")
                    }
                ],
            ]
        }
    });

    // CLAIM THIS FIRST TO CREATE YOUR SERIES
    let { keys: keys2, dropId: dropId2 } = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        config: {
            usesPerKey: 1
        },
        depositPerUseNEAR: "0.1",
        fcData: {
            methods: [
                [
                    {
                        receiverId: `nft-v2.keypom.${contractNetworkId}`,
                        methodName: "create_series",
                        args: JSON.stringify({
                            // Change this token_id if it already exists -> check explorer transaction
                            mint_id: parseInt(MAIN_DROP_ID),
                            metadata: {
                                title: "Near Ukraine Guild - Rust Kyiv Meetup",
                                description: "Rust Kyiv Meetup ticket from Near Ukraine Guild, Human Guild, Brushfam",
                                media: "bafybeicmsn7aqzz7qma6fhkipu7bmfd6huopnhuil5d7nqpwsu4tqggafu",
                                copies: 4
                            }
                        }),
                        attachedDeposit: parseNearAmount("0.1")
                    }
                ],
            ]
        }
    });

    const {contractId: KEYPOM_CONTRACT} = getEnv()
    let tickets = formatLinkdropUrl({
        customURL: "https://kiskesis.github.io/ticketdrop/#/CONTRACT_ID/SECRET_KEY",
        secretKeys: keys.secretKeys,
        contractId: KEYPOM_CONTRACT,
    })
    let nfts = formatLinkdropUrl({
        // customURL: "https://wallet.near.org/linkdrop/CONTRACT_ID/SECRET_KEY",
        customURL: "https://testnet.mynearwallet.com/linkdrop/CONTRACT_ID/SECRET_KEY",
        secretKeys: keys2.secretKeys,
        contractId: KEYPOM_CONTRACT,
    })
    console.log("\nOnly scan tickets once NFT series is created by claiming the link below!!!\n\n" + tickets.join("\n") + "\n");
    console.log("\nCLAIM ME FIRST, I CREATE THE NFT SERIES:\n\n" + nfts.join("\n") + "\n");
    return keys
}

createTickDrop()

module.exports = {
    createTickDrop
}
'''
'''--- advanced-tutorials/ticket-app-mainnet/utils/testTickDrop.js ---
var assert = require('assert');
const { createTickDrop } = require("./createTickDrop");
const { allowEntry } = require("./allowEntry");

async function wrongPasswordCheck() {
    let responses = [null, null]
    // Create Drop
    let keys = await createTickDrop();
    let privKey = keys.secretKeys[0];

    // Incorrect Password
    console.log("Claiming with wrong password...")
    let shouldAdmit = await allowEntry({
        privKey, 
        basePassword: "wrong-password"
    })
    assert(shouldAdmit === false, `Expected no admittance with incorrect password.`)
    responses[0] = shouldAdmit

    // Correct password
    console.log("claiming with correct password...")
    shouldAdmit = await allowEntry({
        privKey,
        basePassword: "event-password"
    })
    assert(shouldAdmit === true, `Expected admittance with correct password.`)
    responses[1] = shouldAdmit

    return responses;
}

async function doubleClaimCheck() {
    let responses = [null, null];
    // Create Drop
    let keys = await createTickDrop();
    let privKey = keys.secretKeys[0];

    // Correct Password (first claim)
    console.log("Claiming with correct password...")
    let shouldAdmit = await allowEntry({
        privKey, 
        basePassword: "event-password"
    })
    assert(shouldAdmit === true, `Expected admittance with correct password.`)
    responses[0] = shouldAdmit

    // Correct password (duplicate claim)
    console.log("claiming the same key twice...")
    shouldAdmit = await allowEntry({
        privKey,
        basePassword: "event-password"
    })
    assert(shouldAdmit === false, `Expected no admittance due to duplicate claim.`)
    responses[1] = shouldAdmit

    return responses;
}

async function tests() {
    let pwResponses = await wrongPasswordCheck();
    let dcResponses = await doubleClaimCheck();

    console.log(`
        Password Test Responses:
        Expected false, got: ${pwResponses[0]}
        Expected true, got: ${pwResponses[1]}

        Double Claim Test Responses:
        Expected true, got: ${dcResponses[0]}
        Expected false, got: ${dcResponses[1]}
    `);
}

tests()

'''
'''--- advanced-tutorials/ticket-app-skeleton/App.css ---
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

'''
'''--- advanced-tutorials/ticket-app-skeleton/components/qrcode.js ---
import { useState, useEffect } from "react";
import { QRCodeCanvas } from "qrcode.react";

const QrCode = ({ link }) => {
  const qrcode = (
    <QRCodeCanvas
      id="qrCode"
      value={link}
      size={300}
      fgColor={"#000000"}
      bgColor={"#F8F8FF"}
      level={"H"}
    />
  );
  return (
    <div className="qrcode__container">
      <div>{qrcode}</div>
    </div>
  );
};

export default QrCode;
'''
'''--- advanced-tutorials/ticket-app-skeleton/components/scanner.js ---
import React from "react";
import { useZxing } from "react-zxing";
import { useState, useEffect } from "react";
import logo from "../static/img/green-check.png"
import xLogo from "../static/img/red-x.png"
import "../styles.css";
import { allowEntry } from "../utils/allowEntry";

export const Scanner = () => {

  // Scanner and getting results of scan
  const { ref } = useZxing({
    onResult(result) {

    },
  });

  // Functions that only run when scanner is mounted 
  // connect to NEAR, initKeypom, and get password
  useEffect(() => {
  
  }, [])

  // Claiming the drop using password
  useEffect(() => {
      function timeout(delay) {
          
      }

      async function scannerClaim(){
        
      }

  }, [masterStatus.data])

  switch (masterStatus.stage) {
    case Stage.preClaim:

    case Stage.claiming:
      
    case Stage.successClaim:
     
    case Stage.failClaim:
      
    default:
      
    }
};

'''
'''--- advanced-tutorials/ticket-app-skeleton/css/global.css ---
* {
  box-sizing: border-box;
}

html {
  --bg: #efefef;
  --fg: #1e1e1e;
  --gray: #555;
  --light-gray: #ccc;
  --shadow: #e6e6e6;
  --success: rgb(90, 206, 132);
  --primary: #FF585D;
  --secondary: #0072CE;

  background-color: var(--bg);
  color: var(--fg);
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  font-size: calc(0.9em + 0.5vw);
  line-height: 1.3;
}

body {
  margin: 0;
  padding: 1em;
}

main {
  margin: 0 auto;
  max-width: 26em;
  text-align: justify;
}

h1 {
  background-image: url(../img/logo-black.svg);
  background-position: center 1em;
  background-repeat: no-repeat;
  background-size: auto 1.5em;
  margin-top: 0;
  padding: 3.5em 0 0.5em;
  text-align: center;
}

a,
.link {
  color: var(--primary);
  text-decoration: none;
}
a:hover,
a:focus,
.link:hover,
.link:focus {
  text-decoration: underline;
}
a:active,
.link:active {
  color: var(--secondary);
}

button, input {
  font: inherit;
  outline: none;
}

button {
  background-color: var(--secondary);
  border-radius: 5px;
  border: none;
  color: #efefef;
  cursor: pointer;
  padding: 0.3em 0.75em;
  transition: transform 30ms;
}
button:hover, button:focus {
  box-shadow: 0 0 10em rgba(255, 255, 255, 0.2) inset;
}
button:active {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.1) inset;
}
button.link {
  background: none;
  border: none;
  box-shadow: none;
  display: inline;
}
[disabled] button, button[disabled] {
  box-shadow: none;
  background-color: var(--light-gray);
  color: gray;
  cursor: not-allowed;
  transform: none;
}
[disabled] button {
  text-indent: -900em;
  width: 2em;
  position: relative;
}
[disabled] button:after {
  content: " ";
  display: block;
  width: 0.8em;
  height: 0.8em;
  border-radius: 50%;
  border: 2px solid #fff;
  border-color: var(--fg) transparent var(--fg) transparent;
  animation: loader 1.2s linear infinite;
  position: absolute;
  top: 0.45em;
  right: 0.5em;
}
@keyframes loader {
  0% { transform: rotate(0deg) }
  100% { transform: rotate(360deg) }
}

fieldset {
  border: none;
  padding: 2em 0;
}

input {
  background-color: var(--shadow);
  border: none;
  border-radius: 5px 0 0 5px;
  caret-color: var(--primary);
  color: inherit;
  padding: 0.25em 1em;
}
input::selection {
  background-color: var(--secondary);
  color: #efefef;
}
input:focus {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.02) inset;
}

code {
  color: var(--gray);
}

li {
  padding-bottom: 1em;
}

aside {
  animation: notify ease-in-out 10s;
  background-color: var(--shadow);
  border-radius: 5px;
  bottom: 0;
  font-size: 0.8em;
  margin: 1em;
  padding: 1em;
  position: fixed;
  transform: translateY(10em);
  right: 0;
}
aside footer {
  display: flex;
  font-size: 0.9em;
  justify-content: space-between;
  margin-top: 0.5em;
}
aside footer *:first-child {
  color: var(--success);
}
aside footer *:last-child {
  color: var(--gray);
}
@keyframes notify {
  0% { transform: translateY(10em) }
  5% { transform: translateY(0) }
  95% { transform: translateY(0) }
  100% { transform: translateY(10em) }
}

@media (prefers-color-scheme: dark) {
  html {
    --bg: #1e1e1e;
    --fg: #efefef;
    --gray: #aaa;
    --shadow: #2a2a2a;
    --light-gray: #444;
  }
  h1 {
    background-image: url(../img/logo-white.svg);
  }
  input:focus {
    box-shadow: 0 0 10em rgba(255, 255, 255, 0.02) inset;
  }
}

'''
'''--- advanced-tutorials/ticket-app-skeleton/index.css ---
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

'''
'''--- advanced-tutorials/ticket-app-skeleton/index.html ---
<body>
    <div id="root"></div>
    <script type="module" src="./index.js"></script>
</body>
'''
'''--- advanced-tutorials/ticket-app-skeleton/index.js ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './state/App';
import { BrowserRouter } from "react-router-dom";
import { Buffer } from "buffer"; global.Buffer = Buffer;

// CREATED WITH V1-4 30 uses with pw and every 2nd minting nft
//ed25519:4Yc94z2jETj2c4iMRuAexRZsYadYtXBoHsmUuN9XUtwj
// https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/t5PWmHyFh5bKFpycSzEApJ4GMjofGZM3pvYpzkNkm6Wa1cDMaotfbYQ67Jwjtrqp9hu8aa1j32Zf9BJEzK1CMLM

// CREATED WITH V1-4, 1000 uses simple drop no pw
// Public Keys and Linkdrops:  {
// 'ed25519:GUeRZniVhEA4DRfikBoiZFZyEdzja3jo3jFLvyLeRd32'
//'https://wallet.testnet.near.org/linkdrop/v1-4.keypom.testnet/4aJGvd5za9nTWJcZBVAgEyaaU6kymPSyoXhtJLfNNx5XA1aWSXxDAqBnrPDBcm7PT5hCwk8L3nDExBYWKoB7HEix'

               
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  // <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>,
  // </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals

// 10 keys, 2 each with null 1st and nft mint second. tabbed entry indicates key in use or depleted
// --- 'ed25519:6Ug2EqRAFSPk5o18aMc7F27EUJjtYwqgKcQvWobUtHZC': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/qKfzzz2y15p91HzSh5xxZA6GGx2V3DmNEAzgtbo5HZVn7PsqaRj6g3P6i5KQ28bKy2R2E61WA5f6jXzNJFmKziN',
// --- 'ed25519:6V4PTNFKgqQet3b5ckB1wwEtT389CDD5rik4SVMTu6kP': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/rtQ9LyqNcbGGJknZeZDk7w37dApUk1GnHCVRb7d5AaqxuytMUf6bh6HQsE3C2uWCakFaa2Z4QJipkFs6WwZafB5',
// 'ed25519:sBb3B1FsjxFHFJCWfMKchyaZWsSsK1U52iwvF9EXmCk': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/3yCwKjw6jSMk4Dbn939mpLVrGBDH4mFd7yRcS8M5Us1LgEhwePMXQ7XczASt7L6qYDHBnvmP1wWnGcF6sgZzo28Y',
// 'ed25519:FUteBnVMTquBS2Fq8NL4krcCX4Bbj7opiLGSnnHHbYvB': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/rwT4ZetJdHdBhGnV7iMD8zqJ4o9bjjBwNJYFcV32CgaQBXDNbHMcp3Df4rP3iCER28ZwrFhKNDaTGhJYPCoFNaT',
// 'ed25519:DW6Ux6XJhYLajej5VB8svyZ5MGeCMozeazxRSuA4CHtm': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/c5B7yjwTHwkquKjYT5z2hGvXsHS3kdKvy2v5NChdJVaQGeJfTsMhs3VM7tfq28f7FqLBNZNJSUQB2nUuesRMmCu',
// 'ed25519:2nbNNfo1tm5pcMniq8r6HSkq2gLhK9M1iCwGZ59JPhQF': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/5QN4aFbfMwAtm8ubasKX6VbqH7i4K33HznfLTpRpQYKv9oG2dBNbRg1pYooYbC7kSbJ3qgA6pSySwEha71XvN5oH',
// 'ed25519:FY7Ws3yW7TmbEhJGkpcM8tx4Lowt5Z6wqC9z8fJYXUGS': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/2Uj5a2e9AjWG6p8SqMNCEJGKAW5QiVjtgmqGShDWYE3GY5oYWz9mzC19vPyLUmAXNuhxCN9r6TF3D6vhdYTahVUn',
// 'ed25519:Gd7v5NaL2fCwNsMdDiRiwtXBBhe9LHo1CSoRCDs1unev': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/3J744n3zT29Dc4GzrnGbdNiwMM5cZv9eJdCd6WxAbJQy48RSfMWvnzbwcn6tgBYYPYtqcEeGhxU4pVdjmCx3yBZc',
// 'ed25519:DULssBcpvFpnMQ4sPnGrpqSrqyuTnHErFTzNfJERvf7e': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/25J9zdomMM9uDttmJRefwJwSpKsv7VRccvbqym8QEUu3PnjiRhye5h8U9hUdnq7bp72x56eABLNXYaThqVNVeWnL',
// 'ed25519:3CSopDVtq4uGno5tAes3Ld1tBE8jM1qJmMTsYt86PMxy': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/3JPaXXbdiDr3JVXx6qR1bce2byrTbgBeVKzYCWZ7jSwuKgangetNiYG5NY4NtUzxbaV1LDLtqqDoMuvE19zNa9jb'

// OLD
// https://wallet.testnet.near.org/linkdrop/v1-3.keypom.testnet/2TJ9RbP3UtNyJGTD9EKdabavTMSJC97hcnGQjXwbC7uRPn7TZaUspoXEKzFEThgyJqatyCVung3yySQGGEBumXd2
// curPks:  [ 'ed25519:4X3TdmDCEuVg6ifBoU3v3r75XqUk6w37HiapucsQ497W' ]

'''
'''--- advanced-tutorials/ticket-app-skeleton/package.json ---
{
  "name": "ticket-app",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "parcel index.html --open",
    "build": "parcel build index.html --public-url ./",
    "create-ticket-drop": "node utils/createTickDrop.js",
    "test-ticket-drop": "node utils/testTickDrop.js"
  },
  "dependencies": {
    "@keypom/core": "^1.0.0",
    "@keypom/selector": "^1.0.0",
    "parcel": "^2.6.0",
    "qrcode.react": "^3.1.0",
    "react-router-dom": "^6.8.2",
    "react-zxing": "^1.1.3"
  },
  "devDependencies": {
    "@babel/core": "~7.18.2",
    "@babel/preset-env": "~7.18.2",
    "@babel/preset-react": "~7.17.12",
    "assert": "^2.0.0",
    "buffer": "^5.5.0",
    "crypto-browserify": "^3.12.0",
    "env-cmd": "~10.1.0",
    "events": "^3.1.0",
    "nodemon": "~2.0.16",
    "os-browserify": "^0.3.0",
    "process": "^0.11.10",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "stream-browserify": "^3.0.0",
    "ts-node": "^10.8.0",
    "typescript": "^4.7.2"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- advanced-tutorials/ticket-app-skeleton/state/App.js ---
import QrCode from "../components/qrcode";
import KeyInfo from "./keyInfo";
// import "./styles.css";
import React from "react";
import { useState, useEffect } from "react";
import { BrowserRouter, Route, Routes } from 'react-router-dom';
import { Scanner } from "../components/scanner";
import "../styles.css";
import { initKeypom, formatLinkdropUrl } from "@keypom/core";
import { Near } from "@near-js/wallet-account";
import { BrowserLocalStorageKeyStore } from "@near-js/keystores-browser";

async function connectNear(privateKey, contractId){

}

async function setup(){
  
}

function App() {
  
}

export default App
// ReactDOM.render(<AppRouter />, document.getElementById("root"));

'''
'''--- advanced-tutorials/ticket-app-skeleton/state/keyInfo.js ---
import { initKeypom, getPubFromSecret, getKeyInformation, getDropInformation } from "@keypom/core";
import React from 'react'
import { useState, useEffect } from "react";

const KeyInfo = ({ contractId, privKey, curUse, setCurUse, pubKey, setPubkey }) => {
   
}

export default KeyInfo

'''
'''--- advanced-tutorials/ticket-app-skeleton/styles.css ---
/* src/styles.css */
*,
*:before,
*:after {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
:root {
  --font-color: 230 25% 7%;
}
body {
  color: hsl(var(--font-color));
  background-color: #626262;
}
img {
  max-width: 100%;
  display: block;
  color:aqua
}
.section {
  padding: 2em 0;
  /* display: flex; */
  min-height: 100vh;
  align-items: center;
  
}
.content {
  position: absolute;
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
  transform: translate(-50%, -50%);
  text-align: center;
}

.container {
  margin-inline: auto;
  max-width: 75rem;
  width: 85%;
  /* top: 50%;
  left: 50%;
  -moz-transform: translateX(-50%) translateY(-50%);
  -webkit-transform: translateX(-50%) translateY(-50%);
  transform: translateX(-50%) translateY(-50%); */
}
.input__group {
  /* display: flex; */
  margin-top: 2em;
}
.img_center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
.button span {
  cursor: pointer;
  display: inline-block;
  position: relative;
  transition: 0.5s;
}

.button span:after {
  content: '\00bb';
  position: absolute;
  opacity: 0;
  top: 0;
  right: -20px;
  transition: 0.5s;
}

.button:hover span {
  padding-right: 25px;
}

.button:hover span:after {
  opacity: 1;
  right: 0;
}
.button:active {
  background-color: #3e8e41;
  box-shadow: 0 5px #666;
  transform: translateY(8px);
}
input {
  width: 100%;
  padding: 1em 0.75em;
  border: 1px solid #444343;
  border-radius: 3px;
  margin-bottom: 2em;
  margin-top: 0.75em;
}
.button {
  padding:0.6em 2em;
  border-radius: 8px;
  color:#fff;
  background-color:#2e7d32;
  font-size:1.1em;
  border:0;
  cursor:pointer;
  margin:1em;
  transition: all 0.5s;
}
.onboard_button {
  padding:0.6em 2em;
  border-radius: 16px;
  color:#fff;
  background-color:#8852a5;
  font-size:1.1em;
  border:0;
  cursor:pointer;
  margin:1em;
  transition: all 0.5s;
}
.onboard_button:active {
  background-color: #7d2eab;
  box-shadow: 0 5px #666;
  transform: translateY(8px);
}

@media screen and (min-width: 768px) {
  .section {
    padding: 0;
  }
  input {
    margin: 0;
  }
  .qrcode__container {
    /* display: flex; */
    align-items: center;
  }
  .input__group {
    margin-left: 3em;
  }
  input {
    margin-bottom: 2em;
    margin-top: 0.75em;
    font-size: 1rem;
  }
}
'''
'''--- advanced-tutorials/ticket-app-skeleton/utils/allowEntry.js ---
const keypom = require("@keypom/core");
const {
	getPubFromSecret,
	getKeyInformation,
	hashPassword,
    claim
} = keypom

async function allowEntry({privKey, basePassword}) {
}

module.exports = {
    allowEntry
}
'''
'''--- advanced-tutorials/ticket-app-skeleton/utils/createTickDrop.js ---
const path = require("path");
const homedir = require("os").homedir();
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { parseNearAmount } = require("@near-js/utils");
const { Account } = require("@near-js/accounts");
const { connect, Near } = require("@near-js/wallet-account");
var assert = require('assert');

const keypom = require("@keypom/core");
const {
	initKeypom,
	getEnv,
	createDrop,
    createNFTSeries,
    formatLinkdropUrl
} = keypom

// Change this to your account ID
const FUNDER_ACCOUNT_ID = "minqi.testnet";
const NETWORK_ID = "testnet";
async function createTickDrop() {
    // STEP 1: Initiate a NEAR connection.

    // STEP 2: Create the drop with function call data.

    // STEP 3: Make NFT series for POAPs.
}

createTickDrop()

module.exports = {
    createTickDrop
}

'''
'''--- advanced-tutorials/ticket-app-skeleton/utils/testTickDrop.js ---
var assert = require('assert');
const { createTickDrop } = require("./createTickDrop");
const { allowEntry } = require("./allowEntry");

async function wrongPasswordCheck() {
}

async function doubleClaimCheck() {
}

async function tests() {
    let pwResponses = await wrongPasswordCheck();
    let dcResponses = await doubleClaimCheck();

    console.log(`
        Password Test Responses:
        Expected false, got: ${pwResponses[0]}
        Expected true, got: ${pwResponses[1]}

        Double Claim Test Responses:
        Expected true, got: ${dcResponses[0]}
        Expected false, got: ${dcResponses[1]}
    `);
}

tests()

'''
'''--- advanced-tutorials/ticket-app/App.css ---
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

'''
'''--- advanced-tutorials/ticket-app/components/qrcode.js ---
import { useState, useEffect } from "react";
import { QRCodeCanvas } from "qrcode.react";

const QrCode = ({ link }) => {
  const qrcode = (
    <QRCodeCanvas
      id="qrCode"
      value={link}
      size={300}
      fgColor={"#000000"}
      bgColor={"#F8F8FF"}
      level={"H"}
    />
  );
  return (
    <div className="qrcode__container">
      <div>{qrcode}</div>
    </div>
  );
};

export default QrCode;
'''
'''--- advanced-tutorials/ticket-app/components/scanner.js ---
import React from "react";
import { useZxing } from "react-zxing";
import { useState, useEffect } from "react";
import logo from "../static/img/green-check.png"
import xLogo from "../static/img/red-x.png"
import "../styles.css";
import { allowEntry } from "../utils/allowEntry";

export const Scanner = () => {
  // Stage enum
  const Stage = {
    preClaim: "Pre-claim",
    claiming: "Claiming",
    successClaim: "Success",
    failClaim: "Fail"
  }

  // Data enum
  const Data = {
    empty: "Empty",
    captured: "Captured",
  }

  // State Variables
  const [result, setResult] = useState("");
  const [splitRes, setSplitRes] = useState([]);
  const [resPrivKey, setResPrivkey] = useState("")
  const [password, setPassword] = useState("NULL")
  const [masterStatus, setMasterStatus] = useState({ stage: Stage.preClaim, data: Data.empty })

  // Scanner and getting results of scan
  const { ref } = useZxing({
    onResult(result) {
      setResult(result.getText());
      setSplitRes([...result.getText().split("/")]);
      setResPrivkey(result.getText().split("/")[1])

      //indicate new data
      let tempMaster = {
        stage: Stage.claiming,
        data: Data.captured
      }
      setMasterStatus(tempMaster)
    },
  });

  // Functions that only run when scanner is mounted 
  // Get password
  useEffect(() => {
    let PASSWORD = "NULL"
    PASSWORD = prompt("Enter base password for drop")
    setPassword(PASSWORD)
  }, [])

  // Claiming the drop using password
  useEffect(() => {
    function timeout(delay) {
      return new Promise(res => setTimeout(res, delay));
    }

    async function scannerClaim() {
      let isAllowedIn = await allowEntry({
        privKey: resPrivKey,
        basePassword: password
      })

      // Successful Claim
      if (isAllowedIn) {
        setMasterStatus({
          stage: Stage.successClaim,
          data: Data.captured
        })
      } else { // Failed Claim
        setMasterStatus({
          stage: Stage.failClaim,
          data: Data.captured
        })
      }

      // Wait 3s, then flip go back to pre-claim
      await timeout(3000)
      setMasterStatus({
        stage: Stage.preClaim,
        data: Data.empty
      })
    }
    // Only claim if there is data present
    if (masterStatus.data === Data.captured) {
      scannerClaim()
    }

  }, [masterStatus.data])

  switch (masterStatus.stage) {
    case Stage.preClaim:
      return (
        <>
          <div className="content">
            <div style={{ border: "0.5rem solid white" }}><video ref={ref} /></div>
            <h2>Scan a linkdrop QR code to claim</h2>
            <h4>To re-enter password, refresh the page</h4>
          </div>
        </>
      );
    case Stage.claiming:
      return (
        <>
          <div className="content">
            <div style={{ border: "0.5rem solid yellow" }}><video ref={ref} /></div>
            <h2>Claiming</h2>
            <h4>Note this should take a few seconds</h4>
          </div>
        </>
      );
    case Stage.successClaim:
      return (
        <>
          <div className="content">
            <div style={{ border: "0.5rem solid green" }}><video ref={ref} /></div>
            <h2>Claimed!</h2>
            <img src={logo} alt="green check" width="50" height="60" className="img_center"></img>
          </div>
        </>
      );
    case Stage.failClaim:
      return (
        <>
          <div className="content">
            <div style={{ border: "0.5rem solid red" }}><video ref={ref} /></div>
            <h2>Could Not Be Claimed!</h2>
            <h3>Ensure Password is Correct</h3>
            <h4>To re-enter password, refresh the page</h4>
            <img src={xLogo} alt="red x" width="50" height="60" className="img_center"></img>
          </div>
        </>
      );
    default:
      let errorMsg = `Error: masterState.stage is ${masterStatus.stage}`
      return (
        <>
          <div className="content">
            <h2>{errorMsg}</h2>
            <img src={xLogo} alt="red x" width="50" height="60" className="img_center"></img>
          </div>
        </>
      );
  }
};

'''
'''--- advanced-tutorials/ticket-app/css/global.css ---
* {
  box-sizing: border-box;
}

html {
  --bg: #efefef;
  --fg: #1e1e1e;
  --gray: #555;
  --light-gray: #ccc;
  --shadow: #e6e6e6;
  --success: rgb(90, 206, 132);
  --primary: #FF585D;
  --secondary: #0072CE;

  background-color: var(--bg);
  color: var(--fg);
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  font-size: calc(0.9em + 0.5vw);
  line-height: 1.3;
}

body {
  margin: 0;
  padding: 1em;
}

main {
  margin: 0 auto;
  max-width: 26em;
  text-align: justify;
}

h1 {
  background-image: url(../img/logo-black.svg);
  background-position: center 1em;
  background-repeat: no-repeat;
  background-size: auto 1.5em;
  margin-top: 0;
  padding: 3.5em 0 0.5em;
  text-align: center;
}

a,
.link {
  color: var(--primary);
  text-decoration: none;
}
a:hover,
a:focus,
.link:hover,
.link:focus {
  text-decoration: underline;
}
a:active,
.link:active {
  color: var(--secondary);
}

button, input {
  font: inherit;
  outline: none;
}

button {
  background-color: var(--secondary);
  border-radius: 5px;
  border: none;
  color: #efefef;
  cursor: pointer;
  padding: 0.3em 0.75em;
  transition: transform 30ms;
}
button:hover, button:focus {
  box-shadow: 0 0 10em rgba(255, 255, 255, 0.2) inset;
}
button:active {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.1) inset;
}
button.link {
  background: none;
  border: none;
  box-shadow: none;
  display: inline;
}
[disabled] button, button[disabled] {
  box-shadow: none;
  background-color: var(--light-gray);
  color: gray;
  cursor: not-allowed;
  transform: none;
}
[disabled] button {
  text-indent: -900em;
  width: 2em;
  position: relative;
}
[disabled] button:after {
  content: " ";
  display: block;
  width: 0.8em;
  height: 0.8em;
  border-radius: 50%;
  border: 2px solid #fff;
  border-color: var(--fg) transparent var(--fg) transparent;
  animation: loader 1.2s linear infinite;
  position: absolute;
  top: 0.45em;
  right: 0.5em;
}
@keyframes loader {
  0% { transform: rotate(0deg) }
  100% { transform: rotate(360deg) }
}

fieldset {
  border: none;
  padding: 2em 0;
}

input {
  background-color: var(--shadow);
  border: none;
  border-radius: 5px 0 0 5px;
  caret-color: var(--primary);
  color: inherit;
  padding: 0.25em 1em;
}
input::selection {
  background-color: var(--secondary);
  color: #efefef;
}
input:focus {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.02) inset;
}

code {
  color: var(--gray);
}

li {
  padding-bottom: 1em;
}

aside {
  animation: notify ease-in-out 10s;
  background-color: var(--shadow);
  border-radius: 5px;
  bottom: 0;
  font-size: 0.8em;
  margin: 1em;
  padding: 1em;
  position: fixed;
  transform: translateY(10em);
  right: 0;
}
aside footer {
  display: flex;
  font-size: 0.9em;
  justify-content: space-between;
  margin-top: 0.5em;
}
aside footer *:first-child {
  color: var(--success);
}
aside footer *:last-child {
  color: var(--gray);
}
@keyframes notify {
  0% { transform: translateY(10em) }
  5% { transform: translateY(0) }
  95% { transform: translateY(0) }
  100% { transform: translateY(10em) }
}

@media (prefers-color-scheme: dark) {
  html {
    --bg: #1e1e1e;
    --fg: #efefef;
    --gray: #aaa;
    --shadow: #2a2a2a;
    --light-gray: #444;
  }
  h1 {
    background-image: url(../img/logo-white.svg);
  }
  input:focus {
    box-shadow: 0 0 10em rgba(255, 255, 255, 0.02) inset;
  }
}

'''
'''--- advanced-tutorials/ticket-app/index.css ---
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

'''
'''--- advanced-tutorials/ticket-app/index.html ---
<body>
    <div id="root"></div>
    <script type="module" src="./index.js"></script>
</body>
'''
'''--- advanced-tutorials/ticket-app/index.js ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './state/App';
import { BrowserRouter } from "react-router-dom";
import { Buffer } from "buffer"; global.Buffer = Buffer;

// CREATED WITH V1-4 30 uses with pw and every 2nd minting nft
//ed25519:4Yc94z2jETj2c4iMRuAexRZsYadYtXBoHsmUuN9XUtwj
// https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/t5PWmHyFh5bKFpycSzEApJ4GMjofGZM3pvYpzkNkm6Wa1cDMaotfbYQ67Jwjtrqp9hu8aa1j32Zf9BJEzK1CMLM

// CREATED WITH V1-4, 1000 uses simple drop no pw
// Public Keys and Linkdrops:  {
// 'ed25519:GUeRZniVhEA4DRfikBoiZFZyEdzja3jo3jFLvyLeRd32'
//'https://wallet.testnet.near.org/linkdrop/v1-4.keypom.testnet/4aJGvd5za9nTWJcZBVAgEyaaU6kymPSyoXhtJLfNNx5XA1aWSXxDAqBnrPDBcm7PT5hCwk8L3nDExBYWKoB7HEix'

               
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  // <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>,
  // </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals

// 10 keys, 2 each with null 1st and nft mint second. tabbed entry indicates key in use or depleted
// --- 'ed25519:6Ug2EqRAFSPk5o18aMc7F27EUJjtYwqgKcQvWobUtHZC': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/qKfzzz2y15p91HzSh5xxZA6GGx2V3DmNEAzgtbo5HZVn7PsqaRj6g3P6i5KQ28bKy2R2E61WA5f6jXzNJFmKziN',
// --- 'ed25519:6V4PTNFKgqQet3b5ckB1wwEtT389CDD5rik4SVMTu6kP': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/rtQ9LyqNcbGGJknZeZDk7w37dApUk1GnHCVRb7d5AaqxuytMUf6bh6HQsE3C2uWCakFaa2Z4QJipkFs6WwZafB5',
// 'ed25519:sBb3B1FsjxFHFJCWfMKchyaZWsSsK1U52iwvF9EXmCk': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/3yCwKjw6jSMk4Dbn939mpLVrGBDH4mFd7yRcS8M5Us1LgEhwePMXQ7XczASt7L6qYDHBnvmP1wWnGcF6sgZzo28Y',
// 'ed25519:FUteBnVMTquBS2Fq8NL4krcCX4Bbj7opiLGSnnHHbYvB': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/rwT4ZetJdHdBhGnV7iMD8zqJ4o9bjjBwNJYFcV32CgaQBXDNbHMcp3Df4rP3iCER28ZwrFhKNDaTGhJYPCoFNaT',
// 'ed25519:DW6Ux6XJhYLajej5VB8svyZ5MGeCMozeazxRSuA4CHtm': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/c5B7yjwTHwkquKjYT5z2hGvXsHS3kdKvy2v5NChdJVaQGeJfTsMhs3VM7tfq28f7FqLBNZNJSUQB2nUuesRMmCu',
// 'ed25519:2nbNNfo1tm5pcMniq8r6HSkq2gLhK9M1iCwGZ59JPhQF': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/5QN4aFbfMwAtm8ubasKX6VbqH7i4K33HznfLTpRpQYKv9oG2dBNbRg1pYooYbC7kSbJ3qgA6pSySwEha71XvN5oH',
// 'ed25519:FY7Ws3yW7TmbEhJGkpcM8tx4Lowt5Z6wqC9z8fJYXUGS': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/2Uj5a2e9AjWG6p8SqMNCEJGKAW5QiVjtgmqGShDWYE3GY5oYWz9mzC19vPyLUmAXNuhxCN9r6TF3D6vhdYTahVUn',
// 'ed25519:Gd7v5NaL2fCwNsMdDiRiwtXBBhe9LHo1CSoRCDs1unev': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/3J744n3zT29Dc4GzrnGbdNiwMM5cZv9eJdCd6WxAbJQy48RSfMWvnzbwcn6tgBYYPYtqcEeGhxU4pVdjmCx3yBZc',
// 'ed25519:DULssBcpvFpnMQ4sPnGrpqSrqyuTnHErFTzNfJERvf7e': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/25J9zdomMM9uDttmJRefwJwSpKsv7VRccvbqym8QEUu3PnjiRhye5h8U9hUdnq7bp72x56eABLNXYaThqVNVeWnL',
// 'ed25519:3CSopDVtq4uGno5tAes3Ld1tBE8jM1qJmMTsYt86PMxy': 'https://testnet.mynearwallet.com/linkdrop/v1-4.keypom.testnet/3JPaXXbdiDr3JVXx6qR1bce2byrTbgBeVKzYCWZ7jSwuKgangetNiYG5NY4NtUzxbaV1LDLtqqDoMuvE19zNa9jb'

// OLD
// https://wallet.testnet.near.org/linkdrop/v1-3.keypom.testnet/2TJ9RbP3UtNyJGTD9EKdabavTMSJC97hcnGQjXwbC7uRPn7TZaUspoXEKzFEThgyJqatyCVung3yySQGGEBumXd2
// curPks:  [ 'ed25519:4X3TdmDCEuVg6ifBoU3v3r75XqUk6w37HiapucsQ497W' ]

'''
'''--- advanced-tutorials/ticket-app/package.json ---
{
  "name": "ticket-app",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "parcel index.html --open",
    "build": "parcel build index.html --public-url ./",
    "create-ticket-drop": "node utils/createTickDrop.js",
    "test-ticket-drop": "node utils/testTickDrop.js"
  },
  "dependencies": {
    "@keypom/core": "^1.0.0",
    "@keypom/selector": "^1.0.0",
    "parcel": "^2.6.0",
    "qrcode.react": "^3.1.0",
    "react-router-dom": "^6.8.2",
    "react-zxing": "^1.1.3"
  },
  "devDependencies": {
    "@babel/core": "~7.18.2",
    "@babel/preset-env": "~7.18.2",
    "@babel/preset-react": "~7.17.12",
    "assert": "^2.0.0",
    "buffer": "^5.5.0",
    "crypto-browserify": "^3.12.0",
    "env-cmd": "~10.1.0",
    "events": "^3.1.0",
    "https-browserify": "^1.0.0",
    "nodemon": "~2.0.16",
    "os-browserify": "^0.3.0",
    "process": "^0.11.10",
    "punycode": "^1.4.1",
    "querystring-es3": "^0.2.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "stream-browserify": "^3.0.0",
    "stream-http": "^3.2.0",
    "ts-node": "^10.8.0",
    "typescript": "^4.7.2",
    "url": "^0.11.0"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- advanced-tutorials/ticket-app/state/App.js ---
import QrCode from "../components/qrcode";
import KeyInfo from "./keyInfo";
// import "./styles.css";
import React from "react";
import { useState, useEffect } from "react";
import { BrowserRouter, Route, Routes } from 'react-router-dom';
import { Scanner } from "../components/scanner";
import "../styles.css";
import { initKeypom, formatLinkdropUrl } from "@keypom/core";
import { Near } from "@near-js/wallet-account";
import { BrowserLocalStorageKeyStore } from "@near-js/keystores-browser";

const NETWORK_ID = "testnet";
async function connectNear(privateKey, contractId){
  const myKeyStore = new BrowserLocalStorageKeyStore();
  const connectionConfig = {
     networkId: NETWORK_ID,
     keyStore: myKeyStore,
     nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
     walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
     helperUrl: `https://helper.${NETWORK_ID}.near.org`,
     explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
  };

  const nearConnection = new Near(connectionConfig);
  await initKeypom({
      near: nearConnection,
      network: NETWORK_ID,
      keypomContractId: contractId
  });
}

let contractId;
let privKey;
let qrText;
function setup() {
  // Setting contract id, priv key and link state variables.
  const urlSplit = window.location.href.split("/");

  if (urlSplit.length > 3) {
    contractId = urlSplit[3]
    privKey = urlSplit[4]
    qrText =  `${contractId}/${privKey}`
  }

  if (contractId) {
    connectNear(contractId)
  }
}

setup()

function App() {
  //state variables
  const [curUse, setCurUse] = useState(0);
  const [pubKey, setPubKey] = useState("");
  
  const homepath = `/${contractId}/${privKey}`
  const scannerpath = `/${contractId}/scanner`

  // rendering stuff
  if(curUse == 1){
    // QR code
    console.log("scenario 1, QR code")
    return (
      <div className="content">
          <Routes>
            <Route path={scannerpath} element={ <Scanner/> } />
            <Route path={homepath} element={
            <>
              <h1>🎟️This is your ticket🔑</h1>
              <h4>Screenshot and show me at the door</h4>
              <br></br>
              <QrCode link={qrText} />
              <br></br>
              <KeyInfo contractId={contractId} privKey={privKey} curUse={curUse} setCurUse={setCurUse} pubKey={pubKey} setPubKey={setPubKey} />
            </>}/>
          </Routes>
      </div>
    );
  }
  else if(curUse==2){
    // Direct user to claim POAP
    let link = formatLinkdropUrl({
      customURL: "https://testnet.mynearwallet.com/linkdrop/CONTRACT_ID/SECRET_KEY",
      secretKeys: privKey
    });
    return (
      <div className="content">
          <Routes>
            <Route path={scannerpath} element={ <Scanner/> } />
            <Route path={homepath} element={
            <>
              <h1>You're all set! Enjoy the event</h1>
              <a href={link} target="_blank" rel="noopener noreferrer"><button className="onboard_button">Claim your POAP</button></a>
              <KeyInfo contractId={contractId} privKey={privKey} curUse={curUse} setCurUse={setCurUse} pubKey={pubKey} setPubKey={setPubKey} />
            </>}/>
          </Routes>
      </div>
    );
  }
  else if(curUse==0 && !contractId && !privKey){
    // Event Landing Page
    return (
      <div className="content">
        <h1>Welcome to the Keypom Party!</h1>
          <div>Drinks are on the house tonight!</div>
          <Routes>
            <Route path={scannerpath} element={ <Scanner/> } />
            <Route path={homepath} element={  <KeyInfo contractId={contractId} privKey={privKey} curUse={curUse} setCurUse={setCurUse} pubKey={pubKey} setPubKey={setPubKey} /> }></Route>
          </Routes>
      </div>
    );
  }
  else if(curUse==0){
    // Key has been depleted, show resources for NEAR
    return (
      <div className="content">
          <Routes>
            <Route path={scannerpath} element={ <Scanner/> } />
            <Route path={homepath} element={
            <>
              <h1>Now that you have a wallet...</h1>
              <a href={"https://near.org/learn/#anker_near"} target="_blank" rel="noopener noreferrer"><button className="onboard_button">Continue your journey into NEAR</button></a>
              <KeyInfo contractId={contractId} privKey={privKey} curUse={curUse} setCurUse={setCurUse} pubKey={pubKey} setPubKey={setPubKey} />
            </>}/>
          </Routes>
      </div>
    );
  }
  
  
}

export default App
// ReactDOM.render(<AppRouter />, document.getElementById("root"));

'''
'''--- advanced-tutorials/ticket-app/state/keyInfo.js ---
import { initKeypom, getPubFromSecret, getKeyInformation, getDropInformation } from "@keypom/core";
import React from 'react'
import { useState, useEffect } from "react";

const KeyInfo = ({ contractId, privKey, curUse, setCurUse, pubKey, setPubKey }) => {
    
    // These functions will run anytime the component is re-rendered 
    useEffect(() => {
        async function getUsesRemaining(privKey){
            let tempKey = await getPubFromSecret(privKey)
            setPubKey(tempKey)
            const resKeyInfo = await getKeyInformation({publicKey: tempKey})
            if(resKeyInfo){
                setCurUse(resKeyInfo.cur_key_use)
            }
            else{
                setCurUse(0)
            }
        }
        async function main(privKey){
            await getUsesRemaining(privKey)
        }
        main(privKey)
        
    });

    if(curUse==1){
        console.log(pubKey)
        return (
            <div>
              <div>Public Key: {pubKey}</div>
              <div>Current Key Use: {curUse}</div>
            </div>
          )
    }
    else{
        console.log(curUse)
        return
    }
   
}

export default KeyInfo

'''
'''--- advanced-tutorials/ticket-app/styles.css ---
/* src/styles.css */
*,
*:before,
*:after {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
:root {
  --font-color: 230 25% 7%;
}
body {
  color: hsl(var(--font-color));
  background-color: #626262;
}
img {
  max-width: 100%;
  display: block;
  color:aqua
}
.section {
  padding: 2em 0;
  /* display: flex; */
  min-height: 100vh;
  align-items: center;
  
}
.content {
  position: absolute;
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
  transform: translate(-50%, -50%);
  text-align: center;
}

.container {
  margin-inline: auto;
  max-width: 75rem;
  width: 85%;
  /* top: 50%;
  left: 50%;
  -moz-transform: translateX(-50%) translateY(-50%);
  -webkit-transform: translateX(-50%) translateY(-50%);
  transform: translateX(-50%) translateY(-50%); */
}
.input__group {
  /* display: flex; */
  margin-top: 2em;
}
.img_center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
.button span {
  cursor: pointer;
  display: inline-block;
  position: relative;
  transition: 0.5s;
}

.button span:after {
  content: '\00bb';
  position: absolute;
  opacity: 0;
  top: 0;
  right: -20px;
  transition: 0.5s;
}

.button:hover span {
  padding-right: 25px;
}

.button:hover span:after {
  opacity: 1;
  right: 0;
}
.button:active {
  background-color: #3e8e41;
  box-shadow: 0 5px #666;
  transform: translateY(8px);
}
input {
  width: 100%;
  padding: 1em 0.75em;
  border: 1px solid #444343;
  border-radius: 3px;
  margin-bottom: 2em;
  margin-top: 0.75em;
}
.button {
  padding:0.6em 2em;
  border-radius: 8px;
  color:#fff;
  background-color:#2e7d32;
  font-size:1.1em;
  border:0;
  cursor:pointer;
  margin:1em;
  transition: all 0.5s;
}
.onboard_button {
  padding:0.6em 2em;
  border-radius: 16px;
  color:#fff;
  background-color:#8852a5;
  font-size:1.1em;
  border:0;
  cursor:pointer;
  margin:1em;
  transition: all 0.5s;
}
.onboard_button:active {
  background-color: #7d2eab;
  box-shadow: 0 5px #666;
  transform: translateY(8px);
}

@media screen and (min-width: 768px) {
  .section {
    padding: 0;
  }
  input {
    margin: 0;
  }
  .qrcode__container {
    /* display: flex; */
    align-items: center;
  }
  .input__group {
    margin-left: 3em;
  }
  input {
    margin-bottom: 2em;
    margin-top: 0.75em;
    font-size: 1rem;
  }
}
'''
'''--- advanced-tutorials/ticket-app/utils/allowEntry.js ---
const keypom = require("@keypom/core");
const {
	getPubFromSecret,
	getKeyInformation,
	hashPassword,
    claim
} = keypom

async function allowEntry({privKey, basePassword}) {
    try {
        // Check 1: Key existence
        var publicKey = getPubFromSecret(privKey)
        var keyInfo = await getKeyInformation({publicKey})
        // If key does not exist, the user should not be admitted
        if(keyInfo == null) {
            console.log(`Key does not exist. Admission denied`);
            return false;
        }

        var curUse = keyInfo.cur_key_use 

        // Ticket was already scanned
        if (curUse !== 1) {
            console.log(`Key has already been scanned. Admission denied`);
            return false;
        }

        // Create password using base + pubkey + key use as string
        let passwordForClaim = await hashPassword(basePassword + publicKey + curUse.toString())
        // Claim with created password
        await claim({
            secretKey: privKey,
            password: passwordForClaim
        })

        // Check 3: Check if claim was successful by validating that curUse incremented
        keyInfo = await getKeyInformation({publicKey})

        if (keyInfo.cur_key_use !== 2) {
            console.log(`Claim has failed, check password`)
            return false;
        }
    } catch(err) {
        console.log(`Unknown Error: ${err}. Admission denied`)
        return false;
    }

    return true
}

module.exports = {
    allowEntry
}
'''
'''--- advanced-tutorials/ticket-app/utils/createTickDrop.js ---
const path = require("path");
const homedir = require("os").homedir();
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { parseNearAmount } = require("@near-js/utils");
const { Account } = require("@near-js/accounts");
const { connect, Near } = require("@near-js/wallet-account");
var assert = require('assert');

const keypom = require("@keypom/core");
const {
	initKeypom,
	getEnv,
	createDrop,
    createNFTSeries,
    formatLinkdropUrl
} = keypom

// Change this to your account ID
const FUNDER_ACCOUNT_ID = "minqi.testnet";
const NETWORK_ID = "testnet";
async function createTickDrop() {
    // Initiate connection to the NEAR blockchain.
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);  

    let nearConfig = {
        networkId: NETWORK_ID,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
        walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
        helperUrl: `https://helper.${NETWORK_ID}.near.org`,
        explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
    };  

    let near = new Near(nearConfig);
    const fundingAccount = new Account(near.connection, FUNDER_ACCOUNT_ID)
    
    // If a NEAR connection is not passed in and is not already running, initKeypom will create a new connection
    // Here we are connecting to the testnet network
    await initKeypom({
        near,
        network: NETWORK_ID,
    });

    // Create drop with 10 keys and 2 key uses each
    let {keys, dropId} = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        config: {
            usesPerKey: 2
        },
        depositPerUseNEAR: "0.1",
        basePassword: "event-password",
        passwordProtectedUses: [1],
        fcData: {
            methods: [
                null,
                [
                    {
                        receiverId: `nft-v2.keypom.${NETWORK_ID == "mainnet" ? "near" : "testnet"}`,
                        methodName: "nft_mint",
                        args: "",
                        dropIdField: "mint_id",
                        accountIdField: "receiver_id",
                        attachedDeposit: parseNearAmount("0.1")
                    }
                ],
            ]   
        },
        useBalance: true
    })

    await createNFTSeries({
        account: fundingAccount,
        dropId,
        metadata: {
            title: "Moon NFT Ticket!",
            description: "A cool NFT POAP for the best dog in the world.",
            media: "bafybeibwhlfvlytmttpcofahkukuzh24ckcamklia3vimzd4vkgnydy7nq",
            copies: 30
        }
    }); 

    const {contractId: KEYPOM_CONTRACT} = getEnv()
    let tickets = formatLinkdropUrl({
        customURL: "http://localhost:1234/CONTRACT_ID/SECRET_KEY",
        secretKeys: keys.secretKeys,
        contractId: KEYPOM_CONTRACT,
    })
    console.log(`
    
    Ticket Links: 
    
    ${tickets}
    
    `)

    return keys
}

createTickDrop()

module.exports = {
    createTickDrop
}

'''
'''--- advanced-tutorials/ticket-app/utils/temp.js ---
const path = require("path");
const homedir = require("os").homedir();
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { parseNearAmount } = require("@near-js/utils");
const { Account } = require("@near-js/accounts");
const { Near } = require("@near-js/wallet-account");

const keypom = require("@keypom/core");
const {
  initKeypom,
  getEnv,
  createDrop,
    createNFTSeries,
    formatLinkdropUrl
} = keypom

// Change this to your account ID
const FUNDER_ACCOUNT_ID = "minqi.testnet";
const NETWORK_ID = "testnet";
async function createTickDrop() {
    // Initiate connection to the NEAR blockchain.
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

    let nearConfig = {
        networkId: NETWORK_ID,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
        walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
        helperUrl: `https://helper.${NETWORK_ID}.near.org`,
        explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
    };

    let near = new Near(nearConfig);
    const fundingAccount = new Account(near.connection, FUNDER_ACCOUNT_ID)

    // If a NEAR connection is not passed in and is not already running, initKeypom will create a new connection
    // Here we are connecting to the testnet network
    await initKeypom({
        near,
        network: NETWORK_ID,
    });

    const contractNetworkId = NETWORK_ID === "mainnet" ? "near" : NETWORK_ID;

    // ONCE SERIES IS CREATED, THIS WILL WORK
    let { keys, dropId: MAIN_DROP_ID } = await createDrop({
        account: fundingAccount,
        numKeys: 4,
        config: {
            usesPerKey: 2
        },
        depositPerUseNEAR: "0.1",
        basePassword: "event-password",
        passwordProtectedUses: [1],
        fcData: {
            methods: [
                null,
                [
                    {
                        receiverId: `nft-v2.keypom.${contractNetworkId}`,
                        methodName: "nft_mint",
                        args: "",
                        dropIdField: "mint_id",
                        accountIdField: "receiver_id",
                        attachedDeposit: parseNearAmount("0.1")
                    }
                ],
            ]
        }
    });

    // CLAIM THIS FIRST TO CREATE YOUR SERIES
    let { keys: keys2, dropId: dropId2 } = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        config: {
            usesPerKey: 1
        },
        depositPerUseNEAR: "0.1",
        fcData: {
            methods: [
                [
                    {
                        receiverId: `nft-v2.keypom.${contractNetworkId}`,
                        methodName: "create_series",
                        args: JSON.stringify({
                            // Change this token_id if it already exists -> check explorer transaction
                            mint_id: parseInt(MAIN_DROP_ID),
                            metadata: {
                                title: "Near Ukraine Guild - Rust Kyiv Meetup",
                                description: "Rust Kyiv Meetup ticket from Near Ukraine Guild, Human Guild, Brushfam",
                                media: "bafybeicmsn7aqzz7qma6fhkipu7bmfd6huopnhuil5d7nqpwsu4tqggafu",
                                copies: 4
                            }
                        }),
                        attachedDeposit: parseNearAmount("0.1")
                    }
                ],
            ]
        }
    });

    const {contractId: KEYPOM_CONTRACT} = getEnv()
    let tickets = formatLinkdropUrl({
        customURL: "https://kiskesis.github.io/ticketdrop/#/CONTRACT_ID/SECRET_KEY",
        secretKeys: keys.secretKeys,
        contractId: KEYPOM_CONTRACT,
    })
    let nfts = formatLinkdropUrl({
        // customURL: "https://wallet.near.org/linkdrop/CONTRACT_ID/SECRET_KEY",
        customURL: "https://testnet.mynearwallet.com/linkdrop/CONTRACT_ID/SECRET_KEY",
        secretKeys: keys2.secretKeys,
        contractId: KEYPOM_CONTRACT,
    })
    console.log("\nOnly scan tickets once NFT series is created by claiming the link below!!!\n\n" + tickets.join("\n") + "\n");
    console.log("\nCLAIM ME FIRST, I CREATE THE NFT SERIES:\n\n" + nfts.join("\n") + "\n");
    return keys
}

createTickDrop()

module.exports = {
    createTickDrop
}
'''
'''--- advanced-tutorials/ticket-app/utils/testTickDrop.js ---
var assert = require('assert');
const { createTickDrop } = require("./createTickDrop");
const { allowEntry } = require("./allowEntry");

async function wrongPasswordCheck() {
    let responses = [null, null]
    // Create Drop
    let keys = await createTickDrop();
    let privKey = keys.secretKeys[0];

    // Incorrect Password
    console.log("Claiming with wrong password...")
    let shouldAdmit = await allowEntry({
        privKey, 
        basePassword: "wrong-password"
    })
    assert(shouldAdmit === false, `Expected no admittance with incorrect password.`)
    responses[0] = shouldAdmit

    // Correct password
    console.log("claiming with correct password...")
    shouldAdmit = await allowEntry({
        privKey,
        basePassword: "event-password"
    })
    assert(shouldAdmit === true, `Expected admittance with correct password.`)
    responses[1] = shouldAdmit

    return responses;
}

async function doubleClaimCheck() {
    let responses = [null, null];
    // Create Drop
    let keys = await createTickDrop();
    let privKey = keys.secretKeys[0];

    // Correct Password (first claim)
    console.log("Claiming with correct password...")
    let shouldAdmit = await allowEntry({
        privKey, 
        basePassword: "event-password"
    })
    assert(shouldAdmit === true, `Expected admittance with correct password.`)
    responses[0] = shouldAdmit

    // Correct password (duplicate claim)
    console.log("claiming the same key twice...")
    shouldAdmit = await allowEntry({
        privKey,
        basePassword: "event-password"
    })
    assert(shouldAdmit === false, `Expected no admittance due to duplicate claim.`)
    responses[1] = shouldAdmit

    return responses;
}

async function tests() {
    let pwResponses = await wrongPasswordCheck();
    let dcResponses = await doubleClaimCheck();

    console.log(`
        Password Test Responses:
        Expected false, got: ${pwResponses[0]}
        Expected true, got: ${pwResponses[1]}

        Double Claim Test Responses:
        Expected true, got: ${dcResponses[0]}
        Expected false, got: ${dcResponses[1]}
    `);
}

tests()

'''
'''--- advanced-tutorials/trial-accounts/create-trial-drop-mainnet.js ---
const { initKeypom, createTrialAccountDrop } = require('@keypom/core');
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Account } = require('@near-js/accounts');
const { Near } = require("@near-js/wallet-account");
const { readFileSync } = require('fs');

require('dotenv').config()
const path = require("path");
const homedir = require("os").homedir();

const funderAccountId = "mintlu.near";
const NETWORK_ID = "mainnet";
async function createTrialAccount() {
	// Initiate connection to the NEAR blockchain.
    const CREDENTIALS_DIR = '.near-credentials';
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);  

    let nearConfig = {
        networkId: NETWORK_ID,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
        walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
        helperUrl: `https://helper.${NETWORK_ID}.near.org`,
        explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
    };  

    let near = new Near(nearConfig);
    fundingAccount = new Account(near.connection, funderAccountId);

	// Initialize the SDK and point it to the custom NEAR object that was created.
    await initKeypom({
		near,
		network: NETWORK_ID
	});

	// What contracts can the trial account call?
    const callableContracts = [
        'social.near'
    ]
    // What is the maximum amount of $NEAR that can be attached to a call for each callable contract?
    const maxAttachableNEARPerContract = [
        '1',
    ]
	// What methods can the trial account call?
	const callableMethods = [
		['*'],
	]

    const wasmDirectory = `${require('path').resolve(__dirname, '..')}/trial-accounts/ext-wasm/trial-accounts.wasm`
    const {keys} = await createTrialAccountDrop({
		account: fundingAccount,
        numKeys: 1,
        contractBytes: [...readFileSync(wasmDirectory)],
		// How much $NEAR should be made available to the trial account when it's created?
        startingBalanceNEAR: 0.25,
        callableContracts,
        callableMethods,
        maxAttachableNEARPerContract,
		// Once the trial account has spent this much $NEAR, the trial will be over.
        trialEndFloorNEAR: 0.05
    })  

    

    const nearInstance = "http://near.org/#trial-url"
    // https://near.org/#trial-url
    const keypomContractId = "v2.keypom.near"
    const delimiter = "/"
    const secretKey = keys.secretKeys[0]

    console.log(`
    
    NEAR.ORG:
 	${nearInstance}${delimiter}${keypomContractId}${delimiter}${secretKey}
    
 	Good Luck!
    `)
}

createTrialAccount();
'''
'''--- advanced-tutorials/trial-accounts/create-trial-drop.js ---
const { initKeypom, createTrialAccountDrop } = require('@keypom/core');
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Account } = require('@near-js/accounts');
const { Near } = require("@near-js/wallet-account");
const { readFileSync } = require('fs');

require('dotenv').config()
const path = require("path");
const homedir = require("os").homedir();

const funderAccountId = 'minqi.testnet';
const NETWORK_ID = 'testnet';
async function createTrialAccount() {
	// Initiate connection to the NEAR blockchain.
    const CREDENTIALS_DIR = '.near-credentials';
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);  

    let nearConfig = {
        networkId: NETWORK_ID,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
        walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
        helperUrl: `https://helper.${NETWORK_ID}.near.org`,
        explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
    };  

    let near = new Near(nearConfig);
    fundingAccount = new Account(near.connection, funderAccountId);

	// Initialize the SDK and point it to the custom NEAR object that was created.
    await initKeypom({
		near,
		network: NETWORK_ID
	});

	// What contracts can the trial account call?
    const callableContracts = [
        'guest-book.examples.keypom.testnet',
        'v1.social08.testnet'
    ]
    // What is the maximum amount of $NEAR that can be attached to a call for each callable contract?
    const maxAttachableNEARPerContract = [
        '1',
        '1'
    ]
	// What methods can the trial account call?
	const callableMethods = [
		['*'],
        ['*']
	]

    const wasmDirectory = `${require('path').resolve(__dirname, '..')}/trial-accounts/ext-wasm/trial-accounts.wasm`
    const {keys} = await createTrialAccountDrop({
		account: fundingAccount,
        numKeys: 1,
        contractBytes: [...readFileSync(wasmDirectory)],
		// How much $NEAR should be made available to the trial account when it's created?
        startingBalanceNEAR: 2.5,
        callableContracts,
        callableMethods,
        maxAttachableNEARPerContract,
		// Once the trial account has spent this much $NEAR, the trial will be over.
        trialEndFloorNEAR: 1.25
    })  

    

    const guestBookInstance = "http://localhost:1234/trial-url#"
    const keypomContractId = "v2.keypom.testnet"
    const delimiter = "/"
    const secretKey = keys.secretKeys[0]

    const alphaInstance = "http://localhost:3000/#trial-url/"

    console.log(`
    
    Guest-Book App:
 	${guestBookInstance}${keypomContractId}${delimiter}${secretKey}
    
    Alpha:
 	${alphaInstance}${keypomContractId}${delimiter}${secretKey}

 	Good Luck!
    `)
}

createTrialAccount();
'''
'''--- advanced-tutorials/trial-accounts/guest-book/App.js ---
import 'regenerator-runtime/runtime';
import React, { useState, useEffect } from 'react';
import Form from './components/Form';
import SignIn from './components/SignIn';
import Messages from './components/Messages';

const App = ({ isSignedIn, guestBook, wallet }) => {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    guestBook.getMessages().then(setMessages);
  }, []);

  onSubmit = async (e) => {
    e.preventDefault();

    const { fieldset, message, donation } = e.target.elements;

    fieldset.disabled = true;

    await guestBook.addMessage(message.value, donation.value)
    const messages = await guestBook.getMessages()

    setMessages(messages);
    message.value = '';
    donation.value = '0';
    fieldset.disabled = false;
    message.focus();
  };

  const signIn = () => { wallet.signIn() }

  const signOut = () => { wallet.signOut() }

  return (
    <main>
      <table>
        <tr>
          <td><h1>📖 NEAR Guest Book</h1></td>
          <td>{ isSignedIn
          ? <button onClick={signOut}>Log out</button>
          : <button onClick={signIn}>Log in</button>
        }</td>
        </tr>
      </table>

      <hr />
      { isSignedIn
        ? <Form onSubmit={onSubmit} currentAccountId={wallet.accountId} />
        : <SignIn/>
      }

      <hr />

      { !!messages.length && <Messages messages={messages}/> }

    </main>
  );
};

export default App;
'''
'''--- advanced-tutorials/trial-accounts/guest-book/contract.env ---
CONTRACT_NAME=guest-book.examples.keypom.testnet
'''
'''--- advanced-tutorials/trial-accounts/guest-book/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="./favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <link rel="apple-touch-icon" href="./favicon.ico" />
    <link rel="stylesheet" href="global.scss">
    <title>NEAR Guest Book</title>
    <meta property="og:title" content="NEAR Guest Book">
    <meta property="og:description" content="A guest book with comments stored on the NEAR blockchain">
    <!-- <meta property="og:image" content=""> -->
    <!-- <meta property="og:url" content=""> -->
    <!-- <meta name="twitter:card" content="summary_large_image"> -->
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.
    -->
    <script src="./index.js" type="module"></script>
  </body>
</html>

'''
'''--- advanced-tutorials/trial-accounts/guest-book/index.js ---
// React
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

// NEAR
import { GuestBook } from './near-interface';
import { Wallet } from './near-wallet';

// When creating the wallet you can choose to create an access key, so the user
// can skip signing non-payable methods when talking wth the  contract
const wallet = new Wallet({ createAccessKeyFor: process.env.CONTRACT_NAME })

// Abstract the logic of interacting with the contract to simplify your flow
const guestBook = new GuestBook({ contractId: process.env.CONTRACT_NAME, walletToUse: wallet });

// Setup on page load
window.onload = async () => {
  const isSignedIn = await wallet.startUp()
 
  ReactDOM.render(
    <App isSignedIn={isSignedIn} guestBook={guestBook} wallet={wallet} />,
    document.getElementById('root')
  );
}
'''
'''--- advanced-tutorials/trial-accounts/guest-book/keypom-data.js ---
export const KEYPOM_OPTIONS = {
  beginTrial: {
    landing: {
      title: "Create an Account",
      body: "To start, enter a username.",
      fieldPlaceholder: "Account ID",
      buttonText: "Create",
    },
    claiming: {
        title: "Creating Account",
        body: "Your account is being created. Please wait...",
    },
    claimed: {
        title: "You're all set!🎉",
        body: "Your account has been successfully created.",
        buttonText: "Continue to app"
    }
  },
  trialOver: {
    mainBody: {
      title: "Your trial has ended",
      body: "Choose a wallet provider and onboard fully into the NEAR ecosystem.",
      imageOne: {
        title: "Secure Your Digital Assets",
        body: "Now that your trial is over, secure your account with an official wallet provider!"
      },
      imageTwo: {
        title: "Log In to Any NEAR App",
        body: "Once your account is secured, you can use any app on NEAR!"
      }
    },
    offboardingOptions: {
      title: "Choose a Wallet",
    }
  },
  invalidAction: {
    title: "Invalid Action",
    body: "Your trial does not allow you to perform this action. For more information, please contact the site administrator."
  },
  insufficientBalance: {
    title: "Insufficient Balance",
    body: "Your account does not have enough balance for the action you are trying to perform. Please try again with a different action. For more information, please contact the site administrator."
  },
  wallets: [
    {
      name: "MyNEARWallet",
      description: "Secure your account with a Seed Phrase",
      redirectUrl: "https://localhost:1234/linkdrop/ACCOUNT_ID/SECRET_KEY",
      iconUrl: "data:image/png;base64,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"
    },
    {
      name: "FastAuth",
      description: "Secure your account with Biometrics",
      redirectUrl: "https://www.youtube.com/watch?v=dQw4w9WgXcQ#SECRET_KEY/ACCOUNT_ID",
      iconUrl: "data:image/png;base64,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"
    }
  ]
}
'''
'''--- advanced-tutorials/trial-accounts/guest-book/near-interface.js ---
/* Talking with a contract often involves transforming data, we recommend you to encapsulate that logic into a class */

import { utils } from 'near-api-js';

export class GuestBook {

  constructor({ contractId, walletToUse }) {
    this.contractId = contractId;
    this.wallet = walletToUse
  }

  async getMessages() {
    let totalMessages = await this.wallet.viewMethod({ contractId: this.contractId, method: "total_messages" });
    const messagesPerPage = 5;
    const messages = await this.wallet.viewMethod({ contractId: this.contractId, method: "get_messages", args: {limit: messagesPerPage, from_index: (totalMessages - messagesPerPage)} })
    console.log(messages)
    return messages
  }

  async addMessage(message, donation) {
    const deposit = utils.format.parseNearAmount(donation);
    return await this.wallet.callMethod({ contractId: this.contractId, method: "add_message", args: { text: message }, deposit });
  }

}
'''
'''--- advanced-tutorials/trial-accounts/guest-book/near-wallet.js ---
/* A helper file that simplifies using the wallet selector */

// near api js

// wallet selector UI
import '@near-wallet-selector/modal-ui/styles.css';
import MyNearIconUrl from '@near-wallet-selector/my-near-wallet/assets/my-near-wallet-icon.png';

// wallet selector options
import { setupWalletSelector } from '@near-wallet-selector/core';
import { setupKeypom } from '@keypom/selector';
import { JsonRpcProvider } from '@near-js/providers';
import {
  getTransactionLastResult,
} from '@near-js/utils';
import { setupMyNearWallet } from '@near-wallet-selector/my-near-wallet';
import { setupModal } from '@near-wallet-selector/modal-ui';
import { KEYPOM_OPTIONS } from './keypom-data';

const THIRTY_TGAS = '30000000000000';
const NO_DEPOSIT = '0';

// Wallet that simplifies using the wallet selector
export class Wallet {
  walletSelector;
  wallet;
  network;
  createAccessKeyFor;

  constructor({ createAccessKeyFor = undefined, network = 'testnet' }) {
    // Login to a wallet passing a contractId will create a local
    // key, so the user skips signing non-payable transactions.
    // Omitting the accountId will result in the user being
    // asked to sign all transactions.
    this.createAccessKeyFor = createAccessKeyFor
    this.network = network
  }

  // To be called when the website loads
  async startUp() {
    this.walletSelector = await setupWalletSelector({
      network: this.network,
      modules: [
        setupMyNearWallet({ iconUrl: MyNearIconUrl }),
        setupKeypom({ 
          networkId: this.network, 
          signInContractId: this.createAccessKeyFor,
          trialAccountSpecs: {
            url: "http://localhost:1234/trial-url#ACCOUNT_ID/SECRET_KEY",
            modalOptions: KEYPOM_OPTIONS
          },
          instantSignInSpecs: {
            url: "http://localhost:1234/instant-url#ACCOUNT_ID/SECRET_KEY/MODULE_ID",
          }
        })
      ],
    });

    const isSignedIn = this.walletSelector.isSignedIn();

    if (isSignedIn) {
      this.wallet = await this.walletSelector.wallet();
      this.accountId = this.walletSelector.store.getState().accounts[0].accountId;
    }

    return isSignedIn;
  }
  
  // Sign-in method
  signIn() {
    const description = 'Please select a wallet to sign in.';
    const modal = setupModal(this.walletSelector, { contractId: this.createAccessKeyFor, description });
    modal.show();
  }

  // Sign-out method
  signOut() {
    this.wallet.signOut();
    this.wallet = this.accountId = this.createAccessKeyFor = null;
    window.location.replace(window.location.origin + window.location.pathname);
  }

  // Make a read-only call to retrieve information from the network
  async viewMethod({ contractId, method, args = {} }) {
    const { network } = this.walletSelector.options;
    const provider = new JsonRpcProvider({ url: network.nodeUrl });

    let res = await provider.query({
      request_type: 'call_function',
      account_id: contractId,
      method_name: method,
      args_base64: Buffer.from(JSON.stringify(args)).toString('base64'),
      finality: 'optimistic',
    });
    return JSON.parse(Buffer.from(res.result).toString());
  }

  // Call a method that changes the contract's state
  async callMethod({ contractId, method, args = {}, gas = THIRTY_TGAS, deposit = NO_DEPOSIT }) {
    // Sign a transaction with the "FunctionCall" action
    const outcome = await this.wallet.signAndSendTransaction({
      signerId: this.accountId,
      receiverId: contractId,
      actions: [
        {
          type: 'FunctionCall',
          params: {
            methodName: method,
            args,
            gas,
            deposit,
          },
        },
      ],
    });

    return getTransactionLastResult(outcome)
  }

  // Get transaction result from the network
  async getTransactionResult(txhash) {
    const { network } = this.walletSelector.options;
    const provider = new JsonRpcProvider({ url: network.nodeUrl });

    // Retrieve transaction result from the network
    const transaction = await provider.txStatus(txhash, 'unnused');
    return getTransactionLastResult(transaction);
  }
}
'''
'''--- advanced-tutorials/trial-accounts/guest-book/package.json ---
{
  "name": "guest-book-keypom-demo",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "start": "rm -rf .parcel-cache && ./start.sh"
  },
  "devDependencies": {
    "@babel/core": "^7.18.2",
    "@babel/preset-env": "^7.18.2",
    "@babel/preset-react": "^7.17.12",
    "@parcel/transformer-sass": "^2.8.0",
    "@types/node": "^18.6.2",
    "buffer": "^5.5.0",
    "crypto-browserify": "^3.12.0",
    "env-cmd": "^10.1.0",
    "https-browserify": "^1.0.0",
    "nodemon": "^2.0.16",
    "parcel": "^2.6.0",
    "path-browserify": "^1.0.1",
    "process": "^0.11.10",
    "punycode": "^1.4.1",
    "querystring-es3": "^0.2.1",
    "react-test-renderer": "^18.1.0",
    "stream-browserify": "^3.0.0",
    "stream-http": "^3.1.0",
    "ts-node": "^10.8.0",
    "typescript": "^4.7.2",
    "url": "^0.11.0",
    "util": "^0.12.5"
  },
  "dependencies": {
    "@near-wallet-selector/core": "^7.9.1",
    "@near-wallet-selector/ledger": "^7.9.1",
    "@near-wallet-selector/math-wallet": "^7.9.1",
    "@near-wallet-selector/meteor-wallet": "^7.9.1",
    "@near-wallet-selector/modal-ui": "^7.9.1",
    "@near-wallet-selector/my-near-wallet": "^7.9.1",
    "@near-wallet-selector/near-wallet": "^7.9.1",
    "@near-wallet-selector/nightly": "^7.9.1",
    "@near-wallet-selector/nightly-connect": "^7.9.1",
    "@near-wallet-selector/sender": "^7.9.1",
    "@near-wallet-selector/wallet-connect": "^7.9.1",
    "near-api-js": "^0.44.2",
    "prop-types": "^15.8.1",
    "react": "^18.1.0",
    "react-dom": "^18.1.0",
    "regenerator-runtime": "^0.13.9"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- advanced-tutorials/trial-accounts/guest-book/start.sh ---
#!/bin/sh

GREEN='\033[1;32m'
NC='\033[0m' # No Color

CONTRACT_ACCOUNT_FILE="contract.env"

start () {
  echo The app is starting!
  env-cmd -f $CONTRACT_ACCOUNT_FILE parcel index.html --open
}

alert () {
  echo "======================================================"
  echo "It looks like you forgot to deploy your contract"
  echo ">> Run ${GREEN}'npm run deploy'${NC} from the 'root' directory"
  echo "======================================================"
}

if [ -f "$CONTRACT_ACCOUNT_FILE" ]; then
  start
else
  alert
fi

'''
'''--- basic-tutorials/function-call-drop/fc-example.js ---
const { initKeypom, createDrop, getEnv, formatLinkdropUrl } = require("@keypom/core"); 
const { parseNearAmount } = require("@near-js/utils");
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Near } = require("@near-js/wallet-account");
const { Account } = require("@near-js/accounts");
const path = require("path");
const homedir = require("os").homedir();

async function fcDropKeypom(){
	// Initiate connection to the NEAR blockchain.
	const network = "testnet"
	const CREDENTIALS_DIR = ".near-credentials";
	const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);
	const YOUR_ACCOUNT = "keypom-docs-demo.testnet";
	const NFT_TOKEN_ID = "keypom-token-" + Date.now().toString();
	const NFT_CONTRACT = "nft.examples.testnet";
	
	let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

	let nearConfig = {
	    networkId: network,
	    keyStore: keyStore,
	    nodeUrl: `https://rpc.${network}.near.org`,
	    walletUrl: `https://wallet.${network}.near.org`,
	    helperUrl: `https://helper.${network}.near.org`,
	    explorerUrl: `https://explorer.${network}.near.org`,
	};

	let near = new Near(nearConfig);
	const fundingAccount = new Account(near.connection, YOUR_ACCOUNT);

	// If a NEAR connection is not passed in and is not already running, initKeypom will create a new connection
	// Here we are connecting to the testnet network
	await initKeypom({
	    near,
	    network
	});

	// Note that the SDK does error checks to ensure all the information passed in will succeed when creating a drop.
	// If any information is not valid, the SDK will panic and the drop will NOT be created.
	// These checks include, but are not limited to, valid configurations, enough attached deposit, and drop existence.
	const {keys} = await createDrop({
	    account: fundingAccount,
	    numKeys: 1,
	    depositPerUseNEAR: "1",
		// With our function call for this drop, we wish to allow the user to lazy mint an NFT
	    fcData: {
		// 2D array of function calls. In this case, there is 1 function call to make for a key use
		// By default, if only one array of methods is present, this array of function calls will be used for all key uses
		methods: [
			// Array of functions for Key use 1. 
		    [{
		    	receiverId: NFT_CONTRACT,
		    	methodName: "nft_mint",
		    	args: JSON.stringify({
					// Change this token_id if it already exists -> check explorer transaction
		    	    token_id: NFT_TOKEN_ID,
		    	    metadata: {
		    	        title: "My Keypom NFT",
		    	        description: "Keypom is lit fam",
		    	        media: "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
		    	    }
		    	}),
				accountIdField: "receiver_id",
		    	// Attached deposit of 1 $NEAR for when the receiver makes this function call
		    	attachedDeposit: parseNearAmount("1")
		    }]
		]
	    },
	});
	pubKeys = keys.publicKeys

    const {contractId: KEYPOM_CONTRACT} = getEnv()
    // Creating list of pk's and linkdrops; copied from orignal simple-create.js
	let linkdropUrl = formatLinkdropUrl({
		customURL: "https://testnet.mynearwallet.com/linkdrop/CONTRACT_ID/SECRET_KEY",
		secretKeys: keys.secretKeys,
		contractId: KEYPOM_CONTRACT
	})
	// Write file of all pk's and their respective linkdrops
	console.log('Public Keys: ', pubKeys)
	console.log('Linkdrops: ', linkdropUrl)
	console.log(`Keypom Contract Explorer Link: explorer.${network}.near.org/accounts/${KEYPOM_CONTRACT}.com`)

}
fcDropKeypom()
'''
'''--- basic-tutorials/function-call-drop/fc-near-example.js ---
const { parseNearAmount } = require("@near-js/utils");
const { KeyPair } = require("@near-js/crypto")
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Near } = require("@near-js/wallet-account");
const { Account } = require("@near-js/accounts");
const path = require("path");
const homedir = require("os").homedir();

async function fcDropNear(){
	// Initiate connection to the NEAR blockchain.
	const network = "testnet"
	const CREDENTIALS_DIR = ".near-credentials";
	const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);
	const YOUR_ACCOUNT = "keypom-docs-demo.testnet";
	const NFT_TOKEN_ID = "near-api-token-" + Date.now().toString();
	const NFT_CONTRACT = "nft.examples.testnet";
	const KEYPOM_CONTRACT = "v2.keypom.testnet"

	let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

	let nearConfig = {
	    networkId: network,
	    keyStore: keyStore,
	    nodeUrl: `https://rpc.${network}.near.org`,
	    walletUrl: `https://wallet.${network}.near.org`,
	    helperUrl: `https://helper.${network}.near.org`,
	    explorerUrl: `https://explorer.${network}.near.org`,
	};

	let near = new Near(nearConfig);
	const fundingAccount = new Account(near.connection, YOUR_ACCOUNT);

	// Keep track of an array of the keyPairs we create and the public keys to pass into the contract
	let keyPairs = [];
	let pubKeys = [];
	// Generate keypairs and store them into the arrays defined above
	let keyPair = await KeyPair.fromRandom('ed25519'); 
	keyPairs.push(keyPair);   
	pubKeys.push(keyPair.publicKey.toString());   

	// Create FC drop with pubkkeys from above and fc data
	// Note that the user is responsible for error checking when using NEAR-API-JS
	// The SDK automatically does error checking; ensuring valid configurations, enough attached deposit, drop existence etc.
	try {
		// With our function call for this drop, we wish to allow the user to lazy mint an NFT
		await fundingAccount.functionCall({
			contractId: KEYPOM_CONTRACT, 
			methodName: 'create_drop', 
			args: {
				public_keys: pubKeys,
				deposit_per_use: parseNearAmount("0.1"),
				fc: {
					// 2D array of function calls. In this case, there is 1 function call to make for a key use
					// By default, if only one array of methods is present, this array of function calls will be used for all key uses
				    methods: [
				    	// Array of functions for Key use 1. 
				    	[{
				    	    receiver_id: NFT_CONTRACT,
				    	    method_name: "nft_mint",
				    	    args: JSON.stringify({
	                		        token_id: NFT_TOKEN_ID,
	                		        metadata: {
				    	            title: "My Keypom NFT",
				    	            description: "Keypom is lit fam",
				    	            media: "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
				    	        }
				    	    }),
							account_id_field: "receiver_id",
				    	    // Attached deposit of 1 $NEAR for when the receiver makes this function call
				    	    attached_deposit: parseNearAmount("1"),
				    	}]
				    ]
				}
			}, 
			gas: "300000000000000",
			// Attcned depot of 1.5 $NEAR for creating the drop
			attachedDeposit: parseNearAmount("1.5")
		});
	} catch(e) {
		console.log('error creating drop: ', e);
	}

	var dropInfo = {};
    	// Creating list of pk's and linkdrops; copied from orignal simple-create.js
    	for(var i = 0; i < keyPairs.length; i++) {
		// For keyPairs.length > 1, change URL secret key to keyPair.secretKey[i]
	    let linkdropUrl = `https://testnet.mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keyPair.secretKey}`;
	    dropInfo[pubKeys[i]] = linkdropUrl;
	}
	// Write file of all pk's and their respective linkdrops
	console.log('Public Keys and Linkdrops: ', dropInfo)
	console.log(`Keypom Contract Explorer Link: explorer.${network}.near.org/accounts/${KEYPOM_CONTRACT}.com`)
}
fcDropNear()

'''
'''--- basic-tutorials/fungible-token-drop/ft-example.js ---
const { initKeypom, createDrop, getEnv, formatLinkdropUrl } = require("@keypom/core");
const { parseNearAmount } = require("@near-js/utils");
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Near } = require("@near-js/wallet-account");
const { Account } = require("@near-js/accounts");
const { BN } = require("bn.js");
const path = require("path");
const homedir = require("os").homedir();

async function ftDropKeypom(){
	// Initiate connection to the NEAR testnet blockchain.
	const network = "testnet"
	const CREDENTIALS_DIR = ".near-credentials";
	const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);
	const YOUR_ACCOUNT = "keypom-docs-demo.testnet";
	const FT_CONTRACT = "ft.keypom.testnet";

	let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

	let nearConfig = {
	    networkId: network,
	    keyStore: keyStore,
	    nodeUrl: `https://rpc.${network}.near.org`,
	    walletUrl: `https://wallet.${network}.near.org`,
	    helperUrl: `https://helper.${network}.near.org`,
	    explorerUrl: `https://explorer.${network}.near.org`,
	};

	let near = new Near(nearConfig);
	const fundingAccount = await new Account(near.connection, YOUR_ACCOUNT);

	// Get amount of FTs to transfer. In this scenario, we've assumed it to be 1 for one single use key.
	let amountToTransfer = parseNearAmount("1")
	let funderFungibleTokenBal = await fundingAccount.viewFunction({
		contractId: FT_CONTRACT, 
		methodName: 'ft_balance_of',
		args: {
			account_id: YOUR_ACCOUNT
		}
	});

	// Check if the owner has enough FT balance to fund drop
	if (new BN(funderFungibleTokenBal).lte(new BN(amountToTransfer))){
		throw new Error('funder does not have enough Fungible Tokens for this drop. Top up and try again.');
	}

	// Initiate Keypom, while passing in the existing NEAR testnet connection so it does not create a new one
	await initKeypom({
	    near,
	    network,
	});

	// Creates the FT drop based on data from config file. Keys are automatically generated within the function based on `NUM_KEYS`. Since there is no entropy, all keys are completely random.
	// Note that the SDK does error checks to ensure all the information passed in will succeed when creating a drop.
	// If any information is not valid, the SDK will panic and the drop will NOT be created.
	// These checks include, but are not limited to, valid configurations, enough attached deposit, and drop existence.
	const { keys } = await createDrop({
	    account: fundingAccount,
	    numKeys: 1,
	    depositPerUseNEAR: 1,
	    ftData: {
	    	contractId: FT_CONTRACT,
	    	senderId: YOUR_ACCOUNT,
	    	// This balance per use is balance of human readable FTs per use. 
	    	amount: "1"
			// Alternatively, you could use absoluteAmount, which is dependant on the decimals value of the FT
			// ex. if decimals of an ft = 8, then 1 FT token would be absoluteAmount = 100000000
	    },
	});
	pubKeys = keys.publicKeys

    const {contractId: KEYPOM_CONTRACT} = getEnv()
    // Creating list of pk's and linkdrops; copied from orignal simple-create.js
	let linkdropUrl = formatLinkdropUrl({
		customURL: "https://testnet.mynearwallet.com/linkdrop/CONTRACT_ID/SECRET_KEY",
		secretKeys: keys.secretKeys,
		contractId: KEYPOM_CONTRACT
	})
	// Write file of all pk's and their respective linkdrops
	console.log('Public Keys: ', pubKeys)
	console.log('Linkdrops: ', linkdropUrl)
	console.log(`Keypom Contract Explorer Link: explorer.${network}.near.org/accounts/${KEYPOM_CONTRACT}.com`)
	// Note that Keypom createDrop will auto-register you onto the contract if you are not yet registered.
}

ftDropKeypom()
'''
'''--- basic-tutorials/fungible-token-drop/ft-near-example.js ---
const { parseNearAmount } = require("@near-js/utils");
const { KeyPair } = require("@near-js/crypto")
const { Near } = require("@near-js/wallet-account");
const { Account } = require("@near-js/accounts");
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { getRecentDropId } = require("../utils/general.js")
const { BN } = require("bn.js");
const path = require("path");
const homedir = require("os").homedir();

async function ftDropNear(){
	// Initiate connection to the NEAR testnet blockchain.
	const network = "testnet"
	const CREDENTIALS_DIR = ".near-credentials";
	const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);
	const YOUR_ACCOUNT = "keypom-docs-demo.testnet";
	const FT_CONTRACT = "ft.keypom.testnet";
	const KEYPOM_CONTRACT = "v2.keypom.testnet";

	let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

	let nearConfig = {
	    networkId: network,
	    keyStore: keyStore,
	    nodeUrl: `https://rpc.${network}.near.org`,
	    walletUrl: `https://wallet.${network}.near.org`,
	    helperUrl: `https://helper.${network}.near.org`,
	    explorerUrl: `https://explorer.${network}.near.org`,
	};

	let near = new Near(nearConfig);
	const fundingAccount = new Account(near.connection, YOUR_ACCOUNT);

	// Get amount of FTs to transfer. In this scenario, we've assumed it to be 1 for one single use key.
	let amountToTransfer = parseNearAmount("1")
	let funderFungibleTokenBal = await fundingAccount.viewFunction({
		contractId: FT_CONTRACT, 
		methodName: 'ft_balance_of',
		args: {
			account_id: YOUR_ACCOUNT
		}
	});

	// Check if the owner has enough FT balance to fund drop
	if (new BN(funderFungibleTokenBal).lte(new BN(amountToTransfer))){
		throw new Error('funder does not have enough Fungible Tokens for this drop. Top up and try again.');
	}

	// Keep track of an array of the keyPairs we create and public keys to pass into the contract
	let keyPairs = [];
	let pubKeys = [];
	// Generate keypairs and store them in the arrays defined above
	let keyPair = await KeyPair.fromRandom('ed25519'); 
	keyPairs.push(keyPair);   
	pubKeys.push(keyPair.publicKey.toString());   

	// Create drop with FT data
	// Note that the user is responsible for error checking when using NEAR-API-JS
	// The SDK automatically does error checking; ensuring valid configurations, enough attached deposit, drop existence etc.
	try {
		await fundingAccount.functionCall({
			contractId: KEYPOM_CONTRACT, 
			methodName: 'create_drop', 
			args: {
				public_keys: pubKeys,
				deposit_per_use: parseNearAmount("1"),
				ft: {
					contract_id: FT_CONTRACT,
					sender_id: YOUR_ACCOUNT,
					// This balance per use is balance of FTs per use. 
					// parseNearAmount is used for conveience to convert to 10^24
					balance_per_use: parseNearAmount("1")
				}
			}, 
			gas: "300000000000000",
			// Attached deposit of 1.5 $NEAR
			attachedDeposit: parseNearAmount("1.5")
		});
	} catch(e) {
		console.log('error creating drop: ', e);
	}

	// Pay storage deposit and trasnfer FTs to Keypom contract.
	try {
		await fundingAccount.functionCall({
			contractId: FT_CONTRACT, 
			methodName: 'storage_deposit',
			args: {
				account_id: YOUR_ACCOUNT,
			},
			gas: "300000000000000",
			// We are using 0.1 $NEAR to pay the storage deposit to include our account ID in their registered list of users. 
			// Realistically, this will be more than enough and will be refunded the excess
			attachedDeposit: parseNearAmount("0.1")
		});

		// Get the drop ID of the drop that we just created. This is for the message in the NFT transfer
		let dropId = await getRecentDropId(fundingAccount, YOUR_ACCOUNT, KEYPOM_CONTRACT);
		
		console.log(dropId)
		await fundingAccount.functionCall({
			contractId: FT_CONTRACT, 
			methodName: 'ft_transfer_call', 
			args: {
				receiver_id: KEYPOM_CONTRACT,
				amount: (amountToTransfer.toString()),				
				msg: dropId.toString()
			},
			gas: "300000000000000",
			attachedDeposit: "1"
		});
	} catch(e) {
		console.log('error sending FTs', e);
	}
	var dropInfo = {};
    	// Creating list of pk's and linkdrops; copied from orignal simple-create.js
    	for(var i = 0; i < keyPairs.length; i++) {
		// For keyPairs.length > 1, change URL secret key to keyPair.secretKey[i]
	    let linkdropUrl = `https://testnet.mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keyPair.secretKey}`;
	    dropInfo[pubKeys[i]] = linkdropUrl;
	}
	// Write file of all pk's and their respective linkdrops
	console.log('Public Keys and Linkdrops: ', dropInfo)
	console.log(`Keypom Contract Explorer Link: explorer.${network}.near.org/accounts/${KEYPOM_CONTRACT}.com`)
}
ftDropNear()
'''
'''--- basic-tutorials/non-fungible-token-drop/nft-example.js ---
const { parseNearAmount } = require("@near-js/utils");
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Near } = require("@near-js/wallet-account");
const { Account } = require("@near-js/accounts");
const { initKeypom, createDrop, getEnv, formatLinkdropUrl } = require("@keypom/core");

const path = require("path");
const homedir = require("os").homedir();

async function nftDropKeypom(){
	// Initiate connection to NEAR testnet blockchain
	const network = "testnet"
	const CREDENTIALS_DIR = ".near-credentials";
	const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);
	const YOUR_ACCOUNT = "minqi.testnet";
	const NFT_TOKEN_ID = "keypom-token-" + Date.now().toString();
	const NFT_CONTRACT = "nft.examples.testnet";

	let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

	let nearConfig = {
	    networkId: network,
	    keyStore: keyStore,
	    nodeUrl: `https://rpc.${network}.near.org`,
	    walletUrl: `https://wallet.${network}.near.org`,
	    helperUrl: `https://helper.${network}.near.org`,
	    explorerUrl: `https://explorer.${network}.near.org`,
	};

	let near = new Near(nearConfig);
	const fundingAccount = new Account(near.connection, YOUR_ACCOUNT);

	// Mint 1 NFT for the funder from the NFT contract outlined in the NFT_DATA
	await fundingAccount.functionCall({
		contractId: NFT_CONTRACT, 
		methodName: 'nft_mint', 
		args: {
			receiver_id: YOUR_ACCOUNT,
			metadata: {
			    title: "My First Keypom NFT",
			    description: "NFT from my first NFT Drop!",
			    media: "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
			},
			token_id: NFT_TOKEN_ID,
		},
		gas: "300000000000000",
		// Cost to cover storage of NFT
		attachedDeposit: parseNearAmount("0.1")
	});

	// Initiate Keypom using existing NEAR testnet connection
	await initKeypom({
	    near,
		network,
	});

	// Create drop with nft data
	// Note that the SDK does error checks to ensure all the information passed in will succeed when creating a drop.
	// If any information is not valid, the SDK will panic and the drop will NOT be created.
	// These checks include, but are not limited to, valid configurations, enough attached deposit, and drop existence.
	const { keys } = await createDrop({
	    account: fundingAccount,
	    numKeys: 1,
	    depositPerUseNEAR: "1",
	    nftData: {
		    // NFT Contract Id that the tokens will come from
		    contractId: NFT_CONTRACT,
		    // Who will be sending the NFTs to the Keypom contract
		    senderId: YOUR_ACCOUNT,
		    // List of tokenIDs
		    tokenIds: [NFT_TOKEN_ID]
		}
	});
	pubKeys = keys.publicKeys

    const {contractId: KEYPOM_CONTRACT} = getEnv()
    // Creating list of pk's and linkdrops; copied from orignal simple-create.js
	let linkdropUrl = formatLinkdropUrl({
		customURL: "https://testnet.mynearwallet.com/linkdrop/CONTRACT_ID/SECRET_KEY",
		secretKeys: keys.secretKeys,
		contractId: KEYPOM_CONTRACT
	})
	// Write file of all pk's and their respective linkdrops
	console.log('Public Keys: ', pubKeys)
	console.log('Linkdrops: ', linkdropUrl)
	console.log(`Keypom Contract Explorer Link: explorer.${network}.near.org/accounts/${KEYPOM_CONTRACT}.com`)

}
nftDropKeypom()
'''
'''--- basic-tutorials/non-fungible-token-drop/nft-near-example.js ---
const { parseNearAmount } = require("@near-js/utils");
const { KeyPair } = require("@near-js/crypto")
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Near } = require("@near-js/wallet-account");
const { Account } = require("@near-js/accounts");
const { getRecentDropId } = require("../utils/general.js")
const path = require("path");
const homedir = require("os").homedir();

async function nftDropNear(){
	// Initiate connection to the NEAR testnet blockchain.
	const network = "testnet"
	const CREDENTIALS_DIR = ".near-credentials";
	const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);
	const YOUR_ACCOUNT = "keypom-docs-demo.testnet";
	const NFT_TOKEN_ID = "near-api-token-" + Date.now().toString();
	const NFT_CONTRACT = "nft.examples.testnet";
	const KEYPOM_CONTRACT = "v2.keypom.testnet";
	
	let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);
	
	let nearConfig = {
	    networkId: network,
	    keyStore: keyStore,
	    nodeUrl: `https://rpc.${network}.near.org`,
	    walletUrl: `https://wallet.${network}.near.org`,
	    helperUrl: `https://helper.${network}.near.org`,
	    explorerUrl: `https://explorer.${network}.near.org`,
	};
	
	let near = new Near(nearConfig);
	const fundingAccount = new Account(near.connection, YOUR_ACCOUNT);
	
	// Mint 1 NFT for the funder from the NFT contract outlined in the NFT_DATA
	await fundingAccount.functionCall({
		contractId: NFT_CONTRACT, 
		methodName: 'nft_mint', 
		args: {
			receiver_id: YOUR_ACCOUNT,
			metadata: {
			    title: "My Keypom NFT",
			    description: "Keypom is lit fam :D",
			    media: "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
			},
			token_id: NFT_TOKEN_ID,
		},
		gas: "300000000000000",
		// Attached deposit of 0.1 $NEAR
		attachedDeposit: parseNearAmount("0.1")
	});
	
	// Keep track of an array of the key pairs we create and the public keys we pass into the contract
	let keyPairs = [];
	let pubKeys = [];
	// Generate keypairs and store them into the arrays defined above
	let keyPair = await KeyPair.fromRandom('ed25519'); 
	keyPairs.push(keyPair);   
	pubKeys.push(keyPair.publicKey.toString());   
	
	// Create drop with NFT data and transfer NFTs to Keypom
	// Note that the user is responsible for error checking when using NEAR-API-JS
	// The SDK automatically does error checking; ensuring valid configurations, enough attached deposit, drop existence etc.
	try {
		await fundingAccount.functionCall({
			contractId: KEYPOM_CONTRACT, 
			methodName: 'create_drop', 
			args: {
				public_keys: pubKeys,
				deposit_per_use: parseNearAmount("1"),
				nft: {
					// Who will be sending the NFTs to the Keypom contract
					sender_id: YOUR_ACCOUNT,
					// NFT Contract Id that the tokens will come from
					contract_id: NFT_CONTRACT
				}
			}, 
			gas: "300000000000000",
			// Attached deposit of 1 $NEAR
			attachedDeposit: parseNearAmount("1")
		});
		
		// Get the drop ID of the drop that we just created. This is for the message in the NFT transfer
		let dropId = await getRecentDropId(fundingAccount, YOUR_ACCOUNT, KEYPOM_CONTRACT);
		
		// Transfer the NFT to the Keypom contract. 
		// This gives Keypom the ownership and thus the ability to give it to the recipient when they use the linkdrop
		await fundingAccount.functionCall({
			contractId: NFT_CONTRACT, 
			methodName: 'nft_transfer_call', 
			args: {
				receiver_id: KEYPOM_CONTRACT,
				token_id: NFT_TOKEN_ID,
				msg: dropId.toString()
			},
			gas: "300000000000000",
			// Attached deposit of 1 $NEAR
			attachedDeposit: "1"
		});
	} catch(e) {
		console.log('error creating drop: ', e);
	}
	var dropInfo = {};
    	// Creating list of pk's and linkdrops; copied from orignal simple-create.js
    	for(var i = 0; i < keyPairs.length; i++) {
		// For keyPairs.length > 1, change URL secret key to keyPair.secretKey[i]
	    let linkdropUrl = `https://testnet.mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keyPair.secretKey}`;
	    dropInfo[pubKeys[i]] = linkdropUrl;
	}
	// Write file of all pk's and their respective linkdrops
	console.log('Public Keys and Linkdrops: ', dropInfo)
	console.log(`Keypom Contract Explorer Link: explorer.${network}.near.org/accounts/${KEYPOM_CONTRACT}.com`)
}

nftDropNear()
'''
'''--- basic-tutorials/package.json ---
{
  "name": "keypom-js",
  "version": "0.0.14",
  "description": "Keypom JS SDK",
  "main": "./lib/index.js",
  "scripts": {
    "test": "yarn build && yarn ava",
    "ava": "ava test/ws.test.js -vs --timeout=5m",
    "build": "npx tsc",
    "publish": "npx tsc && npm publish",
    "fc-keypom": "node keypom-js-sdk/fc-example.js",
    "ft-keypom": "node keypom-js-sdk/ft-example.js",
    "nft-keypom": "node keypom-js-sdk/nft-example.js",
    "simple-keypom": "node keypom-js-sdk/simple-example.js",
    "fc-near": "node near-api-js/fc-near-example.js",
    "ft-near": "node near-api-js/ft-near-example.js",
    "nft-near": "node near-api-js/nft-near-example.js",
    "simple-near": "node near-api-js/simple-near-example.js",
    "testing-import" : "node near-api-js/testing.js"

  },
  "author": "mattlockyer",
  "license": "MIT",
  "dependencies": {
    "keypom-js": "^1.4.9"
  },
  "ava": {
    "require": [
      "dotenv/config"
    ]
  }
}

'''
'''--- basic-tutorials/simple-drop/simple-example.js ---
const { initKeypom, createDrop, getEnv, formatLinkdropUrl } = require("@keypom/core");
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { connect, Near } = require("@near-js/wallet-account");

const path = require("path");
const homedir = require("os").homedir();

async function simpleDropKeypom(){
	// Initiate connection to the NEAR blockchain.
	const network = "testnet"
	const CREDENTIALS_DIR = ".near-credentials";
	const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);
	const YOUR_ACCOUNT = "minqi.testnet";
	
	let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

	let nearConfig = {
	    networkId: network,
	    keyStore: keyStore,
	    nodeUrl: `https://rpc.${network}.near.org`,
	    walletUrl: `https://wallet.${network}.near.org`,
	    helperUrl: `https://helper.${network}.near.org`,
	    explorerUrl: `https://explorer.${network}.near.org`,
	};

	let near = new Near(nearConfig);
	const fundingAccount = await near.account(YOUR_ACCOUNT);

	// If a NEAR connection is not passed in and is not already running, initKeypom will create a new connection
	// Here we are connecting to the testnet network
	await initKeypom({
	    near,
	    network
	});

	// Note that the SDK does error checks to ensure all the information passed in will succeed when creating a drop.
	// If any information is not valid, the SDK will panic and the drop will NOT be created.
	// These checks include, but are not limited to, valid configurations, enough attached deposit, and drop existence.
	const {keys} = await createDrop({
	    account: fundingAccount,
	    numKeys: 2,
		config:{
			usesPerKey: 5
		},
	    depositPerUseNEAR: "0.1",
	});
	pubKeys = keys.publicKeys
	
	const {contractId: KEYPOM_CONTRACT} = getEnv()
    // Creating list of pk's and linkdrops; copied from orignal simple-create.js
	let linkdropUrl = formatLinkdropUrl({
		customURL: "https://testnet.mynearwallet.com/linkdrop/CONTRACT_ID/SECRET_KEY",
		secretKeys: keys.secretKeys,
		contractId: KEYPOM_CONTRACT
	})
	// Write file of all pk's and their respective linkdrops
	console.log('Public Keys: ', pubKeys)
	console.log('Linkdrops: ', linkdropUrl)
	console.log(`Keypom Contract Explorer Link: explorer.${network}.near.org/accounts/${KEYPOM_CONTRACT}.com`)

}

simpleDropKeypom()
'''
'''--- basic-tutorials/simple-drop/simple-near-example.js ---
const { parseNearAmount } = require("@near-js/utils");
const { KeyPair } = require("@near-js/crypto")
const { Near } = require("@near-js/wallet-account");
const { Account } = require("@near-js/accounts");
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");

const path = require("path");
const homedir = require("os").homedir();

async function simpleDropNear(){
	// Initiate connection to the NEAR blockchain.
	const network = "testnet"
	const CREDENTIALS_DIR = ".near-credentials";
	const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);
	const YOUR_ACCOUNT = "keypom-docs-demo.testnet";
	const KEYPOM_CONTRACT = "v2.keypom.testnet"

	
	let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

	let nearConfig = {
	    networkId: network,
	    keyStore: keyStore,
	    nodeUrl: `https://rpc.${network}.near.org`,
	    walletUrl: `https://wallet.${network}.near.org`,
	    helperUrl: `https://helper.${network}.near.org`,
	    explorerUrl: `https://explorer.${network}.near.org`,
	};

	let near = new Near(nearConfig);
	const fundingAccount = new Account(near.connection, YOUR_ACCOUNT);

	// Keep track of an array of the key pairs we create and the public keys we pass into the contract
	let keyPairs = [];
	let pubKeys = [];
	// Generate keypairs and store them into the arrays defined above
	let keyPair = await KeyPair.fromRandom('ed25519');
	keyPairs.push(keyPair);   
	pubKeys.push(keyPair.publicKey.toString());   

	// Create drop with pub keys, deposit_per_use
	// Note that the user is responsible for error checking when using NEAR-API-JS
	// The SDK automatically does error checking; ensuring valid configurations, enough attached deposit, drop existence etc.
	try {
		await fundingAccount.functionCall({
			contractId: KEYPOM_CONTRACT, 
			methodName: 'create_drop', 
			args: {
				public_keys: pubKeys,
				deposit_per_use: parseNearAmount('1'),
			}, 
			gas: "300000000000000",
			// Generous attached deposit of 1.5 $NEAR
			attachedDeposit: parseNearAmount("1.5")
		});
	} catch(e) {
		console.log('error creating drop: ', e);
	}
	var dropInfo = {};
    	// Creating list of pk's and linkdrops; copied from orignal simple-create.js
    	for(var i = 0; i < keyPairs.length; i++) {
		// For keyPairs.length > 1, change URL secret key to keyPair.secretKey[i]
	    let linkdropUrl = `https://testnet.mynearwallet.com/linkdrop/${KEYPOM_CONTRACT}/${keyPair.secretKey}`;
	    dropInfo[pubKeys[i]] = linkdropUrl;
	}
	// Write file of all pk's and their respective linkdrops
	console.log('Public Keys and Linkdrops: ', dropInfo)
	console.log(`Keypom Contract Explorer Link: explorer.${network}.near.org/accounts/${KEYPOM_CONTRACT}.com`)
}
simpleDropNear()
'''
'''--- basic-tutorials/utils/general.js ---

// Estimate the amount of allowance required for a given attached gas.
const getRecentDropId = async (fundingAccountObject, accountId, keypomContract) => {
    let dropSupplyForOwner = await fundingAccountObject.viewFunction({
        contractId: keypomContract, 
        methodName: 'get_drop_supply_for_owner', 
        args: {account_id: accountId}
    });
	console.log('dropSupplyForOwner: ', dropSupplyForOwner)
	let dropsForOwner = await fundingAccountObject.viewFunction({
        contractId: keypomContract, 
        methodName: 'get_drops_for_owner', 
        args: { account_id: accountId, from_index: (dropSupplyForOwner - 1).toString() }
    });
	console.log('dropsForOwner: ', dropsForOwner)

    return dropsForOwner[dropsForOwner.length - 1].drop_id;
};

module.exports = {
    getRecentDropId,
};
'''
'''--- cookbook/drops.js ---
// Initiate connection to the NEAR blockchain.
const path = require("path");
var assert = require('assert');
const homedir = require("os").homedir();
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Account } = require("@near-js/accounts");
const { parseNearAmount } = require("@near-js/utils");
const { Near } = require("@near-js/wallet-account");
const keypom = require("@keypom/core");
const { BN } = require("bn.js");
const { readFileSync } = require('fs');

const {
    initKeypom,
    createDrop,
    getDropInformation,
    generateKeys,
    addKeys,
    getKeyInformation,
    getKeySupplyForDrop,
    claim,
    createNFTSeries,
    createTrialAccountDrop,
    claimTrialAccountDrop,
    trialSignAndSendTxns
} = keypom

async function simpleTests(fundingAccount) {
    // Creating drop with 2 single use keys
    let {keys: keys1, dropId: dropId1} = await createDrop({
        account: fundingAccount,
        numKeys: 2,
        depositPerUseNEAR: "0.1",
    });

    const keyInfo1 = await getKeyInformation({
        publicKey: keys1.publicKeys[0]
    })
    assert(keyInfo1.drop_id === dropId1, `First drop failed.`)

    
    // Creating drop with 0 single use keys
    let {dropId: dropId2} = await createDrop({
        account: fundingAccount,
        depositPerUseNEAR: "0.001",
    });

    let numKeys = 200
    let keysAdded = 0;
    let allSecretKeys = [];
    while (keysAdded < numKeys) {
        const keysToAdd = Math.min(50, numKeys - keysAdded);
        const {secretKeys, publicKeys} = await generateKeys({
            numKeys: keysToAdd,
        });
        await addKeys({
            account: fundingAccount,
            dropId: dropId2,
            publicKeys
        });
        keysAdded += keysToAdd;
        allSecretKeys = allSecretKeys.concat(secretKeys);
    }
    // Query for the drop information and also return the key information as well
    let keyInfo2 = await getKeyInformation({
        secretKey: allSecretKeys[5],
    })

    let keySupply2 = await getKeySupplyForDrop({
        dropId: dropId2
    })

    assert(keyInfo2.drop_id === dropId2 && keySupply2 == 200, `Second drop failed.`)

}

async function nftTests(fundingAccount) {
    NFT_TOKEN_ID = 'keypom_test_token_122333'
    NFT_CONTRACT = 'nft.examples.testnet'
    
    // Mint 1 NFT for the drop funder
    await fundingAccount.functionCall({
        contractId: NFT_CONTRACT, 
        methodName: 'nft_mint', 
        args: {
            receiver_id: "minqi.testnet",
            metadata: {
                title: "My Test Keypom NFT",
                description: "NFT from my first NFT Drop!",
                media: "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
            },
            token_id: NFT_TOKEN_ID,
        },
        gas: "300000000000000",
        // Cost to cover storage of NFT
        attachedDeposit: parseNearAmount("0.1")
    });

    const { keys } = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        depositPerUseNEAR: "1",
        nftData: {
            // NFT Contract Id that the tokens will come from
            contractId: NFT_CONTRACT,
            // Who will be sending the NFTs to the Keypom contract
            senderId: "minqi.testnet",
            // List of tokenIDs
            tokenIds: [NFT_TOKEN_ID]
        }
    });

    await claim({
        accountId: "minqianlu.testnet",
        secretKey: keys.secretKeys[0],
    })

    let viewReturn = await fundingAccount.viewFunction({
        contractId: NFT_CONTRACT,
		methodName: 'nft_token',
        args: {
            token_id: NFT_TOKEN_ID
        }
    })
    assert(viewReturn.owner_id === "minqianlu.testnet", `NFT drop failed.`)

}

async function ftTests(fundingAccount) {
    YOUR_ACCOUNT = "minqi.testnet"

    // Get amount of FTs to transfer. In this scenario, we've assumed it to be 1 for one single use key.
    let amountToTransfer = parseNearAmount("1")
    FT_CONTRACT = "ft.keypom.testnet"

    // Get funder's fungible token balance
    let funderFungibleTokenBal = await fundingAccount.viewFunction({
        contractId: FT_CONTRACT, 
        methodName: 'ft_balance_of',
        args: {
            account_id: YOUR_ACCOUNT
        }
    });

    // Check if the owner has enough FT balance to fund drop
    if (new BN(funderFungibleTokenBal).lte(new BN(amountToTransfer))){
        throw new Error('funder does not have enough Fungible Tokens for this drop. Top up and try again.');
    }

    const { keys } = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        depositPerUseNEAR: 1,
        ftData: {
            contractId: FT_CONTRACT,
            senderId: YOUR_ACCOUNT,
            // This balance per use is balance of human readable FTs per use. 
            amount: "1"
            // Alternatively, you could use absoluteAmount, which is dependant on the decimals value of the FT
            // ex. if decimals of an ft = 8, then 1 FT token would be absoluteAmount = 100000000
        },
    });

    let preClaimBal = await fundingAccount.viewFunction({
        contractId: FT_CONTRACT,
		methodName: 'ft_balance_of',
        args: {
            account_id: "minqianlu.testnet"
        }
    })

    await claim({
        accountId: "minqianlu.testnet",
        secretKey: keys.secretKeys[0],
    })

    let postClaimBal = await fundingAccount.viewFunction({
        contractId: FT_CONTRACT,
		methodName: 'ft_balance_of',
        args: {
            account_id: "minqianlu.testnet"
        }
    }) 

    let balChange = (postClaimBal - preClaimBal)

    assert(balChange == "1", `FT drop failed.`)

}

async function fcTests(fundingAccount) {
    MY_CONTRACT = "guest-book.examples.keypom.testnet"
    YOUR_ACCOUNT = "minqi.testnet"
    
    console.log("SINGLE USE, SINGLE METHOD")
    // Creating a single key single use FC drop
    let {keys: key1} = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        depositPerUseNEAR: "0.1",
        fcData: {
            methods: [
                // First key use
                [
                    {
                        receiverId: MY_CONTRACT,
                        methodName: "add_message",
                        args: JSON.stringify({
                            text: "first"
                        }),
                        attachedDeposit: parseNearAmount("0.001"),
                    },
                ],
            ]   
        }   
    })

    await claim({accountId: "minqianlu.testnet", secretKey: key1.secretKeys[0],})
    let messages1 = await fundingAccount.viewFunction({contractId: MY_CONTRACT, methodName: 'get_messages', args: {from: 200, limit: 500}})
    assert(messages1[messages1.length - 1].sender == "v2.keypom.testnet" && messages1[messages1.length - 1].text == "first", `FC drop failed.`)
    // Buffer
    await fundingAccount.functionCall({
        contractId: MY_CONTRACT,
        methodName: "add_message",
        args: {
            text: "BUFFER BUFFER BUFFER"
        },
        attachedDeposit: parseNearAmount("0.001")
    })

    
    console.log("MULTI-USE SINGLE METHOD")
    // Creating a single key single use FC drop
    let {keys: key2} = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        config: {
            usesPerKey: 2
        },
        depositPerUseNEAR: "0.1",
        fcData: {
            methods: [
                // First key use
                [
                    {
                        receiverId: MY_CONTRACT,
                        methodName: "add_message",
                        args: JSON.stringify({
                            text: "first"
                        }),
                        attachedDeposit: parseNearAmount("0.001"),
                    },
                ],
                [
                    {
                        receiverId: MY_CONTRACT,
                        methodName: "add_message",
                        args: JSON.stringify({
                            text: "first-point-five"
                        }),
                        attachedDeposit: parseNearAmount("0.001"),
                    }
                ],
            ]   
        }   
    })
    // First claim
    await claim({accountId: "minqianlu.testnet", secretKey: key2.secretKeys[0],})
    let messages2 = await fundingAccount.viewFunction({contractId: MY_CONTRACT, methodName: 'get_messages', args: {from: 200, limit: 500}})
    assert(messages2[messages2.length - 1].sender == "v2.keypom.testnet" && messages2[messages2.length - 1].text == "first", `FC drop failed.`)

    // Second claim
    await claim({accountId: "minqianlu.testnet", secretKey: key2.secretKeys[0],})
    messages2 = await fundingAccount.viewFunction({contractId: MY_CONTRACT, methodName: 'get_messages', args: {from: 200, limit: 500}})
    assert(messages2[messages2.length - 1].sender == "v2.keypom.testnet" && messages2[messages2.length - 1].text == "first-point-five", `FC drop failed.`)
    // Buffer
    await fundingAccount.functionCall({
        contractId: MY_CONTRACT,
        methodName: "add_message",
        args: {
            text: "BUFFER BUFFER BUFFER"
        },
        attachedDeposit: parseNearAmount("0.001")
    })

    console.log("SINGLE USE MULTI-METHOD")
    // Creating a single key single use FC drop
    let {keys: key3} = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        depositPerUseNEAR: "0.1",
        fcData: {
            methods: [
                // // First key use
                [
                    {
                        receiverId: MY_CONTRACT,
                        methodName: "add_message",
                        args: JSON.stringify({
                            text: "second"
                        }),
                        attachedDeposit: parseNearAmount("0.001"),
                    },
                    {
                        receiverId: MY_CONTRACT,
                        methodName: "add_message",
                        args: JSON.stringify({
                            text: "third"
                        }),
                        attachedDeposit: parseNearAmount("0.001"),
                    },
                    {
                        receiverId: MY_CONTRACT,
                        methodName: "add_message",
                        args: JSON.stringify({
                            text: "fourth"
                        }),
                        attachedDeposit: parseNearAmount("0.001"),
                    },
                ],
            ]   
        }   
    })
    await claim({accountId: "minqianlu.testnet", secretKey: key3.secretKeys[0],})
    let messages3 = await fundingAccount.viewFunction({contractId: MY_CONTRACT, methodName: 'get_messages', args: {from: 200, limit: 500}})
    assert(messages3[messages3.length - 3].sender == "v2.keypom.testnet" && messages3[messages3.length - 3].text == "second" &&
           messages3[messages3.length - 2].sender == "v2.keypom.testnet" && messages3[messages3.length - 2].text == "third" &&
           messages3[messages3.length - 1].sender == "v2.keypom.testnet" && messages3[messages3.length - 1].text == "fourth", `FC drop failed.`)
    // Buffer
    await fundingAccount.functionCall({
        contractId: MY_CONTRACT,
        methodName: "add_message",
        args: {
            text: "BUFFER BUFFER BUFFER"
        },
        attachedDeposit: parseNearAmount("0.001")
    })

    console.log("MULTI-USE MULTI-METHOD")
    // Creating a single key single use FC drop
    let {keys: key4} = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        config: {
            usesPerKey: 3
        },
        depositPerUseNEAR: "0.1",
        fcData: {
            methods: [
                // First key use
                [
                    {
                        receiverId: MY_CONTRACT,
                        methodName: "add_message",
                        args: JSON.stringify({
                            text: "first"
                        }),
                        attachedDeposit: parseNearAmount("0.001"),
                    }
                ],
                // Second key use
                null,

                // Third key use
                [
                    {
                        receiverId: MY_CONTRACT,
                        methodName: "add_message",
                        args: JSON.stringify({
                            text: "second"
                        }),
                        attachedDeposit: parseNearAmount("0.001"),
                    },
                    {
                        receiverId: MY_CONTRACT,
                        methodName: "add_message",
                        args: JSON.stringify({
                            text: "third"
                        }),
                        attachedDeposit: parseNearAmount("0.001"),
                    },
                    {
                        receiverId: MY_CONTRACT,
                        methodName: "add_message",
                        args: JSON.stringify({
                            text: "fourth"
                        }),
                        attachedDeposit: parseNearAmount("0.001"),
                    },
                ],
            ]   
        }   
    })
    // First claim
    await claim({accountId: "minqianlu.testnet", secretKey: key4.secretKeys[0],})
    let messages4 = await fundingAccount.viewFunction({contractId: MY_CONTRACT, methodName: 'get_messages', args: {from: 200, limit: 500}})
    assert(messages4[messages4.length - 1].sender == "v2.keypom.testnet" && messages4[messages4.length - 1].text == "first", `FC drop failed.`)

    // Second claim, should do nothing
    await claim({accountId: "minqianlu.testnet", secretKey: key4.secretKeys[0],})
    messages4 = await fundingAccount.viewFunction({contractId: MY_CONTRACT, methodName: 'get_messages', args: {from: 200, limit: 500}})
    assert(messages4[messages4.length - 1].sender == "v2.keypom.testnet" && messages4[messages4.length - 1].text == "first", `FC drop failed.`)

    // Third claim
    await claim({accountId: "minqianlu.testnet", secretKey: key4.secretKeys[0],})
    messages4 = await fundingAccount.viewFunction({contractId: MY_CONTRACT, methodName: 'get_messages', args: {from: 200, limit: 500}})
    assert(messages4[messages4.length - 4].sender == "v2.keypom.testnet" && messages4[messages4.length - 4].text == "first" &&
           messages4[messages4.length - 3].sender == "v2.keypom.testnet" && messages4[messages4.length - 3].text == "second" &&
           messages4[messages4.length - 2].sender == "v2.keypom.testnet" && messages4[messages4.length - 2].text == "third" &&
           messages4[messages4.length - 1].sender == "v2.keypom.testnet" && messages4[messages4.length - 1].text == "fourth", `FC drop failed.`)
    // Buffer
    await fundingAccount.functionCall({
        contractId: MY_CONTRACT,
        methodName: "add_message",
        args: {
            text: "BUFFER BUFFER BUFFER"
        },
        attachedDeposit: parseNearAmount("0.001")
    })
}

async function fcNFTTests(fundingAccount) {
    // Create drop with 10 keys and 2 key uses each
    let {keys, dropId} = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        depositPerUseNEAR: "0.1",
        fcData: {
            methods: [
                [
                    {
                        receiverId: `nft-v2.keypom.testnet`,
                        methodName: "nft_mint",
                        args: "",
                        dropIdField: "mint_id",
                        accountIdField: "receiver_id",
                        attachedDeposit: parseNearAmount("0.1")
                    }
                ],
            ]   
        }   
    })

    await createNFTSeries({
        account: fundingAccount,
        dropId,
        metadata: {
            title: "Moon NFT Ticket!",
            description: "A cool NFT POAP for the best dog in the world.",
            media: "bafybeibwhlfvlytmttpcofahkukuzh24ckcamklia3vimzd4vkgnydy7nq",
            copies: 1
        }
    }); 

    let preClaimNFTs = await fundingAccount.viewFunction({
        contractId: "nft-v2.keypom.testnet",
		methodName: 'nft_supply_for_owner',
        args: {
            account_id: "minqianlu.testnet"
        }
    })

    await claim({accountId: "minqianlu.testnet", secretKey: keys.secretKeys[0],})

    let postClaimNFTs = await fundingAccount.viewFunction({
        contractId: "nft-v2.keypom.testnet",
		methodName: 'nft_supply_for_owner',
        args: {
            account_id: "minqianlu.testnet"
        }
    })

    assert(postClaimNFTs - preClaimNFTs == 1, `FC drop failed.`)
    

    
}

async function trialTests(fundingAccount) {
    // What contracts can the trial account call?
const callableContracts = [
        'guest-book.examples.keypom.testnet',
        'v1.social08.testnet'
    ]
    // What is the maximum amount of $NEAR that can be attached to a call for each callable contract?
    // 1 NEAR for guestbook, 2 NEAR for NEAR social
    const maxAttachableNEARPerContract = [
        '1.5',
        '2'
    ]
    // What methods can the trial account call?
    // Any function can be called on either contracts. 
    const callableMethods = [
        ['*'],
        ['*']
    ]

    const wasmDirectory = `${require('path').resolve(__dirname, '..')}/cookbook/ext-wasm/trial-accounts.wasm`
    const {dropId, keys: {secretKeys: trialSecretKeys, publicKeys: trialPublicKeys}} = await createTrialAccountDrop({
        account: fundingAccount,
        numKeys: 1,
        contractBytes: [...readFileSync(wasmDirectory)],
        // How much $NEAR should be made available to the trial account when it's created?
        startingBalanceNEAR: 2.5,
        callableContracts,
        callableMethods,
        maxAttachableNEARPerContract,
        // repayAmountNEAR: 0.6,
        // repayTo: "dennis.near",
        // Once the trial account has spent this much $NEAR, the trial will be over.
        trialEndFloorNEAR: 1.25
    })

    const desiredAccountId = `${dropId}-keypom.testnet`
    const trialSecretKey = trialSecretKeys[0]
    await claimTrialAccountDrop({
        desiredAccountId,
        secretKey: trialSecretKeys[0],
    })

    console.log('desiredAccountId: ', desiredAccountId)
    console.log(`trialSecretKey: ${JSON.stringify(trialSecretKey)}`)
    const txns = [{
        receiverId: callableContracts[0],
        actions: [
            {
                type: 'FunctionCall',
                params: {
                    methodName: 'add_message',
                    args: {
                        text: "Trial Account Cookbook Test"
                    },
                    gas: '30000000000000',
                    deposit: parseNearAmount('1.5')
                },
            },
        ],
    }];

    await trialSignAndSendTxns({
        trialAccountId: desiredAccountId,
        trialAccountSecretKey: trialSecretKey,
        txns
    })
    try{
        const txns_fail = [{
            receiverId: callableContracts[0],
            actions: [
                // Second one should fail
                {
                    type: 'FunctionCall',
                    params: {
                        methodName: 'add_message',
                        args: {
                            text: "Trial Account Cookbook Test 2"
                        },
                        gas: '30000000000000',
                        deposit: parseNearAmount('1')
                    },
                },
            ],
        }];
    
        await trialSignAndSendTxns({
            trialAccountId: desiredAccountId,
            trialAccountSecretKey: trialSecretKey,
            txns: txns_fail
        })
    } catch(e){
        console.log("Balance limit reached, as expected")
    }
    
}

async function tests() {
    const network = "testnet"
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);
    const YOUR_ACCOUNT = "minqi.testnet";

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

    let nearConfig = {
        networkId: network,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${network}.near.org`,
        walletUrl: `https://wallet.${network}.near.org`,
        helperUrl: `https://helper.${network}.near.org`,
        explorerUrl: `https://explorer.${network}.near.org`,
    };  

    let near = new Near(nearConfig);
    const fundingAccount = await near.account(YOUR_ACCOUNT);

    // If a NEAR connection is not passed in and is not already running, initKeypom will create a new connection
    // Here we are connecting to the testnet network
    await initKeypom({
        near,
        network
    });

    // await simpleTests(fundingAccount)
    // await nftTests(fundingAccount)
    //await fcTests(fundingAccount)
    //await fcNFTTests(fundingAccount)
    await trialTests(fundingAccount)
}

tests()

'''
'''--- cookbook/keys.js ---
// Initiate connection to the NEAR blockchain.
const path = require("path");
var assert = require('assert');
const homedir = require("os").homedir();
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Account } = require("@near-js/accounts");
const { parseNearAmount } = require("@near-js/utils");
const { Near } = require("@near-js/wallet-account");
const keypom = require("@keypom/core");
const { BN } = require("bn.js");
const { readFileSync } = require('fs');

const {
    initKeypom,
    createDrop,
    getDropInformation,
    generateKeys,
    addKeys,
    getKeyInformation,
    getKeySupplyForDrop,
    claim,
    createNFTSeries,
    createTrialAccountDrop,
    claimTrialAccountDrop,
    trialSignAndSendTxns,
    deleteKeys,
    getKeysForDrop
} = keypom

async function keyTests(fundingAccount) {
    // Creating drop with 2 single use keys
    let {keys, dropId} = await createDrop({
        account: fundingAccount,
        numKeys: 2,
        config:{
            usesPerKey: 3
        },
        depositPerUseNEAR: "0.1",
    });

    // Delete first key from drop
    await deleteKeys({
        account: fundingAccount,
        dropId,
        publicKeys: keys.publicKeys[0] // Can be wrapped in an array as well
    })

    // Query for the key supply for a drop
    const keySupply = await getKeySupplyForDrop({
        dropId
    })

    assert(keySupply == 1, "Key deletion unsuccessful")

    // Query for the key supply for the drop that was created
    const keyInfos = await getKeysForDrop({
        dropId
    })

    // Check key usage of first key
    const keyUsage = keyInfos[0].remaining_uses
    assert(keyUsage == 3, "Getting key usage has failed")

    // Check key usage of first key
    const keyBalance = keyInfos[0].allowance
    console.log(`Key balance is: ${keyBalance}`)
    assert(keyBalance != 0, "Key balance funky")

    

}

async function tests() {
    const network = "testnet"
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);
    const YOUR_ACCOUNT = "minqi.testnet";

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

    let nearConfig = {
        networkId: network,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${network}.near.org`,
        walletUrl: `https://wallet.${network}.near.org`,
        helperUrl: `https://helper.${network}.near.org`,
        explorerUrl: `https://explorer.${network}.near.org`,
    };  

    let near = new Near(nearConfig);
    const fundingAccount = await near.account(YOUR_ACCOUNT);

    // If a NEAR connection is not passed in and is not already running, initKeypom will create a new connection
    // Here we are connecting to the testnet network
    await initKeypom({
        near,
        network
    });

    await keyTests(fundingAccount)

}

tests()

'''
'''--- cookbook/password.js ---
// Initiate connection to the NEAR blockchain.
const path = require("path");
var assert = require('assert');
const homedir = require("os").homedir();
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Account } = require("@near-js/accounts");
const { parseNearAmount } = require("@near-js/utils");
const { Near } = require("@near-js/wallet-account");
const keypom = require("@keypom/core");
const { BN } = require("bn.js");
const { readFileSync } = require('fs');

const {
    initKeypom,
    createDrop,
    getDropInformation,
    generateKeys,
    addKeys,
    getKeyInformation,
    getKeySupplyForDrop,
    claim,
    createNFTSeries,
    createTrialAccountDrop,
    claimTrialAccountDrop,
    trialSignAndSendTxns,
    hashPassword
} = keypom

async function protectedDropTest(fundingAccount) {
    let base_password = "base-password"
    // Creating drop with 2 single use keys
    let {keys, dropId} = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        depositPerUseNEAR: "0.1",
        basePassword: base_password
    })

    let preClaimSupply = await getKeySupplyForDrop({
        dropId
    })

    // First claim
    const keyInfo1 = await getKeyInformation({
        publicKey: keys.publicKeys[0]
    })
    let passwordForClaim = await hashPassword(base_password + keys.publicKeys[0] + keyInfo1.cur_key_use.toString())
    await claim({
        accountId: "minqianlu.testnet",
        secretKey: keys.secretKeys[0],
        password: passwordForClaim
    })

    let postClaimSupply = await getKeySupplyForDrop({
        dropId
    })

    assert(preClaimSupply - postClaimSupply === 1, `PW protected drop failed.`)
}

async function protectedUseTest(fundingAccount) {
    let base_password = "base-password"
    // Creating drop with 2 single use keys
    let {keys, dropId} = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        config:{
            usesPerKey: 2
        },
        depositPerUseNEAR: "0.1",
        basePassword: base_password,
        // Password protect the first key uses
        passwordProtectedUses: [1],
    })

    let preBadClaim = await getKeyInformation({publicKey: keys.publicKeys[0]})

    // this should fail
    await claim({
        accountId: "minqianlu.testnet",
        secretKey: keys.secretKeys[0],
    })

    let postBadClaim = await getKeyInformation({publicKey: keys.publicKeys[0]})
    assert(preBadClaim.cur_key_use == postBadClaim.cur_key_use, "First bad claim went through")

    // First proper claim
    const keyInfo1 = await getKeyInformation({
        publicKey: keys.publicKeys[0]
    })
    let passwordForClaim = await hashPassword(base_password + keys.publicKeys[0] + keyInfo1.cur_key_use.toString())
    await claim({
        accountId: "minqianlu.testnet",
        secretKey: keys.secretKeys[0],
        password: passwordForClaim
    })
    let postGoodClaim = await getKeyInformation({publicKey: keys.publicKeys[0]})
    assert(postGoodClaim.cur_key_use - postBadClaim.cur_key_use == 1, "First good claim failed")

    let preSecondClaimSupply = await getKeySupplyForDrop({dropId})
    // Second claim, no PW needed
    await claim({
        accountId: "minqianlu.testnet",
        secretKey: keys.secretKeys[0],
    })

    let postSecondClaimSupply = await getKeySupplyForDrop({dropId})
    assert(preSecondClaimSupply - postSecondClaimSupply == 1, "Second good claim failed")
}

async function tests() {
    const network = "testnet"
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);
    const YOUR_ACCOUNT = "minqi.testnet";

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

    let nearConfig = {
        networkId: network,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${network}.near.org`,
        walletUrl: `https://wallet.${network}.near.org`,
        helperUrl: `https://helper.${network}.near.org`,
        explorerUrl: `https://explorer.${network}.near.org`,
    };  

    let near = new Near(nearConfig);
    const fundingAccount = await near.account(YOUR_ACCOUNT);

    // If a NEAR connection is not passed in and is not already running, initKeypom will create a new connection
    // Here we are connecting to the testnet network
    await initKeypom({
        near,
        network
    });

    // await protectedDropTest(fundingAccount)
    await protectedUseTest(fundingAccount)
}

tests()

'''
'''--- cookbook/saleConfig.js ---
// Initiate connection to the NEAR blockchain.
const path = require("path");
var assert = require('assert');
const homedir = require("os").homedir();
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Account } = require("@near-js/accounts");
const { parseNearAmount } = require("@near-js/utils");
const { Near } = require("@near-js/wallet-account");
const keypom = require("@keypom/core");
const { BN } = require("bn.js");
const { readFileSync } = require('fs');

const {
    initKeypom,
    createDrop,
    getDropInformation,
    generateKeys,
    addKeys,
    getKeyInformation,
    getKeySupplyForDrop,
    claim,
    createNFTSeries,
    createTrialAccountDrop,
    claimTrialAccountDrop,
    trialSignAndSendTxns,
    hashPassword,
    canUserAddKeys,
    addToSaleAllowlist,
    removeFromSaleAllowlist,
    addToSaleBlocklist,
    removeFromSaleBlocklist
} = keypom

async function openSaleTest(fundingAccount) {
    const TICKET_PRICE = "1"

    // Create drop with a maximum of 100 keys that can be added by anyone
    const { keys, dropId } = await createDrop({
        account: fundingAccount,
        depositPerUseNEAR: 0.1,
        config: {
            sale: {
                maxNumKeys: 10,
                pricePerKeyNEAR: TICKET_PRICE
            }
        }
    });

    console.log("Checking drop starting key supply, should be 0")
    let startingNumKeys = await getKeySupplyForDrop({dropId})
    assert(startingNumKeys == 0, "Drop should start with 0 keys")

    console.log("Checking permissions")
    let canAddKeys = await canUserAddKeys({dropId, accountId: "minqianlu.testnet"});
    assert(canAddKeys, "Not everyone is allowed to add keys")

    console.log("Buying Key")
    const {publicKeys} = await generateKeys({numKeys: 1});
    await addKeys({account: fundingAccount, publicKeys, dropId, extraDepositNEAR: TICKET_PRICE})

    console.log("Checking drop keys again")
    let newgNumKeys = await getKeySupplyForDrop({dropId})
    assert(newgNumKeys == 1, "Drop should now have 1 key added by minqianlu")
}

async function AllowlistTests(fundingAccount) {
    // Create drop with restrictive allowlist, try adding with another account, then modify allowlist and check permissions
    // check with canUserAddKeys

    const { keys, dropId } = await createDrop({
        account: fundingAccount,
        depositPerUseNEAR: 0.1,
        config: {
            sale: {
                maxNumKeys: 10,
                pricePerKeyNEAR: 1,
                allowlist: ["minqi.testnet"]
            }
        }
    });

    // check benji perms
    console.log("Checking benji perms")
    let canAddKeys = await canUserAddKeys({dropId, accountId: "benji.testnet"});
    assert(!canAddKeys, "benji shouldn't be allowed")

    console.log("add benji")
    await addToSaleAllowlist({account: fundingAccount, dropId, accountIds: ["benji.testnet"]});
    canAddKeys = await canUserAddKeys({dropId, accountId: "benji.testnet"});
    assert(canAddKeys, "benji still cannot add keys")

    console.log("remove minqi")
    await removeFromSaleAllowlist({account: fundingAccount, dropId, accountIds: ["minqi.testnet"]});
    let canAddKeys2 = await canUserAddKeys({dropId, accountId: "minqi.testnet"});
    assert(!canAddKeys2, "minqi is still allowed to add")
}

async function BlocklistTests(fundingAccount) {
    // Create drop with restrictive allowlist, try adding with another account, then modify allowlist and check permissions
    // check with canUserAddKeys

    const { keys, dropId } = await createDrop({
        account: fundingAccount,
        depositPerUseNEAR: 0.1,
        config: {
            sale: {
                maxNumKeys: 10,
                pricePerKeyNEAR: 1,
                blocklist: ["benji.testnet"]
            }
        }
    });

    // check benji perms
    console.log("Checking benji perms")
    let canAddKeys = await canUserAddKeys({dropId, accountId: "benji.testnet"});
    assert(!canAddKeys, "benji shouldn't be allowed")

    // check minqi perms
    console.log("Checking minqi perms")
    canAddKeys = await canUserAddKeys({dropId, accountId: "minqi.testnet"});
    assert(canAddKeys, "minqi should be allowed")

    console.log("add minqi to blocklist")
    await addToSaleBlocklist({account: fundingAccount, dropId, accountIds: ["minqi.testnet"]});
    canAddKeys = await canUserAddKeys({dropId, accountId: "minqi.testnet"});
    assert(!canAddKeys, "minqi should not be allowed to add keys")

    console.log("remove benji")
    await removeFromSaleBlocklist({account: fundingAccount, dropId, accountIds: ["benji.testnet"]});
    canAddKeys = await canUserAddKeys({dropId, accountId: "benji.testnet"});
    assert(canAddKeys, "benji should now be allowed to add")
}

async function tests() {
    const network = "testnet"
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);
    const YOUR_ACCOUNT = "minqi.testnet";

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

    let nearConfig = {
        networkId: network,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${network}.near.org`,
        walletUrl: `https://wallet.${network}.near.org`,
        helperUrl: `https://helper.${network}.near.org`,
        explorerUrl: `https://explorer.${network}.near.org`,
    };  

    let near = new Near(nearConfig);
    const fundingAccount = await near.account(YOUR_ACCOUNT);

    // If a NEAR connection is not passed in and is not already running, initKeypom will create a new connection
    // Here we are connecting to the testnet network
    await initKeypom({
        near,
        network
    });

    // await openSaleTest(fundingAccount)
    // await AllowlistTests(fundingAccount)
    await BlocklistTests(fundingAccount)
}

tests()

'''
'''--- cookbook/timeConfig.js ---
// Initiate connection to the NEAR blockchain.
const path = require("path");
var assert = require('assert');
const homedir = require("os").homedir();
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Account } = require("@near-js/accounts");
const { parseNearAmount } = require("@near-js/utils");
const { Near } = require("@near-js/wallet-account");
const keypom = require("@keypom/core");
const { BN } = require("bn.js");
const { readFileSync } = require('fs');

const {
    initKeypom,
    createDrop,
    getDropInformation,
    generateKeys,
    addKeys,
    getKeyInformation,
    getKeySupplyForDrop,
    claim,
    createNFTSeries,
    createTrialAccountDrop,
    claimTrialAccountDrop,
    trialSignAndSendTxns,
    hashPassword
} = keypom

async function startEndTest(fundingAccount) {
    const ONE_SECOND_NS = 1e9;

    // Creating timed drop with 1 double use keys
    const {keys, dropId} = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        config:{
            usesPerKey: 2,
            time: {
                // Start time is 30 seconds from now
                start: (Date.now() * 1000000) + ONE_SECOND_NS * 15,
                // End time is 90 seconds from start time
                end: (Date.now() * 1000000) + ONE_SECOND_NS * 45,
            },
        },
        depositPerUseNEAR: "0.1",
    });

    console.log("Violating start time")
    await claim({accountId: "minqianlu.testnet", secretKey: keys.secretKeys[0]})
    let jumpStartInfo = await getKeyInformation({publicKey: keys.publicKeys[0]})
    assert(jumpStartInfo.remaining_uses == 2, "Start time violated")

    console.log("Respecting start time")
    await new Promise(r => setTimeout(r, 15000));
    console.log("Respected")
    await claim({accountId: "minqianlu.testnet", secretKey: keys.secretKeys[0]})
    let goodStartInfo = await getKeyInformation({publicKey: keys.publicKeys[0]})
    assert(goodStartInfo.remaining_uses == 1, "Valid claim failed")

    console.log("Violating end time")
    await new Promise(r => setTimeout(r, 30001));
    await claim({accountId: "minqianlu.testnet", secretKey: keys.secretKeys[0]})
    let lateClaimInfo = await getKeyInformation({publicKey: keys.publicKeys[0]})
    assert(lateClaimInfo.remaining_uses == 1, "End time violated")
}

async function throttleTest(fundingAccount) {
    const ONE_SECOND_NS = 1e9;

    // Creating timed drop with 1 double use keys
    const {keys, dropId} = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        config:{
            usesPerKey: 2,
            time: {
                // Time between use is 15 seconds
                throttle: ONE_SECOND_NS * 30,
            },
        },
        depositPerUseNEAR: "0.1",
    });

    console.log("First claim")
    await claim({accountId: "minqianlu.testnet", secretKey: keys.secretKeys[0]})
    let firstClaimInfo = await getKeyInformation({publicKey: keys.publicKeys[0]})
    assert(firstClaimInfo.remaining_uses == 1, "First claim failed")

    console.log("Violating throttle time")
    await new Promise(r => setTimeout(r, 5000));
    await claim({accountId: "minqianlu.testnet", secretKey: keys.secretKeys[0]})
    let goodStartInfo = await getKeyInformation({publicKey: keys.publicKeys[0]})
    assert(goodStartInfo.remaining_uses == 1, "Throttle has been disrespected :(")

    console.log("Respecting thottle")
    await new Promise(r => setTimeout(r, 25001));
    await claim({accountId: "minqianlu.testnet", secretKey: keys.secretKeys[0]})
    let keysLeft = await getKeySupplyForDrop({dropId})
    assert(keysLeft == 0, "Not sure how this would happen ://")
}

async function recurringPaymentTest(fundingAccount) {
    const ONE_SECOND_NS = 1e9;

    // Creating timed drop with 1 double use keys
    const {keys, dropId} = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        config:{
            usesPerKey: 3,
            time: {
                // Start time is now + 1s
                start: (Date.now() * 1000000) + ONE_SECOND_NS * 5,
                // End time is 30 day after start time
                end: (Date.now() * 1000000) + ONE_SECOND_NS * 2592000,
                // Time after start for first use is 30s
                interval: ONE_SECOND_NS * 30,
            },
        },
        depositPerUseNEAR: "0.1",
    });

    console.log("Premature claim")
    await claim({accountId: "minqianlu.testnet", secretKey: keys.secretKeys[0]})
    let firstClaimInfo = await getKeyInformation({publicKey: keys.publicKeys[0]})
    assert(firstClaimInfo.remaining_uses == 3, "First interval failed")

    console.log("First valid time")
    await new Promise(r => setTimeout(r, 30000));
    await claim({accountId: "minqianlu.testnet", secretKey: keys.secretKeys[0]})
    let goodStartInfo = await getKeyInformation({publicKey: keys.publicKeys[0]})
    assert(goodStartInfo.remaining_uses == 2, "Interval start has been disrespected :(")

    console.log("Violating Interval")
    await claim({accountId: "minqianlu.testnet", secretKey: keys.secretKeys[0]})
    let violateIntervalInfo = await getKeyInformation({publicKey: keys.publicKeys[0]})
    assert(violateIntervalInfo.remaining_uses == 2, "Interval has been disrespected :(")

    console.log("Second and third valid claim")
    await new Promise(r => setTimeout(r, 60000));
    await claim({accountId: "minqianlu.testnet", secretKey: keys.secretKeys[0]})
    let doubelRespectedInfo = await getKeyInformation({publicKey: keys.publicKeys[0]})
    assert(doubelRespectedInfo.remaining_uses == 1, "Second claim failed")
    await claim({accountId: "minqianlu.testnet", secretKey: keys.secretKeys[0]})
    let keysLeft = await getKeySupplyForDrop({dropId})
    assert(keysLeft == 0, "Not sure how this would happen ://")
}

async function tests() {
    const network = "testnet"
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);
    const YOUR_ACCOUNT = "minqi.testnet";

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

    let nearConfig = {
        networkId: network,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${network}.near.org`,
        walletUrl: `https://wallet.${network}.near.org`,
        helperUrl: `https://helper.${network}.near.org`,
        explorerUrl: `https://explorer.${network}.near.org`,
    };  

    let near = new Near(nearConfig);
    const fundingAccount = await near.account(YOUR_ACCOUNT);

    // If a NEAR connection is not passed in and is not already running, initKeypom will create a new connection
    // Here we are connecting to the testnet network
    await initKeypom({
        near,
        network
    });

    // await startEndTest(fundingAccount)
    // await throttleTest(fundingAccount)
    await recurringPaymentTest(fundingAccount)
}

tests()

'''
'''--- cookbook/usageConfig.js ---
// Initiate connection to the NEAR blockchain.
const path = require("path");
var assert = require('assert');
const homedir = require("os").homedir();
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Account } = require("@near-js/accounts");
const { parseNearAmount } = require("@near-js/utils");
const { Near } = require("@near-js/wallet-account");
const keypom = require("@keypom/core");
const { BN } = require("bn.js");
const { readFileSync } = require('fs');

const {
    initKeypom,
    createDrop,
    getDropInformation,
    generateKeys,
    addKeys,
    getKeyInformation,
    getKeySupplyForDrop,
    claim,
    createNFTSeries,
    createTrialAccountDrop,
    claimTrialAccountDrop,
    trialSignAndSendTxns,
    hashPassword,
    canUserAddKeys,
    addToSaleAllowlist,
    removeFromSaleAllowlist,
    addToSaleBlocklist,
    removeFromSaleBlocklist,
    getUserBalance,
    addToBalance,
    withdrawBalance,
    getEnv,
    formatLinkdropUrl
} = keypom

// Permissions + refunding deposit when claim is called tests

// Deleting drop when empty and refunding balance tests

async function permissionsAndRefundingTests(fundingAccount) {
    // Only claim
    const { keys: keys_caac, dropId: dropId_caac } = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        depositPerUseNEAR: "1",
        config: {
            usage:{
                permissions: `create_account_and_claim`
            }
        }
    });

    // Only caac
    const { keys: keys_claim, dropId: dropId_claim } = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        depositPerUseNEAR: "1",
        config: {
            usage:{
                permissions: `claim`
            }
        }
    });
    
    // Refunding when claim is called
    const { keys: keys_refund, dropId: dropId_refund } = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        depositPerUseNEAR: "1",
        config: {
            usage:{
                refundDeposit: true
            }
        }
    });

    
    // CAAC ONLY DROP
    console.log("CAAC ONLY: trying to claim")
    try{    
        await claim({accountId: "minqianlu.testnet", secretKey: keys_caac.secretKeys[0]})
        let badClaimOnCAAC = await getKeyInformation({publicKey: keys_caac.publicKeys[0]})
        assert(badClaimOnCAAC.remaining_uses == 1, "claim should not work")
    }
    catch{
        console.log("Claim on CAAC only drop rightfully denied")
    }  

    console.log("CAAC ONLY: using CAAC")
    const {publicKeys, secretKeys} = await generateKeys({numKeys: 2});
    await claim({ 
        secretKey: keys_caac.secretKeys[0],
        newAccountId: `kpm-cookbook-${dropId_caac}.testnet`, 
        newPublicKey: publicKeys[0]
    })
    let goodCAADonCAAC = await getKeySupplyForDrop({dropId: dropId_caac})
    assert(goodCAADonCAAC == 0, "CAAC has failed unexpectedly")
    

    
    // CLAIM ONLY DROP
    console.log("CLAIM ONLY: trying to use CAAC")
    try{
        await claim({ 
            secretKey: keys_claim.secretKeys[0],
            newAccountId: `kpm-cookbook-${dropId_claim}.testnet`, 
            newPublicKey: publicKeys[1]
        })
        let badCAADonClaim = await getKeyInformation({publicKey: keys_claim.publicKeys[0]})
        assert(badCAADonClaim.remaining_uses == 1, "CAAC should not work")
    }catch{
        console.log("CAAC on claim only drop rightfully denied")
    }

    console.log("CLAIM ONLY: trying to use claim")
    await claim({accountId: "minqianlu.testnet", secretKey: keys_claim.secretKeys[0]})
    let  goodClaimOnClaim= await getKeySupplyForDrop({dropId: dropId_claim})
    assert(goodClaimOnClaim == 0, "Claim has failed unexpectedly")

    // REFUNDING
    console.log("Checking refunds")
    const unClaimedFunderBal = await getUserBalance({accountId: "minqi.testnet",})
    await claim({accountId: "minqianlu.testnet", secretKey: keys_refund.secretKeys[0]})
    const claimedFunderBal = await getUserBalance({accountId: "minqi.testnet",})
    console.log(`Funder Bal before: ${unClaimedFunderBal}`)
    console.log(`Funder Bal claimed: ${claimedFunderBal}`)
    assert(claimedFunderBal > unClaimedFunderBal, "funder balance was not changed")
}

async function dropDeletionTests(fundingAccount) {
    // Quick balance test
    await addToBalance({
        account: fundingAccount, 
        amountNear: "5"
    });
    let bal1 = await getUserBalance({accountId: "mintlu.testnet"})
    await withdrawBalance({
        account: fundingAccount
    })
    let bal2 = await getUserBalance({accountId: "mintlu.testnet"})
    assert(bal1 - bal2 == parseNearAmount("5"), "balance funky")

    // Begin drop deletion tests
    await addToBalance({account: fundingAccount, amountNear: "15"});

    // create a drop, now balance is roughly 5 $NEAR
    const { keys, dropId } = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        depositPerUseNEAR: "1",
        config: {
            usage:{
                autoDeleteDrop: true,
                autoWithdraw: true
            }
        }
    });
    let funderBal1 = await getUserBalance({accountId: "mintlu.testnet"})
    assert(funderBal1 != 0, "Funder balance somehow 0")

    console.log("Now claiming, funder balance should now be 0 after this")
    await claim({accountId: "minqianlu.testnet", secretKey: keys.secretKeys[0]})
    let funderBal2 = await getUserBalance({accountId: "mintlu.testnet"})
    assert(funderBal2 == 0, "Funder balance was not successfully withdrawn")
}

async function accountCreationTests(fundingAccount) {

    // Creating FC drop that injects accountId into function call arguments
    let {keys, dropId} = await createDrop({
        account: fundingAccount,
        numKeys: 1,
        config: {
            usage:{
                permissions: `create_account_and_claim`,
                accountCreationFields: {
                    funderIdField: "funder_id"
                }

            },
            dropRoot: "mint-brigade.testnet"
        },
        depositPerUseNEAR: "1",
    })

     // CAAC ONLY DROP
     console.log("CAAC ONLY: trying to claim")
     try{    
         await claim({accountId: "minqianlu.testnet", secretKey: keys.secretKeys[0]})
         let badClaimOnCAAC = await getKeyInformation({publicKey: keys.publicKeys[0]})
         assert(badClaimOnCAAC.remaining_uses == 1, "claim should not work")
     }
     catch{
         console.log("Claim on CAAC only drop rightfully denied")
     }  
 
     console.log("CAAC ONLY: using CAAC")
     const {publicKeys, secretKeys} = await generateKeys({numKeys: 2});
     await claim({ 
         secretKey: keys.secretKeys[0],
         newAccountId: `floodgates.mint-brigade.testnet`, 
         newPublicKey: publicKeys[0]
     })
     let goodCAADonCAAC = await getKeySupplyForDrop({dropId: dropId})
     assert(goodCAADonCAAC == 0, "CAAC has failed unexpectedly")
    
}

async function tests() {
    const network = "testnet"
    const CREDENTIALS_DIR = ".near-credentials";
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);
    const YOUR_ACCOUNT = "minqi.testnet";

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

    let nearConfig = {
        networkId: network,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${network}.near.org`,
        walletUrl: `https://wallet.${network}.near.org`,
        helperUrl: `https://helper.${network}.near.org`,
        explorerUrl: `https://explorer.${network}.near.org`,
    };  

    let near = new Near(nearConfig);
    const fundingAccount = await near.account(YOUR_ACCOUNT);
    const fundingAccountNEW = await near.account("mintlu.testnet");

    // If a NEAR connection is not passed in and is not already running, initKeypom will create a new connection
    // Here we are connecting to the testnet network
    await initKeypom({
        near,
        network
    });

    // await permissionsAndRefundingTests(fundingAccount)
    // await dropDeletionTests(fundingAccountNEW)
    await accountCreationTests(fundingAccount)
}

tests()

'''
'''--- package.json ---
{
  "name": "@keypom/docs",
  "version": "1.0.0",
  "description": "Examples and Tutorials used in the Keypom Documentation",
  "main": "lib/index.js",
  "scripts": {
    "basic:all:keypom": "yarn basic:simple:keypom && yarn basic:nft:keypom && yarn basic:ft:keypom && yarn basic:fc:keypom",
    "basic:all:naj": "yarn basic:simple:naj && yarn basic:nft:naj && yarn basic:ft:naj  && yarn basic:fc:naj ",
    "basic:simple:keypom": "node basic-tutorials/simple-drop/simple-example",
    "basic:nft:keypom": "node basic-tutorials/non-fungible-token-drop/nft-example",
    "basic:ft:keypom": "node basic-tutorials/fungible-token-drop/ft-example",
    "basic:fc:keypom": "node basic-tutorials/function-call-drop/fc-example",
    "basic:simple:naj": "node basic-tutorials/simple-drop/simple-near-example",
    "basic:nft:naj": "node basic-tutorials/non-fungible-token-drop/nft-near-example",
    "basic:ft:naj": "node basic-tutorials/fungible-token-drop/ft-near-example",
    "basic:fc:naj": "node basic-tutorials/function-call-drop/fc-near-example",
    "ticketing:init-skeleton": "yarn && cd advanced-tutorials/ticket-app-skeleton && yarn",
    "ticketing:init-complete": "yarn && cd advanced-tutorials/ticket-app && yarn",
    "ticketing:create-drop": "node advanced-tutorials/ticket-app/utils/createTickDrop",
    "ticketing:start": "cd advanced-tutorials/ticket-app && pnpm start",
    "ticketing:main:start": "cd advanced-tutorials/ticket-app-mainnet && pnpm start",
    "dao:create-drop": "node advanced-tutorials/dao-onboarding/createDaoDrop",
    "dao:create-drop-mainnet": "node advanced-tutorials/dao-onboarding/createDaoDrop-mainnet",
    "trial:create-drop": "node advanced-tutorials/trial-accounts/create-trial-drop"

  },
  "author": "benkurrek, mattlockyer, minqianlu",
  "license": "MIT",
  "dependencies": {
    "@keypom/core": "^1.0.1",
    "@keypom/selector": "^1.1.0",
    "bn.js": "^5.2.1"
  },
  "ava": {
    "require": [
      "dotenv/config"
    ]
  },
  "devDependencies": {
    "typedoc": "^0.23.24",
    "typescript": "^4.8.4",
    "ava": "^4.3.3",
    "dotenv": "^10.0.0",
    "@near-js/accounts": "^0.1.3",
    "@near-js/crypto": "^0.0.4",
    "@near-js/types": "^0.0.4",
    "@near-js/wallet-account": "^0.0.6",
    "@near-js/utils": "^0.0.4",
    "@near-js/keystores-browser": "^0.0.4",
    "@near-js/keystores-node": "^0.0.4",
    "@near-wallet-selector/core": "^8.0.3",
    "react": "^18.2.0",
    "react-dom": "18.2.0",
    "@types/react": "^18.0.26"
  }
}

'''