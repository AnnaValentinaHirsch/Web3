*GitHub Repository "near/near-workspaces-js"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- .github/workflows/lint.yml ---
name: Lint
on:
  pull_request:
  push:
    branches:
      - main
jobs:
  eslint:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - uses: actions/setup-node@v2
      with:
        node-version: '16'
        cache: 'yarn'
    - run: yarn install
    - run: yarn lint

'''
'''--- .github/workflows/tests-sandbox.yml ---
name: Test Sandbox
on:
  pull_request:
  push:
    branches:
      - main
jobs:
  sandbox:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
        node-version: [16]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node-version }}
      - name: Install dependencies
        run: yarn
      - name: Run tests
        run: yarn test:sandbox:ci-with-ignore --fail-fast

'''
'''--- .github/workflows/typedoc-generator.yml ---
name: Deploy TypeDoc on GitHub pages

on:
    push:
      branches:
        main  

env:
  NODE_VERSION: 18.x.x
  ENTRY_FILE: 'packages'
  CONFIG_PATH: 'tsconfig.base.json'
  USES_PNPM: 'true'
  
jobs:
  deploy:
    concurrency: ci-${{ github.ref }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install yarn
        run: npm install -g yarn

      - name: Install dependencies
        run: yarn install

      - name: Build project
        run:  yarn build

      - name: Build documentation
        run:  yarn docs:generate

      - name: Deploy to GitHub pages
        uses: JamesIves/github-pages-deploy-action@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: gh-pages
          folder: docs
          clean: true
'''
'''--- .near-credentials/workspaces/testnet/ro3evqruqecmi7q4uwux1651245117258.json ---
{"account_id":"ro3evqruqecmi7q4uwux1651245117258","public_key":"ed25519:4bf6F3pA2J7DNYeAZNZiPz6FhFbhNCspoSmXeFWvQVVa","private_key":"ed25519:62XEGAGaa3aJhZZgooTXkUFehoV15XG5EaumTWD8sB8qcV7UFCdC2SrmAghmdDBbQ37Ecr58aBRWyXHQxmPrFXSG"}
'''
'''--- .vscode/extensions.json ---
{
	// See https://go.microsoft.com/fwlink/?LinkId=827846 to learn about workspace recommendations.
	// Extension identifier format: ${publisher}.${name}. Example: vscode.csharp
	// List of extensions which should be recommended for users of this workspace.
	"recommendations": [
		"spence-s.linter-xo"
	],
	// List of extensions recommended by VS Code that should not be recommended for users of this workspace.
	"unwantedRecommendations": []
}
'''
'''--- .vscode/settings.json ---
{
  "xo.format.enable": true,
  "xo.overrideSeverity": "info",
  "[javascript]": {
    "editor.defaultFormatter": "spence-s.linter-xo"
  },
  "[typescript]": {
    "editor.defaultFormatter": "spence-s.linter-xo"
  },
  "editor.codeActionsOnSave": {
    "spence-s.linter-xo": true
  }
}
'''
'''--- README.md ---
<div align="center">

  <h1>NEAR Workspaces (TypeScript/JavaScript Edition)</h1>

  [![Project license](https://img.shields.io/badge/license-Apache2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
  [![Project license](https://img.shields.io/badge/license-MIT-blue.svg)](https://opensource.org/licenses/MIT)
  [![Discord](https://img.shields.io/discord/490367152054992913?label=discord)](https://discord.gg/Vyp7ETM)
  [![NPM version](https://img.shields.io/npm/v/near-workspaces.svg?style=flat-square)](https://npmjs.com/near-workspaces)
  [![Size on NPM](https://img.shields.io/bundlephobia/minzip/near-workspaces.svg?style=flat-square)](https://npmjs.com/near-workspaces)

</div>

`NEAR Workspaces` is a library for automating workflows and writing tests for NEAR smart contracts. You can use it as is or integrate with test runner of your choise (AVA, Jest, Mocha, etc.). If you don't have a preference, we suggest you to use AVA.

Quick Start (without testing frameworks)
===========
To get started with `Near Workspaces` you need to do only two things:

1. Initialize a `Worker`.

    ```ts
    const worker = await Worker.init();
    const root = worker.rootAccount;

    const alice = await root.createSubAccount('alice');
    const contract = await root.devDeploy('path/to/compiled.wasm');
    ```

   Let's step through this.

   1. `Worker.init` initializes a new `SandboxWorker` or `TestnetWorker` depending on the config. `SandboxWorker` contains [NEAR Sandbox](https://github.com/near/sandbox), which is essentially a local mini-NEAR blockchain. You can create one `Worker` per test to get its own data directory and port (for Sandbox) or root account (for Testnet), so that tests can run in parallel without race conditions in accessing states. If there's no state intervention. you can also reuse the `Worker` to speedup the tests.
   2. The worker has a `root` account. For `SandboxWorker`, it's `test.near`. For `TestnetWorker`, it creates a unique account. The following accounts are created as subaccounts of the root account. The name of the account will change from different runs, so you should not refer to them by hard coded account name. You can access them via the account object, such as `root`, `alice` and `contract` above.
   3. `root.createSubAccount` creates a new subaccount of `root` with the given name, for example `alice.<root-account-name>`.
   4. `root.devDeploy` creates an account with random name, then deploys the specified Wasm file to it.
   5. `path/to/compiled.wasm` will resolve relative to your project root. That is, the nearest directory with a `package.json` file, or your current working directory if no `package.json` is found. To construct a path relative to your test file, you can use `path.join(__dirname, '../etc/etc.wasm')` ([more info](https://nodejs.org/api/path.html#path_path_join_paths)).
   6. `worker` contains a reference to this data directory, so that multiple tests can use it as a starting point.
   7. If you're using a test framework, you can save the `worker` object and account objects `root`, `alice`, `contract` to test context to reuse them in subsequent tests.
   8. At the end of test, call `await worker.tearDown()` to shuts down the Worker. It gracefully shuts down the Sandbox instance it ran in the background. However, it keeps the data directory around. That's what stores the state of the two accounts that were created (`alice` and `contract-account-name` with its deployed contract).

2. Writing tests.

   `near-workspaces` is designed for concurrency. Here's a simple way to get concurrent runs using plain JS:

   ```ts
   import {strict as assert} from 'assert';

   await Promise.all([
     async () => {
       await alice.call(
         contract,
         'some_update_function',
         {some_string_argument: 'cool', some_number_argument: 42}
       );
       const result = await contract.view(
         'some_view_function',
         {account_id: alice}
       );
       assert.equal(result, 'whatever');
     },
     async () => {
       const result = await contract.view(
         'some_view_function',
         {account_id: alice}
       );
       /* Note that we expect the value returned from `some_view_function` to be
       a default here, because this `fork` runs *at the same time* as the
       previous, in a separate local blockchain */
       assert.equal(result, 'some default');
     }
   ]);
   ```

   Let's step through this.

   1. `worker` and accounts such as `alice` are created before.
   2. `call` syntax mirrors [near-cli](https://github.com/near/near-cli) and either returns the successful return value of the given function or throws the encountered error. If you want to inspect a full transaction and/or avoid the `throw` behavior, you can use `callRaw` instead.
   3. While `call` is invoked on the account _doing the call_ (`alice.call(contract, …)`), `view` is invoked on the account _being viewed_ (`contract.view(…)`). This is because the caller of a view is irrelevant and ignored.

See the [tests](https://github.com/near/workspaces-js/tree/main/__tests__) directory in this project for more examples.

Quick Start with AVA
===========
Since `near-workspaces` is designed for concurrency, AVA is a great fit, because it runs tests concurrently by default. To use`NEAR Workspaces` with AVA:
 1. Start with the basic setup described [here](https://github.com/avajs/ava).
 2. Add custom script for running tests on Testnet (if needed). Check instructions in `Running on Testnet` section.
 3. Add your tests following these example:

  ```ts
  import {Worker} from 'near-workspaces';
  import anyTest, {TestFn} from 'ava'

  const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
  }>;

  /* If using `test.before`, each test is reusing the same worker;
  If you'd like to make a copy of the worker, use `beforeEach` after `afterEach`,
  which allows you to isolate the state for each test */
  test.before(async t => {
    const worker = await Worker.init();
    const root = worker.rootAccount;
    const contract = await root.devDeploy('path/to/contract/file.wasm');
    /* Account that you will be able to use in your tests */
    const ali = await root.createSubAccount('ali');
    t.context.worker = worker;
    t.context.accounts = {root, contract, ali};
  })

  test('Test name', async t => {
    const {ali, contract} = t.context.accounts;
    await ali.call(contract, 'set_status', {message: 'hello'});
    const result: string = await contract.view('get_status', {account_id: ali});
    t.is(result, 'hello');
  });

  test.after(async t => {
    // Stop Sandbox server
    await t.context.worker.tearDown().catch(error => {
      console.log('Failed to tear down the worker:', error);
    });
  });
  ```

"Spooning" Contracts from Testnet and Mainnet
=============================================

[Spooning a blockchain](https://coinmarketcap.com/alexandria/glossary/spoon-blockchain) is copying the data from one network into a different network. near-workspaces makes it easy to copy data from Mainnet or Testnet contracts into your local Sandbox environment:

```ts
const refFinance = await root.importContract({
  mainnetContract: 'v2.ref-finance.near',
  blockId: 50_000_000,
  withData: true,
});
```

This would copy the Wasm bytes and contract state from [v2.ref-finance.near](https://explorer.near.org/accounts/v2.ref-finance.near) to your local blockchain as it existed at block `50_000_000`. This makes use of Sandbox's special [patch state](#patch-state-on-the-fly) feature to keep the contract name the same, even though the top level account might not exist locally (note that this means it only works in Sandbox testing mode). You can then interact with the contract in a deterministic way the same way you interact with all other accounts created with near-workspaces.

Gotcha: `withData` will only work out-of-the-box if the contract's data is 50kB or less. This is due to the default configuration of RPC servers; see [the "Heads Up" note here](https://docs.near.org/api/rpc/contracts#view-contract-state). Some teams at NEAR are hard at work giving you an easy way to run your own RPC server, at which point you can point tests at your custom RPC endpoint and get around the 50kB limit.

See an [example of spooning](https://github.com/near/workspaces-js/blob/main/__tests__/05.spoon-contract-to-sandbox.ava.ts)  contracts.

Running on Testnet
==================

near-workspaces is set up so that you can write tests once and run them against a local Sandbox node (the default behavior) or against [NEAR TestNet](https://docs.near.org/concepts/basics/networks). Some reasons this might be helpful:

* Gives higher confidence that your contracts work as expected
* You can test against deployed testnet contracts
* If something seems off in Sandbox mode, you can compare it to testnet

In order to use Workspaces JS in testnet mode you will need to have a testnet account. You can create one [here](https://wallet.testnet.near.org/).

You can switch to testnet mode in three ways.

1. When creating Worker set network to `testnet` and pass your master account:

   ```ts
   const worker = await Worker.init({
     network: 'testnet',
     testnetMasterAccountId: '<yourAccountName>',
   })
   ```

2. Set the `NEAR_WORKSPACES_NETWORK` and `TESTNET_MASTER_ACCOUNT_ID` environment variables when running your tests:

   ```bash
   NEAR_WORKSPACES_NETWORK=testnet TESTNET_MASTER_ACCOUNT_ID=<your master account Id> node test.js
   ```

   If you set this environment variables and pass `{network: 'testnet', testnetMasterAccountId: <masterAccountId>}` to `Worker.init`, the config object takes precedence.

3. If using `near-workspaces` with AVA, you can use a custom config file. Other test runners allow similar config files; adjust the following instructions for your situation.

   Create a file in the same directory as your `package.json` called `ava.testnet.config.cjs` with the following contents:

   ```js
   module.exports = {
     ...require('near-workspaces/ava.testnet.config.cjs'),
     ...require('./ava.config.cjs'),
   };
   module.exports.environmentVariables = {
        TESTNET_MASTER_ACCOUNT_ID: '<masterAccountId>',
   };
   ```

   The [near-workspaces/ava.testnet.config.cjs](https://github.com/near/workspaces-js/blob/main/ava.testnet.config.cjs) import sets the `NEAR_WORKSPACES_NETWORK` environment variable for you. A benefit of this approach is that you can then easily ignore files that should only run in Sandbox mode.

   Now you'll also want to add a `test:testnet` script to your `package.json`'s `scripts` section:

   ```diff
    "scripts": {
      "test": "ava",
   +  "test:testnet": "ava --config ./ava.testnet.config.cjs"
    }
    ```

Stepping through a testnet example
----------------------------------

Let's revisit a shortened version of the example from How It Works above, describing what will happen in Testnet.

1. Create a `Worker`.

   ```ts
   const worker = await Worker.init();
   ```

   `Worker.init` creates a unique testnet account as root account.

2. Write tests.

   ```ts
   await Promise.all([
     async () => {
       await alice.call(
         contract,
         'some_update_function',
         {some_string_argument: 'cool', some_number_argument: 42}
       );
       const result = await contract.view(
         'some_view_function',
         {account_id: alice}
       );
       assert.equal(result, 'whatever');
     },
     async () => {
       const result = await contract.view(
         'some_view_function',
         {account_id: alice}
       );
       assert.equal(result, 'some default');
     }
   ]);
   ```

Note: Sometimes account creation rate limits are reached on testnet, simply wait a little while and try again.

Running tests only in Sandbox
-------------------------------

If some of your runs take advantage of Sandbox-specific features, you can skip these on testnet in two ways:

1. You can skip entire sections of your files by checking `getNetworkFromEnv() === 'sandbox'`.

  ```ts
  let worker = Worker.init();
  // things make sense to any network
  const root = worker.rootAccount;
  const alice = await root.createSubAccount('alice');

  if (getNetworkFromEnv() === 'sandbox') {
    // thing that only makes sense with sandbox
  }
  ```

2. Use a separate testnet config file, as described under the "Running on Testnet" heading above. Specify test files to include and exclude in config file.

Patch State on the Fly
======================

In Sandbox-mode, you can add or modify any contract state, contract code, account or access key with `patchState`.

You cannot perform arbitrary mutation on contract state with transactions since transactions can only include contract calls that mutate state in a contract-programmed way. For example, with an NFT contract, you can perform some operation with NFTs you have ownership of, but you cannot manipulate NFTs that are owned by other accounts since the smart contract is coded with checks to reject that. This is the expected behavior of the NFT contract. However, you may want to change another person's NFT for a test setup. This is called "arbitrary mutation on contract state" and can be done with `patchState`. Alternatively you can stop the node, dump state at genesis, edit genesis, and restart the node. The later approach is more complicated to do and also cannot be performed without restarting the node.

It is true that you can alter contract code, accounts, and access keys using normal transactions via the `DeployContract`, `CreateAccount`, and `AddKey` [actions](https://nomicon.io/RuntimeSpec/Actions.html?highlight=actions#actions). But this limits you to altering your own account or sub-account. `patchState` allows you to perform these operations on any account.

To see an example of how to do this, see the [patch-state test](https://github.com/near/workspaces-js/blob/main/__tests__/02.patch-state.ava.ts).

Time Traveling
===============

In Sandbox-mode, you can forward time-related state (the block height, timestamp and epoch height) with `fastForward`.

This means contracts which require time sensitive data do not need to sit and wait the same amount of time for blocks on the sandbox to be produced.
We can simply just call the api to get us further in time.

For an example, see the [fast-forward test](./__tests__/08.fast-forward.ava.ts)

Note: `fastForward` does not speed up an in-flight transactions.

Pro Tips
========

* `NEAR_WORKSPACES_DEBUG=true` – run tests with this environment variable set to get copious debug output and a full log file for each Sandbox instance.

* `Worker.init` [config](https://github.com/near/workspaces-js/blob/main/packages/js/src/interfaces.ts) – you can pass a config object as the first argument to `Worker.init`. This lets you do things like:

  * skip initialization if specified data directory already exists (the default behavior)

    ```ts
    Worker.init(
      { rm: false, homeDir: './test-data/alice-owns-an-nft' },
    )
    ```

  * always recreate such data directory instead with `rm: true`

  * specify which port to run on

  * and more!

Env variables
========
```text
NEAR_CLI_MAINNET_RPC_SERVER_URL
NEAR_CLI_TESTNET_RPC_SERVER_URL
```
Clear them in case you want to get back to the default RPC server.

Example:

```shell
export NEAR_CLI_MAINNET_RPC_SERVER_URL=<put_your_rpc_server_url_here>
```
here is a testcase: [jsonrpc.ava.js](./packages/js/__tests__/jsonrpc.ava.js)

'''
'''--- __tests__/01.basic-transactions.ava.ts ---
/**
 * This test demonstrates basic behavior of near-workspaces, making simple
 * function calls and view calls to the contract from
 * https://github.com/near-examples/rust-status-message
 *
 * Note that the same tests will be run on both a local sandbox environment and
 * on testnet by using the `test:sandbox` and `test:testnet` scripts in
 * package.json.
 */
import {Worker, NEAR, NearAccount} from 'near-workspaces';
import anyTest, {TestFn} from 'ava';

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async t => {
  // Init the worker and start a Sandbox server
  const worker = await Worker.init();

  // Prepare sandbox for tests, create accounts, deploy contracts, etx.
  const root = worker.rootAccount;
  const contract = await root.devDeploy(
    '__tests__/build/debug/status_message.wasm',
    {initialBalance: NEAR.parse('3 N').toJSON()},
  );
  const ali = await root.createSubAccount('ali', {initialBalance: NEAR.parse('3 N').toJSON()});

  // Save state for test runs, it is unique for each test
  t.context.worker = worker;
  t.context.accounts = {root, contract, ali};
});

test.afterEach.always(async t => {
  // Stop Sandbox server
  await t.context.worker.tearDown().catch(error => {
    console.log('Failed to tear down the worker:', error);
  });
});

test('Root gets null status', async t => {
  const {root, contract} = t.context.accounts;
  const result: null = await contract.view('get_status', {account_id: root.accountId});
  t.is(result, null);
});

test('Ali sets then gets status', async t => {
  const {ali, contract} = t.context.accounts;
  await ali.call(contract, 'set_status', {message: 'hello'});
  const result: string = await contract.view('get_status', {account_id: ali});
  t.is(result, 'hello');
});

test('Root and Ali have different statuses', async t => {
  const {root, contract, ali} = t.context.accounts;
  await root.call(contract, 'set_status', {message: 'world'});
  const rootStatus: string = await contract.view('get_status', {account_id: root});
  t.is(rootStatus, 'world');
  const aliStatus: null = await contract.view('get_status', {account_id: ali});
  t.is(aliStatus, null);
});

'''
'''--- __tests__/03.single-use-access-keys-with-linkdrop.ava.ts ---
/**
 * This test verifies the functionality of the contract at
 * https://github.com/near/near-linkdrop
 *
 * An interesting feature of this contract: when someone first visits a linkdrop
 * page, they don't yet have a NEAR account. But they still make a call to the
 * contract! How? From the contract's perspective, it _calls itself_ (see
 * `linkdrop.call(linkdrop, …)` below) using a Function Call access key, which
 * can only call one function (`create_account_and_claim`) and which is only
 * good for one use.
 *
 * You can see this functionality in action below using `signWithKey`.
 */
import {Worker, createKeyPair, NEAR, NearAccount} from 'near-workspaces';
import anyTest, {TestFn} from 'ava';

/* Contract API for reference
impl Linkdrop {
  pub fn create_account(new_account_id: &str, new_public_key: &str){}
  pub fn get_key_balance(public_key: &str){}
  pub fn send(public_key: &str){}
  pub fn create_account_and_claim(new_account_id: &str, new_public_key: &str){}
  pub fn on_account_created(predecessor_account_id: &str, amount: &str){}
  pub fn on_account_created_and_claimed(amount: &str){}
  pub fn claim(account_id: &str){}
}
*/

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async t => {
  const worker = await Worker.init();
  const root = worker.rootAccount;
  const linkdrop = await root.devDeploy(
    '__tests__/build/debug/linkdrop.wasm',
    {initialBalance: NEAR.parse('3 N').toJSON()},
  );

  t.context.worker = worker;
  t.context.accounts = {root, linkdrop};
});

test.afterEach.always(async t => {
  await t.context.worker.tearDown().catch(error => {
    console.log('Failed to tear down the worker:', error);
  });
});

test('Use `create_account_and_claim` to create a new account', async t => {
  const {root, linkdrop} = t.context.accounts;
  // Create temporary keys for access key on linkdrop
  const senderKey = createKeyPair();
  const public_key = senderKey.getPublicKey().toString();
  const attachedDeposit = '2 N';

  // This adds the key as a function access key on `create_account_and_claim`
  await root.call(linkdrop, 'send', {public_key}, {attachedDeposit});

  const new_account_id = `bob.${linkdrop.accountId}`;
  const actualKey = createKeyPair();
  const new_public_key = actualKey.getPublicKey().toString();

  await linkdrop.callRaw(
    linkdrop,
    'create_account_and_claim',
    {
      new_account_id,
      new_public_key,
    },
    {
      signWithKey: senderKey,
      gas: '50 TGas',
    },
  );

  const bob = root.getAccount(new_account_id);
  const balance = await bob.availableBalance();
  t.log(balance.toHuman());
  t.deepEqual(balance, NEAR.parse('0.99818'));

  t.log(`Account ${new_account_id} claim and has ${balance.toHuman()} available`);
});

test('Use `claim` to transfer to an existing account', async t => {
  const {root, linkdrop} = t.context.accounts;
  const bob = await root.createSubAccount('bob', {initialBalance: NEAR.parse('3 N').toJSON()});
  const originalBalance = await bob.availableBalance();
  // Create temporary keys for access key on linkdrop
  const senderKey = createKeyPair();
  const public_key = senderKey.getPublicKey().toString();
  const attachedDeposit = '2 N';

  // This adds the key as a function access key on `create_account_and_claim`
  await root.call(linkdrop, 'send', {public_key}, {attachedDeposit});
  // Can only create subaccounts

  await linkdrop.callRaw(
    linkdrop,
    'claim',
    {
      account_id: bob,
    },
    {
      signWithKey: senderKey,
      gas: '50 TGas',
    },
  );

  const newBalance = await bob.availableBalance();

  t.assert(originalBalance.lt(newBalance));
  t.log(
    `${bob.accountId} claimed ${newBalance
      .sub(originalBalance).toHuman()}`,
  );
});

'''
'''--- __tests__/04.cross-contract-calls-with-fungible-token.ava.ts ---
/**
 * This tests the behavior of the standard FT contract at
 * https://github.com/near/near-sdk-rs/tree/master/examples/fungible-token
 *
 * Some advanced features of near-workspaces this shows off:
 *
 * - Cross-Contract Calls: the "defi" contract implements basic features that
 *   might be used by a marketplace contract. You can see its source code at the
 *   near-sdk-rs link above. Several FT methods make cross-contract calls, and
 *   these are tested below using this "defi" contract.
 *
 * - Complex transactions: to exercise certain edge cases of the FT standard,
 *   tests below initiate chains of transactions using near-workspaces's transaction
 *   builder. Search for `batch` below.
 */
import {Worker, NearAccount, captureError, BN, NEAR} from 'near-workspaces';
import anyTest, {TestFn} from 'ava';

const STORAGE_BYTE_COST = '1.5 mN';

async function init_ft(
  ft: NearAccount,
  owner: NearAccount,
  supply: BN | string = '10000',
) {
  await ft.call(ft, 'new_default_meta', {
    owner_id: owner,
    total_supply: supply,
  });
}

async function init_defi(defi: NearAccount, ft: NearAccount) {
  await defi.call(defi, 'new', {
    fungible_token_account_id: ft,
  });
}

async function registerUser(ft: NearAccount, user: NearAccount) {
  await user.call(
    ft,
    'storage_deposit',
    {account_id: user},
    // Deposit pulled from ported sim test
    {attachedDeposit: STORAGE_BYTE_COST},
  );
}

async function ft_balance_of(ft: NearAccount, user: NearAccount): Promise<BN> {
  return new BN(await ft.view('ft_balance_of', {
    account_id: user,
  }));
}

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async t => {
  const worker = await Worker.init();
  const root = worker.rootAccount;
  const ft = await root.devDeploy(
    '__tests__/build/debug/fungible_token.wasm',
    {initialBalance: NEAR.parse('3 N').toJSON()},
  );
  const defi = await root.devDeploy(
    '__tests__/build/debug/defi.wasm',
    {initialBalance: NEAR.parse('3 N').toJSON()},
  );
  const ali = await root.createSubAccount('ali', {initialBalance: NEAR.parse('1 N').toJSON()});

  t.context.worker = worker;
  t.context.accounts = {root, ft, defi, ali};
});

test.afterEach.always(async t => {
  await t.context.worker.tearDown().catch(error => {
    console.log('Failed to tear down the worker:', error);
  });
});

test('Total supply', async t => {
  const {ft, ali} = t.context.accounts;
  await init_ft(ft, ali, '1000');

  const totalSupply: string = await ft.view('ft_total_supply');
  t.is(totalSupply, '1000');
});

test('Simple transfer', async t => {
  const {ft, ali, root} = t.context.accounts;
  const initialAmount = new BN('10000');
  const transferAmount = new BN('100');
  await init_ft(ft, root, initialAmount);

  // Register by prepaying for storage.
  await registerUser(ft, ali);

  await root.call(
    ft,
    'ft_transfer',
    {
      receiver_id: ali,
      amount: transferAmount,
    },
    {attachedDeposit: '1'},
  );

  const rootBalance = await ft_balance_of(ft, root);
  const aliBalance = await ft_balance_of(ft, ali);

  t.deepEqual(new BN(rootBalance), initialAmount.sub(transferAmount));
  t.deepEqual(new BN(aliBalance), transferAmount);
});

test('Can close empty balance account', async t => {
  const {ft, ali, root} = t.context.accounts;
  await init_ft(ft, root);

  await registerUser(ft, ali);

  const result = await ali.call(
    ft,
    'storage_unregister',
    {},
    {attachedDeposit: '1'},
  );

  t.is(result, true);
});

test('Can force close non-empty balance account', async t => {
  const {ft, root} = t.context.accounts;

  await init_ft(ft, root, '100');

  const errorString = await captureError(async () =>
    root.call(ft, 'storage_unregister', {}, {attachedDeposit: '1'}));
  t.regex(errorString, /Can't unregister the account with the positive balance without force/);

  const result = await root.callRaw(
    ft,
    'storage_unregister',
    {force: true},
    {attachedDeposit: '1'},
  );

  t.is(result.logs[0],
    `Closed @${root.accountId} with 100`,
  );
});

test('Transfer call with burned amount', async t => {
  const {ft, defi, root} = t.context.accounts;

  const initialAmount = new BN(10_000);
  const transferAmount = new BN(100);
  const burnAmount = new BN(10);
  await init_ft(ft, root, initialAmount);
  await init_defi(defi, ft);

  await registerUser(ft, defi);
  const result = await root
    .batch(ft)
    .functionCall(
      'ft_transfer_call',
      {
        receiver_id: defi,
        amount: transferAmount,
        msg: burnAmount,
      },
      {attachedDeposit: '1', gas: '150 Tgas'},
    )
    .functionCall(
      'storage_unregister',
      {force: true},
      {attachedDeposit: '1', gas: '150 Tgas'},
    )
    .transact();

  t.true(result.logs.includes(
    `Closed @${root.accountId} with ${
      (initialAmount.sub(transferAmount)).toString()}`,
  ));

  t.is(result.parseResult(), true);

  t.true(result.logs.includes(
    'The account of the sender was deleted',
  ));

  t.true(result.logs.includes(
    `Account @${root.accountId} burned ${burnAmount.toString()}`,
  ));

  // Help: this index is diff from sim, we have 10 len when they have 4
  const callbackOutcome = result.receipts_outcomes[5];
  t.is(callbackOutcome.parseResult(), transferAmount.toString());
  const expectedAmount = transferAmount.sub(burnAmount);
  const totalSupply: string = await ft.view('ft_total_supply');
  t.is(totalSupply, expectedAmount.toString());
  const defiBalance = await ft_balance_of(ft, defi);
  t.deepEqual(defiBalance, expectedAmount);
});

test('Transfer call immediate return no refund', async t => {
  const {ft, defi, root} = t.context.accounts;
  const initialAmount = new BN(10_000);
  const transferAmount = new BN(100);
  await init_ft(ft, root, initialAmount);
  await init_defi(defi, ft);

  await registerUser(ft, defi);

  await root.call(
    ft,
    'ft_transfer_call',
    {
      receiver_id: defi,
      amount: transferAmount,
      memo: null,
      msg: 'take-my-money',
    },
    {attachedDeposit: '1', gas: '150 Tgas'},
  );

  const rootBalance = await ft_balance_of(ft, root);
  const defiBalance = await ft_balance_of(ft, defi);

  t.deepEqual(rootBalance, initialAmount.sub(transferAmount));
  t.deepEqual(defiBalance, transferAmount);
});

test('Transfer call promise panics for a full refund', async t => {
  const {ft, defi, root} = t.context.accounts;
  const initialAmount = new BN(10_000);
  const transferAmount = new BN(100);
  await init_ft(ft, root, initialAmount);
  await init_defi(defi, ft);

  await registerUser(ft, defi);

  const result = await root.callRaw(
    ft,
    'ft_transfer_call',
    {
      receiver_id: defi,
      amount: transferAmount,
      memo: null,
      msg: 'this won\'t parse as an integer',
    },
    {attachedDeposit: '1', gas: '150 Tgas'},
  );

  t.regex(result.receiptFailureMessages.join('\n'), /ParseIntError/);

  const rootBalance = await ft_balance_of(ft, root);
  const defiBalance = await ft_balance_of(ft, defi);

  t.deepEqual(rootBalance, initialAmount);
  t.assert(defiBalance.isZero(), `Expected zero got ${defiBalance.toJSON()}`);
});

'''
'''--- __tests__/05.spoon-contract-to-sandbox.ava.ts ---
/**
 * This test shows how to "spoon" a contract from testnet or mainnet to your
 * local sandbox environment. "Spooning" is copying a contract's bytes (compiled
 * source code) and data from one network and pasting it into another.
 *
 * This test shows off how to spoon just contract bytes from mainnet. You could
 * do the same with testnet: just replace the `mainnetContract` lines below with
 * a `testnetContract` equivalent.
 *
 * You can use `withData` to also pull the data of a contract. However, at this
 * time most RPC endpoints limit these queries to 50kB (see the "Heads Up" at
 * https://docs.near.org/docs/api/rpc/contracts#view-contract-state). Some teams
 * at NEAR are hard at work giving you an easy way to run your own RPC server,
 * at which point you can point tests at your custom RPC endpoint and get around
 * the 50kB limit.
 *
 * Even without the ability to fetch the data, being able to test against "live"
 * contracts can give you a huge confidence boost that your contracts will work
 * as expected once actually deployed.
 */
import {Gas, NEAR, NearAccount, Worker, captureError} from 'near-workspaces';
import anyTest, {TestFn} from 'ava';

const REF_FINANCE_ACCOUNT = 'v2.ref-finance.near';

const DEFAULT_BLOCK_HEIGHT = 45_800_000;

const INIT_SHARES_SUPPLY = '1000000000000000000000000';

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async t => {
  t.context.worker = await Worker.init();
});

test.afterEach.always(async t => {
  await t.context.worker.tearDown().catch(error => {
    console.log('Failed to tear down the worker:', error);
  });
});

test('using `withData` for contracts > 50kB fails', async t => {
  const root = t.context.worker.rootAccount;

  const error_response = await captureError(async () => {
    await root.importContract({
      mainnetContract: REF_FINANCE_ACCOUNT,
      withData: true,
      blockId: 50_000_000,
    });
  });
  t.assert(
    error_response.includes('is larger than allowed') || error_response.includes('is too large to be viewed'),
  );
});

test('if skipping `withData`, fetches only contract Wasm bytes', async t => {
  const root = t.context.worker.rootAccount;

  const refFinance = await root.importContract({
    mainnetContract: REF_FINANCE_ACCOUNT,
    blockId: DEFAULT_BLOCK_HEIGHT,
  });
  t.regex(
    await captureError(async () => refFinance.view('version')),
    /The contract is not initialized/,
  );
});

/**
     * This test copies logic from the Ref.Finance source code:
     * https://github.com/ref-finance/ref-contracts/blob/e96a6b5e3b403a3ba5271b6a03843a50b3e54a4f/ref-exchange/src/lib.rs#L454-L501
     *
     * However, this test also has some cool upgrades compared to the tests there:
     *
     *   - Whereas Rust unit tests can only interact with one contract, this
     *     test makes actual cross-contract calls (compare `depositTokens` here to
     *     `deposit_tokens` at the link above, for example).
     *   - It uses a local Fungible Token contract while pulling "live" versions
     *     of Ref Finance and wNEAR. Using this approach can help give you
     *     confidence that your contracts work as expected with deployed contracts
     *     on testnet or mainnet.
     */
test('integrate own FT with Ref.Finance', async t => {
  const root = t.context.worker.rootAccount;

  const [ft, refFinance, wNEAR] = await Promise.all([
    root.devDeploy(
      '__tests__/build/debug/fungible_token.wasm',
      {
        method: 'new_default_meta',
        args: {
          owner_id: root,
          total_supply: NEAR.parse('1,000,000,000 N'),
        },
      }),
    createRef(root),
    createWNEAR(root),
  ]);
  const pool_id = await createPoolWithLiquidity(root, refFinance, {
    [ft.accountId]: NEAR.parse('5 N').toJSON(),
    [wNEAR.accountId]: NEAR.parse('10 N').toJSON(),
  });
  await depositTokens(root, refFinance, {
    [ft.accountId]: NEAR.parse('100 N').toJSON(),
    [wNEAR.accountId]: NEAR.parse('100 N').toJSON(),
  });
  await depositTokens(root, refFinance, {});
  t.is(
    await refFinance.view('get_deposit', {account_id: root, token_id: ft}),
    NEAR.parse('100 N').toJSON(),
  );
  t.is(
    await refFinance.view('get_deposit', {account_id: root, token_id: wNEAR}),
    NEAR.parse('100 N').toJSON(),
  );
  t.is(
    await refFinance.view('get_pool_total_shares', {pool_id}),
    INIT_SHARES_SUPPLY,
  );

  // Get price from pool :0 1 -> 2 tokens.
  const expectedOut: string = await refFinance.view('get_return', {
    pool_id,
    token_in: ft,
    amount_in: NEAR.parse('1 N'),
    token_out: wNEAR,
  });
  t.is(expectedOut, '1662497915624478906119726');
  const amountOut: string = await root.call(refFinance, 'swap', {actions: [{
    pool_id,
    token_in: ft,
    amount_in: NEAR.parse('1 N'),
    token_out: wNEAR,
    min_amount_out: '1',
  }]}, {
    attachedDeposit: '1',
  });
  t.is(amountOut, expectedOut);
  t.is(
    await refFinance.view('get_deposit', {account_id: root, token_id: ft}),
    NEAR.parse('99 N').toJSON(),
  );
});

// Contract: https://github.com/near/core-contracts/blob/master/w-near
async function createWNEAR(
  creator: NearAccount,
  blockId = DEFAULT_BLOCK_HEIGHT,
): Promise<NearAccount> {
  const wNEAR = await creator.importContract({
    mainnetContract: 'wrap.near',
    blockId,
  });
  await creator.call(wNEAR, 'new', {
    owner_id: creator,
    total_supply: NEAR.parse('1,000,000,000 N'),
  });
  await creator.call(wNEAR, 'storage_deposit', {}, {
    attachedDeposit: NEAR.parse('0.008 N'),
  });
  await creator.call(wNEAR, 'near_deposit', {}, {
    attachedDeposit: NEAR.parse('200 N'),
  });
  return wNEAR;
}

// Contract: https://github.com/ref-finance/ref-contracts/
async function createRef(
  creator: NearAccount,
  blockId = DEFAULT_BLOCK_HEIGHT,
): Promise<NearAccount> {
  const refFinance = await creator.importContract({
    mainnetContract: REF_FINANCE_ACCOUNT,
    blockId,
    initialBalance: NEAR.parse('1000 N').toJSON(),
  });
  await creator.call(
    refFinance,
    'new',
    {
      owner_id: creator,
      exchange_fee: 4,
      referral_fee: 1,
    },
  );
  await creator.call(refFinance, 'storage_deposit', {}, {
    attachedDeposit: NEAR.parse('30 mN'),
  });
  return refFinance;
}

  type AccountID = string;

async function createPoolWithLiquidity(
  root: NearAccount,
  refFinance: NearAccount,
  tokenAmounts: Record<AccountID, string>,
): Promise<string> {
  const tokens = Object.keys(tokenAmounts);
  await root.call(refFinance, 'extend_whitelisted_tokens', {tokens});
  const pool_id: string = await root.call(refFinance, 'add_simple_pool', {tokens, fee: 25}, {
    attachedDeposit: NEAR.parse('3mN'),
  });
  await root.call(refFinance, 'register_tokens', {token_ids: tokens}, {
    attachedDeposit: '1',
  });
  await depositTokens(root, refFinance, tokenAmounts);
  await root.call(refFinance, 'add_liquidity', {
    pool_id,
    amounts: Object.values(tokenAmounts),
  }, {
    attachedDeposit: NEAR.parse('1N'),
  });
  return pool_id;
}

async function depositTokens(
  root: NearAccount,
  refFinance: NearAccount,
  tokenAmounts: Record<AccountID, string>,
): Promise<void> {
  await Promise.all(Object.entries(tokenAmounts).map(async ([accountId, amount]) => {
    await refFinance.call(accountId, 'storage_deposit', {registration_only: true}, {
      attachedDeposit: NEAR.parse('1N'),
    });
    await root.call(accountId, 'ft_transfer_call', {
      receiver_id: refFinance,
      amount,
      msg: '',
    }, {
      attachedDeposit: '1',
      gas: Gas.parse('200Tgas'),
    });
  }));
}

'''
'''--- __tests__/06.init-config.ava.ts ---
import {getNetworkFromEnv, NearAccount, Worker} from 'near-workspaces';
import anyTest, {TestFn} from 'ava';

if (getNetworkFromEnv() === 'testnet') {
  const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
  }>;

  test.beforeEach(async t => {
    t.context.worker = await Worker.init({
      network: 'testnet',
      rootAccountId: 'meta',
    });
  });

  test.afterEach.always(async t => {
    await t.context.worker.tearDown().catch(error => {
      console.log('Failed to tear down the worker:', error);
    });
  });

  test('Inspecting an account on testnet', async t => {
    // The rootAccointId is not meta anymore, invertigate if it's important
    // const root = t.context.worker.rootAccount;
    // t.is(root.accountId, 'meta');
    // t.assert(await root.exists());
    t.assert(true);
  });
}

'''
'''--- __tests__/07.resue-worker.ava.ts ---
/**
 * This test file demonstrates the reuse of the Worker across several tests.
 * The maine differance is the usage of before() and after() AVA functions
 * instead of beforeEach() and after each.
 * Keep in mind that tests are executed in parallel.
 * It means that they should not depend on each other.
 */
import {Worker, NEAR, NearAccount} from 'near-workspaces';
import anyTest, {TestFn} from 'ava';

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

test.before(async t => {
  const worker = await Worker.init();

  const root = worker.rootAccount;
  const contract = await root.devDeploy(
    '__tests__/build/debug/status_message.wasm',
    {initialBalance: NEAR.parse('3 N').toJSON()},
  );
  const ali = await root.createSubAccount('ali', {initialBalance: NEAR.parse('3 N').toJSON()});

  t.context.worker = worker;
  t.context.accounts = {root, contract, ali};
});

test.after.always(async t => {
  await t.context.worker.tearDown().catch(error => {
    console.log('Failed to tear down the worker:', error);
  });
});

test('Root gets null status', async t => {
  const {root, contract} = t.context.accounts;
  const result: null = await contract.view('get_status', {account_id: root.accountId});
  t.is(result, null);
});

test('Ali sets then gets status', async t => {
  const {ali, contract} = t.context.accounts;
  await ali.call(contract, 'set_status', {message: 'hello'});
  const result: string = await contract.view('get_status', {account_id: ali});
  t.is(result, 'hello');
});

'''
'''--- __tests__/08.custom-network.ava.ts ---
import process from 'process';
import {Worker, getNetworkFromEnv} from 'near-workspaces';
import anyTest, {TestFn} from 'ava';

// To run this test, you need to set the NEAR_RPC_API_KEY environment variable tied the Pagoda testnet network.
// And the NEAR_WORKSPACES_NETWORK environment variable to 'custom'.
//
// Sample: NEAR_WORKSPACES_NETWORK=custom NEAR_RPC_API_KEY="xxx" yarn test...
if (getNetworkFromEnv() === 'custom' && process.env.NEAR_RPC_API_KEY !== '') {
  const test = anyTest as TestFn<{
    worker: Worker;
  }>;

  test.before(async t => {
    const worker = await Worker.init({
      network: 'custom',
      rpcAddr: 'https://near-testnet.api.pagoda.co/rpc/v1/',
      apiKey: process.env.NEAR_RPC_API_KEY!,
    });
    t.context.worker = worker;
  });

  test.after.always(async t => {
    await t.context.worker.tearDown().catch(error => {
      console.log('Failed to tear down the worker:', error);
    });
  });

  test('Ping network', async t => {
    try {
      await t.context.worker.provider.block({finality: 'final'});
    } catch (error: unknown) {
      t.fail(`Failed to ping the network: ${error as string}`);
      return;
    }

    t.pass('Network pinged successfully!');
  });
}

'''
'''--- __tests__/08.fast-forward.ava.ts ---
import {NearAccount, getNetworkFromEnv} from 'near-workspaces';
import anyTest, {TestFn} from 'ava';
import {Worker} from 'near-workspaces/dist/worker';

// The contract provided contains only one view call, returning the
// block_timestamp and epoch_height of the current block as a tuple.
// Source is here <https://github.com/near/near-workspaces-rs/blob/main/examples/simple-contract/src/lib.rs>
const contract_wasm = '__tests__/build/debug/simple_contract.wasm';

// Represents the timestamp and epoch_height result from the view call.
type EnvData = [number, number];

if (getNetworkFromEnv() === 'sandbox') {
  const test = anyTest as TestFn<{
    worker: Worker;
    contract: NearAccount;
  }>;

  test.beforeEach(async t => {
    const worker = await Worker.init();
    const root = worker.rootAccount;
    const contract = await root.devDeploy(contract_wasm);

    t.context.worker = worker;
    t.context.contract = contract;
  });

  test.afterEach.always(async t => {
    await t.context.worker.tearDown().catch(error => {
      console.log('Failed to tear down the worker:', error);
    });
  });

  test('Fast Forward', async t => {
    const before = await t.context.contract.view('current_env_data');
    const env_before = before as EnvData;
    console.log(`Before: timestamp = ${env_before[0]}, epoch_height = ${env_before[1]}`);

    const forward_height = 10_000;

    // Call into fastForward. This will take a bit of time to invoke, but is
    // faster than manually waiting for the same amounts of blocks to be produced
    await t.context.worker.provider.fastForward(forward_height);

    const after = await t.context.contract.view('current_env_data');
    const env_after = after as EnvData;
    console.log(`After: timestamp = ${env_after[0]}, epoch_height = ${env_after[1]}`);

    const block = await t.context.worker.provider.block({finality: 'final'});

    // Rounding off to nearest hundred, providing wiggle room incase not perfectly `forward_height`
    t.true(Math.ceil(block.header.height / 100) * 100 === forward_height);
  });
}

'''
'''--- __tests__/ci-ignore-02.patch-state.ava.ts ---
/**
 * This test demonstrates patchState behavior, using the contract from
 * https://github.com/near-examples/rust-status-message
 *
 * If you want to make arbitrary modifications to a contract that wouldn't be
 * possible with ordinary function calls, you can use patchState. In a
 * test below, this is used to set the status of an account that is never
 * created within the testing environment, `alice.near`.
 *
 * patchState is a Sandbox-specific feature, so these tests can't be run on
 * testnet. That's why they're wrapped with `if (getNetworkFromEnv() === 'sandbox')`.
 */

/* eslint-disable @typescript-eslint/no-extraneous-class, @typescript-eslint/no-unsafe-member-access */
import * as borsh from 'borsh';
import {Worker, getNetworkFromEnv, NearAccount} from 'near-workspaces';
import {NEAR} from 'near-units';
import anyTest, {TestFn} from 'ava';

if (getNetworkFromEnv() === 'sandbox') {
  const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
  }>;

  test.beforeEach(async t => {
    const worker = await Worker.init();
    const root = worker.rootAccount;
    const contract = await root.devDeploy('__tests__/build/debug/status_message.wasm');
    const ali = await root.createSubAccount('ali');

    t.context.worker = worker;
    t.context.accounts = {root, contract, ali};
  });

  test.afterEach.always(async t => {
    await t.context.worker.tearDown().catch(error => {
      console.log('Failed to tear down the worker:', error);
    });
  });

  class Assignable {
    [key: string]: any;
    constructor(properties: any) {
      for (const key of Object.keys(properties)) {
        this[key] = properties[key];
      }
    }
  }

  class StatusMessage extends Assignable {}

  class BorshRecord extends Assignable {}

  const schema = new Map([
    [StatusMessage, {kind: 'struct', fields: [['records', [BorshRecord]]]}],
    [
      BorshRecord,
      {
        kind: 'struct',
        fields: [
          ['k', 'string'],
          ['v', 'string'],
        ],
      },
    ],
  ]);

  test('View state', async t => {
    const {contract, ali} = t.context.accounts;
    await ali.call(contract, 'set_status', {message: 'hello'});
    const state = await contract.viewState();
    // Get raw value
    const data = state.getRaw('STATE');
    // Deserialize from borsh
    const statusMessage: StatusMessage = borsh.deserialize(
      schema,
      StatusMessage,
      data,
    );
    t.deepEqual(statusMessage.records[0],
      new BorshRecord({k: ali.accountId, v: 'hello'}),
    );
  });

  test('Patch state', async t => {
    const {contract, ali} = t.context.accounts;
    // Contract must have some state for viewState & patchState to work
    await ali.call(contract, 'set_status', {message: 'hello'});
    // Get state
    const state = await contract.viewState();
    // Get raw value
    const statusMessage = state.get('STATE', {schema, type: StatusMessage});
    // Update contract state
    statusMessage.records.push(
      new BorshRecord({k: 'alice.near', v: 'hello world'}),
    );
    // Serialize and patch state back to runtime
    await contract.patchState(
      'STATE',
      borsh.serialize(schema, statusMessage),
    );
    // Check again that the update worked
    const result = await contract.view('get_status', {
      account_id: 'alice.near',
    });
    t.is(result, 'hello world');
  });

  test('Patch Account', async t => {
    const {root, contract, ali} = t.context.accounts;
    const bob = root.getAccount('bob');
    const public_key = await bob.setKey();
    const {code_hash} = await contract.accountView();
    const BOB_BALANCE = NEAR.parse('100 N');

    await bob.updateAccount({
      amount: BOB_BALANCE.toString(),
      code_hash,
    });

    await bob.updateAccessKey(
      public_key,
      {
        nonce: 0,
        permission: 'FullAccess',
      },
    );

    await bob.updateContract(await contract.viewCode());
    const balance = await bob.availableBalance();
    t.deepEqual(balance, BOB_BALANCE);
    await ali.call(bob, 'set_status', {message: 'hello'});
    const result = await bob.view('get_status', {
      account_id: ali.accountId,
    });

    t.is(result, 'hello');
  });
}

'''
'''--- examples/simple-project/README.md ---
# Simple project

This is the simplest project setup example with workspaces-js. You can copy it as the starting point when setup your project. 

## Usage
```
yarn
yarn test
```

## Setup your project

Assume you have written your smart contract. Setup and write workspaces-js test as this project is easy:

1. Build the contract to `.wasm` as place it in `contracts/`.
2. Install the `near-workspaces` and `ava` with `npm` or `yarn`.
3. Copy the ava.config.cjs to you project root directory.
4. Write test, place in `__tests__/`, end with `.ava.js`. You can refer to `__tests__/test-status-message.ava.js` as an example.
5. We're done! Run test with `yarn test` and continue adding more tests!
'''
'''--- examples/simple-project/__tests__/test-simple-project.ava.js ---
/**
 * This test demonstrates basic behavior of near-workspaces, making simple
 * function calls and view calls to the contract from
 * https://github.com/near-examples/rust-status-message
 *
 * Note that the same tests will be run on both a local sandbox environment and
 * on testnet by using the `test:sandbox` and `test:testnet` scripts in
 * package.json.
 */
import {Worker, NEAR} from 'near-workspaces';
import test from 'ava';

test.beforeEach(async t => {
  // Init the worker and start a Sandbox server
  const worker = await Worker.init();

  // Prepare sandbox for tests, create accounts, deploy contracts, etx.
  const root = worker.rootAccount;
  const contract = await root.devDeploy(
      // source code: https://github.com/NEARFoundation/near-smart-contract-rust-template/tree/main
    'contracts/near_smart_contract_rust_template.wasm',
    {initialBalance: NEAR.parse('30 N').toJSON()},
  );
  const ali = await root.createSubAccount('ali', {initialBalance: NEAR.parse('3 N').toJSON()});

  // Save state for test runs, it is unique for each test
  t.context.worker = worker;
  t.context.accounts = {root, contract, ali};
});

test.afterEach.always(async t => {
  // Stop Sandbox server
  await t.context.worker.tearDown().catch(error => {
    console.log('Failed to tear down the worker:', error);
  });
});

test('Root call new', async t => {
  const {contract, ali} = t.context.accounts;
  await ali.call(contract, 'new', {});
});

'''
'''--- examples/simple-project/__tests__/test-status-message.ava.js ---
/**
 * This test demonstrates basic behavior of near-workspaces, making simple
 * function calls and view calls to the contract from
 * https://github.com/near-examples/rust-status-message
 *
 * Note that the same tests will be run on both a local sandbox environment and
 * on testnet by using the `test:sandbox` and `test:testnet` scripts in
 * package.json.
 */
import {Worker, NEAR} from 'near-workspaces';
import test from 'ava';

test.beforeEach(async t => {
  // Init the worker and start a Sandbox server
  const worker = await Worker.init();

  // Prepare sandbox for tests, create accounts, deploy contracts, etx.
  const root = worker.rootAccount;
  const contract = await root.devDeploy(
    'contracts/status_message.wasm',
    {initialBalance: NEAR.parse('3 N').toJSON()},
  );
  const ali = await root.createSubAccount('ali', {initialBalance: NEAR.parse('3 N').toJSON()});

  // Save state for test runs, it is unique for each test
  t.context.worker = worker;
  t.context.accounts = {root, contract, ali};
});

test.afterEach.always(async t => {
  // Stop Sandbox server
  await t.context.worker.tearDown().catch(error => {
    console.log('Failed to tear down the worker:', error);
  });
});

test('Root gets null status', async t => {
  const {root, contract} = t.context.accounts;
  const result = await contract.view('get_status', {account_id: root.accountId});
  t.is(result, null);
});

test('Ali sets then gets status', async t => {
  const {ali, contract} = t.context.accounts;
  await ali.call(contract, 'set_status', {message: 'hello'});
  const result = await contract.view('get_status', {account_id: ali});
  t.is(result, 'hello');
});

test('Root and Ali have different statuses', async t => {
  const {root, contract, ali} = t.context.accounts;
  await root.call(contract, 'set_status', {message: 'world'});
  const rootStatus = await contract.view('get_status', {account_id: root});
  t.is(rootStatus, 'world');
  const aliStatus = await contract.view('get_status', {account_id: ali});
  t.is(aliStatus, null);
});

'''
'''--- examples/simple-project/package.json ---
{
  "name": "simple-project",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "ava"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "near-workspaces": "file:../../packages/js"
  },
  "devDependencies": {
    "ava": "^4.0.1"
  }
}

'''
'''--- lerna.json ---
{
  "npmClient": "yarn",
  "useWorkspaces": true,
  "version": "independent"
}

'''
'''--- package.json ---
{
  "name": "near-workspaces-monorepo",
  "version": "0.0.0",
  "description": "Write tests in TypeScript/JavaScript to run in a controlled NEAR Sandbox local environment.",
  "repository": "https://github.com/near/workspaces-js",
  "author": "Near Inc (team@near.org)",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "build": "yarn workspaces run build",
    "clean:accounts": "ts-node packages/js/scripts/delete-accounts.ts",
    "lint": "xo",
    "lint:fix": "xo --fix",
    "test:testnet": "yarn test:testnet:ci --verbose",
    "test:testnet:ci": "yarn build && TESTNET_MASTER_ACCOUNT_ID='ro3evqruqecmi7q4uwux1651245117258' ava --config ./ava.testnet.config.cjs",
    "test:sandbox": "yarn test:sandbox:ci --verbose",
    "test:sandbox:ci": "yarn build && ava",
    "test:sandbox:ci-with-ignore": "yarn build && ava __tests__/0* && cd examples/simple-project/ && ava && cd ../../packages/js && ava",
    "test": "yarn test:sandbox && yarn test:testnet",
    "prepare": "husky install",
    "release": "yarn lerna publish",
    "release:prerelease": "yarn release --dist-tag next",
    "docs:generate": "typedoc"
  },
  "devDependencies": {
    "@ava/typescript": "^2.0.0",
    "@types/bn.js": "^5.1.0",
    "@types/fs-extra": "^9.0.12",
    "@types/node": "^16.4.10",
    "@types/rimraf": "^3.0.1",
    "ava": "^4.0.1",
    "husky": "^7.0.1",
    "lerna": "^5.2.0",
    "ts-node": "^10.9.1",
    "typedoc": "^0.24",
    "typescript": "^4.7.4",
    "xo": "^0.44.0"
  },
  "engines": {
    "node": "^14.17.0 || >=16.0.0",
    "npm": ">= 6.0.0"
  },
  "xo": {
    "space": true,
    "rules": {
      "unicorn/prefer-node-protocol": 0,
      "unicorn/prefer-module": 0,
      "unicorn/no-array-callback-reference": 0,
      "node/prefer-global/url": 0,
      "ava/no-ignored-test-files": 0,
      "@typescript-eslint/no-unsafe-return": 0
    },
    "ignores": [
      "examples/**/*.js"
    ],
    "overrides": [
      {
        "files": [
          "**/__tests__/**/*.spec.ts",
          "**/__tests__/**/*.ava.ts"
        ],
        "rules": {
          "@typescript-eslint/no-unsafe-assignment": 0,
          "unicorn/prefer-module": 0,
          "@typescript-eslint/no-unsafe-call": 0,
          "@typescript-eslint/no-empty-function": 0,
          "import/no-extraneous-dependencies": 0,
          "import/extensions": 0
        }
      }
    ]
  },
  "private": true,
  "workspaces": [
    "packages/js"
  ]
}
'''
'''--- packages/js/README.md ---
<div align="center">

  <h1>NEAR Workspaces (TypeScript/JavaScript Edition)</h1>

  [![Project license](https://img.shields.io/badge/license-Apache2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
  [![Project license](https://img.shields.io/badge/license-MIT-blue.svg)](https://opensource.org/licenses/MIT)
  [![Discord](https://img.shields.io/discord/490367152054992913?label=discord)](https://discord.gg/Vyp7ETM)
  [![NPM version](https://img.shields.io/npm/v/near-workspaces.svg?style=flat-square)](https://npmjs.com/near-workspaces)
  [![Size on NPM](https://img.shields.io/bundlephobia/minzip/near-workspaces.svg?style=flat-square)](https://npmjs.com/near-workspaces)

</div>

`NEAR Workspaces` is a library for automating workflows and writing tests for NEAR smart contracts. You can use it as is or integrate with test runner of your choise (AVA, Jest, Mocha, etc.). If you don't have a preference, we suggest you to use AVA.

Quick Start (without testing frameworks)
===========
To get started with `Near Workspaces` you need to do only two things:

1. Initialize a `Worker`.

    ```ts
    const worker = await Worker.init();
    const root = worker.rootAccount;

    const alice = await root.createSubAccount('alice');
    const contract = await root.devDeploy('path/to/compiled.wasm');
    ```

2. Writing tests.

   `near-workspaces` is designed for concurrency. Here's a simple way to get concurrent runs using plain JS:

   ```ts
   import {strict as assert} from 'assert';

   await Promise.all([
     async () => {
       await alice.call(
         contract,
         'some_update_function',
         {some_string_argument: 'cool', some_number_argument: 42}
       );
       const result = await contract.view(
         'some_view_function',
         {account_id: alice}
       );
       assert.equal(result, 'whatever');
     },
     async () => {
       const result = await contract.view(
         'some_view_function',
         {account_id: alice}
       );
       /* Note that we expect the value returned from `some_view_function` to be
       a default here, because this `fork` runs *at the same time* as the
       previous, in a separate local blockchain */
       assert.equal(result, 'some default');
     }
   ]);
   ```
    ```

More info in our main README: https://github.com/near/workspaces-js

'''
'''--- packages/js/__tests__/account-manager.ava.ts ---
import anyTest, {TestFn} from 'ava';
import {
  AccountManager,
  TestnetWorker,
  Worker,
  TestnetManager,
  getNetworkFromEnv,
} from '..';

const test = anyTest as TestFn<{worker: Worker}>;

if (getNetworkFromEnv() === 'testnet') {
  test('should create a new account', async t => {
    const accountManager = AccountManager.create(TestnetWorker.defaultConfig);
    await accountManager.init();
    const {root} = accountManager;
    t.true(await root.exists());
  });

  test('should be able to add funds', async t => {
    const accountManager = AccountManager.create(TestnetWorker.defaultConfig) as TestnetManager;
    await accountManager.init();
    const {root} = accountManager;
    const balance = await root.availableBalance();
    await accountManager.addFundsFromNetwork();
    const newBalance = await root.availableBalance();
    t.true(balance.lt(newBalance));
  });
} else {
  test('skipping on ' + getNetworkFromEnv(), t => {
    t.true(true);
  });
}

'''
'''--- packages/js/__tests__/account.ava.ts ---
import path from 'path';
import anyTest, {TestFn} from 'ava';
import {getNetworkFromEnv, NearAccount, Worker} from '..';

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

if (getNetworkFromEnv() === 'sandbox') {
  test.beforeEach(async t => {
    const worker = await Worker.init();
    const root = worker.rootAccount;

    t.context.worker = worker;
    t.context.accounts = {root};
  });

  test.afterEach.always(async t => {
    await t.context.worker.tearDown().catch(error => {
      console.log('Failed to tear down the worker:', error);
    });
  });

  test('deploy', async t => {
    const {root} = t.context.accounts;
    const statusMessage = await root.createSubAccount('statusmessage');
    await statusMessage.deploy(path.join(__dirname, '..', '..', '..', '__tests__', 'build', 'debug', 'status_message.wasm'));
    await root.call(statusMessage, 'set_status', {message: 'hello'});
    const result = await statusMessage.view('get_status', {account_id: root});
    t.is(result, 'hello');
  });

  test('devCreateAccount', async t => {
    const {root} = t.context.accounts;
    const devAcc = await root.devCreateAccount();
    await devAcc.deploy(path.join(__dirname, '..', '..', '..', '__tests__', 'build', 'debug', 'status_message.wasm'));
    await root.call(devAcc, 'set_status', {message: 'hello'});
    const result = await devAcc.view('get_status', {account_id: root});
    t.is(result, 'hello');
  });

  test('viewAccessKeys', async t => {
    const {root} = t.context.accounts;
    const access = await root.viewAccessKeys(root.accountId);
    t.is(access.keys.length, 1);
    t.is(access.keys[0].access_key.permission, 'FullAccess');
  });
}

'''
'''--- packages/js/__tests__/jsonrpc.ava.js ---
import process from 'process';

import test from 'ava';

import {JsonRpcProvider} from '../dist/index.js';

test('check url', t => {
  const provider = JsonRpcProvider.fromNetwork('mainnet');
  if (process.env.NEAR_CLI_MAINNET_RPC_SERVER_URL) {
    console.log('use rpc', process.env.NEAR_CLI_MAINNET_RPC_SERVER_URL);
    t.is(provider.connection.url, process.env.NEAR_CLI_MAINNET_RPC_SERVER_URL.toString());
  }
});

'''
'''--- packages/js/__tests__/record-builder.ava.ts ---
import path from 'path';
import anyTest, {TestFn} from 'ava';
import {NEAR} from 'near-units';
import {getNetworkFromEnv, NearAccount, Worker} from '..';
import {RecordBuilder} from '../dist/record';

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

if (getNetworkFromEnv() === 'sandbox') {
  test.beforeEach(async t => {
    const worker = await Worker.init();
    const root = worker.rootAccount;

    const contract = await root.devDeploy(
      path.join(__dirname, '..', '..', '..', '__tests__', 'build', 'debug', 'status_message.wasm'),
    );
    const ali = await root.createSubAccount('ali');

    t.context.worker = worker;
    t.context.accounts = {root, contract, ali};
  });

  test.afterEach.always(async t => {
    await t.context.worker.tearDown().catch(error => {
      console.log('Failed to tear down the worker:', error);
    });
  });

  test('Patch account', async t => {
    const {root, ali, contract} = t.context.accounts;
    const bob = root.getAccount('bob');
    const public_key = await bob.setKey();
    const {code_hash} = await contract.accountView();
    const BOB_BALANCE = NEAR.parse('100 N');
    const rb = RecordBuilder.fromAccount(bob)
      .account({
        amount: BOB_BALANCE.toString(),
        code_hash,
      }).accessKey(
        public_key,
        {
          nonce: 0,
          permission: 'FullAccess',
        }).contract(await contract.viewCode());
    await bob.patchStateRecords(rb);
    const balance = await bob.availableBalance();
    t.deepEqual(balance, BOB_BALANCE);
    await ali.call(bob, 'set_status', {message: 'hello'});
    const result = await bob.view('get_status', {
      account_id: ali.accountId,
    });
    t.is(result, 'hello');
  });
} else {
  test('skipping; not using sandbox', t => {
    t.true(true);
    // Ava requires a test in each file
  });
}

'''
'''--- packages/js/dist/account/account-manager.d.ts ---
import * as nearAPI from 'near-api-js';
import { NEAR } from 'near-units';
import { Config, KeyPair, BN, KeyStore, AccountBalance, NamedAccount, PublicKey, AccountView } from '../types';
import { Transaction } from '../transaction';
import { JsonRpcProvider } from '../jsonrpc';
import { TransactionResult } from '../transaction-result';
import { NearAccount } from './near-account';
import { NearAccountManager } from './near-account-manager';
export declare abstract class AccountManager implements NearAccountManager {
    protected config: Config;
    accountsCreated: Set<string>;
    private _root?;
    constructor(config: Config);
    static create(config: Config): AccountManager;
    accountView(accountId: string): Promise<AccountView>;
    getAccount(accountId: string): NearAccount;
    getParentAccount(accountId: string): NearAccount;
    deleteKey(accountId: string): Promise<void>;
    init(): Promise<AccountManager>;
    get root(): NearAccount;
    get initialBalance(): string;
    get doubleInitialBalance(): BN;
    get provider(): JsonRpcProvider;
    batch(sender: NearAccount | string, receiver: NearAccount | string): Transaction;
    getKey(accountId: string): Promise<KeyPair | null>;
    getPublicKey(accountId: string): Promise<PublicKey | null>;
    /** Sets the provided key to store, otherwise creates a new one */
    setKey(accountId: string, keyPair?: KeyPair): Promise<KeyPair>;
    removeKey(accountId: string): Promise<void>;
    deleteAccount(accountId: string, beneficiaryId: string, keyPair?: KeyPair): Promise<TransactionResult>;
    getRootKey(): Promise<KeyPair>;
    balance(account: string | NearAccount): Promise<AccountBalance>;
    availableBalance(account: string | NearAccount): Promise<NEAR>;
    exists(accountId: string | NearAccount): Promise<boolean>;
    canCoverBalance(account: string | NearAccount, amount: BN): Promise<boolean>;
    executeTransaction(tx: Transaction, keyPair?: KeyPair): Promise<TransactionResult>;
    addAccountCreated(account: string, _sender: string): void;
    cleanup(): Promise<void>;
    get rootAccountId(): string;
    protected set rootAccountId(value: string);
    abstract get DEFAULT_INITIAL_BALANCE(): string;
    abstract createFrom(config: Config): Promise<NearAccountManager>;
    abstract get defaultKeyStore(): KeyStore;
    protected get keyStore(): KeyStore;
    protected get signer(): nearAPI.InMemorySigner;
    protected get networkId(): string;
    protected get connection(): nearAPI.Connection;
}
export declare class CustomnetManager extends AccountManager {
    get DEFAULT_INITIAL_BALANCE(): string;
    get defaultKeyStore(): KeyStore;
    get connection(): nearAPI.Connection;
    get networkId(): string;
    init(): Promise<AccountManager>;
    createFrom(config: Config): Promise<NearAccountManager>;
}
export declare class TestnetManager extends AccountManager {
    static readonly KEYSTORE_PATH: string;
    private static numTestAccounts;
    private _testnetRoot?;
    static get defaultKeyStore(): KeyStore;
    get masterAccountId(): string;
    get fullRootAccountId(): string;
    get root(): NearAccount;
    get DEFAULT_INITIAL_BALANCE(): string;
    get defaultKeyStore(): KeyStore;
    get urlAccountCreator(): nearAPI.accountCreator.UrlAccountCreator;
    init(): Promise<AccountManager>;
    createTopLevelAccountWithHelper(accountId: string, keyPair: KeyPair): Promise<void>;
    createAccount(accountId: string, keyPair?: KeyPair): Promise<NearAccount>;
    addFundsFromNetwork(accountId?: string): Promise<void>;
    addFunds(accountId: string, amount: BN): Promise<void>;
    deleteAccounts(accounts: string[], beneficiaryId: string): Promise<void[]>;
    createFrom(config: Config): Promise<AccountManager>;
    cleanup(): Promise<void>;
    needsFunds(accountId: string, amount: BN): Promise<boolean>;
    isRootOrTLAccount(accountId: string): boolean;
}
export declare class SandboxManager extends AccountManager {
    init(): Promise<AccountManager>;
    createFrom(config: Config): Promise<NearAccountManager>;
    get DEFAULT_INITIAL_BALANCE(): string;
    get defaultKeyStore(): KeyStore;
    get keyFilePath(): string;
}
export declare class ManagedTransaction extends Transaction {
    private readonly manager;
    private delete;
    constructor(manager: AccountManager, sender: NamedAccount | string, receiver: NamedAccount | string);
    createAccount(): this;
    deleteAccount(beneficiaryId: string): this;
    /**
     *
     * @param keyPair Temporary key to sign transaction
     * @returns
     */
    transact(keyPair?: KeyPair): Promise<TransactionResult>;
}
//# sourceMappingURL=account-manager.d.ts.map
'''
'''--- packages/js/dist/account/account-manager.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManagedTransaction = exports.SandboxManager = exports.TestnetManager = exports.CustomnetManager = exports.AccountManager = void 0;
const path = __importStar(require("path"));
const process = __importStar(require("process"));
const nearAPI = __importStar(require("near-api-js"));
const near_units_1 = require("near-units");
const utils_1 = require("../utils");
const types_1 = require("../types");
const internal_utils_1 = require("../internal-utils");
const transaction_1 = require("../transaction");
const jsonrpc_1 = require("../jsonrpc");
const transaction_result_1 = require("../transaction-result");
const account_1 = require("./account");
const utils_2 = require("./utils");
class AccountManager {
    constructor(config) {
        this.config = config;
        this.accountsCreated = new Set();
    }
    static create(config) {
        const { network } = config;
        switch (network) {
            case 'sandbox':
                return new SandboxManager(config);
            case 'testnet':
                return new TestnetManager(config);
            case 'custom':
                return new CustomnetManager(config);
            default: throw new Error(`Bad network id: "${network}"; expected "testnet", "custom" or "sandbox"`);
        }
    }
    async accountView(accountId) {
        return this.provider.viewAccount(accountId);
    }
    getAccount(accountId) {
        return new account_1.Account(accountId, this);
    }
    getParentAccount(accountId) {
        const split = accountId.split('.');
        if (split.length === 1) {
            return this.getAccount(accountId);
        }
        return this.getAccount(split.slice(1).join('.'));
    }
    async deleteKey(accountId) {
        try {
            await this.keyStore.removeKey(this.networkId, accountId);
            (0, internal_utils_1.debug)(`deleted Key for ${accountId}`);
        }
        catch {
            (0, internal_utils_1.debug)(`Failed to delete key for ${accountId}`);
        }
    }
    async init() {
        return this;
    }
    get root() {
        if (!this._root) {
            this._root = new account_1.Account(this.rootAccountId, this);
        }
        return this._root;
    }
    get initialBalance() {
        var _a;
        return (_a = this.config.initialBalance) !== null && _a !== void 0 ? _a : this.DEFAULT_INITIAL_BALANCE;
    }
    get doubleInitialBalance() {
        return new types_1.BN(this.initialBalance).mul(new types_1.BN('2'));
    }
    get provider() {
        return jsonrpc_1.JsonRpcProvider.from(this.config);
    }
    batch(sender, receiver) {
        return new ManagedTransaction(this, sender, receiver);
    }
    async getKey(accountId) {
        return this.keyStore.getKey(this.networkId, accountId);
    }
    async getPublicKey(accountId) {
        var _a, _b;
        return (_b = (_a = (await this.getKey(accountId))) === null || _a === void 0 ? void 0 : _a.getPublicKey()) !== null && _b !== void 0 ? _b : null;
    }
    /** Sets the provided key to store, otherwise creates a new one */
    async setKey(accountId, keyPair) {
        const key = keyPair !== null && keyPair !== void 0 ? keyPair : types_1.KeyPairEd25519.fromRandom();
        await this.keyStore.setKey(this.networkId, accountId, key);
        (0, internal_utils_1.debug)(`Setting keys for ${accountId}`);
        return (await this.getKey(accountId));
    }
    async removeKey(accountId) {
        await this.keyStore.removeKey(this.networkId, accountId);
    }
    async deleteAccount(accountId, beneficiaryId, keyPair) {
        try {
            return await this.getAccount(accountId).delete(beneficiaryId, keyPair);
        }
        catch (error) {
            if (keyPair) {
                (0, internal_utils_1.debug)(`Failed to delete ${accountId} with different keyPair`);
                return this.deleteAccount(accountId, beneficiaryId);
            }
            throw error;
        }
    }
    async getRootKey() {
        const keyPair = await this.getKey(this.rootAccountId);
        if (!keyPair) {
            return this.setKey(this.rootAccountId);
        }
        return keyPair;
    }
    async balance(account) {
        return this.provider.accountBalance((0, utils_1.asId)(account));
    }
    async availableBalance(account) {
        return (await this.balance(account)).available;
    }
    async exists(accountId) {
        return this.provider.accountExists((0, utils_1.asId)(accountId));
    }
    async canCoverBalance(account, amount) {
        return amount.lt(await this.availableBalance(account));
    }
    async executeTransaction(tx, keyPair) {
        var _a;
        const account = new nearAPI.Account(this.connection, tx.senderId);
        let oldKey = null;
        if (keyPair) {
            oldKey = await this.getKey(account.accountId);
            await this.setKey(account.accountId, keyPair);
        }
        try {
            const start = Date.now();
            const outcome = await account.signAndSendTransaction({ receiverId: tx.receiverId, actions: tx.actions, returnError: true });
            const end = Date.now();
            if (oldKey) {
                await this.setKey(account.accountId, oldKey);
            }
            else if (keyPair) {
                // Sender account should only have account while execution transaction
                await this.deleteKey(tx.senderId);
            }
            const result = new transaction_result_1.TransactionResult(outcome, start, end, this.config);
            (0, internal_utils_1.txDebug)(result.summary());
            return result;
        }
        catch (error) {
            // Add back oldKey if temporary one was used
            if (oldKey) {
                await this.setKey(account.accountId, oldKey);
            }
            if (error instanceof Error) {
                const key = await this.getPublicKey(tx.receiverId);
                (0, internal_utils_1.debug)(`TX FAILED: receiver ${tx.receiverId} with key ${(_a = key === null || key === void 0 ? void 0 : key.toString()) !== null && _a !== void 0 ? _a : 'MISSING'} ${JSON.stringify(tx.actions).slice(0, 1000)}`);
                (0, internal_utils_1.debug)(error);
            }
            throw error;
        }
    }
    addAccountCreated(account, _sender) {
        this.accountsCreated.add(account);
    }
    async cleanup() { } // eslint-disable-line @typescript-eslint/no-empty-function
    get rootAccountId() {
        return this.config.rootAccountId;
    }
    set rootAccountId(value) {
        this.config.rootAccountId = value;
    }
    get keyStore() {
        var _a;
        return (_a = this.config.keyStore) !== null && _a !== void 0 ? _a : this.defaultKeyStore;
    }
    get signer() {
        return new nearAPI.InMemorySigner(this.keyStore);
    }
    get networkId() {
        return this.config.network;
    }
    get connection() {
        return new nearAPI.Connection(this.networkId, this.provider, this.signer, `jsvm.${this.networkId}`);
    }
}
exports.AccountManager = AccountManager;
class CustomnetManager extends AccountManager {
    get DEFAULT_INITIAL_BALANCE() {
        return near_units_1.NEAR.parse('10 N').toJSON();
    }
    get defaultKeyStore() {
        return new nearAPI.keyStores.InMemoryKeyStore();
    }
    get connection() {
        return new nearAPI.Connection(this.networkId, this.provider, this.signer, `jsvm.${this.networkId}`);
    }
    get networkId() {
        return this.config.network;
    }
    async init() {
        return this;
    }
    async createFrom(config) {
        return new CustomnetManager(config);
    }
}
exports.CustomnetManager = CustomnetManager;
class TestnetManager extends AccountManager {
    static get defaultKeyStore() {
        const keyStore = new nearAPI.keyStores.UnencryptedFileSystemKeyStore(this.KEYSTORE_PATH);
        return keyStore;
    }
    get masterAccountId() {
        var _a;
        const passedAccountId = (_a = this.config.testnetMasterAccountId) !== null && _a !== void 0 ? _a : process.env.TESTNET_MASTER_ACCOUNT_ID;
        if (!passedAccountId) {
            throw new Error('Master account is not provided. You can set it in config while calling Worker.init(config); or with TESTNET_MASTER_ACCOUNT_ID env variable');
        }
        return passedAccountId;
    }
    get fullRootAccountId() {
        return this.rootAccountId + '.' + this.masterAccountId;
    }
    get root() {
        if (!this._testnetRoot) {
            this._testnetRoot = new account_1.Account(this.fullRootAccountId, this);
        }
        return this._testnetRoot;
    }
    get DEFAULT_INITIAL_BALANCE() {
        return near_units_1.NEAR.parse('10 N').toJSON();
    }
    get defaultKeyStore() {
        return TestnetManager.defaultKeyStore;
    }
    get urlAccountCreator() {
        return new nearAPI.accountCreator.UrlAccountCreator({}, // ignored
        this.config.helperUrl);
    }
    async init() {
        if (!this.rootAccountId) {
            this.rootAccountId = (0, utils_1.randomAccountId)('r-', 5, 5);
        }
        if (!(await this.exists(this.fullRootAccountId))) {
            await this.getAccount(this.masterAccountId).createSubAccount(this.rootAccountId);
        }
        return this;
    }
    async createTopLevelAccountWithHelper(accountId, keyPair) {
        await this.urlAccountCreator.createAccount(accountId, keyPair.getPublicKey());
    }
    async createAccount(accountId, keyPair) {
        if (accountId.includes('.')) {
            await this.getParentAccount(accountId).createAccount(accountId, { keyPair });
            this.accountsCreated.delete(accountId);
        }
        else {
            await this.createTopLevelAccountWithHelper(accountId, keyPair !== null && keyPair !== void 0 ? keyPair : await this.getRootKey());
            (0, internal_utils_1.debug)(`Created account ${accountId} with account creator`);
        }
        return this.getAccount(accountId);
    }
    async addFundsFromNetwork(accountId = this.fullRootAccountId) {
        const temporaryId = (0, utils_1.randomAccountId)();
        try {
            const key = await this.getRootKey();
            const account = await this.createAccount(temporaryId, key);
            await account.delete(accountId, key);
        }
        catch (error) {
            if (error instanceof Error) {
                await this.removeKey(temporaryId);
            }
            throw error;
        }
    }
    async addFunds(accountId, amount) {
        const parent = this.getParentAccount(accountId);
        if (parent.accountId === accountId) {
            return this.addFundsFromNetwork(accountId);
        }
        if (!(await this.canCoverBalance(parent, amount))) {
            await this.addFunds(parent.accountId, amount);
        }
        await parent.transfer(accountId, amount);
    }
    async deleteAccounts(accounts, beneficiaryId) {
        var _a;
        const keyPair = (_a = await this.getKey(this.rootAccountId)) !== null && _a !== void 0 ? _a : undefined;
        return Promise.all(accounts.map(async (accountId) => {
            await this.deleteAccount(accountId, beneficiaryId, keyPair);
            await this.deleteKey(accountId);
        }));
    }
    async createFrom(config) {
        const currentRunAccount = TestnetManager.numTestAccounts;
        const prefix = currentRunAccount === 0 ? '' : currentRunAccount;
        TestnetManager.numTestAccounts += 1;
        const newConfig = { ...config, rootAccount: `t${prefix}.${config.rootAccountId}` };
        return (new TestnetManager(newConfig)).init();
    }
    async cleanup() {
        return this.deleteAccounts([...this.accountsCreated.values()], this.rootAccountId);
    }
    async needsFunds(accountId, amount) {
        return !amount.isZero() && this.isRootOrTLAccount(accountId)
            && (!await this.canCoverBalance(accountId, amount));
    }
    isRootOrTLAccount(accountId) {
        return this.rootAccountId === accountId || (0, utils_1.isTopLevelAccount)(accountId);
    }
}
exports.TestnetManager = TestnetManager;
TestnetManager.KEYSTORE_PATH = path.join(process.cwd(), '.near-credentials', 'workspaces');
TestnetManager.numTestAccounts = 0;
class SandboxManager extends AccountManager {
    async init() {
        if (!await this.getKey(this.rootAccountId)) {
            await this.setKey(this.rootAccountId, await (0, utils_2.getKeyFromFile)(this.keyFilePath));
        }
        return this;
    }
    async createFrom(config) {
        return new SandboxManager(config);
    }
    get DEFAULT_INITIAL_BALANCE() {
        return near_units_1.NEAR.parse('200 N').toJSON();
    }
    get defaultKeyStore() {
        const keyStore = new nearAPI.keyStores.UnencryptedFileSystemKeyStore(this.config.homeDir);
        return keyStore;
    }
    get keyFilePath() {
        return path.join(this.config.homeDir, 'validator_key.json');
    }
}
exports.SandboxManager = SandboxManager;
class ManagedTransaction extends transaction_1.Transaction {
    constructor(manager, sender, receiver) {
        super(sender, receiver);
        this.manager = manager;
        this.delete = false;
    }
    createAccount() {
        this.manager.addAccountCreated(this.receiverId, this.senderId);
        return super.createAccount();
    }
    deleteAccount(beneficiaryId) {
        this.delete = true;
        return super.deleteAccount(beneficiaryId);
    }
    /**
     *
     * @param keyPair Temporary key to sign transaction
     * @returns
     */
    async transact(keyPair) {
        const executionResult = await this.manager.executeTransaction(this, keyPair);
        if (executionResult.succeeded && this.delete) {
            await this.manager.deleteKey(this.receiverId);
        }
        return executionResult;
    }
}
exports.ManagedTransaction = ManagedTransaction;
//# sourceMappingURL=account-manager.js.map
'''
'''--- packages/js/dist/account/account.d.ts ---
/// <reference types="node" />
/// <reference types="node" />
import { URL } from 'url';
import { Buffer } from 'buffer';
import BN from 'bn.js';
import { NEAR } from 'near-units';
import { KeyPair, PublicKey, CodeResult, AccountBalance, Args, AccountView, Empty, StateItem, AccessKeyView, AccessKeyList } from '../types';
import { Transaction } from '../transaction';
import { ContractState } from '../contract-state';
import { JsonRpcProvider } from '../jsonrpc';
import { TransactionResult } from '../transaction-result';
import { AccessKeyData, AccountData, Records } from '../record';
import { NearAccount } from './near-account';
import { NearAccountManager } from './near-account-manager';
export declare class Account implements NearAccount {
    private readonly _accountId;
    private readonly manager;
    constructor(_accountId: string, manager: NearAccountManager);
    accountView(): Promise<AccountView>;
    exists(): Promise<boolean>;
    protected get provider(): JsonRpcProvider;
    get accountId(): string;
    availableBalance(): Promise<NEAR>;
    balance(): Promise<AccountBalance>;
    batch(receiver: NearAccount | string): Transaction;
    getKey(): Promise<KeyPair | null>;
    setKey(keyPair?: KeyPair): Promise<PublicKey>;
    createAccount(accountId: string, { keyPair, initialBalance, }?: {
        keyPair?: KeyPair;
        initialBalance?: string;
        isSubAccount?: boolean;
    }): Promise<NearAccount>;
    createSubAccount(accountId: string, { keyPair, initialBalance, }?: {
        keyPair?: KeyPair;
        initialBalance?: string;
        isSubAccount?: boolean;
    }): Promise<NearAccount>;
    importContract({ testnetContract, mainnetContract, withData, blockId, keyPair, initialBalance, }: {
        testnetContract?: string;
        mainnetContract?: string;
        withData?: boolean;
        keyPair?: KeyPair;
        initialBalance?: string;
        blockId?: number | string;
    }): Promise<NearAccount>;
    getSubAccount(accountId: string): NearAccount;
    getAccount(accountId: string): NearAccount;
    deploy(code: string | URL | Uint8Array | Buffer): Promise<TransactionResult>;
    devCreateAccount({ initialBalance, keyPair, }?: {
        initialBalance?: BN | string;
        keyPair?: KeyPair;
    }): Promise<NearAccount>;
    devDeploy(wasm: string | URL | Uint8Array | Buffer, { attachedDeposit, args, gas, initialBalance, keyPair, method, isSubAccount, }?: {
        args?: Record<string, unknown> | Uint8Array;
        attachedDeposit?: string | BN;
        gas?: string | BN;
        initialBalance?: BN | string;
        keyPair?: KeyPair;
        method?: string;
        isSubAccount?: boolean;
    }): Promise<NearAccount>;
    callRaw(contractId: NearAccount | string, methodName: string, args: Record<string, unknown> | Uint8Array, { gas, attachedDeposit, signWithKey, }?: {
        gas?: string | BN;
        attachedDeposit?: string | BN;
        signWithKey?: KeyPair;
    }): Promise<TransactionResult>;
    call<T>(contractId: NearAccount | string, methodName: string, args: Record<string, unknown> | Uint8Array, { gas, attachedDeposit, signWithKey, }?: {
        gas?: string | BN;
        attachedDeposit?: string | BN;
        signWithKey?: KeyPair;
    }): Promise<T>;
    viewRaw(method: string, args?: Args): Promise<CodeResult>;
    view<T>(method: string, args?: Args): Promise<T>;
    viewCode(): Promise<Buffer>;
    viewCodeRaw(): Promise<string>;
    viewState(prefix?: string | Uint8Array): Promise<ContractState>;
    viewStateRaw(prefix?: string | Uint8Array): Promise<StateItem[]>;
    viewAccessKey(accountId: string, publicKey: PublicKey | string): Promise<AccessKeyView>;
    viewAccessKeys(accountId: string): Promise<AccessKeyList>;
    patchState(key: string, value_: any, borshSchema?: any): Promise<Empty>;
    patchStateRecords(records: Records): Promise<Empty>;
    delete(beneficiaryId: string, keyPair?: KeyPair): Promise<TransactionResult>;
    makeSubAccount(accountId: string): string;
    subAccountOf(accountId: string): boolean;
    toJSON(): string;
    updateAccount(accountData?: Partial<AccountData>): Promise<Empty>;
    updateAccessKey(key: string | PublicKey | KeyPair, access_key_data?: AccessKeyData): Promise<Empty>;
    updateContract(binary: Buffer | string): Promise<Empty>;
    updateData(key: string | Buffer, value: string | Buffer): Promise<Empty>;
    transfer(accountId: string | NearAccount, amount: string | BN): Promise<TransactionResult>;
    protected internalCreateAccount(accountId: string, { keyPair, initialBalance, isSubAccount, }?: {
        keyPair?: KeyPair;
        initialBalance?: string | BN;
        isSubAccount?: boolean;
    }): Promise<Transaction>;
    private getOrCreateKey;
    private recordBuilder;
}
//# sourceMappingURL=account.d.ts.map
'''
'''--- packages/js/dist/account/account.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Account = void 0;
const buffer_1 = require("buffer");
const process_1 = require("process");
const borsh = __importStar(require("borsh"));
const types_1 = require("../types");
const contract_state_1 = require("../contract-state");
const jsonrpc_1 = require("../jsonrpc");
const utils_1 = require("../utils");
const transaction_result_1 = require("../transaction-result");
const record_1 = require("../record");
class Account {
    constructor(_accountId, manager) {
        this._accountId = _accountId;
        this.manager = manager;
    }
    async accountView() {
        return this.manager.accountView(this._accountId);
    }
    async exists() {
        return this.provider.accountExists(this.accountId);
    }
    get provider() {
        return this.manager.provider;
    }
    get accountId() {
        return this._accountId;
    }
    async availableBalance() {
        return this.manager.availableBalance(this.accountId);
    }
    async balance() {
        return this.manager.balance(this.accountId);
    }
    batch(receiver) {
        return this.manager.batch(this, receiver);
    }
    async getKey() {
        return this.manager.getKey(this.accountId);
    }
    async setKey(keyPair) {
        return (await this.manager.setKey(this.accountId, keyPair)).getPublicKey();
    }
    async createAccount(accountId, { keyPair, initialBalance, } = {}) {
        const tx = await this.internalCreateAccount(accountId, {
            keyPair,
            initialBalance,
            isSubAccount: false,
        });
        const result = await tx.transact();
        if (result.Failure) {
            throw new Error(`Failure during trasaction excecution, details: ${JSON.stringify(result)}`);
        }
        return this.getAccount(accountId);
    }
    async createSubAccount(accountId, { keyPair, initialBalance, } = {}) {
        const tx = await this.internalCreateAccount(accountId, {
            keyPair,
            initialBalance,
            isSubAccount: true,
        });
        const result = await tx.transact();
        if (result.Failure) {
            throw new Error(`Failure during trasaction excecution, details: ${JSON.stringify(result)}`);
        }
        return this.getSubAccount(accountId);
    }
    async importContract({ testnetContract, mainnetContract, withData = false, blockId, keyPair, initialBalance, }) {
        if ((testnetContract && mainnetContract) || !(testnetContract || mainnetContract)) {
            throw new TypeError('Provide `mainnetContract` or `testnetContract` but not both.');
        }
        const network = mainnetContract ? 'mainnet' : 'testnet';
        const refContract = (mainnetContract !== null && mainnetContract !== void 0 ? mainnetContract : testnetContract);
        const rpc = jsonrpc_1.JsonRpcProvider.fromNetwork(network);
        const blockQuery = blockId ? { block_id: blockId } : undefined;
        const account = this.getAccount(refContract);
        // Get account view of account on reference network
        const accountView = await rpc.viewAccount(refContract, blockQuery);
        accountView.amount = initialBalance !== null && initialBalance !== void 0 ? initialBalance : accountView.amount;
        const pubKey = await account.setKey(keyPair);
        const records = account.recordBuilder()
            .account(accountView)
            .accessKey(pubKey);
        if (accountView.code_hash !== utils_1.EMPTY_CONTRACT_HASH) {
            const binary = await rpc.viewCodeRaw(refContract, blockQuery);
            records.contract(binary);
        }
        await account.patchStateRecords(records);
        if (!await this.provider.accountExists(refContract)) {
            await account.patchStateRecords(records);
            if (!await this.provider.accountExists(refContract)) {
                throw new Error(`Account ${refContract} does not exist after trying to patch into sandbox.`);
            }
        }
        if (withData) {
            const rawData = await rpc.viewStateRaw(account.accountId, '', blockQuery);
            const data = rawData.map(({ key, value }) => ({
                Data: {
                    account_id: account.accountId, data_key: key, value,
                },
            }));
            await account.patchStateRecords({ records: data });
        }
        return account;
    }
    getSubAccount(accountId) {
        const id = this.makeSubAccount(accountId);
        return this.getAccount(id);
    }
    getAccount(accountId) {
        return new Account(accountId, this.manager);
    }
    async deploy(code) {
        const tx = await this.batch(this).deployContractFile(code);
        return tx.transact();
    }
    async devCreateAccount({ initialBalance, keyPair, } = {}) {
        const accountId = `${(0, utils_1.randomAccountId)('dev-', 5, 5)}.${this.accountId}`;
        const tx = await this.internalCreateAccount(accountId, {
            keyPair,
            initialBalance,
        });
        const result = await tx.transact();
        if (result.Failure) {
            throw new Error(`Failure during account creation, details: ${JSON.stringify(result)}`);
        }
        return this.getAccount(accountId);
    }
    async devDeploy(wasm, { attachedDeposit = utils_1.NO_DEPOSIT, args = {}, 
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    gas = types_1.DEFAULT_FUNCTION_CALL_GAS, initialBalance, keyPair, method, isSubAccount, } = {}) {
        const accountId = `${(0, utils_1.randomAccountId)('dev-', 5, 5)}.${this.accountId}`;
        let tx = await this.internalCreateAccount(accountId, {
            keyPair,
            initialBalance,
            isSubAccount,
        });
        tx = await tx.deployContractFile(wasm);
        if (method) {
            tx.functionCall(method, args, { gas, attachedDeposit });
        }
        const result = await tx.transact();
        if (result.Failure) {
            throw new Error(`Failure during trasaction excecution, details: ${JSON.stringify(result)}`);
        }
        return this.getAccount(accountId);
    }
    async callRaw(contractId, methodName, args, { 
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    gas = types_1.DEFAULT_FUNCTION_CALL_GAS, attachedDeposit = utils_1.NO_DEPOSIT, signWithKey = undefined, } = {}) {
        return this.batch(contractId)
            .functionCall(methodName, args, { gas, attachedDeposit })
            .transact(signWithKey);
    }
    async call(contractId, methodName, args, { 
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    gas = types_1.DEFAULT_FUNCTION_CALL_GAS, attachedDeposit = utils_1.NO_DEPOSIT, signWithKey = undefined, } = {}) {
        const txResult = await this.callRaw(contractId, methodName, args, {
            gas,
            attachedDeposit,
            signWithKey,
        });
        if (!process_1.env.NEAR_WORKSPACES_NO_LOGS && txResult.logs.length > 0) {
            const accId = typeof contractId === 'string' ? contractId : contractId.accountId;
            console.log(`Contract logs from ${accId}.${methodName}(${JSON.stringify(args)}) call:`, txResult.logs);
        }
        if (txResult.failed) {
            throw new transaction_result_1.TransactionError(txResult);
        }
        return txResult.parseResult();
    }
    async viewRaw(method, args = {}) {
        return this.provider.viewCall(this.accountId, method, args);
    }
    async view(method, args = {}) {
        const result = await this.viewRaw(method, args);
        if (!process_1.env.NEAR_WORKSPACES_NO_LOGS && result.logs.length > 0) {
            console.log(`Contract logs from ${this.accountId}.${method}(${JSON.stringify(args)}) view call:`, result.logs);
        }
        if (result.result) {
            const value = buffer_1.Buffer.from(result.result).toString();
            try {
                return JSON.parse(value);
            }
            catch {
                return value;
            }
        }
        return null;
    }
    async viewCode() {
        return this.provider.viewCode(this.accountId);
    }
    async viewCodeRaw() {
        return this.provider.viewCodeRaw(this.accountId);
    }
    async viewState(prefix = '') {
        return new contract_state_1.ContractState(await this.provider.viewState(this.accountId, prefix));
    }
    async viewStateRaw(prefix = '') {
        return this.provider.viewStateRaw(this.accountId, prefix);
    }
    async viewAccessKey(accountId, publicKey) {
        return this.provider.viewAccessKey(accountId, publicKey);
    }
    async viewAccessKeys(accountId) {
        return this.provider.viewAccessKeys(accountId);
    }
    async patchState(key, value_, borshSchema) {
        return this.updateData(buffer_1.Buffer.from(key), buffer_1.Buffer.from(borshSchema ? borsh.serialize(borshSchema, value_) : value_));
    }
    async patchStateRecords(records) {
        // FIX THIS: Shouldn't need two calls to update before next RPC view call.
        await this.provider.patchStateRecords(records);
        return this.provider.patchStateRecords(records);
    }
    async delete(beneficiaryId, keyPair) {
        const result = await this.batch(this)
            .deleteAccount(beneficiaryId)
            .transact(keyPair);
        if (result.succeeded && await this.getKey() !== null) {
            await this.manager.deleteKey(this.accountId);
        }
        return result;
    }
    makeSubAccount(accountId) {
        return `${accountId}.${this.accountId}`;
    }
    subAccountOf(accountId) {
        return accountId.endsWith(`.${this.accountId}`);
    }
    toJSON() {
        return this.accountId;
    }
    async updateAccount(accountData) {
        return this.patchStateRecords(this.recordBuilder().account(accountData));
    }
    async updateAccessKey(key, access_key_data) {
        return this.patchStateRecords(this.recordBuilder().accessKey(key, access_key_data));
    }
    async updateContract(binary) {
        const accountView = await this.accountView();
        const rb = this.recordBuilder();
        rb.account(accountView);
        return this.patchStateRecords(rb.contract(binary));
    }
    async updateData(key, value) {
        const key_string = key instanceof buffer_1.Buffer ? key.toString('base64') : key;
        const value_string = value instanceof buffer_1.Buffer ? value.toString('base64') : value;
        return this.patchStateRecords(this.recordBuilder().data(key_string, value_string));
    }
    async transfer(accountId, amount) {
        return this.batch(accountId).transfer(amount).transact();
    }
    async internalCreateAccount(accountId, { keyPair, initialBalance, isSubAccount, } = {}) {
        const newAccountId = isSubAccount ? this.makeSubAccount(accountId) : accountId;
        const pubKey = (await this.getOrCreateKey(newAccountId, keyPair)).getPublicKey();
        const amount = (initialBalance !== null && initialBalance !== void 0 ? initialBalance : this.manager.initialBalance).toString();
        return this.batch(newAccountId)
            .createAccount()
            .transfer(amount)
            .addKey(pubKey);
    }
    async getOrCreateKey(accountId, keyPair) {
        var _a;
        return (_a = (await this.manager.getKey(accountId))) !== null && _a !== void 0 ? _a : this.manager.setKey(accountId, keyPair);
    }
    recordBuilder() {
        return record_1.RecordBuilder.fromAccount(this);
    }
}
exports.Account = Account;
//# sourceMappingURL=account.js.map
'''
'''--- packages/js/dist/account/index.d.ts ---
export * from './near-account';
export * from './near-account-manager';
export * from './account-manager';
export * from './account';
//# sourceMappingURL=index.d.ts.map
'''
'''--- packages/js/dist/account/index.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./near-account"), exports);
__exportStar(require("./near-account-manager"), exports);
__exportStar(require("./account-manager"), exports);
__exportStar(require("./account"), exports);
//# sourceMappingURL=index.js.map
'''
'''--- packages/js/dist/account/near-account-manager.d.ts ---
import { KeyPair } from 'near-api-js';
import { NEAR } from 'near-units';
import { TransactionResult } from '../transaction-result';
import { JsonRpcProvider } from '../jsonrpc';
import { Transaction } from '../transaction';
import { Config, AccountBalance, AccountView } from '../types';
import { NearAccount } from './near-account';
export interface NearAccountManager {
    readonly provider: JsonRpcProvider;
    readonly initialBalance: string;
    readonly root: NearAccount;
    accountView(accountId: string): Promise<AccountView>;
    availableBalance(account: string | NearAccount): Promise<NEAR>;
    balance(accountId: string | NearAccount): Promise<AccountBalance>;
    executeTransaction(tx: Transaction, keyPair?: KeyPair): Promise<TransactionResult>;
    addAccountCreated(account: string, sender: string): void;
    getAccount(accountId: string): NearAccount;
    getKey(accountId: string): Promise<KeyPair | null>;
    deleteAccount(accountId: string, beneficiaryId: string, keyPair?: KeyPair): Promise<TransactionResult>;
    deleteKey(accountId: string): Promise<void>;
    cleanup(): Promise<void>;
    /** Creates a KeyPair if one is not provided */
    setKey(accountId: string, keyPair?: KeyPair): Promise<KeyPair>;
    batch(sender: NearAccount | string, receiver: NearAccount | string): Transaction;
    createFrom(config: Config): Promise<NearAccountManager>;
    init(): Promise<NearAccountManager>;
}
//# sourceMappingURL=near-account-manager.d.ts.map
'''
'''--- packages/js/dist/account/near-account-manager.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=near-account-manager.js.map
'''
'''--- packages/js/dist/account/near-account.d.ts ---
/// <reference types="node" />
/// <reference types="node" />
import { URL } from 'url';
import { Buffer } from 'buffer';
import BN from 'bn.js';
import { NEAR } from 'near-units';
import { KeyPair } from 'near-api-js';
import { AccountBalance, PublicKey, CodeResult, AccountView, Empty, StateItem, AccessKeyList, AccessKeyView } from '../types';
import { ContractState } from '../contract-state';
import { Transaction } from '../transaction';
import { TransactionResult } from '../transaction-result';
import { AccessKeyData, AccountData, Records } from '../record';
export interface NearAccount {
    /** Full account id for given account. */
    readonly accountId: string;
    /**
     * Returns infomation about the account.
     * @see {@link https://docs.near.org/docs/develop/front-end/rpc#view-account}
     */
    accountView(): Promise<AccountView>;
    availableBalance(): Promise<NEAR>;
    /** Current balance of account on network. */
    balance(): Promise<AccountBalance>;
    /**
     * Create a Transaction that can be used to build actions like transfer, createAccount, etc.
     * Then once built can be signed and transmitted.
     * E.g.
     * ```ts
     * const result = await account.batch(bob).transfer(NEAR.parse("1N")).transact();
     * ```
     * @param receiver account that the transaction is addressed to.
     */
    batch(receiver: NearAccount | string): Transaction;
    /** Test whether an account exists on the network */
    exists(): Promise<boolean>;
    /**
     * Gets users key from key store.
     */
    getKey(): Promise<KeyPair | null>;
    /**
     * Adds a key pair to key store and creates a random pair if not provided
     * @param keyPair to add keystore
     */
    setKey(keyPair?: KeyPair): Promise<PublicKey>;
    /**
     * Create a subaccount from this account
     * @param accountId full accountId with current account name as suffix.
     * @param options `keyPair` is key to be added to keystore, otherwise random one will be added.
     *                `initialBalance` how much yoctoNear to transfer to new account.
     */
    createAccount(accountId: string, options?: {
        keyPair?: KeyPair;
        initialBalance?: string;
    }): Promise<NearAccount>;
    /**
     * Create a subaccount from this account
     * @param accountId prefix of accountId with current account name as suffix.
     * @param options `keyPair` is key to be added to keystore, otherwise random one will be added.
     *                `initialBalance` how much yoctoNear to transfer to new account.
     */
    createSubAccount(accountId: string, options?: {
        keyPair?: KeyPair;
        initialBalance?: string;
    }): Promise<NearAccount>;
    /**
     * Create an account, copying Wasm bytes and contract name from a given `testnetContract` or `mainnetContract`.
     *
     * This makes use of Sandbox's patch state feature, and so only works in Sandbox mode.
     *
     * You can include `withData: true` to copy account data as well, but this is
     * currently limited by the default RPC limit of 50kB. You could set up your
     * own RPC server to get around this limit (using your own RPC endpoint will
     * be easier soon).
     *
     * @param options
     */
    importContract(options: {
        testnetContract?: string;
        mainnetContract?: string;
        withData?: boolean;
        keyPair?: KeyPair;
        initialBalance?: string;
        blockId?: number | string;
        isSubAccount?: boolean;
    }): Promise<NearAccount>;
    /** Adds suffix to accountIdPrefix and get that account */
    getSubAccount(accountIdPrefix: string): NearAccount;
    /** Get the account with given full accountId */
    getAccount(accountId: string): NearAccount;
    /** Deploy contract to the current account */
    deploy(code: string | URL | Uint8Array | Buffer): Promise<TransactionResult>;
    /**
     * Creates an account with random accoundId
     * @returns Promise<NearAccount>
     */
    devCreateAccount(): Promise<NearAccount>;
    /**
     * Creates an account for a contract and then deploys a Wasm binary to it.
     * If method arguments are provided a function call to `method` will be added to the transaction so that
     * the contract can be initialized in the same step.
     *
     * @param wasm path or data of contract binary
     * @param options If any method is passed it will be added to the transaction so that contract will be initialized
     *                `gas` and `initialBalance` as strings can be either numbers, e.g. `1_000_000` or have units, `30 Tgas`
     */
    devDeploy(wasm: string | URL | Uint8Array | Buffer, options?: {
        args?: Record<string, unknown> | Uint8Array;
        attachedDeposit?: string | BN;
        gas?: string | BN;
        initialBalance?: BN | string;
        keyPair?: KeyPair;
        method?: string;
        isSubAccount?: boolean;
    }): Promise<NearAccount>;
    /**
     * Call a NEAR contract and return full results with raw receipts, etc. Example:
     *
     *     await callRaw('lol.testnet', 'set_status', { message: 'hello' }, {gas: new BN(30 * 10**12), attachedDeposit: new BN(10**24)})
     *
     *     //`gas` and `initialBalance` as strings can be either numbers, e.g. `1_000_000` or have units, `30 Tgas`
     *
     *     await callRaw('lol.testnet', 'set_status', { message: 'hello' }, {gas:"10 Tgas", attachedDeposit: "1 N"})
  
     * @returns Promise<TransactionResult>
     */
    callRaw(contractId: NearAccount | string, methodName: string, args: Record<string, unknown> | Uint8Array, options?: {
        gas?: string | BN;
        attachedDeposit?: string | BN;
        signWithKey?: KeyPair;
    }): Promise<TransactionResult>;
    /**
     * Convenient wrapper around lower-level `callRaw` that returns only successful result of call, or throws error encountered during call.  Example:
     *
     *     await call('lol.testnet', 'set_status', { message: 'hello' }, new BN(30 * 10**12), '0')
     *
     * @returns any parsed return value, or throws with an error if call failed
     */
    call<T>(contractId: NearAccount | string, methodName: string, args: Record<string, unknown> | Uint8Array, options?: {
        gas?: string | BN;
        attachedDeposit?: string | BN;
        signWithKey?: KeyPair;
    }): Promise<T>;
    /**
     * Get full response from RPC about result of view method
     * @param method contract method
     * @param args args to pass to method if required
     */
    viewRaw(method: string, args?: Record<string, unknown> | Uint8Array): Promise<CodeResult>;
    /**
     * Get the parsed result returned by view method
     * @param method contract method
     * @param args args to pass to method if required
     */
    view<T>(method: string, args?: Record<string, unknown> | Uint8Array): Promise<T>;
    /**
     * Download contract code from provider
     */
    viewCode(): Promise<Buffer>;
    /**
     * Download contract code encoded as a Base64 string
     */
    viewCodeRaw(): Promise<string>;
    /**
     * Get the data of a contract as a map of raw key/values
     * @param prefix optional prefix of key in storage. Default is ''.
     */
    viewState(prefix?: string | Uint8Array): Promise<ContractState>;
    /**
     * Get raw contract data as base64 encoded strings.
     * @param prefix optional prefix of key in storage. Default is ''.
     */
    viewStateRaw(prefix?: string | Uint8Array): Promise<StateItem[]>;
    /**
     * Get the access key associated to the account id and public key.
     * @param accountId ID of the account we want to get the access key from.
     * @param publicKey Which particular access key we want to retrieve.
     */
    viewAccessKey(accountId: string, publicKey: PublicKey | string): Promise<AccessKeyView>;
    /**
     * Get all access keys associated to the account id.
     * @param accountId ID of the account we want to get the access keys from.
     */
    viewAccessKeys(accountId: string): Promise<AccessKeyList>;
    /** Update record to sandbox */
    patchStateRecords(records: Records): Promise<Empty>;
    /**
     * Patch state data of given key and value to sandbox
     * @param key key to update in storage
     * @param value_ Data to be serialized to JSON by default
     * @param borshSchema If passed will be used to encode the data
     */
    patchState(key: string, value_: any, borshSchema?: any): Promise<any>;
    /** Delete account and sends funds to beneficiaryId */
    delete(beneficiaryId: string, keyPair?: KeyPair): Promise<TransactionResult>;
    /**
     * Adds the current account's id as the root account `<accountId>.<thisAccountID>`
     * @param accountId prefix of subaccount
     */
    makeSubAccount(accountId: string): string;
    /**
     * Test whether an accountId is a subaccount of the current account.
     * @param accountId Account to test
     */
    subAccountOf(accountId: string): boolean;
    /**
     * Used to encode the account as the the accountId string when used in `JSON.stringify`
     */
    toJSON(): string;
    /**
    * Transfer yoctoNear to another account.
    * If amount is string it can be either numbers, e.g. `"1_000_000_000_000_000_000_000_000"` or have units, `"1 N"`
    */
    transfer(accountId: string | NearAccount, amount: string | BN): Promise<TransactionResult>;
    /**
     * Update the account balance, storage usage, locked_amount.
     *
     * Uses patchStateRecords to update the account without a transaction. Only works with network: 'sandbox'.
     */
    updateAccount(accountData?: Partial<AccountData>): Promise<Empty>;
    /**
     * Add AccessKey to account.
     *
     * Uses patchStateRecords to update the account without a transaction. Only works with network: 'sandbox'.
     */
    updateAccessKey(key: string | PublicKey | KeyPair, access_key_data?: AccessKeyData): Promise<Empty>;
    /**
     * Deploy contract to account.
     *
     * Uses patchStateRecords to update the account without a transaction. Only works with network: 'sandbox'.
     */
    updateContract(binary: Buffer | string): Promise<Empty>;
    /**
     * Update contract data of account.
     *
     * Uses patchStateRecords to update the account without a transaction. Only works with network: 'sandbox'.
     *
     * @param data Base64 encoded string or Buffer to be encoded as Base64
     * @param value Base64 encoded string or Buffer to be encoded as Base64
     */
    updateData(data: string | Buffer, value: string | Buffer): Promise<Empty>;
}
//# sourceMappingURL=near-account.d.ts.map
'''
'''--- packages/js/dist/account/near-account.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=near-account.js.map
'''
'''--- packages/js/dist/account/utils.d.ts ---
import { CallSite } from 'callsites';
import { KeyPair } from '../types';
export declare function findCallerFile(): [string, number];
export declare function callsites(): CallSite[];
export interface KeyFilePrivate {
    private_key: string;
}
export interface KeyFileSecret {
    secret_key: string;
}
export type KeyFile = KeyFilePrivate | KeyFileSecret;
export declare function getKeyFromFile(filePath: string, create?: boolean): Promise<KeyPair>;
export declare function hashPathBase64(s: string): string;
export declare function sanitize(s: string): string;
//# sourceMappingURL=utils.d.ts.map
'''
'''--- packages/js/dist/account/utils.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sanitize = exports.hashPathBase64 = exports.getKeyFromFile = exports.callsites = exports.findCallerFile = void 0;
const fs = __importStar(require("fs/promises"));
const buffer_1 = require("buffer");
const js_sha256_1 = __importDefault(require("js-sha256"));
const base64url_1 = __importDefault(require("base64url"));
const types_1 = require("../types");
function findCallerFile() {
    const sites = callsites();
    const files = sites.filter(s => s.getFileName());
    // Need better way to find file
    const i = files.length - 1;
    return [files[i].getFileName(), files[i].getLineNumber()];
}
exports.findCallerFile = findCallerFile;
function callsites() {
    const _prepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = (_, stack) => stack;
    const stack = new Error().stack.slice(1); // eslint-disable-line unicorn/error-message
    Error.prepareStackTrace = _prepareStackTrace;
    return stack;
}
exports.callsites = callsites;
async function getKeyFromFile(filePath, create = true) {
    var _a;
    try {
        const keyFile = require(filePath); // eslint-disable-line @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports
        return types_1.KeyPair.fromString(
        // @ts-expect-error `x` does not exist on KeyFile
        (_a = keyFile.secret_key) !== null && _a !== void 0 ? _a : keyFile.private_key);
    }
    catch (error) {
        if (!create) {
            throw error;
        }
        const keyPair = types_1.KeyPairEd25519.fromRandom();
        await fs.writeFile(filePath, JSON.stringify({
            secret_key: keyPair.toString(),
        }));
        return keyPair;
    }
}
exports.getKeyFromFile = getKeyFromFile;
function hashPathBase64(s) {
    // Currently base64url is in newest version of node, but need to use polyfill for now
    const result = base64url_1.default.encode(buffer_1.Buffer.from(js_sha256_1.default.sha256.arrayBuffer(s)));
    return result;
}
exports.hashPathBase64 = hashPathBase64;
function sanitize(s) {
    return s.toLowerCase().replace('__', '_0');
}
exports.sanitize = sanitize;
//# sourceMappingURL=utils.js.map
'''
'''--- packages/js/dist/contract-state.d.ts ---
/// <reference types="node" />
import { Buffer } from 'buffer';
export declare class ContractState {
    private readonly data;
    constructor(dataArray: Array<{
        key: Buffer;
        value: Buffer;
    }>);
    getRaw(key: string): Buffer;
    get(key: string, borshSchema?: {
        type: any;
        schema: any;
    }): any;
}
//# sourceMappingURL=contract-state.d.ts.map
'''
'''--- packages/js/dist/contract-state.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractState = void 0;
const buffer_1 = require("buffer");
const borsh = __importStar(require("borsh"));
class ContractState {
    constructor(dataArray) {
        this.data = new Map();
        for (const { key, value } of dataArray) {
            this.data.set(key.toString(), value);
        }
    }
    getRaw(key) {
        var _a;
        return (_a = this.data.get(key)) !== null && _a !== void 0 ? _a : buffer_1.Buffer.from('');
    }
    get(key, borshSchema) {
        const value = this.getRaw(key);
        if (borshSchema) {
            return borsh.deserialize(borshSchema.schema, borshSchema.type, value);
        }
        return value.toJSON();
    }
}
exports.ContractState = ContractState;
//# sourceMappingURL=contract-state.js.map
'''
'''--- packages/js/dist/index.d.ts ---
export * from './worker';
export * from './server';
export * from './utils';
export * from './types';
export * from './account';
export * from './transaction-result';
export * from './jsonrpc';
export * from 'near-units';
//# sourceMappingURL=index.d.ts.map
'''
'''--- packages/js/dist/index.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
const process = __importStar(require("process"));
if (!process.env.NEAR_PRINT_LOGS) {
    process.env.NEAR_NO_LOGS = 'true';
}
__exportStar(require("./worker"), exports);
__exportStar(require("./server"), exports);
__exportStar(require("./utils"), exports);
__exportStar(require("./types"), exports);
__exportStar(require("./account"), exports);
__exportStar(require("./transaction-result"), exports);
__exportStar(require("./jsonrpc"), exports);
__exportStar(require("near-units"), exports);
//# sourceMappingURL=index.js.map
'''
'''--- packages/js/dist/internal-utils.d.ts ---
/// <reference types="node" />
/// <reference types="node" />
import { PathLike } from 'fs';
import { spawn as _spawn } from 'child_process';
import { URL } from 'url';
import { Binary } from 'near-sandbox';
import { ChildProcessPromise } from './types';
export declare const rm: (arg1: string) => Promise<void>;
export declare const sandboxBinary: () => Promise<Binary>;
export declare function exists(d: PathLike): Promise<boolean>;
export declare function asyncSpawn(bin: string, ...args: string[]): ChildProcessPromise;
export { _spawn as spawn };
export declare function debug(...args: any[]): void;
export declare function txDebug(tx: string): void;
export declare const copyDir: (arg1: string, arg2: string) => Promise<void>;
export declare function ensureBinary(): Promise<string>;
export declare function isPathLike(something: any): something is URL | string;
/**
 * Attempts to construct an absolute path to a file given a path relative to a
 * package.json. Searches through `module.paths` (Node's resolution search
 * paths) as described in https://stackoverflow.com/a/18721515/249801, then
 * falls back to using process.cwd() if still not found. Throws an acceptable
 * user-facing error if no file found.
 */
export declare function findFile(relativePath: string): Promise<string>;
//# sourceMappingURL=internal-utils.d.ts.map
'''
'''--- packages/js/dist/internal-utils.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findFile = exports.isPathLike = exports.ensureBinary = exports.copyDir = exports.txDebug = exports.debug = exports.spawn = exports.asyncSpawn = exports.exists = exports.sandboxBinary = exports.rm = void 0;
const process_1 = __importDefault(require("process"));
const path_1 = require("path");
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const fs = __importStar(require("fs/promises"));
const util_1 = require("util");
const child_process_1 = require("child_process");
Object.defineProperty(exports, "spawn", { enumerable: true, get: function () { return child_process_1.spawn; } });
const url_1 = require("url");
const promisify_child_process_1 = require("promisify-child-process");
const rimraf_1 = __importDefault(require("rimraf"));
const getBinary_1 = require("near-sandbox/dist/getBinary");
const fs_extra_1 = __importDefault(require("fs-extra"));
exports.rm = (0, util_1.promisify)(rimraf_1.default);
const sandboxBinary = async () => ((0, getBinary_1.getBinary)());
exports.sandboxBinary = sandboxBinary;
async function exists(d) {
    let file;
    try {
        file = await fs.open(d, 'r');
    }
    catch {
        return false;
    }
    finally {
        await (file === null || file === void 0 ? void 0 : file.close());
    }
    return true;
}
exports.exists = exists;
async function asyncSpawn(bin, ...args) {
    debug(`spawning \`${bin} ${args.join(' ')}\``);
    return (0, promisify_child_process_1.spawn)(bin, args, { encoding: 'utf8' });
}
exports.asyncSpawn = asyncSpawn;
function debug(...args) {
    if (process_1.default.env.NEAR_WORKSPACES_DEBUG) {
        console.error(...args);
    }
}
exports.debug = debug;
function txDebug(tx) {
    if (process_1.default.env.NEAR_WORKSPACES_TXDEBUG) {
        console.error(tx);
    }
}
exports.txDebug = txDebug;
exports.copyDir = (0, util_1.promisify)(fs_extra_1.default.copy);
async function ensureBinary() {
    const binary = await (0, exports.sandboxBinary)();
    if (!await binary.exists()) {
        await binary.install();
    }
    return binary.binPath;
}
exports.ensureBinary = ensureBinary;
function isPathLike(something) {
    return typeof something === 'string' || something instanceof url_1.URL;
}
exports.isPathLike = isPathLike;
/**
 * Attempts to construct an absolute path to a file given a path relative to a
 * package.json. Searches through `module.paths` (Node's resolution search
 * paths) as described in https://stackoverflow.com/a/18721515/249801, then
 * falls back to using process.cwd() if still not found. Throws an acceptable
 * user-facing error if no file found.
 */
async function findFile(relativePath) {
    for (const modulePath of module.paths) {
        try {
            await (0, promises_1.access)(modulePath, fs_1.constants.F_OK); // eslint-disable-line no-await-in-loop
            const absolutePath = (0, path_1.join)((0, path_1.dirname)(modulePath), relativePath);
            await (0, promises_1.access)(absolutePath, fs_1.constants.F_OK); // eslint-disable-line no-await-in-loop
            return absolutePath;
        }
        catch { }
    }
    const cwd = process_1.default.cwd();
    const absolutePath = (0, path_1.join)(cwd, relativePath);
    try {
        await (0, promises_1.access)(absolutePath, fs_1.constants.F_OK);
        return absolutePath;
    }
    catch { }
    throw new Error(`Could not find '${relativePath}' relative to any package.json file or your current working directory (${cwd})`);
}
exports.findFile = findFile;
//# sourceMappingURL=internal-utils.js.map
'''
'''--- packages/js/dist/jsonrpc.d.ts ---
/// <reference types="node" />
import { Buffer } from 'buffer';
import { Records } from './record';
import { JSONRpc, AccountView, NearProtocolConfig, AccountBalance, CodeResult, BlockId, Finality, StateItem, Empty, PublicKey, Network, AccessKeyView, AccessKeyList } from './types';
/**
 * Extends the main provider class in near-api-js, adding more methods for
 * interacting with an endpoint.
 */
export declare class JsonRpcProvider extends JSONRpc {
    private static readonly providers;
    /**
     * Create a JsonRpcProvider from config or rpcAddr
     * @param config rpc endpoint URL or a configuration that includes one.
     * @returns JsonRpcProvider
     */
    static from(config: string | {
        rpcAddr: string;
    }): JsonRpcProvider;
    static fromNetwork(network: Network): JsonRpcProvider;
    /**
     * Download the binary of a given contract.
     * @param accountId contract account
     * @returns Buffer of Wasm binary
     */
    viewCode(accountId: string, blockQuery?: {
        block_id: BlockId;
    } | {
        finality: Finality;
    }): Promise<Buffer>;
    /**
     * Download the binary of a given contract.
     * @param accountId contract account
     * @returns Base64 string of Wasm binary
     */
    viewCodeRaw(accountId: string, blockQuery?: {
        block_id: BlockId;
    } | {
        finality: Finality;
    }): Promise<string>;
    viewAccount(accountId: string, blockQuery?: {
        block_id: BlockId;
    } | {
        finality: Finality;
    }): Promise<AccountView>;
    accountExists(accountId: string, blockQuery?: {
        block_id: BlockId;
    } | {
        finality: Finality;
    }): Promise<boolean>;
    viewAccessKey(accountId: string, publicKey: PublicKey | string, blockQuery?: {
        block_id: BlockId;
    } | {
        finality: Finality;
    }): Promise<AccessKeyView>;
    viewAccessKeys(accountId: string, blockQuery?: {
        block_id: BlockId;
    } | {
        finality: Finality;
    }): Promise<AccessKeyList>;
    protocolConfig(blockQuery?: {
        block_id: BlockId;
    } | {
        finality: Finality;
    }): Promise<NearProtocolConfig>;
    accountBalance(accountId: string, blockQuery?: {
        block_id: BlockId;
    } | {
        finality: Finality;
    }): Promise<AccountBalance>;
    viewCall(accountId: string, methodName: string, args: Record<string, unknown> | Uint8Array, blockQuery?: {
        block_id: BlockId;
    } | {
        finality: Finality;
    }): Promise<CodeResult>;
    /**
     * Get full response from RPC about result of view method
     * @param accountId
     * @param methodName
     * @param args Base64 encoded string
     * @param blockQuery
     * @returns
     */
    viewCallRaw(accountId: string, methodName: string, args: string, blockQuery?: {
        block_id: BlockId;
    } | {
        finality: Finality;
    }): Promise<CodeResult>;
    /**
     * Download the state of a contract given a prefix of a key.
     *
     * @param accountId contract account to lookup
     * @param prefix string or byte prefix of keys to loodup
     * @param blockQuery state at what block, defaults to most recent final block
     * @returns raw RPC response
     */
    viewState(accountId: string, prefix: string | Uint8Array, blockQuery?: {
        block_id: BlockId;
    } | {
        finality: Finality;
    }): Promise<Array<{
        key: Buffer;
        value: Buffer;
    }>>;
    /**
     * Download the state of a contract given a prefix of a key without decoding from base64.
     *
     * @param accountId contract account to lookup
     * @param prefix string or byte prefix of keys to loodup
     * @param blockQuery state at what block, defaults to most recent final block
     * @returns raw RPC response
     */
    viewStateRaw(accountId: string, prefix: string | Uint8Array, blockQuery?: {
        block_id: BlockId;
    } | {
        finality: Finality;
    }): Promise<StateItem[]>;
    /**
     * Updates records without using a transaction.
     * Note: only avaialable on Sandbox endpoints.
     * @param records
     * @returns Promise<Empty>
     */
    patchStateRecords(records: Records): Promise<Empty>;
    /**
     * Fast forward to a point in the future. The delta block height is supplied to tell the
     * network to advanced a certain amount of blocks. This comes with the advantage only having
     * to wait a fraction of the time it takes to produce the same number of blocks.
     *
     * Estimate as to how long it takes: if our delta_height crosses `X` epochs, then it would
     * roughly take `X * 5` milliseconds for the fast forward request to be processed.
     *
     * Note: This is not to be confused with speeding up the current in-flight transactions;
     * the state being forwarded in this case refers to time-related state (the block height, timestamp and epoch).
     * @param deltaHeight
     * @returns Promise<Empty>
     */
    fastForward(deltaHeight: number): Promise<Empty>;
}
export declare const TestnetRpc: JsonRpcProvider;
export declare const MainnetRpc: JsonRpcProvider;
//# sourceMappingURL=jsonrpc.d.ts.map
'''
'''--- packages/js/dist/jsonrpc.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MainnetRpc = exports.TestnetRpc = exports.JsonRpcProvider = void 0;
// eslint-disable unicorn/no-object-as-default-parameter
const buffer_1 = require("buffer");
const process_1 = __importDefault(require("process"));
const near_units_1 = require("near-units");
const transaction_1 = require("near-api-js/lib/transaction");
const types_1 = require("./types");
const OPTIMISTIC = { finality: 'optimistic' };
/**
 * Extends the main provider class in near-api-js, adding more methods for
 * interacting with an endpoint.
 */
class JsonRpcProvider extends types_1.JSONRpc {
    /**
     * Create a JsonRpcProvider from config or rpcAddr
     * @param config rpc endpoint URL or a configuration that includes one.
     * @returns JsonRpcProvider
     */
    static from(config) {
        const url = typeof config === 'string' ? config : config.rpcAddr;
        if (!this.providers.has(url)) {
            this.providers.set(url, new JsonRpcProvider({ url }));
        }
        return this.providers.get(url);
    }
    static fromNetwork(network) {
        switch (network) {
            case 'mainnet': return process_1.default.env.NEAR_CLI_MAINNET_RPC_SERVER_URL ? JsonRpcProvider.from(process_1.default.env.NEAR_CLI_MAINNET_RPC_SERVER_URL) : exports.MainnetRpc;
            case 'testnet': return process_1.default.env.NEAR_CLI_TESTNET_RPC_SERVER_URL ? JsonRpcProvider.from(process_1.default.env.NEAR_CLI_TESTNET_RPC_SERVER_URL) : exports.TestnetRpc;
            default: throw new TypeError('Invalid network only mainnet or testnet');
        }
    }
    /**
     * Download the binary of a given contract.
     * @param accountId contract account
     * @returns Buffer of Wasm binary
     */
    async viewCode(accountId, blockQuery) {
        return buffer_1.Buffer.from(await this.viewCodeRaw(accountId, blockQuery), 'base64');
    }
    /**
     * Download the binary of a given contract.
     * @param accountId contract account
     * @returns Base64 string of Wasm binary
     */
    async viewCodeRaw(accountId, blockQuery = OPTIMISTIC) {
        const { code_base64 } = await this.query({
            request_type: 'view_code',
            account_id: accountId,
            ...blockQuery,
        });
        return code_base64;
    }
    async viewAccount(accountId, blockQuery = OPTIMISTIC) {
        return this.query({
            request_type: 'view_account',
            account_id: accountId,
            ...blockQuery,
        });
    }
    async accountExists(accountId, blockQuery) {
        try {
            await this.viewAccount(accountId, blockQuery);
            return true;
        }
        catch {
            return false;
        }
    }
    async viewAccessKey(accountId, publicKey, blockQuery = OPTIMISTIC) {
        return this.query({
            request_type: 'view_access_key',
            account_id: accountId,
            public_key: typeof publicKey === 'string' ? publicKey : publicKey.toString(),
            ...blockQuery,
        });
    }
    async viewAccessKeys(accountId, blockQuery = OPTIMISTIC) {
        return this.query({
            request_type: 'view_access_key_list',
            account_id: accountId,
            ...blockQuery,
        });
    }
    async protocolConfig(blockQuery = OPTIMISTIC) {
        // @ts-expect-error Bad type
        return this.experimental_protocolConfig(blockQuery);
    }
    async accountBalance(accountId, blockQuery) {
        const config = await this.protocolConfig(blockQuery);
        const state = await this.viewAccount(accountId, blockQuery);
        const cost = config.runtime_config.storage_amount_per_byte;
        const costPerByte = near_units_1.NEAR.from(cost);
        const stateStaked = near_units_1.NEAR.from(state.storage_usage).mul(costPerByte);
        const staked = near_units_1.NEAR.from(state.locked);
        const total = near_units_1.NEAR.from(state.amount).add(staked);
        const available = total.sub(staked.max(stateStaked));
        return {
            total,
            stateStaked,
            staked,
            available,
        };
    }
    async viewCall(accountId, methodName, args, blockQuery) {
        const args_buffer = (0, transaction_1.stringifyJsonOrBytes)(args);
        return this.viewCallRaw(accountId, methodName, args_buffer.toString('base64'), blockQuery);
    }
    /**
     * Get full response from RPC about result of view method
     * @param accountId
     * @param methodName
     * @param args Base64 encoded string
     * @param blockQuery
     * @returns
     */
    async viewCallRaw(accountId, methodName, args, blockQuery = OPTIMISTIC) {
        return this.query({
            request_type: 'call_function',
            account_id: accountId,
            method_name: methodName,
            args_base64: args,
            ...blockQuery,
        });
    }
    /**
     * Download the state of a contract given a prefix of a key.
     *
     * @param accountId contract account to lookup
     * @param prefix string or byte prefix of keys to loodup
     * @param blockQuery state at what block, defaults to most recent final block
     * @returns raw RPC response
     */
    async viewState(accountId, prefix, blockQuery) {
        const values = await this.viewStateRaw(accountId, prefix, blockQuery);
        return values.map(({ key, value }) => ({
            key: buffer_1.Buffer.from(key, 'base64'),
            value: buffer_1.Buffer.from(value, 'base64'),
        }));
    }
    /**
     * Download the state of a contract given a prefix of a key without decoding from base64.
     *
     * @param accountId contract account to lookup
     * @param prefix string or byte prefix of keys to loodup
     * @param blockQuery state at what block, defaults to most recent final block
     * @returns raw RPC response
     */
    async viewStateRaw(accountId, prefix, blockQuery) {
        const { values } = await this.query({
            request_type: 'view_state',
            ...(blockQuery !== null && blockQuery !== void 0 ? blockQuery : { finality: 'optimistic' }),
            account_id: accountId,
            prefix_base64: buffer_1.Buffer.from(prefix).toString('base64'),
        });
        return values;
    }
    /**
     * Updates records without using a transaction.
     * Note: only avaialable on Sandbox endpoints.
     * @param records
     * @returns Promise<Empty>
     */
    async patchStateRecords(records) {
        return this.sendJsonRpc('sandbox_patch_state', records);
    }
    /**
     * Fast forward to a point in the future. The delta block height is supplied to tell the
     * network to advanced a certain amount of blocks. This comes with the advantage only having
     * to wait a fraction of the time it takes to produce the same number of blocks.
     *
     * Estimate as to how long it takes: if our delta_height crosses `X` epochs, then it would
     * roughly take `X * 5` milliseconds for the fast forward request to be processed.
     *
     * Note: This is not to be confused with speeding up the current in-flight transactions;
     * the state being forwarded in this case refers to time-related state (the block height, timestamp and epoch).
     * @param deltaHeight
     * @returns Promise<Empty>
     */
    async fastForward(deltaHeight) {
        return this.sendJsonRpc('sandbox_fast_forward', { delta_height: deltaHeight });
    }
}
exports.JsonRpcProvider = JsonRpcProvider;
JsonRpcProvider.providers = new Map();
exports.TestnetRpc = JsonRpcProvider.from(types_1.TESTNET_RPC_ADDR);
exports.MainnetRpc = JsonRpcProvider.from(types_1.MAINNET_RPC_ADDR);
//# sourceMappingURL=jsonrpc.js.map
'''
'''--- packages/js/dist/record/builder.d.ts ---
/// <reference types="node" />
import { Buffer } from 'buffer';
import { KeyPair, NamedAccount, PublicKey } from '../types';
import { AccessKeyData, Account, AccountData, StateRecord } from './types';
export declare class RecordBuilder {
    readonly records: StateRecord[];
    static fromAccount(accountId: string | Account | NamedAccount): AccountBuilder;
    push(record: StateRecord): this;
}
export declare class AccountBuilder extends RecordBuilder {
    readonly account_id: string;
    constructor(accountOrId: string | Account | NamedAccount);
    accessKey(key: string | PublicKey | KeyPair, access_key?: AccessKeyData): this;
    account(accountData?: Partial<AccountData>): this;
    data(data_key: string, value: string): this;
    contract(binary: Buffer | string): this;
}
//# sourceMappingURL=builder.d.ts.map
'''
'''--- packages/js/dist/record/builder.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountBuilder = exports.RecordBuilder = void 0;
const types_1 = require("../types");
const utils_1 = require("../utils");
class RecordBuilder {
    constructor() {
        this.records = [];
    }
    static fromAccount(accountId) {
        return new AccountBuilder(accountId);
    }
    push(record) {
        this.records.push(record);
        return this;
    }
}
exports.RecordBuilder = RecordBuilder;
const DEFAULT_ACCOUNT_DATA = {
    // 10_000 NEAR
    amount: '10000000000000000000000000000',
    locked: '0',
    // No contract hash
    code_hash: '11111111111111111111111111111111',
    storage_usage: 0,
    version: 'V1',
};
const DEFAULT_ACCESS_KEY_PERMISSION = { nonce: 0, permission: 'FullAccess' };
function isAccount(something) {
    return 'Account' in something
        && typeof something.Account.account_id === 'string';
}
function isNamedAccount(something) {
    return 'accountId' in something
        && typeof something.accountId === 'string';
}
class AccountBuilder extends RecordBuilder {
    constructor(accountOrId) {
        super();
        if (typeof accountOrId === 'string') {
            this.account_id = accountOrId;
        }
        else if (isAccount(accountOrId)) {
            this.account_id = accountOrId.Account.account_id;
            this.push(accountOrId);
        }
        else if (isNamedAccount(accountOrId)) {
            this.account_id = accountOrId.accountId;
        }
        else {
            throw new TypeError('Only `string` or `Record.Accounts` or `NamedAccount` are allowed.');
        }
    }
    accessKey(key, access_key = DEFAULT_ACCESS_KEY_PERMISSION) {
        const public_key = typeof key === 'string' ? key
            : (key instanceof types_1.PublicKey ? key.toString()
                : key.getPublicKey().toString());
        return this.push({
            AccessKey: {
                account_id: this.account_id,
                public_key,
                access_key,
            },
        });
    }
    account(accountData) {
        const account = { ...DEFAULT_ACCOUNT_DATA, ...accountData };
        return this.push({
            Account: {
                account_id: this.account_id,
                account,
            },
        });
    }
    data(data_key, value) {
        return this.push({
            Data: { account_id: this.account_id, data_key, value },
        });
    }
    contract(binary) {
        const code = typeof binary === 'string' ? binary : binary.toString('base64');
        const record = {
            Contract: {
                account_id: this.account_id,
                code,
            },
        };
        /**
         * Check conditions on ordering and hashes in records to throw error before sandbox does.
        */
        const accountRecord = this.records.find(r => 'Account' in r && r.Account.account_id === this.account_id);
        if (!accountRecord) {
            throw new Error(`Contract record with account_id: ${this.account_id} does not have a preceding Account record.`);
        }
        if ((0, utils_1.hashContract)(record.Contract.code) !== accountRecord.Account.account.code_hash) {
            throw new Error(`The hash field of the Account record with account_id: ${this.account_id} does not equal the hash of the binary in the Contract record.`);
        }
        return this.push(record);
    }
}
exports.AccountBuilder = AccountBuilder;
//# sourceMappingURL=builder.js.map
'''
'''--- packages/js/dist/record/index.d.ts ---
export * from './types';
export * from './builder';
//# sourceMappingURL=index.d.ts.map
'''
'''--- packages/js/dist/record/index.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./types"), exports);
__exportStar(require("./builder"), exports);
//# sourceMappingURL=index.js.map
'''
'''--- packages/js/dist/record/types.d.ts ---
import { FunctionCallPermissionView } from '../types';
export interface KeyData {
    public_key: string;
    access_key: AccessKeyData;
}
export interface AccessKeyData {
    nonce: number;
    permission: 'FullAccess' | FunctionCallPermissionView;
}
export interface AccessKey {
    AccessKey: {
        account_id: string;
    } & KeyData;
}
export interface AccountData {
    amount: string;
    locked: string;
    code_hash: string;
    storage_usage: number;
    version: 'V1';
}
export interface Account {
    Account: {
        account_id: string;
        account: AccountData;
    };
}
export interface Contract {
    Contract: {
        account_id: string;
        /** Base64 Encoded */
        code: string;
    };
}
export interface Data {
    Data: {
        account_id: string;
        data_key: string;
        value: string;
    };
}
export type StateRecord = Data | Account | AccessKey | Contract;
export interface Records {
    records: StateRecord[];
}
/**
 * Unimplemented types

    /// Postponed Action Receipt.
    PostponedReceipt(Box<Receipt>),
    /// Received data from DataReceipt encoded in base64 for the given account_id and data_id.
    ReceivedData {
        account_id: AccountId,
        data_id: CryptoHash,
        #[serde(with = "option_base64_format")]
        data: Option<Vec<u8>>,
    },
    /// Delayed Receipt.
    /// The receipt was delayed because the shard was overwhelmed.
    DelayedReceipt(Box<Receipt>),
 */
//# sourceMappingURL=types.d.ts.map
'''
'''--- packages/js/dist/record/types.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Unimplemented types

    /// Postponed Action Receipt.
    PostponedReceipt(Box<Receipt>),
    /// Received data from DataReceipt encoded in base64 for the given account_id and data_id.
    ReceivedData {
        account_id: AccountId,
        data_id: CryptoHash,
        #[serde(with = "option_base64_format")]
        data: Option<Vec<u8>>,
    },
    /// Delayed Receipt.
    /// The receipt was delayed because the shard was overwhelmed.
    DelayedReceipt(Box<Receipt>),
 */
//# sourceMappingURL=types.js.map
'''
'''--- packages/js/dist/server/index.d.ts ---
export * from './server';
//# sourceMappingURL=index.d.ts.map
'''
'''--- packages/js/dist/server/index.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./server"), exports);
//# sourceMappingURL=index.js.map
'''
'''--- packages/js/dist/server/server.d.ts ---
import { Config } from '../types';
export declare class SandboxServer {
    private static lastPort;
    private static binPath;
    private subprocess;
    private readyToDie;
    private readonly config;
    private constructor();
    static nextPort(): Promise<number>;
    static lockfilePath(filename: string): string;
    static randomHomeDir(): string;
    static init(config: Config): Promise<SandboxServer>;
    get homeDir(): string;
    get port(): number;
    get rpcAddr(): string;
    start(): Promise<SandboxServer>;
    close(): Promise<void>;
    private spawn;
}
//# sourceMappingURL=server.d.ts.map
'''
'''--- packages/js/dist/server/server.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SandboxServer = void 0;
const buffer_1 = require("buffer");
const process_1 = __importDefault(require("process"));
const promises_1 = require("fs/promises");
const path_1 = require("path");
const http = __importStar(require("http"));
const temp_dir_1 = __importDefault(require("temp-dir"));
const portCheck = __importStar(require("node-port-check"));
const pure_uuid_1 = __importDefault(require("pure-uuid"));
const internal_utils_1 = require("../internal-utils");
const pollData = JSON.stringify({
    jsonrpc: '2.0',
    id: 'dontcare',
    method: 'block',
    params: { finality: 'final' },
});
async function pingServer(port) {
    const options = {
        hostname: '0.0.0.0',
        port,
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Content-Length': buffer_1.Buffer.byteLength(pollData),
        },
    };
    return new Promise(resolve => {
        const request = http.request(options, result => {
            if (result.statusCode === 200) {
                resolve(true);
            }
            else {
                (0, internal_utils_1.debug)(`Sandbox running but got non-200 response: ${JSON.stringify(result)}`);
                resolve(false);
            }
        });
        request.on('error', _ => {
            resolve(false);
        });
        // Write data to request body
        request.write(pollData);
        request.end();
    });
}
async function sandboxStarted(port, timeout = 60000) {
    const checkUntil = Date.now() + timeout + 250;
    do {
        if (await pingServer(port)) { // eslint-disable-line no-await-in-loop
            return;
        }
        await new Promise(resolve => {
            setTimeout(() => resolve(true), 250); // eslint-disable-line @typescript-eslint/no-confusing-void-expression
        });
    } while (Date.now() < checkUntil);
    throw new Error(`Sandbox Server with port: ${port} failed to start after ${timeout}ms`);
}
// 5001-60000, increase the range of initialPort to decrease the possibility of port conflict
function initialPort() {
    return Math.max(5001, Math.floor(Math.random() * 60000));
}
class SandboxServer {
    constructor(config) {
        this.readyToDie = false;
        (0, internal_utils_1.debug)('Lifecycle.SandboxServer.constructor', 'config:', config);
        this.config = config;
    }
    static async nextPort() {
        this.lastPort = await portCheck.nextAvailable(this.lastPort + Math.max(1, Math.floor(Math.random() * 4)), '0.0.0.0');
        return this.lastPort;
    }
    static lockfilePath(filename) {
        return (0, path_1.join)(temp_dir_1.default, filename);
    }
    static randomHomeDir() {
        return (0, path_1.join)(temp_dir_1.default, 'sandbox', (new pure_uuid_1.default(4).toString()));
    }
    static async init(config) {
        (0, internal_utils_1.debug)('Lifecycle.SandboxServer.init()', 'config:', config);
        this.binPath = await (0, internal_utils_1.ensureBinary)();
        const server = new SandboxServer(config);
        if (server.config.refDir) {
            await (0, internal_utils_1.rm)(server.homeDir);
            await (0, internal_utils_1.copyDir)(server.config.refDir, server.config.homeDir);
        }
        if ((await (0, internal_utils_1.exists)(server.homeDir))) {
            await (0, internal_utils_1.rm)(server.homeDir);
        }
        const { stderr, code } = await server.spawn('init');
        if (code && code < 0) {
            (0, internal_utils_1.debug)(stderr);
            throw new Error('Failed to spawn sandbox server');
        }
        return server;
    }
    get homeDir() {
        return this.config.homeDir;
    }
    get port() {
        return this.config.port;
    }
    get rpcAddr() {
        return `http://localhost:${this.port}`;
    }
    async start() {
        (0, internal_utils_1.debug)('Lifecycle.SandboxServer.start()');
        const args = [
            '--home',
            this.homeDir,
            'run',
            '--rpc-addr',
            `0.0.0.0:${this.port}`,
            '--network-addr',
            `0.0.0.0:${await SandboxServer.nextPort()}`,
        ];
        if (process_1.default.env.NEAR_WORKSPACES_DEBUG) {
            const filePath = (0, path_1.join)(this.homeDir, 'sandboxServer.log');
            (0, internal_utils_1.debug)(`near-sandbox logs writing to file: ${filePath}`);
            const fd = await (0, promises_1.open)(filePath, 'a');
            this.subprocess = (0, internal_utils_1.spawn)(SandboxServer.binPath, args, {
                env: { RUST_BACKTRACE: 'full' },
                // @ts-expect-error FileHandle not assignable to Stream | IOType
                stdio: ['ignore', 'ignore', fd],
            });
            this.subprocess.on('exit', async () => {
                await fd.close();
            });
        }
        else {
            this.subprocess = (0, internal_utils_1.spawn)(SandboxServer.binPath, args, {
                stdio: ['ignore', 'ignore', 'ignore'],
            });
        }
        this.subprocess.on('exit', () => {
            if (!this.readyToDie) {
                (0, internal_utils_1.debug)(`Server with port ${this.port}: died horribly`);
            }
        });
        await sandboxStarted(this.port);
        return this;
    }
    async close() {
        var _a;
        (0, internal_utils_1.debug)('Lifecycle.SandboxServer.close()');
        this.readyToDie = true;
        if (!this.subprocess.kill('SIGINT')) {
            console.error(`Failed to kill child process with PID: ${(_a = this.subprocess.pid) !== null && _a !== void 0 ? _a : 'undefined'}`);
        }
        if (this.config.rm) {
            await (0, internal_utils_1.rm)(this.homeDir);
        }
    }
    async spawn(command) {
        (0, internal_utils_1.debug)('Lifecycle.SandboxServer.spawn()');
        return (0, internal_utils_1.asyncSpawn)(SandboxServer.binPath, '--home', this.homeDir, command);
    }
}
exports.SandboxServer = SandboxServer;
SandboxServer.lastPort = initialPort();
//# sourceMappingURL=server.js.map
'''
'''--- packages/js/dist/transaction-result.d.ts ---
import { Gas } from 'near-units';
import { Action, ClientConfig, ExecutionError, ExecutionOutcome, ExecutionOutcomeWithId, ExecutionStatus, ExecutionStatusBasic, FinalExecutionOutcome, FinalExecutionStatus, FinalExecutionStatusBasic, PublicKey } from './types';
export declare class ReceiptOutcome {
    outcome: ExecutionOutcome;
    constructor(outcome: ExecutionOutcome);
    get failures(): Array<Record<string, unknown>>;
    get status(): ExecutionStatus | ExecutionStatusBasic;
    get succeeded(): boolean;
    get isFailure(): boolean;
    get executionStatus(): ExecutionStatus;
    parseResult(): any;
    get SuccessValue(): string | undefined;
    get executionFailure(): ExecutionError | undefined;
    get failureMessage(): string | undefined;
    get failureType(): string | undefined;
    get logs(): string[];
    get gas_burnt(): Gas;
}
export declare class TransactionResult {
    readonly result: FinalExecutionOutcome;
    readonly startMs: number;
    readonly endMs: number;
    private readonly config;
    constructor(result: FinalExecutionOutcome, startMs: number, endMs: number, config: ClientConfig);
    get durationMs(): number;
    get outcomesWithId(): ExecutionOutcomeWithId[];
    get receipts_outcomes(): ReceiptOutcome[];
    get outcome(): ExecutionOutcome;
    get outcomes(): ExecutionOutcome[];
    get logs(): string[];
    get transactionReceipt(): TransactionReceipt;
    get failures(): ExecutionError[];
    get status(): FinalExecutionStatus | FinalExecutionStatusBasic;
    get succeeded(): boolean;
    get SuccessValue(): string | null;
    get failed(): boolean;
    get Failure(): ExecutionError | null;
    logsContain(pattern: string | RegExp): boolean;
    findLogs(pattern: string | RegExp): string[];
    receiptSuccessValuesContain(pattern: string | RegExp): boolean;
    findReceiptSuccessValues(pattern: string | RegExp): string[];
    get finalExecutionStatus(): FinalExecutionStatus;
    get receiptFailures(): ExecutionError[];
    get receiptSuccessValues(): string[];
    get receiptFailureMessages(): string[];
    get gas_burnt(): Gas;
    receiptFailureMessagesContain(pattern: string | RegExp): boolean;
    parseResult<T>(): T;
    parsedReceiptResults(): any[];
    summary(): string;
}
export interface TransactionReceipt {
    actions: Action[];
    hash: string;
    nonce: number;
    public_key: PublicKey;
    receiver_id: string;
    signature: string;
    signer_id: string;
}
export declare class TransactionError extends Error {
    constructor(result: TransactionResult);
    parse(): ExecutionOutcome;
}
export type TxResult = TransactionResult;
//# sourceMappingURL=transaction-result.d.ts.map
'''
'''--- packages/js/dist/transaction-result.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionError = exports.TransactionResult = exports.ReceiptOutcome = void 0;
const buffer_1 = require("buffer");
const near_units_1 = require("near-units");
function includes(pattern) {
    if (typeof pattern === 'string') {
        return s => s.includes(pattern);
    }
    return s => pattern.test(s);
}
function parseValue(value) {
    const buffer = buffer_1.Buffer.from(value, 'base64').toString();
    try {
        return JSON.parse(buffer);
    }
    catch {
        return buffer;
    }
}
class ReceiptOutcome {
    constructor(outcome) {
        this.outcome = outcome;
    }
    get failures() {
        return [];
    }
    get status() {
        return this.outcome.status;
    }
    get succeeded() {
        if (typeof this.status === 'string') {
            return false;
        }
        return this.status.SuccessValue !== undefined;
    }
    get isFailure() {
        if (typeof this.status === 'string') {
            return false;
        }
        return this.status.Failure !== undefined;
    }
    get executionStatus() {
        return this.status;
    }
    parseResult() {
        if (this.succeeded) {
            return parseValue(this.SuccessValue);
        }
        throw new Error(JSON.stringify(this.status));
    }
    get SuccessValue() {
        if (this.succeeded) {
            return this.executionStatus.SuccessValue;
        }
        return undefined;
    }
    get executionFailure() {
        if (this.isFailure) {
            return this.executionStatus.Failure;
        }
        return undefined;
    }
    get failureMessage() {
        var _a;
        return (_a = this.executionFailure) === null || _a === void 0 ? void 0 : _a.error_message;
    }
    get failureType() {
        var _a;
        return (_a = this.executionFailure) === null || _a === void 0 ? void 0 : _a.error_type;
    }
    get logs() {
        return this.outcome.logs;
    }
    get gas_burnt() {
        return near_units_1.Gas.from(this.outcome.gas_burnt);
    }
}
exports.ReceiptOutcome = ReceiptOutcome;
class TransactionResult {
    constructor(result, startMs, endMs, config) {
        this.result = result;
        this.startMs = startMs;
        this.endMs = endMs;
        this.config = config;
    }
    get durationMs() {
        return this.endMs - this.startMs;
    }
    get outcomesWithId() {
        const { result } = this;
        return [result.transaction_outcome, ...result.receipts_outcome];
    }
    get receipts_outcomes() {
        return this.result.receipts_outcome.flatMap(o => new ReceiptOutcome(o.outcome));
    }
    get outcome() {
        return this.result.transaction_outcome.outcome;
    }
    get outcomes() {
        return this.outcomesWithId.flatMap(o => o.outcome);
    }
    get logs() {
        return this.outcomes.flatMap(it => it.logs);
    }
    get transactionReceipt() {
        return this.result.transaction;
    }
    get failures() {
        const failures = [...this.receiptFailures];
        if (this.Failure) {
            failures.unshift(this.Failure);
        }
        return failures;
    }
    get status() {
        return this.result.status;
    }
    get succeeded() {
        if (typeof this.result.status === 'string') {
            return false;
        }
        return this.result.status.SuccessValue !== undefined;
    }
    get SuccessValue() {
        if (this.succeeded) {
            return this.finalExecutionStatus.SuccessValue;
        }
        return null;
    }
    get failed() {
        if (typeof this.result.status === 'string') {
            return false;
        }
        return this.result.status.Failure !== undefined;
    }
    get Failure() {
        if (this.failed) {
            return this.finalExecutionStatus.Failure;
        }
        return null;
    }
    logsContain(pattern) {
        return this.logs.some(includes(pattern));
    }
    findLogs(pattern) {
        return this.logs.filter(includes(pattern));
    }
    receiptSuccessValuesContain(pattern) {
        return this.receiptSuccessValues.some(includes(pattern));
    }
    findReceiptSuccessValues(pattern) {
        return this.receiptSuccessValues.filter(includes(pattern));
    }
    get finalExecutionStatus() {
        return this.status;
    }
    get receiptFailures() {
        return this.receipts_outcomes.flatMap(o => { var _a; return (_a = o.executionFailure) !== null && _a !== void 0 ? _a : []; });
    }
    get receiptSuccessValues() {
        return this.receipts_outcomes.flatMap(o => { var _a; return (_a = o.SuccessValue) !== null && _a !== void 0 ? _a : []; });
    }
    get receiptFailureMessages() {
        return this.receiptFailures.map(failure => JSON.stringify(failure));
    }
    get gas_burnt() {
        const receipts_gas = this.receipts_outcomes.reduce((acc, cur) => acc + cur.outcome.gas_burnt, 0);
        return near_units_1.Gas.from(this.result.transaction_outcome.outcome.gas_burnt + receipts_gas);
    }
    receiptFailureMessagesContain(pattern) {
        return this.receiptFailureMessages.some(includes(pattern));
    }
    parseResult() {
        if (this.succeeded) {
            return parseValue(this.SuccessValue);
        }
        throw new Error(JSON.stringify(this.status));
    }
    parsedReceiptResults() {
        return this.receiptSuccessValues.map(parseValue);
    }
    summary() {
        return `(${this.durationMs} ms) burned ${this.gas_burnt.toHuman()} ${transactionReceiptToString(this.transactionReceipt, this.config.explorerUrl)}`;
    }
}
exports.TransactionResult = TransactionResult;
function transactionReceiptToString(tx, explorerUrl) {
    return `${tx.signer_id} -> ${tx.receiver_id} Nonce: ${tx.nonce} Hash: ${explorerUrl ? explorerUrl + '/' : ''}${tx.hash} Actions:\n${tx.actions.map(a => JSON.stringify(a)).join('\n')}`;
}
class TransactionError extends Error {
    constructor(result) {
        super(JSON.stringify(result));
    }
    parse() {
        return JSON.parse(this.message);
    }
}
exports.TransactionError = TransactionError;
//# sourceMappingURL=transaction-result.js.map
'''
'''--- packages/js/dist/transaction.d.ts ---
/// <reference types="node" />
/// <reference types="node" />
import { Buffer } from 'buffer';
import { URL } from 'url';
import { NEAR } from 'near-units';
import { TransactionResult } from './transaction-result';
import { Action, PublicKey, AccessKey, BN, KeyPair, NamedAccount } from './types';
export declare abstract class Transaction {
    readonly receiverId: string;
    readonly senderId: string;
    readonly actions: Action[];
    private accountToBeCreated;
    private _transferAmount?;
    constructor(sender: NamedAccount | string, receiver: NamedAccount | string);
    addKey(publicKey: string | PublicKey, accessKey?: AccessKey): this;
    createAccount(): this;
    deleteAccount(beneficiaryId: string): this;
    deleteKey(publicKey: string | PublicKey): this;
    /**
     * Deploy given Wasm file to the account.
     *
     * @param code path or data of contract binary. If given an absolute path (such as one created with 'path.join(__dirname, …)') will use it directly. If given a relative path such as `res/contract.wasm`, will resolve it from the project root (meaning the location of the package.json file).
     */
    deployContractFile(code: string | URL | Uint8Array | Buffer): Promise<Transaction>;
    deployContract(code: Uint8Array | Buffer): this;
    functionCall(methodName: string, args: Record<string, unknown> | Uint8Array, { gas, attachedDeposit, }?: {
        gas?: BN | string;
        attachedDeposit?: BN | string;
    }): this;
    stake(amount: BN | string, publicKey: PublicKey | string): this;
    transfer(amount: string | BN): this;
    get accountCreated(): boolean;
    get transferAmount(): NEAR;
    abstract transact(keyPair?: KeyPair): Promise<TransactionResult>;
}
//# sourceMappingURL=transaction.d.ts.map
'''
'''--- packages/js/dist/transaction.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
const fs = __importStar(require("fs/promises"));
const near_units_1 = require("near-units");
const types_1 = require("./types");
const internal_utils_1 = require("./internal-utils");
const utils_1 = require("./utils");
class Transaction {
    constructor(sender, receiver) {
        this.actions = [];
        this.accountToBeCreated = false;
        this.senderId = typeof sender === 'string' ? sender : sender.accountId;
        this.receiverId = typeof receiver === 'string' ? receiver : receiver.accountId;
    }
    addKey(publicKey, accessKey = (0, types_1.fullAccessKey)()) {
        this.actions.push((0, types_1.addKey)(types_1.PublicKey.from(publicKey), accessKey));
        return this;
    }
    createAccount() {
        this.accountToBeCreated = true;
        this.actions.push((0, types_1.createAccount)());
        return this;
    }
    deleteAccount(beneficiaryId) {
        this.actions.push((0, types_1.deleteAccount)(beneficiaryId));
        return this;
    }
    deleteKey(publicKey) {
        this.actions.push((0, types_1.deleteKey)(types_1.PublicKey.from(publicKey)));
        return this;
    }
    /**
     * Deploy given Wasm file to the account.
     *
     * @param code path or data of contract binary. If given an absolute path (such as one created with 'path.join(__dirname, …)') will use it directly. If given a relative path such as `res/contract.wasm`, will resolve it from the project root (meaning the location of the package.json file).
     */
    async deployContractFile(code) {
        return this.deployContract((0, internal_utils_1.isPathLike)(code)
            ? await fs.readFile(code.toString().startsWith('/') ? code : await (0, internal_utils_1.findFile)(code.toString()))
            : code);
    }
    deployContract(code) {
        this.actions.push((0, types_1.deployContract)(code));
        return this;
    }
    functionCall(methodName, args, { 
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    gas = types_1.DEFAULT_FUNCTION_CALL_GAS, attachedDeposit = utils_1.NO_DEPOSIT, } = {}) {
        this.actions.push((0, types_1.functionCall)(methodName, args, (0, utils_1.parseGas)(gas), (0, utils_1.parseNEAR)(attachedDeposit)));
        return this;
    }
    stake(amount, publicKey) {
        this.actions.push((0, types_1.stake)(new types_1.BN(amount), types_1.PublicKey.from(publicKey)));
        return this;
    }
    transfer(amount) {
        this._transferAmount = (0, utils_1.parseNEAR)(amount);
        this.actions.push((0, types_1.transfer)(this._transferAmount));
        return this;
    }
    get accountCreated() {
        return this.accountToBeCreated;
    }
    get transferAmount() {
        var _a;
        return (_a = this._transferAmount) !== null && _a !== void 0 ? _a : near_units_1.NEAR.from('0');
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=transaction.js.map
'''
'''--- packages/js/dist/types.d.ts ---
/// <reference types="node" />
import { ChildProcess } from 'child_process';
import _BN from 'bn.js';
import { KeyPair } from 'near-api-js';
import { Output } from 'promisify-child-process';
import { NEAR } from 'near-units';
import { KeyStore } from 'near-api-js/lib/key_stores';
export { ServerError } from 'near-api-js/lib/utils/rpc_errors';
export { KeyPair, Connection } from 'near-api-js';
export { PublicKey, KeyPairEd25519 } from 'near-api-js/lib/utils';
export { Action, createAccount, deployContract, functionCall, transfer, stake, addKey, deleteKey, deleteAccount, fullAccessKey, AccessKey, } from 'near-api-js/lib/transaction';
export { JsonRpcProvider as JSONRpc } from 'near-api-js/lib/providers/json-rpc-provider';
export { KeyStore } from 'near-api-js/lib/key_stores';
export * from 'near-api-js/lib/providers/provider';
export { DEFAULT_FUNCTION_CALL_GAS } from 'near-api-js/lib/constants';
export declare class BN extends _BN {
    toJSON(): string;
}
export type Args = Record<string, any> | Uint8Array;
export interface NamedAccount {
    accountId: string;
}
export interface CallOptions {
    gas?: string | BN;
    attachedDeposit?: string | BN;
    signWithKey?: KeyPair;
}
export type ChildProcessPromise = Promise<ChildProcess & Promise<Output>>;
export interface AccountBalance {
    total: NEAR;
    stateStaked: NEAR;
    staked: NEAR;
    available: NEAR;
}
export type Network = 'testnet' | 'mainnet' | 'sandbox' | 'custom';
export interface ClientConfig {
    network: Network;
    rootAccountId?: string;
    testnetMasterAccountId?: string;
    rpcAddr: string;
    apiKey?: string;
    helperUrl?: string;
    explorerUrl?: string;
    initialBalance?: string;
    walletUrl?: string;
    archivalUrl?: string;
}
export interface Config extends ClientConfig {
    homeDir: string;
    port: number;
    rm: boolean;
    refDir: string | null;
    keyStore?: KeyStore;
}
export declare const TESTNET_RPC_ADDR = "https://archival-rpc.testnet.near.org";
export declare const MAINNET_RPC_ADDR = "https://archival-rpc.mainnet.near.org";
export interface StateItem {
    key: string;
    value: string;
    proof: string[];
}
export type Empty = {};
//# sourceMappingURL=types.d.ts.map
'''
'''--- packages/js/dist/types.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAINNET_RPC_ADDR = exports.TESTNET_RPC_ADDR = exports.BN = exports.DEFAULT_FUNCTION_CALL_GAS = exports.KeyStore = exports.JSONRpc = exports.AccessKey = exports.fullAccessKey = exports.deleteAccount = exports.deleteKey = exports.addKey = exports.stake = exports.transfer = exports.functionCall = exports.deployContract = exports.createAccount = exports.Action = exports.KeyPairEd25519 = exports.PublicKey = exports.Connection = exports.KeyPair = exports.ServerError = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
var rpc_errors_1 = require("near-api-js/lib/utils/rpc_errors");
Object.defineProperty(exports, "ServerError", { enumerable: true, get: function () { return rpc_errors_1.ServerError; } });
var near_api_js_1 = require("near-api-js");
Object.defineProperty(exports, "KeyPair", { enumerable: true, get: function () { return near_api_js_1.KeyPair; } });
Object.defineProperty(exports, "Connection", { enumerable: true, get: function () { return near_api_js_1.Connection; } });
var utils_1 = require("near-api-js/lib/utils");
Object.defineProperty(exports, "PublicKey", { enumerable: true, get: function () { return utils_1.PublicKey; } });
Object.defineProperty(exports, "KeyPairEd25519", { enumerable: true, get: function () { return utils_1.KeyPairEd25519; } });
var transaction_1 = require("near-api-js/lib/transaction");
Object.defineProperty(exports, "Action", { enumerable: true, get: function () { return transaction_1.Action; } });
Object.defineProperty(exports, "createAccount", { enumerable: true, get: function () { return transaction_1.createAccount; } });
Object.defineProperty(exports, "deployContract", { enumerable: true, get: function () { return transaction_1.deployContract; } });
Object.defineProperty(exports, "functionCall", { enumerable: true, get: function () { return transaction_1.functionCall; } });
Object.defineProperty(exports, "transfer", { enumerable: true, get: function () { return transaction_1.transfer; } });
Object.defineProperty(exports, "stake", { enumerable: true, get: function () { return transaction_1.stake; } });
Object.defineProperty(exports, "addKey", { enumerable: true, get: function () { return transaction_1.addKey; } });
Object.defineProperty(exports, "deleteKey", { enumerable: true, get: function () { return transaction_1.deleteKey; } });
Object.defineProperty(exports, "deleteAccount", { enumerable: true, get: function () { return transaction_1.deleteAccount; } });
Object.defineProperty(exports, "fullAccessKey", { enumerable: true, get: function () { return transaction_1.fullAccessKey; } });
Object.defineProperty(exports, "AccessKey", { enumerable: true, get: function () { return transaction_1.AccessKey; } });
var json_rpc_provider_1 = require("near-api-js/lib/providers/json-rpc-provider");
Object.defineProperty(exports, "JSONRpc", { enumerable: true, get: function () { return json_rpc_provider_1.JsonRpcProvider; } });
var key_stores_1 = require("near-api-js/lib/key_stores");
Object.defineProperty(exports, "KeyStore", { enumerable: true, get: function () { return key_stores_1.KeyStore; } });
__exportStar(require("near-api-js/lib/providers/provider"), exports);
var constants_1 = require("near-api-js/lib/constants");
Object.defineProperty(exports, "DEFAULT_FUNCTION_CALL_GAS", { enumerable: true, get: function () { return constants_1.DEFAULT_FUNCTION_CALL_GAS; } });
class BN extends bn_js_1.default {
    toJSON() {
        return this.toString(10);
    }
}
exports.BN = BN;
exports.TESTNET_RPC_ADDR = 'https://archival-rpc.testnet.near.org';
exports.MAINNET_RPC_ADDR = 'https://archival-rpc.mainnet.near.org';
//# sourceMappingURL=types.js.map
'''
'''--- packages/js/dist/utils.d.ts ---
/// <reference types="node" />
import { Buffer } from 'buffer';
import { Gas, NEAR } from 'near-units';
import { NamedAccount, KeyPair, ClientConfig, KeyStore, BN } from './types';
export declare const ONE_NEAR: NEAR;
export declare function toYocto(amount: string): string;
export declare function createKeyPair(): KeyPair;
export declare function tGas(x: string | number): string;
export declare function randomAccountId(prefix?: string, dateLength?: number, suffixLength?: number): string;
export declare function asId(id: string | NamedAccount): string;
export declare const NO_DEPOSIT: NEAR;
export declare function captureError(fn: () => Promise<any>): Promise<string>;
export declare function isTopLevelAccount(accountId: string): boolean;
export declare function urlConfigFromNetwork(network: string | {
    network: string;
    rpcAddr?: string;
}): ClientConfig;
/**
 *
 * @param contract Base64 encoded binary or Buffer.
 * @returns sha256 hash of contract.
 */
export declare function hashContract(contract: string | Buffer): string;
export declare const EMPTY_CONTRACT_HASH = "11111111111111111111111111111111";
/**
 *
 * @returns network to connect to. Default 'sandbox'
 */
export declare function getNetworkFromEnv(): 'sandbox' | 'testnet' | 'custom';
export declare function homeKeyStore(): KeyStore;
export declare function timeSuffix(prefix: string, length?: number): string;
export declare function parseGas(s: string | BN): Gas;
export declare function parseNEAR(s: string | BN): NEAR;
//# sourceMappingURL=utils.d.ts.map
'''
'''--- packages/js/dist/utils.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseNEAR = exports.parseGas = exports.timeSuffix = exports.homeKeyStore = exports.getNetworkFromEnv = exports.EMPTY_CONTRACT_HASH = exports.hashContract = exports.urlConfigFromNetwork = exports.isTopLevelAccount = exports.captureError = exports.NO_DEPOSIT = exports.asId = exports.randomAccountId = exports.tGas = exports.createKeyPair = exports.toYocto = exports.ONE_NEAR = void 0;
const buffer_1 = require("buffer");
const process = __importStar(require("process"));
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const nearAPI = __importStar(require("near-api-js"));
const js_sha256_1 = __importDefault(require("js-sha256"));
const bs58_1 = __importDefault(require("bs58"));
const near_units_1 = require("near-units");
exports.ONE_NEAR = near_units_1.NEAR.parse('1N');
function toYocto(amount) {
    return near_units_1.NEAR.parse(`${amount}N`).toString();
}
exports.toYocto = toYocto;
function createKeyPair() {
    return nearAPI.utils.KeyPairEd25519.fromRandom();
}
exports.createKeyPair = createKeyPair;
function tGas(x) {
    if (typeof x === 'string' && Number.isNaN(Number.parseInt(x, 10))) {
        throw new TypeError(`tGas expects a number or a number-like string; got: ${x}`);
    }
    return String(x) + '0'.repeat(12);
}
exports.tGas = tGas;
// Create random account with at least 33 digits by default
function randomAccountId(prefix = 'dev-', dateLength = 13, suffixLength = 15) {
    const suffix = Math.floor(Math.random() * (10 ** 22)) % (10 ** suffixLength);
    return `${timeSuffix(prefix, dateLength)}-${suffix}`;
}
exports.randomAccountId = randomAccountId;
function asId(id) {
    return typeof id === 'string' ? id : id.accountId;
}
exports.asId = asId;
exports.NO_DEPOSIT = near_units_1.NEAR.from(0);
async function captureError(fn) {
    try {
        await fn();
    }
    catch (error) {
        if (error instanceof Error) {
            return error.message;
        }
    }
    throw new Error('fn succeeded when expected to throw an exception');
}
exports.captureError = captureError;
function isTopLevelAccount(accountId) {
    return !accountId.includes('.');
}
exports.isTopLevelAccount = isTopLevelAccount;
function configFromDomain(network) {
    let rpcAddr = `https://archival-rpc.${network}.near.org`;
    if (network === 'mainnet' && process.env.NEAR_CLI_MAINNET_RPC_SERVER_URL) {
        rpcAddr = process.env.NEAR_CLI_MAINNET_RPC_SERVER_URL;
    }
    else if (network === 'testnet' && process.env.NEAR_CLI_TESTNET_RPC_SERVER_URL) {
        rpcAddr = process.env.NEAR_CLI_TESTNET_RPC_SERVER_URL;
    }
    return {
        network,
        rpcAddr,
        walletUrl: `https://wallet.${network}.near.org`,
        helperUrl: `https://helper.${network}.near.org`,
        explorerUrl: `https://explorer.${network}.near.org`,
        archivalUrl: `https://archival-rpc.${network}.near.org`,
    };
}
function urlConfigFromNetwork(network) {
    const networkName = typeof network === 'string' ? network : network.network;
    const rpcAddr = typeof network === 'string' ? undefined : network.rpcAddr;
    switch (networkName) {
        case 'sandbox':
            return {
                network: 'sandbox',
                rpcAddr: 'http://localhost',
            };
        case 'custom':
            return {
                network: 'custom',
                rpcAddr: rpcAddr,
            };
        case 'testnet':
        case 'mainnet': return configFromDomain(networkName);
        default:
            throw new Error(`Got network ${networkName}, but only accept 'sandbox', 'testnet', 'mainnet' and 'custom'`);
    }
}
exports.urlConfigFromNetwork = urlConfigFromNetwork;
/**
 *
 * @param contract Base64 encoded binary or Buffer.
 * @returns sha256 hash of contract.
 */
function hashContract(contract) {
    const bytes = typeof contract === 'string' ? buffer_1.Buffer.from(contract, 'base64') : contract;
    const buffer = buffer_1.Buffer.from(js_sha256_1.default.sha256(bytes), 'hex');
    return bs58_1.default.encode(buffer);
}
exports.hashContract = hashContract;
exports.EMPTY_CONTRACT_HASH = '11111111111111111111111111111111';
/**
 *
 * @returns network to connect to. Default 'sandbox'
 */
function getNetworkFromEnv() {
    const network = process.env.NEAR_WORKSPACES_NETWORK;
    switch (network) {
        case 'sandbox':
        case 'testnet':
        case 'custom':
            return network;
        case undefined:
            return 'sandbox';
        default:
            throw new Error(`environment variable NEAR_WORKSPACES_NETWORK=${network} invalid; `
                + 'use \'testnet\', \'custom\', or \'sandbox\' (the default)');
    }
}
exports.getNetworkFromEnv = getNetworkFromEnv;
function homeKeyStore() {
    return new nearAPI.keyStores.UnencryptedFileSystemKeyStore(path.join(os.homedir(), '.near-credentials'));
}
exports.homeKeyStore = homeKeyStore;
function timeSuffix(prefix, length = 6) {
    return `${prefix}${Date.now() % (10 ** length)}`;
}
exports.timeSuffix = timeSuffix;
const NOT_NUMBER_OR_UNDERLINE = /[^\d_]/;
function parseGas(s) {
    if (typeof s === 'string' && NOT_NUMBER_OR_UNDERLINE.test(s)) {
        return near_units_1.Gas.parse(s);
    }
    return near_units_1.Gas.from(s);
}
exports.parseGas = parseGas;
// One difference with `NEAR.parse` is that here strings of just numbers are considered `yN`
// And not `N`
function parseNEAR(s) {
    if (typeof s === 'string' && NOT_NUMBER_OR_UNDERLINE.test(s)) {
        return near_units_1.NEAR.parse(s);
    }
    return near_units_1.NEAR.from(s);
}
exports.parseNEAR = parseNEAR;
//# sourceMappingURL=utils.js.map
'''
'''--- packages/js/dist/worker.d.ts ---
import { Config } from './types';
import { NearAccount, NearAccountManager } from './account';
import { JsonRpcProvider } from './jsonrpc';
/**
 * The main interface to near-workspaces. Create a new worker instance with {@link Worker.init}, then run code on it.
 */
export declare abstract class Worker {
    protected config: Config;
    protected manager: NearAccountManager;
    constructor(config: Config);
    /**
     * Initialize a new worker.
     *
     * In local sandbox mode, this will:
     *   - Create a new local blockchain
     *   - Load the root account for that blockchain, available as `root`:
     *
     * In testnet mode, the same functionality is achieved via different means:
     * creating a new account as the `root`.
     * Since all actions must occur on one blockchain instead of N.
     *
     * @param config a configuration object
     * @returns an instance of the Worker class
     */
    static init(config?: Partial<Config>): Promise<Worker>;
    get rootAccount(): NearAccount;
    abstract get provider(): JsonRpcProvider;
    abstract tearDown(): Promise<void>;
}
export declare class CustomnetWorker extends Worker {
    private readonly clientConfig;
    static init(config: Partial<Config>): Promise<CustomnetWorker>;
    get provider(): JsonRpcProvider;
    tearDown(): Promise<void>;
    get defaultConfig(): Config;
}
export declare class TestnetWorker extends Worker {
    static init(config: Partial<Config>): Promise<TestnetWorker>;
    get provider(): JsonRpcProvider;
    tearDown(): Promise<void>;
    static get defaultConfig(): Config;
    private static get clientConfig();
}
export declare class SandboxWorker extends Worker {
    private server;
    static init(config: Partial<Config>): Promise<SandboxWorker>;
    static defaultConfig(): Promise<Config>;
    get provider(): JsonRpcProvider;
    tearDown(): Promise<void>;
    private static get clientConfig();
    private get rpcAddr();
}
//# sourceMappingURL=worker.d.ts.map
'''
'''--- packages/js/dist/worker.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SandboxWorker = exports.TestnetWorker = exports.CustomnetWorker = exports.Worker = void 0;
const fs_1 = __importDefault(require("fs"));
const near_units_1 = require("near-units");
const proper_lockfile_1 = require("proper-lockfile");
const utils_1 = require("./utils");
const account_1 = require("./account");
const jsonrpc_1 = require("./jsonrpc");
const internal_utils_1 = require("./internal-utils");
const server_1 = require("./server/server");
const API_KEY_HEADER = 'x-api-key';
/**
 * The main interface to near-workspaces. Create a new worker instance with {@link Worker.init}, then run code on it.
 */
class Worker {
    constructor(config) {
        (0, internal_utils_1.debug)('Lifecycle.Worker.constructor', 'config:', config);
        this.config = config;
        this.manager = account_1.AccountManager.create(config);
    }
    /**
     * Initialize a new worker.
     *
     * In local sandbox mode, this will:
     *   - Create a new local blockchain
     *   - Load the root account for that blockchain, available as `root`:
     *
     * In testnet mode, the same functionality is achieved via different means:
     * creating a new account as the `root`.
     * Since all actions must occur on one blockchain instead of N.
     *
     * @param config a configuration object
     * @returns an instance of the Worker class
     */
    static async init(config = {}) {
        var _a;
        (0, internal_utils_1.debug)('Lifecycle.Worker.init()', 'config:', config);
        switch ((_a = config.network) !== null && _a !== void 0 ? _a : (0, utils_1.getNetworkFromEnv)()) {
            case 'testnet':
                return TestnetWorker.init(config);
            case 'sandbox':
                return SandboxWorker.init(config);
            case 'custom':
                return CustomnetWorker.init(config);
            default:
                throw new Error(`config.network = '${config.network}' invalid; ` // eslint-disable-line @typescript-eslint/restrict-template-expressions
                    + 'must be \'testnet\', \'sandbox\' or \'custom\' (the default). Soon \'mainnet\'');
        }
    }
    get rootAccount() {
        return this.manager.root;
    }
}
exports.Worker = Worker;
// Connect to a custom network.
// Note: the burden of ensuring the methods that are able to be called are left up to the user.
class CustomnetWorker extends Worker {
    constructor() {
        super(...arguments);
        this.clientConfig = (0, utils_1.urlConfigFromNetwork)({ network: 'custom', rpcAddr: this.config.rpcAddr });
    }
    static async init(config) {
        (0, internal_utils_1.debug)('Lifecycle.CustomnetWorker.create()', 'config:', config);
        const fullConfig = {
            homeDir: 'ignored',
            port: 3030,
            rm: false,
            refDir: null,
            ...(0, utils_1.urlConfigFromNetwork)({ network: 'custom', rpcAddr: config.rpcAddr }),
            ...config,
        };
        const worker = new CustomnetWorker(fullConfig);
        if (config.apiKey) {
            worker.provider.connection.headers = {
                ...worker.provider.connection.headers, [API_KEY_HEADER]: config.apiKey,
            };
        }
        await worker.manager.init();
        return worker;
    }
    get provider() {
        return jsonrpc_1.JsonRpcProvider.from(this.clientConfig);
    }
    async tearDown() {
        // We are not stopping any server here because it is an external network.
        return Promise.resolve();
    }
    get defaultConfig() {
        return {
            homeDir: 'ignored',
            port: 3030,
            rm: false,
            refDir: null,
            ...this.clientConfig,
        };
    }
}
exports.CustomnetWorker = CustomnetWorker;
class TestnetWorker extends Worker {
    static async init(config) {
        (0, internal_utils_1.debug)('Lifecycle.TestnetWorker.create()', 'config:', config);
        const fullConfig = { ...this.defaultConfig, ...config };
        const worker = new TestnetWorker(fullConfig);
        if (config.apiKey) {
            worker.provider.connection.headers = {
                ...worker.provider.connection.headers, [API_KEY_HEADER]: config.apiKey,
            };
        }
        await worker.manager.init();
        return worker;
    }
    get provider() {
        return jsonrpc_1.JsonRpcProvider.from(TestnetWorker.clientConfig);
    }
    async tearDown() {
        // We are not stoping any server here because we are using Testnet
        return Promise.resolve();
    }
    static get defaultConfig() {
        return {
            homeDir: 'ignored',
            port: 3030,
            rm: false,
            refDir: null,
            ...this.clientConfig,
        };
    }
    static get clientConfig() {
        return (0, utils_1.urlConfigFromNetwork)('testnet');
    }
}
exports.TestnetWorker = TestnetWorker;
class SandboxWorker extends Worker {
    static async init(config) {
        (0, internal_utils_1.debug)('Lifecycle.SandboxWorker.create()', 'config:', config);
        const syncFilename = server_1.SandboxServer.lockfilePath('near-sandbox-worker-sync.txt');
        try {
            fs_1.default.accessSync(syncFilename, fs_1.default.constants.F_OK);
        }
        catch {
            (0, internal_utils_1.debug)('catch err in access file:', syncFilename);
            fs_1.default.writeFileSync(syncFilename, 'workspace-js test port sync');
        }
        const retryOptions = {
            retries: {
                retries: 100,
                factor: 3,
                minTimeout: 200,
                maxTimeout: 2 * 1000,
                randomize: true,
            },
        };
        // Add file lock in assign port and run near node process
        const release = await (0, proper_lockfile_1.lock)(syncFilename, retryOptions);
        const defaultConfig = await this.defaultConfig();
        const worker = new SandboxWorker({ ...defaultConfig, ...config });
        if (config.apiKey) {
            worker.provider.connection.headers = {
                ...worker.provider.connection.headers, [API_KEY_HEADER]: config.apiKey,
            };
        }
        worker.server = await server_1.SandboxServer.init(worker.config);
        await worker.server.start();
        // Release file lock after near node start
        await release();
        await worker.manager.init();
        return worker;
    }
    static async defaultConfig() {
        const port = await server_1.SandboxServer.nextPort();
        return {
            ...this.clientConfig,
            homeDir: server_1.SandboxServer.randomHomeDir(),
            port,
            rm: false,
            refDir: null,
            rpcAddr: `http://localhost:${port}`,
        };
    }
    get provider() {
        return jsonrpc_1.JsonRpcProvider.from(this.rpcAddr);
    }
    async tearDown() {
        try {
            await this.server.close();
        }
        catch (error) {
            (0, internal_utils_1.debug)('this.server.close() threw error.', JSON.stringify(error, null, 2));
        }
    }
    static get clientConfig() {
        return {
            network: 'sandbox',
            rootAccountId: 'test.near',
            rpcAddr: '',
            initialBalance: near_units_1.NEAR.parse('100 N').toJSON(),
        };
    }
    get rpcAddr() {
        return `http://localhost:${this.config.port}`;
    }
}
exports.SandboxWorker = SandboxWorker;
//# sourceMappingURL=worker.js.map
'''
'''--- packages/js/package.json ---
{
  "name": "near-workspaces",
  "version": "3.5.0",
  "description": "Write tests in TypeScript/JavaScript to run in a controlled NEAR Sandbox local environment.",
  "repository": {
    "type": "git",
    "url": "git@github.com:near/workspaces-js.git",
    "directory": "packages/js"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org/"
  },
  "author": "Near Inc (team@near.org)",
  "license": "(MIT AND Apache-2.0)",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "dependencies": {
    "base64url": "^3.0.1",
    "bn.js": "^5.2.0",
    "borsh": "^0.5.0",
    "bs58": "^4.0.1",
    "callsites": "^4.0.0",
    "fs-extra": "^10.0.0",
    "js-sha256": "^0.9.0",
    "near-api-js": "^v3.0.3",
    "near-sandbox": "^0.0.17",
    "near-units": "^0.1.9",
    "node-port-check": "^2.0.1",
    "promisify-child-process": "^4.1.1",
    "proper-lockfile": "^4.1.2",
    "pure-uuid": "^1.6.2",
    "rimraf": "^3.0.2",
    "temp-dir": "^2.0.0"
  },
  "scripts": {
    "build": "tsc",
    "prepublishOnly": "yarn build",
    "postinstall": "node scripts/install.js",
    "test:testnet": "NEAR_WORKSPACES_NETWORK=testnet ava --verbose",
    "test:testnet:ci": "NEAR_WORKSPACES_DEBUG=true NEAR_WORKSPACES_NETWORK=testnet ava --verbose",
    "test:sandbox": "yarn build && ava --verbose",
    "test:sandbox:ci": "yarn build && NEAR_WORKSPACES_DEBUG=true ava --verbose",
    "test": "ava --verbose && yarn test:testnet",
    "clean:accounts": "ts-node ./scripts/delete-accounts.ts",
    "test:jsonrpc:env": " NEAR_CLI_MAINNET_RPC_SERVER_URL=https://near-mainnet.api.pagoda.co/rpc/v1 ava __tests__/jsonrpc.ava.js"
  },
  "files": [
    "dist/",
    "tsconfig.json",
    "core_contracts",
    "scripts/*.js"
  ],
  "engines": {
    "node": ">= 14.0.0",
    "npm": ">= 6.0.0"
  },
  "devDependencies": {
    "@types/bs58": "^4.0.1",
    "@types/proper-lockfile": "^4.1.2"
  },
  "gitHead": "20b58f0acd60d76517479f3b295f4c7ab938061f"
}

'''
'''--- packages/js/scripts/delete-accounts.ts ---
import * as process from 'process';
import * as fs from 'fs/promises';
import {join, parse} from 'path';

import {KeyPair, NearAccount, Worker, TransactionResult} from '..';

async function deleteAccount(accountId: string, root: NearAccount, key?: KeyPair): Promise<TransactionResult | null> {
  const account = root.getAccount(accountId);
  try {
    if (!await account.exists()) {
      console.log(`${accountId} ------- Doesn't Exists Deleting`);
      // @ts-expect-error private method
      await account.manager.deleteKey(accountId);
      console.log(`${accountId} deleted!`);
      return null;
    }

    const txResult = await account.delete('meta', key);
    if (txResult.failed && key) {
      return await deleteAccount(accountId, root);
    }

    console.log(`${accountId} deleted!`);

    return txResult;
  } catch {
    if (key) {
      return deleteAccount(accountId, root);
    }
  }

  return null;
}

async function pMap<I, O=I>(array: I[], fn: (i: I) => Promise<O>): Promise<O[]> {
  return Promise.all(array.map(fn));
}

async function main() {
  const worker = await Worker.init({network: 'testnet'});
  const root = worker.rootAccount;

  const pattern = new RegExp(process.argv.length > 2 ? process.argv[2] : '');

  const accounts = (await fs.readdir(join(process.cwd(), '.near-credentials', 'workspaces', 'testnet')))
    .map(s => parse(s).name);
  const originalMap: Map<string, string[]> = new Map();
  originalMap.set(root.accountId, []);
  const accountMap: Map<string, string[]> = accounts.reduce((acc, accountId) => {
    if (!pattern.test(accountId)) {
      return acc;
    }

    const parts = accountId.split('.');
    const rootId = parts.pop()!;
    if (!acc.has(rootId)) {
      acc.set(rootId, []);
    }

    if (parts.length > 0) {
      acc.get(rootId)!.push(accountId);
    }

    return acc;
  }, originalMap);

  await Promise.all([...accountMap.entries()].map(async ([rootAccountId, subaccounts]) => {
    const rootAccount = root.getAccount(rootAccountId);
    const key = await rootAccount.getKey() ?? undefined;
    const txs = await pMap(subaccounts, async account => deleteAccount(account, rootAccount, key));
    const failures = txs.filter(tx => tx?.failed).map(tx => tx?.summary());
    if (failures.length > 0) {
      console.log(failures);
    }

    await deleteAccount(rootAccountId, rootAccount);
  }));
}

main();
'''
'''--- packages/js/scripts/install.js ---
module.exports = require("near-sandbox/install");
'''
'''--- packages/js/src/account/account-manager.ts ---
import * as path from 'path';
import * as process from 'process';
import * as nearAPI from 'near-api-js';
import {NEAR} from 'near-units';
import {asId, isTopLevelAccount, randomAccountId} from '../utils';
import {Config, KeyPair, BN, KeyPairEd25519, FinalExecutionOutcome, KeyStore, AccountBalance, NamedAccount, PublicKey, AccountView} from '../types';
import {debug, txDebug} from '../internal-utils';
import {Transaction} from '../transaction';
import {JsonRpcProvider} from '../jsonrpc';
import {TransactionResult} from '../transaction-result';
import {Account} from './account';
import {NearAccount} from './near-account';
import {getKeyFromFile} from './utils';
import {NearAccountManager} from './near-account-manager';

export abstract class AccountManager implements NearAccountManager {
  accountsCreated: Set<string> = new Set();
  private _root?: NearAccount;
  constructor(
    protected config: Config,
  ) {}

  static create(
    config: Config,
  ): AccountManager {
    const {network} = config;
    switch (network) {
      case 'sandbox':
        return new SandboxManager(config);
      case 'testnet':
        return new TestnetManager(config);
      case 'custom':
        return new CustomnetManager(config);
      default: throw new Error(`Bad network id: "${network as string}"; expected "testnet", "custom" or "sandbox"`);
    }
  }

  async accountView(accountId: string): Promise<AccountView> {
    return this.provider.viewAccount(accountId);
  }

  getAccount(accountId: string): NearAccount {
    return new Account(accountId, this);
  }

  getParentAccount(accountId: string): NearAccount {
    const split = accountId.split('.');
    if (split.length === 1) {
      return this.getAccount(accountId);
    }

    return this.getAccount(split.slice(1).join('.'));
  }

  async deleteKey(
    accountId: string,
  ): Promise<void> {
    try {
      await this.keyStore.removeKey(this.networkId, accountId);
      debug(`deleted Key for ${accountId}`);
    } catch {
      debug(`Failed to delete key for ${accountId}`);
    }
  }

  async init(): Promise<AccountManager> {
    return this;
  }

  get root(): NearAccount {
    if (!this._root) {
      this._root = new Account(this.rootAccountId, this);
    }

    return this._root;
  }

  get initialBalance(): string {
    return this.config.initialBalance ?? this.DEFAULT_INITIAL_BALANCE;
  }

  get doubleInitialBalance(): BN {
    return new BN(this.initialBalance).mul(new BN('2'));
  }

  get provider(): JsonRpcProvider {
    return JsonRpcProvider.from(this.config);
  }

  batch(sender: NearAccount | string, receiver: NearAccount | string): Transaction {
    return new ManagedTransaction(this, sender, receiver);
  }

  async getKey(accountId: string): Promise<KeyPair | null> {
    return this.keyStore.getKey(this.networkId, accountId);
  }

  async getPublicKey(accountId: string): Promise<PublicKey | null> {
    return (await this.getKey(accountId))?.getPublicKey() ?? null;
  }

  /** Sets the provided key to store, otherwise creates a new one */
  async setKey(accountId: string, keyPair?: KeyPair): Promise<KeyPair> {
    const key = keyPair ?? KeyPairEd25519.fromRandom();
    await this.keyStore.setKey(this.networkId, accountId, key);
    debug(`Setting keys for ${accountId}`);
    return (await this.getKey(accountId))!;
  }

  async removeKey(accountId: string): Promise<void> {
    await this.keyStore.removeKey(this.networkId, accountId);
  }

  async deleteAccount(accountId: string, beneficiaryId: string, keyPair?: KeyPair): Promise<TransactionResult> {
    try {
      return await this.getAccount(accountId).delete(beneficiaryId, keyPair);
    } catch (error: unknown) {
      if (keyPair) {
        debug(`Failed to delete ${accountId} with different keyPair`);
        return this.deleteAccount(accountId, beneficiaryId);
      }

      throw error;
    }
  }

  async getRootKey(): Promise<KeyPair> {
    const keyPair = await this.getKey(this.rootAccountId);
    if (!keyPair) {
      return this.setKey(this.rootAccountId);
    }

    return keyPair;
  }

  async balance(account: string | NearAccount): Promise<AccountBalance> {
    return this.provider.accountBalance(asId(account));
  }

  async availableBalance(account: string | NearAccount): Promise<NEAR> {
    return (await this.balance(account)).available;
  }

  async exists(accountId: string | NearAccount): Promise<boolean> {
    return this.provider.accountExists(asId(accountId));
  }

  async canCoverBalance(account: string | NearAccount, amount: BN): Promise<boolean> {
    return amount.lt(await this.availableBalance(account));
  }

  async executeTransaction(tx: Transaction, keyPair?: KeyPair): Promise<TransactionResult> {
    const account: nearAPI.Account = new nearAPI.Account(this.connection, tx.senderId);
    let oldKey: KeyPair | null = null;
    if (keyPair) {
      oldKey = await this.getKey(account.accountId);
      await this.setKey(account.accountId, keyPair);
    }

    try {
      const start = Date.now();
      const outcome: FinalExecutionOutcome = await account.signAndSendTransaction({receiverId: tx.receiverId, actions: tx.actions, returnError: true});
      const end = Date.now();
      if (oldKey) {
        await this.setKey(account.accountId, oldKey);
      } else if (keyPair) {
        // Sender account should only have account while execution transaction
        await this.deleteKey(tx.senderId);
      }

      const result = new TransactionResult(outcome, start, end, this.config);
      txDebug(result.summary());
      return result;
    } catch (error: unknown) {
      // Add back oldKey if temporary one was used
      if (oldKey) {
        await this.setKey(account.accountId, oldKey);
      }

      if (error instanceof Error) {
        const key = await this.getPublicKey(tx.receiverId);
        debug(`TX FAILED: receiver ${tx.receiverId} with key ${key?.toString() ?? 'MISSING'} ${JSON.stringify(tx.actions).slice(0, 1000)}`);
        debug(error);
      }

      throw error;
    }
  }

  addAccountCreated(account: string, _sender: string): void {
    this.accountsCreated.add(account);
  }

  async cleanup(): Promise<void> {} // eslint-disable-line @typescript-eslint/no-empty-function

  get rootAccountId(): string {
    return this.config.rootAccountId!;
  }

  protected set rootAccountId(value: string) {
    this.config.rootAccountId = value;
  }

  abstract get DEFAULT_INITIAL_BALANCE(): string;
  abstract createFrom(config: Config): Promise<NearAccountManager>;
  abstract get defaultKeyStore(): KeyStore;

  protected get keyStore(): KeyStore {
    return this.config.keyStore ?? this.defaultKeyStore;
  }

  protected get signer(): nearAPI.InMemorySigner {
    return new nearAPI.InMemorySigner(this.keyStore);
  }

  protected get networkId(): string {
    return this.config.network;
  }

  protected get connection(): nearAPI.Connection {
    return new nearAPI.Connection(this.networkId, this.provider, this.signer, `jsvm.${this.networkId}`);
  }
}

export class CustomnetManager extends AccountManager {
  get DEFAULT_INITIAL_BALANCE(): string {
    return NEAR.parse('10 N').toJSON();
  }

  get defaultKeyStore(): KeyStore {
    return new nearAPI.keyStores.InMemoryKeyStore();
  }

  get connection(): nearAPI.Connection {
    return new nearAPI.Connection(this.networkId, this.provider, this.signer, `jsvm.${this.networkId}`);
  }

  get networkId(): string {
    return this.config.network;
  }

  async init(): Promise<AccountManager> {
    return this;
  }

  async createFrom(config: Config): Promise<NearAccountManager> {
    return new CustomnetManager(config);
  }
}

export class TestnetManager extends AccountManager {
  static readonly KEYSTORE_PATH: string = path.join(process.cwd(), '.near-credentials', 'workspaces');
  private static numTestAccounts = 0;

  private _testnetRoot?: NearAccount;

  static get defaultKeyStore(): KeyStore {
    const keyStore = new nearAPI.keyStores.UnencryptedFileSystemKeyStore(
      this.KEYSTORE_PATH,
    );
    return keyStore;
  }

  get masterAccountId(): string {
    const passedAccountId = this.config.testnetMasterAccountId ?? process.env.TESTNET_MASTER_ACCOUNT_ID;
    if (!passedAccountId) {
      throw new Error(
        'Master account is not provided. You can set it in config while calling Worker.init(config); or with TESTNET_MASTER_ACCOUNT_ID env variable',
      );
    }

    return passedAccountId;
  }

  get fullRootAccountId(): string {
    return this.rootAccountId + '.' + this.masterAccountId;
  }

  get root(): NearAccount {
    if (!this._testnetRoot) {
      this._testnetRoot = new Account(this.fullRootAccountId, this);
    }

    return this._testnetRoot;
  }

  get DEFAULT_INITIAL_BALANCE(): string {
    return NEAR.parse('10 N').toJSON();
  }

  get defaultKeyStore(): KeyStore {
    return TestnetManager.defaultKeyStore;
  }

  get urlAccountCreator(): nearAPI.accountCreator.UrlAccountCreator {
    return new nearAPI.accountCreator.UrlAccountCreator(
      {} as any, // ignored
      this.config.helperUrl!,
    );
  }

  async init(): Promise<AccountManager> {
    if (!this.rootAccountId) {
      this.rootAccountId = randomAccountId('r-', 5, 5);
    }

    if (!(await this.exists(this.fullRootAccountId))) {
      await this.getAccount(this.masterAccountId).createSubAccount(this.rootAccountId);
    }

    return this;
  }

  async createTopLevelAccountWithHelper(accountId: string, keyPair: KeyPair): Promise<void> {
    await this.urlAccountCreator.createAccount(accountId, keyPair.getPublicKey());
  }

  async createAccount(accountId: string, keyPair?: KeyPair): Promise<NearAccount> {
    if (accountId.includes('.')) {
      await this.getParentAccount(accountId).createAccount(accountId, {keyPair});
      this.accountsCreated.delete(accountId);
    } else {
      await this.createTopLevelAccountWithHelper(accountId, keyPair ?? await this.getRootKey());
      debug(`Created account ${accountId} with account creator`);
    }

    return this.getAccount(accountId);
  }

  async addFundsFromNetwork(accountId: string = this.fullRootAccountId): Promise<void> {
    const temporaryId = randomAccountId();
    try {
      const key = await this.getRootKey();
      const account = await this.createAccount(temporaryId, key);
      await account.delete(accountId, key);
    } catch (error: unknown) {
      if (error instanceof Error) {
        await this.removeKey(temporaryId);
      }

      throw error;
    }
  }

  async addFunds(accountId: string, amount: BN): Promise<void> {
    const parent = this.getParentAccount(accountId);
    if (parent.accountId === accountId) {
      return this.addFundsFromNetwork(accountId);
    }

    if (!(await this.canCoverBalance(parent, amount))) {
      await this.addFunds(parent.accountId, amount);
    }

    await parent.transfer(accountId, amount);
  }

  async deleteAccounts(accounts: string[], beneficiaryId: string): Promise<void[]> {
    const keyPair = await this.getKey(this.rootAccountId) ?? undefined;
    return Promise.all(
      accounts.map(async accountId => {
        await this.deleteAccount(accountId, beneficiaryId, keyPair);
        await this.deleteKey(accountId);
      }),
    );
  }

  async createFrom(config: Config): Promise<AccountManager> {
    const currentRunAccount = TestnetManager.numTestAccounts;
    const prefix = currentRunAccount === 0 ? '' : currentRunAccount;
    TestnetManager.numTestAccounts += 1;
    const newConfig = {...config, rootAccount: `t${prefix}.${config.rootAccountId!}`};
    return (new TestnetManager(newConfig)).init();
  }

  async cleanup(): Promise<void> {
    return this.deleteAccounts([...this.accountsCreated.values()], this.rootAccountId) as unknown as void;
  }

  async needsFunds(accountId: string, amount: BN): Promise<boolean> {
    return !amount.isZero() && this.isRootOrTLAccount(accountId)
    && (!await this.canCoverBalance(accountId, amount));
  }

  isRootOrTLAccount(accountId: string): boolean {
    return this.rootAccountId === accountId || isTopLevelAccount(accountId);
  }
}

export class SandboxManager extends AccountManager {
  async init(): Promise<AccountManager> {
    if (!await this.getKey(this.rootAccountId)) {
      await this.setKey(this.rootAccountId, await getKeyFromFile(this.keyFilePath));
    }

    return this;
  }

  async createFrom(config: Config): Promise<NearAccountManager> {
    return new SandboxManager(config);
  }

  get DEFAULT_INITIAL_BALANCE(): string {
    return NEAR.parse('200 N').toJSON();
  }

  get defaultKeyStore(): KeyStore {
    const keyStore = new nearAPI.keyStores.UnencryptedFileSystemKeyStore(
      this.config.homeDir,
    );
    return keyStore;
  }

  get keyFilePath(): string {
    return path.join(this.config.homeDir, 'validator_key.json');
  }
}

export class ManagedTransaction extends Transaction {
  private delete = false;
  constructor(private readonly manager: AccountManager, sender: NamedAccount | string, receiver: NamedAccount | string) {
    super(sender, receiver);
  }

  createAccount(): this {
    this.manager.addAccountCreated(this.receiverId, this.senderId);
    return super.createAccount();
  }

  deleteAccount(beneficiaryId: string): this {
    this.delete = true;
    return super.deleteAccount(beneficiaryId);
  }

  /**
   *
   * @param keyPair Temporary key to sign transaction
   * @returns
   */
  async transact(keyPair?: KeyPair): Promise<TransactionResult> {
    const executionResult = await this.manager.executeTransaction(this, keyPair);
    if (executionResult.succeeded && this.delete) {
      await this.manager.deleteKey(this.receiverId);
    }

    return executionResult;
  }
}

'''
'''--- packages/js/src/account/account.ts ---
import {URL} from 'url';
import {Buffer} from 'buffer';
import {env} from 'process';
import BN from 'bn.js';
import {NEAR} from 'near-units';
import * as borsh from 'borsh';
import {
  DEFAULT_FUNCTION_CALL_GAS,
  KeyPair,
  PublicKey,
  CodeResult,
  AccountBalance,
  Args,
  AccountView,
  Empty,
  StateItem,
  AccessKeyView,
  AccessKeyList,
} from '../types';
import {Transaction} from '../transaction';
import {ContractState} from '../contract-state';
import {JsonRpcProvider} from '../jsonrpc';
import {EMPTY_CONTRACT_HASH, NO_DEPOSIT, randomAccountId} from '../utils';
import {TransactionResult, TransactionError} from '../transaction-result';
import {AccessKeyData, AccountBuilder, AccountData, RecordBuilder, Records} from '../record';
import {NearAccount} from './near-account';
import {NearAccountManager} from './near-account-manager';

export class Account implements NearAccount {
  constructor(
    private readonly _accountId: string,
    private readonly manager: NearAccountManager,
  ) {}

  async accountView(): Promise<AccountView> {
    return this.manager.accountView(this._accountId);
  }

  async exists(): Promise<boolean> {
    return this.provider.accountExists(this.accountId);
  }

  protected get provider(): JsonRpcProvider {
    return this.manager.provider;
  }

  get accountId(): string {
    return this._accountId;
  }

  async availableBalance(): Promise<NEAR> {
    return this.manager.availableBalance(this.accountId);
  }

  async balance(): Promise<AccountBalance> {
    return this.manager.balance(this.accountId);
  }

  batch(receiver: NearAccount | string): Transaction {
    return this.manager.batch(this, receiver);
  }

  async getKey(): Promise<KeyPair | null> {
    return this.manager.getKey(this.accountId);
  }

  async setKey(keyPair?: KeyPair): Promise<PublicKey> {
    return (await this.manager.setKey(this.accountId, keyPair)).getPublicKey();
  }

  async createAccount(
    accountId: string,
    {
      keyPair,
      initialBalance,
    }: {keyPair?: KeyPair; initialBalance?: string; isSubAccount?: boolean} = {},
  ): Promise<NearAccount> {
    const tx = await this.internalCreateAccount(accountId, {
      keyPair,
      initialBalance,
      isSubAccount: false,
    });

    const result = await tx.transact();

    if (result.Failure) {
      throw new Error(`Failure during trasaction excecution, details: ${JSON.stringify(result)}`);
    }

    return this.getAccount(accountId);
  }

  async createSubAccount(
    accountId: string,
    {
      keyPair,
      initialBalance,
    }: {keyPair?: KeyPair; initialBalance?: string; isSubAccount?: boolean} = {},
  ): Promise<NearAccount> {
    const tx = await this.internalCreateAccount(accountId, {
      keyPair,
      initialBalance,
      isSubAccount: true,
    });

    const result = await tx.transact();

    if (result.Failure) {
      throw new Error(`Failure during trasaction excecution, details: ${JSON.stringify(result)}`);
    }

    return this.getSubAccount(accountId);
  }

  async importContract({
    testnetContract,
    mainnetContract,
    withData = false,
    blockId,
    keyPair,
    initialBalance,
  }: {
    testnetContract?: string;
    mainnetContract?: string;
    withData?: boolean;
    keyPair?: KeyPair;
    initialBalance?: string;
    blockId?: number | string;
  }): Promise<NearAccount> {
    if ((testnetContract && mainnetContract) || !(testnetContract || mainnetContract)) {
      throw new TypeError('Provide `mainnetContract` or `testnetContract` but not both.');
    }

    const network = mainnetContract ? 'mainnet' : 'testnet';
    const refContract = (mainnetContract ?? testnetContract)!;

    const rpc = JsonRpcProvider.fromNetwork(network);
    const blockQuery = blockId ? {block_id: blockId} : undefined;
    const account = this.getAccount(refContract) as Account;

    // Get account view of account on reference network
    const accountView = await rpc.viewAccount(refContract, blockQuery);
    accountView.amount = initialBalance ?? accountView.amount;
    const pubKey = await account.setKey(keyPair);
    const records = account.recordBuilder()
      .account(accountView)
      .accessKey(pubKey);

    if (accountView.code_hash !== EMPTY_CONTRACT_HASH) {
      const binary = await rpc.viewCodeRaw(refContract, blockQuery);
      records.contract(binary);
    }

    await account.patchStateRecords(records);

    if (!await this.provider.accountExists(refContract)) {
      await account.patchStateRecords(records);
      if (!await this.provider.accountExists(refContract)) {
        throw new Error(`Account ${refContract} does not exist after trying to patch into sandbox.`);
      }
    }

    if (withData) {
      const rawData = await rpc.viewStateRaw(account.accountId, '', blockQuery);
      const data = rawData.map(({key, value}) => ({
        Data: {
          account_id: account.accountId, data_key: key, value,
        },
      }));
      await account.patchStateRecords({records: data});
    }

    return account;
  }

  getSubAccount(accountId: string): NearAccount {
    const id = this.makeSubAccount(accountId);
    return this.getAccount(id);
  }

  getAccount(accountId: string): NearAccount {
    return new Account(accountId, this.manager);
  }

  async deploy(code: string | URL | Uint8Array | Buffer): Promise<TransactionResult> {
    const tx = await this.batch(this).deployContractFile(code);
    return tx.transact();
  }

  async devCreateAccount({
    initialBalance,
    keyPair,
  }: {
    initialBalance?: BN | string;
    keyPair?: KeyPair;
  } = {}): Promise<NearAccount> {
    const accountId = `${randomAccountId('dev-', 5, 5)}.${this.accountId}`;
    const tx = await this.internalCreateAccount(accountId, {
      keyPair,
      initialBalance,
    });

    const result = await tx.transact();

    if (result.Failure) {
      throw new Error(`Failure during account creation, details: ${JSON.stringify(result)}`);
    }

    return this.getAccount(accountId);
  }

  async devDeploy(
    wasm: string | URL | Uint8Array | Buffer,
    {
      attachedDeposit = NO_DEPOSIT,
      args = {},
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      gas = DEFAULT_FUNCTION_CALL_GAS,
      initialBalance,
      keyPair,
      method,
      isSubAccount,
    }: {
      args?: Record<string, unknown> | Uint8Array;
      attachedDeposit?: string | BN;
      gas?: string | BN;
      initialBalance?: BN | string;
      keyPair?: KeyPair;
      method?: string;
      isSubAccount?: boolean;
    } = {},
  ): Promise<NearAccount> {
    const accountId = `${randomAccountId('dev-', 5, 5)}.${this.accountId}`;
    let tx = await this.internalCreateAccount(accountId, {
      keyPair,
      initialBalance,
      isSubAccount,
    });
    tx = await tx.deployContractFile(wasm);
    if (method) {
      tx.functionCall(method, args, {gas, attachedDeposit});
    }

    const result = await tx.transact();

    if (result.Failure) {
      throw new Error(`Failure during trasaction excecution, details: ${JSON.stringify(result)}`);
    }

    return this.getAccount(accountId);
  }

  async callRaw(
    contractId: NearAccount | string,
    methodName: string,
    args: Record<string, unknown> | Uint8Array,
    {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      gas = DEFAULT_FUNCTION_CALL_GAS,
      attachedDeposit = NO_DEPOSIT,
      signWithKey = undefined,
    }: {
      gas?: string | BN;
      attachedDeposit?: string | BN;
      signWithKey?: KeyPair;
    } = {},
  ): Promise<TransactionResult> {
    return this.batch(contractId)
      .functionCall(methodName, args, {gas, attachedDeposit})
      .transact(signWithKey);
  }

  async call<T>(
    contractId: NearAccount | string,
    methodName: string,
    args: Record<string, unknown> | Uint8Array,
    {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      gas = DEFAULT_FUNCTION_CALL_GAS,
      attachedDeposit = NO_DEPOSIT,
      signWithKey = undefined,
    }: {
      gas?: string | BN;
      attachedDeposit?: string | BN;
      signWithKey?: KeyPair;
    } = {},
  ): Promise<T> {
    const txResult = await this.callRaw(contractId, methodName, args, {
      gas,
      attachedDeposit,
      signWithKey,
    });

    if (!env.NEAR_WORKSPACES_NO_LOGS && txResult.logs.length > 0) {
      const accId = typeof contractId === 'string' ? contractId : contractId.accountId;
      console.log(`Contract logs from ${accId}.${methodName}(${JSON.stringify(args)}) call:`, txResult.logs);
    }

    if (txResult.failed) {
      throw new TransactionError(txResult);
    }

    return txResult.parseResult<T>();
  }

  async viewRaw(method: string, args: Args = {}): Promise<CodeResult> {
    return this.provider.viewCall(this.accountId, method, args);
  }

  async view<T>(method: string, args: Args = {}): Promise<T> {
    const result = await this.viewRaw(method, args);

    if (!env.NEAR_WORKSPACES_NO_LOGS && result.logs.length > 0) {
      console.log(`Contract logs from ${this.accountId}.${method}(${JSON.stringify(args)}) view call:`, result.logs);
    }

    if (result.result) {
      const value = Buffer.from(result.result).toString();
      try {
        return JSON.parse(value) as T;
      } catch {
        return value as unknown as T;
      }
    }

    return null as unknown as T;
  }

  async viewCode(): Promise<Buffer> {
    return this.provider.viewCode(this.accountId);
  }

  async viewCodeRaw(): Promise<string> {
    return this.provider.viewCodeRaw(this.accountId);
  }

  async viewState(prefix: string | Uint8Array = ''): Promise<ContractState> {
    return new ContractState(
      await this.provider.viewState(this.accountId, prefix),
    );
  }

  async viewStateRaw(prefix: string | Uint8Array = ''): Promise<StateItem[]> {
    return this.provider.viewStateRaw(this.accountId, prefix);
  }

  async viewAccessKey(accountId: string, publicKey: PublicKey | string): Promise<AccessKeyView> {
    return this.provider.viewAccessKey(accountId, publicKey);
  }

  async viewAccessKeys(accountId: string): Promise<AccessKeyList> {
    return this.provider.viewAccessKeys(accountId);
  }

  async patchState(key: string, value_: any, borshSchema?: any): Promise<Empty> {
    return this.updateData(Buffer.from(key), Buffer.from(borshSchema ? borsh.serialize(borshSchema, value_) : value_));
  }

  async patchStateRecords(records: Records): Promise<Empty> {
    // FIX THIS: Shouldn't need two calls to update before next RPC view call.
    await this.provider.patchStateRecords(records);
    return this.provider.patchStateRecords(records);
  }

  async delete(beneficiaryId: string, keyPair?: KeyPair): Promise<TransactionResult> {
    const result = await this.batch(this)
      .deleteAccount(beneficiaryId)
      .transact(keyPair);
    if (result.succeeded && await this.getKey() !== null) {
      await this.manager.deleteKey(this.accountId);
    }

    return result;
  }

  makeSubAccount(accountId: string): string {
    return `${accountId}.${this.accountId}`;
  }

  subAccountOf(accountId: string): boolean {
    return accountId.endsWith(`.${this.accountId}`);
  }

  toJSON(): string {
    return this.accountId;
  }

  async updateAccount(accountData?: Partial<AccountData>): Promise<Empty> {
    return this.patchStateRecords(this.recordBuilder().account(accountData));
  }

  async updateAccessKey(key: string | PublicKey | KeyPair, access_key_data?: AccessKeyData): Promise<Empty> {
    return this.patchStateRecords(this.recordBuilder().accessKey(key, access_key_data));
  }

  async updateContract(binary: Buffer | string): Promise<Empty> {
    const accountView = await this.accountView();
    const rb = this.recordBuilder();
    rb.account(accountView);
    return this.patchStateRecords(rb.contract(binary));
  }

  async updateData(key: string | Buffer, value: string | Buffer): Promise<Empty> {
    const key_string = key instanceof Buffer ? key.toString('base64') : key;
    const value_string = value instanceof Buffer ? value.toString('base64') : value;
    return this.patchStateRecords(this.recordBuilder().data(key_string, value_string));
  }

  async transfer(accountId: string | NearAccount, amount: string | BN): Promise<TransactionResult> {
    return this.batch(accountId).transfer(amount).transact();
  }

  protected async internalCreateAccount(
    accountId: string,
    {
      keyPair,
      initialBalance,
      isSubAccount,
    }: {keyPair?: KeyPair; initialBalance?: string | BN; isSubAccount?: boolean} = {},
  ): Promise<Transaction> {
    const newAccountId = isSubAccount ? this.makeSubAccount(accountId) : accountId;
    const pubKey = (await this.getOrCreateKey(newAccountId, keyPair)).getPublicKey();
    const amount = (initialBalance ?? this.manager.initialBalance).toString();
    return this.batch(newAccountId)
      .createAccount()
      .transfer(amount)
      .addKey(pubKey);
  }

  private async getOrCreateKey(accountId: string, keyPair?: KeyPair): Promise<KeyPair> {
    return (await this.manager.getKey(accountId)) ?? this.manager.setKey(accountId, keyPair);
  }

  private recordBuilder(): AccountBuilder {
    return RecordBuilder.fromAccount(this);
  }
}

'''
'''--- packages/js/src/account/index.ts ---
export * from './near-account';
export * from './near-account-manager';
export * from './account-manager';
export * from './account';

'''
'''--- packages/js/src/account/near-account-manager.ts ---
import {KeyPair} from 'near-api-js';
import {NEAR} from 'near-units';
import {TransactionResult} from '../transaction-result';
import {JsonRpcProvider} from '../jsonrpc';
import {Transaction} from '../transaction';
import {Config, AccountBalance, AccountView} from '../types';
import {NearAccount} from './near-account';

export interface NearAccountManager {
  readonly provider: JsonRpcProvider;
  readonly initialBalance: string;
  readonly root: NearAccount;
  accountView(accountId: string): Promise<AccountView>;
  availableBalance(account: string | NearAccount): Promise<NEAR>;
  balance(accountId: string | NearAccount): Promise<AccountBalance>;
  executeTransaction(tx: Transaction, keyPair?: KeyPair): Promise<TransactionResult>;
  addAccountCreated(account: string, sender: string): void;
  getAccount(accountId: string): NearAccount;
  getKey(accountId: string): Promise<KeyPair | null>;
  deleteAccount(accountId: string, beneficiaryId: string, keyPair?: KeyPair): Promise<TransactionResult>;
  deleteKey(accountId: string): Promise<void>;
  cleanup(): Promise<void>;
  /** Creates a KeyPair if one is not provided */
  setKey(accountId: string, keyPair?: KeyPair): Promise<KeyPair>;
  batch(sender: NearAccount | string, receiver: NearAccount | string): Transaction;
  createFrom(config: Config): Promise<NearAccountManager>;
  init(): Promise<NearAccountManager>;
}

'''
'''--- packages/js/src/account/near-account.ts ---
import {URL} from 'url';
import {Buffer} from 'buffer';
import BN from 'bn.js';
import {NEAR} from 'near-units';
import {KeyPair} from 'near-api-js';
import {AccountBalance, PublicKey, CodeResult, AccountView, Empty, StateItem, AccessKeyList, AccessKeyView} from '../types';
import {ContractState} from '../contract-state';
import {Transaction} from '../transaction';
import {TransactionResult} from '../transaction-result';
import {AccessKeyData, AccountData, Records} from '../record';

export interface NearAccount {
  /** Full account id for given account. */
  readonly accountId: string;

  /**
   * Returns infomation about the account.
   * @see {@link https://docs.near.org/docs/develop/front-end/rpc#view-account}
   */
  accountView(): Promise<AccountView>;

  /* How many liquid yNear tokens that belong to the user */
  availableBalance(): Promise<NEAR>;

  /** Current balance of account on network. */
  balance(): Promise<AccountBalance>;
  /**
   * Create a Transaction that can be used to build actions like transfer, createAccount, etc.
   * Then once built can be signed and transmitted.
   * E.g.
   * ```ts
   * const result = await account.batch(bob).transfer(NEAR.parse("1N")).transact();
   * ```
   * @param receiver account that the transaction is addressed to.
   */
  batch(receiver: NearAccount | string): Transaction;
  /** Test whether an account exists on the network */
  exists(): Promise<boolean>;
  /**
   * Gets users key from key store.
   */
  getKey(): Promise<KeyPair | null>;
  /**
   * Adds a key pair to key store and creates a random pair if not provided
   * @param keyPair to add keystore
   */
  setKey(keyPair?: KeyPair): Promise<PublicKey>;

  /**
   * Create a subaccount from this account
   * @param accountId full accountId with current account name as suffix.
   * @param options `keyPair` is key to be added to keystore, otherwise random one will be added.
   *                `initialBalance` how much yoctoNear to transfer to new account.
   */
  createAccount(
    accountId: string,
    options?: {keyPair?: KeyPair; initialBalance?: string},
  ): Promise<NearAccount>;

  /**
   * Create a subaccount from this account
   * @param accountId prefix of accountId with current account name as suffix.
   * @param options `keyPair` is key to be added to keystore, otherwise random one will be added.
   *                `initialBalance` how much yoctoNear to transfer to new account.
   */
  createSubAccount(
    accountId: string,
    options?: {keyPair?: KeyPair; initialBalance?: string},
  ): Promise<NearAccount>;

  /**
   * Create an account, copying Wasm bytes and contract name from a given `testnetContract` or `mainnetContract`.
   *
   * This makes use of Sandbox's patch state feature, and so only works in Sandbox mode.
   *
   * You can include `withData: true` to copy account data as well, but this is
   * currently limited by the default RPC limit of 50kB. You could set up your
   * own RPC server to get around this limit (using your own RPC endpoint will
   * be easier soon).
   *
   * @param options
   */
  importContract(options: {
    testnetContract?: string;
    mainnetContract?: string;
    withData?: boolean;
    keyPair?: KeyPair;
    initialBalance?: string;
    blockId?: number | string;
    isSubAccount?: boolean;
  }): Promise<NearAccount>;

  /** Adds suffix to accountIdPrefix and get that account */
  getSubAccount(accountIdPrefix: string): NearAccount;

  /** Get the account with given full accountId */
  getAccount(accountId: string): NearAccount;

  /** Deploy contract to the current account */
  deploy(code: string | URL | Uint8Array | Buffer): Promise<TransactionResult>;

  /**
   * Creates an account with random accoundId
   * @returns Promise<NearAccount>
   */
  devCreateAccount(): Promise<NearAccount>;

  /**
   * Creates an account for a contract and then deploys a Wasm binary to it.
   * If method arguments are provided a function call to `method` will be added to the transaction so that
   * the contract can be initialized in the same step.
   *
   * @param wasm path or data of contract binary
   * @param options If any method is passed it will be added to the transaction so that contract will be initialized
   *                `gas` and `initialBalance` as strings can be either numbers, e.g. `1_000_000` or have units, `30 Tgas`
   */
  devDeploy(
    wasm: string | URL | Uint8Array | Buffer,
    options?: {
      args?: Record<string, unknown> | Uint8Array;
      attachedDeposit?: string | BN;
      gas?: string | BN;
      initialBalance?: BN | string;
      keyPair?: KeyPair;
      method?: string;
      isSubAccount?: boolean;
    }
  ): Promise<NearAccount>;

  /**
   * Call a NEAR contract and return full results with raw receipts, etc. Example:
   *
   *     await callRaw('lol.testnet', 'set_status', { message: 'hello' }, {gas: new BN(30 * 10**12), attachedDeposit: new BN(10**24)})
   *
   *     //`gas` and `initialBalance` as strings can be either numbers, e.g. `1_000_000` or have units, `30 Tgas`
   *
   *     await callRaw('lol.testnet', 'set_status', { message: 'hello' }, {gas:"10 Tgas", attachedDeposit: "1 N"})

   * @returns Promise<TransactionResult>
   */
  callRaw(
    contractId: NearAccount | string,
    methodName: string,
    args: Record<string, unknown> | Uint8Array,
    options?: {
      gas?: string | BN;
      attachedDeposit?: string | BN;
      signWithKey?: KeyPair;
    }
  ): Promise<TransactionResult>;

  /**
   * Convenient wrapper around lower-level `callRaw` that returns only successful result of call, or throws error encountered during call.  Example:
   *
   *     await call('lol.testnet', 'set_status', { message: 'hello' }, new BN(30 * 10**12), '0')
   *
   * @returns any parsed return value, or throws with an error if call failed
   */
  call<T>(
    contractId: NearAccount | string,
    methodName: string,
    args: Record<string, unknown> | Uint8Array,
    options?: {
      gas?: string | BN;
      attachedDeposit?: string | BN;
      signWithKey?: KeyPair;
    }
  ): Promise<T>;

  /**
   * Get full response from RPC about result of view method
   * @param method contract method
   * @param args args to pass to method if required
   */
  viewRaw(method: string, args?: Record<string, unknown> | Uint8Array): Promise<CodeResult>;
  /**
   * Get the parsed result returned by view method
   * @param method contract method
   * @param args args to pass to method if required
   */
  view<T>(method: string, args?: Record<string, unknown> | Uint8Array): Promise<T>;

  /**
   * Download contract code from provider
   */
  viewCode(): Promise<Buffer>;

  /**
   * Download contract code encoded as a Base64 string
   */
  viewCodeRaw(): Promise<string>;

  /**
   * Get the data of a contract as a map of raw key/values
   * @param prefix optional prefix of key in storage. Default is ''.
   */
  viewState(prefix?: string | Uint8Array): Promise<ContractState>;

  /**
   * Get raw contract data as base64 encoded strings.
   * @param prefix optional prefix of key in storage. Default is ''.
   */
  viewStateRaw(prefix?: string | Uint8Array): Promise<StateItem[]>;

  /**
   * Get the access key associated to the account id and public key.
   * @param accountId ID of the account we want to get the access key from.
   * @param publicKey Which particular access key we want to retrieve.
   */
  viewAccessKey(accountId: string, publicKey: PublicKey | string): Promise<AccessKeyView>;

  /**
   * Get all access keys associated to the account id.
   * @param accountId ID of the account we want to get the access keys from.
   */
  viewAccessKeys(accountId: string): Promise<AccessKeyList>;

  /** Update record to sandbox */
  patchStateRecords(records: Records): Promise<Empty>;

  /**
   * Patch state data of given key and value to sandbox
   * @param key key to update in storage
   * @param value_ Data to be serialized to JSON by default
   * @param borshSchema If passed will be used to encode the data
   */
  patchState(key: string, value_: any, borshSchema?: any): Promise<any>;

  /** Delete account and sends funds to beneficiaryId */
  delete(beneficiaryId: string, keyPair?: KeyPair): Promise<TransactionResult>;
  /**
   * Adds the current account's id as the root account `<accountId>.<thisAccountID>`
   * @param accountId prefix of subaccount
   */
  makeSubAccount(accountId: string): string;
  /**
   * Test whether an accountId is a subaccount of the current account.
   * @param accountId Account to test
   */
  subAccountOf(accountId: string): boolean;

  /**
   * Used to encode the account as the the accountId string when used in `JSON.stringify`
   */
  toJSON(): string;

  /**
  * Transfer yoctoNear to another account.
  * If amount is string it can be either numbers, e.g. `"1_000_000_000_000_000_000_000_000"` or have units, `"1 N"`
  */
  transfer(accountId: string | NearAccount, amount: string | BN): Promise<TransactionResult>;

  /**
   * Update the account balance, storage usage, locked_amount.
   *
   * Uses patchStateRecords to update the account without a transaction. Only works with network: 'sandbox'.
   */
  updateAccount(accountData?: Partial<AccountData>): Promise<Empty>;

  /**
   * Add AccessKey to account.
   *
   * Uses patchStateRecords to update the account without a transaction. Only works with network: 'sandbox'.
   */
  updateAccessKey(key: string | PublicKey | KeyPair, access_key_data?: AccessKeyData): Promise<Empty>;

  /**
   * Deploy contract to account.
   *
   * Uses patchStateRecords to update the account without a transaction. Only works with network: 'sandbox'.
   */
  updateContract(binary: Buffer | string): Promise<Empty>;

  /**
   * Update contract data of account.
   *
   * Uses patchStateRecords to update the account without a transaction. Only works with network: 'sandbox'.
   *
   * @param data Base64 encoded string or Buffer to be encoded as Base64
   * @param value Base64 encoded string or Buffer to be encoded as Base64
   */
  updateData(data: string | Buffer, value: string | Buffer): Promise<Empty>;
}

'''
'''--- packages/js/src/account/utils.ts ---
import * as fs from 'fs/promises';
import {Buffer} from 'buffer';
import sha256 from 'js-sha256';
import base64url from 'base64url';
import {CallSite} from 'callsites';
import {KeyPair, KeyPairEd25519} from '../types';

export function findCallerFile(): [string, number] {
  const sites: CallSite[] = callsites();
  const files: CallSite[] = sites.filter(s => s.getFileName());
  // Need better way to find file
  const i = files.length - 1;
  return [files[i].getFileName()!, files[i].getLineNumber()!];
}

export function callsites(): CallSite[] {
  const _prepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = (_, stack) => stack;
  const stack = new Error().stack!.slice(1); // eslint-disable-line unicorn/error-message
  Error.prepareStackTrace = _prepareStackTrace;
  return stack as unknown as CallSite[];
}

export interface KeyFilePrivate {
  private_key: string;
}

export interface KeyFileSecret {
  secret_key: string;
}

export type KeyFile = KeyFilePrivate | KeyFileSecret;

export async function getKeyFromFile(filePath: string, create = true): Promise<KeyPair> {
  try {
    const keyFile = require(filePath) as KeyFile; // eslint-disable-line @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports
    return KeyPair.fromString(
      // @ts-expect-error `x` does not exist on KeyFile
      keyFile.secret_key ?? keyFile.private_key,
    );
  } catch (error: unknown) {
    if (!create) {
      throw error;
    }

    const keyPair = KeyPairEd25519.fromRandom();
    await fs.writeFile(filePath, JSON.stringify({
      secret_key: keyPair.toString(),
    }));
    return keyPair;
  }
}

export function hashPathBase64(s: string): string {
  // Currently base64url is in newest version of node, but need to use polyfill for now
  const result = base64url.encode(Buffer.from(sha256.sha256.arrayBuffer(s)));
  return result;
}

export function sanitize(s: string): string {
  return s.toLowerCase().replace('__', '_0');
}

'''
'''--- packages/js/src/contract-state.ts ---
import {Buffer} from 'buffer';
import * as borsh from 'borsh';

export class ContractState {
  private readonly data: Map<string, Buffer>;
  constructor(dataArray: Array<{key: Buffer; value: Buffer}>) {
    this.data = new Map();
    for (const {key, value} of dataArray) {
      this.data.set(key.toString(), value);
    }
  }

  getRaw(key: string): Buffer {
    return this.data.get(key) ?? Buffer.from('');
  }

  get(key: string, borshSchema?: {type: any; schema: any}): any {
    const value = this.getRaw(key);
    if (borshSchema) {
      return borsh.deserialize(borshSchema.schema, borshSchema.type, value);
    }

    return value.toJSON();
  }
}

'''
'''--- packages/js/src/index.ts ---
import * as process from 'process';

if (!process.env.NEAR_PRINT_LOGS) {
  process.env.NEAR_NO_LOGS = 'true';
}

export * from './worker';
export * from './server';
export * from './utils';
export * from './types';
export * from './account';
export * from './transaction-result';
export * from './jsonrpc';
export * from 'near-units';

'''
'''--- packages/js/src/internal-utils.ts ---
import process from 'process';
import {dirname, join} from 'path';
import {constants, PathLike} from 'fs';
import {access} from 'fs/promises';
import * as fs from 'fs/promises';
import {promisify} from 'util';
import {spawn as _spawn} from 'child_process';
import {URL} from 'url';
import {spawn as _asyncSpawn} from 'promisify-child-process';
import rimraf from 'rimraf';
import {Binary} from 'near-sandbox';
import {getBinary} from 'near-sandbox/dist/getBinary';
import fs_extra from 'fs-extra';
import {ChildProcessPromise} from './types';

export const rm = promisify(rimraf);
export const sandboxBinary: () => Promise<Binary> = async () => (getBinary());

export async function exists(d: PathLike): Promise<boolean> {
  let file: fs.FileHandle | undefined;
  try {
    file = await fs.open(d, 'r');
  } catch {
    return false;
  } finally {
    await file?.close();
  }

  return true;
}

export async function asyncSpawn(bin: string, ...args: string[]): ChildProcessPromise {
  debug(`spawning \`${bin} ${args.join(' ')}\``);
  return _asyncSpawn(bin, args, {encoding: 'utf8'});
}

export {_spawn as spawn};

export function debug(...args: any[]): void {
  if (process.env.NEAR_WORKSPACES_DEBUG) {
    console.error(...args);
  }
}

export function txDebug(tx: string): void {
  if (process.env.NEAR_WORKSPACES_TXDEBUG) {
    console.error(tx);
  }
}

export const copyDir = promisify(fs_extra.copy);

export async function ensureBinary(): Promise<string> {
  const binary = await sandboxBinary();
  if (!await binary.exists()) {
    await binary.install();
  }

  return binary.binPath;
}

export function isPathLike(something: any): something is URL | string {
  return typeof something === 'string' || something instanceof URL;
}

/**
 * Attempts to construct an absolute path to a file given a path relative to a
 * package.json. Searches through `module.paths` (Node's resolution search
 * paths) as described in https://stackoverflow.com/a/18721515/249801, then
 * falls back to using process.cwd() if still not found. Throws an acceptable
 * user-facing error if no file found.
 */
export async function findFile(relativePath: string): Promise<string> {
  for (const modulePath of module.paths) {
    try {
      await access(modulePath, constants.F_OK); // eslint-disable-line no-await-in-loop
      const absolutePath = join(dirname(modulePath), relativePath);
      await access(absolutePath, constants.F_OK); // eslint-disable-line no-await-in-loop
      return absolutePath;
    } catch {}
  }

  const cwd = process.cwd();
  const absolutePath = join(cwd, relativePath);
  try {
    await access(absolutePath, constants.F_OK);
    return absolutePath;
  } catch {}

  throw new Error(`Could not find '${relativePath}' relative to any package.json file or your current working directory (${cwd})`);
}

'''
'''--- packages/js/src/jsonrpc.ts ---
// eslint-disable unicorn/no-object-as-default-parameter
import {Buffer} from 'buffer';
import process from 'process';
import {NEAR} from 'near-units';
import {stringifyJsonOrBytes} from 'near-api-js/lib/transaction';
import {Records} from './record';
import {JSONRpc, ContractCodeView, AccountView, NearProtocolConfig, AccountBalance, CodeResult, ViewStateResult, BlockId, Finality, StateItem, TESTNET_RPC_ADDR, Empty, MAINNET_RPC_ADDR, PublicKey, Network, AccessKeyView, AccessKeyList} from './types';

const OPTIMISTIC: {finality: 'optimistic'} = {finality: 'optimistic'};
/**
 * Extends the main provider class in near-api-js, adding more methods for
 * interacting with an endpoint.
 */
export class JsonRpcProvider extends JSONRpc {
  private static readonly providers: Map<string, JsonRpcProvider> = new Map();

  /**
   * Create a JsonRpcProvider from config or rpcAddr
   * @param config rpc endpoint URL or a configuration that includes one.
   * @returns JsonRpcProvider
   */
  static from(config: string | {rpcAddr: string}): JsonRpcProvider {
    const url = typeof config === 'string' ? config : config.rpcAddr;
    if (!this.providers.has(url)) {
      this.providers.set(url, new JsonRpcProvider({url}));
    }

    return this.providers.get(url)!;
  }

  static fromNetwork(network: Network): JsonRpcProvider {
    switch (network) {
      case 'mainnet': return process.env.NEAR_CLI_MAINNET_RPC_SERVER_URL ? JsonRpcProvider.from(process.env.NEAR_CLI_MAINNET_RPC_SERVER_URL) : MainnetRpc;
      case 'testnet': return process.env.NEAR_CLI_TESTNET_RPC_SERVER_URL ? JsonRpcProvider.from(process.env.NEAR_CLI_TESTNET_RPC_SERVER_URL) : TestnetRpc;
      default: throw new TypeError('Invalid network only mainnet or testnet');
    }
  }

  /**
   * Download the binary of a given contract.
   * @param accountId contract account
   * @returns Buffer of Wasm binary
   */
  async viewCode(accountId: string, blockQuery?: {block_id: BlockId} | {finality: Finality}): Promise<Buffer> {
    return Buffer.from(await this.viewCodeRaw(accountId, blockQuery), 'base64');
  }

  /**
   * Download the binary of a given contract.
   * @param accountId contract account
   * @returns Base64 string of Wasm binary
   */
  async viewCodeRaw(accountId: string, blockQuery: {block_id: BlockId} | {finality: Finality} = OPTIMISTIC): Promise<string> {
    const {code_base64}: ContractCodeView = await this.query({
      request_type: 'view_code',
      account_id: accountId,
      ...blockQuery,
    });
    return code_base64;
  }

  async viewAccount(accountId: string, blockQuery: {block_id: BlockId} | {finality: Finality} = OPTIMISTIC): Promise<AccountView> {
    return this.query<AccountView>({
      request_type: 'view_account',
      account_id: accountId,
      ...blockQuery,
    });
  }

  async accountExists(accountId: string, blockQuery?: {block_id: BlockId} | {finality: Finality}): Promise<boolean> {
    try {
      await this.viewAccount(accountId, blockQuery);
      return true;
    } catch {
      return false;
    }
  }

  async viewAccessKey(accountId: string, publicKey: PublicKey | string, blockQuery: {block_id: BlockId} | {finality: Finality} = OPTIMISTIC): Promise<AccessKeyView> {
    return this.query({
      request_type: 'view_access_key',
      account_id: accountId,
      public_key: typeof publicKey === 'string' ? publicKey : publicKey.toString(),
      ...blockQuery,
    });
  }

  async viewAccessKeys(accountId: string, blockQuery: {block_id: BlockId} | {finality: Finality} = OPTIMISTIC): Promise<AccessKeyList> {
    return this.query({
      request_type: 'view_access_key_list',
      account_id: accountId,
      ...blockQuery,
    });
  }

  async protocolConfig(blockQuery: {block_id: BlockId} | {finality: Finality} = OPTIMISTIC): Promise<NearProtocolConfig> {
    // @ts-expect-error Bad type
    return this.experimental_protocolConfig(blockQuery);
  }

  async accountBalance(accountId: string, blockQuery?: {block_id: BlockId} | {finality: Finality}): Promise<AccountBalance> {
    const config = await this.protocolConfig(blockQuery);
    const state = await this.viewAccount(accountId, blockQuery);
    const cost = config.runtime_config.storage_amount_per_byte;
    const costPerByte = NEAR.from(cost);
    const stateStaked = NEAR.from(state.storage_usage).mul(costPerByte);
    const staked = NEAR.from(state.locked);
    const total = NEAR.from(state.amount).add(staked);
    const available = total.sub(staked.max(stateStaked));
    return {
      total,
      stateStaked,
      staked,
      available,
    };
  }

  async viewCall(accountId: string, methodName: string, args: Record<string, unknown> | Uint8Array, blockQuery?: {block_id: BlockId} | {finality: Finality}): Promise<CodeResult> {
    const args_buffer = stringifyJsonOrBytes(args);
    return this.viewCallRaw(accountId, methodName, args_buffer.toString('base64'), blockQuery);
  }

  /**
   * Get full response from RPC about result of view method
   * @param accountId
   * @param methodName
   * @param args Base64 encoded string
   * @param blockQuery
   * @returns
   */
  async viewCallRaw(accountId: string, methodName: string, args: string, blockQuery: {block_id: BlockId} | {finality: Finality} = OPTIMISTIC): Promise<CodeResult> {
    return this.query({
      request_type: 'call_function',
      account_id: accountId,
      method_name: methodName,
      args_base64: args,
      ...blockQuery,
    });
  }

  /**
   * Download the state of a contract given a prefix of a key.
   *
   * @param accountId contract account to lookup
   * @param prefix string or byte prefix of keys to loodup
   * @param blockQuery state at what block, defaults to most recent final block
   * @returns raw RPC response
   */
  async viewState(accountId: string, prefix: string | Uint8Array, blockQuery?: {block_id: BlockId} | {finality: Finality}): Promise<Array<{key: Buffer; value: Buffer}>> {
    const values = await this.viewStateRaw(accountId, prefix, blockQuery);

    return values.map(({key, value}) => ({
      key: Buffer.from(key, 'base64'),
      value: Buffer.from(value, 'base64'),
    }));
  }

  /**
   * Download the state of a contract given a prefix of a key without decoding from base64.
   *
   * @param accountId contract account to lookup
   * @param prefix string or byte prefix of keys to loodup
   * @param blockQuery state at what block, defaults to most recent final block
   * @returns raw RPC response
   */
  async viewStateRaw(accountId: string, prefix: string | Uint8Array, blockQuery?: {block_id: BlockId} | {finality: Finality}): Promise<StateItem[]> {
    const {values} = await this.query<ViewStateResult>({
      request_type: 'view_state',
      ...(blockQuery ?? {finality: 'optimistic'}),
      account_id: accountId,
      prefix_base64: Buffer.from(prefix).toString('base64'),
    });

    return values;
  }

  /**
   * Updates records without using a transaction.
   * Note: only avaialable on Sandbox endpoints.
   * @param records
   * @returns Promise<Empty>
   */
  async patchStateRecords(records: Records): Promise<Empty> {
    return this.sendJsonRpc('sandbox_patch_state', records);
  }

  /**
   * Fast forward to a point in the future. The delta block height is supplied to tell the
   * network to advanced a certain amount of blocks. This comes with the advantage only having
   * to wait a fraction of the time it takes to produce the same number of blocks.
   *
   * Estimate as to how long it takes: if our delta_height crosses `X` epochs, then it would
   * roughly take `X * 5` milliseconds for the fast forward request to be processed.
   *
   * Note: This is not to be confused with speeding up the current in-flight transactions;
   * the state being forwarded in this case refers to time-related state (the block height, timestamp and epoch).
   * @param deltaHeight
   * @returns Promise<Empty>
   */
  async fastForward(deltaHeight: number): Promise<Empty> {
    return this.sendJsonRpc('sandbox_fast_forward', {delta_height: deltaHeight});
  }
}

export const TestnetRpc = JsonRpcProvider.from(TESTNET_RPC_ADDR);
export const MainnetRpc = JsonRpcProvider.from(MAINNET_RPC_ADDR);

'''
'''--- packages/js/src/record/builder.ts ---
import {Buffer} from 'buffer';
import {KeyPair, NamedAccount, PublicKey} from '../types';
import {hashContract} from '../utils';
import {AccessKeyData, Account, AccountData, StateRecord} from './types';

export class RecordBuilder {
  readonly records: StateRecord[] = [];

  static fromAccount(accountId: string | Account | NamedAccount): AccountBuilder {
    return new AccountBuilder(accountId);
  }

  push(record: StateRecord): this {
    this.records.push(record);
    return this;
  }
}

const DEFAULT_ACCOUNT_DATA: AccountData = {
  // 10_000 NEAR
  amount: '10000000000000000000000000000',
  locked: '0',
  // No contract hash
  code_hash: '11111111111111111111111111111111',
  storage_usage: 0,
  version: 'V1',
};

const DEFAULT_ACCESS_KEY_PERMISSION: AccessKeyData
  = {nonce: 0, permission: 'FullAccess'};

function isAccount(something: Account | NamedAccount): something is Account {
  return 'Account' in something
  && typeof something.Account.account_id === 'string';
}

function isNamedAccount(something: Account | NamedAccount): something is NamedAccount {
  return 'accountId' in something
      && typeof something.accountId === 'string';
}

export class AccountBuilder extends RecordBuilder {
  readonly account_id: string;
  constructor(accountOrId: string | Account | NamedAccount) {
    super();
    if (typeof accountOrId === 'string') {
      this.account_id = accountOrId;
    } else if (isAccount(accountOrId)) {
      this.account_id = accountOrId.Account.account_id;
      this.push(accountOrId);
    } else if (isNamedAccount(accountOrId)) {
      this.account_id = accountOrId.accountId;
    } else {
      throw new TypeError(
        'Only `string` or `Record.Accounts` or `NamedAccount` are allowed.',
      );
    }
  }

  accessKey(key: string | PublicKey | KeyPair, access_key = DEFAULT_ACCESS_KEY_PERMISSION): this {
    const public_key
      = typeof key === 'string' ? key
        : (key instanceof PublicKey ? key.toString()
          : key.getPublicKey().toString());
    return this.push({
      AccessKey: {
        account_id: this.account_id,
        public_key,
        access_key,
      },
    });
  }

  account(accountData?: Partial<AccountData>): this {
    const account = {...DEFAULT_ACCOUNT_DATA, ...accountData};
    return this.push({
      Account: {
        account_id: this.account_id,
        account,
      },
    });
  }

  data(data_key: string, value: string): this {
    return this.push({
      Data: {account_id: this.account_id, data_key, value},
    });
  }

  contract(binary: Buffer | string): this {
    const code = typeof binary === 'string' ? binary : binary.toString('base64');
    const record = {
      Contract: {
        account_id: this.account_id,
        code,
      },
    };

    /**
     * Check conditions on ordering and hashes in records to throw error before sandbox does.
    */
    const accountRecord = this.records.find(r => 'Account' in r && r.Account.account_id === this.account_id) as Account;
    if (!accountRecord) {
      throw new Error(`Contract record with account_id: ${this.account_id} does not have a preceding Account record.`);
    }

    if (hashContract(record.Contract.code) !== accountRecord.Account.account.code_hash) {
      throw new Error(`The hash field of the Account record with account_id: ${this.account_id} does not equal the hash of the binary in the Contract record.`);
    }

    return this.push(record);
  }
}

'''
'''--- packages/js/src/record/index.ts ---
export * from './types';
export * from './builder';

'''
'''--- packages/js/src/record/types.ts ---
import {FunctionCallPermissionView} from '../types';

export interface KeyData {
  public_key: string; // "ed25519:546XB2oHhj7PzUKHiH9Xve3Ze5q1JiW2WTh6abXFED3c",
  access_key: AccessKeyData;
}

export interface AccessKeyData {
  nonce: number; // 0,
  permission: 'FullAccess' | FunctionCallPermissionView;
}

export interface AccessKey {
  AccessKey: {
    account_id: string; // "near",
  } & KeyData;
}

export interface AccountData {
  amount: string; // "1000000000000000000000000000000000",
  locked: string; // "0",
  code_hash: string; // "11111111111111111111111111111111",
  storage_usage: number; // 0
  version: 'V1';
}

export interface Account {
  Account: {
    account_id: string;
    account: AccountData;
  };
}

export interface Contract {
  Contract: {
    account_id: string;
    /** Base64 Encoded */
    code: string;
  };
}

// Need to fill out all record types
export interface Data {
  Data: {account_id: string; data_key: string; value: string};
}

export type StateRecord = Data | Account | AccessKey | Contract;

export interface Records {
  records: StateRecord[];
}

/**
 * Unimplemented types

    /// Postponed Action Receipt.
    PostponedReceipt(Box<Receipt>),
    /// Received data from DataReceipt encoded in base64 for the given account_id and data_id.
    ReceivedData {
        account_id: AccountId,
        data_id: CryptoHash,
        #[serde(with = "option_base64_format")]
        data: Option<Vec<u8>>,
    },
    /// Delayed Receipt.
    /// The receipt was delayed because the shard was overwhelmed.
    DelayedReceipt(Box<Receipt>),
 */

'''
'''--- packages/js/src/server/index.ts ---
export * from './server';

'''
'''--- packages/js/src/server/node-port-check.d.ts ---
declare module 'node-port-check' {
  interface NodePortCheck {
    nextAvailable: (from: number, ipAddr: string) => Promise<number>;
  }

  const NodePortCheck: NodePortCheck;

  export = NodePortCheck;
}

'''
'''--- packages/js/src/server/server.ts ---
import {ChildProcess} from 'child_process';
import {Buffer} from 'buffer';
import process from 'process';
import {open} from 'fs/promises';
import {join} from 'path';
import * as http from 'http';
import tmpDir from 'temp-dir';
import * as portCheck from 'node-port-check';
import UUID from 'pure-uuid';
import {
  debug,
  asyncSpawn,
  exists,
  rm,
  spawn,
  copyDir,
  ensureBinary,
} from '../internal-utils';
import {Config, ChildProcessPromise} from '../types';

const pollData = JSON.stringify({
  jsonrpc: '2.0',
  id: 'dontcare',
  method: 'block',
  params: {finality: 'final'},
});

async function pingServer(port: number): Promise<boolean> {
  const options = {
    hostname: '0.0.0.0',
    port,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Content-Length': Buffer.byteLength(pollData),
    },
  };
  return new Promise(resolve => {
    const request = http.request(options, result => {
      if (result.statusCode === 200) {
        resolve(true);
      } else {
        debug(`Sandbox running but got non-200 response: ${JSON.stringify(result)}`);
        resolve(false);
      }
    });
    request.on('error', _ => {
      resolve(false);
    });

    // Write data to request body
    request.write(pollData);
    request.end();
  });
}

async function sandboxStarted(port: number, timeout = 60_000): Promise<void> {
  const checkUntil = Date.now() + timeout + 250;
  do {
    if (await pingServer(port)) { // eslint-disable-line no-await-in-loop
      return;
    }

    await new Promise(resolve => { // eslint-disable-line no-await-in-loop
      setTimeout(() => resolve(true), 250); // eslint-disable-line @typescript-eslint/no-confusing-void-expression
    });
  } while (Date.now() < checkUntil);

  throw new Error(`Sandbox Server with port: ${port} failed to start after ${timeout}ms`);
}

// 5001-60000, increase the range of initialPort to decrease the possibility of port conflict
function initialPort(): number {
  return Math.max(5001, Math.floor(Math.random() * 60_000));
}

export class SandboxServer {
  private static lastPort: number = initialPort();
  private static binPath: string;

  private subprocess!: ChildProcess;
  private readyToDie = false;
  private readonly config: Config;

  private constructor(config: Config) {
    debug('Lifecycle.SandboxServer.constructor', 'config:', config);
    this.config = config;
  }

  static async nextPort(): Promise<number> {
    this.lastPort = await portCheck.nextAvailable(this.lastPort + Math.max(1, Math.floor(Math.random() * 4)), '0.0.0.0');
    return this.lastPort;
  }

  static lockfilePath(filename: string): string {
    return join(tmpDir, filename);
  }

  static randomHomeDir(): string {
    return join(tmpDir, 'sandbox', (new UUID(4).toString()));
  }

  static async init(config: Config): Promise<SandboxServer> {
    debug('Lifecycle.SandboxServer.init()', 'config:', config);
    this.binPath = await ensureBinary();
    const server = new SandboxServer(config);
    if (server.config.refDir) {
      await rm(server.homeDir);
      await copyDir(server.config.refDir, server.config.homeDir);
    }

    if ((await exists(server.homeDir))) {
      await rm(server.homeDir);
    }

    const {stderr, code} = await server.spawn('init');
    if (code && code < 0) {
      debug(stderr);
      throw new Error('Failed to spawn sandbox server');
    }

    return server;
  }

  get homeDir(): string {
    return this.config.homeDir;
  }

  get port(): number {
    return this.config.port;
  }

  get rpcAddr(): string {
    return `http://localhost:${this.port}`;
  }

  async start(): Promise<SandboxServer> {
    debug('Lifecycle.SandboxServer.start()');
    const args = [
      '--home',
      this.homeDir,
      'run',
      '--rpc-addr',
      `0.0.0.0:${this.port}`,
      '--network-addr',
      `0.0.0.0:${await SandboxServer.nextPort()}`,
    ];
    if (process.env.NEAR_WORKSPACES_DEBUG) {
      const filePath = join(this.homeDir, 'sandboxServer.log');
      debug(`near-sandbox logs writing to file: ${filePath}`);
      const fd = await open(filePath, 'a');
      this.subprocess = spawn(SandboxServer.binPath, args, {
        env: {RUST_BACKTRACE: 'full'},
        // @ts-expect-error FileHandle not assignable to Stream | IOType
        stdio: ['ignore', 'ignore', fd],
      });
      this.subprocess.on('exit', async () => {
        await fd.close();
      });
    } else {
      this.subprocess = spawn(SandboxServer.binPath, args, {
        stdio: ['ignore', 'ignore', 'ignore'],
      });
    }

    this.subprocess.on('exit', () => {
      if (!this.readyToDie) {
        debug(`Server with port ${this.port}: died horribly`);
      }
    });
    await sandboxStarted(this.port);
    return this;
  }

  async close(): Promise<void> {
    debug('Lifecycle.SandboxServer.close()');
    this.readyToDie = true;
    if (!this.subprocess.kill('SIGINT')) {
      console.error(
        `Failed to kill child process with PID: ${this.subprocess.pid ?? 'undefined'}`,
      );
    }

    if (this.config.rm) {
      await rm(this.homeDir);
    }
  }

  private async spawn(command: string): ChildProcessPromise {
    debug('Lifecycle.SandboxServer.spawn()');
    return asyncSpawn(SandboxServer.binPath, '--home', this.homeDir, command);
  }
}

'''
'''--- packages/js/src/transaction-result.ts ---
import {Buffer} from 'buffer';
import {Gas} from 'near-units';
import {
  Action,
  ClientConfig,
  ExecutionError,
  ExecutionOutcome,
  ExecutionOutcomeWithId,
  ExecutionStatus,
  ExecutionStatusBasic,
  FinalExecutionOutcome,
  FinalExecutionStatus,
  FinalExecutionStatusBasic,
  PublicKey,
} from './types';

function includes(pattern: string | RegExp): (s: string) => boolean {
  if (typeof pattern === 'string') {
    return s => s.includes(pattern);
  }

  return s => pattern.test(s);
}

function parseValue<T>(value: string): T | string {
  const buffer = Buffer.from(value, 'base64').toString();
  try {
    return JSON.parse(buffer) as T;
  } catch {
    return buffer;
  }
}

export class ReceiptOutcome {
  constructor(public outcome: ExecutionOutcome) {}

  get failures(): Array<Record<string, unknown>> {
    return [];
  }

  get status(): ExecutionStatus | ExecutionStatusBasic {
    return this.outcome.status;
  }

  get succeeded(): boolean {
    if (typeof this.status === 'string') {
      return false;
    }

    return this.status.SuccessValue !== undefined;
  }

  get isFailure(): boolean {
    if (typeof this.status === 'string') {
      return false;
    }

    return this.status.Failure !== undefined;
  }

  get executionStatus(): ExecutionStatus {
    return this.status as ExecutionStatus;
  }

  parseResult(): any {
    if (this.succeeded) {
      return parseValue(this.SuccessValue!);
    }

    throw new Error(JSON.stringify(this.status));
  }

  get SuccessValue(): string | undefined {
    if (this.succeeded) {
      return this.executionStatus.SuccessValue!;
    }

    return undefined;
  }

  get executionFailure(): ExecutionError | undefined {
    if (this.isFailure) {
      return this.executionStatus.Failure!;
    }

    return undefined;
  }

  get failureMessage(): string | undefined {
    return this.executionFailure?.error_message;
  }

  get failureType(): string | undefined {
    return this.executionFailure?.error_type;
  }

  get logs(): string[] {
    return this.outcome.logs;
  }

  get gas_burnt(): Gas {
    return Gas.from(this.outcome.gas_burnt);
  }
}

export class TransactionResult {
  constructor(
    public readonly result: FinalExecutionOutcome,
    public readonly startMs: number,
    public readonly endMs: number,
    private readonly config: ClientConfig,
  ) {}

  get durationMs(): number {
    return this.endMs - this.startMs;
  }

  get outcomesWithId(): ExecutionOutcomeWithId[] {
    const {result} = this;
    return [result.transaction_outcome, ...result.receipts_outcome];
  }

  get receipts_outcomes(): ReceiptOutcome[] {
    return this.result.receipts_outcome.flatMap(
      o => new ReceiptOutcome(o.outcome),
    );
  }

  get outcome(): ExecutionOutcome {
    return this.result.transaction_outcome.outcome;
  }

  get outcomes(): ExecutionOutcome[] {
    return this.outcomesWithId.flatMap(o => o.outcome);
  }

  get logs(): string[] {
    return this.outcomes.flatMap(it => it.logs);
  }

  get transactionReceipt(): TransactionReceipt {
    return this.result.transaction as TransactionReceipt;
  }

  get failures(): ExecutionError[] {
    const failures = [...this.receiptFailures];

    if (this.Failure) {
      failures.unshift(this.Failure);
    }

    return failures;
  }

  get status(): FinalExecutionStatus | FinalExecutionStatusBasic {
    return this.result.status;
  }

  get succeeded(): boolean {
    if (typeof this.result.status === 'string') {
      return false;
    }

    return this.result.status.SuccessValue !== undefined;
  }

  get SuccessValue(): string | null {
    if (this.succeeded) {
      return this.finalExecutionStatus.SuccessValue!;
    }

    return null;
  }

  get failed(): boolean {
    if (typeof this.result.status === 'string') {
      return false;
    }

    return this.result.status.Failure !== undefined;
  }

  get Failure(): ExecutionError | null {
    if (this.failed) {
      return this.finalExecutionStatus.Failure!;
    }

    return null;
  }

  logsContain(pattern: string | RegExp): boolean {
    return this.logs.some(includes(pattern));
  }

  findLogs(pattern: string | RegExp): string[] {
    return this.logs.filter(includes(pattern));
  }

  receiptSuccessValuesContain(pattern: string | RegExp): boolean {
    return this.receiptSuccessValues.some(includes(pattern));
  }

  findReceiptSuccessValues(pattern: string | RegExp): string[] {
    return this.receiptSuccessValues.filter(includes(pattern));
  }

  get finalExecutionStatus(): FinalExecutionStatus {
    return this.status as FinalExecutionStatus;
  }

  get receiptFailures(): ExecutionError[] {
    return this.receipts_outcomes.flatMap(o => o.executionFailure ?? []);
  }

  get receiptSuccessValues(): string[] {
    return this.receipts_outcomes.flatMap(o => o.SuccessValue ?? []);
  }

  get receiptFailureMessages(): string[] {
    return this.receiptFailures.map(failure => JSON.stringify(failure));
  }

  get gas_burnt(): Gas {
    const receipts_gas = this.receipts_outcomes.reduce((acc, cur) => acc + cur.outcome.gas_burnt, 0);
    return Gas.from(this.result.transaction_outcome.outcome.gas_burnt + receipts_gas);
  }

  receiptFailureMessagesContain(pattern: string | RegExp): boolean {
    return this.receiptFailureMessages.some(includes(pattern));
  }

  parseResult<T>(): T {
    if (this.succeeded) {
      return parseValue<T>(this.SuccessValue!) as T;
    }

    throw new Error(JSON.stringify(this.status));
  }

  parsedReceiptResults(): any[] {
    return this.receiptSuccessValues.map(parseValue);
  }

  summary(): string {
    return `(${this.durationMs} ms) burned ${this.gas_burnt.toHuman()} ${transactionReceiptToString(this.transactionReceipt, this.config.explorerUrl)}`;
  }
}

export interface TransactionReceipt {
  actions: Action[];
  hash: string;
  nonce: number;
  public_key: PublicKey;
  receiver_id: string;
  signature: string;
  signer_id: string;
}

function transactionReceiptToString(tx: TransactionReceipt, explorerUrl?: string): string {
  return `${tx.signer_id} -> ${tx.receiver_id} Nonce: ${tx.nonce} Hash: ${explorerUrl ? explorerUrl + '/' : ''}${tx.hash} Actions:\n${tx.actions.map(a => JSON.stringify(a)).join('\n')}`;
}

export class TransactionError extends Error {
  constructor(result: TransactionResult) {
    super(JSON.stringify(result));
  }

  parse(): ExecutionOutcome {
    return JSON.parse(this.message) as ExecutionOutcome;
  }
}

export type TxResult = TransactionResult;

'''
'''--- packages/js/src/transaction.ts ---
import {Buffer} from 'buffer';
import * as fs from 'fs/promises';
import {URL} from 'url';
import {NEAR} from 'near-units';
import {TransactionResult} from './transaction-result';
import {
  Action,
  PublicKey,
  AccessKey,
  fullAccessKey,
  addKey,
  createAccount,
  deleteAccount,
  deleteKey,
  deployContract,
  functionCall,
  stake,
  transfer,
  BN,
  DEFAULT_FUNCTION_CALL_GAS,
  KeyPair,
  NamedAccount,
} from './types';
import {findFile, isPathLike} from './internal-utils';
import {NO_DEPOSIT, parseGas, parseNEAR} from './utils';

export abstract class Transaction {
  readonly receiverId: string;
  readonly senderId: string;
  readonly actions: Action[] = [];
  private accountToBeCreated = false;
  private _transferAmount?: NEAR;

  constructor(sender: NamedAccount | string, receiver: NamedAccount | string) {
    this.senderId = typeof sender === 'string' ? sender : sender.accountId;
    this.receiverId = typeof receiver === 'string' ? receiver : receiver.accountId;
  }

  addKey(publicKey: string | PublicKey, accessKey: AccessKey = fullAccessKey()): this {
    this.actions.push(addKey(PublicKey.from(publicKey), accessKey));
    return this;
  }

  createAccount(): this {
    this.accountToBeCreated = true;
    this.actions.push(createAccount());
    return this;
  }

  deleteAccount(beneficiaryId: string): this {
    this.actions.push(deleteAccount(beneficiaryId));
    return this;
  }

  deleteKey(publicKey: string | PublicKey): this {
    this.actions.push(deleteKey(PublicKey.from(publicKey)));
    return this;
  }

  /**
   * Deploy given Wasm file to the account.
   *
   * @param code path or data of contract binary. If given an absolute path (such as one created with 'path.join(__dirname, …)') will use it directly. If given a relative path such as `res/contract.wasm`, will resolve it from the project root (meaning the location of the package.json file).
   */
  async deployContractFile(code: string | URL | Uint8Array | Buffer): Promise<Transaction> {
    return this.deployContract(isPathLike(code)
      ? await fs.readFile(
        code.toString().startsWith('/') ? code : await findFile(code.toString()),
      )
      : code,
    );
  }

  deployContract(code: Uint8Array | Buffer): this {
    this.actions.push(deployContract(code));
    return this;
  }

  functionCall(
    methodName: string,
    args: Record<string, unknown> | Uint8Array,
    {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      gas = DEFAULT_FUNCTION_CALL_GAS,
      attachedDeposit = NO_DEPOSIT,
    }: {gas?: BN | string; attachedDeposit?: BN | string} = {},
  ): this {
    this.actions.push(
      functionCall(methodName, args, parseGas(gas), parseNEAR(attachedDeposit)),
    );
    return this;
  }

  stake(amount: BN | string, publicKey: PublicKey | string): this {
    this.actions.push(stake(new BN(amount), PublicKey.from(publicKey)));
    return this;
  }

  transfer(amount: string | BN): this {
    this._transferAmount = parseNEAR(amount);
    this.actions.push(transfer(this._transferAmount));
    return this;
  }

  get accountCreated(): boolean {
    return this.accountToBeCreated;
  }

  get transferAmount(): NEAR {
    return this._transferAmount ?? NEAR.from('0');
  }

  abstract transact(keyPair?: KeyPair): Promise<TransactionResult>;
}

'''
'''--- packages/js/src/types.ts ---
import {ChildProcess} from 'child_process';
import _BN from 'bn.js';
import {KeyPair} from 'near-api-js';
import {Output} from 'promisify-child-process';
import {NEAR} from 'near-units';
import {KeyStore} from 'near-api-js/lib/key_stores';

export {ServerError} from 'near-api-js/lib/utils/rpc_errors';
export {KeyPair, Connection} from 'near-api-js';
export {PublicKey, KeyPairEd25519} from 'near-api-js/lib/utils';
export {
  Action,
  createAccount,
  deployContract,
  functionCall,
  transfer,
  stake,
  addKey,
  deleteKey,
  deleteAccount,
  fullAccessKey,
  AccessKey,
} from 'near-api-js/lib/transaction';

export {JsonRpcProvider as JSONRpc} from 'near-api-js/lib/providers/json-rpc-provider';
export {KeyStore} from 'near-api-js/lib/key_stores';
export * from 'near-api-js/lib/providers/provider';

export {DEFAULT_FUNCTION_CALL_GAS} from 'near-api-js/lib/constants';

export class BN extends _BN {
  toJSON(): string {
    return this.toString(10);
  }
}

export type Args = Record<string, any> | Uint8Array;

export interface NamedAccount {
  accountId: string;
}

export interface CallOptions {
  gas?: string | BN;
  attachedDeposit?: string | BN;
  signWithKey?: KeyPair;
}

export type ChildProcessPromise = Promise<ChildProcess & Promise<Output>>;

export interface AccountBalance {
  total: NEAR;
  stateStaked: NEAR;
  staked: NEAR;
  available: NEAR;
}

export type Network = 'testnet' | 'mainnet' | 'sandbox' | 'custom';

export interface ClientConfig {
  network: Network;
  rootAccountId?: string;
  testnetMasterAccountId?: string;
  rpcAddr: string;
  apiKey?: string;
  helperUrl?: string;
  explorerUrl?: string;
  initialBalance?: string;
  walletUrl?: string;
  archivalUrl?: string;
}

export interface Config extends ClientConfig {
  homeDir: string;
  port: number;
  rm: boolean;
  refDir: string | null;
  keyStore?: KeyStore;
}

export const TESTNET_RPC_ADDR = 'https://archival-rpc.testnet.near.org';
export const MAINNET_RPC_ADDR = 'https://archival-rpc.mainnet.near.org';

export interface StateItem {
  key: string;
  value: string;
  proof: string[];
}

export type Empty = {}; // eslint-disable-line @typescript-eslint/ban-types

'''
'''--- packages/js/src/utils.ts ---
import {Buffer} from 'buffer';
import * as process from 'process';
import * as os from 'os';
import * as path from 'path';
import * as nearAPI from 'near-api-js';
import sha256 from 'js-sha256';
import bs58 from 'bs58';
import {Gas, NEAR} from 'near-units';
import {NamedAccount, KeyPair, ClientConfig, KeyStore, BN} from './types';

export const ONE_NEAR = NEAR.parse('1N');

export function toYocto(amount: string): string {
  return NEAR.parse(`${amount}N`).toString();
}

export function createKeyPair(): KeyPair {
  return nearAPI.utils.KeyPairEd25519.fromRandom();
}

export function tGas(x: string | number) {
  if (typeof x === 'string' && Number.isNaN(Number.parseInt(x, 10))) {
    throw new TypeError(
      `tGas expects a number or a number-like string; got: ${x}`,
    );
  }

  return String(x) + '0'.repeat(12);
}

// Create random account with at least 33 digits by default
export function randomAccountId(prefix = 'dev-', dateLength = 13, suffixLength = 15): string {
  const suffix = Math.floor(Math.random() * (10 ** 22)) % (10 ** suffixLength);
  return `${timeSuffix(prefix, dateLength)}-${suffix}`;
}

export function asId(id: string | NamedAccount): string {
  return typeof id === 'string' ? id : id.accountId;
}

export const NO_DEPOSIT = NEAR.from(0);

export async function captureError(fn: () => Promise<any>): Promise<string> {
  try {
    await fn();
  } catch (error: unknown) {
    if (error instanceof Error) {
      return error.message;
    }
  }

  throw new Error('fn succeeded when expected to throw an exception');
}

export function isTopLevelAccount(accountId: string): boolean {
  return !accountId.includes('.');
}

function configFromDomain(network: 'testnet' | 'mainnet' | 'custom'): ClientConfig {
  let rpcAddr = `https://archival-rpc.${network}.near.org`;
  if (network === 'mainnet' && process.env.NEAR_CLI_MAINNET_RPC_SERVER_URL) {
    rpcAddr = process.env.NEAR_CLI_MAINNET_RPC_SERVER_URL;
  } else if (network === 'testnet' && process.env.NEAR_CLI_TESTNET_RPC_SERVER_URL) {
    rpcAddr = process.env.NEAR_CLI_TESTNET_RPC_SERVER_URL;
  }

  return {
    network,
    rpcAddr,
    walletUrl: `https://wallet.${network}.near.org`,
    helperUrl: `https://helper.${network}.near.org`,
    explorerUrl: `https://explorer.${network}.near.org`,
    archivalUrl: `https://archival-rpc.${network}.near.org`,
  };
}

export function urlConfigFromNetwork(network: string | {network: string; rpcAddr?: string}): ClientConfig {
  const networkName = typeof network === 'string' ? network : network.network;
  const rpcAddr = typeof network === 'string' ? undefined : network.rpcAddr;
  switch (networkName) {
    case 'sandbox':
      return {
        network: 'sandbox',
        rpcAddr: 'http://localhost',
      };

    case 'custom':
      return {
        network: 'custom',
        rpcAddr: rpcAddr!,
      };

    case 'testnet':
    case 'mainnet': return configFromDomain(networkName);
    default:
      throw new Error(`Got network ${networkName}, but only accept 'sandbox', 'testnet', 'mainnet' and 'custom'`);
  }
}

/**
 *
 * @param contract Base64 encoded binary or Buffer.
 * @returns sha256 hash of contract.
 */
export function hashContract(contract: string | Buffer): string {
  const bytes = typeof contract === 'string' ? Buffer.from(contract, 'base64') : contract;
  const buffer = Buffer.from(sha256.sha256(bytes), 'hex');
  return bs58.encode(buffer);
}

export const EMPTY_CONTRACT_HASH = '11111111111111111111111111111111';

/**
 *
 * @returns network to connect to. Default 'sandbox'
 */
export function getNetworkFromEnv(): 'sandbox' | 'testnet' | 'custom' {
  const network = process.env.NEAR_WORKSPACES_NETWORK;
  switch (network) {
    case 'sandbox':
    case 'testnet':
    case 'custom':
      return network;
    case undefined:
      return 'sandbox';
    default:
      throw new Error(
        `environment variable NEAR_WORKSPACES_NETWORK=${network} invalid; `
        + 'use \'testnet\', \'custom\', or \'sandbox\' (the default)',
      );
  }
}

export function homeKeyStore(): KeyStore {
  return new nearAPI.keyStores.UnencryptedFileSystemKeyStore(
    path.join(os.homedir(), '.near-credentials'),
  );
}

export function timeSuffix(prefix: string, length = 6): string {
  return `${prefix}${Date.now() % (10 ** length)}`;
}

const NOT_NUMBER_OR_UNDERLINE = /[^\d_]/;

export function parseGas(s: string | BN): Gas {
  if (typeof s === 'string' && NOT_NUMBER_OR_UNDERLINE.test(s)) {
    return Gas.parse(s);
  }

  return Gas.from(s);
}

// One difference with `NEAR.parse` is that here strings of just numbers are considered `yN`
// And not `N`
export function parseNEAR(s: string | BN): NEAR {
  if (typeof s === 'string' && NOT_NUMBER_OR_UNDERLINE.test(s)) {
    return NEAR.parse(s);
  }

  return NEAR.from(s);
}

'''
'''--- packages/js/src/worker.ts ---
import fs from 'fs';
import {NEAR} from 'near-units';
import {lock} from 'proper-lockfile';
import {getNetworkFromEnv, urlConfigFromNetwork} from './utils';
import {Config, ClientConfig} from './types';
import {AccountManager, NearAccount, NearAccountManager} from './account';
import {JsonRpcProvider} from './jsonrpc';
import {debug} from './internal-utils';
import {SandboxServer} from './server/server';

const API_KEY_HEADER = 'x-api-key';

/**
 * The main interface to near-workspaces. Create a new worker instance with {@link Worker.init}, then run code on it.
 */
export abstract class Worker {
  protected config: Config;

  protected manager!: NearAccountManager;

  constructor(config: Config) {
    debug('Lifecycle.Worker.constructor', 'config:', config);
    this.config = config;
    this.manager = AccountManager.create(config);
  }

  /**
   * Initialize a new worker.
   *
   * In local sandbox mode, this will:
   *   - Create a new local blockchain
   *   - Load the root account for that blockchain, available as `root`:
   *
   * In testnet mode, the same functionality is achieved via different means:
   * creating a new account as the `root`.
   * Since all actions must occur on one blockchain instead of N.
   *
   * @param config a configuration object
   * @returns an instance of the Worker class
   */
  static async init(config: Partial<Config> = {}): Promise<Worker> {
    debug('Lifecycle.Worker.init()', 'config:', config);
    switch (config.network ?? getNetworkFromEnv()) {
      case 'testnet':
        return TestnetWorker.init(config);
      case 'sandbox':
        return SandboxWorker.init(config);
      case 'custom':
        return CustomnetWorker.init(config);
      default:
        throw new Error(
          `config.network = '${config.network}' invalid; ` // eslint-disable-line @typescript-eslint/restrict-template-expressions
            + 'must be \'testnet\', \'sandbox\' or \'custom\' (the default). Soon \'mainnet\'',
        );
    }
  }

  get rootAccount(): NearAccount {
    return this.manager.root;
  }

  abstract get provider(): JsonRpcProvider;

  abstract tearDown(): Promise<void>;
}

// Connect to a custom network.
// Note: the burden of ensuring the methods that are able to be called are left up to the user.
export class CustomnetWorker extends Worker {
  private readonly clientConfig: ClientConfig = urlConfigFromNetwork({network: 'custom', rpcAddr: this.config.rpcAddr});

  static async init(config: Partial<Config>): Promise<CustomnetWorker> {
    debug('Lifecycle.CustomnetWorker.create()', 'config:', config);
    const fullConfig = {
      homeDir: 'ignored',
      port: 3030,
      rm: false,
      refDir: null,
      ...urlConfigFromNetwork({network: 'custom', rpcAddr: config.rpcAddr}), // Copied over, can't access member clientConfig here
      ...config,
    };

    const worker = new CustomnetWorker(fullConfig);
    if (config.apiKey) {
      worker.provider.connection.headers = {
        ...worker.provider.connection.headers, [API_KEY_HEADER]: config.apiKey,
      };
    }

    await worker.manager.init();
    return worker;
  }

  get provider(): JsonRpcProvider {
    return JsonRpcProvider.from(this.clientConfig);
  }

  async tearDown(): Promise<void> {
    // We are not stopping any server here because it is an external network.
    return Promise.resolve();
  }

  get defaultConfig(): Config {
    return {
      homeDir: 'ignored',
      port: 3030,
      rm: false,
      refDir: null,
      ...this.clientConfig,
    };
  }
}

export class TestnetWorker extends Worker {
  static async init(config: Partial<Config>): Promise<TestnetWorker> {
    debug('Lifecycle.TestnetWorker.create()', 'config:', config);
    const fullConfig = {...this.defaultConfig, ...config};

    const worker = new TestnetWorker(fullConfig);
    if (config.apiKey) {
      worker.provider.connection.headers = {
        ...worker.provider.connection.headers, [API_KEY_HEADER]: config.apiKey,
      };
    }

    await worker.manager.init();
    return worker;
  }

  get provider(): JsonRpcProvider {
    return JsonRpcProvider.from(TestnetWorker.clientConfig);
  }

  async tearDown(): Promise<void> {
    // We are not stoping any server here because we are using Testnet
    return Promise.resolve();
  }

  static get defaultConfig(): Config {
    return {
      homeDir: 'ignored',
      port: 3030,
      rm: false,
      refDir: null,
      ...this.clientConfig,
    };
  }

  private static get clientConfig(): ClientConfig {
    return urlConfigFromNetwork('testnet');
  }
}

export class SandboxWorker extends Worker {
  private server!: SandboxServer;

  static async init(config: Partial<Config>): Promise<SandboxWorker> {
    debug('Lifecycle.SandboxWorker.create()', 'config:', config);
    const syncFilename = SandboxServer.lockfilePath('near-sandbox-worker-sync.txt');
    try {
      fs.accessSync(syncFilename, fs.constants.F_OK);
    } catch {
      debug('catch err in access file:', syncFilename);
      fs.writeFileSync(syncFilename, 'workspace-js test port sync');
    }

    const retryOptions = {
      retries: {
        retries: 100,
        factor: 3,
        minTimeout: 200,
        maxTimeout: 2 * 1000,
        randomize: true,
      },
    };

    // Add file lock in assign port and run near node process
    const release = await lock(syncFilename, retryOptions);
    const defaultConfig = await this.defaultConfig();
    const worker = new SandboxWorker({...defaultConfig, ...config});
    if (config.apiKey) {
      worker.provider.connection.headers = {
        ...worker.provider.connection.headers, [API_KEY_HEADER]: config.apiKey,
      };
    }

    worker.server = await SandboxServer.init(worker.config);
    await worker.server.start();
    // Release file lock after near node start
    await release();
    await worker.manager.init();
    return worker;
  }

  static async defaultConfig(): Promise<Config> {
    const port = await SandboxServer.nextPort();
    return {
      ...this.clientConfig,
      homeDir: SandboxServer.randomHomeDir(),
      port,
      rm: false,
      refDir: null,
      rpcAddr: `http://localhost:${port}`,
    };
  }

  get provider(): JsonRpcProvider {
    return JsonRpcProvider.from(this.rpcAddr);
  }

  async tearDown(): Promise<void> {
    try {
      await this.server.close();
    } catch (error: unknown) {
      debug('this.server.close() threw error.', JSON.stringify(error, null, 2));
    }
  }

  private static get clientConfig(): ClientConfig {
    return {
      network: 'sandbox',
      rootAccountId: 'test.near',
      rpcAddr: '', // Will be over written
      initialBalance: NEAR.parse('100 N').toJSON(),
    };
  }

  private get rpcAddr(): string {
    return `http://localhost:${this.config.port}`;
  }
}

'''
'''--- packages/js/tsconfig.json ---
{
  "compilerOptions": {
    /* Basic Options */
    "incremental": true, /* Enable incremental compilation */
    "target": "ES2019", /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019' or 'ESNEXT'. */
    "module": "commonjs", /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */
    "lib": [
      "es2020",
      "ESNext"
    ], /* Specify library files to be included in the compilation. */
    "allowJs": true, /* Allow javascript files to be compiled. */
    "declaration": true, /* Generates corresponding '.d.ts' file. */
    "declarationMap": true, /* Generates a sourcemap for each corresponding '.d.ts' file. */
    "sourceMap": true, /* Generates corresponding '.map' file. */
    "outDir": "./dist", /* Redirect output structure to the directory. */
    /* Strict Type-Checking Options */
    "strict": true, /* Enable all strict type-checking options. */
    "noImplicitAny": true, /* Raise error on expressions and declarations with an implied 'any' type. */
    "strictNullChecks": true, /* Enable strict null checks. */
    "noImplicitThis": true, /* Raise error on 'this' expressions with an implied 'any' type. */
    "esModuleInterop": true, /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */
    "forceConsistentCasingInFileNames": true /* Disallow inconsistently-cased references to the same file. */
  },
  "include": [
    "src/*.ts",
    "src/**/*.ts",
    "src/server/*.d.ts"
  ]
}
'''
'''--- packages/js/typedoc.json ---
{
    "extends": [
      "../../typedoc.json"
    ],
    "entryPoints": [
      "src"
    ],
    "entryPointStrategy": "expand",
}
'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "target": "ES2019",
    "module": "commonjs",
    "lib": [
      "es2020",
      "ESNext"
    ],
    "allowJs": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "incremental": true,
    "declaration": true,
    "sourceMap": true,
    /* Strict Type-Checking Options */
    "strict": true, /* Enable all strict type-checking options. */
    "noImplicitAny": true, /* Raise error on expressions and declarations with an implied 'any' type. */
    "strictNullChecks": true, /* Enable strict null checks. */
    "noImplicitThis": true, /* Raise error on 'this' expressions with an implied 'any' type. */
  }
}
'''
'''--- typedoc.json ---
{
    "includeVersion": true,
    "entryPoints": [
      "packages/js",
    ],
    "entryPointStrategy": "packages",
    "githubPages": true,
    "validation": {
      "notExported": false
    },
    "out": "docs",
    "readme": "./README.md"
}
'''