*GitHub Repository "nhussein11/web3-infura"*

'''--- .github/workflows/rust.yml ---
name: Rust

on:
  push:
    branches: ["master"]
  pull_request:
    branches: ["master"]

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    runs-on: ubuntu-latest
    environment: INFURA_API_KEY
    steps:
      - uses: actions/checkout@v3
      - name: Build
        run: cargo build --verbose
      # - name: Dump Secret [debug]
      # run: echo -n "${{ secrets.INFURA_API_KEY }}" | xxd -ps
      - name: Run tests
        run: cargo test --verbose
        env:
          INFURA_API_KEY: ${{ secrets.INFURA_API_KEY }}

'''
'''--- Cargo.toml ---
[package]
name = "web3-infura"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
clap = { version = "4.1.6", features = ["derive"] }
dotenv = "0.15.0"
num-format = "0.4.4"
tokio = "1.25.0"
web3 = "0.18.0"

'''
'''--- README.md ---
# Web 3 - Infura :boom:

This project is a simple example of how to use Infura to connect to the Ethereum blockchain. It uses the Infura API to get the latest block number and the latest block hash. To get the infura API key, you need to create an account on [Infura](https://infura.io/). After creating an account, you can create a new project and get the API key.

As it is a simple example, I added only some of the available methods in the Infura API. You can find the full list of the available methods [here](https://docs.infura.io/infura/networks/ethereum/json-rpc-methods).

### Why did I create this project? :books:

The main reason is that I wanted to learn more about Rust and I thought that creating a CLI to get information about the Ethereum blockchain would be a good idea. I also wanted to learn more about the Rust ecosystem and how to use some of the available crates. I used the following crates in this project:

- [clap](https://crates.io/crates/clap): to parse the CLI arguments
- [dotenv](https://crates.io/crates/dotenv): to load the environment variables from the .env file
- [tokio](https://crates.io/crates/tokio): to make HTTP requests
- [web3](https://crates.io/crates/web3): to connect to the Ethereum blockchain
- [num-format](https://crates.io/crates/num-format): to format the numbers

### What's next? :100:

If I have more time, I will add more features to this project. My idea is to use the CLI to get information not only about the Ethereum blockchain but also about other blockchains available on Infura, that's why I separated the project into different modules, so it will be easier to add more features tn the future hypothetically. For instance, if I want to add a module that to get information about NEAR blockchain, probably I will create a new module called `near` and there I would add the necessary code to get the desired data.

Having that in mind, **_if you want to contribute to this project, obviously you are more than welcome_**. Feel free to add more features to the CLI or suggest some ideas for new features.

## How to run :runner:

1. Clone the project:

```bash
git clone https://github.com/nhussein11/web3-infura.git
```

2. Create a .env file and add the infura API key with the following format:

```bash
INFURA_API_KEY=<YOUR_API_KEY>
```

3. Run the CLI (to see some of the available commands, you can run the following command):

```bash
cargo run -- --help
```

At the moment, the CLI only supports the following commands:

- `balance` : get the balance of an address
- `block-number`: get the latest block number
- `get-price`: get the current price of Ether in USD

This CLI also provides the option to specify the transport protocol. The default protocol is HTTP. You can also use WebSockets. To use WebSockets, you need to add the `web-socket` flag when running the CLI.

## How to test :white_check_mark:

I wrote some unit test for this project. It's important to mention that some tests, like the ones that depends on real time variation, are approachs in fact.

- To run all of them, you just need to run the following command:

```bash
cargo test
```

- If you want to run a specific test, you can run the following command:

```bash
cargo test <test_name>
```

## Examples :crab:

Let's see some examples:

- Get the balance of the following address, using HTTP

```bash
cargo run -- balance --address 0x71C7656EC7ab88b098defB751B7401B5f6d8976F
```

- Get the balance of the following address, using WebSockets

```bash
cargo run -- web-socket balance --address 0x71C7656EC7ab88b098defB751B7401B5f6d8976F
```

- Get the latest block number, using HTTP

```bash
cargo run -- block-number
```

- Get the current gas price, using WebSockets

```bash
cargo run -- web-socket gas-price
```

And that's it. I hope you find this project useful. If you have any questions, feel free to contact me :rocket:

'''
'''--- src/cli/cli.rs ---
pub mod cli {
    use crate::{
        ethereum::ethereum::{
            get_eth_balance, get_eth_blocknumber, get_eth_gasprice, ETH_HTTP_URL, ETH_WS_URL,
        },
        infura::infura::{HttpBuilder, WebSocketBuilder},
    };

    use clap::Parser;
    use web3::{Transport as Web3Transport, Web3};

    #[derive(Parser, Debug)]
    #[clap(version = "1.0", author = "nhussein11")]
    pub struct Commands {
        #[clap(value_enum, default_value = "http")]
        pub transport: Transport,

        #[clap(subcommand)]
        pub ethereum_subcommands: EthereumSubcommands,
    }
    #[derive(clap::ValueEnum, Debug, Clone, PartialEq)]
    pub enum Transport {
        Http,
        WebSocket,
    }

    #[derive(Parser, Debug)]
    pub enum EthereumSubcommands {
        #[clap(version = "1.0", author = "nhussein11")]
        Balance(Balance),
        #[clap(version = "1.0", author = "nhussein11")]
        BlockNumber,
        #[clap(version = "1.0", author = "nhussein11")]
        GasPrice,
    }

    #[derive(Parser, Debug)]
    pub struct Balance {
        #[clap(short, long)]
        pub address: String,
    }

    pub async fn run_cli(api_key: &String) {
        let args = Commands::parse();

        match args.transport {
            Transport::Http => {
                let http_url = format!("{}{}", ETH_HTTP_URL, api_key);
                let web3s = HttpBuilder::new(http_url).build();
                match web3s {
                    Ok(web3s) => run_ethereum_subcommands(args.ethereum_subcommands, &web3s).await,
                    Err(e) => println!("Error: {}", e),
                }
            }
            Transport::WebSocket => {
                let ws_url = format!("{}{}", ETH_WS_URL, api_key);
                let web3s = WebSocketBuilder::new(ws_url).build().await;
                match web3s {
                    Ok(web3s) => run_ethereum_subcommands(args.ethereum_subcommands, &web3s).await,
                    Err(e) => println!("Error: {}", e),
                }
            }
        }
    }

    async fn run_ethereum_subcommands<T: Web3Transport>(
        args: EthereumSubcommands,
        web3s: &Web3<T>,
    ) {
        match args {
            EthereumSubcommands::Balance(balance) => {
                get_eth_balance(web3s, &balance.address).await;
            }
            EthereumSubcommands::BlockNumber => {
                get_eth_blocknumber(web3s).await;
            }
            EthereumSubcommands::GasPrice => {
                get_eth_gasprice(web3s).await;
            }
        };
    }
}

'''
'''--- src/cli/tests.rs ---
/*
I'm aware that is not a good practice to do this kind of "unit tests" (spawing subprocess and
checking the output), but I'm doing this just to learn how to do it.

The idea is to have a test for each command, just showing that the command is working.
*/
#[cfg(test)]
mod tests {
    use std::process::Command;

    #[test]
    fn get_gas_price_using_ws() {
        let mut binding = Command::new("cargo");
        let command = binding
            .arg("run")
            .arg("--")
            .arg("web-socket")
            .arg("gas-price");

        assert!(output.status.success());
    }

    #[test]
    fn try_to_get_gas_price_using_ws() {
        let mut binding = Command::new("cargo");
        let command = binding
            .arg("run")
            .arg("--")
            .arg("web-socket")
            // Use invalid argument
            .arg("gas-pri");

        let output = command.output().unwrap();
        assert!(!output.status.success());
    }

    #[test]
    fn get_gas_price_using_http() {
        let mut binding = Command::new("cargo");

        let command = binding.arg("run").arg("--").arg("http").arg("gas-price");

        let output = command.output().unwrap();
        assert!(output.status.success());
    }

    #[test]
    fn try_to_get_gas_price_using_http() {
        let mut binding = Command::new("cargo");

        let command = binding
            .arg("run")
            .arg("--")
            .arg("http")
            // Use invalid argument (use "gas-pri" instead of "gas-price")
            .arg("gas-pri");

        let output = command.output().unwrap();
        assert!(!output.status.success());
    }

    #[test]
    fn get_balance_using_ws() {
        let mut binding = Command::new("cargo");

        let command = binding
            .arg("run")
            .arg("--")
            .arg("web-socket")
            .arg("balance")
            .arg("--address")
            .arg("0x71C7656EC7ab88b098defB751B7401B5f6d8976F");

        let output = command.output().unwrap();
        assert!(output.status.success());
    }

    #[test]
    fn try_to_get_balance_using_ws() {
        let mut binding = Command::new("cargo");

        let command = binding
            .arg("run")
            .arg("--")
            .arg("web-socket")
            .arg("balance")
            // Use invalid argument (use "addres" instead of "address")
            .arg("--addres")
            .arg("0x71C7656EC7ab88b098defB751B7401B5f6d8976F");

        let output = command.output().unwrap();
        assert!(!output.status.success());
    }

    #[test]
    fn get_balance_using_http() {
        let mut binding = Command::new("cargo");

        let command = binding
            .arg("run")
            .arg("--")
            .arg("http")
            .arg("balance")
            .arg("--address")
            .arg("0x71C7656EC7ab88b098defB751B7401B5f6d8976F");

        let output = command.output().unwrap();
        assert!(output.status.success());
    }

    #[test]
    fn try_to_get_balance_using_http() {
        let mut binding = Command::new("cargo");

        let command = binding
            .arg("run")
            .arg("--")
            .arg("http")
            .arg("balance")
            // Use invalid argument (use "addres" instead of "address")
            .arg("--addres")
            .arg("0x71C7656EC7ab88b098defB751B7401B5f6d8976F");

        let output = command.output().unwrap();
        assert!(!output.status.success());
    }

    #[test]
    fn get_block_number_using_ws() {
        let mut binding = Command::new("cargo");

        let command = binding
            .arg("run")
            .arg("--")
            .arg("web-socket")
            .arg("block-number");

        let output = command.output().unwrap();
        assert!(output.status.success());
    }

    #[test]
    fn try_to_get_block_number_using_ws() {
        let mut binding = Command::new("cargo");

        let command = binding
            .arg("run")
            .arg("--")
            .arg("web-socket")
            // Use invalid argument (use "block-numbe" instead of "block-number")
            .arg("block-numbe");

        let output = command.output().unwrap();
        assert!(!output.status.success());
    }

    #[test]
    fn get_block_number_using_http() {
        let mut binding = Command::new("cargo");

        let command = binding.arg("run").arg("--").arg("http").arg("block-number");

        let output = command.output().unwrap();
        assert!(output.status.success());
    }

    #[test]
    fn try_to_get_block_number_using_http() {
        let mut binding = Command::new("cargo");

        let command = binding
            .arg("run")
            .arg("--")
            .arg("http")
            // Use invalid argument (use "block-numbe" instead of "block-number")
            .arg("block-numbe");

        let output = command.output().unwrap();
        assert!(!output.status.success());
    }
}

'''
'''--- src/ethereum.rs ---
pub mod ethereum {
    use std::convert::TryInto;
    use std::fmt::Display;
    use std::str::FromStr;

    use web3::{
        types::{H160, U256},
        Error, Transport, Web3,
    };

    use num_format::{Locale, ToFormattedString};

    pub const ETH_HTTP_URL: &str = "https://mainnet.infura.io/v3/";
    pub const ETH_WS_URL: &str = "wss://mainnet.infura.io/ws/v3/";

    pub async fn get_eth_balance<T: Transport>(
        transport: &Web3<T>,
        account_address: &str,
    ) -> Result<String, Error> {
        let account = H160::from_str(account_address);
        if account.is_err() {
            return Err(Error::InvalidResponse(
                "Invalid account address".to_string(),
            ));
        }
        let account = account.unwrap();

        let balance = transport.eth().balance(account, None).await;
        match balance {
            Ok(balance) => {
                let converted_balance = wei_to_eth(balance);
                println!("Balance: {} [ETH]", format_unit_integer(converted_balance));
                Ok(format_unit_integer(converted_balance))
            }
            Err(e) => Err(e),
        }
    }

    pub async fn get_eth_blocknumber<T: Transport>(transport: &Web3<T>) -> Result<String, Error> {
        let block_number = transport.eth().block_number().await;
        match block_number {
            Ok(block_number) => {
                let block_number_formatted = format_unit_integer(block_number);
                Ok(block_number_formatted)
            }
            Err(e) => Err(e),
        }
    }

    pub async fn get_eth_gasprice<T: Transport>(transport: &Web3<T>) -> Result<String, Error> {
        let gas_price = transport.eth().gas_price().await;
        match gas_price {
            Ok(gas_price) => {
                let gas_price_formatted = format_unit_integer(gas_price);
                Ok(gas_price_formatted)
            }
            Err(e) => Err(e),
        }
    }

    // Helper functions
    fn wei_to_eth(wei: U256) -> U256 {
        let wei_conv: U256 = U256::exp10(18);
        wei.checked_div(wei_conv).unwrap()
    }
    #[allow(dead_code)]
    fn wei_to_gwei(wei: U256) -> U256 {
        let wei_conv: U256 = U256::exp10(9);
        wei.checked_div(wei_conv).unwrap()
    }
    fn format_unit_integer<T: TryInto<u64> + Display + Copy>(integer: T) -> String {
        match integer.try_into() {
            Ok(n) => n.to_formatted_string(&Locale::es_AR),
            Err(_) => format!("Conversion to u64 failed for input: {}", integer),
        }
    }
}

'''
'''--- src/infura.rs ---
pub mod infura {
    use web3::{
        transports::{Http, WebSocket},
        Error, Transport, Web3,
    };

    pub struct TransportBuilder<T: Transport> {
        transport: T,
    }

    impl<T: Transport> TransportBuilder<T> {
        pub fn new(transport: T) -> Self {
            TransportBuilder { transport }
        }

        pub fn build(self) -> Web3<T> {
            Web3::new(self.transport)
        }
    }

    pub struct WebSocketBuilder {
        url: String,
    }

    impl WebSocketBuilder {
        pub fn new(url: String) -> Self {
            WebSocketBuilder { url }
        }

        pub async fn build(self) -> Result<Web3<WebSocket>, Error> {
            let transport = WebSocket::new(&self.url).await;
            match transport {
                Ok(transport) => Ok(TransportBuilder::new(transport).build()),
                Err(e) => Err(e),
            }
        }
    }

    pub struct HttpBuilder {
        url: String,
    }

    impl HttpBuilder {
        pub fn new(url: String) -> Self {
            HttpBuilder { url }
        }

        pub fn build(self) -> Result<Web3<Http>, Error> {
            let transport = Http::new(&self.url);
            match transport {
                Ok(transport) => Ok(TransportBuilder::new(transport).build()),
                Err(e) => Err(e),
            }
        }
    }
}

'''
'''--- src/main.rs ---
#[path = "cli/cli.rs"]
mod cli;
mod ethereum;
mod infura;
mod tests;
use crate::cli::cli::run_cli;

use std::env;

#[tokio::main]
async fn main() -> web3::Result<()> {
    dotenv::dotenv().ok();
    let api_key = &env::var("INFURA_API_KEY").unwrap();

    run_cli(api_key).await;

    Ok(())
}

'''
'''--- src/tests.rs ---
#[cfg(test)]
mod tests {
    use web3::error::TransportError;
    use web3::Error;

    use crate::ethereum::ethereum::{
        get_eth_balance, get_eth_blocknumber, get_eth_gasprice, ETH_HTTP_URL, ETH_WS_URL,
    };
    use crate::infura::infura::{HttpBuilder, WebSocketBuilder};
    use std::env;

    #[tokio::test]
    async fn get_ethereum_balance() {
        let address = "0x71C7656EC7ab88b098defB751B7401B5f6d8976F";

        dotenv::dotenv().ok();
        let api_key = &env::var("INFURA_API_KEY").unwrap();
        let http_url = format!("{}{}", ETH_HTTP_URL, api_key);
        let web3s = HttpBuilder::new(http_url).build().unwrap();
        let eth_balance = get_eth_balance(&web3s, &address).await.unwrap();

        // The current balance of the address (at the time of writing this test) is 33 ETH
        assert_eq!(eth_balance, "34");
    }

    #[tokio::test]
    async fn try_to_get_ethereum_balance_with_invalid_address_with_http() {
        let address = "invalid address";

        dotenv::dotenv().ok();
        let api_key = &env::var("INFURA_API_KEY").unwrap();
        let http_url = format!("{}{}", ETH_HTTP_URL, api_key);
        let web3s = HttpBuilder::new(http_url).build().unwrap();

        let eth_balance = get_eth_balance(&web3s, &address).await.unwrap_err();
        let expected_error_message: String = "Invalid account address".to_string();

        match eth_balance {
            Error::InvalidResponse(error) => {
                assert_eq!(error, expected_error_message);
            }
            _ => unreachable!(),
        }
    }

    #[tokio::test]
    async fn try_to_get_ethereum_balance_with_invalid_address_with_wss() {
        let address = "invalid address";

        dotenv::dotenv().ok();
        let api_key = &env::var("INFURA_API_KEY").unwrap();
        let ws_url = format!("{}{}", ETH_WS_URL, api_key);
        let web3s = WebSocketBuilder::new(ws_url).build().await.unwrap();

        let eth_balance = get_eth_balance(&web3s, &address).await.unwrap_err();
        let expected_error_message: String = "Invalid account address".to_string();

        match eth_balance {
            Error::InvalidResponse(error) => {
                assert_eq!(error, expected_error_message);
            }
            _ => unreachable!(),
        }
    }

    #[tokio::test]
    async fn get_ethereum_block_number() {
        dotenv::dotenv().ok();
        let api_key = &env::var("INFURA_API_KEY").unwrap();
        let http_url = format!("{}{}", ETH_HTTP_URL, api_key);
        let web3s = HttpBuilder::new(http_url).build().unwrap();

        let block_number = get_eth_blocknumber(&web3s).await.unwrap();
        // The current block number (at the time of writing this test) is 16.734.004
        let block_number = block_number.replace(".", "");
        assert!(block_number.parse::<u64>().unwrap() > 16_000_000);
    }

    #[tokio::test]
    async fn get_ethereum_gas_price() {
        dotenv::dotenv().ok();
        let api_key = &env::var("INFURA_API_KEY").unwrap();
        let http_url = format!("{}{}", ETH_HTTP_URL, api_key);
        let web3s = HttpBuilder::new(http_url).build().unwrap();

        let gas_price = get_eth_gasprice(&web3s).await.unwrap();

        // The current gas price (at the time of writing this test) is 24.937.932.747
        let gas_price = gas_price.replace(".", "");
        assert!(gas_price.parse::<u64>().unwrap() > 24_000_000_000);
    }

    #[tokio::test]
    async fn try_to_build_connection_with_invalid_http_url() {
        let invalid_http_url = "https://mainnet.infura.io/v3/invalid".to_string();
        let web3s = HttpBuilder::new(invalid_http_url).build().unwrap();

        let gas_price = get_eth_gasprice(&web3s).await.unwrap_err();
        let transport_error_expected_code = TransportError::Code(401);

        match gas_price {
            Error::Transport(transport_error) => {
                assert_eq!(transport_error_expected_code, transport_error);
            }
            _ => unreachable!(),
        }
    }

    #[tokio::test]
    async fn try_to_build_connection_with_invalid_ws_url() {
        let invalid_ws_url = "wss://mainnet.infura.io/ws/v3/invalid".to_string();
        let web3s = WebSocketBuilder::new(invalid_ws_url)
            .build()
            .await
            .unwrap_err();

        let transport_error_expected_code = TransportError::Code(401);
        match web3s {
            Error::Transport(transport_error) => {
                assert_eq!(transport_error, transport_error_expected_code);
            }
            _ => unreachable!(),
        }
    }
}

// Why do you believe that you have the skills and experience required for this role?✱

'''