*GitHub Repository "near-cli-rs/interactive-clap"*

'''--- .github/workflows/release-plz.yml ---
name: Release-plz

permissions:
  pull-requests: write
  contents: write

on:
  push:
    branches:
      - master

jobs:
  release-plz:
    name: Release-plz
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.CUSTOM_GITHUB_TOKEN }}
      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
      - name: Run release-plz
        uses: MarcoIeni/release-plz-action@v0.5
        env:
          # https://marcoieni.github.io/release-plz/github-action.html#triggering-further-workflow-runs
          GITHUB_TOKEN: ${{ secrets.CUSTOM_GITHUB_TOKEN }}
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

'''
'''--- CHANGELOG.md ---
# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.2.10](https://github.com/near-cli-rs/interactive-clap/compare/interactive-clap-v0.2.9...interactive-clap-v0.2.10) - 2024-04-21

### Added
- Add support for "subargs" ([#17](https://github.com/near-cli-rs/interactive-clap/pull/17))

## [0.2.9](https://github.com/near-cli-rs/interactive-clap/compare/interactive-clap-v0.2.8...interactive-clap-v0.2.9) - 2024-03-25

### Added
- Added support for "#[interactive_clap(flatten)]" ([#15](https://github.com/near-cli-rs/interactive-clap/pull/15))

## [0.2.8](https://github.com/near-cli-rs/interactive-clap/compare/interactive-clap-v0.2.7...interactive-clap-v0.2.8) - 2024-01-15

### Added
- Added possibility to process optional fields ([#13](https://github.com/near-cli-rs/interactive-clap/pull/13))

## [0.2.7](https://github.com/near-cli-rs/interactive-clap/compare/interactive-clap-v0.2.6...interactive-clap-v0.2.7) - 2023-10-13

### Other
- updated the following local packages: interactive-clap-derive

## [0.2.6](https://github.com/near-cli-rs/interactive-clap/compare/interactive-clap-v0.2.5...interactive-clap-v0.2.6) - 2023-10-05

### Fixed
- named_args/unnamed_args/args_without_attrs conflict ([#9](https://github.com/near-cli-rs/interactive-clap/pull/9))

## [0.2.5](https://github.com/near-cli-rs/interactive-clap/compare/interactive-clap-v0.2.4...interactive-clap-v0.2.5) - 2023-09-21

### Other
- added fn try_parse_from()
- Merge branch 'master' of https://github.com/FroVolod/interactive-clap

## [0.2.4](https://github.com/near-cli-rs/interactive-clap/compare/interactive-clap-v0.2.3...interactive-clap-v0.2.4) - 2023-06-02

### Added
- Add support for boolean flags (e.g. --offline) ([#6](https://github.com/near-cli-rs/interactive-clap/pull/6))

## [0.2.3](https://github.com/near-cli-rs/interactive-clap/compare/interactive-clap-v0.2.2...interactive-clap-v0.2.3) - 2023-05-30

### Other
- Added README

'''
'''--- Cargo.toml ---
[workspace]
members = [
    "interactive-clap-derive",
]

[package]
name = "interactive-clap"
version = "0.2.10"
authors = ["FroVolod <frol_off@meta.ua>"]
edition = "2018"
license = "MIT OR Apache-2.0"
repository = "https://github.com/FroVolod/interactive-clap"
description = "Interactive mode extension crate to Command Line Arguments Parser (https://crates.io/crates/clap)"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
interactive-clap-derive = { path = "interactive-clap-derive", version = "0.2.10" }
strum = { version = "0.24", features = ["derive"] }
strum_macros = "0.24"

[dev-dependencies]
shell-words = "1.0.0"

clap = { version = "4.0.18", features = ["derive"] }

inquire = "0.6"
color-eyre = "0.6"

'''
'''--- README.md ---
# Interactive clap

> **`interactive-clap` is a Rust crate of helpers for [`clap`](https://github.com/clap-rs/clap) that enable interactive prompts for structs.**

[![Crates.io](https://img.shields.io/crates/v/interactive-clap?style=flat-square)](https://crates.io/crates/interactive-clap)
[![Crates.io](https://img.shields.io/crates/d/interactive-clap?style=flat-square)](https://crates.io/crates/interactive-clap)
[![License](https://img.shields.io/badge/license-Apache%202.0-blue?style=flat-square)](LICENSE-APACHE)
[![License](https://img.shields.io/badge/license-MIT-blue?style=flat-square)](LICENSE-MIT)
[![Contributors](https://img.shields.io/github/contributors/near-cli-rs/interactive-clap?style=flat-square)](https://github.com/near-cli-rs/interactive-clap/graphs/contributors)

See examples in the [`examples/`](https://github.com/near-cli-rs/interactive-clap/tree/master/examples) folder.

See it in action in [`near-cli-rs`](https://near.cli.rs) and [`bos-cli-rs`](https://bos.cli.rs).

'''
'''--- examples/advanced_enum.rs ---
//This example shows how to parse data from the command line to an enum using the "interactive-clap" macro.

// 1) build an example: cargo build --example advanced_enum
// 2) go to the `examples` folder: cd target/debug/examples
// 3) run an example: ./advanced_enum (without parameters) => entered interactive mode
//                    ./advanced_enum network 23 QWE ASDFG => mode: Network(CliArgs { age: Some(23), first_name: Some("QWE"), second_name: Some("ASDFG") })
//                    ./advanced_enum offline              => mode: Offline
// To learn more about the parameters, use "help" flag: ./advanced_enum --help

use interactive_clap::{ResultFromCli, ToCliArgs};
use strum::{EnumDiscriminants, EnumIter, EnumMessage};

#[derive(Debug, EnumDiscriminants, Clone, interactive_clap::InteractiveClap)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///To construct a transaction you will need to provide information about sender (signer) and receiver accounts, and actions that needs to be performed.
///Do you want to derive some information required for transaction construction automatically querying it online?
pub enum Mode {
    /// Prepare and, optionally, submit a new transaction with online mode
    #[strum_discriminants(strum(message = "Yes, I keep it simple"))]
    Network(Args),
    /// Prepare and, optionally, submit a new transaction with offline mode
    #[strum_discriminants(strum(
        message = "No, I want to work in no-network (air-gapped) environment"
    ))]
    Offline,
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
pub struct Args {
    age: u64,
    first_name: String,
    second_name: String,
}

fn main() -> color_eyre::Result<()> {
    let cli_mode = Mode::try_parse().ok();
    let context = (); // default: input_context = ()
    let mode = loop {
        let mode = <Mode as interactive_clap::FromCli>::from_cli(cli_mode.clone(), context);
        match mode {
            ResultFromCli::Ok(cli_mode) => break cli_mode,
            ResultFromCli::Cancel(Some(cli_mode)) => {
                println!(
                    "Your console command:  {}",
                    shell_words::join(&cli_mode.to_cli_args())
                );
                return Ok(());
            }
            ResultFromCli::Cancel(None) => {
                println!("Goodbye!");
                return Ok(());
            }
            ResultFromCli::Back => {}
            ResultFromCli::Err(optional_cli_mode, err) => {
                if let Some(cli_mode) = optional_cli_mode {
                    println!(
                        "Your console command:  {}",
                        shell_words::join(&cli_mode.to_cli_args())
                    );
                }
                return Err(err);
            }
        }
    };
    println!("mode: {:?}", mode);
    println!(
        "Your console command:  {}",
        shell_words::join(&mode.to_cli_args())
    );
    Ok(())
}

'''
'''--- examples/advanced_struct.rs ---
// This example shows additional functionality of the "interactive-clap" macro for parsing command-line data into a structure using macro attributes.

// 1) build an example: cargo build --example advanced_struct
// 2) go to the `examples` folder: cd target/debug/examples
// 3) run an example: ./advanced_struct (without parameters) => entered interactive mode
//                    ./advanced_struct --age-full-years 30 --first-name QWE --second-name QWERTY --favorite-color red =>
//                                    => cli_args: CliArgs { age: Some(30), first_name: Some("QWE"), second_name: Some("QWERTY"), favorite_color: Some(Red) }
//                    ./advanced_struct --first-name QWE --second-name QWERTY --favorite-color red =>
//                                    => cli_args: CliArgs { age: None, first_name: Some("QWE"), second_name: Some("QWERTY"), favorite_color: Some(Red) }
// To learn more about the parameters, use "help" flag: ./advanced_struct --help

use inquire::Select;
use interactive_clap::{ResultFromCli, ToCliArgs};
use strum::{EnumDiscriminants, EnumIter, EnumMessage, IntoEnumIterator};

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
struct Args {
    #[interactive_clap(long = "age-full-years")]
    #[interactive_clap(skip_interactive_input)]
    /// If you want, enter the full age on the command line
    age: Option<u64>,
    #[interactive_clap(long)]
    /// What is your first name?
    first_name: String,
    #[interactive_clap(long)]
    #[interactive_clap(skip_default_input_arg)]
    second_name: String,
    #[interactive_clap(long)]
    #[interactive_clap(value_enum)]
    #[interactive_clap(skip_default_input_arg)]
    favorite_color: ColorPalette,
}

impl Args {
    fn input_second_name(_context: &()) -> color_eyre::eyre::Result<Option<String>> {
        match inquire::Text::new("Input second name".to_string().as_str()).prompt() {
            Ok(value) => Ok(Some(value)),
            Err(
                inquire::error::InquireError::OperationCanceled
                | inquire::error::InquireError::OperationInterrupted,
            ) => Ok(None),
            Err(err) => Err(err.into()),
        }
    }

    fn input_favorite_color(_context: &()) -> color_eyre::eyre::Result<Option<ColorPalette>> {
        let variants = ColorPaletteDiscriminants::iter().collect::<Vec<_>>();
        let selected = Select::new("What color is your favorite?", variants).prompt()?;
        match selected {
            ColorPaletteDiscriminants::Red => Ok(Some(ColorPalette::Red)),
            ColorPaletteDiscriminants::Orange => Ok(Some(ColorPalette::Orange)),
            ColorPaletteDiscriminants::Yellow => Ok(Some(ColorPalette::Yellow)),
            ColorPaletteDiscriminants::Green => Ok(Some(ColorPalette::Green)),
            ColorPaletteDiscriminants::Blue => Ok(Some(ColorPalette::Blue)),
            ColorPaletteDiscriminants::Indigo => Ok(Some(ColorPalette::Indigo)),
            ColorPaletteDiscriminants::Violet => Ok(Some(ColorPalette::Violet)),
        }
    }
}

#[derive(Debug, EnumDiscriminants, Clone, clap::ValueEnum)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
pub enum ColorPalette {
    #[strum_discriminants(strum(message = "red"))]
    /// Red
    Red,
    #[strum_discriminants(strum(message = "orange"))]
    /// Orange
    Orange,
    #[strum_discriminants(strum(message = "yellow"))]
    /// Yellow
    Yellow,
    #[strum_discriminants(strum(message = "green"))]
    /// Green
    Green,
    #[strum_discriminants(strum(message = "blue"))]
    /// Blue
    Blue,
    #[strum_discriminants(strum(message = "indigo"))]
    /// Indigo
    Indigo,
    #[strum_discriminants(strum(message = "violet"))]
    /// Violet
    Violet,
}

impl interactive_clap::ToCli for ColorPalette {
    type CliVariant = ColorPalette;
}

impl std::str::FromStr for ColorPalette {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "red" => Ok(Self::Red),
            "orange" => Ok(Self::Orange),
            "yellow" => Ok(Self::Yellow),
            "green" => Ok(Self::Green),
            "blue" => Ok(Self::Blue),
            "indigo" => Ok(Self::Indigo),
            "violet" => Ok(Self::Violet),
            _ => Err("ColorPalette: incorrect value entered".to_string()),
        }
    }
}

impl std::fmt::Display for ColorPalette {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            Self::Red => write!(f, "red"),
            Self::Orange => write!(f, "orange"),
            Self::Yellow => write!(f, "yellow"),
            Self::Green => write!(f, "green"),
            Self::Blue => write!(f, "blue"),
            Self::Indigo => write!(f, "indigo"),
            Self::Violet => write!(f, "violet"),
        }
    }
}

impl std::fmt::Display for ColorPaletteDiscriminants {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            Self::Red => write!(f, "red"),
            Self::Orange => write!(f, "orange"),
            Self::Yellow => write!(f, "yellow"),
            Self::Green => write!(f, "green"),
            Self::Blue => write!(f, "blue"),
            Self::Indigo => write!(f, "indigo"),
            Self::Violet => write!(f, "violet"),
        }
    }
}

fn main() -> color_eyre::Result<()> {
    let mut cli_args = Args::parse();
    let context = (); // default: input_context = ()
    loop {
        let args = <Args as interactive_clap::FromCli>::from_cli(Some(cli_args), context);
        match args {
            ResultFromCli::Ok(cli_args) | ResultFromCli::Cancel(Some(cli_args)) => {
                println!("cli_args: {cli_args:?}");
                println!(
                    "Your console command:  {}",
                    shell_words::join(&cli_args.to_cli_args())
                );
                return Ok(());
            }
            ResultFromCli::Cancel(None) => {
                println!("Goodbye!");
                return Ok(());
            }
            ResultFromCli::Back => {
                cli_args = Default::default();
            }
            ResultFromCli::Err(cli_args, err) => {
                if let Some(cli_args) = cli_args {
                    println!(
                        "Your console command:  {}",
                        shell_words::join(&cli_args.to_cli_args())
                    );
                }
                return Err(err);
            }
        }
    }
}

'''
'''--- examples/simple_enum.rs ---
#![allow(dead_code)]
//This example shows how to parse data from the command line to an enum using the "interactive-clap" macro.

// 1) build an example: cargo build --example simple_enum
// 2) go to the `examples` folder: cd target/debug/examples
// 3) run an example: ./simple_enum (without parameters) => entered interactive mode
//                    ./simple_enum network              => mode: Ok(Network)
//                    ./simple_enum offline              => mode: Ok(Offline)
// To learn more about the parameters, use "help" flag: ./simple_enum --help

use interactive_clap::{ResultFromCli, ToCliArgs};
use strum::{EnumDiscriminants, EnumIter, EnumMessage};

#[derive(Debug, EnumDiscriminants, Clone, interactive_clap::InteractiveClap)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///To construct a transaction you will need to provide information about sender (signer) and receiver accounts, and actions that needs to be performed.
///Do you want to derive some information required for transaction construction automatically querying it online?
pub enum Mode {
    /// Prepare and, optionally, submit a new transaction with online mode
    #[strum_discriminants(strum(message = "Yes, I keep it simple"))]
    Network,
    /// Prepare and, optionally, submit a new transaction with offline mode
    #[strum_discriminants(strum(
        message = "No, I want to work in no-network (air-gapped) environment"
    ))]
    Offline,
}

fn main() -> color_eyre::Result<()> {
    let cli_mode = Mode::try_parse().ok();
    let context = (); // default: input_context = ()
    loop {
        let mode = <Mode as interactive_clap::FromCli>::from_cli(cli_mode.clone(), context);
        match mode {
            ResultFromCli::Ok(cli_mode) | ResultFromCli::Cancel(Some(cli_mode)) => {
                println!(
                    "Your console command:  {}",
                    shell_words::join(&cli_mode.to_cli_args())
                );
                return Ok(());
            }
            ResultFromCli::Cancel(None) => {
                println!("Goodbye!");
                return Ok(());
            }
            ResultFromCli::Back => {}
            ResultFromCli::Err(optional_cli_mode, err) => {
                if let Some(cli_mode) = optional_cli_mode {
                    println!(
                        "Your console command:  {}",
                        shell_words::join(&cli_mode.to_cli_args())
                    );
                }
                return Err(err);
            }
        }
    }
}

'''
'''--- examples/simple_struct.rs ---
// This example shows how to parse data from the command line to a structure using the "interactive-clap" macro.

// 1) build an example: cargo build --example simple_struct
// 2) go to the `examples` folder: cd target/debug/examples
// 3) run an example: ./simple_struct (without parameters) => entered interactive mode
//                    ./simple_struct 30 QWE QWERTY => args: Ok(Args { age: 30, first_name: "QWE", second_name: "QWERTY" })
// To learn more about the parameters, use "help" flag: ./simple_struct --help

use interactive_clap::{ResultFromCli, ToCliArgs};

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
pub struct Args {
    age: u64,
    first_name: String,
    second_name: String,
}

fn main() -> color_eyre::Result<()> {
    let mut cli_args = Args::parse();
    let context = (); // default: input_context = ()
    loop {
        let args = <Args as interactive_clap::FromCli>::from_cli(Some(cli_args), context);
        match args {
            ResultFromCli::Ok(cli_args) | ResultFromCli::Cancel(Some(cli_args)) => {
                println!(
                    "Your console command:  {}",
                    shell_words::join(&cli_args.to_cli_args())
                );
                return Ok(());
            }
            ResultFromCli::Cancel(None) => {
                println!("Goodbye!");
                return Ok(());
            }
            ResultFromCli::Back => {
                cli_args = Default::default();
            }
            ResultFromCli::Err(cli_args, err) => {
                if let Some(cli_args) = cli_args {
                    println!(
                        "Your console command:  {}",
                        shell_words::join(&cli_args.to_cli_args())
                    );
                }
                return Err(err);
            }
        }
    }
}

'''
'''--- examples/struct_with_context.rs ---
// This example shows additional functionality of the "interactive-clap" macro for parsing command line data into a structure using the context attributes of the macro.

// 1) build an example: cargo build --example struct_with_context
// 2) go to the `examples` folder: cd target/debug/examples
// 3) run an example: ./struct_with_context (without parameters) => entered interactive mode
//                    ./struct_with_context account QWERTY => offline_args: Ok(OfflineArgs { account: Sender { sender_account_id: "QWERTY" } })
// To learn more about the parameters, use "help" flag: ./struct_with_context --help

use interactive_clap::{ResultFromCli, ToCliArgs};

mod simple_enum;

#[derive(Debug, Clone)]
pub enum ConnectionConfig {
    Testnet,
    Mainnet,
    Betanet,
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(input_context = ())]
#[interactive_clap(output_context = OfflineArgsContext)]
pub struct OfflineArgs {
    #[interactive_clap(named_arg)]
    ///Specify a sender
    sender: Sender,
}

#[derive(Debug)]
pub struct OfflineArgsContext {
    pub some_context_field: i64,
}

impl OfflineArgsContext {
    fn from_previous_context(
        _previous_context: (),
        _scope: &<OfflineArgs as interactive_clap::ToInteractiveClapContextScope>::InteractiveClapContextScope,
    ) -> color_eyre::eyre::Result<Self> {
        Ok(Self {
            some_context_field: 42,
        })
    }
}

impl From<OfflineArgsContext> for NetworkContext {
    fn from(_: OfflineArgsContext) -> Self {
        Self {
            connection_config: None,
        }
    }
}

impl From<()> for NetworkContext {
    fn from(_: ()) -> Self {
        Self {
            connection_config: None,
        }
    }
}

impl From<NetworkContext> for () {
    fn from(_: NetworkContext) -> Self {
        ()
    }
}

#[derive(Debug)]
pub struct NetworkContext {
    pub connection_config: Option<ConnectionConfig>,
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = NetworkContext)]
pub struct Sender {
    #[interactive_clap(skip_default_input_arg)]
    sender_account_id: String,
    #[interactive_clap(subcommand)]
    network: simple_enum::Mode,
}

impl Sender {
    fn input_sender_account_id(
        context: &NetworkContext,
    ) -> color_eyre::eyre::Result<Option<String>> {
        println!("Let's use context: {:?}", context);
        match inquire::CustomType::new("What is the account ID?").prompt() {
            Ok(value) => Ok(Some(value)),
            Err(
                inquire::error::InquireError::OperationCanceled
                | inquire::error::InquireError::OperationInterrupted,
            ) => Ok(None),
            Err(err) => Err(err.into()),
        }
    }
}

fn main() -> color_eyre::Result<()> {
    let mut cli_offline_args = OfflineArgs::parse();
    let context = (); // #[interactive_clap(input_context = ())]
    loop {
        let offline_args = <OfflineArgs as interactive_clap::FromCli>::from_cli(
            Some(cli_offline_args.clone()),
            context,
        );
        match offline_args {
            ResultFromCli::Ok(cli_offline_args) | ResultFromCli::Cancel(Some(cli_offline_args)) => {
                println!(
                    "Your console command:  {}",
                    shell_words::join(&cli_offline_args.to_cli_args())
                );
                return Ok(());
            }
            ResultFromCli::Cancel(None) => {
                println!("Goodbye!");
                return Ok(());
            }
            ResultFromCli::Back => {
                cli_offline_args = Default::default();
            }
            ResultFromCli::Err(cli_offline_args, err) => {
                if let Some(cli_offline_args) = cli_offline_args {
                    println!(
                        "Your console command:  {}",
                        shell_words::join(&cli_offline_args.to_cli_args())
                    );
                }
                return Err(err);
            }
        }
    }
}

'''
'''--- examples/struct_with_flatten.rs ---
// This example shows additional functionality of the "interactive-clap" macro for parsing command-line data into a structure using the macro's flatten attributes.

// 1) build an example: cargo build --example struct_with_flatten
// 2) go to the `examples` folder: cd target/debug/examples
// 3) run an example: ./struct_with_flatten (without parameters) => entered interactive mode
//                    ./struct_with_flatten --no-docker --no-abi --out-dir /Users/Documents/Rust --color never test.testnet offline => contract: CliContract { build_command_args: Some(CliBuildCommand { no_docker: true, no_release: false, no_abi: true, no_embed_abi: false, no_doc: false, out_dir: Some("/Users/Documents/Rust"), manifest_path: None, color: Some(Never) }), contract_account_id: Some("test.testnet"), mode: Some(Offline) }
// To learn more about the parameters, use "help" flag: ./struct_with_flatten --help

// Note: currently there is no automatic generation of "interactive clap::From Cli"

use interactive_clap::{ResultFromCli, ToCliArgs};

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(input_context = ())]
#[interactive_clap(output_context = ContractContext)]
#[interactive_clap(skip_default_from_cli)]
pub struct Contract {
    #[interactive_clap(flatten)]
    /// Specify a build command args:
    build_command_args: BuildCommand,
    /// What is the contract account ID?
    contract_account_id: String,
    #[interactive_clap(subcommand)]
    pub mode: Mode,
}

#[derive(Debug, Clone)]
pub struct ContractContext;

impl ContractContext {
    pub fn from_previous_context(
        previous_context: (),
        scope: &<Contract as interactive_clap::ToInteractiveClapContextScope>::InteractiveClapContextScope,
    ) -> color_eyre::eyre::Result<Self> {
        // Your commands
        Ok(Self)
    }
}

impl interactive_clap::FromCli for Contract {
    type FromCliContext = ();
    type FromCliError = color_eyre::eyre::Error;
    fn from_cli(
        optional_clap_variant: Option<<Self as interactive_clap::ToCli>::CliVariant>,
        context: Self::FromCliContext,
    ) -> interactive_clap::ResultFromCli<
        <Self as interactive_clap::ToCli>::CliVariant,
        Self::FromCliError,
    >
    where
        Self: Sized + interactive_clap::ToCli,
    {
        let mut clap_variant = optional_clap_variant.unwrap_or_default();

        let build_command_args =
            if let Some(cli_build_command_args) = &clap_variant.build_command_args {
                BuildCommand {
                    no_docker: cli_build_command_args.no_docker,
                    no_release: cli_build_command_args.no_release,
                    no_abi: cli_build_command_args.no_abi,
                    no_embed_abi: cli_build_command_args.no_embed_abi,
                    no_doc: cli_build_command_args.no_doc,
                    out_dir: cli_build_command_args.out_dir.clone(),
                    manifest_path: cli_build_command_args.manifest_path.clone(),
                    color: cli_build_command_args.color.clone(),
                }
            } else {
                BuildCommand::default()
            };

        if clap_variant.contract_account_id.is_none() {
            clap_variant.contract_account_id = match Self::input_contract_account_id(&context) {
                Ok(Some(contract_account_id)) => Some(contract_account_id),
                Ok(None) => return interactive_clap::ResultFromCli::Cancel(Some(clap_variant)),
                Err(err) => return interactive_clap::ResultFromCli::Err(Some(clap_variant), err),
            };
        }
        let contract_account_id = clap_variant
            .contract_account_id
            .clone()
            .expect("Unexpected error");

        let new_context_scope = InteractiveClapContextScopeForContract {
            build_command_args,
            contract_account_id,
        };

        let output_context =
            match ContractContext::from_previous_context(context, &new_context_scope) {
                Ok(new_context) => new_context,
                Err(err) => return interactive_clap::ResultFromCli::Err(Some(clap_variant), err),
            };

        match <Mode as interactive_clap::FromCli>::from_cli(
            clap_variant.mode.take(),
            context.into(),
        ) {
            interactive_clap::ResultFromCli::Ok(cli_field) => {
                clap_variant.mode = Some(cli_field);
            }
            interactive_clap::ResultFromCli::Cancel(option_cli_field) => {
                clap_variant.mode = option_cli_field;
                return interactive_clap::ResultFromCli::Cancel(Some(clap_variant));
            }
            interactive_clap::ResultFromCli::Cancel(option_cli_field) => {
                clap_variant.mode = option_cli_field;
                return interactive_clap::ResultFromCli::Cancel(Some(clap_variant));
            }
            interactive_clap::ResultFromCli::Back => {
                return interactive_clap::ResultFromCli::Back;
            }
            interactive_clap::ResultFromCli::Err(option_cli_field, err) => {
                clap_variant.mode = option_cli_field;
                return interactive_clap::ResultFromCli::Err(Some(clap_variant), err);
            }
        };
        interactive_clap::ResultFromCli::Ok(clap_variant)
    }
}

#[derive(Debug, Default, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(input_context = ())]
#[interactive_clap(output_context = BuildCommandlContext)]
pub struct BuildCommand {
    /// Build contract without SourceScan verification
    #[interactive_clap(long)]
    pub no_docker: bool,
    /// Build contract in debug mode, without optimizations and bigger is size
    #[interactive_clap(long)]
    pub no_release: bool,
    /// Do not generate ABI for the contract
    #[interactive_clap(long)]
    pub no_abi: bool,
    /// Do not embed the ABI in the contract binary
    #[interactive_clap(long)]
    pub no_embed_abi: bool,
    /// Do not include rustdocs in the embedded ABI
    #[interactive_clap(long)]
    pub no_doc: bool,
    /// Copy final artifacts to this directory
    #[interactive_clap(long)]
    #[interactive_clap(skip_interactive_input)]
    pub out_dir: Option<String>,
    /// Path to the `Cargo.toml` of the contract to build
    #[interactive_clap(long)]
    #[interactive_clap(skip_interactive_input)]
    pub manifest_path: Option<String>,
    /// Coloring: auto, always, never
    #[interactive_clap(long)]
    #[interactive_clap(value_enum)]
    #[interactive_clap(skip_interactive_input)]
    pub color: Option<ColorPreference>,
}

#[derive(Debug, Clone)]
pub struct BuildCommandlContext {
    build_command_args: BuildCommand,
}

impl BuildCommandlContext {
    pub fn from_previous_context(
        _previous_context: (),
        scope: &<BuildCommand as interactive_clap::ToInteractiveClapContextScope>::InteractiveClapContextScope,
    ) -> color_eyre::eyre::Result<Self> {
        let build_command_args = BuildCommand {
            no_docker: scope.no_docker,
            no_release: scope.no_release,
            no_abi: scope.no_abi,
            no_embed_abi: scope.no_embed_abi,
            no_doc: scope.no_doc,
            out_dir: scope.out_dir.clone(),
            manifest_path: scope.manifest_path.clone(),
            color: scope.color.clone(),
        };
        Ok(Self { build_command_args })
    }
}

use strum::{EnumDiscriminants, EnumIter, EnumMessage};

#[derive(Debug, EnumDiscriminants, Clone, interactive_clap::InteractiveClap)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
///To construct a transaction you will need to provide information about sender (signer) and receiver accounts, and actions that needs to be performed.
///Do you want to derive some information required for transaction construction automatically querying it online?
pub enum Mode {
    /// Prepare and, optionally, submit a new transaction with online mode
    #[strum_discriminants(strum(message = "Yes, I keep it simple"))]
    Network,
    /// Prepare and, optionally, submit a new transaction with offline mode
    #[strum_discriminants(strum(
        message = "No, I want to work in no-network (air-gapped) environment"
    ))]
    Offline,
}

use std::{env, str::FromStr};

#[derive(Debug, EnumDiscriminants, Clone, clap::ValueEnum)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
pub enum ColorPreference {
    Auto,
    Always,
    Never,
}

impl interactive_clap::ToCli for ColorPreference {
    type CliVariant = ColorPreference;
}

impl std::fmt::Display for ColorPreference {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            Self::Auto => write!(f, "auto"),
            Self::Always => write!(f, "always"),
            Self::Never => write!(f, "never"),
        }
    }
}

impl FromStr for ColorPreference {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "auto" => Ok(default_mode()),
            "always" => Ok(ColorPreference::Always),
            "never" => Ok(ColorPreference::Never),
            _ => Err(format!("invalid color preference: {}", s)),
        }
    }
}

fn default_mode() -> ColorPreference {
    ColorPreference::Never
}

impl ColorPreference {
    pub fn as_str(&self) -> &str {
        match self {
            ColorPreference::Auto => "auto",
            ColorPreference::Always => "always",
            ColorPreference::Never => "never",
        }
    }
}

fn main() -> color_eyre::Result<()> {
    let mut cli_contract = Contract::parse();
    let context = (); // default: input_context = ()
    loop {
        let contract =
            <Contract as interactive_clap::FromCli>::from_cli(Some(cli_contract), context);
        match contract {
            ResultFromCli::Ok(cli_contract) | ResultFromCli::Cancel(Some(cli_contract)) => {
                println!("contract: {cli_contract:?}");
                println!(
                    "Your console command:  {}",
                    shell_words::join(&cli_contract.to_cli_args())
                );
                return Ok(());
            }
            ResultFromCli::Cancel(None) => {
                println!("Goodbye!");
                return Ok(());
            }
            ResultFromCli::Back => {
                cli_contract = Default::default();
            }
            ResultFromCli::Err(cli_contract, err) => {
                if let Some(cli_contract) = cli_contract {
                    println!(
                        "Your console command:  {}",
                        shell_words::join(&cli_contract.to_cli_args())
                    );
                }
                return Err(err);
            }
        }
    }
}

'''
'''--- examples/struct_with_named_arg.rs ---
// This example shows additional functionality of the "interactive-clap" macro for parsing command-line data into a structure using the macro's named attributes.
// "named_arg" is a simplified version of the subcommand, consisting of a single enum element.

// 1) build an example: cargo build --example struct_with_named_arg
// 2) go to the `examples` folder: cd target/debug/examples
// 3) run an example: ./struct_with_named_arg (without parameters) => entered interactive mode
//                    ./struct_with_named_arg account QWERTY => account: Ok(Account { account: Sender { sender_account_id: "QWERTY" } })
// To learn more about the parameters, use "help" flag: ./struct_with_named_arg --help

use interactive_clap::{ResultFromCli, ToCliArgs};

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
struct Account {
    #[interactive_clap(named_arg)]
    ///Specify a sender
    account: Sender,
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
pub struct Sender {
    ///What is the sender account ID?
    pub sender_account_id: String,
}

fn main() -> color_eyre::Result<()> {
    let mut cli_account = Account::parse();
    let context = (); // default: input_context = ()
    loop {
        let account = <Account as interactive_clap::FromCli>::from_cli(Some(cli_account), context);
        match account {
            ResultFromCli::Ok(cli_account) | ResultFromCli::Cancel(Some(cli_account)) => {
                println!(
                    "Your console command:  {}",
                    shell_words::join(&cli_account.to_cli_args())
                );
                return Ok(());
            }
            ResultFromCli::Cancel(None) => {
                println!("Goodbye!");
                return Ok(());
            }
            ResultFromCli::Back => {
                cli_account = Default::default();
            }
            ResultFromCli::Err(cli_account, err) => {
                if let Some(cli_account) = cli_account {
                    println!(
                        "Your console command:  {}",
                        shell_words::join(&cli_account.to_cli_args())
                    );
                }
                return Err(err);
            }
        }
    }
}

'''
'''--- examples/struct_with_subargs.rs ---
// This example shows additional functionality of the "interactive-clap" macro for parsing command-line data into a structure using the macro's subargs attributes.

// 1) build an example: cargo build --example struct_with_subargs
// 2) go to the `examples` folder: cd target/debug/examples
// 3) run an example: ./struct_with_subargs (without parameters) => entered interactive mode
//                    ./struct_with_subargs QWERTY 18 => account: CliAccount { social_db_folder: None, account: Some(CliSender { sender_account_id: Some("QWERTY"), age: Some(18) }) }
// To learn more about the parameters, use "help" flag: ./struct_with_subargs --help

use interactive_clap::{ResultFromCli, ToCliArgs};

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
struct Account {
    /// Change SocialDb prefix
    #[interactive_clap(long)]
    #[interactive_clap(skip_interactive_input)]
    social_db_folder: Option<String>,
    #[interactive_clap(subargs)]
    account: Sender,
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
pub struct Sender {
    /// What is the sender account ID?
    sender_account_id: String,
    /// How old is the sender?
    age: u64,
}

fn main() -> color_eyre::Result<()> {
    let mut cli_account = Account::parse();
    let context = (); // default: input_context = ()
    loop {
        let account = <Account as interactive_clap::FromCli>::from_cli(Some(cli_account), context);
        match account {
            ResultFromCli::Ok(cli_account) | ResultFromCli::Cancel(Some(cli_account)) => {
                println!("account: {cli_account:?}");
                println!(
                    "Your console command:  {}",
                    shell_words::join(&cli_account.to_cli_args())
                );
                return Ok(());
            }
            ResultFromCli::Cancel(None) => {
                println!("Goodbye!");
                return Ok(());
            }
            ResultFromCli::Back => {
                cli_account = Default::default();
            }
            ResultFromCli::Err(cli_account, err) => {
                if let Some(cli_account) = cli_account {
                    println!(
                        "Your console command:  {}",
                        shell_words::join(&cli_account.to_cli_args())
                    );
                }
                return Err(err);
            }
        }
    }
}

'''
'''--- examples/struct_with_subcommand.rs ---
// This example shows additional functionality of the "interactive-clap" macro for parsing command line data into a structure using a subcommand in the macro attribute.

// 1) build an example: cargo build --example struct_with_subcommand
// 2) go to the `examples` folder: cd target/debug/examples
// 3) run an example: ./struct_with_subcommand (without parameters) => entered interactive mode
//                    ./struct_with_subcommand network => operation_mode: Ok(OperationMode { mode: Network })
//                    ./struct_with_subcommand offline => operation_mode: Ok(OperationMode { mode: Offline })
// To learn more about the parameters, use "help" flag: ./struct_with_subcommand --help

use interactive_clap::{ResultFromCli, ToCliArgs};

mod simple_enum;

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
pub struct OperationMode {
    #[interactive_clap(subcommand)]
    pub mode: simple_enum::Mode,
}

fn main() -> color_eyre::Result<()> {
    let mut cli_operation_mode = OperationMode::parse();
    let context = (); // default: input_context = ()
    loop {
        let operation_mode = <OperationMode as interactive_clap::FromCli>::from_cli(
            Some(cli_operation_mode),
            context,
        );
        match operation_mode {
            ResultFromCli::Ok(cli_operation_mode)
            | ResultFromCli::Cancel(Some(cli_operation_mode)) => {
                println!(
                    "Your console command:  {}",
                    shell_words::join(&cli_operation_mode.to_cli_args())
                );
                return Ok(());
            }
            ResultFromCli::Cancel(None) => {
                println!("Goodbye!");
                return Ok(());
            }
            ResultFromCli::Back => {
                cli_operation_mode = Default::default();
            }
            ResultFromCli::Err(cli_operation_mode, err) => {
                if let Some(cli_operation_mode) = cli_operation_mode {
                    println!(
                        "Your console command:  {}",
                        shell_words::join(&cli_operation_mode.to_cli_args())
                    );
                }
                return Err(err);
            }
        }
    }
}

'''
'''--- examples/to_cli_args.rs ---
// The "to_cli_args" method of the "interactive-clap" macro is designed to form and print the cli command using the interactive mode for entering parameters.

// 1) build an example: cargo build --example to_cli_args
// 2) go to the `examples` folder: cd target/debug/examples
// 3) run an example: ./to_cli_args (without parameters) => entered interactive mode
//                    ./to_cli_args send    => Your console command:  send
//                    ./to_cli_args display => Your console command:  display
// To learn more about the parameters, use "help" flag: ./to_cli_args --help

use inquire::Select;
use interactive_clap::{ResultFromCli, SelectVariantOrBack, ToCliArgs};
use strum::{EnumDiscriminants, EnumIter, EnumMessage, IntoEnumIterator};

#[derive(Debug, Clone)]
pub enum ConnectionConfig {
    Testnet,
    Mainnet,
    Betanet,
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap)]
#[interactive_clap(context = ConnectionConfig)]
struct OnlineArgs {
    /// What is the name of the network
    #[interactive_clap(skip_default_input_arg)]
    network_name: String,
    #[interactive_clap(subcommand)]
    submit: Submit,
}

impl OnlineArgs {
    fn input_network_name(_context: &ConnectionConfig) -> color_eyre::eyre::Result<Option<String>> {
        match inquire::Text::new("Input network name").prompt() {
            Ok(value) => Ok(Some(value)),
            Err(
                inquire::error::InquireError::OperationCanceled
                | inquire::error::InquireError::OperationInterrupted,
            ) => Ok(None),
            Err(err) => Err(err.into()),
        }
    }
}

#[derive(Debug, EnumDiscriminants, Clone, clap::Parser)]
#[strum_discriminants(derive(EnumMessage, EnumIter))]
pub enum Submit {
    #[strum_discriminants(strum(message = "I want to send the transaction to the network"))]
    Send(Args),
    #[strum_discriminants(strum(
        message = "I only want to print base64-encoded transaction for JSON RPC input and exit"
    ))]
    Display,
}

#[derive(Debug, EnumDiscriminants, Clone, clap::Parser)]
pub enum CliSubmit {
    Send(CliArgs),
    Display,
}

impl From<Submit> for CliSubmit {
    fn from(command: Submit) -> Self {
        match command {
            Submit::Send(args) => Self::Send(args.into()),
            Submit::Display => Self::Display,
        }
    }
}

impl interactive_clap::FromCli for Submit {
    type FromCliContext = ConnectionConfig;
    type FromCliError = color_eyre::eyre::Error;

    fn from_cli(
        optional_clap_variant: Option<<Self as interactive_clap::ToCli>::CliVariant>,
        context: Self::FromCliContext,
    ) -> ResultFromCli<<Self as interactive_clap::ToCli>::CliVariant, Self::FromCliError>
    where
        Self: Sized + interactive_clap::ToCli,
    {
        match optional_clap_variant {
            Some(submit) => ResultFromCli::Ok(submit),
            None => Self::choose_variant(context),
        }
    }
}

impl interactive_clap::ToCliArgs for CliSubmit {
    fn to_cli_args(&self) -> std::collections::VecDeque<String> {
        match self {
            Self::Send(cli_args) => {
                let mut args = cli_args.to_cli_args();
                args.push_front("send".to_owned());
                args
            }
            Self::Display => {
                let mut args = std::collections::VecDeque::new();
                args.push_front("display".to_owned());
                args
            }
        }
    }
}

impl Submit {
    fn choose_variant(
        context: ConnectionConfig,
    ) -> ResultFromCli<
        <Self as interactive_clap::ToCli>::CliVariant,
        <Self as interactive_clap::FromCli>::FromCliError,
    > {
        match Select::new(
            "How would you like to proceed",
            SubmitDiscriminants::iter()
                .map(SelectVariantOrBack::Variant)
                .chain([SelectVariantOrBack::Back])
                .collect(),
        )
        .prompt()
        {
            Ok(SelectVariantOrBack::Variant(variant)) => ResultFromCli::Ok(match variant {
                SubmitDiscriminants::Send => {
                    let cli_args =
                        match <Args as interactive_clap::FromCli>::from_cli(None, context) {
                            ResultFromCli::Ok(cli_args) => cli_args,
                            ResultFromCli::Cancel(optional_cli_args) => {
                                return ResultFromCli::Cancel(Some(CliSubmit::Send(
                                    optional_cli_args.unwrap_or_default(),
                                )));
                            }
                            ResultFromCli::Back => return ResultFromCli::Back,
                            ResultFromCli::Err(optional_cli_args, err) => {
                                return ResultFromCli::Err(
                                    Some(CliSubmit::Send(optional_cli_args.unwrap_or_default())),
                                    err,
                                );
                            }
                        };
                    CliSubmit::Send(cli_args)
                }
                SubmitDiscriminants::Display => CliSubmit::Display,
            }),
            Ok(SelectVariantOrBack::Back) => ResultFromCli::Back,
            Err(
                inquire::error::InquireError::OperationCanceled
                | inquire::error::InquireError::OperationInterrupted,
            ) => ResultFromCli::Cancel(None),
            Err(err) => ResultFromCli::Err(None, err.into()),
        }
    }
}
impl interactive_clap::ToCli for Submit {
    type CliVariant = CliSubmit;
}

impl std::fmt::Display for SubmitDiscriminants {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            Self::Send => write!(f, "send"),
            Self::Display => write!(f, "display"),
        }
    }
}

#[derive(Debug, Clone, interactive_clap::InteractiveClap, clap::Args)]
#[interactive_clap(context = ConnectionConfig)]
pub struct Args {
    age: u64,
    first_name: String,
    second_name: String,
}

fn main() -> color_eyre::Result<()> {
    let mut cli_online_args = OnlineArgs::parse();
    let context = ConnectionConfig::Testnet; //#[interactive_clap(context = ConnectionConfig)]
    let cli_args = loop {
        match <OnlineArgs as interactive_clap::FromCli>::from_cli(
            Some(cli_online_args),
            context.clone(),
        ) {
            ResultFromCli::Ok(cli_args) => break cli_args,
            ResultFromCli::Cancel(Some(cli_args)) => {
                println!(
                    "Your console command:  {}",
                    shell_words::join(&cli_args.to_cli_args())
                );
                return Ok(());
            }
            ResultFromCli::Cancel(None) => {
                println!("Goodbye!");
                return Ok(());
            }
            ResultFromCli::Back => {
                cli_online_args = Default::default();
            }
            ResultFromCli::Err(cli_args, err) => {
                if let Some(cli_args) = cli_args {
                    println!(
                        "Your console command:  {}",
                        shell_words::join(&cli_args.to_cli_args())
                    );
                }
                return Err(err);
            }
        }
    };
    println!("cli_args: {:?}", cli_args);
    println!(
        "Your console command:  {}",
        shell_words::join(&cli_args.to_cli_args())
    );
    Ok(())
}

'''
'''--- interactive-clap-derive/CHANGELOG.md ---
# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.2.10](https://github.com/near-cli-rs/interactive-clap/compare/interactive-clap-derive-v0.2.9...interactive-clap-derive-v0.2.10) - 2024-04-21

### Added
- Add support for "subargs" ([#17](https://github.com/near-cli-rs/interactive-clap/pull/17))

## [0.2.9](https://github.com/near-cli-rs/interactive-clap/compare/interactive-clap-derive-v0.2.8...interactive-clap-derive-v0.2.9) - 2024-03-25

### Added
- Added support for "#[interactive_clap(flatten)]" ([#15](https://github.com/near-cli-rs/interactive-clap/pull/15))

## [0.2.8](https://github.com/near-cli-rs/interactive-clap/compare/interactive-clap-derive-v0.2.7...interactive-clap-derive-v0.2.8) - 2024-01-15

### Added
- Added possibility to process optional fields ([#13](https://github.com/near-cli-rs/interactive-clap/pull/13))

## [0.2.7](https://github.com/near-cli-rs/interactive-clap/compare/interactive-clap-derive-v0.2.6...interactive-clap-derive-v0.2.7) - 2023-10-13

### Added
- Add support for "flatten" ([#11](https://github.com/near-cli-rs/interactive-clap/pull/11))

## [0.2.6](https://github.com/near-cli-rs/interactive-clap/compare/interactive-clap-derive-v0.2.5...interactive-clap-derive-v0.2.6) - 2023-10-05

### Fixed
- named_args/unnamed_args/args_without_attrs conflict ([#9](https://github.com/near-cli-rs/interactive-clap/pull/9))

## [0.2.5](https://github.com/near-cli-rs/interactive-clap/compare/interactive-clap-derive-v0.2.4...interactive-clap-derive-v0.2.5) - 2023-09-21

### Fixed
- fixed unnamed_args/args_without_attrs conflict

### Other
- added fn try_parse_from()
- Merge branch 'master' of https://github.com/FroVolod/interactive-clap

## [0.2.4](https://github.com/near-cli-rs/interactive-clap/compare/interactive-clap-derive-v0.2.3...interactive-clap-derive-v0.2.4) - 2023-06-02

### Added
- Add support for boolean flags (e.g. --offline) ([#6](https://github.com/near-cli-rs/interactive-clap/pull/6))

## [0.2.3](https://github.com/near-cli-rs/interactive-clap/compare/interactive-clap-derive-v0.2.2...interactive-clap-derive-v0.2.3) - 2023-05-30

### Fixed
- Trim unnecessary spaces in inquire prompts (fix it again after recent refactoring that reverted the previous fix)

'''
'''--- interactive-clap-derive/Cargo.toml ---
[package]
name = "interactive-clap-derive"
version = "0.2.10"
authors = ["FroVolod <frol_off@meta.ua>"]
edition = "2018"
license = "MIT OR Apache-2.0"
repository = "https://github.com/FroVolod/interactive-clap/tree/master/interactive-clap-derive"
description = "Interactive mode extension crate to Command Line Arguments Parser (https://crates.io/crates/clap) (derive macros helper crate)"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
proc-macro = true

[dependencies]
proc-macro2 = "1.0.24"
proc-macro-error = "1"
quote = "1.0"
syn = "1"

[dev-dependencies]
prettyplease = "0.1"
insta = "1"
syn = { version = "1", features = ["full"] }

'''
'''--- interactive-clap-derive/src/derives/interactive_clap/methods/choose_variant.rs ---
extern crate proc_macro;

use proc_macro2::Span;
use proc_macro_error::abort_call_site;
use quote::quote;
use syn;

pub fn fn_choose_variant(
    ast: &syn::DeriveInput,
    variants: &syn::punctuated::Punctuated<syn::Variant, syn::token::Comma>,
) -> proc_macro2::TokenStream {
    let name = &ast.ident;
    let interactive_clap_attrs_context =
        super::interactive_clap_attrs_context::InteractiveClapAttrsContext::new(ast);
    let command_discriminants = syn::Ident::new(&format!("{name}Discriminants"), Span::call_site());
    let cli_command = syn::Ident::new(&format!("Cli{name}"), Span::call_site());

    let mut cli_variant = quote!();
    let mut ast_attrs: Vec<&str> = std::vec::Vec::new();

    if !ast.attrs.is_empty() {
        for attr in ast.attrs.clone() {
            if attr.path.is_ident("interactive_clap") {
                for attr_token in attr.tokens.clone() {
                    if let proc_macro2::TokenTree::Group(group) = attr_token {
                        if group.stream().to_string().contains("disable_back") {
                            ast_attrs.push("disable_back");
                        };
                    }
                }
            };
            if attr.path.is_ident("strum_discriminants") {
                for attr_token in attr.tokens.clone() {
                    if let proc_macro2::TokenTree::Group(group) = attr_token {
                        if &group.stream().to_string() == "derive(EnumMessage, EnumIter)" {
                            ast_attrs.push("strum_discriminants");
                        };
                    }
                }
            };
        }
        if ast_attrs.contains(&"strum_discriminants") {
            let doc_attrs = ast
                .attrs
                .iter()
                .filter(|attr| attr.path.is_ident("doc"))
                .filter_map(|attr| {
                    for attr_token in attr.tokens.clone() {
                        if let proc_macro2::TokenTree::Literal(literal) = attr_token {
                            return Some(literal);
                        }
                    }
                    None
                });

            let enum_variants = variants.iter().map(|variant| {
                let variant_ident = &variant.ident;
                match &variant.fields {
                    syn::Fields::Unnamed(_) => {
                        quote! {
                            #command_discriminants::#variant_ident => {
                                #cli_command::#variant_ident(Default::default())
                            }
                        }
                    }
                    syn::Fields::Unit => {
                        quote! {
                            #command_discriminants::#variant_ident => #cli_command::#variant_ident
                        }
                    }
                    _ => abort_call_site!(
                        "Only option `Fields::Unnamed` or `Fields::Unit` is needed"
                    ),
                }
            });
            let actions_push_back = if ast_attrs.contains(&"disable_back") {
                quote!()
            } else {
                quote! {.chain([SelectVariantOrBack::Back])}
            };

            cli_variant = quote! {
                use interactive_clap::SelectVariantOrBack;
                use inquire::Select;
                use strum::{EnumMessage, IntoEnumIterator};

                let selected_variant = Select::new(
                    concat!(#( #doc_attrs, )*).trim(),
                    #command_discriminants::iter()
                        .map(SelectVariantOrBack::Variant)
                        #actions_push_back
                        .collect(),
                )
                .prompt();
                match selected_variant {
                    Ok(SelectVariantOrBack::Variant(variant)) => {
                        let cli_args = match variant {
                            #( #enum_variants, )*
                        };
                        return interactive_clap::ResultFromCli::Ok(cli_args);
                    },
                    Ok(SelectVariantOrBack::Back) => return interactive_clap::ResultFromCli::Back,
                    Err(
                        inquire::error::InquireError::OperationCanceled
                        | inquire::error::InquireError::OperationInterrupted,
                    ) => return interactive_clap::ResultFromCli::Cancel(None),
                    Err(err) => return interactive_clap::ResultFromCli::Err(None, err.into()),
                }
            };
        }
    };
    let context = interactive_clap_attrs_context.get_input_context_dir();

    quote! {
        pub fn choose_variant(context: #context) -> interactive_clap::ResultFromCli<
        <Self as interactive_clap::ToCli>::CliVariant,
        <Self as interactive_clap::FromCli>::FromCliError,
    > {
        #cli_variant
    }
    }
}

'''
'''--- interactive-clap-derive/src/derives/interactive_clap/methods/cli_field_type.rs ---
extern crate proc_macro;

use proc_macro_error::abort_call_site;
use quote::quote;
use syn;

pub fn cli_field_type(ty: &syn::Type) -> proc_macro2::TokenStream {
    match &ty {
        syn::Type::Path(type_path) => match type_path.path.segments.first() {
            Some(path_segment) => {
                if path_segment.ident == "Option" {
                    match &path_segment.arguments {
                        syn::PathArguments::AngleBracketed(gen_args) => {
                            let ty_option = &gen_args.args;
                            quote! {
                                Option<<#ty_option as interactive_clap::ToCli>::CliVariant>
                            }
                        }
                        _ => {
                            quote! {
                                Option<<#ty as interactive_clap::ToCli>::CliVariant>
                            }
                        }
                    }
                } else if path_segment.ident == "bool" {
                    quote! {
                        bool
                    }
                } else {
                    quote! {
                        Option<<#ty as interactive_clap::ToCli>::CliVariant>
                    }
                }
            }
            _ => abort_call_site!("Only option `PathSegment` is needed"),
        },
        _ => abort_call_site!("Only option `Type::Path` is needed"),
    }
}

'''
'''--- interactive-clap-derive/src/derives/interactive_clap/methods/fields_with_skip_default_input_arg.rs ---
extern crate proc_macro;

use syn;

pub fn is_field_with_skip_default_input_arg(field: &syn::Field) -> bool {
    if field.attrs.is_empty() {
        return false;
    }
    field
        .attrs
        .iter()
        .filter(|attr| attr.path.is_ident("interactive_clap"))
        .flat_map(|attr| attr.tokens.clone())
        .any(|attr_token| {
            attr_token.to_string().contains("skip_default_input_arg")
                || attr_token.to_string().contains("flatten")
                || attr_token.to_string().contains("subargs")
        })
}

'''
'''--- interactive-clap-derive/src/derives/interactive_clap/methods/fields_with_subargs.rs ---
extern crate proc_macro;

use syn;

pub fn is_field_with_subargs(field: &syn::Field) -> bool {
    if field.attrs.is_empty() {
        return false;
    }
    field
        .attrs
        .iter()
        .flat_map(|attr| attr.tokens.clone())
        .any(|attr_token| attr_token.to_string().contains("subargs"))
}

'''
'''--- interactive-clap-derive/src/derives/interactive_clap/methods/fields_with_subcommand.rs ---
extern crate proc_macro;

use syn;

/// This function selects fields with:  subcommand, named_arg
pub fn is_field_with_subcommand(field: &syn::Field) -> bool {
    if field.attrs.is_empty() {
        return false;
    }
    field
        .attrs
        .iter()
        .flat_map(|attr| attr.tokens.clone())
        .any(|attr_token| {
            attr_token.to_string().contains("named_arg")
                || attr_token.to_string().contains("subcommand")
        })
}

'''
'''--- interactive-clap-derive/src/derives/interactive_clap/methods/from_cli_for_enum.rs ---
extern crate proc_macro;

use proc_macro2::Span;
use proc_macro_error::abort_call_site;
use quote::quote;
use syn;

pub fn from_cli_for_enum(
    ast: &syn::DeriveInput,
    variants: &syn::punctuated::Punctuated<syn::Variant, syn::token::Comma>,
) -> proc_macro2::TokenStream {
    let name = &ast.ident;
    let cli_name = syn::Ident::new(&format!("Cli{name}"), Span::call_site());

    let interactive_clap_attrs_context =
        super::interactive_clap_attrs_context::InteractiveClapAttrsContext::new(ast);
    if interactive_clap_attrs_context.is_skip_default_from_cli {
        return quote!();
    };

    let from_cli_variants = variants.iter().map(|variant| {
        let variant_ident = &variant.ident;

        let output_context = match &interactive_clap_attrs_context.output_context_dir {
            Some(output_context_dir) => {
                quote! {
                    type Alias = <#name as interactive_clap::ToInteractiveClapContextScope>::InteractiveClapContextScope;
                    let new_context_scope = Alias::#variant_ident;
                    let output_context = match #output_context_dir::from_previous_context(context.clone(), &new_context_scope) {
                        Ok(new_context) => new_context,
                        Err(err) => return interactive_clap::ResultFromCli::Err(Some(#cli_name::#variant_ident(inner_cli_args)), err),
                    };
                }
            }
            None => {
                quote! {
                    let output_context = context.clone();
                }
            }
        };

        match &variant.fields {
            syn::Fields::Unnamed(fields) => {
                let ty = &fields.unnamed[0].ty;
                quote! {
                    Some(#cli_name::#variant_ident(inner_cli_args)) => {
                        #output_context
                        let cli_inner_args = <#ty as interactive_clap::FromCli>::from_cli(Some(inner_cli_args), output_context.into());
                        match cli_inner_args {
                            interactive_clap::ResultFromCli::Ok(cli_args) => {
                                interactive_clap::ResultFromCli::Ok(#cli_name::#variant_ident(cli_args))
                            }
                            interactive_clap::ResultFromCli::Back => {
                                optional_clap_variant = None;
                                continue;
                            },
                            interactive_clap::ResultFromCli::Cancel(Some(cli_args)) => {
                                interactive_clap::ResultFromCli::Cancel(Some(#cli_name::#variant_ident(cli_args)))
                            }
                            interactive_clap::ResultFromCli::Cancel(None) => {
                                interactive_clap::ResultFromCli::Cancel(None)
                            }
                            interactive_clap::ResultFromCli::Err(Some(cli_args), err) => {
                                interactive_clap::ResultFromCli::Err(Some(#cli_name::#variant_ident(cli_args)), err)
                            }
                            interactive_clap::ResultFromCli::Err(None, err) => {
                                interactive_clap::ResultFromCli::Err(None, err)
                            }
                        }
                    }
                }
            },
            syn::Fields::Unit => {
                match &interactive_clap_attrs_context.output_context_dir {
                    Some(output_context_dir) => quote! {
                        Some(#cli_name::#variant_ident) => {
                            type Alias = <#name as interactive_clap::ToInteractiveClapContextScope>::InteractiveClapContextScope;
                            let new_context_scope = Alias::#variant_ident;
                            let output_context = match #output_context_dir::from_previous_context(context.clone(), &new_context_scope) {
                                Ok(new_context) => new_context,
                                Err(err) => return interactive_clap::ResultFromCli::Err(Some(#cli_name::#variant_ident), err),
                            };
                            interactive_clap::ResultFromCli::Ok(#cli_name::#variant_ident)
                        }
                    },
                    None => quote! {
                        Some(#cli_name::#variant_ident) => {
                            interactive_clap::ResultFromCli::Ok(#cli_name::#variant_ident)
                        },
                    }
                }
            },
            _ => abort_call_site!("Only option `Fields::Unnamed` or `Fields::Unit` is needed")
        }
    });

    let input_context_dir = interactive_clap_attrs_context
        .clone()
        .get_input_context_dir();

    quote! {
        impl interactive_clap::FromCli for #name {
            type FromCliContext = #input_context_dir;
            type FromCliError = color_eyre::eyre::Error;
            fn from_cli(
                mut optional_clap_variant: Option<<Self as interactive_clap::ToCli>::CliVariant>,
                context: Self::FromCliContext,
            ) -> interactive_clap::ResultFromCli<<Self as interactive_clap::ToCli>::CliVariant, Self::FromCliError> where Self: Sized + interactive_clap::ToCli {
                loop {
                    return match optional_clap_variant {
                        #(#from_cli_variants)*
                        None => match Self::choose_variant(context.clone()) {
                            interactive_clap::ResultFromCli::Ok(cli_args) => {
                                optional_clap_variant = Some(cli_args);
                                continue;
                            },
                            result => return result,
                        },
                    }
                }
            }
        }
    }
}

'''
'''--- interactive-clap-derive/src/derives/interactive_clap/methods/from_cli_for_struct.rs ---
extern crate proc_macro;

use proc_macro2::Span;
use proc_macro_error::abort_call_site;
use quote::{quote, ToTokens};
use syn;

pub fn from_cli_for_struct(
    ast: &syn::DeriveInput,
    fields: &syn::Fields,
) -> proc_macro2::TokenStream {
    let name = &ast.ident;

    let interactive_clap_attrs_context =
        super::interactive_clap_attrs_context::InteractiveClapAttrsContext::new(ast);
    if interactive_clap_attrs_context.is_skip_default_from_cli {
        return quote!();
    };

    let fields_without_subcommand_and_subargs = fields
        .iter()
        .filter(|field| {
            !super::fields_with_subcommand::is_field_with_subcommand(field)
                && !super::fields_with_subargs::is_field_with_subargs(field)
        })
        .map(|field| {
            let ident_field = &field.clone().ident.expect("this field does not exist");
            quote! {#ident_field: #ident_field.into()}
        })
        .collect::<Vec<_>>();

    let fields_value = fields
        .iter()
        .map(fields_value)
        .filter(|token_stream| !token_stream.is_empty());

    let field_value_named_arg = fields
        .iter()
        .map(|field| field_value_named_arg(name, field))
        .find(|token_stream| !token_stream.is_empty())
        .unwrap_or(quote!());

    let field_value_subcommand = fields
        .iter()
        .map(field_value_subcommand)
        .find(|token_stream| !token_stream.is_empty())
        .unwrap_or(quote!());

    let field_value_subargs = fields
        .iter()
        .map(field_value_subargs)
        .find(|token_stream| !token_stream.is_empty())
        .unwrap_or(quote!());

    let input_context_dir = interactive_clap_attrs_context
        .clone()
        .get_input_context_dir();

    let interactive_clap_context_scope_for_struct = syn::Ident::new(
        &format!("InteractiveClapContextScopeFor{}", &name),
        Span::call_site(),
    );
    let new_context_scope = quote! {
        let new_context_scope = #interactive_clap_context_scope_for_struct { #(#fields_without_subcommand_and_subargs,)* };
    };

    let output_context = match &interactive_clap_attrs_context.output_context_dir {
        Some(output_context_dir) => {
            quote! {
                let output_context = match #output_context_dir::from_previous_context(context.clone(), &new_context_scope) {
                    Ok(new_context) => new_context,
                    Err(err) => return interactive_clap::ResultFromCli::Err(Some(clap_variant), err),
                };
                let context = output_context;
            }
        }
        None => quote!(),
    };

    quote! {
        impl interactive_clap::FromCli for #name {
            type FromCliContext = #input_context_dir;
            type FromCliError = color_eyre::eyre::Error;
            fn from_cli(
                optional_clap_variant: Option<<Self as interactive_clap::ToCli>::CliVariant>,
                context: Self::FromCliContext,
            ) -> interactive_clap::ResultFromCli<<Self as interactive_clap::ToCli>::CliVariant, Self::FromCliError> where Self: Sized + interactive_clap::ToCli {
                let mut clap_variant = optional_clap_variant.clone().unwrap_or_default();
                #(#fields_value)*
                #new_context_scope
                #output_context
                #field_value_subargs
                #field_value_named_arg
                #field_value_subcommand;
                interactive_clap::ResultFromCli::Ok(clap_variant)
            }
        }
    }
}

fn fields_value(field: &syn::Field) -> proc_macro2::TokenStream {
    let ident_field = &field.clone().ident.expect("this field does not exist");
    let fn_input_arg = syn::Ident::new(&format!("input_{}", &ident_field), Span::call_site());
    if field.ty.to_token_stream().to_string() == "bool"
        || super::skip_interactive_input::is_skip_interactive_input(field)
    {
        quote! {
            let #ident_field = clap_variant.#ident_field.clone();
        }
    } else if field
        .ty
        .to_token_stream()
        .to_string()
        .starts_with("Option <")
    {
        quote! {
            if clap_variant.#ident_field.is_none() {
                clap_variant
                    .#ident_field = match Self::#fn_input_arg(&context) {
                    Ok(optional_field) => optional_field,
                    Err(err) => return interactive_clap::ResultFromCli::Err(Some(clap_variant), err),
                };
            };
            let #ident_field = clap_variant.#ident_field.clone();
        }
    } else if !super::fields_with_subcommand::is_field_with_subcommand(field)
        && !super::fields_with_subargs::is_field_with_subargs(field)
    {
        quote! {
            if clap_variant.#ident_field.is_none() {
                clap_variant
                    .#ident_field = match Self::#fn_input_arg(&context) {
                    Ok(Some(#ident_field)) => Some(#ident_field),
                    Ok(None) => return interactive_clap::ResultFromCli::Cancel(Some(clap_variant)),
                    Err(err) => return interactive_clap::ResultFromCli::Err(Some(clap_variant), err),
                };
            };
            let #ident_field = clap_variant.#ident_field.clone().expect("Unexpected error");
        }
    } else {
        quote!()
    }
}

fn field_value_named_arg(name: &syn::Ident, field: &syn::Field) -> proc_macro2::TokenStream {
    let ident_field = &field.clone().ident.expect("this field does not exist");
    let ty = &field.ty;
    if field.attrs.is_empty() {
        quote!()
    } else {
        field.attrs.iter()
            .filter(|attr| attr.path.is_ident("interactive_clap"))
            .flat_map(|attr| attr.tokens.clone())
            .filter(|attr_token| {
                match attr_token {
                    proc_macro2::TokenTree::Group(group) => group.stream().to_string() == *"named_arg",
                    _ => abort_call_site!("Only option `TokenTree::Group` is needed")
                }
            })
            .map(|_| {
                let type_string = match ty {
                    syn::Type::Path(type_path) => {
                        match type_path.path.segments.last() {
                            Some(path_segment) => path_segment.ident.to_string(),
                            _ => String::new()
                        }
                    },
                    _ => String::new()
                };
                let enum_for_clap_named_arg = syn::Ident::new(&format!("ClapNamedArg{}For{}", &type_string, &name), Span::call_site());
                let variant_name_string = crate::helpers::snake_case_to_camel_case::snake_case_to_camel_case(ident_field.to_string());
                let variant_name = &syn::Ident::new(&variant_name_string, Span::call_site());
                quote! {
                    let optional_field = match clap_variant.#ident_field.take() {
                        Some(#enum_for_clap_named_arg::#variant_name(cli_arg)) => Some(cli_arg),
                        None => None,
                    };
                    match <#ty as interactive_clap::FromCli>::from_cli(
                        optional_field,
                        context.into(),
                    ) {
                        interactive_clap::ResultFromCli::Ok(cli_field) => {
                            clap_variant.#ident_field = Some(#enum_for_clap_named_arg::#variant_name(cli_field));
                        }
                        interactive_clap::ResultFromCli::Cancel(optional_cli_field) => {
                            clap_variant.#ident_field = optional_cli_field.map(#enum_for_clap_named_arg::#variant_name);
                            return interactive_clap::ResultFromCli::Cancel(Some(clap_variant));
                        }
                        interactive_clap::ResultFromCli::Back => return interactive_clap::ResultFromCli::Back,
                        interactive_clap::ResultFromCli::Err(optional_cli_field, err) => {
                            clap_variant.#ident_field = optional_cli_field.map(#enum_for_clap_named_arg::#variant_name);
                            return interactive_clap::ResultFromCli::Err(Some(clap_variant), err);
                        }
                    }
                }
            })
            .next()
            .unwrap_or(quote!())
    }
}

fn field_value_subcommand(field: &syn::Field) -> proc_macro2::TokenStream {
    let ident_field = &field.clone().ident.expect("this field does not exist");
    let ty = &field.ty;
    if field.attrs.is_empty() {
        quote!()
    } else {
        field.attrs.iter()
            .filter(|attr| attr.path.is_ident("interactive_clap"))
            .flat_map(|attr| attr.tokens.clone())
            .filter(|attr_token| {
                match attr_token {
                    proc_macro2::TokenTree::Group(group) => group.stream().to_string().contains("subcommand"),
                    _ => abort_call_site!("Only option `TokenTree::Group` is needed")
                }
            })
            .map(|_| {
                quote! {
                    match <#ty as interactive_clap::FromCli>::from_cli(clap_variant.#ident_field.take(), context.into()) {
                        interactive_clap::ResultFromCli::Ok(cli_field) => {
                            clap_variant.#ident_field = Some(cli_field);
                        }
                        interactive_clap::ResultFromCli::Cancel(option_cli_field) => {
                            clap_variant.#ident_field = option_cli_field;
                            return interactive_clap::ResultFromCli::Cancel(Some(clap_variant));
                        }
                        interactive_clap::ResultFromCli::Cancel(option_cli_field) => {
                            clap_variant.#ident_field = option_cli_field;
                            return interactive_clap::ResultFromCli::Cancel(Some(clap_variant));
                        }
                        interactive_clap::ResultFromCli::Back => return interactive_clap::ResultFromCli::Back,
                        interactive_clap::ResultFromCli::Err(option_cli_field, err) => {
                            clap_variant.#ident_field = option_cli_field;
                            return interactive_clap::ResultFromCli::Err(Some(clap_variant), err);
                        }
                    }
                }
            })
            .next()
            .unwrap_or(quote!())
    }
}

fn field_value_subargs(field: &syn::Field) -> proc_macro2::TokenStream {
    let ident_field = &field.clone().ident.expect("this field does not exist");
    let ty = &field.ty;
    if field.attrs.is_empty() {
        quote!()
    } else {
        field.attrs.iter()
            .filter(|attr| attr.path.is_ident("interactive_clap"))
            .flat_map(|attr| attr.tokens.clone())
            .filter(|attr_token| {
                match attr_token {
                    proc_macro2::TokenTree::Group(group) => group.stream().to_string().contains("subargs"),
                    _ => abort_call_site!("Only option `TokenTree::Group` is needed")
                }
            })
            .map(|_| {
                quote! {
                    match #ty::from_cli(
                        optional_clap_variant.unwrap_or_default().#ident_field,
                        context.into(),
                    ) {
                        interactive_clap::ResultFromCli::Ok(cli_field) => clap_variant.#ident_field = Some(cli_field),
                        interactive_clap::ResultFromCli::Cancel(optional_cli_field) => {
                            clap_variant.#ident_field = optional_cli_field;
                            return interactive_clap::ResultFromCli::Cancel(Some(clap_variant));
                        }
                        interactive_clap::ResultFromCli::Back => return interactive_clap::ResultFromCli::Back,
                        interactive_clap::ResultFromCli::Err(optional_cli_field, err) => {
                            clap_variant.#ident_field = optional_cli_field;
                            return interactive_clap::ResultFromCli::Err(Some(clap_variant), err);
                        }
                    };
                }
            })
            .next()
            .unwrap_or(quote!())
    }
}

'''
'''--- interactive-clap-derive/src/derives/interactive_clap/methods/input_arg.rs ---
extern crate proc_macro;

use proc_macro2::Span;
use quote::quote;
use syn;

pub fn vec_fn_input_arg(
    ast: &syn::DeriveInput,
    fields: &syn::Fields,
) -> Vec<proc_macro2::TokenStream> {
    let interactive_clap_attrs_context =
        super::interactive_clap_attrs_context::InteractiveClapAttrsContext::new(ast);
    let vec_fn_input_arg = fields
        .iter()
        .filter(|field| !super::fields_with_subcommand::is_field_with_subcommand(field))
        .filter(|field| {
            !super::fields_with_skip_default_input_arg::is_field_with_skip_default_input_arg(
                field,
            )
        })
        .map(|field| {
            let ident_field = &field.clone().ident.expect("this field does not exist");
            let ty = &field.ty;

            let input_context_dir = interactive_clap_attrs_context
                .clone()
                .get_input_context_dir();

            let fn_input_arg =
                syn::Ident::new(&format!("input_{}", &ident_field), Span::call_site());

            if field.attrs.is_empty() {
                let promt = &syn::LitStr::new(&ident_field.to_string(), Span::call_site());
                return quote! {
                    fn #fn_input_arg(
                        _context: &#input_context_dir,
                    ) -> color_eyre::eyre::Result<Option<#ty>> {
                        match inquire::CustomType::new(#promt).prompt() {
                            Ok(value) => Ok(Some(value)),
                            Err(inquire::error::InquireError::OperationCanceled | inquire::error::InquireError::OperationInterrupted) => Ok(None),
                            Err(err) => Err(err.into()),
                        }
                    }
                };
            }

            if super::skip_interactive_input::is_skip_interactive_input(field) {
                return quote! {};
            }

            let doc_attrs = field
                .attrs
                .iter()
                .filter(|attr| attr.path.is_ident("doc"))
                .filter_map(|attr| {
                    for attr_token in attr.tokens.clone() {
                        if let proc_macro2::TokenTree::Literal(literal) = attr_token {
                            return Some(literal);
                        }
                    }
                    None
                });

            quote! {
                fn #fn_input_arg(
                    _context: &#input_context_dir,
                ) -> color_eyre::eyre::Result<Option<#ty>> {
                    match inquire::CustomType::new(concat!(#( #doc_attrs, )*).trim()).prompt() {
                        Ok(value) => Ok(Some(value)),
                        Err(inquire::error::InquireError::OperationCanceled | inquire::error::InquireError::OperationInterrupted) => Ok(None),
                        Err(err) => Err(err.into()),
                    }
                }
            }
        })
        .filter(|token_stream| !token_stream.is_empty())
        .collect::<Vec<proc_macro2::TokenStream>>();
    vec_fn_input_arg
}

'''
'''--- interactive-clap-derive/src/derives/interactive_clap/methods/interactive_clap_attrs_context.rs ---
extern crate proc_macro;

use quote::quote;
use syn;

#[derive(Debug, Clone)]
pub struct InteractiveClapAttrsContext {
    pub context_dir: Option<proc_macro2::TokenStream>,
    pub input_context_dir: Option<proc_macro2::TokenStream>,
    pub output_context_dir: Option<proc_macro2::TokenStream>,
    pub is_skip_default_from_cli: bool,
}

impl InteractiveClapAttrsContext {
    pub fn new(ast: &syn::DeriveInput) -> Self {
        let mut context_dir = quote!();
        let mut input_context_dir = quote!();
        let mut output_context_dir = quote!();
        let mut is_skip_default_from_cli = false;
        if !ast.attrs.is_empty() {
            for attr in ast.attrs.clone() {
                if attr.path.is_ident("interactive_clap") {
                    for attr_token in attr.tokens.clone() {
                        if let proc_macro2::TokenTree::Group(group) = attr_token {
                            if group.stream().to_string().contains("output_context") {
                                let group_stream =
                                    &group.stream().into_iter().collect::<Vec<_>>()[2..];
                                output_context_dir = quote! {#(#group_stream)*};
                            } else if group.stream().to_string().contains("input_context") {
                                let group_stream =
                                    &group.stream().into_iter().collect::<Vec<_>>()[2..];
                                input_context_dir = quote! {#(#group_stream)*};
                            } else if group.stream().to_string().contains("context") {
                                let group_stream =
                                    &group.stream().into_iter().collect::<Vec<_>>()[2..];
                                context_dir = quote! {#(#group_stream)*};
                            };
                            if group.stream().to_string().contains("skip_default_from_cli") {
                                is_skip_default_from_cli = true;
                            };
                        }
                    }
                };
            }
        };
        let context_dir: Option<proc_macro2::TokenStream> = if context_dir.is_empty() {
            None
        } else {
            Some(context_dir)
        };
        let input_context_dir: Option<proc_macro2::TokenStream> = if input_context_dir.is_empty() {
            None
        } else {
            Some(input_context_dir)
        };
        let output_context_dir: Option<proc_macro2::TokenStream> = if output_context_dir.is_empty()
        {
            None
        } else {
            Some(output_context_dir)
        };
        Self {
            context_dir,
            input_context_dir,
            output_context_dir,
            is_skip_default_from_cli,
        }
    }

    pub fn get_input_context_dir(self) -> proc_macro2::TokenStream {
        let context_dir = match self.context_dir {
            Some(context_dir) => context_dir,
            None => quote!(),
        };
        if !context_dir.is_empty() {
            return context_dir;
        };
        match self.input_context_dir {
            Some(input_context_dir) => input_context_dir,
            None => quote! {()},
        }
    }
}

'''
'''--- interactive-clap-derive/src/derives/interactive_clap/methods/mod.rs ---
pub mod choose_variant;
pub mod cli_field_type;
pub mod fields_with_skip_default_input_arg;
pub mod fields_with_subargs;
pub mod fields_with_subcommand;
pub mod from_cli_for_enum;
pub mod from_cli_for_struct;
pub mod input_arg;
pub mod interactive_clap_attrs_context;
pub mod skip_interactive_input;

'''
'''--- interactive-clap-derive/src/derives/interactive_clap/methods/skip_interactive_input.rs ---
extern crate proc_macro;

use syn;

pub fn is_skip_interactive_input(field: &syn::Field) -> bool {
    field
        .attrs
        .iter()
        .filter(|attr| attr.path.is_ident("interactive_clap"))
        .flat_map(|attr| attr.tokens.clone())
        .any(|attr_token| match attr_token {
            proc_macro2::TokenTree::Group(group) => group
                .stream()
                .to_string()
                .contains("skip_interactive_input"),
            _ => false,
        })
}

'''
'''--- interactive-clap-derive/src/derives/interactive_clap/mod.rs ---
extern crate proc_macro;

use proc_macro2::{Span, TokenStream};
use proc_macro_error::abort_call_site;
use quote::{quote, ToTokens};
use syn;

mod methods;

pub fn impl_interactive_clap(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let cli_name_string = format!("Cli{}", &ast.ident);
    let cli_name = &syn::Ident::new(&cli_name_string, Span::call_site());
    match &ast.data {
        syn::Data::Struct(data_struct) => {
            let fields = data_struct.fields.clone();
            let mut ident_skip_field_vec: Vec<syn::Ident> = Vec::new();

            let cli_fields = fields
                .iter()
                .map(|field| {
                    let ident_field = field.ident.clone().expect("this field does not exist");
                    let ty = &field.ty;
                    let cli_ty = self::methods::cli_field_type::cli_field_type(ty);
                    let mut cli_field = quote! {
                        pub #ident_field: #cli_ty
                    };
                    if field.attrs.is_empty() {
                        return cli_field;
                    };
                    let mut clap_attr_vec: Vec<proc_macro2::TokenStream> = Vec::new();
                    let mut cfg_attr_vec: Vec<proc_macro2::TokenStream> = Vec::new();
                    for attr in &field.attrs {
                        if attr.path.is_ident("interactive_clap") || attr.path.is_ident("cfg") {
                            for attr_token in attr.tokens.clone() {
                                match attr_token {
                                    proc_macro2::TokenTree::Group(group) => {
                                        if group.stream().to_string().contains("subcommand")
                                            || group.stream().to_string().contains("value_enum")
                                            || group.stream().to_string().contains("long")
                                            || (group.stream().to_string() == *"skip")
                                            || (group.stream().to_string() == *"flatten")
                                        {
                                            clap_attr_vec.push(group.stream())
                                        } else if group.stream().to_string() == *"named_arg" {
                                            let ident_subcommand =
                                                syn::Ident::new("subcommand", Span::call_site());
                                            clap_attr_vec.push(quote! {#ident_subcommand});
                                            let type_string = match ty {
                                                syn::Type::Path(type_path) => {
                                                    match type_path.path.segments.last() {
                                                        Some(path_segment) => {
                                                            path_segment.ident.to_string()
                                                        }
                                                        _ => String::new(),
                                                    }
                                                }
                                                _ => String::new(),
                                            };
                                            let enum_for_clap_named_arg = syn::Ident::new(
                                                &format!(
                                                    "ClapNamedArg{}For{}",
                                                    &type_string, &name
                                                ),
                                                Span::call_site(),
                                            );
                                            cli_field = quote! {
                                                pub #ident_field: Option<#enum_for_clap_named_arg>
                                            }
                                        };
                                        if group.stream().to_string().contains("feature") {
                                            cfg_attr_vec.push(attr.into_token_stream())
                                        };
                                        if group.stream().to_string().contains("subargs") {
                                            let ident_subargs =
                                                syn::Ident::new("flatten", Span::call_site());
                                            clap_attr_vec.push(quote! {#ident_subargs});
                                        };
                                        if group.stream().to_string() == *"skip" {
                                            ident_skip_field_vec.push(ident_field.clone());
                                            cli_field = quote!()
                                        };
                                    }
                                    _ => {
                                        abort_call_site!("Only option `TokenTree::Group` is needed")
                                    }
                                }
                            }
                        }
                    }
                    if cli_field.is_empty() {
                        return cli_field;
                    };
                    let cfg_attrs = cfg_attr_vec.iter();
                    if !clap_attr_vec.is_empty() {
                        let clap_attrs = clap_attr_vec.iter();
                        quote! {
                            #(#cfg_attrs)*
                            #[clap(#(#clap_attrs, )*)]
                            #cli_field
                        }
                    } else {
                        quote! {
                            #(#cfg_attrs)*
                            #cli_field
                        }
                    }
                })
                .filter(|token_stream| !token_stream.is_empty())
                .collect::<Vec<_>>();

            let for_cli_fields = fields
                .iter()
                .map(|field| for_cli_field(field, &ident_skip_field_vec))
                .filter(|token_stream| !token_stream.is_empty());

            let fn_from_cli_for_struct =
                self::methods::from_cli_for_struct::from_cli_for_struct(ast, &fields);

            let vec_fn_input_arg = self::methods::input_arg::vec_fn_input_arg(ast, &fields);

            let context_scope_fields = fields
                .iter()
                .map(context_scope_for_struct_field)
                .filter(|token_stream| !token_stream.is_empty())
                .collect::<Vec<_>>();
            let context_scope_for_struct = context_scope_for_struct(name, context_scope_fields);

            let clap_enum_for_named_arg = fields.iter().find_map(|field| {
                let ident_field = &field.clone().ident.expect("this field does not exist");
                let variant_name_string = crate::helpers::snake_case_to_camel_case::snake_case_to_camel_case(ident_field.to_string());
                let variant_name = &syn::Ident::new(&variant_name_string, Span::call_site());
                let attr_doc_vec: Vec<_> = field.attrs.iter()
                    .filter(|attr| attr.path.is_ident("doc"))
                    .map(|attr| attr.into_token_stream())
                    .collect();
                field.attrs.iter()
                    .filter(|attr| attr.path.is_ident("interactive_clap"))
                    .flat_map(|attr| attr.tokens.clone())
                    .filter(|attr_token| {
                        match attr_token {
                            proc_macro2::TokenTree::Group(group) => group.stream().to_string() == *"named_arg",
                            _ => abort_call_site!("Only option `TokenTree::Group` is needed")
                        }
                    })
                    .map(|_| {
                        let ty = &field.ty;
                        let type_string = match ty {
                            syn::Type::Path(type_path) => {
                                match type_path.path.segments.last() {
                                    Some(path_segment) => path_segment.ident.to_string(),
                                    _ => String::new()
                                }
                            },
                            _ => String::new()
                        };
                        let enum_for_clap_named_arg = syn::Ident::new(&format!("ClapNamedArg{}For{}", &type_string, &name), Span::call_site());
                        quote! {
                            #[derive(Debug, Clone, clap::Parser, interactive_clap_derive::ToCliArgs)]
                            pub enum #enum_for_clap_named_arg {
                                #(#attr_doc_vec)*
                                #variant_name(<#ty as interactive_clap::ToCli>::CliVariant)
                            }

                            impl From<#ty> for #enum_for_clap_named_arg {
                                fn from(item: #ty) -> Self {
                                    Self::#variant_name(<#ty as interactive_clap::ToCli>::CliVariant::from(item))
                                }
                            }
                        }
                    })
                    .next()
                })
                .unwrap_or(quote!());

            quote! {
                #[derive(Debug, Default, Clone, clap::Parser, interactive_clap::ToCliArgs)]
                #[clap(author, version, about, long_about = None)]
                pub struct #cli_name {
                    #( #cli_fields, )*
                }

                impl interactive_clap::ToCli for #name {
                    type CliVariant = #cli_name;
                }

                #context_scope_for_struct

                #fn_from_cli_for_struct

                impl #name {
                    #(#vec_fn_input_arg)*

                    pub fn try_parse() -> Result<#cli_name, clap::Error> {
                        <#cli_name as clap::Parser>::try_parse()
                    }

                    pub fn parse() -> #cli_name {
                        <#cli_name as clap::Parser>::parse()
                    }

                    pub fn try_parse_from(s: &str) -> Result<#cli_name, clap::Error> {
                        <#cli_name as clap::Parser>::try_parse_from(s.split(" "))
                    }
                }

                impl From<#name> for #cli_name {
                    fn from(args: #name) -> Self {
                        Self {
                            #( #for_cli_fields, )*
                        }
                    }
                }

                #clap_enum_for_named_arg
            }
        }
        syn::Data::Enum(syn::DataEnum { variants, .. }) => {
            let enum_variants = variants.iter().map(|variant| {
                let ident = &variant.ident;
                let mut attrs: Vec<proc_macro2::TokenStream> = Vec::new();
                if !&variant.attrs.is_empty() {
                    for attr in &variant.attrs {
                        if attr.path.is_ident("doc") {
                            attrs.push(attr.into_token_stream());
                        };
                        if attr.path.is_ident("cfg") {
                            for attr_token in attr.tokens.clone() {
                                match attr_token {
                                    proc_macro2::TokenTree::Group(group) => {
                                        if group.stream().to_string().contains("feature") {
                                            attrs.push(attr.into_token_stream());
                                        } else {
                                            continue;
                                        };
                                    }
                                    _ => {
                                        abort_call_site!("Only option `TokenTree::Group` is needed")
                                    }
                                }
                            }
                        };
                    }
                    match &variant.fields {
                        syn::Fields::Unnamed(fields) => {
                            let ty = &fields.unnamed[0].ty;
                            if attrs.is_empty() {
                                quote! {#ident(<#ty as interactive_clap::ToCli>::CliVariant)}
                            } else {
                                quote! {
                                    #(#attrs)*
                                    #ident(<#ty as interactive_clap::ToCli>::CliVariant)
                                }
                            }
                        }
                        syn::Fields::Unit => {
                            if attrs.is_empty() {
                                quote! {#ident}
                            } else {
                                quote! {
                                    #(#attrs)*
                                    #ident
                                }
                            }
                        }
                        _ => abort_call_site!(
                            "Only option `Fields::Unnamed` or `Fields::Unit` is needed"
                        ),
                    }
                } else {
                    match &variant.fields {
                        syn::Fields::Unnamed(fields) => {
                            let ty = &fields.unnamed[0].ty;
                            quote! { #ident(<#ty as interactive_clap::ToCli>::CliVariant) }
                        }
                        syn::Fields::Unit => {
                            quote! { #ident }
                        }
                        _ => abort_call_site!(
                            "Only option `Fields::Unnamed` or `Fields::Unit` is needed"
                        ),
                    }
                }
            });
            let for_cli_enum_variants = variants.iter().map(|variant| {
                let ident = &variant.ident;
                match &variant.fields {
                    syn::Fields::Unnamed(_) => {
                        quote! { #name::#ident(arg) => Self::#ident(arg.into()) }
                    }
                    syn::Fields::Unit => {
                        quote! { #name::#ident => Self::#ident }
                    }
                    _ => abort_call_site!(
                        "Only option `Fields::Unnamed` or `Fields::Unit` is needed"
                    ),
                }
            });

            let scope_for_enum = context_scope_for_enum(name);

            let fn_choose_variant = self::methods::choose_variant::fn_choose_variant(ast, variants);

            let fn_from_cli_for_enum =
                self::methods::from_cli_for_enum::from_cli_for_enum(ast, variants);

            quote! {
                #[derive(Debug, Clone, clap::Parser, interactive_clap::ToCliArgs)]
                pub enum #cli_name {
                    #( #enum_variants, )*
                }

                impl interactive_clap::ToCli for #name {
                    type CliVariant = #cli_name;
                }

                #scope_for_enum

                impl From<#name> for #cli_name {
                    fn from(command: #name) -> Self {
                        match command {
                            #( #for_cli_enum_variants, )*
                        }
                    }
                }

                #fn_from_cli_for_enum

                impl #name {
                    #fn_choose_variant

                    pub fn try_parse() -> Result<#cli_name, clap::Error> {
                        <#cli_name as clap::Parser>::try_parse()
                    }

                    pub fn parse() -> #cli_name {
                        <#cli_name as clap::Parser>::parse()
                    }

                    pub fn try_parse_from(s: &str) -> Result<#cli_name, clap::Error> {
                        <#cli_name as clap::Parser>::try_parse_from(s.split(" "))
                    }
                }
            }
        }
        _ => abort_call_site!("`#[derive(InteractiveClap)]` only supports structs and enums"),
    }
}

fn context_scope_for_struct(
    name: &syn::Ident,
    context_scope_fields: Vec<proc_macro2::TokenStream>,
) -> proc_macro2::TokenStream {
    let interactive_clap_context_scope_for_struct = syn::Ident::new(
        &format!("InteractiveClapContextScopeFor{}", &name),
        Span::call_site(),
    );
    quote! {
        pub struct #interactive_clap_context_scope_for_struct {
            #(#context_scope_fields,)*
        }
        impl interactive_clap::ToInteractiveClapContextScope for #name {
            type InteractiveClapContextScope = #interactive_clap_context_scope_for_struct;
        }
    }
}

fn context_scope_for_struct_field(field: &syn::Field) -> proc_macro2::TokenStream {
    let ident_field = &field.ident.clone().expect("this field does not exist");
    let ty = &field.ty;
    if !self::methods::fields_with_subcommand::is_field_with_subcommand(field)
        && !self::methods::fields_with_subargs::is_field_with_subargs(field)
    {
        quote! {
            pub #ident_field: #ty
        }
    } else {
        quote!()
    }
}

fn context_scope_for_enum(name: &syn::Ident) -> proc_macro2::TokenStream {
    let interactive_clap_context_scope_for_enum = syn::Ident::new(
        &format!("InteractiveClapContextScopeFor{}", &name),
        Span::call_site(),
    );
    let enum_discriminants = syn::Ident::new(&format!("{}Discriminants", &name), Span::call_site());
    quote! {
        pub type #interactive_clap_context_scope_for_enum = #enum_discriminants;
        impl interactive_clap::ToInteractiveClapContextScope for #name {
                    type InteractiveClapContextScope = #interactive_clap_context_scope_for_enum;
                }
    }
}

fn for_cli_field(
    field: &syn::Field,
    ident_skip_field_vec: &[syn::Ident],
) -> proc_macro2::TokenStream {
    let ident_field = &field.clone().ident.expect("this field does not exist");
    if ident_skip_field_vec.contains(ident_field) {
        quote!()
    } else {
        let ty = &field.ty;
        match &ty {
            syn::Type::Path(type_path) => match type_path.path.segments.first() {
                Some(path_segment) => {
                    if path_segment.ident == "Option" || path_segment.ident == "bool" {
                        quote! {
                            #ident_field: args.#ident_field.into()
                        }
                    } else {
                        quote! {
                            #ident_field: Some(args.#ident_field.into())
                        }
                    }
                }
                _ => abort_call_site!("Only option `PathSegment` is needed"),
            },
            _ => abort_call_site!("Only option `Type::Path` is needed"),
        }
    }
}

'''
'''--- interactive-clap-derive/src/derives/mod.rs ---
pub mod interactive_clap;
pub mod to_cli_args;

'''
'''--- interactive-clap-derive/src/derives/to_cli_args/methods/interactive_clap_attrs_cli_field.rs ---
extern crate proc_macro;

use proc_macro2::Span;
use proc_macro_error::abort_call_site;
use quote::{quote, ToTokens};
use syn;

#[derive(Debug, Clone)]
pub enum InteractiveClapAttrsCliField {
    RegularField(proc_macro2::TokenStream),
    SubcommandField(proc_macro2::TokenStream),
}

impl InteractiveClapAttrsCliField {
    pub fn new(field: syn::Field) -> Self {
        let ident_field = field.ident.clone().expect("this field does not exist");
        let mut args_without_attrs = quote!();
        let mut named_args = quote!();
        let mut unnamed_args = quote!();

        if field.attrs.is_empty() {
            args_without_attrs = quote! {
                if let Some(arg) = &self.#ident_field {
                    args.push_front(arg.to_string())
                }
            };
        } else {
            for attr in &field.attrs {
                if attr.path.is_ident("clap") {
                    for attr_token in attr.tokens.clone() {
                        match attr_token {
                            proc_macro2::TokenTree::Group(group) => {
                                for item in group.stream() {
                                    match &item {
                                        proc_macro2::TokenTree::Ident(ident) => {
                                            if ident == "subcommand" {
                                                return Self::SubcommandField(quote! {
                                                    let mut args = self
                                                    .#ident_field
                                                    .as_ref()
                                                    .map(|subcommand| subcommand.to_cli_args())
                                                    .unwrap_or_default();
                                                });
                                            }
                                            if ident == "flatten" {
                                                args_without_attrs = quote! {
                                                    if let Some(arg) = &self.#ident_field {
                                                        let mut to_cli_args = arg.to_cli_args();
                                                        to_cli_args.append(&mut args);
                                                        std::mem::swap(&mut args, &mut to_cli_args);
                                                    }
                                                };
                                            }
                                            if ident == "value_enum" {
                                                args_without_attrs = quote! {
                                                    if let Some(arg) = &self.#ident_field {
                                                        args.push_front(arg.to_string())
                                                    }
                                                };
                                            } else if ident == "long" {
                                                let ident_field_to_kebab_case_string =
                                                    crate::helpers::to_kebab_case::to_kebab_case(
                                                        ident_field.to_string(),
                                                    );
                                                let ident_field_to_kebab_case = &syn::LitStr::new(
                                                    &ident_field_to_kebab_case_string,
                                                    Span::call_site(),
                                                );
                                                if field.ty.to_token_stream().to_string() == "bool"
                                                {
                                                    unnamed_args = quote! {
                                                        if self.#ident_field {
                                                            args.push_front(std::concat!("--", #ident_field_to_kebab_case).to_string());
                                                        }
                                                    };
                                                } else {
                                                    unnamed_args = quote! {
                                                        if let Some(arg) = &self.#ident_field {
                                                            args.push_front(arg.to_string());
                                                            args.push_front(std::concat!("--", #ident_field_to_kebab_case).to_string());
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        proc_macro2::TokenTree::Literal(literal) => {
                                            named_args = quote! {
                                                if let Some(arg) = &self.#ident_field {
                                                    args.push_front(arg.to_string());
                                                    args.push_front(std::concat!("--", #literal).to_string());
                                                }
                                            };
                                        }
                                        _ => (), //abort_call_site!("Only option `TokenTree::Ident` is needed")
                                    };
                                }
                            }
                            _ => abort_call_site!("Only option `TokenTree::Group` is needed"),
                        }
                    }
                }
            }
        };
        let token_stream_args: proc_macro2::TokenStream = if !named_args.is_empty() {
            named_args
        } else if !unnamed_args.is_empty() {
            unnamed_args
        } else if !args_without_attrs.is_empty() {
            args_without_attrs
        } else {
            quote!()
        };
        Self::RegularField(token_stream_args)
    }
}

'''
'''--- interactive-clap-derive/src/derives/to_cli_args/methods/mod.rs ---
pub mod interactive_clap_attrs_cli_field;

'''
'''--- interactive-clap-derive/src/derives/to_cli_args/mod.rs ---
extern crate proc_macro;

use proc_macro2::{Span, TokenStream};
use proc_macro_error::abort_call_site;
use quote::quote;
use syn;

use self::methods::interactive_clap_attrs_cli_field::InteractiveClapAttrsCliField;

mod methods;

pub fn impl_to_cli_args(ast: &syn::DeriveInput) -> TokenStream {
    let cli_name = &ast.ident;
    match &ast.data {
        syn::Data::Struct(data_struct) => {
            let mut args_subcommand = quote! {
                let mut args = std::collections::VecDeque::new();
            };
            let mut args_push_front_vec: Vec<proc_macro2::TokenStream> = Vec::new();

            for field in data_struct.clone().fields.iter() {
                match InteractiveClapAttrsCliField::new(field.clone()) {
                    InteractiveClapAttrsCliField::RegularField(regular_field_args) => {
                        args_push_front_vec.push(regular_field_args)
                    }
                    InteractiveClapAttrsCliField::SubcommandField(subcommand_args) => {
                        args_subcommand = subcommand_args
                    }
                }
            }
            let args_push_front_vec = args_push_front_vec.into_iter().rev();

            quote! {
                impl interactive_clap::ToCliArgs for #cli_name {
                    fn to_cli_args(&self) -> std::collections::VecDeque<String> {
                        #args_subcommand;
                        #(#args_push_front_vec; )*
                        args
                    }
                }
            }
        }
        syn::Data::Enum(syn::DataEnum { variants, .. }) => {
            let enum_variants = variants.iter().map(|variant| {
                let ident = &variant.ident;
                let variant_name_string =
                    crate::helpers::to_kebab_case::to_kebab_case(ident.to_string());
                let variant_name = &syn::LitStr::new(&variant_name_string, Span::call_site());

                match &variant.fields {
                    syn::Fields::Unnamed(_) => {
                        quote! {
                            Self::#ident(subcommand) => {
                                let mut args = subcommand.to_cli_args();
                                args.push_front(#variant_name.to_owned());
                                args
                            }
                        }
                    }
                    syn::Fields::Unit => {
                        quote! {
                            Self::#ident => {
                                let mut args = std::collections::VecDeque::new();
                                args.push_front(#variant_name.to_owned());
                                args
                            }
                        }
                    }
                    _ => abort_call_site!(
                        "Only options `Fields::Unnamed` or `Fields::Unit` are needed"
                    ),
                }
            });
            quote! {
                impl interactive_clap::ToCliArgs for #cli_name {
                    fn to_cli_args(&self) -> std::collections::VecDeque<String> {
                        match self {
                            #( #enum_variants, )*
                        }
                    }
                }
            }
        }
        _ => abort_call_site!("`#[derive(InteractiveClap)]` only supports structs and enums"),
    }
}

'''
'''--- interactive-clap-derive/src/helpers/mod.rs ---
pub mod snake_case_to_camel_case;
pub mod to_kebab_case;

'''
'''--- interactive-clap-derive/src/helpers/snake_case_to_camel_case.rs ---
pub fn snake_case_to_camel_case(s: String) -> String {
    let s_vec: Vec<String> = s
        .to_lowercase()
        .split('_')
        .map(|s| s.replacen(&s[..1], &s[..1].to_ascii_uppercase(), 1))
        .collect();
    s_vec.join("")
}

'''
'''--- interactive-clap-derive/src/helpers/to_kebab_case.rs ---
pub fn to_kebab_case(s: String) -> String {
    let mut snake = String::new();
    for (i, ch) in s.char_indices() {
        if i > 0 && ch.is_uppercase() {
            snake.push('-');
        }
        snake.push(ch.to_ascii_lowercase());
    }
    snake.as_str().replace('_', "-")
}

'''
'''--- interactive-clap-derive/src/lib.rs ---
extern crate proc_macro;

use proc_macro::TokenStream;
use proc_macro_error::proc_macro_error;

mod derives;
mod helpers;
#[cfg(test)]
mod tests;

#[proc_macro_derive(InteractiveClap, attributes(interactive_clap))]
#[proc_macro_error]
pub fn interactive_clap(input: TokenStream) -> TokenStream {
    let ast = syn::parse_macro_input!(input);
    derives::interactive_clap::impl_interactive_clap(&ast).into()
}

#[proc_macro_derive(ToCliArgs, attributes(to_cli_args))]
#[proc_macro_error]
pub fn to_cli_args(input: TokenStream) -> TokenStream {
    let ast = syn::parse_macro_input!(input);
    derives::to_cli_args::impl_to_cli_args(&ast).into()
}

'''
'''--- interactive-clap-derive/src/tests/mod.rs ---
mod test_simple_struct;

'''
'''--- interactive-clap-derive/src/tests/test_simple_struct.rs ---
fn pretty_codegen(ts: &proc_macro2::TokenStream) -> String {
    let file = syn::parse_file(&ts.to_string()).unwrap();
    prettyplease::unparse(&file)
}

#[test]
fn test_simple_struct() {
    let input = syn::parse_quote! {
        struct Args {
            age: u64,
            first_name: String,
            second_name: String,
        }
    };

    let interactive_clap_codegen = crate::derives::interactive_clap::impl_interactive_clap(&input);
    insta::assert_snapshot!(pretty_codegen(&interactive_clap_codegen));

    let to_cli_args_codegen = crate::derives::to_cli_args::impl_to_cli_args(&input);
    insta::assert_snapshot!(pretty_codegen(&to_cli_args_codegen));
}

#[test]
fn test_flag() {
    let input = syn::parse_quote! {
        struct Args {
            /// Offline mode
            #[interactive_clap(long)]
            offline: bool
        }
    };

    let interactive_clap_codegen = crate::derives::interactive_clap::impl_interactive_clap(&input);
    insta::assert_snapshot!(pretty_codegen(&interactive_clap_codegen));

    let input = syn::parse_quote! {
        struct CliArgs {
            /// Offline mode
            #[clap(long)]
            offline: bool
        }
    };

    let to_cli_args_codegen = crate::derives::to_cli_args::impl_to_cli_args(&input);
    insta::assert_snapshot!(pretty_codegen(&to_cli_args_codegen));
}

'''
'''--- src/helpers/mod.rs ---
pub mod snake_case_to_camel_case;
pub mod to_kebab_case;

'''
'''--- src/helpers/snake_case_to_camel_case.rs ---
pub fn snake_case_to_camel_case(s: String) -> String {
    let s_vec: Vec<String> = s
        .to_lowercase()
        .split("_")
        .map(|s| s.replacen(&s[..1], &s[..1].to_ascii_uppercase(), 1))
        .collect();
    s_vec.join("")
}

'''
'''--- src/helpers/to_kebab_case.rs ---
pub fn to_kebab_case(s: String) -> String {
    let mut snake = String::new();
    for (i, ch) in s.char_indices() {
        if i > 0 && ch.is_uppercase() {
            snake.push('-');
        }
        snake.push(ch.to_ascii_lowercase());
    }
    snake.as_str().replace("_", "-")
}

'''
'''--- src/lib.rs ---
//! The Interactive-clap library is an add-on for the Command Line Argument
//! Parser (https://crates.io/crates/clap). Interactive-clap allows you to parse
//! command line options. The peculiarity of this macro is that in the absence
//! of command line parameters, the interactive mode of entering these data by
//! the user is activated.

pub use interactive_clap_derive::{InteractiveClap, ToCliArgs};

pub trait ToCli {
    type CliVariant;
}

impl ToCli for String {
    type CliVariant = String;
}

impl ToCli for u128 {
    type CliVariant = u128;
}

impl ToCli for u64 {
    type CliVariant = u64;
}

impl ToCli for bool {
    type CliVariant = bool;
}

pub trait ToInteractiveClapContextScope {
    type InteractiveClapContextScope;
}

pub trait ToCliArgs {
    fn to_cli_args(&self) -> std::collections::VecDeque<String>;
}

pub enum ResultFromCli<T, E> {
    Ok(T),
    Cancel(Option<T>),
    Back,
    Err(Option<T>, E),
}

pub trait FromCli {
    type FromCliContext;
    type FromCliError;
    fn from_cli(
        optional_clap_variant: Option<<Self as ToCli>::CliVariant>,
        context: Self::FromCliContext,
    ) -> ResultFromCli<<Self as ToCli>::CliVariant, Self::FromCliError>
    where
        Self: Sized + ToCli;
}

pub enum SelectVariantOrBack<T: strum::EnumMessage> {
    Variant(T),
    Back,
}
impl<T: strum::EnumMessage> std::fmt::Display for SelectVariantOrBack<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Self::Variant(variant) = self {
            f.write_str(variant.get_message().unwrap())
        } else {
            f.write_str("back")
        }
    }
}

'''