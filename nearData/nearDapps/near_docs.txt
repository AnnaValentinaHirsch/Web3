*GitHub Repository "near/docs"*

'''--- .github/ISSUE_TEMPLATE/bug_report.md ---
---
name: Bug report üêû
about: Create a report to help us improve the docs
title: "[BUG] "
labels: bug
assignees: ''

---
<!-- ‚ö†Ô∏è Do Not Delete This! bug_report_template ‚ö†Ô∏è -->
<!-- Please search existing issues to avoid creating duplicates. -->

**Describe the bug** üêû
Briefly describe the issue you're experiencing.

**Expected behavior**
Describe what you were expecting to find.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Location** üéØ
Please link to the page that you see this issue.

'''
'''--- .github/ISSUE_TEMPLATE/config.yml ---
blank_issues_enabled: false
contact_links:
  - name: Question
    url:  https://stackoverflow.com/questions/tagged/nearprotocol
    about: Please ask and answer questions here.
'''
'''--- .github/ISSUE_TEMPLATE/documentation-request.md ---
---
name: Documentation request ‚úèÔ∏è 
about: Suggest an idea for a new document propose an enhancement of an existing document.
title: "[DOC] "
labels: enhancement
assignees: ''

---
<!-- ‚ö†Ô∏è Do Not Delete This! documentation_request_template ‚ö†Ô∏è -->
<!-- Please search existing issues to avoid creating duplicates. -->

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Additional context**
Add any other context or screenshots about the feature request here.

'''
'''--- .github/ISSUE_TEMPLATE/epic.md ---
---
name: Create an EPIC üîπ 
about: Create an epic of work that tracks several issues
title: "üîπ[EPIC] "
labels: Epic
assignees: ''

---

### Description

(Problem statement with a description of work to be accomplished.)

---

### Goal

(Define success. What is the desired outcome?)

---

### Resources

(Relevant documentation, Figma links, and other reference material)

- Item 1
- Item 2
- Item 3

---

```[tasklist]
### Related Issues
- [ ] https://github.com/near/docs/issues/1
- [ ] https://github.com/near/docs/issues/2
- [ ] https://github.com/near/docs/issues/3
```

'''
'''--- .github/ISSUE_TEMPLATE/meta-improvement.md ---
---
name: Meta improvement üí°
about: This is for an improvement to the workflow and/or tooling
title: "[META]"
labels: enhancement
assignees: ''

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Additional context**
Add any other context or screenshots about the feature request here.

'''
'''--- .github/workflows/build-check.yml ---
name: build-check

on:
  workflow_dispatch:
  pull_request:
    types: [opened, reopened, synchronize]
    branches:
      - master

jobs:
  build-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: "18"
      - uses: actions/cache@v3
        with:
          path: |
            ${{ github.workspace }}/**/.cache
          key: |
            ${{ runner.os }}-docusaurus-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-docusaurus-${{ hashFiles('**/yarn.lock') }}

      - name: Build docusaurus
        run: |
          cd website && yarn
          yarn build:preview
        env:
          NODE_OPTIONS: --max-old-space-size=8192

'''
'''--- .github/workflows/build-docs.yml ---
name: Build docs on PR merge

on:
  push:
    branches:
      - master
  workflow_dispatch:

jobs:
  merge_job:
    runs-on: ubuntu-latest
    concurrency:
      group: build-docs
      cancel-in-progress: true

    permissions:
      contents: write
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: "0"
      - uses: actions/setup-node@v2
        with:
          node-version: "18"

      - uses: actions/cache@v3
        with:
          path: |
            ${{ github.workspace }}/**/.cache
          key: |
            ${{ runner.os }}-docusaurus-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-docusaurus-${{ hashFiles('**/yarn.lock') }}

      - name: Set Git config
        run: |
          git config --local user.email "actions@github.com"
          git config --local user.name "Github Actions"

      - name: Merge master back to build
        run: |
          git fetch 
          git checkout build
          git pull
          git merge --no-ff master -m "Auto-merge main back to build"

      - name: Install dependencies and build
        run: |
          cd website
          yarn
          yarn build
          yarn crowdin:upload

      - name: Commit build
        run: |
          git add -f ./website/build ./website/.docusaurus ./website/i18n 
          if git commit -m "add new build";then
            git push
          else 
            echo "Nothing to commit"
          fi
    env:
      NODE_OPTIONS: --max-old-space-size=8192
      CROWDIN_PERSONAL_TOKEN: ${{ secrets.CROWDIN_PERSONAL_TOKEN }}

'''
'''--- .github/workflows/spellcheck.yml ---
name: spellchecker

on:
  workflow_dispatch:
  pull_request:
    types: [opened, reopened, synchronize]
    branches:
      - master

jobs:
  misspell:
    name: runner / misspell
    runs-on: ubuntu-latest
    steps:
      - name: Check out code.
        uses: actions/checkout@v1
      - name: misspell
        id: check_for_typos
        uses: reviewdog/action-misspell@v1
        with:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          path: "./docs"
          locale: "US"

'''
'''--- .github/workflows/test-links.yml ---
name: Link Checker

on:
  workflow_dispatch:
  pull_request:
    types: [opened, reopened, synchronize]
    branches:
      - master

jobs:
  check_links:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: "18"

      - uses: actions/cache@v3
        with:
          path: |
            ${{ github.workspace }}/**/.cache
          key: |
            ${{ runner.os }}-docusaurus-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-docusaurus-${{ hashFiles('**/yarn.lock') }}

      - name: Install dependencies
        run: cd ./website && yarn

      - name: Run test
        run: cd ./website && yarn full-test

'''
'''--- .github/workflows/translation.yml ---
name: Download translation and build docs

on:
  schedule:
    - cron: "0 9 * * 1"
  workflow_dispatch:

jobs:
  merge_job:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: "0"

      - uses: actions/cache@v3
        with:
          path: |
            ${{ github.workspace }}/**/.cache
          key: |
            ${{ runner.os }}-docusaurus-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-docusaurus-${{ hashFiles('**/yarn.lock') }}

      - name: Set Git config
        run: |
          git config --local user.email "actions@github.com"
          git config --local user.name "Github Actions"

      - name: Checkout and pull build
        run: |
          git fetch
          git checkout build
          git pull

      - name: Install dependencies and build
        run: |
          cd website
          yarn
          yarn crowdin:download
          yarn build

      - name: Commit build
        run: |
          git add -f ./website/build ./website/.docusaurus ./website/i18n
          if git commit -m "add new build";then
            git push
          else 
            echo "Nothing to commit"
          fi
    env:
      NODE_OPTIONS: --max-old-space-size=8192
      CROWDIN_PERSONAL_TOKEN: ${{ secrets.CROWDIN_PERSONAL_TOKEN }}

'''
'''--- CODE_OF_CONDUCT.md ---
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
 advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
 address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
 professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at social@near.org. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq

'''
'''--- CONTRIBUTING.md ---
# Contributing to NEAR

NEAR welcomes help in many forms, including development, code review, documentation improvements, and outreach.
Please visit [the contribution overview](https://wiki.near.org/contribute/near-contributing) for more information.

## Using GitHub issues and pull requests

Some repositories (including this one) have specific issue templates that will be helpful for maintainers and community contributors. Please use the templates whenever available.

Please include steps to reproduce if you are reporting an error. Information on all applicable versions is quite helpful. Some versions can be found using the command line. (For example: `node --version` or `rustc --version`.) Other version information may be packaged as dependencies. (For example: in `package.json` or `Cargo.toml`.)

If verbosity flags are available, please include those to offer as much information as possible.

When opening a pull request, please use the typical open-source flow of forking the desired repository and opening a pull request from your forked repository. (More information on [technical contributions here](https://wiki.near.org/development/how-to-contribute).)

## Testing

Please note that for technical contributions, NEAR runs a battery of continuous integration tools and tests for each pull request.

It's encouraged to write unit tests on new features. Many NEAR repositories have built-in scripts that run tests locally. Tests may check linting and must be addressed.

For example, a repository might have `yarn test` available. It's a good idea to run tests locally before submitting a pull request, as these will be caught during the CI process.

### Thank you

NEAR values all contributors to the projects in the ecosystem and invites public discussion on the tech and vision. Please feel free to join the conversation using the links offered at [near.help](https://near.help).

'''
'''--- LICENSE-APACHE.txt ---
                              Apache License
                        Version 2.0, January 2004
                     http://www.apache.org/licenses/

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.

   "License" shall mean the terms and conditions for use, reproduction,
   and distribution as defined by Sections 1 through 9 of this document.

   "Licensor" shall mean the copyright owner or entity authorized by
   the copyright owner that is granting the License.

   "Legal Entity" shall mean the union of the acting entity and all
   other entities that control, are controlled by, or are under common
   control with that entity. For the purposes of this definition,
   "control" means (i) the power, direct or indirect, to cause the
   direction or management of such entity, whether by contract or
   otherwise, or (ii) ownership of fifty percent (50%) or more of the
   outstanding shares, or (iii) beneficial ownership of such entity.

   "You" (or "Your") shall mean an individual or Legal Entity
   exercising permissions granted by this License.

   "Source" form shall mean the preferred form for making modifications,
   including but not limited to software source code, documentation
   source, and configuration files.

   "Object" form shall mean any form resulting from mechanical
   transformation or translation of a Source form, including but
   not limited to compiled object code, generated documentation,
   and conversions to other media types.

   "Work" shall mean the work of authorship, whether in Source or
   Object form, made available under the License, as indicated by a
   copyright notice that is included in or attached to the work
   (an example is provided in the Appendix below).

   "Derivative Works" shall mean any work, whether in Source or Object
   form, that is based on (or derived from) the Work and for which the
   editorial revisions, annotations, elaborations, or other modifications
   represent, as a whole, an original work of authorship. For the purposes
   of this License, Derivative Works shall not include works that remain
   separable from, or merely link (or bind by name) to the interfaces of,
   the Work and Derivative Works thereof.

   "Contribution" shall mean any work of authorship, including
   the original version of the Work and any modifications or additions
   to that Work or Derivative Works thereof, that is intentionally
   submitted to Licensor for inclusion in the Work by the copyright owner
   or by an individual or Legal Entity authorized to submit on behalf of
   the copyright owner. For the purposes of this definition, "submitted"
   means any form of electronic, verbal, or written communication sent
   to the Licensor or its representatives, including but not limited to
   communication on electronic mailing lists, source code control systems,
   and issue tracking systems that are managed by, or on behalf of, the
   Licensor for the purpose of discussing and improving the Work, but
   excluding communication that is conspicuously marked or otherwise
   designated in writing by the copyright owner as "Not a Contribution."

   "Contributor" shall mean Licensor and any individual or Legal Entity
   on behalf of whom a Contribution has been received by Licensor and
   subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   copyright license to reproduce, prepare Derivative Works of,
   publicly display, publicly perform, sublicense, and distribute the
   Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   (except as stated in this section) patent license to make, have made,
   use, offer to sell, sell, import, and otherwise transfer the Work,
   where such license applies only to those patent claims licensable
   by such Contributor that are necessarily infringed by their
   Contribution(s) alone or by combination of their Contribution(s)
   with the Work to which such Contribution(s) was submitted. If You
   institute patent litigation against any entity (including a
   cross-claim or counterclaim in a lawsuit) alleging that the Work
   or a Contribution incorporated within the Work constitutes direct
   or contributory patent infringement, then any patent licenses
   granted to You under this License for that Work shall terminate
   as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the
   Work or Derivative Works thereof in any medium, with or without
   modifications, and in Source or Object form, provided that You
   meet the following conditions:

   (a) You must give any other recipients of the Work or
       Derivative Works a copy of this License; and

   (b) You must cause any modified files to carry prominent notices
       stating that You changed the files; and

   (c) You must retain, in the Source form of any Derivative Works
       that You distribute, all copyright, patent, trademark, and
       attribution notices from the Source form of the Work,
       excluding those notices that do not pertain to any part of
       the Derivative Works; and

   (d) If the Work includes a "NOTICE" text file as part of its
       distribution, then any Derivative Works that You distribute must
       include a readable copy of the attribution notices contained
       within such NOTICE file, excluding those notices that do not
       pertain to any part of the Derivative Works, in at least one
       of the following places: within a NOTICE text file distributed
       as part of the Derivative Works; within the Source form or
       documentation, if provided along with the Derivative Works; or,
       within a display generated by the Derivative Works, if and
       wherever such third-party notices normally appear. The contents
       of the NOTICE file are for informational purposes only and
       do not modify the License. You may add Your own attribution
       notices within Derivative Works that You distribute, alongside
       or as an addendum to the NOTICE text from the Work, provided
       that such additional attribution notices cannot be construed
       as modifying the License.

   You may add Your own copyright statement to Your modifications and
   may provide additional or different license terms and conditions
   for use, reproduction, or distribution of Your modifications, or
   for any such Derivative Works as a whole, provided Your use,
   reproduction, and distribution of the Work otherwise complies with
   the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise,
   any Contribution intentionally submitted for inclusion in the Work
   by You to the Licensor shall be under the terms and conditions of
   this License, without any additional terms or conditions.
   Notwithstanding the above, nothing herein shall supersede or modify
   the terms of any separate license agreement you may have executed
   with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade
   names, trademarks, service marks, or product names of the Licensor,
   except as required for reasonable and customary use in describing the
   origin of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or
   agreed to in writing, Licensor provides the Work (and each
   Contributor provides its Contributions) on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied, including, without limitation, any warranties or conditions
   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
   PARTICULAR PURPOSE. You are solely responsible for determining the
   appropriateness of using or redistributing the Work and assume any
   risks associated with Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory,
   whether in tort (including negligence), contract, or otherwise,
   unless required by applicable law (such as deliberate and grossly
   negligent acts) or agreed to in writing, shall any Contributor be
   liable to You for damages, including any direct, indirect, special,
   incidental, or consequential damages of any character arising as a
   result of this License or out of the use or inability to use the
   Work (including but not limited to damages for loss of goodwill,
   work stoppage, computer failure or malfunction, or any and all
   other commercial damages or losses), even if such Contributor
   has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing
   the Work or Derivative Works thereof, You may choose to offer,
   and charge a fee for, acceptance of support, warranty, indemnity,
   or other liability obligations and/or rights consistent with this
   License. However, in accepting such obligations, You may act only
   on Your own behalf and on Your sole responsibility, not on behalf
   of any other Contributor, and only if You agree to indemnify,
   defend, and hold each Contributor harmless for any liability
   incurred by, or claims asserted against, such Contributor by reason
   of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS

'''
'''--- LICENSE-MIT.txt ---
Permission is hereby granted, free of charge, to any
person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the
Software without restriction, including without
limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software
is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice
shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

'''
'''--- LOCALIZATION.md ---
# Docs Localization

## Introduction

Welcome to the [NEAR Dev Docs](https://docs.near.org/) translation project.
This article is aimed to community members that want to help in the localization of NEAR's documentation.
If you feel comfortable translating from English into your local language, you're more than welcome to contribute with this project.

### Roles

For simplicity, the translation project is hosted on [Crowdin](https://crowdin.com/project/near-docs) and anyone is free to register and join.
There are 3 basic roles across the Crowdin project:

1. **Translator:** translates documentation
2. **Proof Reader:** helps proof reading localized documents
3. **Manager:** manages memberships and helps with technical issues

### How to become a Translator

To become a certified NEAR docs translator, you need to pass a pre-translation test by working on a selected document translation. A proof reader will review your document, and if your translation proves to be high-quality, your application will be accepted and you'll be accepted as a NEAR Certified Translator.

> To become a certified translator, please join our [Crowdin project](https://crowdin.com/project/near-docs) and [create a new topic](https://crowdin.com/project/near-docs/discussions) with your application.
> The NEAR team will review your request, assign a test, and follow up with you as needed.
>
> If you have questions, please contact us on [Discord](https://near.chat). 

## How to translate

Before you start working on the translation of an article, you need to get pre-approval from the community first. The reason is to make sure the plans are transparent in the community, and the proof-readers can help to review and approve the translation once it's ready.

You can check the current translation plans available for each language on the [Tasks section](https://crowdin.com/project/near-docs/tasks):

![image](website/static/docs/assets/crowdin-tasks.png)

If there's no active plan for your language, you can submit a proposal by opening a thread on the [Discussions section](https://crowdin.com/project/near-docs/discussions).
Once your plan is pre-approved by the community, you can just go to the [Crowdin project](https://crwd.in/near-docs) and work on the translation of the specific markdown file.

### Translation plan

For each language, the current plan is to translate all the documents with the following priorities.

**Website**

1. `website` (except the `docusaurus-plugin-content-blog` folder)

**Developer**

1. `concepts`
2. `develop`
3. `tutorials`
4. `tools`
5. `api`
6. `intergrator`

**Exchanges & Integration**

1. `roles`
2. `faq`

![image](website/static/docs/assets/crowdin-list.png)

### Proof reading and go-to Production

For each document, expect no less than two proof readers to review the translations. The translator or proof reader can propose different translations if he/she doesn't agree the existing ones, the translations that receive the most votes will be accepted and displayed in the production version.

> Please pay attention to the maintainer's feedback, since its a necessary step to keep up with the standards NEAR attains to.

## Questions?

If you have any questions feel free to post them to our [Discord channel](http://near.chat).

Thanks for your time and translations!

> Got a question? [Ask it on StackOverflow!](https://stackoverflow.com/questions/tagged/nearprotocol)

'''
'''--- README.md ---
<br />
<br />

<p align="center">
<img src="website/static/docs/assets/near_logo.png" width="240">
</p>

<br />
<br />

## NEAR Protocol - scalable and usable blockchain

[![Discord](https://img.shields.io/discord/490367152054992913.svg)](http://near.chat)
[![CI](https://github.com/near/docs/actions/workflows/build-docs.yml/badge.svg)](https://github.com/near/docs/actions/workflows/build-docs.yml)

This is the repository for the official documentation of NEAR Protocol, a user-friendly and carbon-neutral blockchain, built from the ground up to be performant, secure, and infinitely scalable.

## Quick start

Check out the following links

- Deployed, live documentation: https://docs.near.org
- Example applications: https://github.com/near-examples
- Community chat: https://near.chat

## Contributing

NEAR uses [Docusaurus](https://docusaurus.io) for documentation.  Please refer to their documentation for details on major structural contributions to the documentation.

For simple content changes you have 2 options

- [Submit an issue](https://github.com/near/docs/issues)
- [Submit a pull request](https://github.com/near/docs/pulls) *(we prefer PRs of course)*

### The instant PR

This is the fastest way to submit content changes directly from the page where you notice a mistake.

1. Open any page in the docs on https://docs.near.org
2. Click the `[ Edit ]` button at the top right hand side of _every_ content page
3. Make your edits to the document that opens in GitHub by clicking the ‚úé (pencil) icon
4. Submit a PR with your changes and comments for context

### The typical PR

This is the standard fork-branch-commit workflow for submitting pull requests to open source repositories

1. Fork this repo to your own GitHub account (or just clone it directly if you are currently a member of NEAR)

2. Open your editor to the _top level repo folder_ to view the directory structure as seen below

3. Move into the `/website` folder where you will run the following commands:

   - Make sure all the dependencies for the website are installed:

     ```sh
     # Install dependencies
     yarn
     ```

   - Run the local docs development server

      ```sh
      # Start the site
      yarn start
      ```

      _Expected Output_

      ```sh
      # Website with live reload is started
      LiveReload server started on port 35729
      Docusaurus server started on port 3000
      ```

      The website for docs will open your browser locally to port `3000`

4. Make changes to the docs

5. Observe those changes reflected in the local docs

6. Submit a pull request with your changes - **[Please check for broken links before opening PR üôè](#check-for-broken-links)**

## Directory Structure

Your project file structure should look something like this with a few key files and folders highlighted

```
‚îú‚îÄ‚îÄ CODE_OF_CONDUCT.md
‚îú‚îÄ‚îÄ CONTRIBUTING.md
‚îú‚îÄ‚îÄ LICENSE-APACHE.txt
‚îú‚îÄ‚îÄ LICENSE-MIT.txt
‚îú‚îÄ‚îÄ README.md             <-- the document you are reading right now
‚îú‚îÄ‚îÄ docs                  <-- all the content for the site is in this folder as markdown files
‚îî‚îÄ‚îÄ website
    ‚îú‚îÄ‚îÄ build
    ‚îú‚îÄ‚îÄ core
    ‚îú‚îÄ‚îÄ i18n
    ‚îú‚îÄ‚îÄ package.json
    ‚îú‚îÄ‚îÄ pages
    ‚îú‚îÄ‚îÄ sidebars.js     <-- rarely used for changing left-hand-side page navigation
    ‚îú‚îÄ‚îÄ docusaurus.config.js     <-- rarely used for general site configuration (including header links)
    ‚îú‚îÄ‚îÄ static
    ‚îî‚îÄ‚îÄ test-links.sh     <-- always used to test links before submitting changes
```

## Found a broken link?

For broken links internal to the docs, please submit an issue or PR request as per above.

If you found a broken link from a Google search, please request to remove it from their index here: https://www.google.com/webmasters/tools/removals

## Check for broken links

Before opening a pull request, please check for broken links:

```bash
yarn test
```

or id you are in the `./website` directory:

```bash
yarn full-test
```

'''
'''--- blog/2024-04-23.md ---
---
title: We have a blog now!
authors: [gagdiez]
slug: we-have-a-blog
tags: [updates]
---

*Check check check. Is this thing on? Hello, world!*

<p><img src="/assets/images/protocol-b73c2a3ace3307226ee7eb2149ee432f.png" /></p>

<!-- truncate -->

## Hello there!
Welcome to the new NEAR documentation blog! We're excited to inaugurate this new space where we can share news and updates. We know what you are thinking ‚Äî why a blog? Well, it allows us to interact with you in a different way!

When writing documentation, it is important for us to keep the content focused and concise. This way, when you read it, you have nothing to distract you, and you can focus on learning a new concept.

The problem with this is that many times, we want to share ideas, thoughts, or insights into why some things are the way they are. However, this would imply going off on a tangent and explaining why some decisions were made, which will probably add noise to the document. Most of the time, users just want a link to an example or working code. Also, people don't like to read long texts.

Besides that, sometimes we just want to share what we did during the week. For example, did you notice that we fixed the nightmare that was the URL structure, or that we added new landing pages for all concepts? We want to share these things with you, but they don't really belong in the Docs.

:::tip
You would not believe the number of times we said during a review _"let's remove that, we are writing technical documentation, not a blog post"_ ... well, now we can make the blog post!
:::

## What to expect

We will be using this space to share updates about our docs, as well as **complement them** with additional information that we think you'll find interesting.

Our aim is to keep the blog updated at least once a week, but given the limited amount of time we have, we will see how that goes.

Moreover, we want to remind you that our Docs are an open source and **collaborative project**. If you feel like you have something to share, or want to contribute to the blog, feel free to reach out. And by reaching out, we mean [opening a PR](https://github.com/near/docs/pulls)!

## A new era for NEAR docs

We are super excited to start this new section and hope it helps us to connect with all of you in a better way. We are looking forward to hearing your thoughts and feedback, and hope you enjoy the content we'll be sharing.

See you in the next post! üöÄ

'''
'''--- blog/2024-04-24.md ---
---
title: Reorganizing our docs
authors: [gagdiez]
slug: reorganizing-docs
tags: [docusaurus, updates]
hide_table_of_contents: true
---

*We released a mayor reorganization of our repository, so we can improve docs for everyone... including us*

<p><img src="https://img.freepik.com/free-photo/ancient-books-adorn-library-carefully-arranged-with-classics-rare-gems_157027-2332.jpg" /></p>

<!-- truncate -->

## Organic growth
Our documentation is the result of multiple people collaborating across the span of four very active years, and it has seen a lot of changes: [2942 commits and counting](https://github.com/near/docs/commits/master/).

In the beginning, our docs only needed to explain how to create [smart contracts](/build/smart-contracts/what-is), and how to [interact with them through a frontend](/build/web3-apps/quickstart). Fast forward to today, and we have more than 200 pages of documentation, covering topics such as [chain abstraction](/build/chain-abstraction/what-is), [on-chain components](/build/near-components/what-is), [data infrastructure](/build/data-infrastructure/what-is), and [primitives such as NFT, FT](/build/primitives/what-is).

The best thing is that new features are released every single month. However, all progress comes at a cost, and as our ecosystem grew, so did the disorganization of our documentation.

## What link was that again?
Let's briefly explain how [docusaurus](https://docusaurus.io/) (the framework we use in our docs) works so you can understand the problem.

In docusaurus, all the pages are written as simple markdown files. These files go inside the `./docs` folder, and can be organized in folders. Each file has a unique ID on its header that identifies it (e.g. `id: what-is`), and this ID, alongside its folder path, is used to generate the URL. 

> For example, the document [`docs/build/smart-contracts/what-is.md`](https://github.com/near/docs/blob/master/docs/2.build/2.smart-contracts/what-is.md) has the `id: what-is`, so it ends ends being served in the URL https://docs.near.org/build/smart-contracts/what-is.

### The problem

About a year ago, we noticed that our organic growth had left us with a very inconsistent URL structure. Basically, we had a lot of folders, and the files related to the same topic (e.g. NEAR components) would be all over the place.

For example, you would be in the "Build" section reading about "What is a NEAR Component?" and the URL was `/bos/tutorial/quickstart`. The next page was "Setup an Environment" located at `/bos/dev/intro`, followed by "Anatomy of a Component -> State" at `/bos/api/state`. Talk about consistency!

Of course, we did not do this on purpose, it is just how things evolved. You might even notice that we are now talking about "NEAR Components" but the URL talks about "BOS". This is because when we started, "BOS" (Blockchain Operating System) felt like a good name, but community feedback made us know that, indeed, it was not. 

### The migration

We [re-organized more than 200 files](https://github.com/near/docs/pull/1890/files) to a new structure that is more consistent. This makes it easier for users to remember the URLs, improves our SEO, and makes it easier for contributors to find where to add new content. No more need to search across multiple folders trying to find the right file!

In the process, we updated all **internal links**, aided by our [link-checker script](https://github.com/near/docs/blob/master/website/test-links.sh) to make sure we left **no broken links**. We also added **URL redirects** in our server, so all users coming from an external site are redirected to the correct URLs.

Besides checking broken links, we took the time to make sure all the **translations were correctly migrated**. The system Docusaurus uses (called [Crowdin](https://crowdin.com/)) is not very good at detecting changes in a file, so migrating all the translations was a huge effort in itself. 

We could write a blog post just about migrating translations in docusaurus + crowdin... but we will spare you the pain.

:::tip Missing URL
If you come across a URL that is not working, please let us know by using the `Feedback` button on the right side of the page, or by opening an [issue in our repository](https://github.com/near/docs/issues)
:::

## What's next
Now that most of our documentation is in a better shape, we can focus on improving the content itself. We have a lot of ideas on how to make the docs more interactive, and we are excited to start working on them.

Stay tuned for more updates, and remember that if you have any feedback or ideas, you can always reach out to us. We are always happy to hear from you!

See you in the next post! üöÄ

'''
'''--- blog/authors.yml ---
gagdiez:
  name: Guille
  title: Docs Maintainer
  url: https://github.com/gagdiez
  image_url: https://github.com/gagdiez.png

'''
'''--- docs/1.concepts/3.advanced/indexers.md ---
---
sidebar_label: "Intro to Indexers"
---

# Introduction to Indexers

Here you will find everything you need to know in order to familiarize yourself with the concept of indexers and even build your own one.

:::info Disclaimer

The explanation on this page assumes you have a certain level of understanding of the blockchain technology.

:::

### Blockchains and their nature

Blockchain data is optimized for serialized **writes**, one block at a time, as the chain is being created. Querying the blockchain for data about a specific block or account is fairly straightforward or a "narrow" query. However, querying data across many blocks can be cumbersome because we have to aggregate results from multiple single-block queries. Therefore, we can consider these *"wide" queries*.

Given the fact that a blockchain itself is a distributed database, and a smart contract (decentralized application, dApp) is an application that runs on a virtual machine inside a blockchain, we need to understand that smart contracts should *not* be considered as a "backend". While some applications might consist only of smart contracts, building a dApp with only smart contracts, in most cases, is not possible.

Smart contracts are limited in terms of interactions. By "interactions" we mean things that are very common in the real world, like user notifications, integration with third-party applications, etc.

However, the nature of a blockchain is that it *must* be deterministic. A critical feature of a blockchain is that it knows the state at a given time, and for blockchains that time unit is a block. Think of them as being snapshots. A blockchain does snapshots of its state on every block. We as users can call smart contracts for a specific block, and the blockchain provides guarantees that execution will always produce the same result for the same block any time we call it.

The deterministic nature of a blockchain closes it from external (off-chain) variables. It is totally impossible to perform a call to an API from within a smart contract. A blockchain and a smart contract are closed off from the external (off-chain) world.

![Blockchain closed from outer world](/docs/intro/blockchain.png)

Blockchains are great at providing a way to apply the requested changes to the state in a decentralized manner. However, in order to observe the changes, you need to actively pull the information from the network.

Instead of abstract explanations let's look at an example.

:::note Example dApp

Say, we have a smart contract that sells e-books. Once a user buys a book we want to send them a copy via email.

:::

The dApp has a helper deployed somewhere off-chain, and this helper has code that can send an email with a copy of an e-book. But how would we trigger the helper?

### Getting the data from a blockchain from the external world

NEAR blockchain implements a [JSON-RPC endpoint](https://docs.near.org/api/rpc/introduction) for everyone to interact with the blockchain. Through the JSON-RPC API users can call smart contracts triggering them to be executed with given parameters. Also, users can view the data from the blockchain.

So, continuing with our example we can make our helper pull a [Block](https://docs.near.org/api/rpc/block-chunk#block) every second, then pull all the [Chunks](https://docs.near.org/api/rpc/block-chunk#chunk) and analyze the Transactions included in the Block to check if there is a transaction to our smart contract with "buy an e-book" function call. If we observe such a Transaction, we need to ensure it is successful, so we don't send the e-book to a user whose "buy e-book" Transaction failed.

After the process is complete we can trigger the helper's code to send the user an email with the e-book they bought.

This approach is so-called *pull model* of getting the data. There is nothing wrong with this approach, but sometimes you might find it is not the most comfortable or reliable approach.

Also, not all the data is available through the JSON-RPC. *Local Receipts* for example are not available through the JSON-RPC, because they are not stored in NEAR node's internal database.

### Indexer

A blockchain indexer is an implementation of the *push model* of getting the data. Instead of actively pulling the data from the source, your helper waits for the data to be sent to it. The data is complete and so the helper can start analyzing it immediately; ideally the data is complete enough to avoid additional pulls to get more details.

Getting back to our example, the helper becomes **an indexer** that receives every *Block*, along with **Chunks**, **Transactions** with its statuses, etc. In the same way the helper analyzes the data and triggers the code to send the user an email with the e-book they bought.

![Indexer is streaming the data from the blockchain](/docs/intro/indexer.png)

:::info An indexer concept

An indexer listens to the *stream of data as it's being written on chain* and can then be immediately filtered and processed to detect interesting events or patterns.

:::

## Indexers and "wide" queries

The term *"wide" queries* was mentioned in the beginning of this document. Here's a recap:

:::note "Wide" queries definition

To query data across many blocks requires the aggregation of results from multiple single-block queries. We can consider these aggregates as coming from *"wide" queries*.

:::

Because indexers listen to the *stream of data* from the blockchain and the data can be immediately filtered and processed according to defined requirements, they can be used to simplify the "wide" queries execution. For example, a stream of data can be written to a permanent database for later data analysis using a convenient query language like SQL. That is what [Indexer for Explorer](/tools/indexer-for-explorer) is doing.

Another example that highlights the need for a "wide query" is when you use a seed phrase to recover one or more accounts. Since a seed phrase essentially represents a signing key pair, the recovery is for all accounts that share the associated public key. Therefore, when a seed phrase is used to recover an account via [NEAR Wallet](https://wallet.near.org), the query requires that all accounts with a matching public key are found and recovered. [NEAR Indexer for Explorer](/tools/indexer-for-explorer) is storing this data in a permanent database and this allows [NEAR Wallet](https://wallet.near.org) to perform such "wide queries". This is impossible to achieve using JSON-RPC only.

## Summary

We hope this article gives you an understanding of the Indexer concept. Also, we hope now you can easily decide whether you need an indexer for your application.

## What's next?

We encourage you to learn more about the [Lake Indexer project](/tools/realtime#near-lake-indexer). Please, proceed to [Tutorials](/build/data-infrastructure/lake-framework/near-lake-state-changes-indexer) section to learn how to build an indexer on practice.

Alternatively, there are a few other third-party indexers that are tightly integrated with the NEAR ecosystem. You can review all of your data sourcing options (including The Graph, Pagoda, Pipespeak, and SubQuery) under [data tools](/concepts/data-flow/data-storage#data-tools).

'''
'''--- docs/1.concepts/3.advanced/near-indexer-framework.md ---
---
sidebar_label: "Indexer Framework"
---

# NEAR Indexer Framework

:::note GitHub repo

https://github.com/near/nearcore/tree/master/chain/indexer

:::

:::caution You might be looking for NEAR Lake Framework

[NEAR Lake Framework](near-lake-framework.md) is a lightweight alternative to NEAR Indexer Framework that is recommended for use when centralization can be tolerated.

:::

## Description

NEAR Indexer Framework is a Rust package (crate) that embeds [nearcore](https://github.com/near/nearcore), and abstracts away all the complexities of collecting every bit of information related to each produced block in NEAR network. The crate name is [`near-indexer`](https://github.com/near/nearcore/tree/master/chain/indexer), and it is part of the [nearcore repository](https://github.com/near/nearcore).

`near-indexer` is a micro-framework, which provides you with a stream of blocks that are recorded on NEAR network. It is useful to handle real-time "events" on the chain.

## Rationale

As scaling dApps enter NEAR‚Äôs mainnet, an issue may arise: how do they quickly and efficiently access state from our deployed smart contracts, and cut out the cruft? Contracts may grow to have complex data structures and querying the network RPC may not be the optimal way to access state data. The NEAR Indexer Framework allows for streams to be captured and indexed in a customized manner. The typical use-case is for this data to make its way to a relational database. Seeing as this is custom per project, there is engineering work involved in using this framework.

## Limitations

NEAR Indexer Framework embeds the full NEAR node and thus requires to sync with the peer-to-peer network and store all the network data locally thus it is subject to the storage requirements, which is hundreds of GBs on SSD if you only need to extract the data that is not older than ~2.5 days, and thousands of GBs on SSD if you want to be able to go over the whole history of the network. Also, the network sync process is known to be extremely slow (while the block production is 1 block per second, while the block sync usually reaches 2 blocks per second, which means that it is capable to catch up with the live network at a speed of 1 block per second, so if your node was offline for one hour, it will take one hour to catch up to the tip of the network that keeps getting freshly produced blocks).

NEAR Indexer Framework only exposes the blocks that were finalized. In NEAR Protocol, it takes 3 consecutive blocks to get the block finalized which means that there is at least a 3-second delay between the time when some transaction hits the network, and the time it is finalized and streamed from NEAR Indexer Framework. If we measure the delay between the moment when a transaction gets submitted from the client device to the moment Indexer Framework-based indexer would receive it, we can see the following timings:

* A serialized transaction being transferred over the Internet to NEAR node (most commonly, through [NEAR JSON RPC broadcast_tx_commit](https://docs.near.org/api/rpc/transactions#send-transaction-await)): around 50ms (it is not measured precisely as it is mostly network latency of TCP handshake + HTTPS handshake)
* The transaction is routed to the [validation node](https://near-nodes.io/intro/what-is-a-node): around 50ms (again, mostly network latency between the peer nodes)
* The transaction arrives in the mempool on the validation node and will be delayed at least until the next chunk/block is produced, so if the transaction was received right at the moment when transactions for the current block were selected, it would take 1.2 seconds on mainnet to get the next block produced
* Once the transaction is included in a block, it will produce a receipt which often will be executed in the next block (another 1.2-second delay) - learn more about the NEAR Protocol data flow [here](../data-flow/near-data-flow.md)
* Given that block finalization takes 3 blocks (1.2 seconds * 3), Indexer Framework will only get the opportunity to start collecting the information about the block where the transaction was included 3.6 seconds later, but we should also include at least a 50ms delay that is introduced by the network latency when produced blocks propagate back from the validation nodes back to the regular nodes
* Indexer Framework then collects all the bits of information for the produced block and streams it: around 50-100ms
* Custom indexer implementation receives the block and there could be additional delays down the line, but that is outside of our scope here

Ultimately, it takes at least 3.8 seconds from the moment one submits a transaction to the network, and Indexer Framework-based indexer picks it up, where the finalization time contributes the most of the delay. In real life scenario, dApps usually need to know the result of the execution, and so it will take a couple of blocks after the transaction is included to get all the receipts executed (read more about the data flow [here](../data-flow/near-data-flow.md)), so the delay between the transaction submission and the result being observed by an indexer could be 5-7 seconds.

## Current Status

Indexer Framework is a tool that provides a straightforward way of getting a stream of finalized NEAR Protocol blocks as soon as possible operating over a decentralized NEAR Protocol peer-to-peer network.

However, in our experiments with the Indexer ecosystem, we realized that we need a lightweight foundation to build micro-indexers instead of maintaining a full [nearcore](https://github.com/near/nearcore) node. We considered various solutions to deliver events (Kafka, RabbitMQ, etc), but ultimately we decided to dump all the blocks as is to AWS S3 bucket. This is where NEAR Lake ecosystem was born, learn more about it [here](near-lake-framework.md).

These days, we use NEAR Indexer Framework to implement [NEAR Lake Indexer](https://github.com/near/near-lake-indexer) and from there we build micro-indexers based on [NEAR Lake Framework](near-lake-framework.md). Said that, Indexer Framework plays a crucial role in the ecosystem even though most of the indexers these days are implemented without using it directly.

## Applications

See the [example](https://github.com/nearprotocol/nearcore/tree/master/tools/indexer/example) for further technical details.

- [`near-examples/indexer-tx-watcher-example`](https://github.com/near-examples/indexer-tx-watcher-example) NEAR Indexer example that watches for transaction for specified accounts/contracts

:::info NEAR Indexer Framework usage

The most famous project build on top of NEAR Indexer Framework is [NEAR Indexer for Explorer](/tools/indexer-for-explorer)

:::

'''
'''--- docs/1.concepts/3.advanced/near-lake-framework.md ---
---
sidebar_label: "Lake Framework"
---

# NEAR Lake Framework

:::note GitHub repo

https://github.com/near/near-lake-framework/

:::

## Description

NEAR Lake Framework is an ecosystem of library companions to [NEAR Lake](/tools/realtime#near-lake-indexer). They allow you to build your own indexer that subscribes to the stream of blocks from the [NEAR Lake](/tools/realtime#near-lake-indexer) data source and create your own logic to process the NEAR Protocol data in the programming languages of your choice (at the moment, there are implementations in [Python](http://pypi.org/project/near-lake-framework), [JavaScript](https://www.npmjs.com/package/near-lake-framework), and [Rust](https://crates.io/crates/near-lake-framework)).

:::tip NEAR Lake Framework announcement

We have announced the release of NEAR Lake Framework on NEAR Governance Forum.

Please, read the post [there](https://gov.near.org/t/announcement-near-lake-framework-brand-new-word-in-indexer-building-approach/17668).

:::

## How does it compare to [NEAR Indexer Framework](near-indexer-framework.md)?

Feature | Indexer Framework | Lake Framework
------- | ----------------- | --------------
Allows to follow the blocks and transactions in the NEAR Protocol | **Yes** | **Yes**<br />(but only mainnet and testnet networks)
Decentralized | **Yes** | No<br />(Pagoda Inc dumps the blocks to AWS S3)
Reaction time (end-to-end) | [minimum 3.8s (estimated average 5-7s)](near-indexer-framework.md#limitations) | [minimum 3.9s (estimated average 6-8s)](#limitations)
Reaction time (framework overhead only) | 0.1s | 0.2-2.2s
Estimated cost of infrastructure | [$500+/mo](https://near-nodes.io/rpc/hardware-rpc) | [**$20/mo**](#what-is-the-cost-of-running-a-custom-indexer-based-on-near-lake)
Ease of maintenance | Advanced<br />(need to follow every nearcore upgrade, and sync state) | **Easy**<br />(deploy once and forget)
How long will it take to start? | days (on mainnet/testnet) | **seconds**
Ease of local development | Advanced<br />(localnet is a good option, but testing on testnet/mainnet is too heavy) | **Easy**<br />(see [tutorials](/build/data-infrastructure/lake-framework/near-lake-state-changes-indexer))
Programming languages that a custom indexer can be implemented with | Rust only | **Any**<br />(currently, helper packages are released in [Python](http://pypi.org/project/near-lake-framework), [JavaScript](https://www.npmjs.com/package/near-lake-framework), and [Rust](https://crates.io/crates/near-lake-framework))

## Limitations

Lake Framework relies on the data being dumped to AWS S3 from [NEAR Lake Indexer](https://github.com/near/near-lake-indexer) which is based on [NEAR Indexer Framework](near-indexer-framework.md). Thus, Lake Framework is centralized around AWS S3 storage and also around maintainers of NEAR Lake Indexer nodes (Pagoda Inc). This is the tradeoff you might still want to take given all the other benefits mentioned above.

Indexers based on the Lake Framework inherit [the latency characteristics of Indexer Framework](near-indexer-framework.md#limitations) and extra latency of dumping to and reading from AWS S3, which is estimated to add at least 50ms delay while writing to S3, and 50ms on polling and reading from S3 (to make the polling cost-efficient, we default to polling only every 2s, so in the worst case you may observe an additional 2-second latency). Thus, Lake Framework adds 0.1-2.1s latency on top of Indexer Framework. Yet, again, most of the latency is there due to the finalization delay and both Indexer Framework and Lake Framework add quite a minimum overhead.

## What is the cost of running a custom indexer based on NEAR Lake?

Indexers based on NEAR Lake consume 100-500MB of RAM depending on the size of the preloading queue, it does not require any storage, and it can potentially run even on Raspberry PI.

Getting the blockchain data from S3 will cost around $18.15 per month as NEAR Lake configured S3 buckets in such a way that the reader is paying the costs.

### AWS S3 cost breakdown

Assuming NEAR Protocol produces exactly 1 block per second (which is really not, the average block production time is 1.3s). A full day consists of 86400 seconds, that's the max number of blocks that can be produced.

According the [Amazon S3 prices](https://aws.amazon.com/s3/pricing/?nc1=h_ls) `list` requests are charged for $0.005 per 1000 requests and `get` is charged for $0.0004 per 1000 requests.

Calculations (assuming we are following the tip of the network all the time):

```
86400 blocks per day * 5 requests for each block / 1000 requests * $0.0004 per 1k requests = $0.173 * 30 days = $5.19
```
**Note:** 5 requests for each block means we have 4 shards (1 file for common block data and 4 separate files for each shard)

And a number of `list` requests we need to perform for 30 days:

```
86400 blocks per day / 1000 requests * $0.005 per 1k list requests = $0.432 * 30 days = $12.96

$5.19 + $12.96 = $18.15
```

Note, the price depends on the number of shards.

## Examples & Tutorials

- [`near-examples/near-lake-raw-printer`](https://github.com/near-examples/near-lake-raw-printer): simple example of a data printer built on top of NEAR Lake Framework
- [`near-examples/near-lake-accounts-watcher`](https://github.com/near-examples/near-lake-accounts-watcher): source code for a video tutorial on how to use the NEAR Lake Framework
- [`near-examples/indexer-tx-watcher-example-lake`](https://github.com/near-examples/indexer-tx-watcher-example-lake) indexer example that watches for transaction for specified accounts/contracts build on top of NEAR Lake Framework

:::note Tutorials

See [Tutorials page](/build/data-infrastructure/lake-framework/near-lake-state-changes-indexer)

:::

'''
'''--- docs/1.concepts/3.advanced/specification.md ---
---
id: specification
title: NEAR Protocol Specification
sidebar_label: Specification
---

NEAR Protocol Specifications and Standards are tracked in two places:

- NEAR Protocol Specification Documentation: [ [Nomicon.io](https://nomicon.io) ] 
- NEAR Enhancement Proposals GitHub Repository: [ [NEAR NEPs](https://github.com/near/NEPs) ]

'''
'''--- docs/1.concepts/3.advanced/virtual_machine.md ---
---
id: vm
title: Virtual Machine
---

Talk about execution here
'''
'''--- docs/1.concepts/abstraction/chain-signatures.md ---
---
id: chain-signatures
title: What are Chain Signatures?
sidebar_label: What are Chain Signatures?
---

Chain signatures enable NEAR accounts, including smart contracts, to sign and execute transactions across many blockchain protocols.

This unlocks the next level of blockchain interoperability by giving ownership of diverse assets, cross-chain accounts, and data to every single NEAR account.

![chain-signatures](/docs/assets/welcome-pages/chain-signatures-overview.png)
_Diagram of a chain signature in NEAR_

:::info Looking for code?
To get started using Chain Signatures in your project see **[Create a Chain Signature](../../2.build/1.chain-abstraction/chain-signatures.md)**.
:::

:::caution
This technology is currently in `alpha` and should only be used in a `testnet` environment.
:::

---

## How It Works

Controlling accounts and their assets on other blockchain platforms is made possible thanks to the interaction between three elements:

1. [**Derivation Paths**](#derivation-paths-one-account-multiple-chains) - A deterministic way to derive foreign addresses from one NEAR account
2. [**Multichain Smart Contract**](#multichain-smart-contract) - Receives requests to sign a transaction for other blockchains
3. [**Multiparty Computation Service**](#multi-party-computation-service) Third-party service providing signatures to the contract

<hr class="subsection" />

### Derivation Paths: One Account, Multiple Chains

Chain Signatures link NEAR accounts to addresses in other blockchain using [Additive Key Derivation](https://eprint.iacr.org/2021/1330) (a simple mechanism for deriving many subkeys from a single master key). These keys are generated using `derivation paths` (or `paths` for short).

A `derivation path` is simply a string (e.g. `ethereum-1`, `ethereum-2`, etc) that in conjunction with the NEAR account derives a unique address on the target blockchain.

For example, we can derive multiple Ethereum addresses from `example.near` by using different paths:

  1. `example.near` + `ethereum-1` = `0x1b48b83a308ea4beb845db088180dc3389f8aa3b`
  2. `example.near` + `ethereum-2` = `0x99c5d3025dc736541f2d97c3ef3c90de4d221315`
  3. `example.near` + `...` = `0x...`

It is important to note that this allows us to discover the **public address** of the foreign account that we can control. To actually control the foreign account, we need to request signatures from the MPC service.

:::tip
In practice, the external address is deterministically derived using the NEAR address (`example.near`), the path (`ethereum-1`) and the MPC service's public key
:::

:::info
See [**Create a Chain Signature - how the derivation is implemented**](../../2.build/1.chain-abstraction/chain-signatures.md#1-deriving-the-foreign-address) for an example implementation
:::

<hr class="subsection" />

### Multichain Smart Contract

A deployed multichain smart contract is used to request signatures for transactions on other blockchains.

This contract has a `sign` method that takes two parameters:

  1. The `payload` (transaction) to be signed for the target blockchain
  2. The `path` that identifies the account you want to use to sign the transaction.

For example, a user could request a signature to `send 0.1 ETH to 0x060f1...` **(transaction)** using the `ethereum-1` account **(path)**.

After a request is made, the `sign` method starts recursively calling itself to wait while the [MPC signing service](#multi-party-computation-service-mpc) signs the transaction.

Once the signature is ready, the contract gains access to it and returns it to the user. This signature is a valid signed transaction that can be readily sent to the target blockchain to be executed.

<details>
<summary> A Contract Recursively Calling Itself? </summary>

NEAR smart contracts are unable to halt execution and await the completion of a process. To solve this, one can make the contract call itself again and again checking on each iteration to see if the result is ready.

**Note:** Each call will take one block which equates to ~1 second of waiting. After some time the contract will either return a result that an external party provided or return an error running out of GAS waiting.

</details>

:::info
See [**Create a Chain Signature - requesting the signature**](../../2.build/1.chain-abstraction/chain-signatures.md#3-requesting-the-signature) for an example implementation
:::

<hr class="subsection" />

### Multi-Party Computation Service

The essence of Multi-Party Computation (MPC) is to enable independent parties to perform shared computations on private information without revealing secrets to each other. In practice, this system can be used with blockchain platforms to safely sign a transaction on behalf of a user without ever having to expose a private key.

NEAR's MPC service is comprised of several independent nodes, **none of which can sign by itself**, but instead create **signature-shares** that are **aggregated through multiple rounds** to **jointly** sign a transaction.

This service continuously listens for signature requests (i.e. users calling the `sign` method on the `multichain` smart contract) and when a call is detected the MPC service:

  1. Asks its nodes to jointly derive a signature for the `payload` using the account identified by the `path`
  2. Once complete, call the `multichain` contract to store the resulting `Signature`

:::info A Custom MPC Service
Generally, MPC signing services work by sharing a master key, which needs to be re-created each time a node joins or leaves.

NEAR's MPC service allows for nodes to safely join and leave, without needing to re-derive a master key
:::

:::tip
Want to learn more about the mathematics that enable MPC? [**Check this awesome article**](https://www.zellic.io/blog/mpc-from-scratch/)
:::

---

## Concluding Remarks

Chain Signatures are a powerful tool that allows NEAR accounts to control accounts on other blockchains. This is a fundamental step towards enabling true ownership of cross-chain data and assets.

For the user, the process is made completely **on chain**, since they only need to make a call to a smart contract and wait for the response.

Thanks to `derivation paths`, a single NEAR account can control **multiple accounts** on different blockchains, and thanks to the MPC service, the user can be sure that **nobody but themselves** can request signatures for those accounts.

'''
'''--- docs/1.concepts/abstraction/meta-tx.md ---
---
id: meta-transactions
title: Meta Transactions
---

# Meta Transactions

[NEP-366](https://github.com/near/NEPs/pull/366) introduced the concept of meta
transactions to Near Protocol. This feature allows users to execute transactions
on NEAR without owning any gas or tokens. In order to enable this, users
construct and sign transactions off-chain. A third party (the relayer) is used
to cover the fees of submitting and executing the transaction.

## Overview

![Flow chart of meta
transactions](https://raw.githubusercontent.com/near/NEPs/003e589e6aba24fc70dd91c9cf7ef0007ca50735/neps/assets/nep-0366/NEP-DelegateAction.png)
_Credits for the diagram go to the NEP authors Alexander Fadeev and Egor
Uleyskiy._

The graphic shows an example use case for meta transactions. Alice owns an
amount of the fungible token `$FT`. She wants to transfer some to John. To do
that, she needs to call `ft_transfer("john", 10)` on an account named `FT`.

The problem is, Alice has no NEAR tokens. She only has a NEAR account that
someone else funded for her and she owns the private keys. She could create a
signed transaction that would make the `ft_transfer("john", 10)` call. But
validator nodes will not accept it, because she does not have the necessary Near
token balance to purchase the gas.

With meta transactions, Alice can create a `DelegateAction`, which is very
similar to a transaction. It also contains a list of actions to execute and a
single receiver for those actions. She signs the `DelegateAction` and forwards
it (off-chain) to a relayer. The relayer wraps it in a transaction, of which the
relayer is the signer and therefore pays the gas costs. If the inner actions
have an attached token balance, this is also paid for by the relayer.

On chain, the `SignedDelegateAction` inside the transaction is converted to an
action receipt with the same `SignedDelegateAction` on the relayer's shard. The
receipt is forwarded to the account from `Alice`, which will unpacked the
`SignedDelegateAction` and verify that it is signed by Alice with a valid Nonce,
etc. If all checks are successful, a new action receipt with the inner actions
as body is sent to `FT`. There, the `ft_transfer` call finally executes.

## Relayer

Meta transactions only work with a [relayer](relayers.md). This is an application layer
concept, implemented off-chain. Think of it as a server that accepts a
`SignedDelegateAction`, does some checks on them and eventually forwards it
inside a transaction to the blockchain network.

A relayer may choose to offer their service for free but that's not going to be
financially viable long-term. But they could easily have the user pay using
other means, outside of Near blockchain. And with some tricks, it can even be
paid using fungible tokens on Near.

In the example visualized above, the payment is done using $FT. Together with
the transfer to John, Alice also adds an action to pay 0.1 $FT to the relayer.
The relayer checks the content of the `SignedDelegateAction` and only processes
it if this payment is included as the first action. In this way, the relayer
will be paid in the same transaction as John. 

:::warning Keep in mind
The payment to the relayer is still not guaranteed. It could be that
Alice does not have sufficient `$FT` and the transfer fails. To mitigate, the
relayer should check the `$FT` balance of Alice first.
:::

Unfortunately, this still does not guarantee that the balance will be high
enough once the meta transaction executes. The relayer could waste NEAR gas
without compensation if Alice somehow reduces her $FT balance in just the right
moment. Some level of trust between the relayer and its user is therefore
required.

## Limitations

### Single receiver

A meta transaction, like a normal transaction, can only have one receiver. It's
possible to chain additional receipts afterwards. But crucially, there is no
atomicity guarantee and no roll-back mechanism.

### Accounts must be initialized 

Any transaction, including meta transactions, must use NONCEs to avoid replay
attacks. The NONCE must be chosen by Alice and compared to a NONCE stored on
chain. This NONCE is stored on the access key information that gets initialized
when creating an account. 

## Constraints on the actions inside a meta transaction

A transaction is only allowed to contain one single delegate action. Nested
delegate actions are disallowed and so are delegate actions next to each other
in the same receipt.

## Gas costs for meta transactions

Meta transactions challenge the traditional ways of charging gas for actions.
Let's assume Alice uses a relayer to
execute actions with Bob as the receiver.

1. The relayer purchases the gas for all inner actions, plus the gas for the
   delegate action wrapping them.
2. The cost of sending the inner actions and the delegate action from the
   relayer to Alice's shard will be burned immediately. The condition `relayer
   == Alice` determines which action `SEND` cost is taken (`sir` or `not_sir`).
   Let's call this `SEND(1)`.
3. On Alice's shard, the delegate action is executed, thus the `EXEC` gas cost
   for it is burned. Alice sends the inner actions to Bob's shard. Therefore, we
   burn the `SEND` fee again. This time based on `Alice == Bob` to figure out
   `sir` or `not_sir`. Let's call this `SEND(2)`.
4. On Bob's shard, we execute all inner actions and burn their `EXEC` cost.

Each of these steps should make sense and not be too surprising. But the
consequence is that the implicit costs paid at the relayer's shard are
`SEND(1)` + `SEND(2)` + `EXEC` for all inner actions plus `SEND(1)` + `EXEC` for
the delegate action. This might be surprising but hopefully with this
explanation it makes sense now!

## Gas refunds in meta transactions

Gas refund receipts work exactly like for normal transaction. At every step, the
difference between the pessimistic gas price and the actual gas price at that
height is computed and refunded. At the end of the last step, additionally all
remaining gas is also refunded at the original purchasing price. The gas refunds
go to the signer of the original transaction, in this case the relayer. This is
only fair, since the relayer also paid for it.

## Balance refunds in meta transactions

Unlike gas refunds, the protocol sends balance refunds to the predecessor
(a.k.a. sender) of the receipt. This makes sense, as we deposit the attached
balance to the receiver, who has to explicitly reattach a new balance to new
receipts they might spawn.

In the world of meta transactions, this assumption is also challenged. If an
inner action requires an attached balance (for example a transfer action) then
this balance is taken from the relayer.

The relayer can see what the cost will be before submitting the meta transaction
and agrees to pay for it, so nothing wrong so far. But what if the transaction
fails execution on Bob's shard? At this point, the predecessor is `Alice` and
therefore she receives the token balance refunded, not the relayer. This is
something relayer implementations must be aware of since there is a financial
incentive for Alice to submit meta transactions that have high balances attached
but will fail on Bob's shard.

## Function access keys in meta transactions

Function access keys can limit the allowance, the receiving contract, and the
contract methods. The allowance limitation acts slightly strange with meta
transactions.

But first, both the methods and the receiver will be checked as expected. That
is, when the delegate action is unwrapped on Alice's shard, the access key is
loaded from the DB and compared to the function call. If the receiver or method
is not allowed, the function call action fails.

For allowance, however, there is no check. All costs have been covered by the
relayer. Hence, even if the allowance of the key is insufficient to make the call
directly, indirectly through meta transaction it will still work.

This behavior is in the spirit of allowance limiting how much financial
resources the user can use from a given account. But if someone were to limit a
function access key to one trivial action by setting a very small allowance,
that is circumventable by going through a relayer. An interesting twist that
comes with the addition of meta transactions.

'''
'''--- docs/1.concepts/abstraction/mpc.md ---
---
id: mpc
title: Multi-Party Computation (MPC)
---

MPC, or multi-party computation, is about how multiple parties can do shared computations on private inputs without revealing the private data.

As an example, suppose two investors want to compare who holds more crypto tokens without revealing their account balances. MPC can solve this situation, by computing the function `f(x > y)`, where `x` and `y` are private inputs. Each person would submit a private value, and would get the function `x > y` result.

In general, MPC can be used to build all kinds of useful protocols, like threshold cryptography, dark pools, and private auctions. For example, MPC can be used to jointly encrypt a message, with the key split up among many different parties.

<details>
<summary> MPC versus key splitting</summary>
In secret sharing, the key has to get reassembled. At some point, some trusted party is going to have the entire key available to them. With MPC, the whole operation is done in MPC, meaning there's no point where the combined key could be extracted.
</details>

:::info
Want to learn more about multi-party computation? Check [this article](https://www.zellic.io/blog/mpc-from-scratch/).
:::

---

## MPC signature generation

- MPC nodes are doing a multistep process called signature generation.
- They are doing it by using user key shares derived from their root key shares.
- A root key is never reconstructed, but protocol allows to create signatures using it‚Äôs shares.

:::info
Using MPC, the root key is never reconstructed and it‚Äôs never available. User key is never reconstructed as well.
:::

## How MPC creates a new key

- Once MPC account verification is complete, a root key becomes available to sign a new signature that creates a new key
- This new key is created using [Additive Key Deriviation](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#specification-key-derivation) (a mechanism for deriving many _sub-keys_ from a single _master key_)
- This new sub-key can now be used to sign a payload for a given account associated with a given blockchain
'''
'''--- docs/1.concepts/abstraction/relayers.md ---
---
id: relayers
title: Relayers
---

A relayer is a simple web service that receives signed transactions from NEAR users, and relays them to the network while attaching tokens to sponsor their GAS expenses. This can be useful to create applications in which the users are not required to purchase NEAR in order to be able to transact. In this document we present a high-level overview on how relayers work. Please check the [build a relayer](../../2.build/welcome.md) page if you want to learn how to build your own relayer.

---

## How it works

![relayer-overview](/docs/assets/welcome-pages/relayer-overview.png)

Relayers are a natural consequence of [Meta Transactions](meta-tx.md) ([NEP-366](https://github.com/near/NEPs/blob/master/neps/nep-0366.md)), a special type of transaction that can be best understood as an intent.

The user expresses: _"I want to do a specific action on chain"_ and signs this intent **off-chain**, but does not send it to the network. Instead, they send the intent to a `Relayer`, which wraps the message into an actual transaction, attaches the necessary funds, and sends it to the network.

<details>
<summary> Technical Details </summary>

Technically, the end user (client) creates a `SignedDelegateAction` that contains the data necessary to construct a `Transaction`, signs the `SignedDelegateAction` using their key, and send it to  the relayer service.

When the request is received, the relayer uses its own key to sign a `Transaction` using the fields in the `SignedDelegateAction` as input to create a `SignedTransaction`.

The `SignedTransaction` is then sent to the network via RPC call, and the result is sent back to the client. The `Transaction` is executed in such a way that the relayer pays the GAS fees, but all actions are executed as if the user had sent the transaction.
</details>

---

## Why use a Relayer?
There are multiple reasons to use a relayer:
1. Your users are new to NEAR and don't have any gas to cover transactions
2. Your users have an account on NEAR, but only have a Fungible Token Balance. They can now use the FT to pay for gas
3. As an enterprise or a large startup you want to seamlessly onboard your existing users onto NEAR without needing them to worry about gas costs and seed phrases
4. As an enterprise or large startup you have a user base that can generate large spikes of user activity that would congest the network. In this case, the relayer acts as a queue for low urgency transactions
5. In exchange for covering the gas fee costs, relayer operators can limit where users spend their assets while allowing users to have custody and ownership of their assets
6. Capital Efficiency: Without relayer if your business has 1M users they would have to be allocated 0.25 NEAR to cover their gas costs totalling 250k NEAR. However, only ~10% of the users would actually use the full allowance and a large amount of the 250k NEAR is just sitting there unused. So using the relayer, you can allocate 50k NEAR as a global pool of capital for your users, which can refilled on an as needed basis. 
'''
'''--- docs/1.concepts/abstraction/signatures/use-case.md ---
---
id: use-cases
title: Use cases for Chain Signatures
sidebar_label: Use cases
---

Chain signatures enable you to implement multichain and cross-chain workflows in a simple way.
Take a look at a few possible use cases:

---

## Trade Blockchain assets without transactions

Trading assets across different blockchains usually require using a bridge that supports them, bringing longer settlement times as the trades are not atomic and require confirmation on both blockchains.

Using Chain signatures, you can trade assets across chains simply swapping the ownership of NEAR accounts that control funds on different blockchains. For example, you could trade a NEAR account that controls a Bitcoin account with `X BTC` for another NEAR account that controls an Ethereum account with `Y ETH`.

This way, you can keep native tokens on their native blockchain (e.g., `BTC` on Bitcoin, `ETH` on Ethereum, `ARB` on Arbitrum) and trade them without bridges.
As an added bonus, trades are atomic across chains, settlement takes just 2 seconds, and supports any token on any chain.

:::tip Keep in mind

 There are transactions happening on different blockchains.
 The difference is that a [Multi-Party Computation service](../chain-signatures.md#multi-party-computation-service) (MPC) signs a transaction for you, and that transaction is then broadcast to another blockchain RPC node or API.

:::

For example, a basic trade flow could be:

1. Users create an account controlled by NEAR chain signatures
2. Users funds these accounts on the native blockchains (depositing)
3. Place orders by funding a new account for the total amount of the order
4. Another user accepts the order
5. Users swap control of the keys to fulfill the order

![docs](/docs/native-cross-chain.png)

<details>
- User A has `ETH` on the Ethereum blockchain, and wants to buy native Bitcoin
- User B wants to sell Bitcoin for Ethereum

**Steps**

1. User B, using NEAR, creates and funds a new account on Bitcoin with 1 `BTC`
2. User B, using the spot marketplace smart contract, signs a transaction to create a limit order. This transfers control of the Bitcoin account to the smart contract
3. User A creates a batch transaction with two steps
    - Creating and funding a new Ethereum account with 10 `ETH`
    - Accepting the order and atomically swapping control of the accounts
4. User A takes ownership of the Bitcoin account with 1 `BTC`, and User B takes ownership of the Ethereum account with 10 `ETH`
5. User A and B can _"withdraw"_ their asset from the order by transferring the assets to their respective _"main"_ accounts
</details>

---

## Oauth-controlled Blockchain accounts

On-boarding is a huge problem for decentralized applications. If you want widespread adoption you can't expect people to keep seed phrases safe in order to use an application.

An attractive way of managing Web3 accounts is to use existing Web2 accounts to on-board users. This can be done in the following way:

1. Deploy a NEAR contract that allows the bearer of a user's [JWT token](https://jwt.io/) to sign a blockchain transaction (Ethereum, Polygon, Avalanche, and others)
2. The user validates their identity with a third-party receiving a JWT Token
3. The user holding that token can interact with blockchain applications on Ethereum/Polygon/+++ via the NEAR contract for the duration of it's validity

Any method of controlling a NEAR account can also be used to control a cross-chain account.

:::info About JWT tokens
JSON Web Tokens are a standard RFC 7519 method for representing claims securely between two parties. They are used in this example to represent the claim that someone is the owner of an Oauth account.
:::

---

## Cross-chain Zero-friction onboarding

Using unique features of the NEAR account model, [Keypom](https://docs.keypom.xyz/) provides zero-friction onboarding and transactions on NEAR. They are generally used for NFT drops, FT drops, and ticketing.

A generic Keypom user-flow could be: 

1. The developer creates a restricted NEAR account
2. The account is funded with `NEAR`
3. The user receives a key with limited control of the account
4. The user uses the funded account to call controlled endpoints on NEAR
5. The user returns the remaining funds to the developer and their account is unlocked

:::tip
This allows easy on-boarding to decentralized apps. The accounts are initially restricted to prevent the user being able to simply withdraw the `NEAR` from the account. 
:::

## DeFi on Bitcoin (and other non-smart contract chains). 

Using chain signatures, smart contracts on NEAR can control externally-owned accounts on non-smart contract chains like Bitcoin, Dogecoin, XRP Ledger, Bittensor, Cosmos Hub, etc. This enables developers to use NEAR as a smart contract ‚Äúlayer‚Äù for chains that do not support this functionality natively.

For example, a developer can build a decentralized exchange for Bitcoin Ordinals, using a smart contract on NEAR to manage deposits (into Bitcoin addresses controlled by the contract) and to verify and execute swaps when two users agree to trade BTC for an Ordinal or BRC20 token.

Example:
1. Seller generates a deposit address on Bitcoin that is controlled by the marketplace smart contract on NEAR via chain signatures
2. Seller deposits a Bitcoin Ordinal to the deposit address
3. The Ordinal is listed for sale with a price and a pre-commitment signature from the seller
4. Buyer accepts the order, deposits USDC
5. The control of the Bitcoin Ordinal address is given to the buyer, USDC on NEAR is transferred to the seller

#### Using Chain Signatures

With Chain Signatures you can do the same but across many chains, for example Polygon:

1. The developer creates a restricted NEAR account with a key
2. The account is funded with `NEAR` and `MATIC`
3. The user receives a key with limited control of the account
4. The user uses the funded account to sign payloads calling controlled endpoints on Polygon
5. The user returns the remaining funds to the developer and their account is unlocked

This allows developers to pay for users to use arbitrary contracts on arbitrary chains.

---

## Decentralized Clients

A big problem in decentralized applications is that while the smart contracts are tamper-proof, the clients that access them generally are not. This allows practically complete control over any user account provided they are using the frontend assets that you serve. This has security, trust, and regulatory implications.

When smart contracts can sign payloads you can start using [signed exchanges](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#name-introduction) (or polyfills) to require HTTP exchanges to be signed by a certain key. If it is not signed with this key the SSL certificate is considered invalid. This means that individual users cannot be served invalid frontends without it being generally observable and non repudiable.

---

## Communication with private NEAR Shards

Companies like [Calimero](https://www.calimero.network/) offer private NEAR shards. Currently, sending messages to and from these NEAR shards is troublesome. If each shard had the ability to sign their message queues, they could be securely sent from one shard to another. Thus you could communicate bidirectionally with any shard as easily as you can with a contract on your own shard.

:::tip
This could also simplify NEAR's sharding model, by treating each NEAR shard like one would a private shard.
:::

'''
'''--- docs/1.concepts/abstraction/what-is.md ---
---
id: introduction
title: Chain Abstraction
sidebar_label: Introduction
---

Do you know how your favorite apps are built and which database they use?. Chances are not, since we choose apps based on their functionality, and not their underlying tech.

We believe that **same should be true for blockchain apps**, users should be able to enjoy an application, without the underlying tech hampering their experience. The user experience should be so good, that they don't realize they're using a blockchain.

![img](/docs/assets/welcome-pages/chain-abstraction-landing.png)

To help make this a reality, NEAR provides a set of services that allow to **abstract away** the blockchain from the user experience. This means that users can use blockchain-based application - both in NEAR and **other chains** - without needing to understand the technical details.

---

## Abstraction services

Through a combination of multiple technologies, NEAR allows to create a seamless flow, in which users can use their email to create an account, use such account without acquiring funds, and even control accounts across multiple chains.

This is achieved through a combination of multiple services:

- **Relayers**: A service that allows developers to subsidize gas fees for their users.
- **FastAuth**: A service that allows users to create and recover accounts using their email address through multi-party computation (MPC).
- **Multi-chain signatures**: A service that allows users to use their NEAR account to sign transactions in other chains.

---

## A holistic view

The combination of these services allows to create a **seamless** user experience, in which users can use blockchain-based applications without realizing they are using a blockchain.

Users will simply login with an email, and a **zero-fund** account will be created for them. No seed phrases to remember, no private keys to safe keep, and no need to acquire funds.

Once having their account, apps can ask the user to create meta-transactions and send them to any relayer. The relayer will pass the transaction to the network, attaching NEAR to pay for the execution fees. The transaction will then be executed as if the user had sent it, since the relayer is only there to attach NEAR to the submission.   

If the user wants to interact with other blockchain, they can use their account to interact with a multi-chain signature relayer, which will relay the transaction to the right network, covering GAS fees.

As an example, this would allow users to collect NFTs across different chains, without ever needing to explicitly create an account or acquire crypto. All with just a single email login.

'''
'''--- docs/1.concepts/basics/epoch.md ---
---
id: epoch
title: Epoch
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

An **epoch** is a unit of time when validators of the network remain constant. It is measured in blocks:

- Both `testnet` and `mainnet` have an epoch duration of 43,200 blocks. Ideally epochs last about 12 hours, since blocks are created every second (in reality, they take slightly longer to be created).
- You can view this setting by querying the **[`protocol_config`](/api/rpc/setup#protocol-config)** RPC endpoint and searching for `epoch_length`.

**Note:** Nodes garbage collect blocks after 5 epochs (~2.5 days) unless they are [archival nodes](https://near-nodes.io/intro/node-types#archival-node).

**Example:**

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_protocol_config",
  "params": {
    "finality": "final"
  }
}
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_protocol_config \
  params:='{
    "finality": "final"
  }'
```

</TabItem>
</Tabs>

**Example Response:**

```json
{
    "jsonrpc": "2.0",
    "result": {
        "protocol_version": 44,
        "genesis_time": "2020-07-21T16:55:51.591948Z",
        "chain_id": "mainnet",
        "genesis_height": 9820210,
        "num_block_producer_seats": 100,
        "num_block_producer_seats_per_shard": [
            100
        ],
        "avg_hidden_validator_seats_per_shard": [
            0
        ],
        "dynamic_resharding": false,
        "protocol_upgrade_stake_threshold": [
            4,
            5
        ],
        "epoch_length": 43200,
        "gas_limit": 1000000000000000,
        "min_gas_price": "1000000000",
        "max_gas_price": "10000000000000000000000",
        "block_producer_kickout_threshold": 90,
        "chunk_producer_kickout_threshold": 90,

// ---- snip ----
}
```

You can learn more about how epochs are used to manage network validation in the [Validator FAQ](https://github.com/near/wiki/blob/master/Archive/validators/faq.md#what-is-an-epoch).

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol"> Ask it on StackOverflow! </a>
:::

'''
'''--- docs/1.concepts/basics/networks.md ---
---
id: networks
title: NEAR Networks
sidebar_label: Networks
---

NEAR Protocol operates on several networks each operating with their own independent validators and unique state. These networks are as follows:

- [`mainnet`](/concepts/basics/networks#mainnet)
- [`testnet`](/concepts/basics/networks#testnet)
- [`localnet`](/concepts/basics/networks#localnet)

## Mainnet {#mainnet}

`mainnet` is for production ready smart contracts and live token transfers. Contracts ready for `mainnet` should have gone through rigorous testing and independent security reviews if necessary. `mainnet` is the only network where state is guaranteed to persist over time _(subject to the typical security guarantees of the network's validation process)_.

- Status: `https://rpc.mainnet.near.org/status`
- [ [NearBlocks Explorer](https://nearblocks.io) ]
- [ [Wallet](https://wallet.near.org) ]
- [ [Data Snapshots](https://near-nodes.io/intro/node-data-snapshots) ]

## Testnet {#testnet}

`testnet` is a public network and the final testing network for `nearcore` changes before deployment to `mainnet`. `testnet` is intended for testing all aspects of the NEAR platform prior to `mainnet` deployment. From account creation, mock token transfers, development tooling, and smart contract development, the `testnet` environment closely resembles `mainnet` behavior. All `nearcore` changes are deployed as release candidates on first testnet, before the changes are released on `mainnet`. A number of `testnet` validators validate transactions and create new blocks. dApp developers deploy their applications on `testnet` before deploying on `mainnet`. It is important to note that `testnet` has its own transactions and states.

- Status: `https://rpc.testnet.near.org/status`
- [ [Explorer](https://testnet.nearblocks.io) ]
- [ [Wallet](https://testnet.mynearwallet.com/) ]
- [ [Data Snapshots](https://near-nodes.io/intro/node-data-snapshots) ]

## Localnet {#localnet}

`localnet` is intended for developers who want to work with the NEAR platform independent of the public blockchain. You will need to generate nodes yourself. `localnet` gives you the total control over accounts, economics, and other factors for more advanced use cases (including making changes to `nearcore`). For developers, `localnet` is the right choice if you prefer to avoid leaking information about your work during the development process.

More on local development [here](https://near-nodes.io/validator/running-a-node)

`near-cli` [network selection](/tools/near-cli#network-selection) variable is `local`

---

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol">
<h8>Ask it on StackOverflow!</h8>
</a>
:::

'''
'''--- docs/1.concepts/basics/overview.md ---
---
id: overview
title: Quick Overview
---

Lets start with a quick overview of the different elements that compose the NEAR blockchain.

---

## Accounts

NEAR uses human-readable account names such as `alice.near` or `bob.near` instead of a public hash such as`0x71C7656EC7ab88b098defB751B7401B5f6d8976F`. 

These accounts also have the permission to create subaccounts such as `nft.alice.near` or `example2.bob.near`. It's important to know that only the root account can create the subaccount. So only `alice.near` can create `nft.alice.near` and only `nft.alice.near` can create `example.nft.alice.near`. Note that `alice.near` ***does not*** have permission to create `example.nft.alice.near`. Only the direct parent account has permission to create a subaccount.

:::tip
For more information see the **[accounts section](/concepts/protocol/account-model)**.
:::

<hr className="subsection" />

## Keys

On most blockchains, there is one [public/private key pair](https://en.wikipedia.org/wiki/Public-key_cryptography) per account. On NEAR, each account can have many key pairs associated with them which we call "Access Keys". There are two types of "Access Keys":

- [Full Access](/concepts/protocol/access-keys#full-access-keys) _(Grants full control to the account)_
- [Function Call](/concepts/protocol/access-keys#function-call-keys) _(Allows for only non-monetary transaction signing)_

Full access keys allow for full control of the account. You can send funds, create sub-accounts, delete the account, and more. Function call keys only allow for calling certain methods on a specific smart contract that **do not** allow the transferring of funds. These keys can be used by dApp developers to allow users to sign simple transactions that mutate state on the blockchain without having to constantly re-direct to the user's wallet to prompt for authorization. They can be widely or narrowly scoped depending on the use case.

:::tip
For more information see the **[access keys section](/concepts/protocol/access-keys)**.
:::

<hr className="subsection" />

### Contracts

Every NEAR account can hold **a** smart contract, which is a small piece of logic embedded directly in the account. Smart contracts in NEAR can be developed using either Javascript or [Rust](https://www.rust-lang.org/). Smart contracts that have been deployed can be [updated](/sdk/rust/building/prototyping) at any time but not removed. This is where [sub-accounts](#concepts/protocol/account-model#subaccounts) can come in handy. NEAR allows users to organize and create a hierarchy for their accounts. 

As an example, benji could have the root account `benji.near`. He then stores all his NFT contracts as sub-accounts of `nft.benji.near`. For example, he worked on a cool lazy minting contract deployed to `lazy.nft.benji.near`. This not only allows for better organization but it allows developers to easily delete and re-create accounts in order to clear state.

:::tip
For more information see a guide on **[deploying contracts](/sdk/rust/promises/deploy-contract)**.
:::

<hr className="subsection" />

### Storage

Any information that is stored on NEAR is accounted for using a mechanism called [storage staking](/concepts/storage/storage-staking). In short, an account must maintain a certain balance that is locked in order to cover the cost of storage. If that storage is released, the funds become available once again. This is why named account IDs on NEAR cost an initial deposit to create. If you attempt to store state on-chain without having the necessary balance in your account to cover the cost, an error will be thrown which will tell you to add more NEAR to your account.

:::tip
For more information on storage staking, see the **[storage staking section](/concepts/storage/storage-staking)**.
:::
'''
'''--- docs/1.concepts/basics/protocol.md ---
---
id: protocol
title: What is NEAR?
sidebar_label: ‚≠ê What is NEAR?
---

NEAR is a **user-friendly** and [**carbon-neutral**](https://near.org/blog/near-climate-neutral-product/) blockchain, built to be [fast, secure, and able to grow without limits](https://www.leewayhertz.com/comparison-of-blockchain-protocols#Parallel-comparison-of-various-blockchain-networks).

![img](@site/static/docs/assets/welcome-pages/protocol.png)

NEAR is the **blockchain for everyone**.

<details>
<summary> What do these Technical Terms mean? </summary>

In technical terms, NEAR is a [layer-one](https://coinmarketcap.com/academy/glossary/layer-1-blockchain), [sharded](https://near.org/blog/near-launches-nightshade-sharding-paving-the-way-for-mass-adoption), [proof-of-stake](https://en.wikipedia.org/wiki/Proof_of_stake) blockchain built with usability in mind. 

[Layer-1](https://coinmarketcap.com/academy/glossary/layer-1-blockchain) means NEAR is the foundation that supports everything else built on it. It keeps all the transaction records safe and unchangeable which keeps the network secure and trustworthy.

[Sharded](https://near.org/blog/near-launches-nightshade-sharding-paving-the-way-for-mass-adoption) means the network is broken into pieces that work in parallel. This helps NEAR process transactions quickly and efficiently.

[Proof-of-stake](https://en.wikipedia.org/wiki/Proof_of_stake) uses less electricity compared with other blockchains which use proof-of-work. Users show they own NEAR tokens to help run the network. This makes it cheaper and lets more people use it.
</details>

---

## Why Choose NEAR? {#why-build-on-near}
NEAR is a technical marvel, offering built-in features such as named accounts and account abstraction. For developers, NEAR offers everything needed for their applications, from smart contracts to indexers. All while being interoperable with other chains.

### ‚≠ê Simple to Use 
1. Use [**named accounts**](../protocol/account-model.md) like `alice.near`
2. Simple sign-up: make an account using [email](https://near.org/signup) or [telegram](https://web.telegram.org/k/#@herewalletbot)
3. Transactions are **fast** _(~1.3s transactions)_ and **cheap** _(< 1¬¢ in fees)_
4. You don't need to buy crypto thanks to **built-in account abstraction**
5. [Access Keys](../protocol/access-keys.md) make it safe and easy to use.
6. Control accounts on **other chains** thanks to [chain signatures](../abstraction/chain-signatures.md)

### üõ°Ô∏è Battle-Tested 
1. 4 years of **100% uptime** with more than [**800M** transactions](https://pikespeak.ai/near-world/overview) processed
2. NEAR has sustained peaks of [>13M transactions](https://pikespeak.ai/near-world/overview) in a day
3. In March 2024, the top three monthly [dApps](https://dappradar.com/rankings?range=30d), based on unique active wallets, were built on NEAR:
    - [Kai-ching](https://cosmose.ai/)
    - [Sweat](https://sweateconomy.com/)
    - [Hot Wallet](https://t.me/herewalletbot/)

### üßë‚Äçüíª Great Developer Experience
1. Build smart contracts with **Javascript** or **Rust**
2. **Simple onboarding**, thanks to its complete documentation and examples
3. Get answers and learn at NEAR DevRel **office hours**, where anybody can participate
4. Earn from your contract's gas fees
5. **EVM compatible** with [Project Aurora](http://www.aurora.dev) _(Deploy your Solidity contracts with ease)_

### ‚ôªÔ∏è Environmentally Friendly
1. NEAR is **[certified carbon-neutral](https://near.org/blog/the-near-blockchain-is-climate-neutral/)**
2. NEAR **consumes in a year** the same energy [**bitcoin consumes in 3 minutes**](https://medium.com/nearprotocol/how-near-went-carbon-neutral-e656db96da47#:~:text=The%20firm%20found%20that%20NEAR,PoS%20technology%20instead%20of%20PoW)

'''
'''--- docs/1.concepts/basics/runtime.md ---
---
id: runtime
title: Runtime
---

This section contains videos that explore the core Runtime, its operation, and how it implements cross-contract calls.

## Runtime Overview

An in-depth code overview of NEAR Runtime.

<iframe
  width="560"
  height="315"
  src="https://www.youtube-nocookie.com/embed/Xi_8PapFCjo"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen>
</iframe>

## Runtime Action and Data Receipts

An in-depth code review of how NEAR Runtime implements cross contract calls.

<iframe
  width="560"
  height="315"
  src="https://www.youtube-nocookie.com/embed/RBb3rJGtqOE"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen>
</iframe>

## Runtime State

An in-depth overview of how NEAR runtime operates with its state.

<iframe
  width="560"
  height="315"
  src="https://www.youtube-nocookie.com/embed/JCkSNL4ie1U"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen>
</iframe>

'''
'''--- docs/1.concepts/basics/technical_stuff.md ---
Interaction with NEAR is done with [JSON RPC API](../../5.api/rpc/introduction.md) via HTTP calls.

With the API, you can call smart contracts, send transactions, manage keys and get information about blockchain data and status.

The NEAR CLI abstracts some actions, such as deploying a contract, but eventually, all actions are done via JSON RPC.

:::info
We recommend using the CLI for deploying contracts. In a CI/CD environment, you can write a shell script to utilize the CLI for deployments.
:::

### API requests flow

There are different types of [Nodes on NEAR](./validators.md): RPC Nodes, Validators, and Archival Nodes.

When calling an endpoint on `near.org`, it resolves to a server that chooses an available RPC node to handle the request.
Then the RPC node passes the request to an available Validator node. Finally, the validator node spawns a VM environment to execute the contract.

Due to the decentralized nature of a blockchain network, there are many RPC nodes, and a request can reach any one of them, after which it can pass it to any one of the validators.

![JSON Network Arch](/docs/assets/JSONNetworkArch.png)
'''
'''--- docs/1.concepts/basics/token-loss.md ---
---
id: token-loss
title: Avoiding Token Loss
sidebar_label: Avoiding Token Loss
---

:::warning
Careful! Losing tokens means losing money!
:::

Token loss is possible under multiple scenarios. These scenarios can be grouped into a few related classes:

1. Improper key management
2. Refunding deleted accounts
3. Failed function calls in batches

---

## Improper key management

Improper key management may lead to token loss. Mitigating such scenarios may be done by issuing backup keys
allowing for recovery of accounts whose keys have been lost or deleted.

### Loss of `FullAccess` key

A user may lose their private key of a `FullAccess` key pair for an account with no other keys.
No one will be able to recover the funds. Funds will remain locked in the account forever.

### Loss of `FunctionCall` access key

An account may have its one and only `FunctionCall` access key deleted.
No one will be able to recover the funds. Funds will remain locked in the account forever.

---
## Refunding deleted accounts

When a refund receipt is issued for an account, if that account no longer exists, the funds will be dispersed among
validators proportional to their stake in the current epoch.

### Deleting account with non-existent beneficiary

When you delete an account, you must assign a beneficiary.
Once deleted, a transfer receipt is generated and sent to the beneficiary account.
If the beneficiary account does not exist, a refund receipt will be generated and sent back to the original account.
Since the original account has already been deleted, the funds will be dispersed among validators.

### Account with zero balance is garbage-collected, just before it receives refund

If an account `A` transfers all of its funds to another account `B` and account `B` does not exist,
a refund receipt will be generated for account `A`. During the period of this round trip,
account `A` is vulnerable to deletion by garbage collection activities on the network.
If account `A` is deleted before the refund receipt arrives, the funds will be dispersed among validators.

---
## Failed function calls in batches

:::warning
When designing a smart contract, you should always consider the asynchronous nature of NEAR Protocol.
:::

If a contract function `f1` calls two (or more) other functions `f2` and `f3`, and at least one of these functions, `f2` and `f3` fails, then tokens will be refunded from the function that failed, but tokens will be appropriately credited to the function(s) which succeed.

The successful call's tokens may be considered lost depending on your use case if a single failure in the batch means the whole batch failed.

'''
'''--- docs/1.concepts/basics/token.md ---
---
id: tokens
title: Tokens
---

# NEAR Token
This is the native token used in NEAR Protocol.
It has multiple use cases:
- Secures the network through staking
- Provides a unit of account - NEAR is used for processing transactions and storing data
- Serves as a medium of exchange

### Securing the Network
NEAR Protocol is a proof-of-stake (PoS) network, which means that resistance from various attacks comes from staking NEAR.
Staked NEAR represents the decentralized infrastructure of servers that maintain the network and process transactions for applications and users on NEAR.
Rewards for providing this service are received in NEAR.

## Providing a Unit of Account
NEAR is used to price computation and storage on the NEAR infrastructure.
The network charges transaction fees in NEAR to process changes and transactions.

## Medium of Exchange
NEAR is readily available on the protocol level, so it can be used to transfer value between NEAR applications and accounts.
This means that applications can use NEAR to charge for various functions, like access to data or other complex transactions.
Entities can also easily exchange NEAR between each other, without the need for trusted third parties to clear and settle transactions.

For a deeper dive on NEAR Economics: [https://near.org/blog/near-protocol-economics](https://near.org/blog/near-protocol-economics)

For more information about the NEAR token, visit [NEAR Token Supply and Distribution](https://near.org/blog/near-token-supply-and-distribution/) or [Nomicon](https://nomicon.io).

'''
'''--- docs/1.concepts/basics/validators.md ---
---
id: validators
title: Validators
---

The NEAR network is decentralized, meaning that multiple people collaborate in order to keep it safe. We call such people **validators**.

In order to make sure that all the transactions in the network are valid, i.e. that nobody is trying to steal money, the validators follow a specific consensus
mechanism.

Currently, there are a few well-known consensus mechanisms to keep a blockchain working correctly and resistant to attacks.
NEAR Protocol uses a version of **Proof-of-Stake**, particularly [Thresholded Proof of Stake](https://near.org/blog/thresholded-proof-of-stake/).

In Proof-of-Stake, users show support to specific network validators by delegating NEAR tokens to them. This process is known as **staking**. The main idea is that, if a validator has a large amount of tokens delegated is because the community trusts them.

### Securing the Network
Validators have two main jobs. The first is to validate and execute transactions, aggregating them in the blocks that form the blockchain. Their second job is to oversee other validators, making sure no one produces an invalid block or creates an alternative chain (eg. with the goal of creating a double spend).

If a validator is caught misbehaving, then they get "slashed", meaning that their stake (or part of it) is burned.

In the NEAR networks, an attempt to manipulate the chain would mean taking control over the majority of the validators at once, so that the malicious activity won't be flagged. However, this would require putting a huge sum of capital at risk, since an unsuccessful attack would mean slashing your staked tokens.

### Validator's Economy
In exchange for servicing the network, validators are rewarded with a target number of NEAR every epoch. The target value is computed in such a way that, on an annualized basis, it will be 4.5% of the total supply.

All transaction fees (minus the part which is allocated as the rebate for contracts) which are collected within each epoch are burned by the system. The inflationary reward is paid out to validators at the same rate regardless of the number of fees collected or burned. 

## Intro to Validators

[Validators](https://pages.near.org/papers/the-official-near-white-paper/#economics) are responsible for producing blocks and the security of the network.

Since Validators validate all shards, high requirements are set for running them (an 8-Core CPU with 16GB of RAM and 1 TB SSD of storage). The cost of running a block-producing validator node is estimated to be $330 per month for hosting. Please see our [hardware and cost estimates page](https://near-nodes.io/validator/hardware) for more info.

The current active Validators are available on the Explorer. The minimum seat price to become a block-producing validator is based on the 300th proposal. (If more than 300 proposals are submitted, the threshold will simply be the stake of the 300th proposal, provided that it‚Äôs larger than the minimum threshold of 25,500 $NEAR.) The current seat price to become a block-producing validator is updated live on the Explorer. Any validator nodes with stakes higher than the seat price can join the active set of Validators.

<blockquote className="lesson">
<strong>Is there a plan to support GPU compute if certain validator nodes can offer that or is it just CPU?</strong><br /><br />
  
We don't need GPU support as we are a POS chain and we require very little compute power.

You can read more about our consensus strategy on our <a href="https://github.com/near/wiki/blob/master/Archive/validators/about.md">Validator Quickstart</a> and <a href="https://github.com/near/wiki/blob/master/Archive/validators/faq.md">Staking FA</a>.
</blockquote>

## Chunk-Only Validators

The Chunk-Only Producer is a more accessible role with lower hardware and token requirements. This new role will allow the network's validator number to grow, creating more opportunities to earn rewards and secure the NEAR Ecosystem. 

[Chunk-Only Producers](https://pages.near.org/papers/the-official-near-white-paper/#economics) are solely responsible for [producing chunks](https://pages.near.org/papers/nightshade/#nightshade) (parts of the block from a shard, see [Nightshade](https://pages.near.org/papers/nightshade/) for more detail) in one shard (a partition on the network). Because Chunk-Only Producers only need to validate one shard, they can run the validator node on a 8-Core CPU, with 16GB of RAM, and 500 GB SSD of storage.

Like Validators, Chunk-Only Producers will receive, at minimum, 4.5% annual rewards. If less than 100% of the tokens on the network is staked, Chunk-Only Producers stand to earn even more annual rewards. For more details about the Validator‚Äôs economics, please check out [NEAR‚Äôs Economics Explained](https://near.org/blog/near-protocol-economics/).

## Dedicated Validator Documentation Site 

If you'd like to further explore Validators and Nodes in general, you can visit the [Dedicated Validator Documentation Site](https://near-nodes.io/).

<blockquote className="lesson">
<strong>If a developer writes a vulnerable or malicious dApp, is a validator implicitly taking on risk?</strong><br /><br />
  
No. We have handled the potential damages to the network on the protocol level. For example, we have a lot of limiters that constrain how much data you can pass into a function call or how much compute you can do in one function call, etc.

That said, smart contract developers will need to be responsible for their own dApps, as there is no stage gate or approval process. All vulnerability can only damage the smart contract itself. Luckily, updating smart contracts is very smooth on NEAR, so vulnerabilities can be updated/patched to an account in ways that cannot be done on other blockchains.
</blockquote>

'''
'''--- docs/1.concepts/data-flow/data-storage.md ---
---
id: data-storage
sidebar_label: "Data on the Blockchain"
---

# Data on the Blockchain

This article will cover a high-level overview of Blockchain concepts and tools which facilitate reading and writing Blockchain data. 

## Writing data

By design, a Blockchain is a distributed database, and blockchain data is optimized to be stored in serialized blocks, writing one block at a time as the chain is being created. These serialized blocks store information about primitive components like transactions, accounts, and contracts. 

Blockchain‚Äôs writing process provides a great way to apply the requested changes to the state in a decentralized manner. However, to observe the changes, you need to actively pull the information from the network. As a result, traversing several blocks and aggregating data is necessary when trying to get data across multiple contracts or a longer time range.

## Reading data

Querying the Blockchain for data about a specific block or account is fairly straightforward and can be considered a "narrow" query. However, querying data across many blocks can be cumbersome because you must aggregate results from multiple single-block queries. Therefore, these can be considered "wide" queries.

:::info

The nature of a blockchain is that it must be deterministic. A critical feature of a blockchain is that it knows the state at a given block (or time unit). Think of them as snapshots ‚Äì  a blockchain does snapshots of its state on every block.

:::

For example, a user can call a smart contract for a specific block, and the blockchain guarantees that the execution will always produce the same result for the same block any time you call it.

:::note

The deterministic nature of a blockchain isolates it from off-chain (external) variables. It is impossible to call an external API to read data from within a smart contract. Therefore, blockchains and smart contracts are closed-off from the outer (off-chain) world.

:::

## Information Availability

As mentioned, the essential information you can acquire from the Blockchain‚Äôs state is related to the transactions, accounts, and contracts taking place at a given block. 

A simple way to get such information from the blockchain is using RPC. NEAR implements a [JSON-RPC endpoint](/api/rpc/introduction) for everyone to interact with the blockchain. Through the JSON-RPC API, users can call smart contracts and view the data from the blockchain.
Keep in mind that not all the data is available through the JSON-RPC. For example, local Receipts are unavailable through the JSON-RPC because they are not stored in the NEAR node's internal database.

:::tip

The JSON-RPC endpoint  approach is the so-called pull model of getting the data. There is nothing wrong with this approach, but it is sometimes not the most comfortable or reliable alternative.

:::

As you can imagine, this basic block information might not be enough for a complex project. For example, in an NFT marketplace, basic read operations via RPC calls could help get the status of a purchase or get the NEAR balance of an NFT creator account, but for information like getting the owner of a certain NFT, getting the metadata of an NFT based on its ID, or the total supply for a certain type of NFT, dApp developers would need to do additional parsing and processing after calling the RPC primitive methods. 

More advanced real-world queries and operations like aggregation, search, relationships, and non-trivial filtering are simply not possible using RPC calls alone. An example of this is showing a leaderboard of the most popular NFT collections in the last 7 days. It would not be possible to get that information by interacting directly with the contract itself or via RPC. Getting this data would require processing every single transaction that ever happened, aggregating them in terms of collection, filtering them by timestamps calculation, and ordering them in terms of total transacted value. 

One option to solve these complex data requirements is to build a server using an indexing framework. A blockchain indexer is an implementation of the push model of getting the data. Instead of actively pulling the data from the source, indexers listen to the stream of data from the blockchain, and the data can be immediately filtered and processed according to defined requirements. Indexers can also be used to simplify the "wide" query execution. For example, a data stream can be written to a permanent database for later data analysis using a convenient query language like SQL.

## Data tools

Building a server and indexing blockchain data on your own is not an easy task. The index server will be responsible for processing all the transactions and saving them to a database. Then you‚Äôll need to build a set of APIs to get the data for your dApp. This option is resource intensive, requires maintenance, presents a single point of failure, and breaks important security properties required for decentralization.
Also, specific Blockchain properties like finality, chain reorganizations, or empty blocks complicate this process further and make it not just time-consuming but conceptually hard to retrieve correct query results from blockchain data.

As an alternative, you can try one of the many available indexing services on the NEAR blockchain, and here is a [suggestive decision tree](https://docs.pagoda.co/decision-tree-lt) of which tool to use for your data needs presented by Pagoda:

<details>
<summary><b>Data Platform Decision Tree</b></summary>
<a href="/docs/assets/data-decision-tree.png" target="_blank">
<img src="/docs/assets/data-decision-tree.png" />
</a>
</details>

* [NEAR Indexer Framework](/concepts/advanced/near-indexer-framework): a micro-framework providing you with a "live" stream of blocks. Useful to handle on-chain real-time "events".
* [NEAR Indexer for Explorer](/tools/indexer-for-explorer): leverages the indexer micro-framework to watch and store all of the blockchain's events/data into a transactional PostgreSQL database. You can clone the [GitHub repository](https://github.com/near/near-indexer-for-explorer) and customize your own indexer solution.
* [NEAR Lake Framework](/concepts/advanced/near-lake-framework): a companion library to NEAR Lake. It allows you to build your own indexer that watches a stream of blocks from a NEAR Lake data source and allows you to create your own logic to process that data. Keep in mind this is probably the one you want to use for future projects, instead of the Indexer Framework. Read [why is better](/concepts/advanced/near-indexer-framework#why-is-it-better-than-near-indexer-framework).
* [NEAR Lake Indexer](/concepts/advanced/near-lake-framework): leverages the indexer micro-framework to watch and store all of the blockchain's events/data as JSON files on a user-specified AWS S3 or S3-compatible storage.
* [Near Query API](https://near.org/dataplatform.near/widget/QueryApi.App): Query API allows you to seamlessly create, manage, and discover indexers on NEAR. Developers can deploy their indexers to aggregate historical data in a matter of minutes, while accessing the data via custom GraphQL queries.
* [The Graph](https://thegraph.com/docs/en/cookbook/near/): The Graph gives developers tools to process blockchain events and make the resulting data easily available via a GraphQL API, known individually as a subgraph. [Graph Node](https://github.com/graphprotocol/graph-node) is now able to process NEAR events, which means that NEAR developers can now build subgraphs to index their smart contracts.
* [Pagoda API](https://pagoda.co) is a hosted service managed by Pagoda that solves the complex data problem by indexing the blockchain into datamarts and is accessible via standard RESTful APIs for you to directly use in any part of your application. The API enables performant and efficient querying of blockchain data without having to build and manage your own indexer infrastructure. Pagoda also offers the Indexer framework as a decentralized solution to indexing on-chain data, and a centralized Data Lake source that can be used to build your own indexers and servers for such data query needs.
* [PIKESPEAK API](https://pikespeak.ai): an enterprise-grade API where you can fetch blockchain events and aggregated analytics on wallets, validators, delegators, money transfers, dapps activity and more. [Documentation](https://doc.pikespeak.ai/)
* [Mintbase Indexer](https://mintbase.xyz/) A highly efficient and adaptable indexing solution developed to capture, process, and store NFT events throughout the NEAR ecosystem. This indexer provides developers with a streamlined and well-structured data stream, making it an optimal choice for constructing data-centric applications in the NFT space. By systematically monitoring and indexing a wide array of NFT-related events across various platforms and projects on NEAR, the Mintbase Indexer offers developers the necessary tools and data access to build innovative and practical applications. Furthermore, the indexed data can be conveniently queried using GraphQL, allowing for flexible and efficient data retrieval tailored to specific developer needs. [Documentation](https://docs.mintbase.xyz/dev/mintbase-graph)
* [SubQuery](https://academy.subquery.network/quickstart/quickstart_chains/near.html): SubQuery is a fast, flexible, and reliable open-source data indexer that provides you with custom APIs for your web3 project across NEAR and many other chains. NEAR developers will benefit from the superior SubQuery experience, including the open-source SDK, tools, [documentation](https://academy.subquery.network), and developer support that the SubQuery ecosystem provides. Additionally, NEAR is accommodated by [SubQuery‚Äôs Managed Service](http://managedservice.subquery.network/), which provides enterprise-level infrastructure hosting.

'''
'''--- docs/1.concepts/data-flow/near-data-flow.md ---
---
sidebar_label: "NEAR Data Flow"
---

# NEAR Data Flow

<iframe
 width="100%"
 height="500"
 src="https://www.youtube.com/embed/VSBJ-A69Km4"
 title="YouTube video player"
 frameborder="0"
 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
 allowfullscreen>
</iframe>

:::info Data flow

In this video we give a quick overview on the main concept of how the data flows across the NEAR Protocol blockchain.

:::

NEAR Protocol blockchain data flow might be a bit tricky at a glance. But it is pretty straightforward and follows well-defined rules. In this article, we are going to have a closer look at how the data flows in NEAR Protocol blockchain.

In fact, any blockchain flow can be represented as an infinity timeline that has a start but has no end.

![Blocks Timeline](/docs/flow/01-timeline.png)

And a block appears on that timeline with some interval. Each of these blocks holds the information about the previous one, thus, creating a *chain of blocks*.

NEAR Protocol has a sharded nature, meaning that more than one parallel network, called a [Shard](../../2.build/6.data-infrastructure/lake-data-structures/shard.mdx), can be live at any moment. And each Shard produces a chunk of a block at a given interval. A Block in NEAR Blockchain is a collection of the block chunks from all shards. Block chunk is shortened to [Chunk](../../2.build/6.data-infrastructure/lake-data-structures/chunk.mdx) in NEAR Protocol documentation.

Returning to the data flow itself. The best we can do is to imagine tracks like we could see in audio/video editing apps. Each Shard has its own set of tracks. The top track is for Chunks. They appear no matter what at a given interval, for NEAR Blockchain the interval is about one second. Chunks are being produced even if nothing is happening on the blockchain.

![Timeline as tracks](/docs/flow/02-tracks.png)

But what do we mean by saying something is happening? We mean that something has triggered some changes in the blockchain. And the most well-known method to trigger any changes is to send a [Transaction](../../2.build/6.data-infrastructure/lake-data-structures/transaction.mdx) to the blockchain with instructions of what we want to change and who has requested those changes.

A transaction needs to be constructed, signed and sent to the blockchain. Once it is executed we expect to have a result - [ExecutionOutcome](../../2.build/6.data-infrastructure/lake-data-structures/execution_outcome.mdx). Oh, that is simple. But it‚Äôs not really accurate for NEAR Blockchain.

![Transaction execution](/docs/flow/03-tx-outcome-receipt.png)

In the beginning there is a [Transaction](../../2.build/6.data-infrastructure/lake-data-structures/transaction.mdx), it contains instructions we want to be executed on the blockchain. Transaction is sent to NEAR Blockchain.

And yes, it is executed there immediately BUT the immediate result of the transaction execution is always just *an acknowledgement that it will be executed on the chain;* this internal execution request is known as [Receipt](../../2.build/6.data-infrastructure/lake-data-structures/receipt.mdx). You can think of the [Receipt](../../2.build/6.data-infrastructure/lake-data-structures/receipt.mdx) as an internal transaction that exists to pass information across shards.

Let‚Äôs get back to the tracks to look at the example.

Assuming we have two accounts living on different [Shards](../../2.build/6.data-infrastructure/lake-data-structures/shard.mdx) **alice.near** and **bob.near**. **alice.near** creates a [Transaction](../../2.build/6.data-infrastructure/lake-data-structures/transaction.mdx) to send a few tokens to **bob.near**. The [Transaction](../../2.build/6.data-infrastructure/lake-data-structures/transaction.mdx) is immediately executed and the [ExecutionOutcome](../../2.build/6.data-infrastructure/lake-data-structures/execution_outcome.mdx) for the [Transaction](../../2.build/6.data-infrastructure/lake-data-structures/transaction.mdx) is always a [Receipt](../../2.build/6.data-infrastructure/lake-data-structures/receipt.mdx).

But this [Receipt](../../2.build/6.data-infrastructure/lake-data-structures/receipt.mdx) cannot be executed here, because **bob.near** doesn‚Äôt live on the same Shard as **alice.near**, so **the Receipt must be executed on the receiver‚Äôs Shard**. So the Receipt is moving to the Shard where **bob.near** belongs to.

On the destination Shard the Receipt is executed and the process is considered as done.

:::info The explanation here is simplified

Please refer to the [Token transfer](token-transfer-flow.md) flow article

:::

So the final scheme will look like:

![Complete scheme of sending tokens from an account from one Shard to an account on another](/docs/flow/04-send-nears-flow.png)

## Summary

We have learnt the main principles of how data is flowing in NEAR Protocol. We have found out that [Transactions](../../2.build/6.data-infrastructure/lake-data-structures/transaction.mdx) execute and the [ExecutionOutcome](../../2.build/6.data-infrastructure/lake-data-structures/execution_outcome.mdx) of the Transaction is always a [Receipt](../../2.build/6.data-infrastructure/lake-data-structures/receipt.mdx).

Now we know that [Receipt](../../2.build/6.data-infrastructure/lake-data-structures/receipt.mdx) is a main internal asset for NEAR Protocol blockchain and it has a power of traveling between [Shards](../../2.build/6.data-infrastructure/lake-data-structures/shard.mdx). We learnt the NEAR Data flow on a simple example. Of course in real life with more complex transactions, that involve cross-contract calls, there will be more Receipts and ExecutionOutcomes.

We hope this article is useful and you will be able to build your dApps and indexers easily with the knowledge of how data if flowing in NEAR Protocol.

'''
'''--- docs/1.concepts/data-flow/token-transfer-flow.md ---
---
sidebar_label: Token Transfer
---

# Token Transfer flow

In the [previous article](near-data-flow.md) we saw an example of token transfer between accounts found in different shards. That example was simplified and missed a few steps in the process. That was intentional, to keep the article and the video short yet explanatory, in order to give you a bigger picture for understanding concepts.

In this article we're going to have a look at the same data flow, but in detail and we will consider two additional scenarios:

- Token transfer between accounts found in different shards
- Token transfer between accounts found in the same shard

You may be asking what was missing in the previous explanation. The short answer is: **Gas Refunds** or simply **Refunds**.

If you don't know what **Gas** is, please [read first the article about Gas](https://docs.near.org/concepts/protocol/gas) from our docs.

As for *Refunds*, here's a quote from the [Gas](https://docs.near.org/concepts/protocol/gas) article:

> Attach extra gas; get refunded!
>
> ...
>
> - If you attach more gas than needed, you'll get refunded
>
> ...
>
> *From NEAR Protocol docs [Gas. Attach extra gas; get refunded!](https://docs.near.org/concepts/protocol/gas#attach-extra-gas-get-refunded)*

:::note What refunds mean in terms of data flow

It means that literally every Transaction includes a refund.

:::

OK, this should be enough for introduction, now let's move on to examples.

## Token transfer between accounts found in different shards

Basically it is an extension of the example from the [NEAR Data Flow](near-data-flow.md) article.

Assume we have two accounts **alice.near** and **bob.near**. They belong to different [Shards](/build/data-infrastructure/lake-data-structures/shard). **alice.near** sends a few tokens to **bob.near**.

A [Transaction](/build/data-infrastructure/lake-data-structures/transaction) signed by **alice.near** is sent to the network. It is immediately executed, [ExecutionOutcome](/build/data-infrastructure/lake-data-structures/execution-outcome) is the output or result from converting the transaction into a [Receipt](/build/data-infrastructure/lake-data-structures/receipt).

![Transaction execution](/docs/flow/03-tx-outcome-receipt.png)

During the above process **alice.near**, the sender, was charged a fee (gas). The [Receipt](/build/data-infrastructure/lake-data-structures/receipt) created as result of the [Transaction](/build/data-infrastructure/lake-data-structures/transaction) follows these rules:

1. It will be executed not earlier than next [Block](/build/data-infrastructure/lake-data-structures/block)
2. It **must** be executed on the receiver's [Shard](/build/data-infrastructure/lake-data-structures/shard)

So, in our case the receiver is **bob.near** and that account belongs to a different [Shard](/build/data-infrastructure/lake-data-structures/shard) that's why the [Receipt](/build/data-infrastructure/lake-data-structures/receipt) moves to the receiver's Shard and is put in the execution queue.

In our example the Receipt is executed in the very next Block.

![The Receipt is executed in the next Block](/docs/flow/04-send-nears-flow.png)

Almost done. Remember the refund? So the [ExecutionOutcome](/build/data-infrastructure/lake-data-structures/execution-outcome) for the Receipt will be another Receipt that is refunding the Gas to the sender. **bob.near** has received tokens from **alice.near**. Now, **alice.near** becomes the receiver for a new (and last) Receipt (keep in mind the sender in this Receipt is always **system**).

Keep in mind rule #2: the Receipt must be executed on the receiver's Shard. So this Receipt moves to the Shard where **alice.near** belongs to. And it is the last execution in this process.

![Complete scheme of Token transfer between the accounts from different Shards](/docs/flow-token-transfer/01-diff-shards-complete.png)

This is it. Tokens has been transferred from the account on one Shard to the account on a different Shard, and the initial sender, **alice.near**, received a refund of Gas.

## Token transfer between accounts found on the same shard

Let's have a look at the example where both accounts are on the same [Shard](/build/data-infrastructure/lake-data-structures/shard). The process is the same as in the previous example, except there are no Receipts moving from one Shard to another.

A [Transaction](/build/data-infrastructure/lake-data-structures/transaction) signed by **alice.near** is sent to the network. It is immediately executed, [ExecutionOutcome](/build/data-infrastructure/lake-data-structures/execution-outcome) is the result of converting the transaction into a [Receipt](/build/data-infrastructure/lake-data-structures/receipt).

![Transaction execution](/docs/flow/03-tx-outcome-receipt.png)

The Receipt is already on the receiver's Shard, so it is put in the execution queue of the next [Block](/build/data-infrastructure/lake-data-structures/block). It is executed in the next Block, and the [ExecutionOutcome](/build/data-infrastructure/lake-data-structures/execution-outcome) result is a new Receipt with the refund to the initial sender, **alice.near**. 
The Same rules apply to this Receipt, it is put into the execution queue and executed in the next Block.

![Complete scheme of Token transfer between the account from the same Shards](/docs/flow-token-transfer/02-same-shard-complete.png)

This is it. You may wonder why the process is overcomplicated for the same Shard case. The answer is: **the same rules are always applied**. Also, this mechanism allows to build the NEAR Protocol data flow by only one set of rules, no matter how many Shards exist. Also, we avoid a lot of "ifs" and we don't have to keep in mind different corner cases because the process always follows the same rules.

'''
'''--- docs/1.concepts/protocol/access-keys.md ---
---
id: access-keys
title: Access Keys
---
In all blockchains, users control their accounts by holding a `private key` (a secret only they know) and using it to sign [transactions](./transactions.md).

![img](@site/static/docs/assets/welcome-pages/access-keys.png)

NEAR accounts present the **unique** feature of being able to hold multiple [Access Keys](https://en.wikipedia.org/wiki/Public-key_cryptography), each with its **own set of permissions**. We distinguish two types of Keys:

1. `Full-Access Keys`: Have full control over the account, and should **never be shared**
2. `Function-Call Keys`: Can sign calls to specific contract, and are **meant to be shared**

---

## Full-Access Keys {#full-access-keys}
As the name suggests, `Full-Access` keys have full control of an account, meaning they can be used to sign [transactions](transactions.md) doing any action in your account's behalf:

1. Transfer NEAR ‚ìÉ
2. Delete your account or create sub-accounts of it
3. Add or remove Access Keys
4. Deploy a smart contract in the account
5. Call methods on any contract

You should never share your `Full-Access`, otherwise you are giving **total control over the account**.

:::tip
The **first** Full-Access Key of an account is added when the account is **created**
:::

---

## Function-Call Keys {#function-call-keys}

`Function-Call` keys can only sign transactions calling a **specific contract**, and do **not allow** to **attach NEAR tokens** to the call. They are defined by three attributes:
1. `receiver_id`: The **contract** which the key allows to call. No other contract can be called using this key
2. `method_names` (Optional): The contract's **methods** the key allows to call. If omitted, all methods can be called
3. `allowance` (Optional): The **amount of NEAR** allowed to be spent on [gas](gas.md). If omitted, the key can consume **unlimited** as gas

Function-Call keys have the main purpose of being shared, so third-parties can make contract calls in your name. This is useful in [multiple scenarios as we will see below](#benefits-of-function-call-keys).

:::tip 
`Function-Call` keys are secure to share, as they only permit calls to a specific contract and prohibit NEAR token transfers.
:::

---

## Benefits of Function-Call Keys

`Function Call Keys` allows you to provide **restricted access** to third parties. This key type, unique to NEAR, enables several use-cases worth discussing.

### Enhancing User Experience
The most common use case for `Function-Call` keys is to allow an application to sign transactions on the user's behalf.

Imagine you are developing a game that records the user's score on a smart contract. On other chains, you would have to disrupt the user's experience to request transaction signatures each time the game needs to update the score.

With NEAR, you can request the user to generate a `Function-Call` key for the game's contract and share it with the game. This way, the game can sign transactions in the user's name, eliminating gameplay interruptions.

Sharing this key is safe for the user, because even in the case of somebody stealing it, they would only be able to call the score-keeping method, and nothing else.

<hr class="subsection" />

### Simple Onboarding

Another common use-case of `Function-Call` keys is to simplify the **onboarding** process for new users. It works as follows:

First create a contract that has a method called `create_account`. This method should only be callable by the contract itself and, when executed, should create a new account and transfer some tokens to it.

You can then create multiple `Function-Call` in the contract's account, that only allow to call `create_account`. Drop these keys to your friends, so they can call the method, and easily create an account with some tokens.

:::tip
This is the basic principle behind [NEAR Drops](../../2.build/5.primitives/linkdrop.md), a way to distribute assets to a large number of users
:::

<hr class="subsection" />

### Key Rotation and Recovery

The presence of multiple keys allows for easy **rotation** and **recovery**. If you suspect a key might be compromised, you can promptly remove it or replace it with a new one, similar to changing your password on a website.

You can also establish a key-recovery contract in your account and generate a "recovery key" for a trusted party. This key would only be used to initiate the recovery process.

In case of necessity, the trusted party can trigger the recovery process, assisting in the creation of a new full-access key for you.

---

## Locked Accounts
If you remove all keys from an account, then the account will become **locked**, meaning that no external actor can perform transactions in the
account's name.

In practice, this means that only the account's smart contract can transfer assets, create sub-accounts, or update its code.

Locking an account is very useful when one wants to deploy a contract, and let the community be assured that only the contract is in control of the account.

:::warning
An account could still add keys to itself through a smart contract, effectively allowing the contract to unlock the account. Notice that this can only be done if the contract is deployed before the account is locked
:::
'''
'''--- docs/1.concepts/protocol/account-id.md ---
---
id: account-id
title: Address (Account ID)
---

NEAR accounts are identified by a unique address, which take one of two forms:
1. [**Implicit addresses**](#implicit-address), which are 64 characters long (e.g. `fb9243ce...`)
2. [**Named addresses**](#named-address), which are simpler to remember and act as domains (e.g. `alice.near`)

:::tip Searching to create an account?
You have multiple ways to create an account, you can [sign-up using your email](https://near.org/), get a mobile wallet through [telegram](https://web.telegram.org/k/#@herewalletbot), or create a [web wallet](https://app.mynearwallet.com).
:::

---

## Implicit Address
Implicit accounts are denoted by a 64 character address, which corresponds to a unique public/private key-pair. Who controls the [private key](./access-keys.md) of the implicit account controls the account.

For example:
- The private key: `ed25519:4x1xiJ6u3sZF3NgrwPUCnHqup2o...`
- Corresponds to the public key: `ed25519:CQLP1o1F3Jbdttek3GoRJYhzfT...`
- And controls the account: `a96ad3cb539b653e4b869bd7cf26590690e8971...`

Implicit accounts always *exist*, and thus do not need to be created. However, in order to use the account you will still need to fund it with NEAR tokens (or get somebody to pay the gas for your transaction).

<details>

<summary> üßë‚Äçüíª Technical: How to obtain a key-pair  </summary>

The simplest way to obtain a public / private key that represents an account is using the [NEAR CLI](../../4.tools/cli.md)

```bash
near generate-key

# Output
# Seed phrase: lumber habit sausage used zebra brain border exist meat muscle river hidden
# Key pair: {"publicKey":"ed25519:AQgnQSR1Mp3v7xrw7egJtu3ibNzoCGwUwnEehypip9od","secretKey":"ed25519:51qTiqybe8ycXwPznA8hz7GJJQ5hyZ45wh2rm5MBBjgZ5XqFjbjta1m41pq9zbRZfWGUGWYJqH4yVhSWoW6pYFkT"}
# Implicit account: 8bca86065be487de45e795b2c3154fe834d53ffa07e0a44f29e76a2a5f075df8
```

</details>

---

## Named Address
In NEAR, users can register **named accounts** (e.g. `bob.near`) which are simpler to share and remember.

Another advantage of named accounts is that they can create **sub-accounts** of themselves, effectively working as domains:

1. The [`registrar`](https://nearblocks.io/address/registrar) account can create top-level accounts (e.g. `near`, `sweat`, `kaiching`).
2. The `near` account can create sub-accounts such as `bob.near` or `alice.near`
3. `bob.near` can create sub-accounts of itself, such as `app.bob.near`
4. Accounts cannot create sub-accounts of other accounts
    - `near` **cannot** create `app.bob.near`
    - `account.near` **cannot** create `sub.another-account.near`
5. Accounts have **no control** over their sub-account, they are different entities

Anyone can create a `.near` or `.testnet` account, you just to call the `create_account` method of the corresponding top-level account - `testnet` on testnet, and `near` on mainnet.

<details>

<summary> üßë‚Äçüíª Technical: How to create a named account  </summary>

Named accounts are created by calling the `create_account` method of the network's top-level account - `testnet` on testnet, and `near` on mainnet. 

```bash
near call testnet create_account '{"new_account_id": "new-acc.testnet", "new_public_key": "ed25519:<data>"}' --deposit 0.00182 --accountId funding-account.testnet
```

We abstract this process in the [NEAR CLI](../../4.tools/cli.md) with the following command:

```bash
near create_account new-acc.testnet --useAccount funding-account.testnet --publicKey ed25519:<data>
```

You can use the same command to create sub-accounts of an existing named account:

```bash
near create_account sub-acc.new-acc.testnet --useAccount new-acc.testnet
```

</details>

:::tip
Accounts have **no control** over their sub-accounts, they are different entities. This means that `near` cannot control `bob.near`, and `bob.near` cannot control `sub.bob.near`.
:::

'''
'''--- docs/1.concepts/protocol/account-model.md ---
---
id: account-model
title: NEAR Accounts
sidebar_label: Overview
---

Users participate in the NEAR ecosystem through their NEAR accounts. These accounts are identified by a [unique address](./account-id.md), can optionally hold a [smart contract](./smart-contract.md), and are controlled through [Access Keys](./access-keys.md).

By signing [transactions](./transactions.md) with their account, users can:

1. Send and receive **digital assets** (such as tokens or collectibles)
2. Create and interact with on-chain applications known as **smart contracts**
3. Control accounts in **other chains** (such as Ethereum or Bitcoin) ‚ú®
4. Help onboard new users by **covering the costs** of their transactions (gas fees)

:::tip Want to create an account?
You have multiple ways to create an account, you can [sign-up using your email](https://near.org/), get a mobile wallet through [telegram](https://web.telegram.org/k/#@herewalletbot), or create a [web wallet](https://app.mynearwallet.com).
:::

---

## Account Model Overview 

Let's take a closer look at the different elements that compose the NEAR account model.

![img](@site/static/docs/assets/welcome-pages/accounts.png)

#### [Account ID](account-id.md)
NEAR implements two types of accounts IDs: **named accounts** such as `alice.near`, which are simple to remember and share, and the classic alphanumeric IDs (`fb9243ce...`) that other chains also implement.

#### [Permissions Through Access Keys](access-keys.md)
NEAR accounts can have multiple [keys](access-keys.md), each with their own set of permissions. This allows to easily swap keys if one gets compromised, and to use keys as authorization tokens for third-parties.

#### [Simple to Develop Smart Contracts](smart-contract.md)
NEAR accounts can optionally hold a simple program, known as a [smart contract](smart-contract.md). In NEAR, developers can create smart contracts using languages such as Javascript or Rust. 

---

## Comparison With Ethereum {#compared-to-ethereum}

If you're familiar with development on Ethereum, it's worth making a quick note about how accounts are different. The table below summarizes some key differences:

|                   | Ethereum Wallet                                                                             | NEAR Account                                                                            |
|-------------------|---------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|
| Public Identifier | Public Key (`0x123...`)                                                                     | Named IDs (`alice.near`) and implicit accounts (Public Key `0x123...`)                  |
| Secret Key        | Private Key (`0x456...`)                                                                    | Multiple key-pairs with permissions:<br />- `FullAccess` key<br />- `FunctionCall` key  |
| Characteristics   | - Private key gives full access<br />- Account doesn't have to be created via a transaction | - Permission-based keypair<br />- Account ID must be created via blockchain transaction |

'''
'''--- docs/1.concepts/protocol/gas.md ---
---
id: gas
title: Gas (Execution Fees)
---

import {NearWidget} from "@site/src/components/near-widget"

On every transaction the NEAR network charges a tiny fee known as **gas**. This fee is a simple mechanism that allows us to:

1. **Prevent** bad actors from **spamming** the network with useless transactions
2. **Burn** a minuscule fraction of the **token supply** on each transaction
3. **Incentivize developers** by giving contracts 30% of the gas they burn while executing
4. Implement a **wall time** by capping transactions to `300Tgas` (~`300ms` of compute time)

Gas in NEAR is computed on [**gas units**](#gas-units--gas-price) and charged using $NEAR tokens based on the network's [**gas price**](#gas-units--gas-price).

:::tip Did you know?
In NEAR, attaching extra gas to a transaction does **not** make it faster. Actions cost a fixed amount of gas, and any extra gas attached is simply sent back to the user
:::
 
---

## Understanding Gas Fees
For every transaction, users get charged a small $NEAR fee which has to be paid **upfront**. This fee is calculated using deterministic **gas units**, and transformed into a cost in $NEAR using the network's **gas price**.

<hr class="subsection" />

### Gas Units
Every action in NEAR costs a fixed amount of **gas units**, meaning that the same operation will always cost the **same amount of gas units**.

Gas units were engineered in such a way that they can be translated into compute resources, where `1Tgas` gets you approx. `1ms` of compute time.

Transactions can use a maximum of `300Tgas`, meaning they should be processed in less than `300ms`, allowing the network to produce a new block approximately **every second**.

:::tip
Gas units encapsulate not only compute/CPU time but also bandwidth/network time and storage/IO time
:::

<hr class="subsection" />

### Gas Price
To determine the actual $NEAR fee, the cost of all actions in the transaction are multiplied by a **gas price**.

The gas price is **recalculated each block** based on the network's demand and floors at `1Tgas = 0.0001‚ìÉ`.

If the previous block is **more than half full** the price goes up by 1%, otherwise it goes down by 1% (until it reaches the floor).

<details>

<summary> What is the gas price now? </summary>

You can query how much a gas unit costs in `yoctoNEAR` (1‚ìÉ = `1e24` yocto) through the [`RPC`](/api/rpc/gas#gas-price). To convert in `Tgas` per `NEAR` simply divide by `1e12`.

<NearWidget height="40px">

```js
const query = fetch('https://rpc.near.org', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    jsonrpc: '2.0',
    id: 'dontcare',
    method: 'gas_price',
    params: [null]
  })
})

const yocto = query.body.result.gas_price
return `Right now, 1 Tgas costs ${Number(yocto) / 1e12}‚ìÉ`
```

</NearWidget>

</details>

<hr class="subsection" />

### Cost for Common Actions

Knowing that actions have a fixed cost in gas units, we can calculate the cost of common operations at the minimum gas price of `1Tgas = 0.0001‚ìÉ`.

| Action                       | TGas           | Fee (‚ìÉ)  |
|------------------------------|----------------|----------|
| Create Account               | 0.42           | 0.000042 |
| Transfer NEAR                | 0.45           | 0.000045 |
| Add Full Access Key          | 0.42           | 0.000042 |
| Delete Key                   | 0.41           | 0.000041 |
| Function Call*               | ‚â§ 300          | ‚â§ 0.03   |
| Deploying a `16`kb contract  | 2.65           | 0.000265 |
| Deploying a `X`kb contract** | 0.58 + 0.13`X` |          |

_Note that the fee is in $NEAR, to obtain the cost in dollars multiply by the current price of $NEAR_

:::tip Function Calls*
The cost of calling a function will depend on how complex the function is, but will be consistent across function calls. Learn more bellow.
:::

:::tip Deploying a Contract**
Note that this covers the cost of uploading and writing bytes to storage, but does **not** cover the cost of [holding these bytes in storage](./smart-contract.md#contracts-storage)
:::

<details className="info">
<summary>Where do these numbers come from?</summary>

NEAR is [configured](https://github.com/near/nearcore/blob/master/core/primitives/res/runtime_configs/parameters.yaml) with base costs. An example:

```json
  transfer_cost: {
    send_sir:     115123062500,
    send_not_sir: 115123062500,
    execution:    115123062500
  },
  deploy_contract_cost: 184765750000,
  deploy_contract_cost_per_byte: 64572944
```

The "sir" here stands for "sender is receiver". Yes, these are all identical, but that could change in the future.

When you make a request to transfer funds, NEAR immediately deducts the appropriate `send` amount from your account. Then it creates a [_receipt_, an internal book-keeping mechanism](./transaction-execution.md). Creating a receipt has its own associated costs:

```json
  action_receipt_creation_config: {
    send_sir:     108059500000,
    send_not_sir: 108059500000,
    execution:    108059500000
  }
```

You can query this value by using the [`protocol_config`](/api/rpc/setup#protocol-config) RPC endpoint and search for `action_receipt_creation_config`. 

The appropriate amount for creating this receipt is also immediately deducted from your account.

The "transfer" action won't be finalized until the next block. At this point, the `execution` amount for each of these actions will be deducted from your account (something subtle: the gas units on this next block could be multiplied by a gas price that's up to 1% different, since gas price is recalculated on each block). Adding it all up to find the total transaction fee:

```
    (transfer_cost.send_not_sir  + action_receipt_creation_config.send_not_sir ) * gas_price_at_block_1 +
    (transfer_cost.execution + action_receipt_creation_config.execution) * gas_price_at_block_2
```

</details>

---

## How Do I Buy Gas?

You don't buy gas, instead, the gas fee is automatically removed from your account's balance when the transaction [is first proccesed](./transaction-execution.md#block-1-the-transaction-arrives) based on the action's gas cost and the network's gas price.

The only exception to this rule is when you make a function call to a contract. In this case, you need to define how many gas units to use, up to a maximum value of `300Tgas`. This amount will be converted to $NEAR using the network's gas price and deducted from your account's balance.

Since many transactions will take more [than 1 block to execute](./transaction-execution.md), and the gas price is recalculated on each block and could go up, you will be charged a pessimistic estimate of $NEAR (see details bellow). 

If the transaction ends up using less gas than the amount deducted, the difference will simply be **refunded to your account**.

<details>

<summary> Pessimistic Estimate </summary>

While actions have a fixed cost in gas units, the gas price might change block to block. Since transactions can take more than 1 block to execute, the gas price might go up during the transaction's execution.

To avoid the need to recalculate the gas price for each block, the network will charge you upfront a pessimistic estimate of the gas fee.

Lets take as an example [this transaction calling a contract method](https://testnet.nearblocks.io/txns/JD8Bg4u8kaYeaSsGBqkvhSDCEPgXhtwJRBBPKicCEPMs). The transaction was submitted with 10Tgas attached.

- 10Tgas would cost 0.001‚ìÉ at the price when the transaction was submitted
- The transaction used:
  - 2.4Tgas to convert the [transaction into a receipt](./transaction-execution.md#block-1-the-transaction-arrives): 0.00024‚ìÉ
  - 3.2Tgas to execute the function in the contract: 0.00032‚ìÉ
  - Total: 5.6Tgas or 0.00056‚ìÉ
- In the end, the user was returned  0.00104‚ìÉ

Since the system returned `0.00104‚ìÉ`, and the transaction expended `0.00056‚ìÉ`, the user was charged upfront `0.0016‚ìÉ`, this is 60% more than what the user expected to pay (0.001‚ìÉ).

This 60% up comes from assuming that the price of gas will go up by 1% on each block, and the transaction will take 50 blocks to execute (`1.01**50 ~ 1.64`).

</details>

:::tip
In other chains, paying a higher gas price gets your transaction processed faster. In NEAR, **gas costs are deterministic**, and you **can't pay extra**. Any extra gas attached to a transaction is simply sent back to the user.
:::

---

## Gas as a Developer Incentive

In NEAR, 30% of the gas fees burn while executing a contract go to the contract's accounts. This is a powerful incentive for developers to create and maintain useful contracts.

For example, in [this transaction](https://testnet.nearblocks.io/txns/JD8Bg4u8kaYeaSsGBqkvhSDCEPgXhtwJRBBPKicCEPMs) the user calls a function in the `guestbook.near-examples.testnet` contract.

Executing the function call burned a total of ~0.00032‚ìÉ, from which 30% goes to the contract's account. This means that the contract's account received 0.000096‚ìÉ.

Notice that the fee comes from the gas burned during the function execution, and not from the total gas used.

---

## Estimating Costs for a Call

:::warning
This section will soon be moved from here to the [build documentation](../../2.build/2.smart-contracts/anatomy/environment.md).
:::

If you developing a smart contract, you might want to estimate how much gas a function call will consume. This is useful to estimate limits for your function and avoid running into out-of-gas errors.

One of the most accurate ways to estimate gas costs is by running your function in `testnet`. To know exactly how much gas a specific part of your function uses, you can use the `used_gas` method from our SDK.

Another option is to use `Sandbox Testing` (available in [Rust](https://github.com/near/workspaces-rs/tree/main/examples/src) and [JavaScript](https://github.com/near/workspaces-js)), which simulates the NEAR network. There you can access the gas burnt after each function call.

Finally, you can obtain gas cost estimates for a given function call using `api.gasbuddy.tech`. This API is experimental and may be removed in the future. One can obtain a gas cost estimate for a given function call by sending a POST request to `https://api.gasbuddy.tech/profile` with the following JSON body:

```json
{
  "contract_id": "<your-contract-account-id>",
  "method": "<your-contract-method-name>",
  "args": {
    "arg1": "value1",
    "arg2": "value2"
  }
}
```

'''
'''--- docs/1.concepts/protocol/smart-contract.md ---
---
id: smartcontract
title: Smart Contract
---

Smart contracts are pieces of **executable code** that live in a NEAR account. They can **store data**, **perform transactions** in the account‚Äôs name, and **expose methods** so other accounts can interact with them.

![Smart Contract](@site/static/docs/assets/welcome-pages/contracts-landing.png)

Developers can choose between using Javascript or Rust to write smart contracts in NEAR. Indistinctly from the language chosen, the contract will be compiled into WebAssembly, from which point it can be deployed and executed on the NEAR platform.

:::tip Want to build a smart contract?
Check our [**Quickstart Guide**](../../2.build/2.smart-contracts/quickstart.md) to build your first smart contract in NEAR.
:::

---

## What can Smart Contract Do?

Smart contracts have complete control over the account, and thus can perform any action on its behalf. For example, contracts can:
- Transfer $NEAR Tokens 
- Call methods on themselves or **other contracts**
- Create new accounts and deploy contracts on them
- Update their own code

Besides, smart contracts can store data in the account's storage. This allows contract's to create almost any type of application, from simple games to complex financial systems.

:::danger What contracts cannot do
- Smart contracts cannot **access the internet**, so they cannot make HTTP requests or access external data 
- Smart contracts cannot **execute automatically**, they need to be called by an external account
:::

---

## What are Contract's Used for?
Smart contracts are useful to create **decentralized applications**. Some traditional examples include:
- [Decentralized Autonomous Organizations](https://near.org/nearcatalog.near/widget/Index?cat=dao), where users create and vote proposals
- [Marketplaces](https://near.org/nearcatalog.near/widget/Index?cat=marketplaces), where users create and commercialize digital art pieces
- [Decentralized exchanges](https://near.org/nearcatalog.near/widget/Index?cat=exchanges), where users can trade different currencies
- [And many more...](https://near.org/nearcatalog.near/widget/Index)

For instance, you can easily create a crowdfunding contract that accepts $NEAR. If the goal is met in time, the creator can claim the funds. Otherwise, the backers are refunded.

---

## Contract's Storage
Smart contract stores data in the account's state. The contract's storage is organized as **key-value pairs** encoded using either [JSON](https://www.json.org/json-en.html) or [Borsh](https://borsh.io) serialization. This allows to store any type of data efficiently, from simple numbers to complex objects.

Since the data occupies space in the network, smart contracts need to **pay for the storage they use**. For this, accounts automatically lock a portion of their balance each time new data is stored in the contract. This means that:
- If data is added to the contract's storage the account's **balance decreases ‚Üì**.
- If data is deleted the account's **balance increases ‚Üë**. 

Currently, it cost approximately **1 ‚ìÉ** to store **100kb** of data.

:::tip
Serializing and deserializing the storage happens automatically through our SDK tools, so you can focus on coding the logic of the contract
:::

'''
'''--- docs/1.concepts/protocol/transaction-anatomy.md ---
---
id: transaction-anatomy
title: Anatomy of a Transaction
---

A transaction is a request from a user to the network to perform a set of actions. To create a transaction, the user must specify the following fields:

- `Signer`: the account that signs the transaction
- `Actions`: the set of actions to be performed (see bellow)
- `Receiver`: the account on which to perform the actions

In addition, a transaction has the following fields to ensure its integrity and validity:

- `PublicKey`: the public key used to sign the Transaction (so the network can verify the signature)
- `Nonce`: a number that is incremented for each transaction sent by the `Signer`
- `BlockHash`: the hash of a recent block, to limit the time-validity of the transaction

Users create transactions and sign them with their private keys. Then, the **transaction and its signature** are broadcasted together to the network, where they are validated and processed.

:::tip
Each transaction has exactly one `Signer` and `Receiver`, but can have multiple `Actions`
:::

---

## Actions
Each transaction can have **one or multiple** `Actions`, which are the actual operations to be performed on the `Receiver` account. There are 9 types of actions that can be performed:

1. `FunctionCall`: to invoke a function on a contract (optionally attaching NEAR to the call)
2. `Transfer`: to transfer tokens to another accounts
3. `DeployContract`: to deploy a contract in the account
4. `CreateAccount`: to create a new sub-account (e.g. `ana.near` can create `sub.ana.near`)
5. `DeleteAccount`: to delete the account (transferring the remaining balance to a beneficiary)
6. `AddKey`: to add a new key to the account (either `FullAccess` or `FunctionCall` access)
7. `DeleteKey`: to delete an existing key from the account
8. `DelegateActions`: to create a meta-transaction
9. `Stake`: special action to express interest in becoming a network validator

For example, `bob.near` can bundle the following actions in a single transaction:
- Create the account `contract.bob.near`
- Transfer 5 NEAR to `contract.bob.near`
- Deploy a contract in `contract.bob.near`
- Call the function `init` in `contract.bob.near`

The `Actions` are executed in the **order they are specified in the transaction**. If any of the **actions fails**, the transaction is discarded and none of the actions take effect.

:::warning One Receiver
Notice that all actions are performed on the same account. It is **not possible** to perform actions on multiple accounts in a single transaction, because transactions can have **only one receiver**
:::
'''
'''--- docs/1.concepts/protocol/transaction-execution.md ---
---
id: transaction-execution
title: Lifecycle of a Transaction
---

`Transactions` are constructed by users to express the intent of performing actions in the network. Once in the network, transactions are converted into `Receipts`, which are messages exchanged between network nodes.

On this page, we will explore the lifecycle of a transaction, from its creation to its final status.

:::tip Recommended Reading
To dig deeper into transaction routing, we recommend reading the [nearcore documentation](https://near.github.io/nearcore/architecture/how/tx_routing.html)
:::

---

## Receipts & Finality

Let's walk through the lifecycle of a complex transaction and see how it is processed by the network using blocks as **time units**.

#### Block #1: The Transaction Arrives
After a transaction arrives, the network takes one block to validate it and transform it into a single `Receipt` that contains all the [actions](./transaction-anatomy.md) to be executed.

While creating the `Receipt`, the `signer` gets $NEAR deducted from its balance to **pay for the gas** and **any attached NEAR**.

If the `signer` and `receiver` coincide - e.g. the `signer` is adding a Key - the `Receipt` is immediately processed in this first block and the transaction is considered final.

#### Block #2: The Receipt is Processed
If the `signer` and `receiver` differs - e.g. the `signer` transfers NEAR to the `receiver` - the `Receipt` is processed in a second block. 

During this process a `FunctionCall` could span a **cross-contract call**, creating one or multiple new `Receipts`.

#### Block #3...: Function Calls
Each `Receipt` created from the function call take an additional block to be processed. Notice that, if those `Receipts` are `FunctionCall` they could spawn new `Receipts` and so on.

#### Final Block: Gas is Refunded
A final `Receipt` is processed in a new block, refunding any extra gas paid by the user.

:::info
A transaction is considered **final** when all its receipts are processed.
:::

:::tip
Most transactions will just spawn a receipt to process the actions, and a receipt to refund the gas, being final in 1-3 blocks (~1-3 seconds):

- [One block](https://testnet.nearblocks.io/txns/8MAvH96aMfDxPb3kVDrgj8nvJS7CAXP1GgtiivKAMGkF#execution) if the `signer` and `receiver` coincide - e.g. when adding a key
- [Three blocks](https://testnet.nearblocks.io/txns/B7gxJNxav1A9WhWvaNWYLrSTub1Mkfj3tAudoASVM5tG#) if the `signer` and `receiver` differ, since the first block creates the `Receipt`, and the last reimburse gas

Function calls might take longer, as they can spawn multiple receipts. Network congestion can also increase the time to process a receipt and, thus, a transaction.
:::

---

## Transaction Status

As the `Receipts` of a `Transaction` are processed, they get a status:

- `Success`: the actions on the receipt were executed successfully
- `Failed`: an action on the receipt failed
- `Unknown`: the receipt is not known by the network

If an action in a `Receipt` fails, all the actions in that `Receipt` are rolled back. Notice that we are talking about the `Receipt` status, and not the `Transaction` status.

The status of a transaction is determined by its first receipt, which contains all its actions. If any of the actions in the first receipt fail, the transaction is marked as failed.

Notice that, it could happen that a transaction is marked as successful, but some of its receipt fails. This happens when a `FunctionCall` successfully spawns a new receipt, but the consequent function call fails. In this case, the transaction is marked as successful because the original function call was successful.

See the examples below for more details.

<details>

<summary> Status Examples </summary>

#### Example: Transaction with Transfer

1. `bob.near` creates a transaction to transfer 10 NEAR to `alice.near`
2. The transaction is converted into a receipt
3. The conversion fails because `bob.near` does not have enough balance
4. The transaction is marked as failed ‚õî

#### Example: Deploying a Contract

1. `bob.near` creates a transaction to:
    - create the account `contract.bob.near`
    - transfer 5 NEAR to `contract.bob.near`
    - deploy a contract in `contract.bob.near`
2. The transaction is transformed into one receipt
3. The account is created, the money transfer and the contract deployed
4. The transaction is marked as successful ‚úÖ

#### Example: Deploying a Contract Fails

1. `bob.near` creates a transaction to:
    - create the account `contract.bob.near`
    - transfer 5 NEAR to `contract.bob.near`
    - deploy a contract in `contract.bob.near`
2. The transaction is transformed into one receipt
3. The account is created, but the transfer fails because `bob.near` does not have enough balance
4. The whole process is reverted (i.e. no account is created)
5. The transaction is marked as successful ‚õî

#### Example: Calling a Function
1. `bob.near` creates a transaction to call the function `cross-call` in `contract.near`
2. The transaction is transformed into one receipt
3. The function `cross-call` creates a promise to call the function `external-call` in `external.near`
4. The function finishes correctly and the transaction is marked as successful ‚úÖ
5. A new receipt is created to call the function `external-call` in `external.near`
5. The function `external-call` fails
6. The original transaction is still marked as successful ‚úÖ because the first receipt was successful

</details>

:::tip
You can check the status of a transactions using the [NearBlocks explorer](https://nearblocks.io/)
:::

'''
'''--- docs/1.concepts/protocol/transactions.md ---
---
id: transactions
title: Transactions
---

Users interact with NEAR by creating transactions. Specifically, user's use their account's [private keys](./access-keys.md) to sign transactions, which are then broadcasted and processed by the network.

![](@site/static/docs/assets/welcome-pages/data-lake.png)

A transaction is composed of one or more [`Actions`](./transaction-anatomy.md), and each action costs a deterministic amount of [gas units](./gas.md). This gas units are translated into a cost in NEAR tokens, which the user must pay for the transaction to be processed.

:::tip
You can use an <a href="https://nearblocks.io/">Explorer</a> to inspect transactions in the NEAR network
:::
'''
'''--- docs/1.concepts/storage/data-collections.md ---
---
id: data-storage
title: "Data Storage / Collections"
sidebar_label: Storage on NEAR
---

All data stored on the NEAR blockchain is done in key / value pairs. There are several collection methods in the SDKs we've created that will help you store your data on chain.

- [`near-sdk-rs`](https://github.com/near/near-sdk-rs) for [Rust](https://www.rust-lang.org/) smart contracts
- [`near-sdk-js`](https://github.com/near/near-sdk-js) for [JavaScript](https://www.javascript.com/) smart contracts

For information on storage costs, please see [ **[storage staking](/concepts/storage/storage-staking)** ].

---

## Rust Collection Types {#rust-collection-types}

[`near-sdk-rs` module documentation](https://docs.rs/near-sdk/latest/near_sdk/collections/)

| Type                                                          | Iterable | Clear All Values | Preserves Insertion Order | Range Selection |
| ------------------------------------------------------------- | :------: | :--------------: | :-----------------------: | :-------------: |
| [`Vector`](/concepts/storage/data-storage#vector)             |    ‚úÖ    |        ‚úÖ        |            ‚úÖ             |       ‚úÖ        |
| [`LookupSet`](/concepts/storage/data-storage#lookupset)       |          |                  |                           |                 |
| [`UnorderedSet`](/concepts/storage/data-storage#unorderedset) |    ‚úÖ    |        ‚úÖ        |                           |       ‚úÖ        |
| [`LookupMap`](/concepts/storage/data-storage#lookupmap)       |          |                  |                           |                 |
| [`UnorderedMap`](/concepts/storage/data-storage#unorderedmap) |    ‚úÖ    |        ‚úÖ        |                           |       ‚úÖ        |
| [`TreeMap`](/concepts/storage/data-storage#treemap)           |    ‚úÖ    |        ‚úÖ        |                           |                 |

---

### Big-O Notation {#big-o-notation-1}

> The [Big-O notation](https://en.wikipedia.org/wiki/Big_O_notation) values in the chart below describe the [time complexity](https://en.wikipedia.org/wiki/Time_complexity) of the various collection methods found in `near-sdk-rs`. These method complexities correlate with [gas](/concepts/protocol/gas) consumption on NEAR, helping you decide which collection to utilize in your project. There are three types found in our collection methods:

- O(1) - _[constant](https://en.wikipedia.org/wiki/Time_complexity#Constant_time)_
- O(n) - _[linear](https://en.wikipedia.org/wiki/Time_complexity#Linear_time)_
- O(log n) - _[logarithmic](https://en.wikipedia.org/wiki/Time_complexity#Logarithmic_time)_

| Type                                                          |  Access  |  Insert  |  Delete  |  Search  | Traverse | Clear |
| ------------------------------------------------------------- | :------: | :------: | :------: | :------: | :------: | :---: |
| [`Vector`](/concepts/storage/data-storage#vector)             |   O(1)   |  O(1)\*  | O(1)\*\* |   O(n)   |   O(n)   | O(n)  |
| [`LookupSet`](/concepts/storage/data-storage#lookupset)       |   O(1)   |   O(1)   |   O(1)   |   O(1)   |   N/A    |  N/A  |
| [`UnorderedSet`](/concepts/storage/data-storage#unorderedset) |   O(1)   |   O(1)   |   O(1)   |   O(1)   |   O(n)   | O(n)  |
| [`LookupMap`](/concepts/storage/data-storage#lookupmap)       |   O(1)   |   O(1)   |   O(1)   |   O(1)   |   N/A    |  N/A  |
| [`UnorderedMap`](/concepts/storage/data-storage#unorderedmap) |   O(1)   |   O(1)   |   O(1)   |   O(1)   |   O(n)   | O(n)  |
| [`TreeMap`](/concepts/storage/data-storage#treemap)           | O(1) | O(log n) | O(log n) | O(log n) |   O(n)   | O(n)  |

_\* - to insert at the end of the vector using `push_back` (or `push_front` for deque)_

_\*\* - to delete from the end of the vector using `pop` (or `pop_front` for deque), or delete using `swap_remove` which swaps the element with the last element of the vector and then removes it._

---

### Gas Consumption Examples {#gas-consumption-examples-1}

> The examples below show differences in gas burnt storing and retrieving key/value pairs using the above methods. Please note that the gas cost of spinning up the runtime environment on chain has been deducted to show just data read/writes.
>
> You can reproduce this and test out your own data set by visiting [collection-examples-rs](https://github.com/near-examples/collection-examples-rs).

![Rust Set Data Gas Chart](/docs/assets/rust-setData-gasBurnt.png)

![Rust Get Data Gas Chart](/docs/assets/rust-getData-gasBurnt.png)

---

### `Vector` {#vector}

> Implements a [vector](https://en.wikipedia.org/wiki/Array_data_structure) / persistent array.
>
> - can iterate using index
> - Uses the following map: index -> element.

[ [SDK source](https://github.com/near/near-sdk-rs/blob/master/near-sdk/src/collections/vector.rs) ]

[ [Implementation](https://docs.rs/near-sdk/latest/near_sdk/collections/vector/struct.Vector.html) ]

---

### `LookupSet` {#lookupset}

> Implements a persistent set _without_ iterators.
>
> - can not iterate over keys
> - more efficient in reads / writes

[ [SDK source](https://github.com/near/near-sdk-rs/blob/master/near-sdk/src/collections/lookup_set.rs) ]

[ [Implementation](https://docs.rs/near-sdk/latest/near_sdk/collections/struct.LookupSet.html) ]

---

### `UnorderedSet` {#unorderedset}

> Implements a persistent set _with_ iterators for keys, values, and entries.

[ [SDK source](https://github.com/near/near-sdk-rs/blob/master/near-sdk/src/collections/unordered_set.rs) ]

[ [Implementation Docs](https://docs.rs/near-sdk/latest/near_sdk/collections/struct.UnorderedSet.html) ]

---

### `LookupMap` {#lookupmap}

> Implements a persistent map.
>
> - can not iterate over keys
> - does not preserve order when removing and adding values
> - efficient in number of reads and writes

- To add data:

```rust
pub fn add_lookup_map(&mut self, key: String, value: String) {
    self.lookup_map.insert(&key, &value);
}
```

- To get data:

```rust
pub fn get_lookup_map(&self, key: String) -> String {
    match self.lookup_map.get(&key) {
        Some(value) => {
            let log_message = format!("Value from LookupMap is {:?}", value.clone());
            env::log(log_message.as_bytes());
            value
        },
        None => "not found".to_string()
    }
}
```

[ [SDK source](https://github.com/near/near-sdk-rs/blob/master/near-sdk/src/collections/lookup_map.rs) ]

[ [Implementation](https://docs.rs/near-sdk/latest/near_sdk/collections/struct.LookupMap.html) ]

---

### `UnorderedMap` {#unorderedmap}

> Implements an unordered map.
>
> - iterable
> - does not preserve order when removing and adding values
> - is able to clear all values

- To add data:

```rust
pub fn add_unordered_map(&mut self, key: String, value: String) {
    self.unordered_map.insert(&key, &value);
}
```

- To get data:

```rust
pub fn get_unordered_map(&self, key: String) -> String {
    match self.unordered_map.get(&key) {
        Some(value) => {
            let log_message = format!("Value from UnorderedMap is {:?}", value.clone());
            env::log(log_message.as_bytes());
            value
        },
        // None => "Didn't find that key.".to_string()
        None => "not found".to_string()
    }
}
```

[ [SDK source](https://github.com/near/near-sdk-rs/tree/master/near-sdk/src/collections/unordered_map) ]

[ [Implementation](https://docs.rs/near-sdk/latest/near_sdk/collections/unordered_map/struct.UnorderedMap.html) ]

---

### `TreeMap` {#treemap}

> Implements a Tree Map based on [AVL-tree](https://en.wikipedia.org/wiki/AVL_tree).
>
> - iterable
> - preserves order
> - able to clear all values
> - self balancing

- To add data:

```rust
pub fn add_tree_map(&mut self, key: String, value: String) {
    self.tree_map.insert(&key, &value);
}
```

- To get data:

```rust
pub fn get_tree_map(&self, key: String) -> String {
    match self.tree_map.get(&key) {
        Some(value) => {
            let log_message = format!("Value from TreeMap is {:?}", value.clone());
            env::log(log_message.as_bytes());
            // Since we found it, return it (note implicit return)
            value
        },
        // did not find the entry
        // note: curly brackets after arrow are optional in simple cases, like other languages
        None => "not found".to_string()
    }
}
```

[ [SDK source](https://github.com/near/near-sdk-rs/blob/master/near-sdk/src/collections/tree_map.rs) ]

[ [Implementation](https://docs.rs/near-sdk/latest/near_sdk/collections/struct.TreeMap.html) ]

---

## Storage Constraints on NEAR

For storing data on-chain it‚Äôs important to keep in mind the following:

- Can add up in storage staking costs
- There is a 4mb limit on how much you can upload at once

Let‚Äôs say for example, someone wants to put an NFT purely on-chain (rather than IPFS or some other decentralized storage solution) you‚Äôll have almost an unlimited amount of storage but will have to pay 1 $NEAR per 100kb of storage used (see Storage Staking).

Users will be limited to 4MB per contract call upload due to MAX_GAS constraints. The maximum amount of gas one can attach to a given functionCall is 300TGas.

'''
'''--- docs/1.concepts/storage/decentralized-storage.md ---
---
id: storage-solutions
title: Decentralized Storage Solutions
sidebar_label: Alternative Solutions
---

> In this article you'll find a brief overview of different decentralized storage solutions that can be integrated into your decentralized applications (dApps). This will allow you to store large amounts of data using a more economical alternative to native NEAR storage.

- [Arweave](#arweave)
- [Crust](#crust)
- [IPFS](#ipfs)

---

## On-Chain Storage Constraints

For storing data on-chain it's important to keep in mind the following:

- You can store an unlimited amount of files, but will cost you 1N per 100KB
- There is a 4 MB limit on how much you can upload at once

For example, if you want to store an NFT purely on-chain (rather than using IPFS or some other decentralized storage solution as mentioned below) you'll have almost an unlimited amount of storage but will have to pay 1 $NEAR per 100 KB of storage used (see [Storage Staking](https://docs.near.org/concepts/storage/storage-staking))

Users will be limited to 4MB per contract call upload due to `MAX_GAS` constraints. The maximum amount of gas one can attach to a given `functionCall` is 300TGas.

## Arweave

[Arweave](https://www.arweave.org/) is a new type of storage that backs data with sustainable and perpetual endowments
(tokens held within the protocol that benefit from inflation and the decrease in the cost of storage over long periods of time). This allows users and developers to store data forever.
Arweave acts as a collectively owned hard drive, and allows their users to preserve valuable information, apps, and history indefinitely.

The Arweave protocol matches a torrent-like swarm of incentivised miners with massive collective hard drive space with those individuals and organizations that need to store data or host content permanently. This is achieved in a decentralized network, and all data stored is backed by block mining rewards and a [sustainable endowment](https://arwiki.wiki/#/en/storage-endowment) ensuring it is available in perpetuity.

:::info
To learn more about Arweave, check its [mining mechanism](https://arwiki.wiki/#/en/arweave-mining) and its [bandwidth-sharing system](https://arwiki.wiki/#/en/karma).
:::

### Example implementation

Let's see how to store some files on Arweave, by running a local Arweave gateway-like server.

### Arlocal setup

[Arlocal](https://github.com/textury/arlocal) essentially creates a simulated version of Arweave. Think of it like a local node that runs on your computer to store information.

In this example you'll need to run **two terminals**.

- Open your first terminal and run:

```bash
npx arlocal
```

You should see the response: `arlocal started on port 1984`.

:::tip
You can specify the port by using `npx arlocal <desired port number>`.
:::

### NEAR-Arweave frontend

The [NEAR-Arweave repository](https://github.com/near-examples/NEAR-Arweave-Tutorial) has a simple frontend that allows you to store `.png` files using arlocal.

- Now open your second terminal and clone the frontend by running the following command:

```bash
git clone https://github.com/near-examples/NEAR-Arweave-Tutorial.git
```

- Install dependencies by running the following in the project folder:

```bash
cd NEAR-Arweave-Tutorial
yarn
```

- Next, start the application by running:

```bash
yarn start
```

- Now you're ready to upload an image by selecting the <kbd>Choose File</kbd> button:

![Arweave step 1](/docs/assets/arweave-1.png)

- You should see the transaction ID window become populated after hitting the <kbd>Submit</kbd> button:

![Arweave step 2](/docs/assets/arweave-2.png)

:::tip
If you get an error, make sure your arlocal node is running in a **separate terminal.**
:::

### Mining your transaction

On Arweave your transaction goes through two stages; a pending stage and a confirmed stage. For the transaction to be complete and for you to be able to retrieve your data, your transaction must be confirmed.

- Visit `http://localhost:1984/mine` in your browser to send a mine request to your local node.

:::tip
you may find that you are still able to retrieve your data without this step, but that's because you are running a local node.
When dealing with a real Arweave node you will have to wait until your transaction has been mined and confirmed.
:::

### Retrieve the image

- Now you can copy and paste any of your listed arweave transaction IDs in step 5 on the frontend to retrieve your file from your local node:

![Arweave step 3](/docs/assets/arweave-3.png)

:::info
Using Arweave's live network will require purchasing artokens to pay for storage. You can find out more at [arweave.org](https://www.arweave.org/).
:::

:::tip
The [near-api-js](https://github.com/near/near-api-js) and [arweave-js](https://github.com/ArweaveTeam/arweave-js) JavaScript libraries allow you to automate most of these steps.
:::

---

## Crust

[Crust](https://crust.network) provides a Web3.0 decentralized storage network for the Metaverse.
It is designed to realize core values of decentralization, privacy and assurance.
Crust supports multiple storage-layer protocols such as IPFS and exposes instant accessible on-chain storage functions to users.
Crust ºs technical stack is also capable of supporting data manipulation and computing.

The Crust protocol is 100% compatible with the [IPFS](https://ipfs.io) protocol, and it matches people who have hard drive space to spare with those who need to store data or host content.
Crust is based on the Polkadot ecosystem and supports most contract platforms, including NEAR/Solana/Ethereum/Elrond/etc. with its cross-chain solution.

:::info
To learn more about Crust, check its [Decentralized Storage Market](https://wiki.crust.network/docs/en/DSM) and [Guaranteed Proof of Stake](https://wiki.crust.network/docs/en/GPoS).
Also, you can start with [Build-101](https://wiki.crust.network/docs/en/build101).
:::

### Integration example

Here's a simple integration example to store a file with Crust and NEAR.

#### 1. Upload the file to IPFS

First, you need to put your files into IPFS.

:::tip
If you want to learn how to upload **files and folders** into IPFS, please refer to [this section](https://wiki.crust.network/docs/en/buildFileStoringWithGWDemo#1-upload-files-to-ipfs-gateway).
:::

There are 2 ways to upload a file to IPFS:

- using a local IPFS node
- using a remote [IPFS W3Authed Gateway](https://docs.ipfs.io/concepts/ipfs-gateway/#authenticated-gateways)

:::info
- You can find more details about `ipfsW3GW` endpoints on [this link](https://github.com/crustio/ipfsscan/blob/main/lib/constans.ts#L29).
- You can also find a code example on how to upload a file to IPFS on [this link](https://github.com/crustio/crust-demo/blob/main/near/src/index.ts#L20-L51).
:::

#### 2. Place an storage order

Next, you need to send a transaction named `Place Storage Order` on Crust chain.
This transaction will dispatch your storage requirement to each Crust IPFS nodes through the blockchain.
Then the IPFS nodes will start pulling your file using the IPFS protocol.

:::info
- You can find more information about `crustChainEndpoint` on [this link](https://github.com/crustio/crust-apps/blob/master/packages/apps-config/src/endpoints/production.ts#L9).
- You can create your own account (`seeds`) following [these instructions](https://wiki.crust.network/docs/en/crustAccount#create-an-account-1).
- Check [this link](https://github.com/crustio/crust-demo/blob/main/near/src/index.ts#L82-L112) for a code example about placing a storage order on Crust.
:::

#### 3. Query order status

Then, you can query the storage order by calling on-chain status (`status{replica_count, storage_duration, ...}`).
This call will return:

```json
{
    "file_size": 23710,
    "spower": 24895,
    "expired_at": 2594488, // Storage duration
    "calculated_at": 2488,
    "amount": "545.3730 nCRU",
    "prepaid": 0,
    "reported_replica_count": 1, // Replica count
    "replicas": [{
        "who": "cTHATJrSgZM2haKfn5e47NSP5Y5sqSCCToxrShtVifD2Nfxv5",
        "valid_at": 2140,
        "anchor": "0xd9aa29dda8ade9718b38681adaf6f84126531246b40a56c02eff8950bb9a78b7c459721ce976c5c0c9cd4c743cae107e25adc3a85ed7f401c8dde509d96dcba0",
        "is_reported": true,
        "created_at": 2140
    }] // Who stores the file
}
```

:::info
Find a code example about quering storage status on [this link](https://github.com/crustio/crust-demo/blob/main/near/src/index.ts#L144-L147).
:::

#### 4. Add file prepaid

The default storage time for a single transaction (order) is 6 months.
If you want to extend the storage duration, Crust provides a prepaid pool so you can customize the file's storage time.
This pool allows you to put some tokens and will automatically extend the file's storage time.

:::info
Follow [this link](https://github.com/crustio/crust-demo/blob/main/near/src/index.ts#L114-L142) for a code snippet on how to add prepaid tokens to your files.
:::

---

## IPFS

The [InterPlanetary File System](https://ipfs.io/) (IPFS) is a protocol and peer-to-peer network for storing and sharing data in a distributed file system. IPFS uses content-addressing to uniquely identify each file in a global namespace connecting all computing devices.

### Content identifier

When you add a file to IPFS it is split into cryptographically hashed smaller chunks and then given a unique fingerprint called a content identifier (CID).

:::tip
The CID acts as an permanent record of a file as it exists at that point in time.
:::

### Look-up

When a node looks up for a file, it ask the peer nodes for the content referenced by the file's CID. When a node views or downloads a file, it caches a copy and become another provider until the cache is cleared.

### Pinned content

On the IPFS network, each node stores only content it is interested in.
A node can pin content in order to keep it forever, or discard content it hasn't used to save space.

### File versions

When you add a new version of your file to IPFS it will get a new CID since the cryptographic hash is different.
This means that any changes to a file will not overwrite the original and common chunks across files can be reused in order to minimize storage costs.

### Naming system

IPFS offers a decentralized naming system so you don't need to remember a long string of CIDs.
IPFS can find the latest version of your file using the IPNS decentralized naming system and you can use DNSLink to map CIDs to human-readable DNS names.

### IPFS providers

- [Web3.Storage](https://web3.storage/): it's a service that simplifies building on top of IPFS and Filecoin. Web3.Storage is backed by Filecoin and makes content available via IPFS, leveraging the unique properties of each network.
- [NFT.Storage](https://nft.storage/): this service is built specifically for storing off-chain NFT data. Data is stored decentralized on IPFS and Filecoin. The data is referenced using content-addressed IPFS URIs that can be used in your smart contracts.
- [Filebase](https://filebase.com/): a geo-redundant IPFS pinning provider that pins all IPFS files with automatic 3x redundancy across diverse, geographic locations for additional performance, redundancy, and reliability.

'''
'''--- docs/1.concepts/storage/storage-staking.md ---
---
id: storage-staking
title: Storage Staking
sidebar_label: Storage Staking
---

> When you deploy a smart contract to NEAR, you pay for the storage that this contract requires using a mechanism called storage staking.
>
> In storage staking (sometimes called _state_ staking), the account that owns a smart contract must stake (or lock) tokens according to the amount of data stored in that smart contract, effectively reducing the balance of the contract's account.

<blockquote className="info">
<strong>Coming from Ethereum?</strong><br /><br />

If you‚Äôre familiar with Ethereum‚Äôs pricing model, you may know that, like NEAR, the protocol charges a fee (called "gas") for each transaction. Unlike NEAR, Ethereum's gas fee accounts for the amount of data stored via that transaction. This essentially means that anyone can pay once to store permanent data on-chain. This is a poor economic design for at least two reasons: 1. The people running the network (miners, in the case of Ethereum 1) are not appropriately incentivized to store large amounts of data, since a gas fee far charged in the distant past can increase storage costs forever, and 2. The users of a smart contract are charged for the data they send to store in it, rather than charging the owner of the smart contract.

</blockquote>

## How does NEAR's design align incentives?

Storage-staked tokens are unavailable for other uses, such as validation staking. This increases the yield that validators will receive. Learn more in [the economics whitepaper](https://pages.near.org/papers/economics-in-sharded-blockchain/).

## When do tokens get staked?

On each incoming transaction that adds data.

Let's walk through an example:

1. You launch [a guest book app](https://examples.near.org/guest-book), deploying your app's smart contract to the account `example.near`
2. Visitors to your app can add messages to the guest book. This means your users will, [by default](/concepts/protocol/gas#what-about-prepaid-gas), pay a small gas fee to send their message to your contract.
3. When such a call comes in, NEAR will check that `example.near` has a large enough balance that it can stake an amount to cover the new storage needs. If it does not, the transaction will fail.

## The "million cheap data additions" attack

Note that this can create an attack surface. To continue the example above, if sending data to your guest book costs users close to nothing while costing the contract owner significantly more, then a malicious user can exploit the imbalance to make maintaining the contract prohibitively expensive.

Take care, then, when designing your smart contracts to ensure that such attacks cost potential attackers more than it would be worth.

## btw, you can remove data to unstake some tokens

People familiar with the "immutable data" narrative about blockchains find this surprising. While it's true that an _indexing node_ will keep all data forever, _validating nodes_ (that is, the nodes run by most validators in the network) do not. Smart contracts can provide ways to delete data, and this data will be purged from most nodes in the network within a few [epochs](../basics/epoch.md).

Note that a call to your smart contract to remove data has an associated gas fee. Given NEAR's gas limit, this creates an upper limit on how much data can be deleted in a single transaction.

## How much does it cost?

Storage staking is priced in an amount set by the network, which is set to **1E19 yoctoNEAR per byte**, or **100kb per NEAR token (‚ìÉ)**. [^1] [^2]

NEAR's JSON RPC API provides [a way to query this initial setting](/api/rpc/setup#genesis-config) as well as a [a way to query the live config / recent blocks](/api/rpc/setup#protocol-config).

## Example cost breakdown

Let's walk through an example.

A [non-fungible token](https://github.com/near/NEPs/pull/4) is unique, which means each token has its own ID. The contract must store a mapping from token IDs to owners' account ID.

If such an NFT is used to track **1 million** tokens, how much storage will be required for the token-ID-to-owner mapping? And how many tokens will need to be staked for that storage?

Let's calculate the storage needs when using a `PersistentMap` that stores data as UTF-8 strings.

Here's our `PersistentMap`:

```ts
type AccountId = string;
type TokenId = u64;
const tokenToOwner = new PersistentMap<TokenId, AccountId>("t2o");
```

Behind the scenes, all data stored on the NEAR blockchain is saved in a key-value database. That `'t2o'` variable that's passed to `PersistentMap` helps it keep track of all its values. If your account `example.near` owns token with ID `0`, then at the time of writing, here's the data that would get saved to the key-value database:

- key: `t2o::0`
- value: `example.near`

So for 1 million tokens, here are all the things we need to add up and multiply by 1 million:

1. The prefix, `t2o`, will be serialized as three bytes in UTF-8, and the two colons will add another two. That's 5 bytes.
2. For an implementation where `TokenId` auto-increments, the values will be between `0` and `999999`, which makes the average length 5 bytes.
3. Let's assume well-formed NEAR `AccountId`s, and let's guess that NEAR Account IDs follow the approximate pattern of domain names, which [average about 10 characters](https://www.gaebler.com/Domain-Length-Research.htm), plus a top-level name like `.near`. So a reasonable average to expect might be about 15 characters; let's keep our estimate pessimistic and say 25. This will equal 25 bytes, since NEAR account IDs must use characters from the ASCII set.

So:

    1_000_000 * (5 + 5 + 25)

35 million bytes. 350 times 100Kib, meaning ‚ìÉ350. To do the exact math: Multiplying by 1e19 yoctoNEAR per byte, we find that the `tokenToOwner` mapping with 35m bytes will require staking 3.5e26 yoctoNEAR, or ‚ìÉ350

Note that you can get this down to ‚ìÉ330 just by changing the prefix from `t2o` to a single character. Or get rid of it entirely! You can have a zero-length prefix on one `PersistentVector` in your smart contract. If you did that with this one, you could get it down to ‚ìÉ250.

## Calculate costs for your own contract

Doing manual byte math as shown above is difficult and error-prone. Good news: you don't have to!

You can test the storage used using the [SDK environment](../../2.build/2.smart-contracts/anatomy/environment.md) and checking `env.storage_usage()`

## Other ways to keep costs down

Storing data on-chain isn't cheap for the people running the network, and NEAR passes on this cost to developers. So, how do you, as a developer, keep your costs down? There are two popular approaches:

1. Use a binary serialization format, rather than JSON
2. Store data off-chain

### Use a binary serialization format, rather than JSON

The core NEAR team maintains a library called [borsh](https://borsh.io/),
which is used automatically when you use `near-sdk-rs`. Someday, it will probably also be used by `near-sdk-js`.

Imagine that you want to store an array like `[0, 1, 2, 3]`. You could serialize it as a string and store it as UTF-8 bytes. This is what `near-sdk-js` does today. Cutting out spaces, you end up using 9 bytes.

Using borsh, this same array gets saved as 8 bytes:

    \u0004\u0000\u0000\u0000\u0000\u0001\u0002\u0003

At first glance, saving 1 byte might not seem significant. But let's look closer.

The first four bytes here, `\u0004\u0000\u0000\u0000`, tell the serializer that this is a `u32` array of length `4` using little-endian encoding. The rest of the bytes are the literal numbers of the array ‚Äì `\u0000\u0001\u0002\u0003`. As you serialize more elements, each will add one byte to the data structure. With JSON, each new element requires adding two bytes, to represent both another comma and the number.

In general, Borsh is faster, uses less storage, and costs less gas. Use it if you can.

### Store data off-chain

This is especially important if you are storing user-generated data!

Let's use this [Guest Book](https://github.com/near-examples/guest-book-examples) as an example. As implemented today, visitors to the app can sign in with NEAR and leave a message. Their message is stored on-chain.

Imagine this app got very popular, and that visitors started leaving unexpectedly long messages. The contract owner might run out of funding for storage very quickly!

A better strategy could be to store data off-chain. If you want to keep the app decentralized, a popular off-chain data storage solution is [IPFS](https://ipfs.io/). With this, you can represent any set of data with a predictable content address such as:

    QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG

Such a content address could represent a JSON structure or an image or any other type of data. Where does this data get physically stored? You could use [Filecoin](https://filecoin.io/) or run your own IPFS server to pin your app's data.

With this approach, each record you add to your contract will be a predictable size.

## Summary

NEAR's structure incentivizes network operators while giving flexibility and predictability to contract developers. Managing storage is an important aspect of smart contract design, and NEAR's libraries make it easy to figure out how much storage will cost for your application.

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol"><h8>Ask it on StackOverflow!</h8></a>
:::

## Footnotes

[^1]: [Storage staking price](https://gov.near.org/t/storage-staking-price/399)
[^2]: [Lower storage cost 10x](https://github.com/near/nearcore/pull/3881)

'''
'''--- docs/1.concepts/web3/blockchain.md ---
---
id: basics
title: Blockchain basics
sidebar_label: Blockchain basics
---

Before diving deeper into the intricacies of Web 3 development, let‚Äôs explore what it is and why it exists.
First of all - what does number 3 mean? The World Wide Web, or Internet in general, has evolved through the years and can be loosely divided into the 3 ‚Äúgenerations‚Äù:

- Web 1.0 - the first generation, roughly from 1991 to 2004. At this time, the Internet was slow, expensive, and dominated by static web pages. Most people were content consumers, with only a handful of content creators who created and hosted sites. JavaScript was at its infancy, media was rarely seen (due to speed and cost), and social media hadn't been invented yet. The Internet was highly decentralized and open to anyone. Everyone ran their own server or used one of the numerous hosting providers. Open protocols and standards were used for everything - HTTP, HTML, FTP, SMTP.
- Web 2.0 - the current generation, from around 2004 till now. A massive paradigm shift started to happen in the early 2000s. The Internet became faster and cheaper, and slowly but steadily spread into the lives of ordinary people. And as people trickled in, businesses followed. More and more services were offered through the web, like payments, shopping, and deliveries. Pages became more interactive and rich with media, but most importantly - users transitioned from just consuming content, to actively creating one. Social media boomed, smartphones were invented, and the web began its explosive growth we are still seeing to this day. 
At present day, the Internet touches almost every aspect of modern life, but with all of its usefulness comes a darker side. As it grew, it became more and more centralized. While this centralization brought a number of benefits, there are a number of problems as well. Digital ownership is one of them. As digital assets became ubiquitous, it became apparent that users don't really own them. Instead, ownership remained with centralized companies. Google can block access to your emails on Gmail any time it wants ([one example](https://www.businessinsider.com/terraria-google-youtube-gmail-play-2021-2)), or a game company can shut down a game server and destroy forever a game you once bought. 
Another major problem is a loss of privacy. A new business model has emerged, where users ‚Äúpay‚Äù for the services with their personal data. Social platforms ask us to share our personal information so they can feed us information we want to see. Once they have our attention they sell it to anyone who will buy it, effectively [harming society for financial gain](https://mitsloan.mit.edu/ideas-made-to-matter/social-media-broken-a-new-report-offers-25-ways-to-fix-it). 
- Web 3.0 - the next generation. It‚Äôs still in its early stages, and no one knows for sure how it will evolve, but several key aspects can already be outlined:
    - Focus on decentralization and privacy. Shift digital ownership from companies to users.
    - Trustless and permissionless.
    - Driven by the community through tokenomics and governance.

In this guide we‚Äôll demonstrate some of these Web3 principles in practice and show how to build an application, in which digital assets are decentralized and owned by users.

## Building blocks of Web decentralization

As we already briefly discussed, the current Web is highly centralized, and mostly built using [client-server architecture](https://en.wikipedia.org/wiki/Client%E2%80%93server_model) on centralized servers hosted on one of the clouds (AWS, Azure, GCP, etc). According to one [report](https://www.statista.com/statistics/292840/distribution-global-cloud-and-non-cloud-traffic/), 90% of mobile traffic goes to the clouds, which means a significant portion of the Internet is basically controlled by a handful of companies. This consolidation of power has a number of downsides and this article on "[Why Decentralization Matters](https://onezero.medium.com/why-decentralization-matters-5e3f79f7638e)" does a good job explaining some of those problems.

The first decentralization revolution happened in file sharing, with the arrival of the (in)famous BitTorrent protocol. By being a p2p protocol, it‚Äôs truly decentralized, and allows data to be stored distributedly without any central authority (and sometimes without consent of a central authority, which caused a lot of drama, but that‚Äôs a story for another time). Ideas behind this protocol have been used in modern decentralized file storages like IPFS and FileCoin, we‚Äôll come back to this later and explore it in more details.

The next revolution happened in the world of finance. For a long time transferring money required a central authority (banks), which would monitor, approve and execute these transfers. This has changed when the first cryptocurrency - Bitcoin - appeared. As already mentioned BitTorrent protocol, it also uses p2p communication, but instead of files it operates a transaction ledger, which is stored as a blockchain. Blockchain structure is needed to ensure that stored ledger cannot be altered, and at the same time to incentivize storage of this data. Unlike BitTorrent, Bitcoin network participants are rewarded for their services using a process called ‚Äúmining‚Äù. This created a foundation for a new form of currency - digital currency (or cryptocurrency), with a unique property that it doesn‚Äôt need a central authority to function. Instead, users themselves maintain and operate it. And as with the previous decentralized system, BitTorrent, central authorities have issues with this.

Following the success of Bitcoin, other cryptocurrencies started to appear. The most important one is Ethereum, which took the concept of blockchain one step further and adapted it to store not just a transactions leger, but any kind of data, and, most importantly code (which is just another form of data). Basically, it turned out we can use it as a decentralized database transaction log. And if we have data and code living in the decentralized database, the only thing we lack to build a decentralized application is an ability to execute this code. So Ethereum did just that, and a Smart Contract was born. Now, let's dive deeper into the world of blockchains, smart contracts, and explore how we can build decentralized applications with them.

## Blockchain basics

Let's start with a brief overview of what blockchain and smart contracts are.

In classical Web 2.0 applications, you need 2 things to build an application backend: a database to store data and a server to execute your code. The same is true for the Web 3.0, but instead of a database we have a blockchain, and instead of a server we have smart contracts.

Blockchain itself is just a linked list (chain) of transactions. As a performance optimization, instead of linking individual transactions, they are grouped into blocks. Linking happens using hashes - each block contains the cryptographic hash of a previous block. Such a structure grants us an important property - we cannot modify an individual transaction inside a chain, since it would change its hash and invalidate all transactions after it. This makes it an ideal structure to store in a decentralized fashion, since everyone can quickly verify the integrity of a transaction on a chain (and of the entire chain).

![image](/docs/assets/web3/web3-1.png)

Since we can only add new transactions to the chain, it serves as a decentralized transaction log. And if we have a [transaction log](https://en.wikipedia.org/wiki/Transaction_log), we basically have our database. Another good mental model is to think about this as a decentralized [event sourcing pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing), where each transaction represents a separate event. 

Due to the distributed nature of a blockchain, that has no single server which would manage a blockchain, a [consensus mechanism](https://www.investopedia.com/terms/c/consensus-mechanism-cryptocurrency.asp) is used to add new blocks, synchronize data between machines, and incentivize network participation. Several consensus mechanisms exist, we‚Äôll discuss them in more detail later.

It‚Äôs important to remember that every transaction on blockchain is publicly visible, so sensitive data should be encrypted beforehand.

But how do we put transactions into a blockchain? That‚Äôs the purpose of a Blockchain Node. Everyone can set up their own node, connect to the p2p blockchain network, and post new transactions. Also, this node provides access to the current blockchain data.

<div align="center">
<img src="/docs/assets/web3/web3--2.png" alt="image" width="440" />
</div>

Blockchain transactions themselves can be of a different type; exact supported types depend on a specific blockchain network. In the first Blockchain network, the Bitcoin, which stored only a financial ledger, transactions were quite simple - mostly just transfers of funds between accounts. This works very well for decentralized financing (Bitcoin is still the most popular cryptocurrency), but if we want to build general-purpose decentralized applications (or dApps for short), we need something better. That's where smart contracts come into the stage.

For Web 2.0 developers, a good way to think about a smart contract is as a serverless function which runs on blockchain nodes, instead of a traditional cloud. However, It has a few important properties:

- It is a pure function, which accepts the current state (which is stored on the blockchain) and caller-supplied arguments, and returns a modified state: _F(state, args)_ -> _state_. In practical terms, it means that we can‚Äôt do any external (off-blockchain) calls from it - no API or DB server calls are allowed. The reason behind this is decentralization - different nodes on the network should be able to execute it and get the same result.
- It‚Äôs fully open-source. Everyone is able to view your code and check what it‚Äôs doing.
- It cannot be changed. Once deployed, code remains on the chain forever and cannot be altered. Different upgrade mechanisms are possible, but are chain-specific.

Such properties allow us to make analogies with real-world legal contracts - they cannot be changed (usually), they're predictable and they're publicly accessible for participants. Smart contracts are basically such contracts, or agreements, but instead of a human performing actions, they are represented as code.

But how do we deploy and execute them, if everything we can do is to create a transaction?  All we need are 2 specific types of transactions:

- Deploy smart contract code, so it will be persisted in the blockchain, together with other data.
- Call a smart contract with given arguments. As an outcome, a modified state will be returned.

When a call transaction arrives on a node, it will read the contract's code and state from the blockchain, execute it, and put a modified state back on a chain (as a transaction).

<div align="center">
<img src="/docs/assets/web3/web3-2.png" alt="image" width="440" />
</div>

So far we‚Äôve explored how the backend layer of a dApp looks like, but what about the client side? Since we are using an API to communicate, we can use any kind of a client we use in the Web 2.0 - web, mobile, desktop, and even other servers. However, an important distinction lies with users. 

In a traditional Web 2.0 application, each server owns the identities of its users, and fully in control over who can and can‚Äôt use its services. In blockchain, however, there are no such restrictions, and anyone can interact with it (there are [private blockchains](https://www.investopedia.com/terms/p/permissioned-blockchains.asp), but we‚Äôll leave them out of scope). 

But how do we perform authentication if there is no standard login/registration process? Instead, we use public key cryptography, where a public key serves as a username, and a private key is a loose equivalent of a password. The major distinction is that instead of a login procedure, in which the server verifies the credentials and grants some form of an access token, here the users sign transactions with a private key. This means there's no classical Web 2 identity (like username, email, or an ID) available. This should be considered if you are building applications that require [KYC](https://en.wikipedia.org/wiki/Know_your_customer).

Another important implication of using private/public key pairs for auth, is that they cannot be easily memorized, like username/password pair. For this purpose, special applications called wallets are used. They store user‚Äôs key pairs and can sign transactions or provide them for other applications.

<div align="center">
<img src="/docs/assets/web3/web3-3.png" alt="image" width="440" />
</div>

The one aspect we haven‚Äôt considered yet is infrastructure cost. In WEB 2.0, users pay for the provided service (directly with money or indirectly with their data, or both), and service providers pay for the infrastructure. 

    
![image](/docs/assets/web3/web3-4.png)
     

In a Web 3.0 model, users pay directly to the infrastructure provider (nodes running in the blockchain), bypassing the service provider.

![image](/docs/assets/web3/web3-5.png)
             

This has huge implications:
- Service providers can‚Äôt shut down services or restrict their usage, since they are deployed on blockchain and can‚Äôt be removed. This means the application will live forever (or at least while the blockchain network is alive).
- A new monetization model should be used for such services, since users don‚Äôt pay directly to service providers. For example, a fee can be coded into a smart contract for performing certain actions.
- Since users should pay for the infrastructure, there‚Äôs no free lunch (this is usually true for Web 2.0 as well, but it‚Äôs often not obvious for ordinary users). Service providers can cover some cost or provide a credit to simplify onboarding, but ultimately users would have to pay.

But how do users pay? Since it‚Äôs a blockchain, they can‚Äôt pay directly with a credit card - in this way it will be tied to a central authority and not really decentralized. A solution is to use a decentralized currency - cryptocurrency. Each blockchain has its own currency, which is used for payments inside of it.
 
Whenever a user wants to perform an action on a blockchain by calling a smart contract, it should always pay an infrastructure cost, and optionally a service cost to the service provider.

![image](/docs/assets/web3/web3-6.png)
    

This infrastructure cost, often called ‚Äúgas‚Äù, usually consists of 2 parts:
- Computational cost - to cover computational power needed to add a transaction into a blockchain.
- Storage cost  - to cover additional storage requirements necessary for each transaction.

However, the question still remains how users can obtain cryptocurrency tokens in the first place. One option is to buy it from other users who already own it by using traditional money or another cryptocurrency. There are exchanges which provide such kind of functionality, e.g. [Binance](https://www.binance.com/en). But this will work only if there is already an existing supply of tokens already in circulation. 

In order to create and grow this supply the blockchain consensus mechanism is used. Earlier, we mentioned that it is used to incentivize blockchain network participation, but how exactly does it happen? Each node that processes transactions receives a reward for its work:

```
reward = infrastructureCostReward + coinbaseReward
```

where:

- `infrastructureCostReward` - share of infrastructure cost paid for the transactions by the users
- `coinbaseReward` - new cryptocurrency token created specifically to reward processing nodes

This means each time a transaction is processed a small amount of cryptocurrency is created, so the amount of cryptocurrency in circulation grows over time (of course some amount of tokens should be created to bootstrap the network, e. g. by using [ICO](https://www.investopedia.com/terms/i/initial-coin-offering-ico.asp)).

At a present day, two consensus mechanisms are commonly used:
- [Proof-of-work](https://www.investopedia.com/terms/p/proof-work.asp) - original consensus mechanism, which is currently used by Bitcoin and was used by Ethereum. It‚Äôs highly criticized for its inefficiency -  processing of new transactions requires ‚Äúmining‚Äù, which is a highly computationally intensive process. Because of this, graphic cards became an endangered species. Another disadvantage - cost of transactions is very high and processing speed is also quite slow.
- [Proof-of-stake](https://www.investopedia.com/terms/p/proof-stake-pos.asp) - newer consensus mechanism, which doesn‚Äôt require significant processing power (and graphic cards). Processing of transactions is usually called ‚Äúvalidation‚Äù. Newer chains, like NEAR, use it. Ethereum switched to Proof-of-stake (PoS) mechanism in September 2022. Transactions are usually much cheaper and processing speed is faster.

At this point, we should have enough knowledge to proceed to the next chapter - choosing the best blockchain to build dApps.

## Choosing the right blockchain

There are a lot of blockchains out there and it might be hard to choose the most suitable one for your needs. First of all, we should define the most important characteristics for a chain:

- Consensus algorithm - by now Proof-of-work proved to be too inefficient and not suitable for high-scale applications. Proof-of-stake seems like a much better choice for now. Other alternatives exist, but they are less explored and tried in practice.
- Transaction/Storage cost - cheaper cost directly benefits users (recall, that users will pay for it).
- Transaction speed - faster transactions processing time means better user experience.
- Scalability - whether a network is designed to support a large number of transactions. If not, transaction speed/cost may grow out of control over time. 
- Development experience - most importantly, what language we‚Äôll use to write our smart contracts. Ethereum popularized [Solidity](https://docs.soliditylang.org/en/v0.8.12/) as a programming language of choice for contracts. Several newer chains, like NEAR, chose Rust, which is a more mature general-purpose programming language.

Historically, the first blockchain to introduce smart contracts was Ethereum. However, as the number of users grew, transaction speed and cost skyrocketed, and it became apparent that it couldn't handle the demand. So, a number of [scaling solutions](https://ethereum.org/en/developers/docs/scaling.html) appeared - [layer 2 chains](https://ethereum.org/en/developers/docs/scaling.html#layer-2-scaling), [sidechains](https://ethereum.org/en/developers/docs/scaling/sidechains/), and [plasma chains](https://ethereum.org/en/developers/docs/scaling/plasma/). However, they all use some kind of workarounds with their own unique drawbacks. Ethereum tries to fix the core problem and redesign its network - like switching to a Proof-of-stake consensus, which is ongoing for quite a long time, but exact timeline when all of the problems will be fixed is very unclear.

Meanwhile, a new generation of blockchains started to appear. They learned from the Etherium mistakes, and designed them from ground-up to be fast, cheap and scalable. 
Choosing the right one is by no means an easy task, but for us we found the [NEAR](https://near.org/) blockchain to be an ideal solution, because of the following properties:
- Transactions are cheap and very fast.
- Designed to be extremely scalable from the beginning. This means we can count that transaction cost and speed will remain stable in the future.
- Uses Proof-of-stake consensus mechanism - so no hated ‚Äúmining‚Äù is needed.
- Rust is used as a primary programming language. Since it‚Äôs [a popular language](https://insights.stackoverflow.com/survey/2021#most-popular-technologies-language-prof) (and [one of the most loved](https://insights.stackoverflow.com/survey/2021#most-loved-dreaded-and-wanted-language-love-dread)), it‚Äôs much easier to learn and find developers on the market.

All of the further sections will use NEAR as an underlying blockchain, so before we jump into the intricacies of the Web 3.0 migration, we should take a closer look at it first.

'''
'''--- docs/1.concepts/web3/economics.md ---
---
id: economics
title: Web 3.0 Economics
sidebar_label: Economics
---

With technological decentralization also came economical decentralization. It stands on 3 pillars - Non-Fungible tokens (NFTs), Fungible tokens (FTs) and Decentralized Finance (DeFi).

## Non-Fungible Tokens
At the heart of the new Web 3 economy lies [Non-Fungible token](https://en.wikipedia.org/wiki/Non-fungible_token) (NFT). In a nutshell, it‚Äôs a way to  represent digital ownership in a decentralized way. From a technical perspective, it‚Äôs just a piece of data on a blockchain. The simplest case of such data is just a `(token_id, account_id)` tuple, where `token_id` uniquely identifies an asset, and `account_id` identifies an owner. A smart contract that owns this data defines a set of allowed operations - like creation of a new token (minting) or transfer of a token to another account. An exact set of allowed operations is defined in an NFT standard. Different blockchains have different standards, NEAR NFT Standard is available [here](https://nomicon.io/Standards/NonFungibleToken/). 

Because NFTs are tied to a specific contract, they mostly make sense only in scope of this contract, and subsequently they are tied to a specific dApp. It‚Äôs possible to implement transfer of NFTs between contracts, but there‚Äôs no standard way to do this.

What digital asset is hiding behind a `token_id` is up to the smart contract to decide. There are few common ways how to handle this:

-  Store an asset itself in a smart contract alongside the ownership information. This is the most straightforward way, but often is not feasible since storage cost is quite high and many types of digital assets, especially media, are quite big.

<div align="center">
<img src="/docs/assets/web3/web3-20.png" alt="image" width="400" />
</div>

- Store token data off-chain. Such an approach solves storage cost problems, but requires some level of trust to guarantee that data in the off-chain storage won‚Äôt be changed or removed. 

![image](/docs/assets/web3/web3-21.png)

- Store asset‚Äôs metadata and hash on chain, and an asset itself on some off-chain storage. Storing an asset‚Äôs hash on a chain guarantees data integrity and immutability. On-chain metadata usually includes basic token information, like title, description and media url. It‚Äôs required to quickly identify an asset without downloading it from the storage. This is the most popular approach to handle NFT‚Äôs since it combines the best of 2 previous approaches - token is immutable and storage cost is cheap (exact cost depends on the storage solution, but it usually several orders of magnitude cheaper than an on-chain storage)

![image](/docs/assets/web3/web3-22.png)

Choosing the right off-chain storage also can be a challenge, in general they can be divided into 2 buckets:
- Centralized storages - traditional Web 2 storage solutions, like relational databases or blob storages. While suitable for some applications, this means NFTs can be destroyed if a central server goes offline, so they aren‚Äôt the most popular in the Web 3 world.
- Decentralized storages. As we already mentioned, BitTorrent protocol is one of the first examples of such decentralized storage solutions, but in recent years more advanced solutions have appeared - like [IPFS](https://ipfs.io/), [FileCoin](https://filecoin.io/) and [Arweawe](https://www.arweave.org/). Such solutions are a preferred method to store digital assets, since they are cheap and decentralized, so no-one can destroy or alter NFT assets.

In addition to the NFT standard, NEAR also provides [its implementation](https://docs.rs/near-contract-standards/latest/near_contract_standards/non_fungible_token/index.html), which can be used by Smart Contract developers to implement NFTs in their smart contract. Implementation itself doesn‚Äôt dictate assets storage model, so it‚Äôs up to a developer to decide how and where it will be stored.

## Fungible Tokens
NFTs changed digital assets ownership model, but by itself they are not enough to build a full digital economy. In the simplest model, NFTs can be sold and bought using main blockchain currency (e.g. NEAR tokens), but this is quite limiting since circulation and price of such tokens is dictated by the blockchain itself. What if, instead of relying on blockchain currency, applications could create their own? For exactly this reason, Fungible Tokens (FT) have been created.

Similarly to NFTs, fungible tokens are also just a piece of data stored in a smart contract, but instead of storing unique token ids, an amount of tokens held by an account is stored.

<div align="center">
<img src="/docs/assets/web3/web3-23.png" alt="image" width="400" />
</div>

Smart Contracts can define allowed operations - like transfer or payment using this token. [NEAR defines a standard](https://nomicon.io/Standards/FungibleToken/Core) for fungible tokens and provides a [default implementation](https://docs.rs/near-contract-standards/latest/near_contract_standards/fungible_token/index.html).

Since an application is fully in control over emission and circulation of such tokens, a full fledged application economy can be created. For example, users can earn FTs for performing actions, and spend them to buy or mint new NFTs. 
Another exciting option is creation of [Decentralized Autonomous Organizations](https://near.org/use-cases/dao/) (DAOs), in which FTs can be used as a membership (or governance) tool. In such scenarios, tokens are awarded to members and can be used to vote on decisions or participate in community events. 

But we can push our tokens even further, by tying them to other cryptocurrencies and giving them a real-life monetary value. That‚Äôs where [Decentralized Finance](https://www.investopedia.com/decentralized-finance-defi-5113835) (DeFi), and especially [Decentralized Exchanges](https://en.wikipedia.org/wiki/Decentralized_exchange) (DEX) come into play. We won‚Äôt go into details here, but at the core a [liquidity pool](https://academy.binance.com/en/articles/what-are-liquidity-pools-in-defi) for a Fungible Token can be created on DEX, which allows trades of this token for other tokens or [stablecoins](https://en.wikipedia.org/wiki/Stablecoin). This opens the door for a new gaming model - [Play-to-Earn](https://en.wikipedia.org/wiki/Blockchain_game), where players can earn real-life money just by playing a game.

'''
'''--- docs/1.concepts/web3/intro.md ---
---
id: intro
title: Moving from Web 2 to Web 3
sidebar_label: Introduction
---

by Sigma Software

>DISCLAIMER. All references to particular products, frameworks, solutions, libraries and other software of NEAR ecosystem are provided for educational purposes only. All product names, logos, brands, trademarks and registered trademarks are property of their respective owners. Use of these names, trademarks and brands throughout the document does not imply endorsement.

## Introduction

In this guideline we‚Äôll see how to bring a traditional Web 2 application into a Web 3 world using NEAR Protocol.

It‚Äôs written for developers who are just starting their journey into the world of Web 3 and Blockchain, so we‚Äôll start by explaining what Web 3 and blockchain are. Then, we‚Äôll explore how to build decentralized applications (dApps) using NEAR Protocol. And after we‚Äôve learned the basics, we‚Äôll guide you through the intricacies of fusing client applications, traditional web servers and the NEAR blockchain.

During our journey we‚Äôll focus on high-level decisions, architecture, and explore not just HOW to do something, but also WHY it‚Äôs done this way. And as with anything, there‚Äôs no single right way, so we‚Äôll explore different alternatives and help you to choose the right one. 

Of course, real world applications aren‚Äôt built with words, but with code, so links to numerous code examples will be provided. But to make it as useful as possible, this guideline itself will be kept implementation and technology agnostic whenever possible.

If you are already familiar with Web 3 and blockchains, feel free to skip to the [NEAR Protocol section](near.md). And if you are already quite comfortable with NEAR, you can jump straight ahead into the [NFTs for Web 2 Applications](nfts.md) chapter, where we‚Äôll guide you on how to connect Web 2 and the NEAR blockchain together to bring the full power of NFTs into your app.

Without further ado, let‚Äôs begin our journey!

'''
'''--- docs/1.concepts/web3/near.md ---
---
id: near
title: NEAR Protocol
sidebar_label: NEAR Protocol
---

For the beginners, it‚Äôs always better to start with [documentation](/concepts/welcome), and NEAR has an excellent one. Here, we only focus on basic concepts which are necessary to understand later chapters, so an entire guideline could be understood without prior NEAR knowledge.

## Accounts & Transactions
NEAR's account system is very powerful and differs substantially from other blockchains, like Bitcoin or Ethereum. Instead of identifying users by their public/private key pairs, it defines accounts as first-class entities. This has a few important implications:
- Instead of public keys, users can use readable account names.
- Multiple key pairs with [different permissions](../protocol/access-keys.md) can be used. This provides a better security model for users, since loss of one key pair doesn‚Äôt compromise an entire account and has a quite limited impact.
- Hierarchical accounts structure is supported. This is useful if we want to manage multiple smart contracts under one parent account.
- Accounts/public keys are created using transactions, since they are stored on the blockchain.

More information on NEAR accounts can be [found in the docs](../protocol/account-model.md).

But an account by itself won‚Äôt get us anywhere, its [transactions](../protocol/transactions.md) that make things happen. In NEAR, we have only one transaction type, but the transaction itself may have different actions included. For most practical purposes, transactions will have a single action included, so for simplicity we‚Äôll use ‚Äúaction‚Äù and ‚Äútransaction‚Äù terms interchangeably further down the road. Each transaction always has sender and receiver accounts (and it is cryptographically signed by the sender‚Äôs key). The following transaction (action) types are supported:

- CreateAccount/DeleteAccount, AddKey/DeleteKey - accounts and key management transactions.
- Transfer - send NEAR tokens from one account to another. The basic command of any blockchain.
- Stake - needed to become a validator in a Proof-of-Stake blockchain network. We won‚Äôt touch this topic in this guideline, more information [can be found here](https://near-nodes.io/validator/staking-and-delegation).
- DeployContract - deploy a smart contract to a given account. An important thing to remember - one account can hold only one contract, so the contract is uniquely identified by the account name. If we issue this transaction to an account which already has a deployed contract, a contract update will be triggered.
- FunctionCall - the most important action on the blockchain, it allows us to call a function of a smart contract.

Smart Contracts on NEAR are written in Rust or JavaScript, and compiled into [WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly). Each contract has one or more methods that can be called via a FunctionCall transaction. Methods may have arguments provided, so each smart contract call includes the following payload: account id, method name, and arguments.

There are 2 ways to call a method on a smart contract:
1. Issue a FunctionCall transaction. This will create a new transaction on a blockchain which may modify a contract state.
2. Make a smart contract view call. NEAR blockchain [RPC nodes](https://near-nodes.io/intro/node-types#rpc-node) provide a special API that allow execution of methods that do not modify contract state (readonly methods).

The second method should always be used whenever possible since it doesn‚Äôt incur any transaction cost (of course, there is some cost of running a node, but it‚Äôs still much cheaper than a transaction; public nodes are available which can be used free of charge). Also, since there‚Äôs no transactions, we don‚Äôt need an account to make a view call, which is quite useful for building client-side applications

## Gas and Storage

As we already discussed, users should pay computational costs for each transaction. This cost is called ‚Äúgas‚Äù and is measured in [gas units](../protocol/gas.md) (this is an established term in the blockchain world). Each time a transaction is posted, an amount of gas is attached to it to cover the cost. For simple transactions, gas can be calculated ahead of time to attach an exact amount. For FunctionCall transactions, however, exact cost is impossible to automatically calculate beforehand, so the usual approach is to attach a large enough amount of gas to cover the cost, and any excess will get automatically refunded.

![image](/docs/assets/web3/web3-7.png)
    

But why do we need separate gas units, why not just pay directly with NEAR tokens? It‚Äôs necessary to accommodate for changing infrastructure costs - as the network evolves over time, cost of gas units may change, but the amount of gas required for a transaction will remain constant.

However, computational cost is not everything - most smart contracts also need storage. The storage cost in NEAR is quite different from gas.
First of all, it‚Äôs not cheap - while gas is very cheap and its cost will be almost unnoticeable by the users, storage is very expensive. As a consequence, the storage budget should be carefully calculated and only necessary data stored on the blockchain. Any auxiliary data (that is not necessary to the contract operations) should be stored off-chain (possible solutions will be covered in later chapters).
The second important difference - storage is not bought, but leased (in NEAR, it‚Äôs called staking). When a smart contract wants to store some data, storage cost is computed and the appropriate amount of NEAR tokens is ‚Äúlocked‚Äù on the account. When data is removed, tokens are unlocked. And unlike gas, these tokens are locked on the smart contract‚Äôs account, so the user doesn‚Äôt directly pay for it.

But what if we want users to pay for the storage (or just pay some fee for using a smart contract)? So far, the only way we‚Äôve seen to transfer a token is a Transfer transaction. It turns out, a FunctionCall transaction also allows us to transfer tokens alongside the call (this is called a deposit). Smart Contracts can verify that an appropriate amount of tokens has been attached, and refuse to perform any actions if there‚Äôs not enough (and refund any excess of tokens attached).

In combination, gas fee and deposit attachments enable creation of contracts that need zero cost from developers to support and can live on blockchain forever. Even more, 30% of gas fees spent on the contract execution will go to a contract‚Äôs account itself (read more [here](https://near.org/blog/near-protocol-economics/#:~:text=a%20new%20entity.-,Contract%20rewards,-As%20one%20of)), so just by being used it will bring some income. To be fair, due to the cheap gas cost this will make a significant impact only for most popular and often-called contracts, but it‚Äôs nice to have such an option nonetheless.

One last gotcha about storage - remember that smart contracts themselves are also just a code stored on a blockchain, so a DeployContract transaction will also incur storage fees. Since smart contracts code can be quite big, it‚Äôs important to optimize their size. A few tips on this:
- Don‚Äôt build Rust code on Windows, it produces quite big output. Use WSL or build on other OSes.
- Optimize smart contracts code for size - [more info here](/sdk/rust/contract-size).

More details on the storage model can be [found in the docs](../storage/storage-staking.md).

## Clients Integration

So far, we‚Äôve discussed how to call smart contracts in a client-agnostic way. However, in the real world, calls we‚Äôll be performed from a client side - like web, mobile or a desktop application.

As we‚Äôve learned from previous chapters, each transaction should be signed using a key. And since keys are managed by a wallet, each application should integrate with it. At the time of this writing, there‚Äôs only one officially supported [NEAR Wallet](https://wallet.near.org/). It is a web application, so integration happens using HTTP redirects. This is relatively straightforward to do in web applications (JavaScript SDK is available), but for mobile or desktop applications it may require deep linking or other more advanced approaches.

The general flow for transactions signing looks like this:

![image](/docs/assets/web3/web3-9.png)
    

Each time we want to post a transaction, the client redirects the user to a wallet, where the transaction is approved and wallet returns a signed transaction back to the client (via redirect). This is a quite secure way of signing, since the private key is not exposed to the client, but constant redirects might quickly get annoying for users, especially if we just want to call smart contract functions that incur only small gas fees. That‚Äôs why NEAR introduced [two types of access keys](../../1.concepts/protocol/access-keys.md) - full keys and functional call keys. Full access keys, as the name implies, can be used to sign any types of transactions. Functional call keys, on the other hand, aim to solve this UX problem. They are tied to a specific contract, and have a budget for gas fees. Such a key can‚Äôt be used to sign transactions that transfers NEAR tokens (payable transactions), and can only be used to cover gas fees, that‚Äôs why it‚Äôs not so security-critical and can be stored on the client. Because of this, we can create a simplified signing flow for non-payable transactions. First of all, a login flow to obtain a Functional Call key is used.

![image](/docs/assets/web3/web3-10.png)

The client generates a new key pair and asks a wallet to add it as a functional call key for a given contract. After this, a login session is established and considered alive until the client has the generated key pair.
To provide the best user experience usage of both keys is combined - type of signing is determined based on a transaction type (payable or non-payable). In case of a payable transaction, flow with wallet redirection is used, otherwise simplified local signing flow (using a stored function call key) is applied:

<div align="center">
<img src="/docs/assets/web3/web3-11.png" alt="image" width="300" />
</div>

It‚Äôs important to note that it‚Äôs possible to generate a Full Access key using the same key addition flow as for the Functional Call key, but this is very dangerous since compromise of such key will give full control over an account. Applications that want to work with Full Key directly should be designed with extreme care, especially in the matters of security.

## Cross-contracts calls

Throughout this section, we‚Äôve discussed how to call a smart contract from a client. But a single smart contract can only take us so far. The true power is achieved when smart contracts are working in concert and communicating with each other. To achieve this, NEAR provides cross-contract calls functionality, which allows one contract to call methods from another contract. The general flow looks like this:

![image](/docs/assets/web3/web3-12.png)
    

Looks simple enough, but there are few gotchas:
- In order to provide a call status (success or failure) and a return value to the calling contract, a callback method should be called, so there‚Äôs no single activation of ContractA. Instead, an entry method is called first by the user, and then a callback is invoked in response to cross-contract call completion.
- Transaction status is determined by the success or failure of a first function call. For example, if a ContractB.methodB or ContractA.methodACb call fails, the transaction will still be considered successful. This means that to ensure proper rollbacks in case of expected failures, custom rollback code must be written in the ContractA.methodACb, and the callback method itself must not fail at all. Otherwise, smart contract state might be left inconsistent.
- Cross-contract calls must have gas attached by the calling contract. Total available gas is attached to a transaction by a calling user, and distributed inside the call chain by contracts. For example, if 15TGas are attached by the user, ContractA may reserve 5TGas for itself and pass the rest to ContractB. All unspent gas will be refunded back to the user.

![image](/docs/assets/web3/web3-13.png)

- NEAR tokens can also be attached to cross contract calls, but they work differently from the gas. Attached deposit is taken directly from the predecessor account. It means even if a user hasn‚Äôt attached any deposit, a contract still can attach tokens, which will be taken from its account. Also, since cross-contract call failure doesn‚Äôt mean transaction failure, there are no automatic refunds. All refunds should be done explicitly in the rollback code.

![image](/docs/assets/web3/web3-14.png)
    

A few notes on failure modes - since smart contracts run on a decentralized environment, which means they are executed on multiple machines and there is no single point of failure, they won‚Äôt fail because of environment issues (e.g. because a machine suddenly lost power or network connectivity). The only possible failures come from the code itself, so they can be predicted and proper failover code added.

In general, cross-contract call graphs can be quite complex (one contract may call multiple contracts and even perform some conditional calls selection). The only limiting factor is the amount of gas attached, and there is a hard cap defined by the network of how many gas transactions may have (this is necessary to prevent any kind of DoS attacks on the Network and keep contracts complexity within reasonable bounds).

## Data Structures, Indexers and Events

We‚Äôve already discussed the storage model on NEAR, but only in abstract terms, without bringing the exact structure, so it‚Äôs time to dive a bit deeper.

Natively, NEAR smart contracts store data as key-value pairs. This is quite limiting, since even simplest applications usually need more advanced data structures. To help in development, NEAR provides [SDK for smart contracts](https://github.com/near/near-sdk-rs), which includes data structures like [vectors, sets and maps](../../1.concepts/storage/data-collections.md#rust-collection-types-rust-collection-types). While they are very useful, it‚Äôs important to remember a few things about them:
- Ultimately, they are stored as binary values, which means it takes some gas to serialize and deserialize them. Also, different operations cost different amounts of gas ([complexity table](../../1.concepts/storage/data-collections.md#big-o-notation-big-o-notation-1)). Because of this, careful choice of data structures is very important. Moving to a different data structure later will not be easy and would probably require data migration.
- While very useful, vectors, maps and sets won‚Äôt match the flexibility and power of classical relational databases. Even implementations of simple filtering and searching might be quite complex and require a lot of gas to execute, especially if multiple entities with relations between them are involved.
- They are limited to a single contract. If data from multiple contracts is required, aggregation should be performed using cross-contract calls or on a client side, which is quite expensive in terms of gas and time.

To support more complex data retrieval scenarios, smart contract data should be put in a more appropriate store, like a relational database. [Indexers](../../4.tools/indexer4explorer.md) are used to achieve this. In a nutshell, indexer is just a special kind of blockchain node that processes incoming transactions and puts relevant data into a database. Collected data can be exposed to a client using a simple API server (e.g. REST or GraphQL).

![image](/docs/assets/web3/web3-15.png)
    

In order to simplify creation of indexers, [NEAR Indexer Framework](/concepts/advanced/near-indexer-framework) has been created. However, even with a framework available, extracting data from a transaction may not be an easy task, since each smart contract has its unique structure and data storage model. To simplify this process, smart contracts can write structured information about outcome into the logs  (e.g. in the JSON format). Each smart contract can use its own format for such logs, but the general format has been standardized as [Events](https://nomicon.io/Standards/EventsFormat).

Such architecture is very similar to Event Sourcing, where blockchain stores events (transactions), and they are materialized to a relational database using an indexer. This means the same drawbacks also apply. For instance, a client should be designed to accommodate indexing delay, which may take a few seconds.

As an alternative to building your own indexer with a database and an API server, [The Graph](https://thegraph.com/en/) can be used instead, which currently has [NEAR support in beta](https://thegraph.com/docs/en/supported-networks/near/). It works using the Indexer-as-a-Service model, and even has decentralized indexing implementation.

## Development tools

By now, we should be familiar with necessary concepts to start developing WEB 3.0 applications, so let‚Äôs explore the development tools available.

First of all, we need a development and testing environment. Of course, we could theoraticaly perform development and testing on the main blockchain network, but this would not be cheap. For this reason, NEAR provides [several networks](../../1.concepts/basics/networks.md) that can be used during development:
- testnet - public NEAR network which is identical to mainnet and can be used for free.
- localnet - you can deploy your personal NEAR network on your own environment. Because it‚Äôs owned by you, data and code can be kept private during development. More info on how you can run your own node can be [found here](https://near-nodes.io/validator/running-a-node). Alternatively, you can bootstrap an entire testing infrastructure in Docker on your local machine using Kurtosis - [guide is here](../../2.build/2.smart-contracts/testing/kurtosis-localnet.md).
- workspaces - you can start your own local network to perform e2e testing. More info [here](../../2.build/2.smart-contracts/testing/integration-test.md).

Once we‚Äôve chosen a network to use, we need a way to interact with it. Of course, transactions can be constructed manually and posted into [node‚Äôs API](/api/rpc/setup). But [this is tedious](https://github.com/near-examples/transaction-examples) and isn‚Äôt fun at all. That‚Äôs why, NEAR [provides a CLI](../../4.tools/cli.md) which automates all of the necessary actions. It can be used locally for development purposes or on build machines for CI/CD scenarios.

In order to manage accounts on the NEAR network, [Wallet](https://wiki.near.org/overview/tokenomics/creating-a-near-wallet) can be used. It can show an effective account balance and active keys.

![image](/docs/assets/web3/web3-16.png)

On the image above, ‚ÄúReserved for storage‚Äù are tokens locked by a smart contract to cover current storage requirements, and ‚ÄúReserved for transactions‚Äù represents the amount of tokens locked to cover gas cost by Functional Call keys.
Currently, there‚Äôs no UI to connect sub-accounts into a wallet. Instead, they should be imported via a specially constructed direct link:
```
https://testnet.mynearwallet.com/auto-import-secret-key#YOUR_ACCOUNT_ID/YOUR_PRIVATE_KEY
```
(you should provide a private key of a full access key for the account in question, so make sure this link is used securely).

Last, but not least, blockchain transactions can be viewed using NEAR Explorer. It provides insights into transaction execution and outcome. Let‚Äôs look at [one example](https://testnet.nearblocks.io/txns/ABh4zQ5aZ3CGhpQzstL16TAB8TvqPbiirJG1uTPJVxTt).
First of all, we can see general transaction information - sender, receiver, status. After this, we can see gas usage information:
- Attached gas - total gas provided for the transaction.
- Gas used - actual gas spend.
- Transaction fee - gas used multiplied to current gas price, shows an actual cost of a transaction in NEAR tokens.
Also, Deposit Value shows the amount of NEAR tokens transferred from sender to receiver.

![image](/docs/assets/web3/web3-17.png)

Below this, we can inspect transaction actions (recall, that transactions may have multiple actions). In this case, we have a single FunctionCall action with arguments:

![image](/docs/assets/web3/web3-18.png)

At the end, transaction execution details, including token transfers, logs, cross-contract calls and gas refunds are provided. One thing that we haven‚Äôt covered yet is shown here - [receipts](../protocol/transactions.md#receipt-receipt). For most practical purposes they are just a transaction implementation detail. They are quite useful in a transaction explorer to understand how a transaction was executed, but aren‚Äôt really relevant outside of it.

![image](/docs/assets/web3/web3-19.png)

## Contract upgrades

During the development, and sometimes even in production, updates to a contract‚Äôs code (or even data) are needed. That‚Äôs why different contract upgrades mechanisms have been created.

While developing the contract, we recommend just creating a new account each time you need to deploy a contract (the [create-account](../../4.tools/cli.md#near-create-account) command in NEAR CLI exists for this). With such an approach, you will start with a clean state each time.
 
However, once we move to a more stable environment, like testing or production, more sophisticated methods are needed. Redeployment of code is quite simple: we just issue another `DeployContract` transaction, and NEAR will handle the rest. The biggest challenge is to migrate contract state - [several approaches are possible](../../2.build/2.smart-contracts/release/upgrade.md#migrating-the-state), but all of them involve some kind of migration code.

But we can take our upgrade strategy one step further. In the previous strategies, developers are fully in control of code upgrades. This is fine for many applications, but it requires some level of trust between users and developers, since malicious changes could be made at any moment and without the user‚Äôs consent (as it [sometimes happens](https://www.bleepingcomputer.com/news/security/dev-corrupts-npm-libs-colors-and-faker-breaking-thousands-of-apps/) in npm world). To solve this, a contract update process itself can also be decentralized - this is called [Programmatic Updates](../../2.build/2.smart-contracts/release/upgrade.md#programmatic-update). The exact strategy may vary, but the basic idea is that the contract update code is implemented in a smart contract itself, and a Full Access key to the contract account is removed from a blockchain (via DeleteKey transaction). In this way, an update strategy is transparent to everyone and cannot be changed by developers at will.

## Further reading

For a deep dive into NEAR, the following links will be useful:

- [NEAR docs](https://docs.near.org)
- [Rust Smart Contract docs](/sdk/rust/introduction)
- [Smart Contract quick start guide](../../2.build/2.smart-contracts/quickstart.md)
- [NEAR Protocol Specification](https://nomicon.io/)
- [How to build a dApp on NEAR](../../3.tutorials/examples/guest-book.md)

'''
'''--- docs/1.concepts/web3/nfts.md ---
---
id: nfts
title: NFTs for Web 2 Applications
sidebar_label: NFTs for Web 2.0 Apps
---

# NFTs for Web 2 Applications

At the first stage of our Web 3 transformation, let‚Äôs decentralize ownership of our digital assets using blockchain technology. By doing this, we can create a user-owned economy, where digital assets are exchanged and traded without any participation or control from the developers. Later, we‚Äôll discuss how to bring it to the next level by adding Fungible Tokens into the mix.

As we discussed previously, in the Web 3 world, NFTs are used to represent ownership of an asset. This can be anything a user owns, e.g. in case of a game this can be a character, upgrade, crafting material, skin, etc. However, since NFTs are living on the blockchain, and the rest of the application resides on traditional servers, we need to find a way to connect these different worlds together.

## Blockchain-Enabled Application Architecture

First of all, let‚Äôs outline a typical architecture of a Web 2 application. In most cases, a classic client-server model is used:

<div align="center">
<img src="/docs/assets/web3/nfts-1.png" alt="image" width="150" />
</div>

In such architecture, we usually have 3 layers:
- Database - stores application‚Äôs data. This can be a single database, or several databases of different types, but this is mostly an implementation detail - for our purposes we can view it as a single logical database.
- Server - a centralized web-server. It may be implemented using different architecture patterns (monolithic, microservices, serverless) and technologies, but again, we can consider it as a single logical server.
- Client - client side application user directly interacts with. Different client types are possible: web, mobile or desktop. There is a difference between these clients in regards to blockchain integration, which we‚Äôll discuss later.

Now, let‚Äôs compare it to a dApp architecture:

<div align="center">
<img src="/docs/assets/web3/nfts-2.png" alt="image" width="400" />
</div>

We can notice that there is a common component in these architectures - the client application. This means we can use it as a junction point to connect them together.

<div align="center">
<img src="/docs/assets/web3/nfts-3.png" alt="image" width="400" />
</div>

A keen reader may notice an additional connection between the Server and RPC Node. This is required because in a client-server architecture clients cannot be trusted. That‚Äôs why every action performed from the client should be validated by a backend server. But in our case everything is complicated by the fact that we essentially have two backends: Web 2 server and a smart contract, so two possible validation flows are possible:
- Client performs an action on a server, which involves blockchain data. In this case the server should talk to the blockchain and verify that valid data is provided.
- Client performs an action on a smart contract, which involves server-owned data. Since the smart contract can‚Äôt talk to the server directly to verify it, we should use a different way to verify the authenticity of the data. In blockchain terminology, such a server is called an [Oracle](https://en.wikipedia.org/wiki/Blockchain_oracle).
We‚Äôll explore how to implement both of these approaches later.

By now, we've reached the point where the type of our client begins to matter. Specifically, problems arise from the dApps payment model - user‚Äôs pay for the blockchain infrastructure using gas, so money goes directly to infrastructure providers. Also, users make payments directly on the blockchain, without using any intermediaries, like banks or payment services. This approach is at odds with mobile app stores (Google Play Store and Apple App Store) - they don‚Äôt allow any payments on their respective mobile platforms without their cut. Although some shifts in policy are starting to happen (e.g. [Apple vs Epic Games duel](https://en.wikipedia.org/wiki/Epic_Games_v._Apple)), at the time of this writing getting blockchain-enabled applications into the stores will probably get vetoed by reviewers. There are some ways to bypass these limitations, e.g. by not using Play Store on Android, but all of these ways are either sub-par in terms of usability or involve some risk of getting banned by stores. That‚Äôs why for mobile applications an alternative approach is needed. 

Sometimes, to move forward we need to take a step back. In our case, to solve a problem with mobile clients we can return to our initial concept of having two clients - one for blockchain integration, and another one for Web 2 server. Blockchain client can be a usual web application, which isn‚Äôt subject to any constraints from stores. It can also serve as a connection point between blockchain and our existing application.

![image](/docs/assets/web3/nfts-4.png)

In this architecture the mobile client is still allowed to talk to the blockchain, but only in a read-only way, which doesn‚Äôt require wallet connection or any payments. All actions on the blockchain happen on the Web Client instead.
Further in this guide we‚Äôll use such dual-client architecture, since simpler architecture with a single client can be directly derived from it by merging two clients together.

At this point, our architecture covers almost everything we need to start building our application. However, since we want to build a user-owned economy, we need a marketplace where it‚Äôll happen. An obvious choice is to put this marketplace into the web client, but there‚Äôs one gotcha. If we recall the smart contract‚Äôs storage model, it‚Äôs not suitable to serve complex data queries, so an indexer should be used to aggregate data from blockchain into a proper database.

![image](/docs/assets/web3/nfts-5.png)

By now, every building-block is in place and we can start exploring how to implement this architecture in practice.

## NFTs in Web 2 Applications

In order to implement a fully functional application using a hybrid Web 2 - Web 3 architecture, a lot of technological challenges have to be addressed, like authentication and authorization, seamless NFTs usage in client and server, and proper NFT storage model. In the following sections we‚Äôll take a closer look at this and describe common patterns and approaches.

### Authentication and Authorization 

Since our digital assets are represented as NFTs on blockchain, in order to use them in our Web 2 application, a server needs a way to authorize their usage. The basic idea is pretty simple - it can just read data from blockchain by calling a smart contract method and check an owner‚Äôs account id. For such flow, we have 3 actors:

* Client that wants to use some digital asset (NFT). 
* Smart Contract for NFTs. Should be implemented according to [NEAR NFT standards](https://nomicon.io/Standards/NonFungibleToken/).
* Server that verifies ownership of NFT and uses it in its internal logic. 

A general flow looks like this:

![image](/docs/assets/web3/nfts-6.png)

However, such an authorization process cannot be performed without authentication, so the server also needs a way to authenticate a user.

Recall that the user's identity on a blockchain is represented by a key pair. However, since in NEAR a user may have multiple key pairs and an account is a separate entity, the authentication procedure is a bit more complicated. 

To authenticate our requests, we can use public-key cryptography - a client can sign a request using a user‚Äôs private key, and then a server can verify the signature and key ownership. A typical request with authentication may look like this:

```javascript
{
	"payload": { /* request-specific payload */ },
	"accountId": "account.near",
	"publicKey": "...",
	"timestamp": 1647091283342,
	"signature": "..."
}
```

where:

* `accountId` ‚Äì user‚Äôs account id on NEAR.
* `publicKey` - public key of the key pair used for signature, must be either Functional or Full access key for the provided account.
* `timestamp` - current datetime, must be verified on server. It‚Äôs needed to prevent [replay attacks](https://en.wikipedia.org/wiki/Replay_attack). Alternative to timestamps is usage of [nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce), but it‚Äôs more complicated.
* `signature` - signature of the request payload and other fields. Usually, a payload is hashed beforehand.

Depending on the implementation, request body, headers, or other side channels can be used to transfer authentication data - exact implementation depends on used technologies and protocols.

Server can use this data to authenticate a request using the following approach:

![image](/docs/assets/web3/nfts-7.png)

3 authentication steps are performed on the server:

1. Signature verification - if the signature is correct, we are sure that the client really has the private key for the provided public key. Also, this proves that request data hasn't been modified in transit.
2. Timestamp verification - prevents replay attacks. Server can verify that the request‚Äôs timestamp is not too old (e.g. has been created no more than 10 seconds ago).
3. Public key ownership verification - by calling [view_access_key method](../../5.api/rpc/access-keys.md), we can make sure that the provided public key is really associated with the provided account.

Such authentication approach is the simplest one, but has a few major drawbacks:

* Performing a REST API call to RPC Node is quite expensive to do each time from the performance perspective.
* We can‚Äôt sign requests from the mobile client, since it usually should be disconnected from the blockchain due to store policies, and hence doesn‚Äôt have a key pair.
* A NEAR account is required in order to start using the application, which complicates the onboarding process.

To solve the first problem, we can simply issue a JWT token or authenticate connection in some other way after a successful NEAR account authentication, so the it will serve as ‚Äúlogin‚Äù of sorts:

![image](/docs/assets/web3/nfts-8.png)

While this may be enough for some applications, it doesn‚Äôt address the last 2 problems. In order to solve all of them, we can use a hybrid authentication approach with 2 accounts:

1. ‚ÄúClassic‚Äù Web 2 account - all clients can use this account to call a server. For example, this can be a simple username/password or OAuth 2 login with a JWT token.
2. NEAR account - can be used from non-mobile clients only. Instead of performing NEAR account auth each time we need to use it, we can do it a single time in order to ‚Äúconnect‚Äù this account to our primary Web 2 account and store Classic-NEAR account connection in our server database. In this way we solve all problems - server doesn‚Äôt need to authenticate NEAR account each time it wants to perform an authorization, instead it can read an associated NEAR account from its own database.

With such hybrid approach, different authentication methods are used for blockchain and server:

<div align="center">
<img src="/docs/assets/web3/nfts-9.png" alt="image" width="400" />
</div>

NEAR account connection sequence can be implemented in a very similar way to the already described NEAR authentication method, where at the end we store an authenticated account in our database:

![image](/docs/assets/web3/nfts-10.png)

There‚Äôs one more improvement we can make to this flow. Since a Web Client uses both accounts, a user is forced to login using both Web 2 login method (e.g. login/password) and NEAR Wallet. This is not ideal from the UX perspective, so we can simplify it by introducing a ‚ÄúLogin with Wallet‚Äù method to our server, which would work when a user already has a wallet connected. We can do this in a similar way to the account connection flow:

![image](/docs/assets/web3/nfts-11.png)

Now, as we‚Äôve discussed possible approaches for authentication, let‚Äôs summarize it as an overall login flow for our clients:

![image](/docs/assets/web3/nfts-12.png)

Of course, this is just one possible flow, and a different solution can be assembled from described building blocks. The most important considerations for choosing right authentication flow are following:

* Type of your client - for web/desktop clients, or sideloaded Android clients, it‚Äôs possible to use Wallet as a single authentication method. For mobile clients installed from a store, a hybrid approach with multiple auth methods should be used.
* Target audience - if you target regular users that are not familiar with blockchain technologies, having a hybrid auth method to simplify onboarding might be better than forcing users to learn blockchain before trying your application.

#### Blockchain Auth & Auth

So far, we‚Äôve discussed authentication and authorization on the Web 2 server‚Äôs side. But what about Web 3 smart contracts? Everything is much more straightforward in this case.

Since everything is public data on the blockchain, we don‚Äôt need any authentication for read calls. For transactions, each is signed by an account‚Äôs private key, and authentication is performed by the network. More details on transaction signing can be found [in the docs](../protocol/transactions.md).

Authorization, on the other hand, must be performed on a smart contract itself, the simplest way is just to check whether caller is allowed to perform an action:

```rust
assert_eq!(
            env::predecessor_account_id(),
            self.tokens.owner_id,
            "Unauthorized"
        );
```

### NFT usage

After we‚Äôve learned how to authenticate users and how to authorize NFTs usage, let‚Äôs find out how we can actually use them in our application.

Since we essentially have two backends in our application - server and smart contract(s), they both can use NFTs for different purposes:

* Server usually uses NFTs for actual functional purposes, e.g. by treating NFT as an in-game character, it can read its properties and stats and apply them using some logic.
* Smart contract is responsible for NFTs ownership, as well as NFTs creation, modification and burning (destruction).

This is the point where the NFT data storage model comes into place. Let‚Äôs recall, that there are 3 possible options:

1. Store data in a smart-contract (on-chain).
2. Store data in an [off-chain decentralized storage](../../1.concepts/storage/decentralized-storage.md), like IPFS (off-chain).
3. Store data in an application itself (in-application).

First 2 approaches provide good decentralization, but make NFT harder to work with, especially if we need to modify its properties. Let‚Äôs consider usage options depending on a storage model used:

1. On-chain storage: 
    * Server can read data from the blockchain by making an API call. Server can‚Äôt directly modify data, it should make a smart contract call instead (by issuing a transaction).
    * Smart contract can directly read/modify NFT data.
    * Clients can read all data directly from the blockchain.
2. Off-chain storage:
    * Server can read data from storage by making an API call. Data on the off-chain storage is usually immutable, so no modifications are possible.
    * Smart contract cannot read data directly, an Oracle should be used. Data cannot be modified from it.
    * Clients should read data from both blockchain and off-chain storage.
3. In-application storage:
    * Server can read/modify data from its own database.
    * Smart contract cannot read data directly, an Oracle should be used. Data cannot be modified from it.
    * Clients should read data from both blockchain and server.

Depending on a particular use case, any approach, or combination of them, can be used. The simplest case is when we don‚Äôt have any dynamic NFT data, and we can easily divide data by domains:

* Data that is used by smart contracts is stored on-chain.
* Other data is stored either off-chain or in-application.

<div align="center">
<img src="/docs/assets/web3/nfts-13.png" alt="image" width="400" />
</div>

In this approach the server needs to read data from the smart contract, and, optionally, from an off-chain storage (like IPFS or Database). 

This will work well for simple use cases, but everything becomes more complicated if we need to have some dynamic data associated with NFTs. E.g we may want to have experience points associated with our game character. Such data can be stored either on-chain or in-application (off-chain storage is also possible, but it‚Äôs more involved, so we won‚Äôt discuss it here).

In case of in-application storage, data can be modified by a server without any problems, but there are few drawbacks:

* In order to read this data, clients should make an API call to the server. This adds a centralized point for our NFT, and may not be suitable for all applications.
* If a smart contract requires this data, a server should serve as a [Blockchain Oracle](https://en.wikipedia.org/wiki/Blockchain_oracle), which complicates things.

If we want our server to serve as an oracle for our smart contract, the easiest way is to cryptographically sign server‚Äôs data and verify it on the contract‚Äôs side (server‚Äôs public key that was used for signing should be stored in a contract in this case). 

In order to prevent replay attacks, signed data should include a timestamp, which should also be verified. However, there‚Äôs one trick to this - smart contracts can‚Äôt access current time, since it would make them non-deterministic. Instead, transaction signature time can be used - it can be accessed using `env::block_timestamp()` function.

![image](/docs/assets/web3/nfts-14.png)

In order to avoid all these complications, we can instead store dynamic data on-chain, and use smart contract calls to update it.

<div align="center">
<img src="/docs/assets/web3/nfts-15.png" alt="image" width="500" />
</div>

Such an approach has one drawback - in order to call a smart contract‚Äôs method, a transaction should be created by the server, and in order to create a transaction it must be signed using an account‚Äôs key. That‚Äôs why a separate NEAR account should be created to be used by the server. Actions on the smart contract can be configured to authorize only this account, so regular users will be disallowed from modifying such data. 

Yet another option is to store data on the server-side, but a smart contract can authorize only a server account for calls that rely on this data. As with the previous scenario, the server must have its own NEAR account.

<div align="center">
<img src="/docs/assets/web3/nfts-16.png" alt="image" width="500" />
</div>

In general, the approach of storing dynamic data on the Smart Contract side is much easier, but an important constraint should be considered - storing data on the blockchain is not cheap, so an appropriate method can be chosen depending on a scenario.

By now, we‚Äôve covered methods to store and interact with NFTs from our application, an exact strategy should be chosen depending on use cases and constraints. A few things to remember:

* Storing NFTs data in a centralized storage (like an application's database) goes against Web 3 philosophy, and should be used sparingly and with care.
* Storage on the blockchain is not cheap, so decentralized off-chain storages can be used to store large data.
* Storing and using dynamic NFT data is quite tricky, and should be carefully designed. If such dynamic data is needed by smart contracts, it‚Äôs better to store it inside this contract if possible.

### NFT minting

So far, we‚Äôve discussed only how to use NFTs in the application, but how do they get created?

In the blockchain world, creation of new NFTs is usually called minting. And as with traditional digital assets, there are few ways how to create them:

* Users can mint them directly. This can be done by either allowing creation of NFTs from scratch, or by using more complex processes, like breeding or upgrading. The most famous example of such process is breeding in [CrytoKitties](https://www.cryptokitties.co/) game - new NFTs are created by combining existing ones. With this approach users usually have to pay to cover the storage and gas cost of NFTs creation.
* NFTs can be distributed by the developer to a set of users - it is usually called [NFTs airdrop](https://www.investopedia.com/terms/a/airdrop-cryptocurrency.asp). Most often this is used as a marketing strategy to kickstart NFTs usage in applications. Storage and gas costs in this case are covered by developers.
* NFTs can be bought on a market or obtained from the lootbox. Depending on an exact strategy, costs can either be paid by a user or by developer. Also, in this case NFTs sometimes can be minted on-demand, to avoid paying upfront costs.

An exact strategy used for NFTs minting depends on application use cases. However, almost always there‚Äôll be an `nft_mint _function` defined in a smart contract, which will handle creation of new tokens. This function itself isn't defined [in the standard](https://nomicon.io/Standards/NonFungibleToken/) and is up to the application to implement, but the standard library provides a core implementation for it - [mint_internal](https://docs.rs/near-contract-standards/latest/near_contract_standards/non_fungible_token/core/struct.NonFungibleToken.html#method.internal_mint). On top of this function an additional logic, e.g. for authorization, can be added:

```rust
#[payable]
pub fn nft_mint(
    &mut self,
    token_id: TokenId,
    receiver_id: AccountId,
    token_metadata: TokenMetadata,
) -> Token {
    assert_eq!(
        env::predecessor_account_id(),
        self.tokens.owner_id,
        "Unauthorized"
    );

    let token = self
        .tokens
        .internal_mint(token_id, receiver_id, Some(token_metadata));

    return token;
}
```

This approach is quite simple, but everything becomes a bit complicated if we want to provide some on-demand minting functionality to avoid paying upfront costs. For example, we may want to create a lootbox with a set of predefined items appearing with some probability. 

One approach is to handle this logic on a server side, in this case the server will call `nft_mint` function with computed parameters. However, in this case developers will have to pay the cost of minting. If we want to avoid this, loot box logic can be moved into the smart contract itself. If users want to open a loot box, he can call a smart contract function and pay for this action (e.g. by using NEAR or Fungible Tokens). Developers would only need to pay for a lootbox configuration costs, like possible items and their probabilities.

## Blockchain Onboarding

Before designing an onboarding strategy, the target audience should be carefully analyzed. As we briefly mentioned before, users can be divided into two broad buckets:

1. Users that are already familiar with blockchain, have their own wallets and understand cryptocurrency basics.
2. ‚ÄúCasual‚Äù users that aren‚Äôt familiar with blockchain and don‚Äôt know much about it.

If only the first category is targeted, then everything is quite simple - users are already familiar with main concepts, and will have no problem connecting their own wallet or creating a new one. However, if we want to target the second category of users as well, a strategy has to be developed to make onboarding into the blockchain world as smooth as possible. While a lot relies on proper UX and is very application-specific, a few architectural patterns and technologies exist to simplify this process: custodial wallets, NEAR drops, Prepaid Gas and Implicit Accounts.

[Custodial Wallet](https://www.coindesk.com/learn/custodial-wallets-vs-non-custodial-crypto-wallets/) is a wallet which is managed by a third party. In our case, a wallet can be created and stored on a server side, and all blockchain operations could be done using the server as a proxy.

![image](/docs/assets/web3/nfts-17.png)

In this way, users can remain unaware about the intricacies of blockchain until they are comfortable enough to claim ownership of this account. Once they are ready, the server can transfer the account's ownership and remove it from the server. However, despite simplifying UX for the users, such approach has a few significant drawbacks:

* Users should trust our application to manage their accounts. 
* Accounts creation is not free, so unless developers want to pay for it, funds should be transferred from a user to cover this cost. Traditional payment methods can be used, like PayPal or Apple/Google Pay. However, such an approach should be used with care for mobile applications due to app stores policies. Alternatively, NEAR Implicit Accounts can be used to avoid paying for account creation.
* Unless we want to leave a custodial wallet as the only supported wallet type, we need to support both types of wallets (custodial and non-custodial) in our application. This will increase implementations complexity, since we need to support 2 transaction types:
    * Server-signed transactions in case of custodial wallet.
    * Client-signed transactions in case of non-custodial wallet.

As we mentioned above, [Implicit Accounts](../protocol/account-id.md#implicit-accounts-implicit-accounts) can be used to avoid paying account creation costs. This is especially useful for custodial wallets, since it allows us to create a NEAR Account free of charge. Basically, they work like an Ethereum/Bitcoin-style account by using a public key as an account id, and later can be converted to a full NEAR account. However, they have drawbacks as well. First of all, human-readable account names cannot be used. Also, if we want to convert it to a proper NEAR account, which can support Functional Call keys, the account creation fee still has to be paid.

While being very powerful, custodial accounts are quite complex and tricky to implement. An alternative approach to ease users onboarding is to simplify creation of a wallet itself. In NEAR, we can do this using [NEAR Drops](https://near.org/blog/send-near-to-anyone-with-near-drops/). It allows us to generate a link that guides users through a quick wallet creation process. However, the same problem as for the custodial accounts applies - creation of an account is not free. That‚Äôs why, such a link has NEAR tokens attached to it to cover account creation cost and to serve as an initial balance for a newly created wallet. And as with custodial accounts, funds should be transferred from a user to cover this cost using traditional payment channels.

Another option to simplify onboarding is usage of the [Prepaid Gas](../protocol/gas.md#what-about-prepaid-gas-what-about-prepaid-gas) concept. For example, we can issue a Functional Call key that allows users to interact with blockchain without having an account created. In this case funds will be drawn from the developer's account. This can be used for demo purposes, or to allow users without a NEAR account to perform some smart contract actions.

## NFT Marketplace

At this point, we‚Äôve covered in detail how to integrate NFTs into our Web 2 application, but we‚Äôve stayed away from the economy part. The essential part for having a functioning economy is a marketplace where users can freely trade and exchange their NFTs. Such a marketplace usually consists of a smart contract and a client application. This smart contract is closely integrated with a NFT‚Äôs smart contract using the cross-contract calls. The reason for having a separate smart contract is two-fold:

* This provides a better separation of concerns - we can modify and upgrade our marketplace independently from the NFT contract.
* Multiple marketplaces can be used - e.g. we can have an internal marketplace, and in addition to it users can list their NFTs on external marketplaces. This is possible because a common NFT standard exists that all marketplaces can rely on.

General flow of a simple marketplace integration can look like this:

![image](/docs/assets/web3/nfts-18.png)

1. Client calls the [nft_approve](https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement#2-approval-with-cross-contract-call) method on the NFT smart contract. This will approve Marketplace Smart Contract to sell this NFT.
2. After approving an account, NFT smart contract issues a cross-contract call to the Marketplace to create a sale object. Arguments for this call are provided as part of the `nft_approve` call.
3. Another user wants to buy the NFT on sale, so he issues a call to the marketplace contract offering to buy it. An exact call signature for such action is not standardized and depends on marketplace implementation.
4. If an offer to buy a NFT is valid, Marketplace issues an [nft_transfer_payout](https://nomicon.io/Standards/NonFungibleToken/Payout) call to transfer the NFT and return payout information. This information is used by the Marketplace to distribute profits from the sale between recipients. In the simplest case, all profits go to a seller.

Such flow looks relatively simple, but a few important details are missing. 

First of all, in order to create a sale, storage needs to be paid for. Usually, the seller is the one who needs to pay for it, but other models are possible - e.g. marketplace or application developers could cover the cost. If we want users to pay for a sale, an approach with storage reservation can be used:

* Before approving NFT for sale, a user should reserve storage on the Marketplace contract to cover sale storage requirements.
* After the NFT is bought or delisted, the user can withdraw storage reservation (remember, that in NEAR storage staking model is used, so data can be deleted and locked tokens refunded).

While this model is relatively straightforward, it‚Äôs not ideal from the UX perspective - users must make a separate action to reserve storage if they want to sell their NFTs. To improve this, we can combine `nft_approve` call with storage reservation, and automatically refund back the storage cost after the sale is removed. 

![image](/docs/assets/web3/nfts-19.png)

Another missing thing is how a client can read data about available sales. Of course, sales information can be read directly from a smart contract, but available data structures are not optimized for searching or filtering. Also, we would have to join data from the NFT and Marketplace contracts on the client side, which isn‚Äôt efficient. In order to solve these problems, an indexer can be used to aggregate data into a suitable database, where data can be stored in a way optimal for retrieval (e.g. a relational database or an ElasticSearch index can be used).

![image](/docs/assets/web3/nfts-20.png)

This is just one example of how a marketplace can be designed, but with it we‚Äôve covered all basic concepts and problems. Most important points to remember:

* It‚Äôs better to implement a marketplace as a separate contract.
* Storage management should be carefully designed, with UX in mind.
* In order to implement a proper searching/filtering functionality, a separate indexing service is needed.

An example of a simple marketplace [can be found here](../../3.tutorials/nfts/8-marketplace.md). A more sophisticated marketplace may allow purchases with Fungible Tokens as payment.

## Implementing Components

Now, let‚Äôs explore our choice of libraries, frameworks and third-party solutions that can be used to implement our architecture.

#### Client & Server

First of all, how can we interact with blockchain from our clients? 

If we need read-level access only, we can simply use the [REST API](https://docs.near.org/api/rpc/setup), so it can be integrated into any language and technology without any problems. But everything becomes more complicated if we need to post transactions from a client. Remember, that transaction should be signed with a private key which is stored in a wallet:

* In case of a Functional Call key, it can be obtained from the wallet and used directly by the client.
* In case of a Full Access key, the user should be redirected to the wallet to approve a transaction.

A [JavaScript API](/tools/near-api-js/quick-reference) exists to cover all of these scenarios. It has all of the necessary functionality to integrate Web/Node.JS applications with blockchain. This SDK is a perfect choice for the Web-based clients, but it‚Äôs not suitable for desktop or mobile based clients. Other libraries can be used for them:

* [.NET Client](https://github.com/good1101/NearClientApi/tree/master/NearClient) - suitable for Unity or Xamarin.
* [Swift](https://github.com/near/near-api-swift)
* [Python](https://github.com/near/near-api-py)
* [Unity](https://github.com/near/near-api-unity)

Same SDKs and libraries can be used for servers. The only difference is that a server cannot interact with a Wallet, so it must have access to a Full Access key, which should be stored and accessed in a secure way. 

Also, another solution is available if a server uses a technology that doesn‚Äôt have NEAR SDK available for - we can create a separate (micro)service using the Node.js, which would handle all blockchain interactions:

<div align="center">
<img src="/docs/assets/web3/nfts-21.png" alt="image" width="450" />
</div>

An example of such a proxy server [can be found here](https://github.com/near-examples/near-api-rest-server).

#### Contracts

As we discovered in a previous section, for our application we need two smart contracts: for NFT and for Marketplace. There are two options on how to get them - use in-house implementation or some third-party/SAAS solution. Both options are viable and have different pros/cons. 

If we want to create our own contract, we are fully in control and can implement anything we want. An obvious drawback, of course, is that it will take time and money to build it. Third-party solutions, on the other hand, are limited in their functionality and often cannot be easily extended. Also, they usually have some upfront costs and/or usage fees.

For an in-house NFT contract implementation a few resources can be used as a starting point. First of all, a [Rust library](https://docs.rs/near-contract-standards/latest/near_contract_standards/index.html) is available which implements most of the standard. Another option is to build an entire contract from scratch, a good guide on how to do this is available by [this link](../../3.tutorials/nfts/0-intro.md).

Implementing an own Marketplace contract is more involved since there is no standard implementation. A few examples:

* [Basic marketplace example](../../3.tutorials/nfts/8-marketplace.md)
* [Paras ](https://paras.id/)marketplace contract - [source](https://github.com/ParasHQ/paras-marketplace-contract/tree/master/paras-marketplace-contract/src). 

As for third-party solutions, the most complete one is [Mintibase](https://www.mintbase.io/), which provides a full suite of components for NFTs integration - including contracts, indexer, API and a web client:

![image](/docs/assets/web3/nfts-22.png)

Another option is to roll-out an own NFT contract and integrate with one of the third-party marketplaces, e.g. with [Paras](https://paras.id/) ([integration docs](https://docs.paras.id/nft-smart-contract-integration)).

![image](/docs/assets/web3/nfts-23.png)

The major advantage of an external marketplace is the fact that they usually run their own indexer and expose collected data via an API, so we don‚Äôt have to implement these components. However, they usually have their fee for providing them, so a cost-benefit analysis should be conducted before using them.

#### Off-chain storages

Previously, we‚Äôve discussed that storage on the blockchain is not cheap, so in most cases some decentralized storage solution should be used. A few options are available:

* [IPFS ](https://ipfs.io/)- one of the first decentralized storage solutions, which is widely used in the blockchain world. However, in order to make sure that data is preserved on the network, an IPFS node(s) should be maintained. 
* [Arweawe](https://www.arweave.org/) - blockchain-based decentralized storage.  
* [Filecoin](https://filecoin.io/) - another blockchain-based storage.
* [nft.storage](https://nft.storage/) - a free service built on top of the IPFS and Filecoin. 

A more in-depth overview of such solutions is available [in the docs](../storage/decentralized-storage.md). In general, there's no ‚Äúsilver bullet‚Äù, so different solutions should be evaluated and the most suitable chosen. The main concerns while choosing a solution are availability guarantees, and cost.

#### Indexer

As we already determined, an indexing service is needed in order to support marketplace functionality. It usually consists of 3 components:

* Indexer - processes transactions from a NEAR network and puts extracted data into a database.
* Database - database of choice to store extracted data.
* Indexer API - an API layer on top of the database.

    
<div align="center">
<img src="/docs/assets/web3/nfts-24.png" alt="image" width="150" />
</div>

While any technology of choice can be used to implement Database and API, an indexer itself is usually implemented using Rust, since a [framework is available](https://github.com/near/nearcore/tree/master/chain/indexer) for this language. Guide how to implement your own indexer can be found [here](../../4.tools/indexer4explorer.md). 

Usually, an indexer works by extracting data from [Events](https://nomicon.io/Standards/EventsFormat), which are basically just structured log messages written during contract execution.

[The Graph](https://thegraph.com/en/) is an alternative to building an indexer from scratch. This is an Indexer-as-a-Service solution, which simplifies their creation and deployment. Guide on how to create a NEAR indexer is available [by this link](https://thegraph.com/docs/en/supported-networks/near/).

#### Automated Testing

Automated testing of the code is one of the pillars of modern software development. But how do we test our dApp?

Recall that a smart contract is a pure function, which can be easily tested using Unit Tests. Guide on how to write them is available [here](../../2.build/2.smart-contracts/testing/unit-test.md), and some examples can be found here. Another important kind of tests that is supported by NEAR are E2E tests, they can be executed either deploying contract code to either the local network environment (more info [here](../../2.build/2.smart-contracts/testing/introduction.md)), or directly to `testnet`, more info [here](../../2.build/2.smart-contracts/testing/integration-test.md)).

Having both types of tests is equally important to ensure continuous quality of smart contracts, especially since contract upgrades usually aren‚Äôt easy to perform (remember, that in DAOs upgrade itself might be governed by a community vote).

## Non-Functional Concerns

Last, but not least, let‚Äôs cover important non-functional concerns for our architecture.

### Security

The most important thing to remember during the entire development is security, and especially the security of smart contracts. Since their code is public and an upgrade procedure is not trivial, it should be carefully audited for security issues and logical exploits. 

Another important thing that should be kept secure is a user's private key. In most cases, only Functional Call keys should be directly accessed from a client, and Full Access keys should be kept in a wallet. However, in some cases a Full Access key might have to be used directly (e.g. in case of server transaction signing scenarios). In such a case, it must be kept in a secure location and treated as a most sensitive secret, since its compromise might lead to a full account takeover.

In general, before deploying an application to the NEAR mainnet, it‚Äôs a good idea to conduct a full security audit.

### Scalability and Availability

Another concern is scalability and availability of a solution. There are a lot of ways to scale traditional servers, but how do we scale our blockchain and make sure it‚Äôs always available? 

Since blockchain is decentralized, it provides us with high-availability by design, and NEAR provides a great scalability by employing Proof-of-Stake consensus and sharding. However, in order to interact with a network, we need an RPC Node. NEAR maintains publicly available nodes for its networks (listed [here](https://rpc.mainnet.near.org/status)), but it doesn't provide any performance or availability guarantees for them. So, in order to make sure our architecture is scalable and fault tolerant, we need to maintain our own cluster of RPC nodes, typically behind a load balancer.

<div align="center">
<img src="/docs/assets/web3/nfts-25.png" alt="image" width="150" />
</div>

Information on how to set up an RPC node is available [here](https://near-nodes.io/rpc). 

Also, to guarantee availability and scalability of a whole system, all used third-party services should be reviewed as well. For example, if IPFS is used as a storage for NFTs, pinning nodes and IPFS gateway should be scalable and fault tolerant.

### Costs

When building a Web 3 application, it‚Äôs important to remember that cost calculation is somewhat different from Web 2 applications. Additional costs can be broken down into several categories:

1. Smart Contracts deployment costs. While deploying on NEAR testnet or local environment, it‚Äôs essentially free of charge. However, when deploying into the mainnet, developers will be charged for storage and gas cost. Gas cost for a contract deployment transaction is relatively small (around 0.04$ at the time of writing). On the other hand, storage costs can be quite substantial, e.g. a 150KB contract (compiled) will cost around 20$.
2. Smart Contracts usage cost. In Web 3, users pay for smart contract calls, so in order to make sure users aren‚Äôt discouraged to interact with a contract due to a high cost, it should be optimized to incur the lowest cost possible. This is especially important for storage costs, since gas is relatively cheap.
3. If we want to use a privately hosted RPC node for better availability, its operational costs should be taken into account as well. Cost breakdown can be found [here](https://near-nodes.io/rpc/hardware-rpc), a rough estimation is about 290$ per node per month (and remember that we need at least 2 nodes for redundancy).
4. Cost of a privately hosted indexer (if it‚Äôs used). More information can be found [here](/concepts/advanced/near-indexer-framework), a rough estimation for the costs is about 100$ per month.
5. Third party services costs. 

'''
'''--- docs/1.concepts/welcome.md ---
---
id: welcome
title: NEAR Protocol Overview
sidebar_label: Home
hide_table_of_contents: true
---
import {FeatureList, Column, Feature} from "@site/src/components/featurelist"

Welcome! Here we will explain you what NEAR Protocol is, its components, and how it works.

Do not worry if you are new to blockchains, we are here to guide you.

<FeatureList>
  <Column title="Introduction to NEAR">
    <Feature url="/concepts/basics/protocol" title="What is NEAR?" subtitle="Learn the Basics about NEAR" image="near-logo.png" />
    <Feature url="/concepts/protocol/account-id" title="Named Accounts" subtitle="NEAR uses human-readable accounts" image="user.png" />
    <Feature url="/concepts/protocol/access-keys" title="Multiple Access Keys" subtitle="More keys means more security" image="key.png" />
    <Feature url="/concepts/protocol/smartcontract" title="Smart Contracts" subtitle="Learn about our contract technology" image="contract.png" />
  </Column>
  <Column title="The Network">
    <Feature url="/concepts/basics/tokens" title="The NEAR Token" subtitle="Learn about the NEAR token" image="ft.png" />
    <Feature url="/concepts/protocol/transactions" title="Transactions" subtitle="Fast and Inexpensive" image="transaction.png" />
    <Feature url="/concepts/basics/validators" title="Validators" subtitle="Learn how the network stays safe" image="validation.png" />
  </Column>
  <Column title="More Resources">
    <Feature url="https://near.org/papers" title="Papers" subtitle="Read the research that defined NEAR" image="experiment.png" />
    <Feature url="/concepts/web3/intro" title="From Web2 to Web3" subtitle="Migrate your applications" image="near-api-js.png" />
    <Feature url="/concepts/advanced/indexers" title="Indexing blockchain data" subtitle="Query usage information for a contract" image="blocks.png" />
  </Column>
</FeatureList>

'''
'''--- docs/2.build/1.chain-abstraction/chain-signatures.md ---
---
id: chain-signatures
title: Chain Signatures
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Chain signatures enable NEAR accounts, including smart contracts, to sign and execute transactions across many blockchain protocols.

This unlocks the next level of blockchain interoperability by giving ownership of diverse assets, cross-chain accounts, and data to a single NEAR account.

:::info

This guide will take you through a step by step process for creating a Chain Signature.

‚≠êÔ∏è For a deep dive into the concepts of Chain Signatures see [What are Chain Signatures?](/concepts/abstraction/chain-signatures)

‚≠êÔ∏è For complete examples of a NEAR account performing transactions in other chains:

- [CLI script](https://github.com/mattlockyer/mpc-script)
- [web-app example](https://github.com/near-examples/near-multichain)
- [component example](https://test.near.social/bot.testnet/widget/chainsig-sign-eth-tx)

:::

---

## Create a Chain Signature

There are five steps to create a Chain Signature:

1. [Deriving the Foreign Address](#1-deriving-the-foreign-address) - Construct the address that will be controlled on the target blockchain
2. [Creating a Transaction](#2-creating-the-transaction) - Create the transaction or message to be signed
3. [Requesting a Signature](#3-requesting-the-signature) - Call the NEAR `multichain` contract requesting it to sign the transaction
4. [Reconstructing the Signature](#4-reconstructing-the-signature) - Reconstruct the signature from the MPC service's response
5. [Relaying the Signed Transaction](#5-relaying-the-signature) - Send the signed transaction to the destination chain for execution

![chain-signatures](/docs/assets/welcome-pages/chain-signatures-overview.png)
_Diagram of a chain signature in NEAR_

:::info MPC testnet contracts

If you want to try things out, these are the smart contracts available on `testnet`:

- `multichain-testnet-2.testnet`: MPC signer contract
- `canhazgas.testnet`: [Multichain Gas Station](multichain-gas-relayer/gas-station.md) contract
- `nft.kagi.testnet`: [NFT Chain Key](nft-keys.md) contract

:::

---

## 1. Deriving the Foreign Address

Chain Signatures use [`derivation paths`](../../1.concepts/abstraction/chain-signatures.md#one-account-multiple-chains) to represent accounts on the target blockchain. The external address to be controlled can be deterministically derived from:

- The NEAR address (e.g., `example.near`, `example.testnet`, etc.)
- A derivation path (a string such as `ethereum-1`, `ethereum-2`, etc.)
- The MPC service's public key

We provide code to derive the address, as it's a complex process that involves multiple steps of hashing and encoding:

<Tabs groupId="code-tabs">
  <TabItem value="Œû Ethereum">
    <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/services/ethereum.js" start="14" end="18" />

</TabItem>

<TabItem value="‚Çø Bitcoin">
    <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/services/bitcoin.js" start="14" end="18" />

</TabItem>

</Tabs>

:::tip

The same NEAR account and path will always produce the same address on the target blockchain.

- `example.near` + `ethereum-1` = `0x1b48b83a308ea4beb845db088180dc3389f8aa3b`
- `example.near` + `ethereum-2` = `0x99c5d3025dc736541f2d97c3ef3c90de4d221315`

:::

---

## 2. Creating the Transaction

Constructing the transaction to be signed (transaction, message, data, etc.) varies depending on the target blockchain, but generally it's the hash of the message or transaction to be signed.

<Tabs groupId="code-tabs">
  <TabItem value="Œû Ethereum">
    <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/services/ethereum.js"
      start="32" end="48" />
    
In Ethereum, constructing the transaction is simple since you only need to specify the address of the receiver and how much you want to send.

</TabItem>

<TabItem value="‚Çø Bitcoin">
    <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/services/bitcoin.js"
      start="28" end="80" />

In bitcoin, you construct a new transaction by using all the Unspent Transaction Outputs (UTXOs) of the account as input, and then specify the output address and amount you want to send.

</TabItem>

</Tabs>

---

## 3. Requesting the Signature

Once the transaction is created and ready to be signed, a signature request is made by calling `sign` on the [MPC smart contract](https://github.com/near/mpc-recovery/blob/develop/contract/src/lib.rs#L298).

The method requires two parameters:

  1. The `transaction` to be signed for the target blockchain
  2. The derivation `path` for the account we want to use to sign the transaction

<Tabs groupId="code-tabs">
  <TabItem value="Œû Ethereum">
    <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/services/ethereum.js"
      start="57" end="61" />

</TabItem>

  <TabItem value="‚Çø Bitcoin">
    <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/services/bitcoin.js"
      start="87" end="98" />

For bitcoin, all UTXOs are signed independently and then combined into a single transaction.

</TabItem>

</Tabs>

:::tip
Notice that the `payload` is being reversed before requesting the signature, to match the little-endian format expected by the contract
:::

:::info

The contract will take some time to respond, as the `sign` method starts recursively calling itself waiting for the **MPC service** to sign the transaction.

<details>
<summary> A Contract Recursively Calling Itself? </summary>

NEAR smart contracts are unable to halt execution and await the completion of a process. To solve this, one can make the contract call itself again and again checking on each iteration to see if the result is ready.

**Note:** Each call will take one block which equates to ~1 second of waiting. After some time the contract will either return a result that an external party provided or return an error running out of GAS waiting.

</details>

:::

---

## 4. Reconstructing the Signature

The MPC contract will not return the signature of the transaction itself, but the elements needed to reconstruct the signature.

This allows the contract to generalize the signing process for multiple blockchains.

<Tabs groupId="code-tabs">
  <TabItem value="Œû Ethereum">
    <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/services/ethereum.js"
      start="62" end="71" />

In Ethereum, the signature is reconstructed by concatenating the `r`, `s`, and `v` values returned by the contract.

The `v` parameter is a parity bit that depends on the `sender` address. We reconstruct the signature using both possible values (`v=0` and `v=1`) and check which one corresponds to our `sender` address.

</TabItem>

<TabItem value="‚Çø Bitcoin">
    <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/services/bitcoin.js"
      start="105" end="116" />

In Bitcoin, the signature is reconstructed by concatenating the `r` and `s` values returned by the contract.

</TabItem>

</Tabs>

---

## 5. Relaying the Signature

Once we have reconstructed the signature, we can relay it to the corresponding network. This will once again vary depending on the target blockchain.

<Tabs groupId="code-tabs">
  <TabItem value="Œû Ethereum">
    <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/services/ethereum.js"
      start="80" end="84" />

</TabItem>

<TabItem value="‚Çø Bitcoin">
    <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/services/bitcoin.js"
      start="119" end="127" />

</TabItem>

</Tabs>

:::info
‚≠êÔ∏è For a deep dive into the concepts of Chain Signatures see [What are Chain Signatures?](/concepts/abstraction/chain-signatures)

‚≠êÔ∏è For complete examples of a NEAR account performing Eth transactions:

- [web-app example](https://github.com/near-examples/near-multichain)
- [component example](https://test.near.social/bot.testnet/widget/chainsig-sign-eth-tx)

:::

'''
'''--- docs/2.build/1.chain-abstraction/data-availability.md ---
---
id: data-availability
title: Rollup Data Availability
---

Utilizing NEAR as storage data availability with a focus on lowering rollup DA fees.

- [Blob Store Contract](#blob-store-contract): A contract that provides the store for arbitrary DA blobs.
- [Light Client](#light-client): A trustless off-chain light client for NEAR with DA-enabled features.
- [RPC Client](#da-rpc): The defacto client for submitting data blobs to NEAR.
- [Integrations](#integrations): Proof of concept works for integrating with L2 rollups.

:::tip
For the latest information, please check the [Near DA](https://github.com/near/rollup-data-availability/) repository.
:::

---

## System Context

This outlines the system components that we build and how it interacts with external components.

Red lines denote external flow of commitments.
White lines denote flow of blob data.

:::note
`Fisherman` is just an example how a rollup can work with the light client in the initial stage of DA, until we implement a more non-interactive approach, such as KZG.
:::

```mermaid 
C4Context
    title NEAR Data Availability System Context

    Enterprise_Boundary(b1, "Ethereum") {
        System_Ext(SystemEth, "Ethereum")

        System_Boundary(b2, "Rollup") {
            System_Ext(SystemRollup, "Rollup", "Derives blocks, execute transactions, posts commitments & sequence data")
            System(SystemNearDa, "NEAR DA Client", "Submits/Gets blob data, creates commitments")
        }
        BiRel(SystemRollup, SystemEth, "Posts sequences, proofs of execution, DA frame references")
        BiRel(SystemRollup, SystemNearDa, "Post batches, retrieves commitments")
        Rel(fisherman, SystemEth, "Looks for commitments, posts results")
    }      
    
    Enterprise_Boundary(b0, "NEAR") {
        
        System(SystemLc, "Light Client", "Syncs headers, provides inclusion proofs")
        System(SystemNear, "NEAR Protocol", "NEAR validators, archival nodes")
        
        Rel(SystemLc, SystemNear, "Syncs headers")    
        Rel(SystemNearDa, SystemNear, "Submits/Gets blob")

        %% This doesn't exist yet
        %% System(SystemDas, "Data Availability Sampling", "Data redundancy, retrieval, sample responses")
        %% BiRel(SystemDas, SystemLc, "Commitments")
    }
     
    Person_Ext(fisherman, "Fisherman")
    Rel(fisherman, SystemLc, "Requests inclusion proofs, validates inclusion proofs")
      

    UpdateRelStyle(fisherman, SystemEth, $offsetY="-10" $lineColor="red")
    UpdateRelStyle(fisherman, SystemLc, $offsetY="-10", $lineColor="red")
    UpdateRelStyle(SystemRollup, SystemEth, $offsetY="-30", $lineColor="white")
    UpdateElementStyle(fisherman, $bgColor="grey", $borderColor="red")

    UpdateRelStyle(SystemRollup, SystemNearDa, $offsetX="-200", $lineColor="white", $textColor="white")
    UpdateRelStyle(SystemNearDa, SystemNear, $textColor="white", $lineColor="white", $offsetY="10")
    UpdateRelStyle(SystemNearLc, SystemNear, $offsetX="30")
```

---

## [Blob Store Contract](https://github.com/near/rollup-data-availability/tree/main/contracts/blob-store)

The [blob store contract](https://github.com/near/rollup-data-availability/tree/main/contracts/blob-store) provides the store for arbitrary DA blobs. In practice, these "blobs" are sequencing data from rollups, but they can be any data.

NEAR blockchain state storage is pretty cheap. At the time of writing, 100KiB is a flat fee of 1NEAR. To limit the costs of NEAR storage even more, we don't store the blob data in the blockchain state.

It works by taking advantage of NEAR consensus around receipts. When a chunk producer processes a receipt, there is consensus around the receipt. However, once the chunk has been processed and included in the block, the receipt is no longer required for consensus and can be pruned. The pruning time is at least 3 NEAR epochs, where each epoch is 12 Hours; in practice, this is around five epochs. Once the receipt has been pruned, it is the responsibility of archival nodes to retain the transaction data, and we can even get the data from indexers.

We can validate that the blob was retrieved from ecosystem actors in the format submitted by checking the blob commitment. The blob commitment currently needs to be more efficient and will be improved, but it benefits us because anybody can build this with limited expertise and tooling. It is created by taking a blob, chunking it into 256-byte pieces, and creating a Merkle tree, where each leaf is a Sha-256 hash of the shard. The root of the Merkle tree is the blob commitment, which is provided as [transaction_id ++ commitment] to the L1 contract, which is 64 bytes.

What this means:
- Consensus is provided around the submission of a blob by NEAR validators
- The function input data is stored by full nodes for at least three days
- Archival nodes can store the data for longer
- We don't occupy consensus with more data than needs to be
- Indexers can also be used, and this Data is currently indexed by all significant explorers in NEAR
- The commitment is available for a long time, and the commitment is straightforward to create

---

## [Light Client](https://github.com/near/rollup-data-availability/tree/main/)

A trustless off-chain light client for NEAR with DA-enabled features, Such as KZG commitments, Reed-Solomon erasure coding & storage connectors.

The light client provides easy access to transaction and receipt inclusion proofs within a block or chunk. This is useful for checking any dubious blobs which may not have been submitted or validating that a blob has been submitted to NEAR.

A blob submission can be verified by:

- Taking the NEAR transaction ID from Ethereum for the blob commitment.
- Ask the light client for an inclusion proof for the transaction ID or the receipt ID if you're feeling specific; this will give you a Merkle inclusion proof for the transaction/receipt.
- Once you have the inclusion proof, you can ask the light client to verify the proof for you, or advanced users can manually verify it themselves.
- Armed with this knowledge, rollup providers can have advanced integration with light clients and build proving systems around it.

In the future, we will provide extensions to light clients such that non-interactive proofs can be supplied for blob commitments and other data availability features.

It's also possible that the light client may be on-chain for the header syncing and inclusion proof verification, but this is a low priority right now.

---

## DA RPC
This client is the defacto client for submitting blobs to NEAR. These crates allow a client to interact with the blob store. It can be treated as a "black box", where blobs go in, and `[transaction_id ++ commitment]` emerges.

There are multiple versions:
- The [`da-rpc` crate](https://github.com/near/rollup-data-availability/tree/main/crates/da-rpc) is the rust client, which anyone can use if they prefer rust in their application.
The responsibility of this client is to provide a simple interface for interacting with NEAR DA.
- The [`da-rpc-sys` crate](https://github.com/near/rollup-data-availability/tree/main/crates/da-rpc-sys) is the FFI client binding for use by non-rust applications. This calls through to `da-rpc` to interact with the blob store, with some additional black box functionality for dealing with pointers wrangling and such.
- The [`da-rpc-go` package](https://github.com/near/rollup-data-availability/tree/main/gopkg/da-rpc) is the go client bindings for use by non-rust applications, and this calls through to `da-rpc-sys`, which provides another application-level layer for easy interaction with the bindings.

:::info
See also [the diagram](https://github.com/near/rollup-data-availability/blob/main/docs/da_rpc_client.md)
:::

---

## Integrations

We have developed some proof of concept works for integrating with L2 rollups:

- [CDK Stack](https://github.com/firatNEAR/cdk-validium-node/tree/near): We have integrated with the Polygon CDK stack. Using the Sequence Sender for submissions to NEAR.
- [Optimism](https://github.com/near/optimism): We have integrated with the Optimism OP stack. Using the `Batcher` for submissions to NEAR and the proposer for submitting NEAR commitment data to Ethereum.

- [Arbitrum Nitro](https://github.com/near/nitro): We have integrated a small plugin into the DAC daserver. This is much like our http sidecar and provides a very modular integration into NEAR DA whilst supporting arbitrum DACs.

:::info
In the future, the `Arbitrum Nitro` integration will likely be the easiest way to support NEAR DA as it acts as an independent sidecar which can be scaled as needed. This also means that the DAC can opt-in and out of NEAR DA, lowering their infrastructure burden. With this approach, the DAC committee members just need to have a "dumb" signing service, with the store backed by NEAR.
:::
'''
'''--- docs/2.build/1.chain-abstraction/fastauth-sdk.md ---
---
id: fastauth-sdk
title: FastAuth SDK
sidebar_label: FastAuth (Email Login)
---

FastAuth is a key management system that allows users to **recover or sign-up for** a NEAR account using their **email address**. Furthermore, it allows to subsidize gas for a certain smart contract, so users can interact with it without having to fund their account. 

---

## FastAuth Components

FastAuth is comprised of 3 main elements:

1. **FastAuth Signer App**: A module that allow FastAuth users to sign transactions.
2. **MPC Recovery Service**: A service to create and restore user accounts, as well as signing transactions on behalf of the user.
3. **Transaction Relayer**: A server that relays transactions to the NEAR network on behalf of the user.

---

### Setting up Firebase

#### Create a project

- Go to [Firebase](https://firebase.com)
- Create or sign in to an account
- Go to "Get started", then "Add project"
- Call this project `my-fastauth-issuer`
- Disable Google Analytics (recommended)
- Click on "Create project"

#### Set up passwordless authentication

- Go to "Authentication", then "Get started", and "Add new provider"
- Enable "Email/Password" and "Email link (passwordless sign-in)"
- Hit "Save"

#### Add user device information to Firestore

- Return to "Project Overview"
- Go to "Cloud Firestore", then "Create database"
- Select "Start in production mode", then "Next"
- Select your preferred location, then "Enable"
- Go to the "Rules" tab
- Change the rules to the following:

```
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
  	match /users/{userId}/{document=**} {
      allow create, read, update, delete: if request.auth != null && request.auth.uid == userId;
    }
    match /publicKeys/{publicKey} {
      allow create, delete: if request.auth != null;
      allow read : if true;
      allow update: if false;
    }
  }
}
```

- Hit "Publish"
- Go to the "Data" tab
- Click on "Start collection"
- Set the Collection ID to `users` and hit "Next"
- Add a Document ID of `root` and press "Save"
- Click on "Start collection"
- Set the Collection ID to `publicKeys` and hit "Next"
- Add a Document ID of `root` and press "Save"

#### Get the application credentials

- Press the gear button next to "Project Overview", and go to "Project settings"
- Under "Your apps", click on the `</>` button
- Set the app nickname as `issuer-gcp` and hit "Register app"
- You should see the code needed for initilization and authentication of Firestore, such as:
```js
// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";

// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries
// Your web app's Firebase configuration

const firebaseConfig = {
  apiKey: "apikey",
  authDomain: "my-fastauth-issuer-123.firebaseapp.com",
  projectId: "my-fastauth-issuer-123",
  storageBucket: "my-fastauth-issuer-123.appspot.com",
  messagingSenderId: "12345678910",
  appId: "1:12345678910:web:12345678910"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
```

### Setting up your relayer

#### Setting up a NEAR account

First ensure that `cargo` is installed on your local machine. Try [rustup](https://rustup.rs/) if you haven't already installed it.

```bash
cargo install near-cli-rs
NEAR_ENV=mainnet
near account create-account fund-later use-auto-generation save-to-folder ~/.near-credentials/implicit
```

This should output something like:

```bash
The file "~/.near-credentials/implicit/275f14eecb0afcb1f46f2b71b7933afd2de6d4ae8b08e9b11fc538a5a81406b7.json" was saved successfully
```

In this example. `275f14eecb0afcb1f46f2b71b7933afd2de6d4ae8b08e9b11fc538a5a81406b7` is your funded account. We'll refer to this as `$FUNDED_ACCOUNT` from now on.

Send some NEAR to this address.

#### Adding multiple keys (Recommended)

This account has been created with one key. However, due to [this](https://near.zulipchat.com/#narrow/stream/295302-general/topic/.E2.9C.94.20The.20trouble.20with.20nonces/near/389649443), you should create an account with `N` keys where `N` is the number of requests you expect to get in a second, at peak load.

To generate an additional key, run the following command:

```bash
near account add-key $FUNDED_ACCOUNT grant-full-access autogenerate-new-keypair save-to-keychain network-config mainnet sign-with-access-key-file ~/.near-credentials/implicit/$FUNDED_ACCOUNT.json send
```

#### Deploying the relayer

Run the following command:

```bash
git clone https://github.com/near/pagoda-relayer-rs
```

Go to `config.toml` and change:

```toml
network = "mainnet"
num_keys = 3  # correlates to the number of keys in `keys_filenames`. Will be optional in the future.
relayer_account_id = "$FUNDED_ACCOUNT"
keys_filenames = [
    # The original account
    "~/.near-credentials/mainnet/$FUNDED_ACCOUNT.json",

    # Other keys you've optionally created. This will allow rotating through each key as to avoid nonce races.
    "~/.near-credentials/mainnet/$FUNDED_ACCOUNT/ed25519_4ryLkp4AuzBD8yuyRJKb91hvHZ4zgqouWcJzu1gNEvLv.json",
    "~/.near-credentials/mainnet/$FUNDED_ACCOUNT/ed25519_7K3jF8Ft5dKFEPYRH1T4mncvsZGgSoGKsvsnnKEmqubT.json"
]
```

Optionally, if you need to generate additional access keys for the `$FUNDED_ACCOUNT`, run the following command N times. Note that this will create keys for implicit accounts, but we'll then tie them to `$FUNDED_ACCOUNT`.

```bash
near generate-key
near add-key $FUNDED_ACCOUNT exampleImplicitPublicKeyCxg2wgFYrdLTEkMu6j5D6aEZqTb3kXbmJygS48ZKbo1S
```

Then run:

```bash
docker compose up
```

You should do this on a VM server of your choice. We will refer to the URL of this VM as `$RELAYER_URL` from now on.

### Setting up the frontend

#### Deploying the signer app

- Go to GCP's Cloud Run console and press "Create Service".
- In the field "Container image URL", paste `nearprotocol/fast-auth-sdk-frontend:latest`.
- Under **Container(s), Volumes, Networking, Security** set **Container port** to `80`
- Go to the "Container, Networking, Security" fold out and then "Environment Variables"
- Click on "Add Variable"
- Set the following environment variables from the `firebaseConfig` you generated earlier.

```yaml
NETWORK_ID:                           'mainnet',
RELAYER_URL:                          '$RELAYER_URL',
FIREBASE_API_KEY:                     'apikey',
FIREBASE_AUTH_DOMAIN:                 'my-fastauth-issuer-123.firebaseapp.com',
FIREBASE_PROJECT_ID:                  'my-fastauth-issuer-123',
FIREBASE_STORAGE_BUCKET:              'my-fastauth-issuer-123.appspot.com',
FIREBASE_MESSAGING_SENDER_ID:         '12345678910',
FIREBASE_APP_ID:                      '1:12345678910:web:12345678910',
```

Alternatively if you're doing a `testnet` deployment, do:

```yaml
NETWORK_ID:                           'testnet',
RELAYER_URL_TESTNET:                  '$RELAYER_URL',
FIREBASE_API_KEY_TESTNET:             'apikey',
FIREBASE_AUTH_DOMAIN_TESTNET:         'my-fastauth-issuer-123.firebaseapp.com',
FIREBASE_PROJECT_ID_TESTNET:          'my-fastauth-issuer-123',
FIREBASE_STORAGE_BUCKET_TESTNET:      'my-fastauth-issuer-123.appspot.com',
FIREBASE_MESSAGING_SENDER_ID_TESTNET: '12345678910',
FIREBASE_APP_ID_TESTNET:              '1:12345678910:web:12345678910',
```

- Click on "Create Application"
- Then, inside your app's control panel copy the app's URL, such as `https://signer-app-123456-ab.a.run.app`. We will refer to the deploy URL as `$WALLET_URL`.

#### Authorizing a domain on Firebase

- Go back to the Firebase Console
- Go to "Authentication" in the sidebar, and then the "Settings" tab
- Click on the "Authorized domains" menu item
- Add `$WALLET_URL` to the list

#### Deploying your application frontend

First, install the `@near-js/iframe-rpc` package from the NPM registry.

```js
import { setupFastAuthWallet } from 'near-fastauth-wallet';
import { setupWalletSelector } from '@near-wallet-selector/core';

// Initialize wallet selector
const selector = setupWalletSelector({
          network: networkId,
          modules: [
            setupFastAuthWallet({
              relayerUrl: "$RELAYER_URL",
              walletUrl: "$WALLET_URL"
            })
          ]
      })

// EITHER setup onClick function for login
const onCLick = () => selector.then((selector: any) => selector.wallet('fast-auth-wallet'))
      .then((fastAuthWallet: any) =>
        fastAuthWallet.signIn({
          contractId: "$CONTRACT_ID",
          email: "<USERS_EMAIL_ADDRESS>",
          isRecovery: true,
        }),);

// OR setup onClick function for login
const onCLick = () => selector.then((selector: any) => selector.wallet('fast-auth-wallet'))
      .then((fastAuthWallet: any) =>
        fastAuthWallet.signIn({
          contractId: "$CONTRACT_ID",
          email: "<USERS_EMAIL_ADDRESS>",
          accountId: "<USERS_DESIRED_NEAR_ADDRESS>.near"
          isRecovery: false,
        }),);
```

Wehenever the user tries to login, call `onClick`.

### Getting added to the MPC recovery service

As a last step, we'll need to add your app to our MPC recovery service.
To get added, please send us your `$FIREBASE_PROJECT_ID`, `$RELAYER_API_KEY` and `$RELAYER_URL` through this [form](https://forms.gle/cDfXj2D5bm9sohBx6).

'''
'''--- docs/2.build/1.chain-abstraction/meta-transactions.md ---
---
id: meta-transactions
title: Building a Meta Transaction Relayer
sidebar_label: Meta Transaction Relayers
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Relayers serve to delegate gas fees to a web service, allowing users to transact on NEAR without the need to acquire the token themselves while still retaining the security of signing their own transactions. This guide will lead you through the components necessary to construct a relayer capable of handling meta transactions.

:::tip

If you're already acquainted with the technology and you just want to run your own Relayer, you can fast track to a complete [Rust Relayer server](#rust-relayer-server) open-source implementation.

:::

## How it works

A basic relayer consists of a web server housing a funded NEAR account. This account receives an encoded signed transaction, which can subsequently be decoded into a `SignedDelegate` format and transmitted on-chain.

The client can then generate a `SignedDelegateAction` (a signed message that hasn't yet been sent), encode it, and transmit it to this server, where it will be relayed onto the blockchain.

![relayer-overview-technical](/docs/assets/welcome-pages/relayer-overview-technical.png)

## Relayer (server)

<Tabs groupId="code-tabs">

<TabItem value="near-api-js">

Here's a simple express endpoint that deserializes the body, instantiates the relayer account and then sends the transaction.

<Github language='typescript' url='https://github.com/SurgeCode/near-relay-example/blob/main/server.ts' start='16' end='27'/>

You can easily get the account object used to send the transactions from its private key using this snippet

<Github language='typescript' url='https://github.com/SurgeCode/near-relay-example/blob/main/util.ts' start='5' end='17'/>  

:::info

 The code in the example only works from the following versions onwards

```
"near-api-js": "3.0.4"
"@near-js/transactions": "1.1.2",
"@near-js/accounts": "1.0.4"
```

::: 

</TabItem>

<TabItem value="@near-relay/server">

`@near-relay` simplifies meta transactions making it easier to get started for a beginner.

To start, call the relay method inside an endpoint to automatically deserialize the transaction and send it with the account defined in the environment variables.

<Github language='typescript' url='https://github.com/SurgeCode/near-relay/blob/main/server/server.ts' start='8' end='12'/>

If you're interested in relaying account creation as well, it's quite straightforward. Simply create another endpoint and directly call the createAccount method with the accountId and publicKey. These parameters are automatically included in the body when using the corresponding client library.

<Github language='typescript' url='https://github.com/SurgeCode/near-relay/blob/main/server/server.ts' start='14' end='18'/>
  
</TabItem>

</Tabs>

## Client

<Tabs groupId="code-tabs">

<TabItem value="near-api-js">

In this method we are creating an arbitrary smart contract call, instantiating an account and using it to sign but not send the transaction. We can then serialize it and send it to the relayer where it will be delegated via the previously created endpoint.

<Github language='typescript' url='https://github.com/SurgeCode/near-relay-example/blob/main/client.ts' start='10' end='30'/>

</TabItem>

<TabItem value="@near-relay/client">

As mentioned in the above note in order to be able to relay on the client side it's necessary to have access to signing transactions directly on the client. Luckily leveraging the near biometric library it's possible to do so in a non custodial way.

By calling this method and passing in the URL for the account creation endpoint (mentioned in the server section) as well as the `accoundId` everything is handled under the hood to successfully create an account.

<Github language='typescript' url='https://github.com/SurgeCode/near-relay/blob/main/example/src/app/page.tsx' start='17' end='23'/>

On the client side, you just need to create an `Action` and pass it into the `relayTransaction` method along with the URL of the relayer endpoint discussed in the server section and the id of the `receiverId`.

<Github language='typescript' url='https://github.com/SurgeCode/near-relay/blob/main/example/src/app/page.tsx' start='25' end='36'/>

</TabItem>

</Tabs>

<details>
<summary> Relaying with wallets </summary>

At the moment, wallet selector standard doesn't support signing transactions without immediately sending them. This functionality is essential for routing transactions to a relayer. Therefore, to smoothly integrate relaying on the client side, it's necessary to be able to sign transactions without relying on wallets.
Progress is being made to make this possible in the future.

</details>

### Gating the relayer

In most production applications it's expected that you want to be able to gate the relayer to only be used in certain cases.
By taking apart the `delegateAction` object inside the `SignedDelegate`on the server this can be done simply.

```typescript
export declare class DelegateAction extends Assignable {
    senderId: string;
    receiverId: string;
    actions: Array<Action>;
    nonce: BN;
    maxBlockHeight: BN;
    publicKey: PublicKey;
}
```

You can, for example, gate by some particular user or contract:

```typescript
  const serializedTx: Buffer = req.body;
  const deserializedTx: SignedDelegate = deserialize(SCHEMA.SignedDelegate, Buffer.from(serializedTx)) as SignedDelegate;
  const relayerAccount: Account = await getAccount(NETWORK_ID, RELAYER_ID, RELAYER_PRIVATE_KEY);
  const delegateAction = deserializedTx?.delegateAction

  if(delegateAction.senderId == 'someUserId' || delegateAction.receiverId == 'someContractId' ){
       const receipt = await relayerAccount.signAndSendTransaction({
       actions: [actionCreators.signedDelegate(deserializedTx)],
       receiverId: deserializedTx.delegateAction.senderId
  });
  }
```

Other examples could be looking into the actions and seeing if there is deposit or gas and limiting them, gating by particular smart contract methods or even args.

You can decode the args using:

```
JSON.parse(Buffer.from(args_base64 || "", "base64").toString())
```

---

## Rust Relayer Server

The open-source Rust [reference implementation of a Relayer server](https://github.com/near/pagoda-relayer-rs/) offers the following features:

:::info
Features can be combined as needed. Use of one feature does not preclude the use of any other feature unless specified.
:::

1. Sign and send Meta Transactions to the RPC to cover the gas costs of end users while allowing them to maintain custody of their funds and approve transactions (`/relay`, `/send_meta_tx`, `/send_meta_tx_async`, `/send_meta_tx_nopoll`)
2. Sign Meta Transactions returning a Signed Meta Transaction to be sent to the RPC later - (`/sign_meta_tx`, `/sign_meta_tx_no_filter`)
3. Only pay for users interacting with certain contracts by whitelisting contracts addresses (`whitelisted_contracts` in `config.toml`) 
4. Specify gas cost allowances for all accounts (`/update_all_allowances`) or on a per-user account basis (`/create_account_atomic`, `/register_account`, `/update_allowance`) and keep track of allowances (`/get_allowance`)
5. Specify the accounts for which the relayer will cover gas fees (`whitelisted_delegate_action_receiver_ids` in `config.toml`)
6. Only allow users to register if they have a unique Oauth Token (`/create_account_atomic`, `/register_account`)
7. Relayer Key Rotation: `keys_filenames` in `config.toml`
8. Integrate with [FastAuth SDK](fastauth-sdk.md)
9. Mix and Match configuration options

:::tip
Check the [Use cases section](#use-cases) for example configuration files corresponding to different usage scenarios.
:::

### Basic Setup

You can follow these steps to set up your local Relayer server development environment:

1. [Install Rust for NEAR Development](../../sdk/rust/intro.md)
2. If you don't have a NEAR account, [create one](../../1.concepts/protocol/account-model.md)
3. With the account from step 2, create a JSON file in this directory in the format
   ```js
   [{"account_id":"example.testnet","public_key":"ed25519:98GtfFzez3opomVpwa7i4m3nptHtc7Ha514XHMWszLtQ","private_key":"ed25519:YWuyKVQHE3rJQYRC3pRGV56o1qEtA1PnMYPDEtroc5kX4A4mWrJwF7XkzGe7JWNMABbtY4XFDBJEzgLyfPkwpzC"}]
   ```
   using a [Full Access Key](../../1.concepts/protocol/access-keys.md#full-access-keys) from an account that has enough NEAR to cover the gas costs of transactions your server will be relaying. Usually, this will be a copy of the json file found in the `.near-credentials` directory. 
4. Update values in `config.toml`
5. Open up the `port` from `config.toml` in your machine's network settings
6. Run the server using `cargo run`. 
   > **(OPTIONAL)** To run with logs (tracing) enabled run `RUST_LOG=tower_http=debug cargo run`

:::info Optional setup

If you're integrating with [FastAuth](fastauth-sdk.md) make sure to enable feature flags: 
```
cargo build --features fastauth_features,shared_storage
```
If you're using shared storage, make sure to enable feature flags:
```
cargo build --features shared_storage
```

:::

### Redis Setup

:::tip
This is only needed if you intend to use whitelisting, allowances, and OAuth functionality.
:::

1. [Install Redis](https://redis.io/docs/latest/get-started/).
   > Steps 2 & 3 assume Redis was installed on machine instead of a Docker setup. If you're connecting to a Redis instance running in GCP, follow the above steps to connect to a VM that will forward requests from your local relayer server to [Redis running in GCP](https://cloud.google.com/memorystore/docs/redis/connect-redis-instance#connecting_from_a_local_machine_with_port_forwarding)
2. Run `redis-server --bind 127.0.0.1 --port 6379` - make sure the port matches the `redis_url` in the `config.toml`.
3. Run `redis-cli -h 127.0.0.1 -p 6379`

### Advanced setup

- [Multiple Key Generation](https://github.com/near/pagoda-relayer-rs/tree/main?tab=readme-ov-file#multiple-key-generation---optional-but-recommended-for-high-throughput-to-prevent-nonce-race-conditions): this is optional, but recommended for high throughput to prevent nonce race conditions. Check 
- [Docker Deployment](https://github.com/near/pagoda-relayer-rs/tree/main?tab=readme-ov-file#docker-deployment): instructions to deploy with Docker
- [Cloud Deployment](https://github.com/near/pagoda-relayer-rs/tree/main?tab=readme-ov-file#cloud-deployment): instructions to deploy on Cloud providers

### API Specifications

You can find the complete Relayer server API specification on the [GitHub repository](https://github.com/near/pagoda-relayer-rs/tree/main?tab=readme-ov-file#api-spec-).

### Use cases

The [examples folder](https://github.com/near/pagoda-relayer-rs/tree/main/examples) on the GitHub repository contains example configuration files corresponding to different use cases. 

:::info
These files are for reference only and you should update the `config.toml` values before using it on your development environment.
:::

#### No filters

This is a config for a relayer that covers gas for all user transactions to all contracts with no filters. To prevent abuse, this should only be used if there's only a secure backend calling the relayer
- [`no_filters.toml`](https://github.com/near/pagoda-relayer-rs/blob/main/examples/configs/no_filters.toml)

#### Basic whitelist

This is a configuration for a basic relayer that covers gas for user transactions to interact with a whitelisted set of contracts
- [`basic_whitelist.toml`](https://github.com/near/pagoda-relayer-rs/blob/main/examples/configs/basic_whitelist.toml)

#### Redis

This is a configuration for a relayer that covers gas for user transactions up to a allowance specified in Redis to interact with a whitelisted set of contracts. 
- Allowances are on a per-account id basis and on signup (account creation in Redis and on-chain) an OAuth token is required to help with sybil resistance
- [`redis.toml`](https://github.com/near/pagoda-relayer-rs/blob/main/examples/configs/redis.toml)

#### FastAuth

This is a configuration for use if you intend to integrate with [FastAuth SDK](fastauth-sdk.md)
- It covers gas for user transactions up to a allowance specified in Redis to interact with a whitelisted set of contracts. 
- Allowances are on a per-account id basis and on signup (account creation in Redis and on-chain) an OAuth token is required to help with sybil resistance 
- This also makes use of a shared storage functionality on the Near Social DB contract 
- and a whitelisted sender (`whitelisted_delegate_action_receiver_ids`)
- [`fastauth.toml`](https://github.com/near/pagoda-relayer-rs/blob/main/examples/configs/fastauth.toml)

#### Pay with fungible tokens

This is a configuration for a relayer that ensures there's FTs sent to a burn address used to cover the equivalent amount of gas for user transactions to interact with a whitelisted set of contracts 
- [`pay_with_ft.toml`](https://github.com/near/pagoda-relayer-rs/blob/main/examples/configs/pay_with_ft.toml)

#### Whitelist senders

This is a config for a relayer that covers gas for a whitelisted set of users' transactions to interact with a whitelisted set of contracts
- [`whitelist_senders.toml`](https://github.com/near/pagoda-relayer-rs/blob/main/examples/configs/whitelist_senders.toml) (`whitelisted_delegate_action_receiver_ids`)

#### Shared storage

This is a configuration for a relayer that covers BOTH gas AND storage fees for user transactions to interact with a whitelisted set of contracts

- be sure to include shared storage logic based on [`shared_storage.rs`](https://github.com/NearSocial/social-db/blob/master/contract/src/shared_storage.rs) in your contract that is being whitelisted
- [`shared_storage.toml`](https://github.com/near/pagoda-relayer-rs/blob/main/examples/configs/shared_storage.toml)

#### Exchange withdraw

This is a configuration for a relayer where an exchange running the relayer covers user withdraw fees when they are withdrawing stablecoins on NEAR (e.g., `USDT` or `USDC`)

- [`exchange_withdraw.toml`](https://github.com/near/pagoda-relayer-rs/blob/main/examples/configs/exchange_withdraw.toml)

'''
'''--- docs/2.build/1.chain-abstraction/multichain-gas-relayer/gas-station.md ---
---
id: gas-station
title: Multichain Gas Station Contract
sidebar_label: Multichain Gas Station
---

The [multichain gas station smart contract](https://github.com/near/multichain-gas-station-contract) accepts payments in NEAR tokens in exchange for gas funding on non-NEAR foreign chains. Part of the NEAR Multichain effort, it works in conjunction with the [MPC recovery service](https://github.com/near/mpc-recovery) to generate on-chain signatures.

## What is it?

This smart contract is a piece of the NEAR Multichain project, which makes NEAR Protocol an effortlessly cross-chain network. This contract accepts EVM transaction request payloads and facilitates the signing, gas funding, and relaying of the signed transactions to their destination chains. It works in conjunction with a few different services, including:

- The [MPC recovery service](https://github.com/near/mpc-recovery), also called the _"MPC signer service"_, includes a network of trusted MPC signers, which hold keyshares and cooperatively sign transactions on behalf of the MPC network. It also includes an on-chain component, called the _"MPC signer contract,"_ which accepts on-chain signature requests and returns signatures computed by the MPC network.
- The [multichain relayer server](multichain-server.md) scans this smart contract for signed transaction payloads and emits them to foreign chain RPCs.

## How it works

Currently, relaying one transaction to a foreign chain requires three transactions.
Three transactions are required because of the gas restrictions imposed by the protocol. Currently (pre-NEP-516), the MPC signing function requires a _lot_ of gas, so dividing up the signing process into three parts is required to maximize the amount of gas available to each signing call.

:::info
[NEP-516 (delayed receipts / runtime triggers)](https://github.com/near/NEPs/issues/516) will reduce the required transactions to one.
:::

Transaction breakdown:

1. The first transaction is a call to the `create_transaction` function. This function accepts an EVM transaction request payload and a deposit amount (to pay for gas on the foreign chain) and returns an `id` and a `pending_transactions_count`.
2. The second transaction is a call to the `sign_next` function. This function accepts the `id` returned in step 1 and returns a signed payload. This payload is the gas funding transaction, transferring funds from a paymaster account on the foreign chain to the user's account on the foreign chain. It must be submitted to the foreign chain before the second signed payload.
3. The third transaction is another call to the `sign_next` function, identical to the one before. This function accepts an `id` and returns a signed payload. This payload is the signed user transaction.

Once this service and its supporting services are live, the multichain relayer server will be monitoring this gas station contract and relaying the signed transactions in the proper order as they become available, so it will not be strictly necessary for the users of this contract to ensure that the transactions are properly relayed, unless the user wishes to relay the transactions using their own RPC (e.g. to minimize latency).

## Variable Gas fees

There's a premium on the Gas Station in `NEAR` for what the gas will cost on the foreign chain to account for variation in both the exchange rate between transactions, settlement between chains, and to account for variation in gas costs until the transaction is confirmed.

This is the formula for calculating the gas fee:

`(gas_limit_of_user_transaction + 21000) * gas_price_of_user_transaction * near_tokens_per_foreign_token * 1.2`

:::note

- `21000` is the exact amount of gas necessary to transfer funds on `BSC`.
- `1.2` is an arbitrage fee: charge 20% more than market rate to discourage people from using the Gas Station as an arbitrage/DEX.

:::

## Settlement

Settlement is needed because the Gas Station contract is accumulating NEAR, while the [Paymaster accounts](multichain-server.md#paymaster) on foreign chains are spending native foreign chain gas tokens (`ETH`, `BNB`, `SOL`, etc).

Manual Settlement involves several steps:

1. Withdrawing the NEAR held in the gas station contract and swapping for a token that can be bridged.
   This may be the native gas token of the foreign chain, another token like USDC that has wide bridge support, or NEAR.

2. Bridging the token from NEAR to the foreign chain.
   - Here's an [overview of bridging related to NEAR](https://knotty-marsupial-f6d.notion.site/NEAR-Bridging-Guides-f4359bd35c794dc184b098f7ed00c4ce).

3. Sending the native gas tokens to the paymaster accounts on the foreign chains.
   - A swap from the bridged token to the native gas token before sending to the paymaster accounts is necessary if the token that was bridged was not the foreign chain native gas token

## Contract Interactions

:::tip
You can review the complete smart contract source code in [this GitHub repository](https://github.com/near/multichain-gas-station-contract).
:::

### Setup and Administration

1.    Initialize the contract with a call to `new`. The [owner](https://github.com/near/near-sdk-contract-tools/blob/develop/src/owner.rs) is initialized as the predecessor of this transaction. All of the following transactions must be called by the owner.
2.    Refresh the MPC contract public key by calling `refresh_signer_public_key`.
3.    Set up foreign chain configurations with `add_foreign_chain`.
4.    Add paymasters to each foreign chain with `add_paymaster`.

### Usage

Users who wish to get transactions signed and relayed by this contract and its accompanying infrastructure should perform the following steps:

1. Construct an unsigned transaction payload for the foreign chain they wish to interact with, e.g. Ethereum.
2. Call `create_transaction` on this contract, passing in that payload and activating the `use_paymaster` toggle in the case that the user wishes to use a paymaster.
   - If the user uses a paymaster, he must attach a sufficient quantity of NEAR tokens to this transaction to pay for the gas + service fee.
   - This function call returns an `id` and a `pending_transactions_count`.
3. Call `sign_next`, passing in the id value obtained in the previous step. This transaction should be executed with the maximum allowable quantity of gas (i.e. 300 TGas).
   - This transaction will return a signed payload, part of the sequence of transactions necessary to send the user's transaction to the foreign chain.
   - Repeat `pending_transactions_count` times.
4. Relay each signed payload to the foreign chain RPC in the order they were requested.

:::tip testnet contract

If you want to try things out, this smart contract is available on `canhazgas.testnet`.

:::

## Limitations

When using the Multichain Gas relayer solution, some limitations should be consider. Here's a list of potential issues you might encounter, and suggested ways to mitigate them:
- Not enough gas for a cross-chain transaction to get included in time.
  - **Solution:** overcharge for gas at the gas station and when constructing the transaction include more than the average gas price.
- Slippage violations causing the gas token or foreign chain Fungible Token to get refunded to the user's foreign chain address.
  - **Solution:** encourage your users to use high slippage settings in volatile or low liquidity market conditions.
  - **Solution:** if such error occurs, make the user aware of what happened and that funds were not lost.
  - **Note:** in future versions the solution will support retrying transactions.
- Nonce issues if Paymaster rotation isn't done properly. This issue is a function of concurrent usage, blockchain finality time, and number of paymaster treasury accounts that the [Gas Station](gas-station.md) is rotating through.
  - **Solution:** use a blockchain that has faster finality.
  - **Solution:** increase the number of paymaster treasury accounts that the gas station rotates through.

'''
'''--- docs/2.build/1.chain-abstraction/multichain-gas-relayer/multichain-server.md ---
---
id: multichain-server
title: Multichain Relayer Server
sidebar_label: Multichain Relayer Server
---

The [Multichain Relayer Server](https://github.com/near/multichain-relayer-server) facilitates cross-chain transactions and enables Chain Abstraction.

## Overview

The main function of this server is interfacing with foreign chain RPCs sending both presigned funding transactions to cover gas and the actual presigned transaction once the funding is done. 

Although the multichain relayer is a server in current design of this system, the goal is to package this as a library that can be called on the client side of the wallet. This will make the system more decentralized.

:::tip
The Multichain Relayer is meant to be deployed alongside the [Gas Station Event Indexer](https://github.com/near/gas-station-event-indexer) on the same server so that the gas station event indexer can call the multichain relayer server via IPC instead of having to send the request over the network introducing extra latency to the system.
:::

## Technical system design

Below is a design diagram of the entire multichain relayer system:

![multichain_relayer_technical_design.png](/docs/multichain_relayer_technical_design.png)

- The [gas station contract](https://github.com/near/multichain-gas-station-contract) and the [MPC signing service contract](https://github.com/near/mpc-recovery/tree/main/contract) are in the green box which take place on NEAR.
- This multichain relayer server focuses on the purple/blue Multichain Relayer Core Backend Services Box in the middle and the connections to the XChain systems in the red box via RPCs.
- The XChain Settlement that's happening in the yellow box is currently manual and will be automated in the future.

## Paymaster

A paymaster represents an address on a destination chain that holds a balance of that chain‚Äôs native gas token:
- User addresses on destination chains will be funded directly from paymaster accounts.
- Partners that want to integrate with the Multichain Gas Relayer service need to create, fund, and manage paymaster accounts on the destination chains that they want to have support for.
- [Manual settlement](gas-station.md#settlement) between the [NEAR Gas Station contract](gas-station.md) and paymaster accounts are also required on a regular basis to ensure a consistent balance of funds.

## System workflow

1. The wallet sends a NEAR transaction to the gas station contract that contains 2 actions:
   1. A transfer of `NEAR` (or FT Transfer in the future) to cover gas on the foreign chain
   2. A `create_transaction` function call to the gas station contract `canhazgas.testnet` containing the unsigned foreign chain transaction to be signed by the MPC signing service, assuming the unsigned transaction passes validation.
2. The Gas Station Contract calls the MPC signing service to sign both a funding transaction, which ensures the user's foreign chain account has sufficient gas to execute the desired transaction, and signs the unsigned foreign chain transaction.
3. Upon receipt of both the signed transactions, the Gas Station Contract emits an event which is picked up by the indexer, which then calls the `/send_funding_and_user_signed_txns` with the 2 signed transactions from the indexer.
4. The multichain relayer server sends the funding transaction to the foreign chain RPC to fund the user's account with gas.
5. After the gas funding transaction is confirmed, the multichain relayer server calls the foreign chain RPC again to send the signed transaction initiated by the user in step 1.
6. The Cross Chain Settlement takes care of selling the extra `NEAR` being sent to the gas station contract for gas tokens on foreign chains as well as bridging the tokens to the other chains. This process is currently manual, but will be automated in partnership with market makers in the future.

## Relayer Server Endpoints

1. `/send_funding_and_user_signed_txns` which handles both
   1. Funding the user's XChain account with gas from the paymaster treasury account, which is provided as a raw signed transaction
   2. Sending the user's raw signed transaction (in hexadecimal in EVM case) after the funding transaction has been confirmed on the foreign chain

## Supported Chains

- BSC testnet
- BSC mainnet, Ethereum mainnet, and more chains coming soon!

:::info
Check the Relayer's [GitHub repository](https://github.com/near/multichain-relayer-server) to learn more about upcoming features and updates.
:::

## Limitations

When using the Multichain Gas relayer solution, some limitations should be considered. Here's a list of potential issues you might encounter, and suggested ways to mitigate them:
- Not enough gas for a cross-chain transaction to get included in time.
  - **Solution:** overcharge for gas at the gas station and when constructing the transaction include more than the average gas price.
- Slippage violations causing the gas token or foreign chain Fungible Token to get refunded to the user's foreign chain address.
  - **Solution:** encourage your users to use high slippage settings in volatile or low liquidity market conditions.
  - **Solution:** if such error occurs, make the user aware of what happened and that funds were not lost.
  - **Note:** in future versions the solution will support retrying transactions.
- Nonce issues if Paymaster rotation isn't done properly. This issue is a function of concurrent usage, blockchain finality time, and the number of paymaster treasury accounts that the [Gas Station](gas-station.md) is rotating through.
  - **Solution:** use a blockchain that has faster finality.
  - **Solution:** increase the number of paymaster treasury accounts through which the gas station rotates.

## Total Time expectations for end users

It depends on the chain, but in our current estimation 50-90% of the time will be on NEAR calling and waiting for the signing to complete on the MPC service. 
The signing service will take 15-30 seconds. 
We assume that both the signing of the foreign chain transaction and the gas funding transaction happen in parallel. 
On BSC mainnet (not beaconchain which has 1 second finality) with 3 second blocktimes there should be 2 blocks for confirmation optimistically bringing the total to 6 seconds optimistically/transaction on BSC. 
We need to make 2 transactions, so that's 12-24 seconds on BSC assuming 2-4 blocks for finality. Add in some network overhead for each step in the process, especially the indexer picking up the emitted event (~5-7 seconds), and we're at 30-60 seconds/transaction on BSC. 
For Solana it would be closer to 20-30 seconds (0.4 second block time, 1 block confirmation). See [table 1](https://usa.visa.com/solutions/crypto/deep-dive-on-solana.html) for more confirmation times. 

L2 real finality times can over a day for finality unless we trust a centralized sequencer for soft confirmations, which may be as fast as a few seconds as in the case of [zksync era](https://era.zksync.io/docs/reference/concepts/finality.html#instant-confirmations).

The difference between optimistic or soft confirmations vs real finality is something we are considering. We may get better finalized guarantees when the [Eigenlayer-Near Partnership is live](https://pages.near.org/blog/near-foundation-and-eigen-labs-partner-to-enable-faster-cheaper-web3-transactions-for-ethereum-rollups-via-eigenlayer/). 3-4 second finality for all ETH L2s is much more manageable.

'''
'''--- docs/2.build/1.chain-abstraction/multichain-gas-relayer/relayer-gas-example.md ---
---
id: relayer-gas-example
title: Multichain Relayer and Gas Station example
sidebar_label: Relayer + Gas Station
---
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In this article you'll learn how to run end-to-end tests on the entire Multichain Relayer system.  

:::info Required tools

For this tutorial, you'll need to have installed:

 - [Multichain Relayer Server](https://github.com/near/multichain-relayer-server)
 - [Gas Station Event indexer](https://github.com/near/gas-station-event-indexer)
 - [NEAR CLI RS](https://github.com/near/near-cli-rs)

:::

## Setup

Before you start testing, set up your local environment and install the Relayer server, the Event indexer and NEAR CLI.

### Multichain Relayer server

The main function of this server is interfacing with foreign chain RPCs sending both pre-signed funding transactions to cover gas and the actual pre-signed transaction once the funding is done.

To run the [Multichain Relayer Server](https://github.com/near/multichain-relayer-server):

1. Configure the Multichain Relayer by editing the [`config.toml`](https://github.com/near/multichain-relayer-server/blob/main/config.toml) file
2. Start the multichain relayer server:
   ```sh
   cargo run
   ```

:::tip

Find the Multichain Relayer server source code in [this GitHub repository](https://github.com/near/multichain-relayer-server).

:::

### Gas Station Event indexer

The event indexer picks up events emitted from the [gas station contract](gas-station.md) used for generating signed foreign chain transactions and calls the multichain relayer `/send_funding_and_user_signed_txns` endpoint locally.

To run the [Gas Station indexer](https://github.com/near/gas-station-event-indexer):

1. Ensure you have the [Multichain Relayer Server](#multichain-relayer-server) running on `localhost:3030`
2. Create and activate a Python virtual environment:
   ```sh
   pip install requirements.txt
   ```

3. Update the [`config.toml`](https://github.com/near/gas-station-event-indexer/blob/main/config.toml) configuration file with appropriate values
   ```
   network = "testnet"
   # gas station contract account id
   contract_id = "canhazgas.testnet"
   ```

4. Run the indexer:
   ```sh
   python3 gas-station-event-indexer.py
   ```

:::tip

Find the Gas Station Event indexer source code in [this GitHub repository](https://github.com/near/gas-station-event-indexer).

:::

## Running tests

The gas station contract supports EIP-1559 transactions. 

1. Set the transaction details of the EVM transaction you want to send in [`generate_rlp_evm_txn.py`](https://github.com/near/multichain-relayer-server/blob/5b040611f2dc6c6b405b5ec00d5102e3cc27a65c/integration_tests/generate_rlp_evm_txn.py), run the script, and save the RLP hex string output.

:::note

Python and Rust output different hex RLP encoded transactions. 
 - If you're using Rust, use [`generate_eip1559_rlp_hex()`](https://github.com/near/multichain-relayer-server/blob/5b040611f2dc6c6b405b5ec00d5102e3cc27a65c/tests/tests.rs#L24).
 - If you're using Python, use [`generate_rlp_encoded_transaction(is_eip_1559=true)`](https://github.com/near/multichain-relayer-server/blob/5b040611f2dc6c6b405b5ec00d5102e3cc27a65c/integration_tests/generate_rlp_evm_txn.py#L7)

:::

<CodeTabs>
  <Language value="Python" language="python">
    <Github fname="generate_rlp_evm_txn.py"
        url="https://github.com/near/multichain-relayer-server/blob/5b040611f2dc6c6b405b5ec00d5102e3cc27a65c/integration_tests/generate_rlp_evm_txn.py"
        start="7" end="13" />
  </Language>
  <Language value="Rust" language="rust">
    <Github fname="test.rs"
        url="https://github.com/near/multichain-relayer-server/blob/5b040611f2dc6c6b405b5ec00d5102e3cc27a65c/tests/tests.rs"
        start="24" end="38" />
  </Language>
</CodeTabs>

2. Ensure the [Multichain Relayer server](#multichain-relayer-server) is configured correctly and running.

3. Ensure the [Gas Station indexer](#gas-station-event-indexer) is running locally.

4. Construct the signed transaction using the [near-cli-rs](https://github.com/near/near-cli-rs).
   The receiver account ID should be the gas station contract.
   You will need 2 actions if you want the gas station to cover your gas cost on the foreign chain:
    - 1 action to send the NEAR equivalent
    - 1 function call to the gas station.

   You should transfer the amount of `NEAR` that's needed to cover gas both on NEAR and on the foreign chain.
   You also need to paste in the RLP generated hex for the EVM transaction you want on the other chain generated in step 1.

   When it asks you to _send_ or _display_, choose <kbd>send</kbd>.
   Example below:
   ```sh
   near contract call-function as-transaction canhazgas.testnet create_transaction json-args '{"transaction_rlp_hex":"eb80851bf08eb000825208947b965bdb7f0464843572eb2b8c17bdf27b720b14872386f26fc1000080808080","use_paymaster":true}' prepaid-gas '100.000 TeraGas' attached-deposit '0.5 NEAR' sign-as nomnomnom.testnet network-config testnet sign-with-keychain send
   ```

5. Get the `"id"` from the receipts from the call in step 4, and use that to call `sign_next` twice:
   ```sh
    near contract call-function as-transaction canhazgas.testnet sign_next json-args '{"id":"16"}' prepaid-gas '300.0 Tgas' attached-deposit '0 NEAR' sign-as nomnomnom.testnet network-config testnet sign-with-keychain send
   ```

## Options for testing purposes

Instead of creating a signed transaction and calling the gas station contract to sign it, you can get the recently signed transactions by calling the contract while replacing the `blockheight` with a more recent block height:

```sh
near contract call-function as-read-only canhazgas.testnet list_signed_transaction_sequences_after json-args '{"block_height":"157111000"}' network-config testnet now
```

This will return something like the output below. Take an individual entry in the list of JSONs and send that as the payload of a `POST` request to the `/send_funding_and_user_signed_txns` endpoint:

```jsx
[
  {
    "created_by_account_id": "b807806adcb73f6aecb5ed98bb8bd7bbe7bbf8ed342596ab700ef6b050abc4c3",
    "foreign_chain_id": "97",
    "signed_transactions": [
      "0x02f873610385174876e80085174876e80082520894c89663ac6d169bc3e2e0a99d9fe96f2e82bcc307870eebe0b40e800080c080a0712d44ba4cd7567764231e21f054c5e7d008055222820e9d5ba148ede48755f7a06e8b812d37047593fc51fce7254ea7aef89927cada729bc903cd36fa9659dce4",
      "0x02f873618085174876e80085174876e80082520894ef55a8bdf4498ea0af88bc54efb29608bb25e130872aa1efb94e000080c080a017d7024fe9e32ad8da1181729fac7e6a45311c47bf59f2b5a8b5e9fe002c0617a04ad725b362cf12c6e066c5b0b7ecbbf08f5e4d0a240337e6ddc8076f0528e3e5"
    ]
  },
...
  {
    "created_by_account_id": "b807806adcb73f6aecb5ed98bb8bd7bbe7bbf8ed342596ab700ef6b050abc4c3",
    "foreign_chain_id": "97",
    "signed_transactions": [
      "0x02f873610185174876e80085174876e80082520894c89663ac6d169bc3e2e0a99d9fe96f2e82bcc307870eebe0b40e800080c001a0ff19fe769246de8483b986e5aeaa3360bfb74f238e2a91ea353dac9aad9e24a0a020485dcd2c64172b9bc058b7813646dafbf2f27d51aae388b074e514fdb6de05",
      "0x02f873618085174876e80085174876e80082520894ef55a8bdf4498ea0af88bc54efb29608bb25e130872e2f6e5e14800080c001a0dac67c383e8de3211f3c5d360cc2e9a21d160711fc3f80113ac525169317e2eca07140a1d0d1528b6eaf9fac4bb1bd44c1c4f63bb956292b0211a0dad1748e2eea"
    ]
  }
]
```

'''
'''--- docs/2.build/1.chain-abstraction/nft-keys.md ---
---
id: nft-chain-keys
title: NFT Chain Keys Smart Contract
sidebar_label: NFT Chain Keys Contract
---

The NFT Chain Keys smart contract makes the ownership of remote accounts both provable and transferrable. This new paradigm allows you to create new end-user experiences that leverage provable and transferrable remote accounts as a core primitive.

## Contract overview

The [MPC Account Recovery smart contract](https://github.com/near/mpc-recovery) provides a [`sign`](https://github.com/near/mpc-recovery#sign) method that accepts a `path` parameter. This allows one predecessor account to have access to an effectively unlimited number of MPC keys.

The NFT Chain Keys contract takes advantage of this property and allows secure transfers of MPC keys between users, using the [NEP-171 NFT contract standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core).
The contract also implements new functionality to enable chain key management features.

:::info

The essence of Multi-Party Computation (MPC) is to enable independent parties to perform shared computations on private information without revealing secrets to each other.

:::

### Standards

Besides the NEP-171 contract standard, the NFT Chain Keys contract complies with a full suite of NEP standards:

- [NEP-145: Storage Management](https://nomicon.io/Standards/StorageManagement)
- [NEP-171: NFT Core](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core)
- [NEP-177: Metadata](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata)
- [NEP-178: Approval Management](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement)
- [NEP-181: Enumeration](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration)

## Usage

Please refer to the smart contract [GitHub documentation](https://github.com/near/multichain-gas-station-contract/blob/master/nft_key/README.md) for usage information:

- [Creating new key tokens](https://github.com/near/multichain-gas-station-contract/tree/master/nft_key#creating-new-key-tokens): mint unlimited new NFT chain keys, as long as the account has sufficient storage.
- [Issuing signatures](https://github.com/near/multichain-gas-station-contract/tree/master/nft_key#issuing-signatures): generate new signatures based on a submitted payload.
- [Approvals](https://github.com/near/multichain-gas-station-contract/tree/master/nft_key#approvals): implement a separate set of approval management functions for using NFTs, which operate similarly to NEP-178.

:::tip testnet contract

If you want to try things out, this smart contract is available on `nft.kagi.testnet`.

:::

---

## Use Cases for NFT Keys

:::info Disclaimer
The ideas presented in this section are just initial concepts, and shouldn‚Äôt be considered as fully fledged solutions.
:::

### Remote Account Marketplace

NFT Keys enable users to buy, sell, and trade remote accounts within a marketplace-style application.
For instance, _Alice_, possessing a set of remote accounts with value and history, can mint an NFT key and list these accounts for sale on the marketplace.
Potential buyers, like _Bob_, can browse the value of _Alice‚Äôs_ accounts and choose to make a purchase.
If _Bob_ decides to proceed, they would simply need to acquire ownership of the original NFT key from _Alice_ in exchange for payment, such as in `$NEAR`.
Once the transaction is completed, ownership of the accounts transfers to _Bob_.

### Bridgeless Multi-Chain DEX

You can create a Multi-chain DEX without bridging by combining Chain Signatures with NFT Keys.
Users wishing to swap asset `$A` for asset `$B` would initiate the swap on the bridgeless DEX.
Supported by liquidity providers (Automated Market Makers) across multiple chains, the DEX facilitates these swaps.
Here's how it works:

- A user proposes the swap, specifying asset `$A` in remote `account X` for asset `$B` in remote `account Y`.
- The liquidity provider receives asset `$A` from the user and sends the equivalent amount of asset `$B` to a newly created remote `account Y`, along with a minted NFT key.
- The NFT key is then sent to the user to complete the swap.

Although liquidity providers still need to leverage bridging to settle assets between different pools, users of this exchange type are exposed to reduced bridge risk.

'''
'''--- docs/2.build/1.chain-abstraction/wallet.md ---
---
id: wallet
title: Wallet Chain Key Rules 
---

## Overview

In this article you'll find details on how to parse and present multichain transactions to the user so they can take an informed decision about their wallet's assets, while minimizing the number of times the user has to consent.
You'll also learn how to ensure that a signature on one chain is not used to take a meaningful action on another chain.

### Key derivation

When signing using [chain signatures](./chain-signatures.md) each account has an unlimited number of keys. Each key's public key is derived from the account name and the key extension which is an arbitrary string. 

User's keys can be described as follow:

```
"david.near,"              A key with no extension
"david.near, "             A key with an extension of " "
"david.near,cold_wallet"   A key with an extension of "cold_wallet"
```

:::tip
If the keys aren't identical they have no relationship.
:::

### Ambiguous signatures

You're going to be potentially storing keys for users who hold assets on many chains. Different chains have different ways of serializing and signing transactions. Many chains take steps to ensure that their signatures are not valid signatures on other chains. EVM chains use `ChainID` to disambiguate signatures between different EVM chains. Dfinity uses a unique salt on the hash of the transaction.

Unfortunately, while this is a best practice, you can't guarantee that all chains do this. As such, a user could receive an innocent looking transaction on one chain that could be used to take a destructive action on another chain.

An apocryphal example:

```
Transaction: "7b73656e643a2022313030222c206e6f74652022227d"
Parsed SOL: claim free NFT
Parsed BTC: send 100 BTC to Attacker
```

The user would approve the `SOL` transaction but the attacker would also get the `BTC` transaction.

This can be solved by having different keys for any chains that you can't prove could have ambiguous transactions. This means that while an attacker may create ambiguous transactions, it will only be for wallets without assets on the target chain.

## Serialization format

We're using the following format for our derivations paths.

```typescript
{
   chain: number, // SLIP-44 coin type unsigned integer
   domain: String, // The domain that owns this key
   meta: any, // Catch all data structure
}
```

This is encoded in canonical [JSON RFC 8785](https://www.rfc-editor.org/rfc/rfc8785).

:::info
If you are not using a field don't make it `null`, don't include the key instead.
:::

### User-defined fields

For user-defined fields, the `meta` field can include any data you like. 

:::tip
Do not add any extra fields at the top level, as that may clash with future versions of this specification. If needed, put them in the `meta` field instead.
:::

For example, a simple way of selecting alternate keys will be using an object with an `ID` field:

```typescript
{
    meta: {id: 10}, // Pick the tenth bitcoin key
    chain: 0,
}
```

### Examples

| Key | Description |
|-----|-------------|
| `{chain: 0, domain: "near.org"}` |  A bitcoin key used on `near.org` |
| `{chain: 0, meta: {id: 3}}`      |  Use the third bitcoin key |

## Example user flows

In the following examples, the messages are coming from the user's wallet frontend.

- [Using a domains bitcoin key](#using-a-domains-bitcoin-key)
- [Using a personal Bitcoin key](#using-a-personal-bitcoin-key)
- [Using a personal EVM key to sign a Binance transaction](#using-a-personal-evm-key-to-sign-a-binance-transaction)
- [Using an untyped domain key](#using-an-untyped-domain-key)
- [Using another domains Bitcoin key](#using-another-domains-bitcoin-key)

:::tip
Wallet developers should follow this user flow format.
:::

### Using a domains bitcoin key

An application at `near.org` wants to sign the Bitcoin transaction `Send 100 BTC` using the key `david.near,bitcoin,near.org,`.

```
Signed ‚úÖ
```

We sign the transaction without confirmation because the key is owned by `near.org`.

### Using a personal Bitcoin key

An application at `near.org` wants to sign the Bitcoin transaction `Send 100 BTC` using the key `david.near,bitcoin,`.

```
near.org would like to run the following Bitcoin transaction:

Send 100 BTC
[Accept] [Reject]
```

The user must make an informed decision about whether this is an action they would like to take.

```
Signed ‚úÖ
```

### Using a personal EVM key to sign a Binance transaction

An application at `near.org` wants to sign the Binance Smart Chain transaction `Send 100 BNB, ChainID 56` using the key `david.near,evm,`. The wallet knows this is a BSC transaction because of the corresponding `ChainID` (56) and because the `evm` key is being used.

```
near.org would like to run the following Binance Smart Chain transaction:

Send 100 BNB
[Accept] [Reject]
```

The user must make an informed decision about whether this is an action they would like to take.

```
Signed ‚úÖ
```

### Using an untyped domain key

An application at `near.org` wants to sign the Bitcoin transaction `Send 100 BTC` using the key `david.near,,near.org,`.

```
Signed ‚úÖ
```

While this is ill advised, it's still the domains key so the domain can still choose whether to sign something using it.

### Using another domains Bitcoin key

An application at `attacker.com` wants to sign the Bitcoin transaction `Send 100 BTC` using the key `david.near,bitcoin,near.org,`.

```
Attacker.com would like to sign a transaction using your credentials from near.org

Send 100 BTC

This is a suspicious transaction and likely not one you should accept
[Reject] [Accept (Are you sure!)]
```

The user must make an explicit decision to do something that is ill advised.

```
Signed ‚úÖ
```

The correct way for `attacker.com` to make this request is to somehow redirect the user to `near.org` and get the user to make a decision there.

'''
'''--- docs/2.build/1.chain-abstraction/what-is.md ---
---
id: what-is
title: What is Chain Abstraction? 
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

The idea behind `chain abstraction` is quite simple: **blockchain** technology should be **abstracted away** from the user experience. In other words, people should **not realize** when they are **using a blockchain**, nor **which blockchain** they are using.

![img](/docs/assets/welcome-pages/chain-abstraction-landing.png)

To help on this task, NEAR Protocol provides services that allow to **create** and **recover accounts** using **email addresses**, use the account **without acquiring funds**, and **control accounts** in **other chains**. All in the most **seamless** way possible.

---

## Fast-Auth: Email onboarding
One of the first barriers that new users face when entering the world of Web3 is the need to create a crypto wallet. This generally implies the need to choose a wallet, create and store a recovery phrase, and obtain deposit funds to start using the account.

With FastAuth, users only need to provide an email address to create a NEAR account. Using the same email address the user will be able to use their account across applications and devices.

:::info
FastAuth accounts are kept safe through multi-party computation (MPC) on a decentralized network. This means that the user's private key is never stored in a single location, and thus it is never exposed to any single party.
:::

<hr subclass="subsection" />

## Relayers: Cover gas fees
Allowing users to start using a dApp without having to acquire funds is a powerful tool to increase user adoption. NEAR Protocol provides a service that allows developers to subsidize gas fees for their users.

This concept, known as "Account Abstraction" in other chains, is a **built-in feature** in NEAR. User can wrap transactions in messages known as **meta-transaction**, that any other account can relay to the network.

:::tip
In NEAR the relayers simply attach NEAR to cover gas fees, and pass the transaction to the network. There, the transaction is executed as if the **user had send it**.
:::

<hr subclass="subsection" />

## Multi-chain signatures: One account, multiple chains 
Currently, users and applications are siloed in different chains. This means that a user needs to create a new account for each chain they want to use. This is not only cumbersome for the user, but also for the developer who needs to maintain different codebases for each chain.

NEAR Protocol provides a multi-chain signature service that allows users to use their NEAR Account to sign transactions in **other chains**. This means that a user can use the same account to interact with **Ethereum**, **Binance Smart Chain**, **Avalanche**, and **NEAR**.

:::info
Multi-chain signatures work by combining **smart contracts** that produce signatures, with indexers that listen for these signatures, and relayers that submit the transactions to other networks. This allows users to hold assets and use applications in **any** network, only needing to have a single NEAR account.
:::
'''
'''--- docs/2.build/2.smart-contracts/anatomy/actions.md ---
---
id: actions
title: Transfers & Actions
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Smart contracts can perform specific `Actions` such as transferring NEAR, or calling other contracts.

An important property of `Actions` is that they can be batched together when acting on the same contract. **Batched actions** act as a unit: they execute in the same [receipt](../../../1.concepts/protocol/transactions.md#receipt-receipt), and if **any fails**, then they **all get reverted**.

:::info
`Actions` can be batched only when they act on the **same contract**. You can batch calling two methods on a contract,
but **cannot** call two methods on different contracts.
:::

---

## Transfer NEAR ‚ìÉ

You can send $NEAR from your contract to any other account on the network. The Gas cost for transferring $NEAR is fixed and is based on the protocol's genesis config. Currently, it costs `~0.45 TGas`.

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```js
  import { NearBindgen, NearPromise, call } from 'near-sdk-js'
  import { AccountId } from 'near-sdk-js/lib/types'

  @NearBindgen({})
  class Contract{
    @call({})
    transfer({ to, amount }: { to: AccountId, amount: bigint }) {
      NearPromise.new(to).transfer(amount);
    }
  }
```

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

```rust
  use near_sdk::{near, AccountId, Promise, NearToken};

  #[near(contract_state)]
  #[derive(Default)]
  pub struct Contract { }

  #[near]
  impl Contract {
    pub fn transfer(&self, to: AccountId, amount: NearToken){
      Promise::new(to).transfer(amount);
    }
  }
```

</TabItem>

</Tabs>

:::tip
The only case where a transfer will fail is if the receiver account does **not** exist.
:::

:::caution
Remember that your balance is used to cover for the contract's storage. When sending money, make sure you always leave enough to cover for future storage needs.
:::

---

## Function Call

Your smart contract can call methods in another contract. In the snippet bellow we call a method
in a deployed [Hello NEAR](../quickstart.md) contract, and check if everything went
right in the callback.

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```js
  import { NearBindgen, near, call, bytes, NearPromise } from 'near-sdk-js'
  import { AccountId } from 'near-sdk-js/lib/types'

  const HELLO_NEAR: AccountId = "hello-nearverse.testnet";
  const NO_DEPOSIT: bigint = BigInt(0);
  const CALL_GAS: bigint = BigInt("10000000000000");

  @NearBindgen({})
  class Contract {
    @call({})
    call_method({}): NearPromise {
      const args = bytes(JSON.stringify({ message: "howdy" }))

      return NearPromise.new(HELLO_NEAR)
      .functionCall("set_greeting", args, NO_DEPOSIT, CALL_GAS)
      .then(
        NearPromise.new(near.currentAccountId())
        .functionCall("callback", bytes(JSON.stringify({})), NO_DEPOSIT, CALL_GAS)
      )
      .asReturn()
    }

    @call({privateFunction: true})
    callback({}): boolean {
      let result, success;
    
      try{ result = near.promiseResult(0); success = true }
      catch{ result = undefined; success = false }
    
      if (success) {
        near.log(`Success!`)
        return true
      } else {
        near.log("Promise failed...")
        return false
      }
    }
  }
```

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

```rust
  use near_sdk::{near, env, log, Promise, Gas, PromiseError};
  use serde_json::json;

  #[near(contract_state)]
  #[derive(Default)]
  pub struct Contract { }

  const HELLO_NEAR: &str = "hello-nearverse.testnet";
  const NO_DEPOSIT: u128 = 0;
  const CALL_GAS: Gas = Gas(5_000_000_000_000);

  #[near]
  impl Contract {
    pub fn call_method(&self){
      let args = json!({ "message": "howdy".to_string() })
                .to_string().into_bytes().to_vec();

      Promise::new(HELLO_NEAR.parse().unwrap())
      .function_call("set_greeting".to_string(), args, NO_DEPOSIT, CALL_GAS)
      .then(
        Promise::new(env::current_account_id())
        .function_call("callback".to_string(), Vec::new(), NO_DEPOSIT, CALL_GAS)
      );
    }

    pub fn callback(&self, #[callback_result] result: Result<(), PromiseError>){
      if result.is_err(){
          log!("Something went wrong")
      }else{
          log!("Message changed")
      }
    }
  }
```

</TabItem>

</Tabs>

:::warning
The snippet showed above is a low level way of calling other methods. We recommend make calls to other contracts as explained in the [Cross-contract Calls section](crosscontract.md).
:::

---

## Create a Sub Account
Your contract can create direct sub accounts of itself, for example, `user.near` can create `sub.user.near`.

Accounts do **NOT** have control over their sub-accounts, since they have their own keys. 

Sub-accounts are simply useful for organizing your accounts (e.g. `dao.project.near`, `token.project.near`).

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```js
  import { NearBindgen, near, call, NearPromise } from 'near-sdk-js'

  const MIN_STORAGE: bigint = BigInt("1000000000000000000000") // 0.001‚ìÉ

  @NearBindgen({})
  class Contract {
    @call({payableFunction:true})
    create({prefix}:{prefix: String}) {
      const account_id = `${prefix}.${near.currentAccountId()}`

      NearPromise.new(account_id)
      .createAccount()
      .transfer(MIN_STORAGE)
    }
  }
```

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

```rust
  use near_sdk::{near, env, Promise, NearToken};

  #[near(contract_state)]
  #[derive(Default)]
  pub struct Contract { }
                            
  const MIN_STORAGE: Balance = 1_000_000_000_000_000_000_000; //0.001‚ìÉ

  #[near]
  impl Contract {
    pub fn create(&self, prefix: String){
      let account_id = prefix + "." + &env::current_account_id().to_string();
      Promise::new(account_id.parse().unwrap())
      .create_account()
      .transfer(MIN_STORAGE);
    }
  }
```

</TabItem>

</Tabs>

:::tip
  Notice that in the snippet we are transferring some money to the new account for storage
:::

:::caution

When you create an account from within a contract, it has no keys by default. If you don't explicitly [add keys](#add-keys) to it or [deploy a contract](#deploy-a-contract) on creation then it will be [locked](../../../1.concepts/protocol/access-keys.md#locked-accounts).

:::

<hr className="subsection" />

#### Creating Other Accounts

Accounts can only create immediate sub-accounts of themselves.

If your contract wants to create a `.mainnet` or `.testnet` account, then it needs to [call](#function-call)
the `create_account` method of `near` or `testnet` root contracts.

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```js
  import { NearBindgen, near, call, bytes, NearPromise } from 'near-sdk-js'

  const MIN_STORAGE: bigint = BigInt("1820000000000000000000"); //0.00182‚ìÉ
  const CALL_GAS: bigint = BigInt("28000000000000");

  @NearBindgen({})
  class Contract {
    @call({})
    create_account({account_id, public_key}:{account_id: String, public_key: String}) {
      const args = bytes(JSON.stringify({ 
        "new_account_id": account_id,
        "new_public_key": public_key 
      }))

      NearPromise.new("testnet")
      .functionCall("create_account", args, MIN_STORAGE, CALL_GAS);
    }
  }
```

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

```rust
  use near_sdk::{near, Promise, Gas, NearToken };
  use serde_json::json;

  #[near(contract_state)]
  #[derive(Default)]
  pub struct Contract { }

  const CALL_GAS: Gas = Gas(28_000_000_000_000);
  const MIN_STORAGE: Balance = 1_820_000_000_000_000_000_000; //0.00182‚ìÉ

  #[near]
  impl Contract {
    pub fn create_account(&self, account_id: String, public_key: String){
      let args = json!({
                  "new_account_id": account_id,
                  "new_public_key": public_key,
                }).to_string().into_bytes().to_vec();

      // Use "near" to create mainnet accounts
      Promise::new("testnet".parse().unwrap())
      .function_call("create_account".to_string(), args, MIN_STORAGE, CALL_GAS);
    }
  }
```

</TabItem>

</Tabs>

---

## Deploy a Contract

When creating an account you can also batch the action of deploying a contract to it. Note that for this, you will need to pre-load the byte-code you want to deploy in your contract.

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="rust" label="ü¶Ä Rust">

```rust
  use near_sdk::{near, env, Promise, NearToken};

  #[near(contract_state)]
  #[derive(Default)]
  pub struct Contract { }

  const MIN_STORAGE: Balance = 1_100_000_000_000_000_000_000_000; //1.1‚ìÉ
  const HELLO_CODE: &[u8] = include_bytes!("./hello.wasm");

  #[near]
  impl Contract {
    pub fn create_hello(&self, prefix: String){
      let account_id = prefix + "." + &env::current_account_id().to_string();
      Promise::new(account_id.parse().unwrap())
      .create_account()
      .transfer(MIN_STORAGE)
      .deploy_contract(HELLO_CODE.to_vec());
    }
  }
```

</TabItem>

</Tabs>

:::tip
If an account with a contract deployed does **not** have any access keys, this is known as a locked contract. When the account is locked, it cannot sign transactions therefore, actions can **only** be performed from **within** the contract code.
:::

---

## Add Keys

When you use actions to create a new account, the created account does not have any [access keys](../../../1.concepts/protocol/access-keys.md), meaning that it **cannot sign transactions** (e.g. to update its contract, delete itself, transfer money).

There are two options for adding keys to the account:
1. `add_access_key`: adds a key that can only call specific methods on a specified contract.
2. `add_full_access_key`: adds a key that has full access to the account.

<br/>

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```js
  import { NearBindgen, near, call, NearPromise } from 'near-sdk-js'
  import { PublicKey } from 'near-sdk-js/lib/types'

  const MIN_STORAGE: bigint = BigInt("1000000000000000000000") // 0.001‚ìÉ

  @NearBindgen({})
  class Contract {
    @call({})
    create_hello({prefix, public_key}:{prefix: String, public_key: PublicKey}) {
      const account_id = `${prefix}.${near.currentAccountId()}`

      NearPromise.new(account_id)
      .createAccount()
      .transfer(MIN_STORAGE)
      .addFullAccessKey(public_key)
    }
  }
```

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

```rust
  use near_sdk::{near, env, Promise, Balance, PublicKey};

  #[near(serializers = [json, borsh])]
  #[derive(Default)]
  pub struct Contract { }

  const MIN_STORAGE: Balance = 1_100_000_000_000_000_000_000_000; //1.1‚ìÉ
  const HELLO_CODE: &[u8] = include_bytes!("./hello.wasm");

  #[near]
  impl Contract {
    pub fn create_hello(&self, prefix: String, public_key: PublicKey){
      let account_id = prefix + "." + &env::current_account_id().to_string();
      Promise::new(account_id.parse().unwrap())
      .create_account()
      .transfer(MIN_STORAGE)
      .deploy_contract(HELLO_CODE.to_vec())
      .add_full_access_key(public_key);
    }
  }
```

</TabItem>

</Tabs>

Notice that what you actually add is a "public key". Whoever holds its private counterpart, i.e. the private-key, will be able to use the newly access key.

:::tip
If an account with a contract deployed does **not** have any access keys, this is known as a locked contract. When the account is locked, it cannot sign transactions therefore, actions can **only** be performed from **within** the contract code.
:::

---

## Delete Account

There are two scenarios in which you can use the `delete_account` action:
1. As the **last** action in a chain of batched actions.
2. To make your smart contract delete its own account.

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```js
  import { NearBindgen, near, call, NearPromise } from 'near-sdk-js'
  import { AccountId } from 'near-sdk-js/lib/types'

  const MIN_STORAGE: bigint = BigInt("1000000000000000000000") // 0.001‚ìÉ

  @NearBindgen({})
  class Contract {
    @call({})
    create_delete({prefix, beneficiary}:{prefix: String, beneficiary: AccountId}) {
      const account_id = `${prefix}.${near.currentAccountId()}`

      NearPromise.new(account_id)
      .createAccount()
      .transfer(MIN_STORAGE)
      .deleteAccount(beneficiary)
    }

    @call({})
    self_delete({beneficiary}:{beneficiary: AccountId}) {
      NearPromise.new(near.currentAccountId())
      .deleteAccount(beneficiary)
    }
  }
```

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

```rust
  use near_sdk::{near, env, Promise, Neartoken, AccountId};

  #[near(contract_state)]
  #[derive(Default)]
  pub struct Contract { }
                            
  const MIN_STORAGE: Balance = 1_000_000_000_000_000_000_000; //0.001‚ìÉ

  #[near]
  impl Contract {
    pub fn create_delete(&self, prefix: String, beneficiary: AccountId){
      let account_id = prefix + "." + &env::current_account_id().to_string();
      Promise::new(account_id.parse().unwrap())
      .create_account()
      .transfer(MIN_STORAGE)
      .delete_account(beneficiary);
    }

    pub fn self_delete(beneficiary: AccountId){
      Promise::new(env::current_account_id())
      .delete_account(beneficiary);
    }
  }
```

</TabItem>

</Tabs>

:::warning Token Loss
If the beneficiary account does not exist the funds will be [**dispersed among validators**](../../../1.concepts/basics/token-loss.md).
:::

:::warning Token Loss
Do **not** use `delete` to try fund a new account. Since the account doesn't exist the tokens will be lost.
:::

'''
'''--- docs/2.build/2.smart-contracts/anatomy/anatomy.md ---
---
id: anatomy
title: Basic Anatomy
hide_table_of_contents: true
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

import {ExplainCode, Block, File} from '@site/src/components/CodeExplainer/code-explainer';

Let's illustrate the basic anatomy of a simple "Hello World" contract. The code on this page comes from our [Hello NEAR repository](https://github.com/near-examples/hello-near-examples) on Github.

<ExplainCode languages={["js", "rust"]} >
  <Block highlights={{"js": "1", "rust": "1"}} fname="hello-near">
    ### Importing the SDK
    All contracts will import the **NEAR SDK**, enabling them to [access the execution environment](./environment.md), [call other contracts](./crosscontract.md), [transfer tokens](./actions.md), and much more

    You can also use third-party libraries, thought some might not work due to the limitations of the contract runtime
  </Block>
  <Block highlights={{"js": "4-17", "rust":"5-7,20-31"}} fname="hello-near">
    ### Contract's Class / Structure
    The contract is described through a `Class` / `Struct` :
    - The attributes define which data the contract stores
    - The functions define its public (and private) interface 
  </Block>
  <Block highlights={{"js": "3"}} fname="hello-near">
    ### Contract Class Decorator
    
    Note that the contract's class is decorated with `@NearBindgen`. This decorator tells the SDK which class defines the contract, so it knows:
    1. What to fetch from storage when the contract is loaded
    2. What to store when the contract is done executing
    3. The methods that are exposed to the outside world

    **Note:** Only one class can be decorated with the `@NearBindgen` decorator
  </Block>
  <Block highlights={{"rust": "4,19"}} fname="hello-near">
    ### Contract Struct Macro
    
    Note that the contract's struct definition and the implementation are decorated with macros
    
    The `#[near(contract_state)]` macro tell the SDK that this structure defines the contract's state, so it knows:
    1. What to fetch from storage when the contract is loaded
    2. What to store when the contract is done executing

    The `#[near]` macro tells the SDK which functions are exposed to the outside world

    **Note:** Only one struct can be decorated with the `#[near(contract_state)]` macro
  </Block>
  <Block highlights={{"js": "5", "rust": "6,10-16"}} fname="hello-near">
    ### Storage (State)
    We call the data stored in the contract [the contract's state](./storage.md).
    
    In our Hello World example, the contract stores a single string (`greeting`), and the state starts initialized with the default value `"Hello"` 

    **Note:** We will cover more about the contract's state in the [state section](./storage.md)
  </Block>
  <Block highlights={{"js": "8-10", "rust": "22-24"}} fname="hello-near">
    ### Read Only Functions
    Contract's functions can be read-only, meaning they don't modify the state. Calling them is free for everyone, and does not require to have a NEAR account

    **Note:** We will cover more about function types in the [functions section](./functions.md)
  </Block>
  <Block highlights={{"js": "13-16", "rust": "27-30"}} fname="hello-near">
    ### State Mutating Functions
    Functions that modify the state or call other contracts are considered state mutating functions. It is necessary to have a NEAR account to call them, as they require a transaction to be sent to the network

    **Note:** We will cover more about function types in the [functions section](./functions.md)
  </Block>
  <File
    language="js"
    fname="hello-near" 
    url="https://github.com/near-examples/hello-near-examples/blob/main/contract-ts/src/contract.ts"
    start="2"
    end="18"
  />
  <File
    language="rust"
    fname="hello-near" 
    url="https://github.com/near-examples/hello-near-examples/blob/main/contract-rs/src/lib.rs"
    start="2"
    end="32"
  />
</ExplainCode>
'''
'''--- docs/2.build/2.smart-contracts/anatomy/collections.md ---
---
id: collections
title: Data Structures
---
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Each contract has its own state (storage), which **only they can modify** but [anyone can see](../../../4.tools/cli.md#near-view-state-near-view-state).

A contract stores all its data in a `key-value` storage. This however is abstracted from you by the SDK through [serialization](./serialization.md).

:::info
Contracts [pay for their storage](#storage-cost) by locking part of their balance. Currently it costs **~1 ‚ìÉ** to store **100KB**
:::
---

## Data Structures
The NEAR SDK exposes a series of structures ([Vectors](#vector), [Sets](#set), [Maps](#map) and [Trees](#tree))
to simplify storing data in an efficient way.

:::info Instantiation

All structures need to be initialized using a **unique `prefix`**, which will be used to identify the structure's keys
in the [serialized state](./serialization.md#borsh-state-serialization)

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="index.js"
          url="https://github.com/near-examples/docs-examples/blob/main/storage-js/src/index.ts"
          start="8" end="11" />
  </Language>

  <Language value="rust" language="rust">
    <Github url="https://github.com/near-examples/docs-examples/blob/main/storage-rs/contract/src/lib.rs" fname="lib.rs" start="33" end="38"/>
  </Language>

</CodeTabs>

:::

<hr className="subsection" />

### Vector

Implements a [vector/array](https://en.wikipedia.org/wiki/Array_data_structure) which persists in the contract's storage. Please refer to the Rust and AS SDK's for a full reference on their interfaces.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="index.js"
          url="https://github.com/near-examples/docs-examples/blob/main/storage-js/src/index.ts"
          start="25" end="28" />

</Language>

<Language value="rust" language="rust">
    <Github fname="vector.rs"
          url="https://github.com/near-examples/docs-examples/blob/main/storage-rs/contract/src/vector.rs" start="12" end="30"/>
    <Github fname="lib.rs"
          url="https://github.com/near-examples/docs-examples/blob/main/storage-rs/contract/src/lib.rs" start="7" end="24"/>

</Language>

</CodeTabs>

<hr className="subsection" />

### Map

Implements a [map/dictionary](https://en.wikipedia.org/wiki/Associative_array) which persists in the contract's storage. Please refer to the Rust and AS SDK's for a full reference on their interfaces.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="index.js"
          url="https://github.com/near-examples/docs-examples/blob/main/storage-js/src/index.ts"
          start="33" end="37" />

</Language>

<Language value="rust" language="rust">
    <Github fname="map.rs"
          url="https://github.com/near-examples/docs-examples/blob/main/storage-rs/contract/src/map.rs" start="9" end="24"/>
    <Github fname="lib.rs"
          url="https://github.com/near-examples/docs-examples/blob/main/storage-rs/contract/src/lib.rs" start="7" end="24"/>

</Language>

</CodeTabs>

<details>
<summary>Nesting of Objects - Temporary Solution</summary>

In the JS SDK, you can store and retrieve elements from a nested map or object, but first you need to construct or deconstruct the structure from state. This is a temporary solution until the improvements have been implemented to the SDK. Here is an example of how to do this:

```ts 
import { NearBindgen, call, view, near, UnorderedMap } from "near-sdk-js";

@NearBindgen({})
class StatusMessage {
  records: UnorderedMap;
  constructor() {
    this.records = new UnorderedMap("a");
  }

  @call({})
  set_status({ message, prefix }: { message: string; prefix: string }) {
    let account_id = near.signerAccountId();

    const inner: any = this.records.get("b" + prefix);
    const inner_map: UnorderedMap = inner
      ? UnorderedMap.deserialize(inner)
      : new UnorderedMap("b" + prefix);

    inner_map.set(account_id, message);

    this.records.set("b" + prefix, inner_map);
  }

  @view({})
  get_status({ account_id, prefix }: { account_id: string; prefix: string }) {
    const inner: any = this.records.get("b" + prefix);
    const inner_map: UnorderedMap = inner
      ? UnorderedMap.deserialize(inner)
      : new UnorderedMap("b" + prefix);
    return inner_map.get(account_id);
  }
}
```

</details>

<hr className="subsection" />

### Set

Implements a [set](https://en.wikipedia.org/wiki/Set_(abstract_data_type)) which persists in the contract's storage. Please refer to the Rust and AS SDK's for a full reference on their interfaces.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="index.js"
          url="https://github.com/near-examples/docs-examples/blob/main/storage-js/src/index.ts"
          start="42" end="46" />

</Language>

<Language value="rust" language="rust">
    <Github fname="set.rs"
          url="https://github.com/near-examples/docs-examples/blob/main/storage-rs/contract/src/set.rs" start="9" end="16"/>
    <Github fname="lib.rs"
          url="https://github.com/near-examples/docs-examples/blob/main/storage-rs/contract/src/lib.rs" start="7" end="24"/>

</Language>

</CodeTabs>

<hr className="subsection" />

### Tree

An ordered equivalent of Map. The underlying implementation is based on an [AVL](https://en.wikipedia.org/wiki/AVL_tree). You should use this structure when you need to: have a consistent order, or access the min/max keys.

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="tree.rs"
          url="https://github.com/near-examples/docs-examples/blob/main/storage-rs/contract/src/tree.rs" start="9" end="24"/>
    <Github fname="lib.rs"
          url="https://github.com/near-examples/docs-examples/blob/main/storage-rs/contract/src/lib.rs" start="7" end="24"/>

</Language>

</CodeTabs>

---

## Storage Cost
Your contract needs to lock a portion of their balance proportional to the amount of data they stored in the blockchain. This means that:
- If more data is added and the **storage increases ‚Üë**, then your contract's **balance decreases ‚Üì**.
- If data is deleted and the **storage decreases ‚Üì**, then your contract's **balance increases ‚Üë**. 

Currently, it cost approximately **1 ‚ìÉ** to store **100kb** of data.

:::info
You can save on smart contract storage if using NEAR Account IDs by encoding them using base32. Since they consist of `[a-z.-_]` characters with a maximum length of 64 characters, they can be encoded using 5 bits per character, with terminal `\0`. Going to a size of 65 * 5 = 325 bits from the original (64 + 4) * 8 = 544 bits. This is a 40% reduction in storage costs.
:::

:::caution
An error will raise if your contract tries to increase its state while not having NEAR to cover for storage.
:::

:::warning
Be mindful of potential [small deposit attacks](../security/storage.md)
:::

'''
'''--- docs/2.build/2.smart-contracts/anatomy/crosscontract.md ---
---
id: crosscontract
title: Cross-Contract Calls
---

import {CodeTabs, Language, Github} from '@site/src/components/codetabs'

Cross-contract calls allow your contract to interact with other deployed contracts. This is useful for:

1. Querying information from another contract.
2. Executing a method in another contract.

#### Cross-Contract Calls are **Independent**
The method in which you make the call and the method in which you receive the result are different.

#### Cross-Contract Calls are **Asynchronous**
There is a delay between the call and the callback in which everyone can still interact with your contract.

---

## Snippet: Querying Information

While making your contract, it is likely that you will want to query information from another contract. Below, you can see a basic example in which we query the greeting message from our [Hello NEAR](../quickstart.md) example.

<CodeTabs>
<Language value="js" language="ts">
    <Github fname="contract.ts" 
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-ts/src/contract.ts"
            start="17" end="39" />

</Language>

<Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/lib.rs"
            start="22" end="51" />
            <Github fname="external.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/external.rs"
            start="2" end="12" />

</Language>

</CodeTabs>

---

## Snippet: Sending Information
Calling another contract passing information is also a common scenario. Bellow you can see a method that interacts with the [Hello NEAR](../quickstart.md) example to change its greeting message.

<CodeTabs>
<Language value="js" language="ts">
    <Github fname="contract.ts"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-ts/src/contract.ts"
            start="41" end="64" />

</Language>

<Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/lib.rs"
            start="53" end="80" />
    <Github fname="external.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/external.rs"
            start="2" end="12" />

</Language>

</CodeTabs>

---

## Promises
Cross-contract calls work by creating two promises in the network:
1. A promise to execute code in the external contract (`Promise.create`).
2. A promise to call back a **different** method in your contract with the result (`Promise.then`).

Both promises take the same arguments:

<CodeTabs>
  <Language value="js" language="ts">
    
```ts
NearPromise.new("external_address").functionCall("method", JSON.stringify(arguments), DEPOSIT, GAS);
```

</Language>

<Language value="rust" language="rust">

```rust
external_trait::ext("external_address")
.with_attached_deposit(DEPOSIT)
.with_static_gas(GAS)
.method(arguments);
```

</Language>

</CodeTabs>

   - The address of the contract you want to interact with
   - The method that you want to execute
   - The (**encoded**) arguments to pass to the method
   - The amount of GAS to use (deducted from the **attached Gas**)
   - The amount of NEAR to attach (deducted from **your contract‚Äôs balance**)

:::tip
Notice that the callback could be made to **any** contract. This means that, if you want, the result could be potentially handled by another contract.
:::

:::caution
The fact that you are creating a Promise means that both the cross-contract call and callback will **not execute immediately**. In fact:
- The cross-contract call will execute 1 or 2 blocks after your method finishes **correctly**.
- The callback will then execute 1 or 2 blocks after the **external** method finishes (**correctly or not**)
:::

---

## Callback Method
If your method finishes correctly, then eventually your callback method will execute. This will happen whether the external contract finishes **successfully or not**. We repeat, if your original method finishes correctly, then your callback will **always execute**.

In the callback method you will have access to the result, which contains two important arguments:
- `status`: Telling if the external method finished successfully or not
- `buffer`: Having the value returned by the external method (if any)

:::tip
The callback methods in your contract must be public, so it can be called when the second promise executes. However, they should be only callable by **your contract**. Always make sure to make it private by asserting that the `predecessor` is `current_account_id`. In rust this can be achieved using the `#[private]` decorator.
:::

### Checking Execution Status

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="contract.ts"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-ts/src/contract.ts"
            start="31" end="38" />

</Language>

<Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/lib.rs"
            start="67" end="74" />

</Language>

</CodeTabs>

### Successful Execution
In case the call finishes successfully, the resulting object will have a `status` of 1, and the `buffer` will have the encoded result (if any). In order to recover the result you need to decode it from the resulting `buffer`:

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="contract.ts"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-ts/src/contract.ts"
            start="31" end="31" />

</Language>

<Language value="rust" language="rust">
    <Github fname="lib.ts"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/lib.rs"
            start="47" end="49" />

</Language>

</CodeTabs>

### Failed Execution
If the external method fails (i.e. it panics), then your callback will be **executed anyway**. Here you need to **manually rollback** any changes made in your
contract during the original call. Particularly:

1. If the contract attached NEAR to the call, the funds are sent back to **the contract's account**.
2. If the original method made any state changes (i.e. changed or stored data), they **won't be automatically reverted**.

:::warning
If your original method finishes correctly then the callback executes **even if the external method panics**. Your state will **not** rollback automatically,
and $NEAR will **not** be returned to the signer automatically. Always make sure to check in the callback if the external method failed, and manually rollback any
operation if necessary.
:::

---

## Security Concerns

While writing cross-contract calls there is a significant aspect to keep in mind: all the calls are **independent** and **asynchronous**. In other words:

- The method in which you make the call and method for the callback are **independent**.
- There is a **delay between the call and the callback**, in which people can still interact with the contract

This has important implications on how you should handle the callbacks. Particularly:

1. Make sure you don't leave the contract in a exploitable state between the call and the callback.
2. Manually rollback any changes to the state in the callback if the external call failed.

We have a whole [security section](../security/callbacks.md) dedicated to these specific errors, so please go and check it.

:::warning
Not following these basic security guidelines could expose your contract to exploits. Please check the [security section](../security/callbacks.md), and if still in doubt, [join us in Discord](https://near.chat).
:::

'''
'''--- docs/2.build/2.smart-contracts/anatomy/environment.md ---
---
id: environment
title: Environment
#sidebar_label: üèûÔ∏è Environment
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Every method execution has an environment associated with information such as:

1. Who called the method
2. How much money is attached to the call
3. How many computational resources are available
4. The current timestamp
5. Helper functions for Public Key derivation, for example

---

## Environment Variables

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

| Variable Name          | SDK Variable                  | Description                                                                          |
| ---------------------- | ----------------------------- | ------------------------------------------------------------------------------------ |
| Predecessor            | `near.predecessorAccountId()` | Account ID that called this method                                                   |
| Current Account        | `near.currentAccountId()`     | Account ID of this smart contract                                                    |
| Signer                 | `near.signerAccountId()`      | Account ID that signed the transaction leading to this execution                     |
| Attached Deposit       | `near.attachedDeposit()`      | Amount in NEAR attached to the call by the predecessor                               |
| Account Balance        | `near.accountBalance()`       | Balance of this smart contract (including Attached Deposit)                          |
| Prepaid Gas            | `near.prepaidGas()`           | Amount of gas available for execution                                                |
| Timestamp              | `near.blockTimestamp()`       | Current timestamp (number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC) |
| Current Epoch          | `near.epochHeight()`          | Current epoch in the blockchain                                                      |
| Block Index            | `near.blockIndex()`           | Current block index (a.k.a. block height)                                            |
| Storage Used           | `near.storageUsage()`         | Current storage used by this smart contract                                          |
| Used Gas               | `near.usedGas()`              | Amount of gas used for execution                                                     |
| Signer Public Key      | `near.signerAccountPk()`      | Sender Public Key                                                                    |
| Account Locked Balance | `near.accountLockedBalance()` | Balance of this smart contract that is locked                                        |

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

| Variable Name          | SDK Variable                    | Description                                                                          |
|------------------------|---------------------------------|--------------------------------------------------------------------------------------|
| Predecessor            | `env::predecessor_account_id()` | Account ID that called this method                                                   |
| Current Account        | `env::current_account_id()`     | Account ID of this smart contract                                                    |
| Signer                 | `env::signer_account_id()`      | Account ID that signed the transaction leading to this execution                     |
| Attached Deposit       | `env::attached_deposit()`       | Amount in NEAR attached to the call by the predecessor                               |
| Account Balance        | `env::account_balance()`        | Balance of this smart contract (including Attached Deposit)                          |
| Prepaid Gas            | `env::prepaid_gas()`            | Amount of gas available for execution                                                |
| Timestamp              | `env::block_timestamp()`        | Current timestamp (number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC) |
| Current Epoch          | `env::epoch_height()`           | Current epoch in the blockchain                                                      |
| Block Index            | `env::block_index()`            | Current block index (a.k.a. block height)                                            |
| Storage Used           | `env::storage_usage()`          | Current storage used by this smart contract in bytes                                 |
| Storage Byte Cost      | `env::storage_byte_cost()`      | Current storage cost per byte in yoctoNEAR                                           |
| Used Gas               | `env::used_gas()`               | Amount of gas used for execution                                                     |
| Signer Public Key      | `env::signer_account_pk()`      | Sender Public Key                                                                    |
| Account Locked Balance | `env::account_locked_balance()` | Balance of this smart contract that is locked                                        |

</TabItem>

</Tabs>

---

## Who is Calling? Who am I?

The environment gives you access to 3 important users: the `current_account`, the `predecessor`, and the `signer`.

### Current Account

The `current_account` contains the address in which your contract is deployed. This is very useful to implement ownership, e.g. making a public method only callable by the contract itself.

### Predecessor and Signer

The `predecessor` is the account that called the method in the contract. Meanwhile, the `signer` is the account that _signed_ the initial transaction.

During a simple transaction (no [cross-contract calls](../anatomy/crosscontract.md)) the `predecessor` is the same as the `signer`. For example, if **alice.near** calls **contract.near**, from the contract's perspective, **alice.near** is both the `signer` and the `predecessor`. However, if **contract.near** creates a [cross-contract call](../anatomy/crosscontract.md), then the `predecessor` changes down the line. In the example below, when **pool.near** executes, it would see **contract.near** as the `predecessor` and **alice.near** as the `signer`.

![img](https://miro.medium.com/max/1400/1*LquSNOoRyXpITQF9ugsDpQ.png)
*You can access information about the users interacting with your smart contract*

:::tip
In most scenarios you will **only need to know the predecessor**. However, there are situations in which the signer is very useful. For example, when adding [NFTs](../../5.primitives/nft.md) into [this marketplace](https://github.com/near-examples/nft-tutorial/blob/7fb267b83899d1f65f1bceb71804430fab62c7a7/market-contract/src/nft_callbacks.rs#L42), the contract checks that the `signer`, i.e. the person who generated the transaction chain, is the NFT owner.
:::

---

## Balances and Attached NEAR
The environment gives you access to 3 token-related parameters, all expressed in yoctoNEAR (1 ‚ìÉ = 10<sup>24</sup>y‚ìÉ):

### Attached Deposit
`attached_deposit` represents the amount of yoctoNEAR the predecessor attached to the call. 

This amount is **already deposited** in your contract's account, and is **automatically returned** to the `predecessor` if your **method panics**.

:::warning
If you make a [cross-contract call](../anatomy/crosscontract.md) and it panics, the funds are sent back to **your contract**. See how to handle this situation in the [callback section](../anatomy/crosscontract.md#failed-execution)
:::

### Account Balance

`account_balance` represents the balance of your contract (`current_account`).

It includes the `attached_deposit`, since it was deposited when the method execution started.

If the contract has any locked $NEAR, it will appear in `account_locked_balance`.

---

### Storage Used

`storage_used` represents the amount of [storage](../anatomy/storage.md) that is currently being used by your contract.

:::tip
If you want to know how much storage a structure uses, print the storage before and after storing it.
:::

---

## Telling the Time

The environment exposes three different ways to tell the pass of time, each representing a different dimension of the underlying blockchain.

### Timestamp

The `timestamp` attribute represents the approximated **UNIX timestamp** at which this call was executed. It quantifies time passing in a human way, enabling to check if a specific date has passed or not.

### Current Epoch

The NEAR blockchain groups blocks in [Epochs](../../../1.concepts/basics/epoch.md). The `current_epoch` attribute measures how many epochs have passed so far. It is very useful to coordinate with other contracts that measure time in epochs, such as the [validators](../../../1.concepts/basics/validators.md).

### Block Index

The `block_index` represents the index of the block in which this transaction will be added to the blockchain.

---

## Gas

Your contract has a **limited number of computational resources** to use on each call. Such resources are measured in [Gas](/concepts/protocol/gas).

Gas can be thought of as wall time, where 1 PetaGas (1_000 TGas) is ~1 second of compute time.

Each code instruction costs a certain amount of Gas, and if you run out of it, the execution halts with the error message `Exceeded the prepaid gas`.

The environment gives you access to two gas-related arguments: `prepaid_gas` and `used_gas`.

### Prepaid Gas
`prepaid_gas` represents the amount of Gas the `predecessor` attached to this call. It cannot exceed the limit 300TGas (300 * 10<sup>12</sup> Gas).

### Used Gas
`used_gas` contains the amount of Gas that has been used so far. It is useful to estimate the Gas cost of running a method.

:::warning
During [cross-contract calls](./crosscontract.md) always make sure the callback has enough Gas to fully execute.
:::

:::tip

If you already [estimated the Gas](../../../1.concepts/protocol/gas.md#estimating-costs-for-a-call) a method needs, you can ensure it never runs out of Gas by using `assert`

<Tabs className="language-tabs" groupId="code-tabs">
<TabItem value="rust" label="ü¶Ä Rust">

```rust
const REQUIRED_GAS: Gas = Gas(20_000_000_000_000); // 20 TGas
assert!(env::prepaid_gas() >= REQUIRED_GAS, "Please attach at least 20 TGas");
```

</TabItem>

</Tabs>

:::

---

## Environment Functions

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

| Function Name         | SDK method                                       | Description                                                                                                                                                                                                                                                                                                                      |
|-----------------------|--------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SHA 256               | `near.sha256(value)`                             | Hashes a sequence of bytes using sha256.                                                                                                                                                                                                                                                                                         |
| Keccak 256            | `near.keccak256(value)`                          | Hashes a sequence of bytes using keccak256.                                                                                                                                                                                                                                                                                      |
| Keccak 512            | `near.keccak512(value)`                          | Hashes a sequence of bytes using keccak512.                                                                                                                                                                                                                                                                                      |
| RIPEMD 160            | `near.ripemd160(value)`                          | Hashes the bytes using the RIPEMD-160 hash function.                                                                                                                                                                                                                                                                             |
| EC Recover            | `near.ecrecover(hash, sig, v, malleabilityFlag)` | Recovers an ECDSA signer address from a 32-byte message `hash` and a corresponding `signature` along with `v` recovery byte. Takes in an additional flag to check for malleability of the signature which is generally only ideal for transactions. Returns 64 bytes representing the public key if the recovery was successful. |
| Log String            | `near.log(msg)`                                  | Logs the string message. This message is stored on chain.                                                                                                                                                                                                                                                                        |
| Validator Stake       | `near.validatorStake(accountId)`                 | For a given account return its current stake. If the account is not a validator, returns 0.                                                                                                                                                                                                                                      |
| Validator Total Stake | `near.validatorTotalStake()`                     | Returns the total stake of validators in the current epoch.                                                                                                                                                                                                                                                                      |

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

| Function Name         | SDK method                                              | Description                                                                                                                                                                                                                                                                                                                      |
|-----------------------|---------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SHA 256               | `env::sha256(value)`                                    | Hashes a sequence of bytes using sha256.                                                                                                                                                                                                                                                                                         |
| Keccak 256            | `env::keccak256(value)`                                 | Hashes a sequence of bytes using keccak256.                                                                                                                                                                                                                                                                                      |
| Keccak 512            | `env::keccak512(value)`                                 | Hashes a sequence of bytes using keccak512.                                                                                                                                                                                                                                                                                      |
| SHA 256 (Array)       | `env::sha256_array(value)`                              | Hashes the bytes using the SHA-256 hash function. This returns a 32 byte hash.                                                                                                                                                                                                                                                   |
| Keccak 256 (Array)    | `env::keccak256_array(value)`                           | Hashes the bytes using the Keccak-256 hash function. This returns a 32 byte hash.                                                                                                                                                                                                                                                |
| Keccak 512 (Array)    | `env::keccak512_array(value)`                           | Hashes the bytes using the Keccak-512 hash function. This returns a 64 byte hash.                                                                                                                                                                                                                                                |
| RIPEMD 160 (Array)    | `env::ripemd160_array(value)`                           | Hashes the bytes using the RIPEMD-160 hash function. This returns a 20 byte hash.                                                                                                                                                                                                                                                |
| EC Recover            | `env::ecrecover(hash, signature, v, malleability_flag)` | Recovers an ECDSA signer address from a 32-byte message `hash` and a corresponding `signature` along with `v` recovery byte. Takes in an additional flag to check for malleability of the signature which is generally only ideal for transactions. Returns 64 bytes representing the public key if the recovery was successful. |
| Panic String          | `env::panic_str(message)`                               | Terminates the execution of the program with the UTF-8 encoded message.                                                                                                                                                                                                                                                          |
| Log String            | `env::log_str(message)`                                 | Logs the string message. This message is stored on chain.                                                                                                                                                                                                                                                                        |
| Validator Stake       | `env::validator_stake(account_id)`                      | For a given account return its current stake. If the account is not a validator, returns 0.                                                                                                                                                                                                                                      |
| Validator Total Stake | `env::validator_total_stake()`                          | Returns the total stake of validators in the current epoch.                                                                                                                                                                                                                                                                      |

</TabItem>

</Tabs>

:::info 
In the JS SDK, `throw new Error("message")` mimics the behavior of Rust's `env::panic_str("message")`.
:::

---

'''
'''--- docs/2.build/2.smart-contracts/anatomy/functions.md ---
---
id: functions
title: External Interface
hide_table_of_contents: true
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"
import CodeBlock from '@theme/CodeBlock'
import {ExplainCode, Block, File} from '@site/src/components/CodeExplainer/code-explainer';

Smart contracts expose functions so users can interact with them. There are different types of functions including `read-only`, `private` and `payable`.

<ExplainCode languages={["js", "rust"]}>

<Block highlights={{"js": "14-17,20-39,42-44,47-49", "rust": "22-30,33-58,60-62,64-66"}} fname="auction">

### Contract's Interface

All public functions in the contract are part of its interface. They can be called by anyone, and are the only way to interact with the contract

</Block>

<Block highlights={{"js":"13-17", "rust": "22-30"}} fname="auction">
### Initialization Functions
A contract can opt to have an initialization function. If present, this function must be called before any other to [initialize the contract](./storage.md)
</Block>

<Block highlights={{"js": "13"}} fname="auction">
#### `@initialize({ privateFunction: true })`
The initialization function is marked with the `@initialize` decorator
</Block>

<Block highlights={{"rust": "20"}} fname="auction">
#### `#[init]`
Read-only functions are those that take an **immutable** reference to `self` in Rust
</Block>

<Block highlights={{"js":"14-17", "rust": "33-58"}} fname="auction">
### State Changing Functions
The functions that modify the [state](./storage.md) or perform [actions](./actions.md) need to be called by a user with a NEAR account, since a transaction is required to execute them
</Block>

<Block highlights={{"js": "19"}} fname="auction">
#### `@call`
State changing functions are marked with the `@call` decorator
</Block>

<Block highlights={{"rust": "33"}} fname="auction">
#### `mut &self`
State changing functions are those that take a **mutable** reference to `self` in Rust
</Block>

<Block highlights={{"js": "22,26", "rust": "36,42"}} fname="auction">
**Note:** The SDK provides [contextual information](./environment.md), such as which account is calling the function, or what time it is
</Block>

<Block highlights={{"js":"42-44,47-49", "rust": "60-62,64-66"}} fname="auction">
### Read-Only Functions
Contract's functions can be read-only, meaning they don't modify the state. Calling them is free for everyone, and does not require to have a NEAR account
</Block>

<Block highlights={{"js": "41,46"}} fname="auction">
#### `@view`
Read-only functions are marked with the `@view` decorator in TS/JS
</Block>

<Block highlights={{"rust": "60,64"}} fname="auction">
#### `&self`
Read-only functions are those that take an **immutable** reference to `self` in Rust
</Block>

<Block highlights={{"js":"13", "rust": "21"}} fname="auction">
### Private Functions
Many times you will want to have functions that **are exposed** as part of the contract's interface, but **should not be called directly** by users

Besides initialization functions, [callbacks from cross-contract calls](./crosscontract.md) should always be `private`

These functions are marked as `private` in the contract's code, and can only be called by the contract itself
</Block>

<Block highlights={{"js": "13"}} fname="auction">
#### `decorator({privateFunction: true})`
Private functions are marked by setting `privateFunction: true` in the `@call` or `@initialization` decorators
</Block>

<Block highlights={{"rust": "21"}} fname="auction">
#### [#private]
Private functions are marked using the `#[private]` macro in Rust
</Block>

<Block highlights={{"js":"19,25", "rust": "32,41"}} fname="auction">
### Payable Functions
By default, functions will panic if the user attaches NEAR Tokens to the call. Functions that accept NEAR Tokens must be marked as `payable`

Within the function, the user will have access to the [attached deposit](./environment.md)
</Block>

<Block highlights={{"js": "19,25"}} fname="auction">
#### `@call({payableFunction: true})`
Payable functions are marked by setting `payableFunction: true` in the `@call` decorator
</Block>

<Block highlights={{"rust": "32,41"}} fname="auction">
#### [#payable]
Payable functions are marked using the `#[payable]` macro in Rust
</Block>

<Block highlights={{"js":"3-5"}} fname="example">
### Internal Functions
All the functions we covered so far are part of the interface, meaning they can be called by an external actor

However, contracts can also have private internal functions - such as helper or utility functions - that are **not exposed** to the outside world

To create internal private methods in a JS contract, simply omit the `@view` and `@call` decorators
</Block>

<Block highlights={{"rust": "5-7"}} fname="example">
### Internal Functions
All the functions we covered so far are part of the interface, meaning they can be called by an external actor

However, contracts can also have private internal functions - such as helper or utility functions - that are **not exposed** to the outside world

To create internal private methods in a Rust contract, do not declare them as public (`pub fn`)
</Block>

<Block highlights={{"rust": "9-11,13-15"}} fname="example">
### Pure Functions
Pure functions are a special kind of function that do not require to access data from the state

They are useful to return hardcoded values on the contract
</Block>

<File language="js" fname="auction" url="https://github.com/near-examples/auction-examples/blob/main/contract-ts/src/contract.ts" start="2" end="51" />

<File language="rust" fname="auction" url="https://github.com/near-examples/auction-examples/blob/main/contract-rs/src/lib.rs" start="2" end="68" />

<CodeBlock language="js" fname="example">

```js
@NearBindgen({})
class Contract {
  helper_function(params... ){
    // this function cannot be called from the outside
  }

  @view({})
  interface_view(params...){
    // this function can be called from outside
  }

  @call({privateFunction: true}){
    // this function can be called from outside, but
    // only by the contract's account
  }
}
```

</CodeBlock>

<CodeBlock language="rust" fname="example">

```rs
const SOME_VALUE: u64 = 8;

#[near]
impl MyContractStructure {
  fn internal_helper(mut &self, params... ){
    // this function cannot be called from the outside
  }

  pub fn public_log(/* Parameters here */) {
      near_sdk::log!("inside log message");
  }

  pub fn return_static_u64() -> u64 {
      SOME_VALUE
  }
}
```

</CodeBlock>

</ExplainCode>

'''
'''--- docs/2.build/2.smart-contracts/anatomy/serialization.md ---
---
id: serialization
title: Notes on Serialization
---

Smart contracts need to be able to **communicate complex data** in a simple way, while
also **reading and storing** such data into their states efficiently.

To achieve such simple communication and efficient storage, smart contracts morph the data
from their complex representation into simpler ones.

This process of translating **complex objects into simpler single-value** representations is called
**serialization**. NEAR uses two serialization formats: [JSON](https://www.json.org/json-en.html) and
[Borsh](https://borsh.io/).
1. [JSON](https://www.json.org/json-en.html) is used to serialize the contract's input/output during a function call
2. [Borsh](https://borsh.io/) is used to serialize the contract's state.

---

## Overview of Serialization Formats

Lets give a quick overview of both serialization formats, including their pros and cons, as well as
an example on how their serializations look like.

<hr className="subsection" />

### [JSON](https://www.json.org/json-en.html): Objects to Strings

#### Features
 - Self-describing format
 - Easy interoperability with JavaScript
 - Multiple implementations readily available
 - But... it is not efficient both in computational times and resulting size

#### Example
```js
Example{
  number: i32 = 2;
  arr: Vector<i32> = [0, 1];
}

// serializes to
"{\"number\": 2, \"arr\": [0, 1]}"
```

<hr className="subsection" />

### [Borsh](https://borsh.io/): Objects to Bytes

#### Features
  - Compact, binary format built to be efficiently (de)serialized
  - Strict and canonical binary representation
  - Less overhead: it does not need to store attributes names
  - But... it is necessary to know the schema to (de)serialize the data

#### Example
```js
Example{
  number: i32 = 2;
  arr: Vector<i32> = [0, 1];
}

// serializes into
[2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]
```
---

## Serializing Input & Output
NEAR contracts can implement methods that both take and return complex objects.
In order to handle this data in a simple way, JSON serialization is used.

Using JSON makes it easier for everyone to talk with the contracts, since most
languages readily implement a JSON (de)serializer.

#### Example
Let's look at this example, written only for educational purposes:

```rust
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct A {
  pub a_number: i32,
  pub b_number: u128
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct B {
  pub success: bool,
  pub other_number: i32
}

pub fn method(&self, struct_a: A): B {
  return B{true, 0}
}
```

#### Receiving Data
When a user calls the `method`, the contract receives the arguments encoded as a JSON string
(e.g. `"{\"a_number\":0, \"b_number\":\"100\"}"`), and proceed to (de)serialize them into
the correct object (`A{0, 100}`) .

#### Returning Data
When returning the result, the contract will automatically encode the object `B{true, 0}`
into its JSON serialized value: `"{\"success\":true, \"other_number\":0}"` and return this
string.

:::caution JSON Limitations
Since JSON is limited to `52 bytes` numbers, you cannot use `u64`/`u128` as input
or output. JSON simply cannot serialize them. Instead, you must use `Strings`.

The `NEAR SDK RS` currently implements the `near_sdk::json_types::{U64, I64, U128, I128}`
that you can use for input / output of data.
:::

---

## Borsh: State Serialization

Under the hood smart contracts store data using simple **key/value pairs**. This means that
the contract needs to translate complex states into simple key-value pairs.

For this, NEAR contracts use [borsh](https://borsh.io) which is optimized for (de)serializing
complex objects into smaller streams of bytes.

:::tip SDK-JS still uses json
The JavaScript SDK uses JSON to serialize objects in the state, but the borsh implementation
should arrive soon
:::

#### Example
Let's look at this example, written only for educational purposes:

```rust
#[near(serializers = [json, borsh])]
#[derive(PanicOnDefault)]
pub struct Contract {
  string: String,
  vector: Vector<u8>
}

#[near]
impl Contract {
  #[init]
  pub fn init(string: String, first_u8: u8) -> Self {
    let mut vector: Vector<u8> = Vector::new("prefix".as_bytes());
    vector.push(&first_u8);

    Self { string, vector }
  }

  pub fn change_state(&mut self, string: String, number: u8) {
    self.string = string;
    self.vector.push(&number);
  }
}
```

#### Empty State On Deploy
If we deploy the contract into a new account and immediately ask for the state we will see
it is empty:

```bash
near view-state $CONTRACT --finality optimistic

# Result is: []
```

#### Initializing the State
If we initialize the state we can see how Borsh is used to serialize the state

```bash
# initialize with the string "hi" and 0
near call $CONTRACT init '{"string":"hi", "first_u8":0}' --accountId $CONTRACT

# check the state
near view-state $CONTRACT --utf8 --finality optimistic

# Result is:
# [
#   {
#     key: 'STATE',
#     value: '\x02\x00\x00\x00hi\x01\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00prefix'
#   },
#   { key: 'prefix\x00\x00\x00\x00\x00\x00\x00\x00', value: '\x00' }
# ]
```

The first key-value is:

```js
key: 'STATE'
value: '\x02\x00\x00\x00hi\x01\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00prefix'
```

Since the `Contract` has a structure `string, Vector<u8>` the value is interpreted as:

```bash
[2, 0, 0, 0, "h", "i"] -> The `string` has 2 elements: "h" and "i".
[1, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, "prefix"] -> The Vector has 1 element, and to see the values search for keys that start with (the 6 bytes prefix): "prefix"
```

Then, the second key-value shows the entries of the `Vector` denoted by the `"prefix"` string:

```js
key: 'prefix\x00\x00\x00\x00\x00\x00\x00\x00'
value: '\x00'
```

#### Modifying the State
If we modify the stored string and add a new number, the state changes accordingly:

```bash
near call $CONTRACT change_state '{"string":"bye", "number":1}' --accountId $CONTRACT

# Result is
# [
#   {
#     key: 'STATE',
#     value: '\x03\x00\x00\x00bye\x02\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00prefix'
#   },
#   { key: 'prefix\x00\x00\x00\x00\x00\x00\x00\x00', value: '\x00' },
#   { key: 'prefix\x01\x00\x00\x00\x00\x00\x00\x00', value: '\x01' }
# ]
```

We can see that the `STATE` key changes to reflect the storage of the new string (`bye`), and that
the vector now has 2 elements.

At the same time, a new key-value was added adding the new vector entry: the `1u8` we just added.

<hr className="subsection" />

<!-- We should see where to move/replicate this -->

### Deserialization Error
When somebody invokes a smart contract method, the first step for the contract is to deserialize
its own state.

In the example used above, the contract will start by reading the `STATE` key and
try to deserialize its value into an object `Contract{string: String, vector: Vector<u8>}`.

If you deploy a contract into the account with a different Contract structure, then the
contract will fail to deserialize the `STATE` key and panic `Cannot deserialize the contract state`.

To solve this, you can either:
1. Rollback to the previous contract code
2. Implement a method to [migrate the contract's state](../release/upgrade.md)

'''
'''--- docs/2.build/2.smart-contracts/anatomy/storage.md ---
---
id: storage
title: State
sidebar_label: State (Storage)
hide_table_of_contents: true
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

import {ExplainCode, Block, File} from '@site/src/components/CodeExplainer/code-explainer';

NEAR accounts store data for their contracts. The storage starts **empty** until a contract is deployed and the state is initialized. The contract's code and state are independent: updating the code does not erase the state.

<ExplainCode languages={["js", "rust"]} >
  <Block highlights={{"js": "3-6,10-11"}} fname="auction">
    ### Defining the State
    The attributes of the `class` marked as the contract define the data that will be stored
    
    The contract can store all native types (e.g. `number`, `string`, `Array`, `Map`) as well as complex objects

    For example, our Auction contract stores when the auction ends, and an object representing the highest bid

    **Note:** The SDK also provides [collections](./collections.md) to efficiently store collections of data
  </Block>
  <Block highlights={{"rust": "6-9,14,15"}} fname="auction">
    ### Defining the State
    The attributes of the `struct` marked as the contract define the data that will be stored

    The contract can store all native types (e.g. `u8`, `string`, `HashMap`, `Vector`) as well as complex objects
    
    For example, our Auction contract stores when the auction ends, and an object representing the highest bid

    **Note:** The structures that will be saved need a special macro, that tells the SDK to store them [serialized in Borsh](./serialization.md)

    **Note:** The SDK also provides [collections](./collections.md) to efficiently store collections of data
  </Block>
  <Block highlights={{"rust": "4"}} fname="auction">
    #### [*] Note
    The `structs` that will be persisted need to be marked with a macro, so the SDK knows to [serialize them in Borsh](./serialization.md) before writing them to the state
  </Block>

  <Block highlights={{"js":"", "rust": ""}} fname="auction">
    #### [!] Important
    Contracts pay for their storage by locking part of their balance
    
    It currently costs ~**1‚ìÉ** to store **100KB** of data
  </Block>
  <Block highlights={{"js": "", "rust": ""}} fname="auction" >
    ### Initializing the State
    After the contract is deployed, its state is empty and needs to be initialized with
    some initial values

    There are two ways to initialize a state:
      1. By creating an initilization function
      2. By setting default values
  </Block>
    <Block highlights={{"js": "8,13-17"}} fname="auction">
    ### I. Initialization Functions
    An option to initialize the state is to create an `initialization` function, which needs to be called before executing any other function

    In our Auction example, the contract has an initialization function that sets when the auction ends. Note the `@initialization` decorator, and the forced initialization on `NearBindgen`
    
    **Note:** It is a good practice to mark initialization functions as private. We will cover function types in the [functions section](./functions.md)
  </Block>
  <Block highlights={{"js": "10-11"}} fname="auction">
    #### [!] Important
    In TS/JS you still **must** set default values for the attributes, so the SDK can infer their types
  </Block>
  <Block highlights={{"rust": "12,22-30"}} fname="auction">
    ### I. Initialization Functions
    An option to initialize the state is to create an `initialization` function, which needs to be called before executing any other function

    In our Auction example, the contract has an initialization function that sets when the auction ends. The contract derives the `PanicOnDefault`, which forces the user to call the init method denoted by the `#[init]` macro
    
    **Note:** It is a good practice to mark initialization functions as private. We will cover function types in the [functions section](./functions.md)
  </Block>

  <Block highlights={{"js": "5"}} fname="hello">
    ### II. Default State
    Another option to initialize the state is to set default values for the attributes of the class

    Such is the case for our "Hello World" contract, which stores a `greeting` with the default value `"Hello"`

    The first time the contract is called (somebody executes `get_greeting` or `set_greeting`), the default values will be stored in the state, and the state will be considered initialized

    **Note:** The state can only be initialized once
  </Block>
  <Block highlights={{"rust": "10-16"}} fname="hello">
    ### II. Default State
    Another option to initialize the state is to create a `Default` version of our contract's `struct`.
    
    For example, our "Hello World" contract has a default state with a `greeting` set to `"Hello"`

    The first time the contract executes, the `Default` will be stored in the state, and the state will be considered initialized

    **Note:** The state can only be initialized once
  </Block>
  <Block highlights={{"js": "", "rust":""}} fname="hello">
    ### Lifecycle of the State
    When a function is called, the contract's state is loaded from the storage and put into memory

    The state is actually [stored serialized](./serialization.md), and the SDK takes a bit of time to deserialize it before the method can access it

    When the method finishes executing successfully, all the changes to the state are serialized, and saved back to the storage
  </Block>
  <Block highlights={{"js": "", "rust":""}} fname="hello">
    ### State and Code
    In NEAR, the contract's code and contract's storage are **independent**
    
    Updating the code of a contract does **not erase** the state, and can indeed lead to unexpected behavior or errors

    Make sure to read the [updating a contract](../release/upgrade.md) if you ran into issues
  </Block>

  <File
    language="js"
    fname="auction" 
    url="https://github.com/near-examples/auction-examples/blob/main/contract-ts/src/contract.ts"
    start="2"
    end="51"
  />
  <File
    language="js"
    fname="hello" 
    url="https://github.com/near-examples/hello-near-examples/blob/main/contract-ts/src/contract.ts"
    start="2"
    end="18"
  />
  <File
    language="rust"
    fname="auction"
    url="https://github.com/near-examples/auction-examples/blob/main/contract-rs/src/lib.rs"
    start="2"
    end="68"
  />
  <File
    language="rust"
    fname="hello" 
    url="https://github.com/near-examples/hello-near-examples/blob/main/contract-rs/src/lib.rs"
    start="2"
    end="32"
  />
</ExplainCode>
'''
'''--- docs/2.build/2.smart-contracts/anatomy/types.md ---
---
id: types
title: SDK Types
hide_table_of_contents: true
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"
import CodeBlock from '@theme/CodeBlock'

import {ExplainCode, Block, File} from '@site/src/components/CodeExplainer/code-explainer';

Lets discuss which types smart contracts use to input and output data, as well as how such data is stored and handled in the contract's code.

<ExplainCode languages={["js", "rust"]}>
  <Block highlights={{"js":"5,8,13"}} fname="hello-near">
    ### Native Types
    Smart contracts can receive, store and return data using JS native types:
    - `string`
    - `number`
    - `boolean`
    - `Array`
    - `Map`
    - `Object`
    - `BigInt`
  </Block>
  <Block highlights={{"rust":"6,13,22,27"}} fname="hello-near">
    ### Native Types
    Smart contracts can receive, store and return data using the following Rust types:
    - `string`
    - `i8-i32/u8-u32`
    - **`u64/128`**: It is preferable to use SDK types `U64` and `U128`
    - `bool`
    - `HashMap`
    - `Vector`
  </Block>
  <Block highlights={{"rust": "1,15,22,64"}} fname="auction">
    #### `U64/U128`
    Smart contracts can store `u64` and `u128`, but these types need to be converted to `string` for input/output

    To simplify development, the SDK provides the `U64` and `U128` types which are automatically casted to `u64/u128` when stored, and to `string` when used as input/output
  </Block>
  <Block highlights={{"js":"3-6", "rust": "6-9"}} fname="auction">
    ### Complex Objects
    Smart contracts can store and return complex objects

    **Note:** Objects will always be received and returned as JSON 
  </Block>
  <Block highlights={{"rust": "4"}} fname="auction">
    #### Serializers
    Objects that will be used as input or output need to be serializable to JSON, add the `#[near(serializer=json)]` macro

    Objects that will be stored in the contract's state need to be serializable to Borsh, add the `#[near(serializer=borsh)]` macro
  </Block>
  <Block highlights={{"js": "5,11,47"}} fname="auction">
    ### Handling Tokens
    `$NEAR` tokens are represented using `BigInt` in JS, and they are always represented in `yoctonear`

    **Note:** 1 NEAR = 10^24 yoctoNEAR
  </Block>
  <Block highlights={{"rust": ""}} fname="auction">
    ### Handling Tokens
    `$NEAR` tokens are handled through the `NearToken` struct, which exposes methods to represent the value in `yoctonear`, `milinear` and `near`

    **Note:** 1 NEAR = 10^24 yoctonear
  </Block>
  <Block highlights={{"js": "4", "rust": "7"}} fname="auction">
    ### Account
    The SDK exposes a special type to handle NEAR Accounts, which automatically checks if the account address is valid
  </Block>

  <File
    language="js"
    fname="hello-near" 
    url="https://github.com/near-examples/hello-near-examples/blob/main/contract-ts/src/contract.ts"
    start="2"
    end="18"
  />
  <File
    language="rust"
    fname="hello-near" 
    url="https://github.com/near-examples/hello-near-examples/blob/main/contract-rs/src/lib.rs"
    start="2"
    end="32"
  />
  <File
    language="js"
    fname="auction" 
    url="https://github.com/near-examples/auction-examples/blob/main/contract-ts/src/contract.ts"
    start="2"
    end="51"
  />
  <File
    language="rust"
    fname="auction"
    url="https://github.com/near-examples/auction-examples/blob/main/contract-rs/src/lib.rs"
    start="2"
    end="68"
  />
</ExplainCode>
'''
'''--- docs/2.build/2.smart-contracts/quickstart.md ---
---
id: quickstart
title: Hello Contract
sidebar_label: Quickstart ‚ú®
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

[NEAR accounts](../../1.concepts/protocol/account-model.md) can host programs known as smart contracts. Smart contracts can **store data**, and **expose methods** so other users and contracts interact with them. 

In this quickstart tutorial, we will guide you in creating your first smart contract in the NEAR **testnet** that stores and retrieves a greeting.

---

## Prerequisites

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

Before starting, make sure you have the following installed:

1. [Node.js](https://nodejs.org/en/download), to use our scaffolding tool.
2. [NEAR CLI](/tools/near-cli#installation), to deploy and interact with the contract.

:::tip Easy Install

- **NEAR-CLI:** Install `near-cli` tools using

  ```
  npm i -g near-cli
  ```

:::

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

Before starting, make sure you have the following installed:

1. [NEAR CLI-RS](/tools/near-cli-rs), to deploy and interact with the contract.
2. [cargo-near](https://github.com/near/cargo-near), to easily create testnet accounts.
3. [Rust](https://www.Rust-lang.org/tools/install), to create Rust contracts.
4. [Node.js](https://nodejs.org/en/download)(Optional), to install the tools.

:::tip Easy Install

- **NEAR-CLI-RS:** Install both `near-cli-rs` and `cargo-near` tools using

```bash
# Using node
npm i -g near-cli-rs cargo-near

# Using macOS, Linux, WSL
curl --proto '=https' --tlsv1.2 -LsSf https://github.com/near/near-cli-rs/releases/latest/download/near-cli-rs-installer.sh | sh
curl --proto '=https' --tlsv1.2 -LsSf https://github.com/near/cargo-near/releases/latest/download/cargo-near-installer.sh | sh
```

:::

</TabItem>

</Tabs>

:::info Testnet Account

There is no need to have a `testnet` account to follow this tutorial.

However, if you want to create one, you can do so through [a wallet](https://testnet.mynearwallet.com), and use it from the `near-cli` by invoking `near login`.

:::

---

## Creating the Contract

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

Create a smart contract by running our `create-near-app` scaffolding tool and following the interactive menu.

- What do you want to build? ‚Ä∫ `A Near Smart Contract`
- Select a smart contract template for your project ‚Ä∫ `JS/TS Contract`
- Name your project ‚Ä∫ `hello-near`

```bash
  npx create-near-app@latest
```

![img](@site/static/docs/hello-near-ts.gif)
_create-near-app in action_

The resulting folder structure will change slightly depending on the chosen language. Here is the general structure you can expect to see:

```bash
‚îú‚îÄ‚îÄ sandbox-ts      # sanbox testing
‚îÇ   ‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ  ‚îî‚îÄ‚îÄ main.ava.ts
‚îÇ   ‚îú‚îÄ‚îÄ ava.config.cjs
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îî‚îÄ‚îÄ contract.ts # contract's code
‚îú‚îÄ‚îÄ package.json    # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ tsconfig.json
```

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

Create a smart contract by running our `near` Rust CLI tool and following the interactive menu.

```bash
  cargo near new <project_name>
```

![img](@site/static/docs/hello-near-rs.gif)
_create-near-app in action_

The resulting folder structure will change slightly depending on the chosen language. Here is the general structure you can expect to see:

```bash
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îî‚îÄ‚îÄ lib.rs # contract's code
‚îú‚îÄ‚îÄ test 
‚îÇ   ‚îî‚îÄ‚îÄ test_basics.rs # testing code
‚îú‚îÄ‚îÄ Cargo.toml # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ rust-toolchain.toml
```

</TabItem>

</Tabs>

---

## The Contract

Your new smart contract stores a `greeting: string` attribute in their state, and exposes two methods to interact with it (`set_greeting`, `get_greeting`).

<CodeTabs>
<Language value="js" language="js">
    <Github fname="index.js"
            url="https://github.com/near-examples/hello-near-examples/blob/main/contract-ts/src/contract.ts"
            start="4" end="18" />

</Language>

<Language value="rs" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/hello-near-examples/blob/main/contract-rs/src/lib.rs"
            start="4" end="32" />

</Language>

</CodeTabs>

There are 3 important things to notice:

1. The `get_greeting` method is a [`view`](./anatomy/anatomy.md#public-methods) method, meaning it only reads from the contract and can be called for free by anyone.
2. By default, the contract is initialized with the `greeting` attribute set to `"Hello"`.
3. The `set_greeting` method is a [`change`](./anatomy/anatomy.md#public-methods) method, meaning it modifies the contract's state and requires a user to sign a transaction in order to be executed.

## Build and Test

Building and testing the contract is as simple as running two commands.

<CodeTabs>
<Language value="js" language="js">

```bash
npm run build
npm run test

# Expected:
# returns the default greeting ‚úÖ
# changes the greeting ‚úÖ
````

</Language>

<Language value="rust" language="rust">

```bash
cargo build
cargo test

# Expected:
# Passed ‚úÖ gets default greeting
# Passed ‚úÖ changes the greeting
```

</Language>

</CodeTabs>

<details>
<summary> Failing tests? </summary>

If the tests are failing, make sure that you are using `node v16` and the `toolchain v1.69` in `rust`. You can always use

- `nvm use 16` to switch to `node v16`
- `rustup default 1.68` to switch to `toolchain v1.69`

</details>

In the background, these commands are calling the build tools for each language and invoking the [Sandbox](./testing/integration-test.md) tests from the `sandbox-ts/rs` directory.

:::tip Sandbox
Testing the contracts within a Sandbox allows you to understand how the contract will behave once deployed to the network while having total control over the testing environment.
:::

---

## Create a Testnet Account

Now that we know the contract is passing the tests, let's create a testnet account in which to deploy the contract.

While there are different ways to create accounts in NEAR, in this quickstart we will use the `cargo-near` tool to create a new random [`named account`](/concepts/protocol/account-id).

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```bash
# Create a new testnet account
# Replace <created-account> with a custom name
near create-account <created-account> --useFaucet
```

<details>
<summary> Example Result </summary>

```bash
> near create-account lovely-event.testnet --useFaucet
# Console response
New account "lovely-event.testnet" created successfully. # Response
```

</details>

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

```bash
# Create a new testnet account with a random name
cargo-near near create-dev-account use-random-account-id autogenerate-new-keypair save-to-legacy-keychain network-config testnet create

# Create a new testnet account
# Replace <lovely-event.testnet> with a custom name
cargo-near near create-dev-account use-specific-account-id lovely-event.testnet autogenerate-new-keypair save-to-keychain network-config testnet create
````

<details>
<summary> Example Result </summary>

```bash
# If you want to create account with a random name
> cargo-near near create-dev-account use-random-account-id autogenerate-new-keypair save-to-legacy-keychain network-config testnet create

New account "lovely-event.testnet" created successfully. # Response

# If you want to create account with a custom name
> cargo-near near create-dev-account use-specific-account-id lovely-event.testnet autogenerate-new-keypair save-to-keychain network-config testnet create

New account "lovely-event.testnet" created successfully. # Response
```

</details>

</TabItem>

</Tabs>

:::tip

Here we are creating a random account since we do not care about the account's name. Remember that you can create a named account through any wallet (i.e. [MyNearWallet](https://testnet.mynearwallet.com)) and then use it from the `near-cli` by invoking `near login`.

:::

---

## Deploy the Contract

Having our account created, we can now deploy the contract into it:

<Tabs>

<TabItem value="near-cli">
  ```bash
  near deploy <created-account> build/release/hello.wasm
  ```

</TabItem>

<TabItem value="near-cli-rs">
  ```bash
  near contract deploy <created-account> use-file ./target/wasm32-unknown-unknown/release/contract_rs.wasm without-init-call network-config testnet sign-with-keychain send
  ```

</TabItem>

</Tabs>

**Congrats**! your contract now lives in the NEAR testnet network.

---

## Interacting with the Contract

To interact with your deployed smart contract, you can call its methods using the `near-cli` or `near-cli-rs` tools.

### Get Greeting

The `get_greeting` method is a [`view`](./anatomy/anatomy.md#public-methods) method, meaning it only reads from the contract's state, and can thus be called for **free**.

<Tabs>

<TabItem value="near-cli">

```bash
> near view <created-account> get_greeting

"Hello" # Response
```

</TabItem>

<TabItem value="near-cli-rs">

```bash
> near contract call-function as-read-only <created-account> get_greeting json-args {} network-config testnet now

"Hello" # Response
```

</TabItem>

</Tabs>

### Set Greeting

The `set_greeting` method is a [`change`](./anatomy/anatomy.md#public-methods) method, meaning it modifies the contract's state, and thus requires a user to sign a transaction in order to be executed.

<Tabs>

<TabItem value="near-cli">

```bash
> near call <created-account> set_greeting '{"greeting": "Hola"}' --accountId <created-account>

Log: Saving greeting "Hola" # Response
```

In this case we are asking the account that stores the contract to call its own contract's method (`--accountId <created-account>`).

</TabItem>

<TabItem value="near-cli-rs">

```bash
> near contract call-function as-transaction <created-account> set_greeting json-args '{"greeting": "Hola"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as <created-account> network-config testnet sign-with-keychain send

Log: Saving greeting "Hola" # Response
```

In this case, we are asking the account that stores the contract to call its own contract's method (`sign-as <created-account>`).

</TabItem>

</Tabs>

---

## Moving Forward

That's it for the quickstart tutorial. You have now seen a fully functional contract with a minimal user interface and testing.

Go ahead and check other [examples](/tutorials/examples/guest-book) or proceed straight to the [Develop section](./anatomy/anatomy.md) to know how to write your own contract.

If you have any questions, do not hesitate to join us on [Discord](https://near.chat). We regularly host Office Hours, in which you can join our voice channel and ask questions.

Happy coding! üöÄ

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- node: `18.19.1`
- rustc: `1.77.0`
- near-cli-rs: `0.8.1`
- cargo-near: `0.6.1`

:::

'''
'''--- docs/2.build/2.smart-contracts/release/deploy.md ---
---
id: deploy
title: NEAR CLI - Basics
sidebar_label: Deploying and Using
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

After your contract is ready you can deploy it in the NEAR network for everyone to use it.

Let us guide you on how to use the [NEAR CLI](../../../4.tools/cli.md) to deploy your contract
and call its methods.

:::info
On this page, we will only cover the basics of NEAR CLI. For more information visit the
[NEAR CLI documentation page](../../../4.tools/cli.md).
:::

---

## Deploying the Contract

Thanks to the `NEAR CLI` deploying a contract is as simple as:

1. Compiling the contract to wasm (done automatically through `yarn build` in our templates).
2. [Create an account](../../../4.tools/cli.md#near-create-account) and [deploy the contract](../../../4.tools/cli.md#near-deploy) into it using `NEAR CLI`.

#### Create an Account and Deploy

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="near-cli">

```bash
# Create a new account pre-funded by a faucet & deploy
near create-account <accountId> --useFaucet
near deploy <accountId> <route_to_wasm>

# Get the account name
cat ./neardev/dev-account
```

</TabItem>

<TabItem value="near-cli-rs">

```bash
# Automatically deploy the wasm in a new account
near account create-account sponsor-by-faucet-service <my-new-dev-account>.testnet autogenerate-new-keypair save-to-keychain network-config testnet create

near contract deploy <my-new-dev-account>.testnet use-file <route_to_wasm> without-init-call network-config testnet sign-with-keychain
```

</TabItem>

</Tabs>

#### Deploy in an Existing Account

<Tabs className="language-tabs" groupId="code-tabs">
<TabItem value="near-cli">

```bash
# login into your account
near login

# deploy the contract
near deploy <accountId> <route_to_wasm>
```

</TabItem>

<TabItem value="near-cli-rs">

```bash
# login into your account
near account import-account using-web-wallet network-config testnet

# deploy the contract
near contract deploy <accountId> use-file <route_to_wasm> without-init-call network-config testnet sign-with-keychain send
```

</TabItem>

</Tabs>

:::tip
You can overwrite a contract by deploying another on top of it. In this case, the account's logic
will change, but the state will persist
:::

:::info
By default `near-cli` uses the `testnet` network. Define `NEAR_ENV=mainnet` to deploy into `mainnet`.
:::

:::info Naming Convention for Public-Facing Methods 
Once the contract is deployed to the network, anyone and any other contract (i.e., any other account on NEAR) can interact with it by calling its methods. Furthermore, any transactions involving the contract will also be included in the network's data stream, which means its activity can also be visible to any who listens to particular events. 

Considering this, we advise to name methods using `snake_case` in all SDKs as this is compatible with the remainder of the NEAR ecosystem which is predominantly comprised of Rust contracts. 
:::

---

## Initializing the Contract
If your contract has an [initialization method](../anatomy/anatomy.md#initialization-functions) you can call it to
initialize the state. This is not necessary if your contract implements `default` values for the state. 

<Tabs className="language-tabs" groupId="code-tabs">
<TabItem value="near-cli">

```bash
# Call the initialization method (`init` in our examples)
near call <contractId> <initMethod> [<args>] --accountId <accountId>
```

</TabItem>

<TabItem value="near-cli-rs">

```bash
# Call the initialization method (`init` in our examples)
near contract call-function as-transaction <contractId> <initMethod> json-args [<args>] prepaid-gas '30 TeraGas' attached-deposit '0 NEAR' sign-as <accountId> network-config testnet sign-with-keychain send
```

</TabItem>

</Tabs>

:::info
You can initialize your contract [during deployment](#deploying-the-contract) using the `--initFunction` & `--initArgs` arguments.
:::

---

## Calling the Contract

Once your contract is deployed you can interact with it right away using [NEAR CLI](../../../4.tools/cli.md).

<hr className="subsection" />

### View methods
View methods are those that perform **read-only** operations. Calling these methods is free, and do not require to specify which account is being used to make the call:

<Tabs className="language-tabs" groupId="code-tabs">
<TabItem value="near-cli">

```bash
near view <contractId> <methodName>
```

</TabItem>

<TabItem value="near-cli-rs">

```bash
near contract call-function as-read-only <contractId> <methodName> text-args '' network-config testnet now
```
</TabItem>

</Tabs>

:::tip
View methods have by default 200 TGAS for execution
:::

<hr className="subsection" />

### Change methods

Change methods are those that perform both read and write operations. For these methods we do need to specify the account being used to make the call,
since that account will expend GAS in the call.

<Tabs className="language-tabs" groupId="code-tabs">
<TabItem value="near-cli">

```bash
near call <contractId> <methodName> <jsonArgs> --accountId <yourAccount> [--deposit <amount>] [--gas <GAS>]
```

</TabItem>

<TabItem value="near-cli-rs">

```bash
near contract call-function as-transaction <AccountId> <MethodName> json-args <JsonArgs> prepaid-gas <PrepaidGas> attached-deposit <AttachedDeposit> sign-as <AccountId>  network-config testnet sign-with-keychain send
```

</TabItem>

</Tabs>

'''
'''--- docs/2.build/2.smart-contracts/release/lock.md ---
---
id: lock
title: Locking Accounts
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Removing all [full access keys](../../../4.tools/cli.md#near-delete-key-near-delete-key) from an account will effectively **lock it**.

When an account is locked nobody can perform transactions in the account's name (e.g. update the code or transfer money).

#### How to Lock an Account
<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="near-cli">

```bash
near keys <dev-account>
# result: [access_key: {"nonce": ..., "public_key": '<key>'}]

near delete-key <dev-account> '<key>'
```

</TabItem>

<TabItem value="near-cli-rs">

```bash
near account list-keys <dev-account> network-config testnet now
# result:

+---+------------+-------+-------------+
| # | Public Key | Nonce | Permissions |
+---+------------+-------+-------------+
..    '<key>'      ...        ...
+---+------------+-------+-------------+

near account delete-key <dev-account> '<key>' network-config testnet sign-with-keychain send
```

</TabItem>

</Tabs>

#### Why Locking an Account

Locking an account brings more reassurance to end-users, since they know no external actor will be able to manipulate the account's
contract or balance.

:::tip Upgrading Locked Contracts

Please do note that, while no external actor can update the contract, the contract **can still upgrade itself**. See [this article](upgrade.md#programmatic-update) for details.

:::

'''
'''--- docs/2.build/2.smart-contracts/release/upgrade.md ---
---
id: upgrade
title: Updating Contracts
---

import {CodeTabs, Language, Github} from "@site/src/components/codetabs"
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

NEAR accounts separate their logic (contract's code) from their state (storage), allowing the code to be changed.

Contract's can be updated in two ways:

1. **Through tools** such as [NEAR CLI](../../../4.tools/cli.md) or [near-api-js](../../../4.tools/near-api-js/quick-reference.md) (if you hold the account's [full access key](../../../1.concepts/protocol/access-keys.md)).
2. **Programmatically**, by implementing a method that [takes the new code and deploys it](#programmatic-update).

---

## Updating Through Tools

Simply re-deploy another contract using your preferred tool, for example, using [NEAR CLI](../../../4.tools/cli.md):

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="near-cli">

```bash
# (optional) If you don't have an account, create one
near create-account <account-id> --useFaucet

# Deploy the contract
near deploy <account-id> <wasm-file>
```

</TabItem>

<TabItem value="near-cli-rs">

```bash
# (optional) If you don't have an account, create one
near account create-account sponsor-by-faucet-service somrnd.testnet autogenerate-new-keypair save-to-keychain network-config testnet create

# Deploy the contract
near contract deploy <accountId> use-file <route_to_wasm> without-init-call network-config testnet sign-with-keychain send
```

</TabItem>

</Tabs>

---

## Programmatic Update
A smart contract can also update itself by implementing a method that:
1. Takes the new wasm contract as input
2. Creates a Promise to deploy it on itself

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="update.rs"
        url="https://github.com/near-examples/update-migrate-rust/blob/main/self-updates/base/src/update.rs"
        start="10" end="31" />

</Language>

</CodeTabs>

#### How to Invoke Such Method?

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="near-cli">

```bash
# Load the contract's raw bytes
CONTRACT_BYTES=`cat ./path/to/wasm.wasm | base64`

# Call the update_contract method
near call <contract-account> update_contract "$CONTRACT_BYTES" --base64 --accountId <manager-account> --gas 300000000000000
```

</TabItem>

<TabItem value="near-cli-rs">

```bash
# Call the update_contract method
near contract call-function as-transaction <contract-account> update_contract file-args </path/to/wasm.wasm> prepaid-gas '300.0 Tgas' attached-deposit '0 NEAR' sign-as <manager-account> network-config testnet sign-with-keychain send
```

</TabItem>

<TabItem value="js" label="üåê JavaScript">

```js
// Load the contract's raw bytes
const code = fs.readFileSync("./path/to/wasm.wasm");

// Call the update_contract method
await wallet.callMethod({contractId: guestBook, method: "update_contract", args: code, gas: "300000000000000"});
```

</TabItem>

</Tabs>

:::tip DAO Factories

This is how DAO factories [update their contracts](https://github.com/near-daos/sputnik-dao-contract/blob/main/sputnikdao-factory2/src/factory_manager.rs#L60)

:::

---

## Migrating the State

Since the account's logic (smart contract) is separated from the account's state (storage),
**the account's state persists** when re-deploying a contract.

Because of this, **adding methods** or **modifying existing ones** will yield **no problems**.

However, deploying a contract that **modifies or removes structures**  stored in the state will raise an
error: `Cannot deserialize the contract state`, in which case you can choose to:
1. Use a different account
2. Rollback to the previous contract code
3. Add a method to migrate the contract's state

<hr className="subsection" />

### The Migration Method

If you have no option but to migrate the state, then you need to implement a method that:
1. Reads the current state of the contract
2. Applies different functions to transform it into the new state
3. Returns the new state

:::tip DAO Update

This is how DAOs [update themselves](https://github.com/near-daos/sputnik-dao-contract/blob/main/sputnikdao2/src/upgrade.rs#L59)

:::

<hr className="subsection" />

### Example: Guest Book Migration

Imagine you have a Guest Book where you store messages, and the users can pay for such messages
to be "premium". You keep track of the messages and payments using the following state:

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
        url="https://github.com/near-examples/update-migrate-rust/blob/main/basic-updates/base/src/lib.rs"
        start="10" end="21" />        

</Language>

</CodeTabs>

#### Update Contract

At some point you realize that you could keep track of the `payments` inside of the `PostedMessage` itself,
so you change the contract to:

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
        url="https://github.com/near-examples/update-migrate-rust/blob/main/basic-updates/update/src/lib.rs"
        start="12" end="23" />        

</Language>

</CodeTabs>

#### Incompatible States

If you deploy the update into an initialized account the contract will fail to deserialize the account's state,
because:
1. There is an extra `payments` vector saved in the state (from the previous contract)
2. The stored `PostedMessages` are missing the `payment` field (as in the previous contract)

#### Migrating the State

To fix the problem, you need to implement a method that goes through the old state, removes the `payments` vector and
adds the information to the `PostedMessages`:

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
        url="https://github.com/near-examples/update-migrate-rust/blob/main/basic-updates/update/src/migrate.rs"
        start="3" end="46" />

</Language>

</CodeTabs>

Notice that `migrate` is actually an [initialization method](../anatomy/anatomy.md#initialization-method) that **ignores** the existing state (`[#init(ignore_state)]`), thus being able to execute and rewrite the state.

:::tip

You can follow a migration step by step in the [official migration example](https://github.com/near-examples/update-migrate-rust/tree/main/basic-updates/base)

:::

'''
'''--- docs/2.build/2.smart-contracts/security/bounty.md ---
---
id: bounty
title: Bug Bounty Program
---

NEAR has a [revamped bug bounty program](https://hackenproof.com/near/near-protocol)!

Hackers - help audit, test, and toughen NEAR up, starting with bounties in the protocol category, and soon expanding to wallet, web, console, and smart contracts

'''
'''--- docs/2.build/2.smart-contracts/security/callbacks.md ---
---
id: callbacks
title: Cross-Contract Calls
---

While writing cross-contract calls there is a significant aspect to keep in mind: all the calls are **independent** and **asynchronous**. In other words:

- The method in which you make the call and method for the callback are **independent**.
- Between the call and the callback, people could interact with the contract.

This has important implications on how you should handle the callbacks. Particularly:

1. Your callback method needs to be public, but you want to make sure only your contract can call it.
2. Make sure you don't leave the contract in a exploitable state between the call and the callback.
3. Manually rollback any changes to the state in the callback if the external call failed.

---

## Private Callbacks
In order for your contract to call itself when a cross-contract call is done, you need to make the callback method public. However, most of the times you would want it to be private. You can make it private while keeping it public by asserting that the `predecessor` is `current_account`. In rust this is done automatically by adding the `#[private]` decorator.

---

## User's Money
When a method panics, the money attached to that transaction returns to the `predecessor`. This means that, if you make a cross-contract call and it fails, then the money **returns to your contract**. If the money came from a user calling your contract, then you should transfer it back during the callback.

![img](https://miro.medium.com/max/1400/1*Hp4TOcaBqm9LS0wkgWw3nA.png)
*If the user attached money, we need to manually return it in the callback*

:::caution
Make sure you pass have enough GAS in the callback to make the transfer
:::

---

## Async Callbacks
Between a cross-contract call and its callback **any method of your contract can be executed**. Not taking this into account is one of the main sources of exploits. It is so common that it has its own name: reentrancy attacks.

Imagine that we develop a `deposit_and_stake` with the following **wrong logic**: (1) The user sends us money, (2) we add it to its balance, (3) we try to stake it in a validator, (4) if the staking fails, we remove the balance in the callback. Then, a user could schedule a call to withdraw between (2) and (4), and, if the staking failed, we would send money twice to the user.

![img](https://miro.medium.com/max/1400/1*VweWHQYGLBa70uceiWHLQA.png)
*Between a cross-contract call and the callback anything could happen*

Luckily for us the solution is rather simple. Instead of immediately adding the money to our user‚Äôs balance, we wait until the callback. There we check, and if the staking went well, then we add it to their balance.

![img](https://miro.medium.com/max/1400/1*o0YVDCp_7l-L3njJMGhU4w.png)
*Correct way to handle deposits in a cross-contract call*
'''
'''--- docs/2.build/2.smart-contracts/security/checklist.md ---
---
id: checklist
title: ‚úÖ Checklist
---

Once you finished developing your smart contract please go through the following list in order to ensure everything is safe for the end user.

:::info
Check our [security articles](./welcome.md) to understand how to improve the security of your contract.
:::

---

## Anatomy
1. All private methods are decorated as `private`.

## Environment
2. `predecessor` and `signer` are used correctly through the entire contract.

## Storage
3. Each time the state grows it is ensured that there is enough balance to cover it
4. All collections (i.e. Vector, Map, Tree, etc) have an unique id
5. Check for underflow and overflow!. In rust, you can do this by simply adding the `overflow-checks = true` flag in your `Cargo.toml`.

## Actions
6. When sending money, you leave enough in the contract to cover the storage cost
7. If you are tracking user's fund, you **deduct them before** sending them back to the user. 

## Callbacks
8. All private callbacks are marked as `private`
9. All cross-contract calls have a callback
10. All callbacks check for errors and roll back the state if necessary
11. All callbacks return money to the `predecessor` if necessary
12. Callbacks are free of `panic!`
13. All the callbacks are given enough GAS to execute entirely
14. The contract is not left in an exploitable state between a cross-contract call and its callback

'''
'''--- docs/2.build/2.smart-contracts/security/frontrunning.md ---
---
id: frontrunning
title: Front Running
---

In the NEAR network, validators have access to the transaction pool, and can therefore see them before they execute. This enables validators to analyze transactions for a potential profit and frontrun them with a transaction of their own.

For example, imagine that you make a game where users are paid for solving puzzles. If not handled carefully, a validator could swap a transaction with the valid answer for one of its own and claim the prize. You can read more about this in [this blog post](https://www.paradigm.xyz/2020/08/ethereum-is-a-dark-forest).

'''
'''--- docs/2.build/2.smart-contracts/security/one_yocto.md ---
---
id: one-yocto
title: Ensure it is the User (1y‚ìÉ)
---

NEAR uses a system of [Access Keys](../../../1.concepts/protocol/access-keys.md) to simplify handling accounts.
There are basically two type of keys: `Full Access`, that have full control over an account (i.e. can perform all [actions](../anatomy/actions.md)), and 
`Function Call`, that only have permission to call a specified smart contract's method(s) that _do not_ attach ‚ìÉ as a deposit.

When a user [signs in on a website](../../4.web3-apps/integrate-contracts.md#user-sign-in--sign-out) to interact with your contract, what actually happens is
that a `Function Call` key is created and stored in the website. Since the website has access to the `Function Call` key, it can use it to
call the authorized methods as it pleases. While this is very user friendly for most cases, it is important to be careful in scenarios involving
transferring of valuable assets like [NFTs](../../../2.build/5.primitives/nft.md) or [FTs](../../../2.build/5.primitives/ft.md). In such cases, you need to ensure that
the person asking for the asset to be transfer is **actually the user**.

One direct and inexpensive way to ensure that the user is the one calling is by requiring to attach `1 y‚ìÉ`. In this case, the user will be
redirected to the wallet and be asked to accept the transaction. This is because, once again, only the `Full Access` key can be used to send NEAR.
Since the `Full Access` key is only in the user's wallet, you can trust that a transaction with `1 y‚ìÉ` was made by the user.
'''
'''--- docs/2.build/2.smart-contracts/security/random.md ---
---
id: random
title: Random Numbers
---

When writing smart contracts in NEAR you have access to a `random seed` that enables you to create random numbers/strings
within your contract.

This `random seed` is **deterministic and verifiable**: it comes from the validator that produced the block signing the previous
block-hash with their private key.

The way the random seed is created implies two things:

- Only the validator mining the transaction **can predict** which random number will come out. **No one else** could predict it because nobody knows the validator's private key (except the validator itself).

- The validator **cannot interfere** with the random number being created. This is because they need to sign the previous block, over which (with a high probability) they had no control.

However, notice that this still leaves room for three types of attacks from the validator:
1. [Frontrunning](./frontrunning.md), which we cover in another page
2. Gaming the input
3. Refusing to mine the block. 

----

## Gaming the Input
Imagine you have a method that takes an input and gives a reward based on it. For example, you ask the user to choose a number,
and if it the same as your `random seed` you give them money.

Since the validator knows which `random seed` will come out, it can create a transaction with that specific input and win the prize.

----

## Refusing to Mine the Block
One way to fix the "gaming the input" problem is to force the user to send the input first, and then decide the result on a different block.
Let's call these two stages: "bet" and "resolve".

In this way, a validator cannot game the input, since the `random` number against which it will be compared is computed in a different block.

However, something that the validator can still do to increase their chance of winning is:
1. Create a "bet" transaction with an account.
2. When it's their turn to validate, decide if they want to "resolve" or not.

If the validator, on their turn, sees that generating a random number makes them win, they can add the transaction to the block. And if they
see that they will not, they can skip the transaction.

While this does not ensure that the validator will win (other good validators could mine the transaction), it can improve their chance of winning.

Imagine a flip-coin game, where you choose `heads` or `tails` in the "bet" stage, and later resolve if you won or not. If you are a validator
you can send a first transaction choosing either input.

Then, on your turn to validate, you can check if your chosen input came out. If not, you can simply skip the transaction. This brings your
probability of winning from `1/2` to `3/4`, that's a 25% increase!

These odds, of course, dilute in games with more possible outcomes.

<details>
<summary>How does the math work here?</summary>

Imagine you always bet for `heads`.

In a fair coin-flip game you have 50-50 percent chance of winning, this is because after the coin is flipped there are two possible outcomes:
`H` and `T`, and you only win in one (`H`).

However, if you can choose to flip again if `tails` comes out, now there are 4 scenarios: `H H` `T H` `H T` `T T`, and in 3 of those
you win (all the ones including an `H`)!!!.

</details>

'''
'''--- docs/2.build/2.smart-contracts/security/reentrancy.md ---
---
id: reentrancy
title: Reentrancy Attacks
---

Between a cross-contract call and its callback **any method of your contract can be executed**. Not taking this into account is one of the main sources of exploits. It is so common that it has its own name: **reentrancy attacks**.

Always make sure to keep your state in a consistent state after a method finishes executing. Assume that:

- Any method could be executed between a method execution and its callback.
- The same method could be executed again before the callback kicks in.

---

### Example
Imagine that we develop a `deposit_and_stake` with the following **wrong logic**: (1) The user sends us money, (2) we add it to its balance, (3) we try to stake it in a validator, (4) if the staking fails, we remove the balance in the callback. Then, a user could schedule a call to withdraw between (2) and (4), and, if the staking failed, we would send money twice to the user.

![img](https://miro.medium.com/max/1400/1*VweWHQYGLBa70uceiWHLQA.png)
*Between a cross-contract call and the callback anything could happen*

Luckily for us the solution is rather simple. Instead of immediately adding the money to our user‚Äôs balance, we wait until the callback. There we check, and if the staking went well, then we add it to their balance.

![img](https://miro.medium.com/max/1400/1*o0YVDCp_7l-L3njJMGhU4w.png)
*Correct way to handle deposits in a cross-contract call*
'''
'''--- docs/2.build/2.smart-contracts/security/storage.md ---
---
id: storage
title: Million Small Deposits
---

On NEAR, your contract pays for the storage it uses. This means that the more data you store, the more balance you need to cover for storage. If you don't handle these costs correctly (e.g. asking the user to cover their storage usage), then a million little deposits can drain your contract of its funds.

Let's walk through an example:

1. You launch [a guest book app](https://examples.near.org/guest-book-js), deploying your app's smart contract to the account `example.near`
2. Visitors to your app can add messages to the guest book. This means your users will pay a small gas fee to **store** their message to your contract.
3. When a new message comes in, NEAR will check if `example.near` has enough balance to cover the new storage needs. If it does not, the transaction will fail.

Note that this can create an attack surface. If sending data to your guest book is inexpensive to the user while costing the contract owner significantly more, a malicious user can exploit the imbalance to make maintaining the contract prohibitively expensive.

One possible way to tackle this problem is asking the user to attach money to the call to cover the storage used by their message.

:::tip
Remember that you can release the *balance locked for storage* by simply deleting data from the contract.
:::

'''
'''--- docs/2.build/2.smart-contracts/security/sybil.md ---
---
id: sybil
title: Sybil Attacks
---

While developing your smart contract, keep in mind that an individual can potentially create multiple NEAR accounts. This is especially relevant in ecosystems involving crowd decisions, such as [DAOs](../../../2.build/5.primitives/dao.md). 

Imagine that you open the voting to anyone in the community. If each account can cast a vote, a malicious actor could span multiple accounts and gain a disproportionately large influence on the result.
'''
'''--- docs/2.build/2.smart-contracts/security/welcome.md ---
---
id: welcome
title: Security
---

Here you will find information on how to keep your smart contract and decentralized applications secure.

:::tip
Please take some time to go through this section, it will help you to keep your dApp safe
:::

---

## üêû Bug Bounty Program
NEAR has a [revamped bug bounty program](./bounty.md), use it if you find any security errors in the protocol or mainstream apps.

## ‚úÖ Security Checklist
Make sure to keep your smart contract safe by running through our [security checklist](checklist.md).

## üõ°Ô∏è Security Concepts
Learn important security concepts to keep your dApp safe and sound.  Read about:

- Keeping [callbacks safe](./callbacks.md).
- Understanding [frontrunning](./frontrunning.md).
- Understanding [sybil attacks](./sybil.md).
- Understanding [reentrancy attacks](./reentrancy.md).
- Making sure the owner of an account is [the one calling](./one_yocto.md).
- Understanding the complexity of [generating random numbers](./random.md).
- Protecting from a [small deposit attacks](./storage.md) draining your account.
'''
'''--- docs/2.build/2.smart-contracts/testing/integration-test.md ---
---
id: integration-test
title: Integration Tests
#sidebar_label: ü•º Integration Test
---
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Integration tests enable to deploy your contract in the NEAR `testnet` or a local `sandbox`, and create test-users to interact with it. In this way, you can thoroughly test your contract in a realistic environment.

Moreover, when using the local `sandbox` you gain complete control of the network:

1. Create test `Accounts` and manipulate their `State` and `Balance`.
2. Simulate errors on callbacks.
3. Control the time-flow and fast-forward into the future (Rust ready, TS coming soon).

:::tip NEAR Workspaces

In NEAR, integration tests are implemented using a framework called **Workspaces**. Workspaces comes in two flavors: [ü¶Ä Rust](https://github.com/near/workspaces-rs) and [üåê Typescript](https://github.com/near/workspaces-js).

All of our [examples](https://github.com/near-examples/docs-examples) come with integration testing.

:::

---

## Snippet I: Testing Hello NEAR

Lets take a look at the test of our [Quickstart Project](../quickstart.md) [üëã Hello NEAR](https://github.com/near-examples/hello-near-examples), where we deploy the contract on an account and test it correctly retrieves and sets the greeting.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="main.ava.ts"
            url="https://github.com/near-examples/hello-near-examples/blob/main/contract-ts/sandbox-ts/main.ava.ts" start="8" end="43"/>
  </Language>
</CodeTabs>

---

## Snippet II: Testing Donations

In most cases we will want to test complex methods involving multiple users and money transfers. A perfect example for this is our [Donation Example](https://github.com/near-examples/donation-examples), which enables users to `donate` money to a beneficiary. Lets see its integration tests

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="main.ava.ts"
            url="https://github.com/near-examples/donation-examples/blob/main/contract-ts/sandbox-ts/src/main.ava.ts"
            start="50" end="73" />
  </Language>
</CodeTabs>

---

## Sandbox Testing

NEAR Workspaces allows you to write tests once, and run them either on `testnet` or a local `Sandbox`. By **default**, Workspaces will start a **sandbox** and run your tests **locally**. Lets dive into the features of our framework and see how they can help you.

### Spooning Contracts

[Spooning a blockchain](https://coinmarketcap.com/alexandria/glossary/spoon-blockchain) is copying the data from one network into a different network. NEAR Workspaces makes it easy to copy data from Mainnet or Testnet contracts into your local Sandbox environment:

<Tabs groupId="code-tabs">
<TabItem value="js" label="üåê JavaScript" default>

```ts
const refFinance = await root.importContract({
  mainnetContract: 'v2.ref-finance.near',
  blockId: 50_000_000,
  withData: true,
});
```

This would copy the Wasm bytes and contract state from [v2.ref-finance.near](https://nearblocks.io/address/v2.ref-finance.near) to your local blockchain as it existed at block `50_000_000`. This makes use of Sandbox's special [patch state](#patch-state-on-the-fly) feature to keep the contract name the same, even though the top level account might not exist locally (note that this means it only works in Sandbox testing mode). You can then interact with the contract in a deterministic way the same way you interact with all other accounts created with near-workspaces.

:::note

`withData` will only work out-of-the-box if the contract's data is 50kB or less. This is due to the default configuration of RPC servers; see [the "Heads Up" note here](../../../5.api/rpc/contracts.md#view-contract-state-view-contract-state).

:::

See a [TypeScript example of spooning](https://github.com/near/workspaces-js/blob/main/__tests__/05.spoon-contract-to-sandbox.ava.ts) contracts.

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

Specify the contract name from `testnet` you want to be pulling, and a specific block ID referencing back to a specific time. (Just in case the contract you're referencing has been changed or updated)

```rust
const CONTRACT_ACCOUNT: &str = "contract_account_name_on_testnet.testnet";
const BLOCK_HEIGHT: BlockHeight = 12345;
```

Create a function called `pull_contract` which will pull the contract's `.wasm` file from the chain and deploy it onto your local sandbox. You'll have to re-initialize it with all the data to run tests.

```rust
async fn pull_contract(owner: &Account, worker: &Worker<Sandbox>) -> anyhow::Result<Contract> {
    let testnet = workspaces::testnet_archival();
    let contract_id: AccountId = CONTRACT_ACCOUNT.parse()?;
```

This next line will actually pull down the relevant contract from testnet and set an initial balance on it with 1000 NEAR.

```rust
    let contract = worker
        .import_contract(&contract_id, &testnet)
        .initial_balance(parse_near!("1000 N"))
        .block_height(BLOCK_HEIGHT)
        .transact()
        .await?;
```

Following that you'll have to init the contract again with your metadata.
This is because the contract's data is too big for the RPC service to pull down. (limits are set to 50Mb)

```rust
    owner
        .call(&worker, contract.id(), "init_method_name")
        .args_json(serde_json::json!({
            "arg1": value1,
            "arg2": value2,
        }))?
        .transact()
        .await?;
    Ok(contract)
}
```

</TabItem>

</Tabs>

### Patch State on the Fly

In Sandbox-mode, you can add or modify any contract state, contract code, account or access key with `patchState`.

:::tip

You can alter contract code, accounts, and access keys using normal transactions via the `DeployContract`, `CreateAccount`, and `AddKey` [actions](https://nomicon.io/RuntimeSpec/Actions#addkeyaction). But this limits you to altering your own account or sub-account. `patchState` allows you to perform these operations on any account.

:::

Keep in mind that you cannot perform arbitrary mutation on contract state with transactions since transactions can only include contract calls that mutate state in a contract-programmed way. For example, with an NFT contract, you can perform some operation with NFTs you have ownership of, but you cannot manipulate NFTs that are owned by other accounts since the smart contract is coded with checks to reject that. This is the expected behavior of the NFT contract. However, you may want to change another person's NFT for a test setup. This is called "arbitrary mutation on contract state" and can be done with `patchState`:

<Tabs groupId="code-tabs">
<TabItem value="js" label="üåê JavaScript" >

```js
    const {contract, ali} = t.context.accounts;
    // Contract must have some state for viewState & patchState to work
    await ali.call(contract, 'set_status', {message: 'hello'});
    // Get state
    const state = await contract.viewState();
    // Get raw value
    const statusMessage = state.get('STATE', {schema, type: StatusMessage});
    // Update contract state
    statusMessage.records.push(
      new BorshRecord({k: 'alice.near', v: 'hello world'}),
    );
    // Serialize and patch state back to runtime
    await contract.patchState(
      'STATE',
      borsh.serialize(schema, statusMessage),
    );
    // Check again that the update worked
    const result = await contract.view('get_status', {
      account_id: 'alice.near',
    });
    t.is(result, 'hello world');
```

To see a complete example of how to do this, see the [patch-state test](https://github.com/near/workspaces-js/blob/main/__tests__/02.patch-state.ava.ts).

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust" >

```rust
    // Grab STATE from the testnet status_message contract. This contract contains the following data:
    //   get_status(dev-20211013002148-59466083160385) => "hello from testnet"
    let (testnet_contract_id, status_msg) = {
        let worker = workspaces::testnet().await?;
        let contract_id: AccountId = TESTNET_PREDEPLOYED_CONTRACT_ID
            .parse()
            .map_err(anyhow::Error::msg)?;
        let mut state_items = worker.view_state(&contract_id, None).await?;
        let state = state_items.remove(b"STATE".as_slice()).unwrap();
        let status_msg = StatusMessage::try_from_slice(&state)?;
        (contract_id, status_msg)
    };
    info!(target: "spooning", "Testnet: {:?}", status_msg);
    // Create our sandboxed environment and grab a worker to do stuff in it:
    let worker = workspaces::sandbox().await?;
    // Deploy with the following status_message state: sandbox_contract_id => "hello from sandbox"
    let sandbox_contract = deploy_status_contract(&worker, "hello from sandbox").await?;
    // Patch our testnet STATE into our local sandbox:
    worker
        .patch_state(
            sandbox_contract.id(),
            "STATE".as_bytes(),
            &status_msg.try_to_vec()?,
        )
        .await?;
    // Now grab the state to see that it has indeed been patched:
    let status: String = sandbox_contract
        .view(
            &worker,
            "get_status",
            serde_json::json!({
                "account_id": testnet_contract_id,
            })
            .to_string()
            .into_bytes(),
        )
        .await?
        .json()?;
    info!(target: "spooning", "New status patched: {:?}", status);
    assert_eq!(&status, "hello from testnet");
```

</TabItem>

</Tabs>

As an alternative to `patchState`, you can stop the node, dump state at genesis, edit the genesis, and restart the node.
This approach is more complex to do and also cannot be performed without restarting the node.

### Time Traveling

`workspaces` offers support for forwarding the state of the blockchain to the future. This means contracts which require time sensitive data do not need to sit and wait the same amount of time for blocks on the sandbox to be produced. We can simply just call `worker.fast_forward` to get us further in time:

<Tabs groupId="code-tabs">
<TabItem value="js" label="üåê JavaScript" default>

  <Github fname="fast-forward.ava.ts" language="js"
          url="https://github.com/near/near-workspaces-js/blob/main/__tests__/08.fast-forward.ava.ts"
          start="34" end="53" />

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

```rust
#[tokio::test]
async fn test_contract() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let contract = worker.dev_deploy(WASM_BYTES);
    let blocks_to_advance = 10000;
    worker.fast_forward(blocks_to_advance);
    // Now, "do_something_with_time" will be in the future and can act on future time-related state.
    contract.call(&worker, "do_something_with_time")
        .transact()
        .await?;
}
```

_[See the full example on Github](https://github.com/near/workspaces-rs/blob/main/examples/src/fast_forward.rs)._

</TabItem>

</Tabs>

---

## Using Testnet

NEAR Workspaces is set up so that you can write tests once and run them against a local Sandbox node (the default behavior) or against [NEAR TestNet](../../../1.concepts/basics/networks.md). Some reasons this might be helpful:

* Gives higher confidence that your contracts work as expected
* You can test against deployed testnet contracts
* If something seems off in Sandbox mode, you can compare it to testnet

:::tip

In order to use Workspaces in testnet mode you will need to have a `testnet` account.
You can create one [here](https://testnet.mynearwallet.com/).

:::

You can switch to testnet mode in three ways.

1. When creating Worker set network to `testnet` and pass your master account:

<Tabs groupId="code-tabs">
<TabItem value="js" label="üåê JavaScript"  default>

```ts
const worker = await Worker.init({
 network: 'testnet',
 testnetMasterAccountId: '<yourAccountName>',
})
```

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust" >

```rust
#[tokio::main]  // or whatever runtime we want
async fn main() -> anyhow::Result<()> {
// Create a sandboxed environment.
// NOTE: Each call will create a new sandboxed environment
let worker = workspaces::sandbox().await?;
// or for testnet:
let worker = workspaces::testnet().await?;
}
```

</TabItem>

</Tabs>

2. Set the `NEAR_WORKSPACES_NETWORK` and `TESTNET_MASTER_ACCOUNT_ID` environment variables when running your tests:

<Tabs groupId="code-tabs">
<TabItem value="js" label="üåê JavaScript"  default>

```bash
NEAR_WORKSPACES_NETWORK=testnet TESTNET_MASTER_ACCOUNT_ID=<your master account Id> node test.js
```

If you set this environment variables and pass `{network: 'testnet', testnetMasterAccountId: <masterAccountId>}` to `Worker.init`, the config object takes precedence.

</TabItem>

</Tabs>

3. If using `near-workspaces` with AVA, you can use a custom config file. Other test runners allow similar config files; adjust the following instructions for your situation.

<Tabs groupId="code-tabs">
<TabItem value="js" label="üåê JavaScript"  default>

Create a file in the same directory as your `package.json` called `ava.testnet.config.cjs` with the following contents:

```js
module.exports = {
 ...require('near-workspaces/ava.testnet.config.cjs'),
 ...require('./ava.config.cjs'),
};
module.exports.environmentVariables = {
    TESTNET_MASTER_ACCOUNT_ID: '<masterAccountId>',
};
```

The [near-workspaces/ava.testnet.config.cjs](https://github.com/near/workspaces-js/blob/main/ava.testnet.config.cjs) import sets the `NEAR_WORKSPACES_NETWORK` environment variable for you. A benefit of this approach is that you can then easily ignore files that should only run in Sandbox mode.

Now you'll also want to add a `test:testnet` script to your `package.json`'s `scripts` section:

```diff
"scripts": {
  "test": "ava",
+  "test:testnet": "ava --config ./ava.testnet.config.cjs"
}
```

</TabItem>

</Tabs>

---

## Additional Media

#### Test Driven Design Using Workspaces and AVA {#test-driven-design}

The video below walks through how to apply TDD with Workspaces and AVA for a simple contract:

<iframe
  width="560"
  height="315"
  src="https://www.youtube-nocookie.com/embed/LCu03IYwu1I"
  title="TDD Using Workspaces"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen>
</iframe>

'''
'''--- docs/2.build/2.smart-contracts/testing/introduction.md ---
---
id: introduction
title: Introduction
---

While developing your smart contract you will want to test that it works as it is supposed to, and moreover, does so securely. In NEAR we have developed tools to help you carry out such tests. Basically, there are two types of tests you can perform:

1. **Unit Tests** to test methods individually. They are written in the contract's language and are executed locally.
2. **Integration Tests** to test how your contract behaves in a realistic environment. You can write them in Rust or Typescript, and execute in a local Sandbox or the NEAR testnet.

We recommend all developers to implement both types of tests, since each is suitable to detect different types of errors and make your code intentional. Furthermore, we strongly recommend to first release all projects on testnet, and give users time to try them before releasing them on mainnet.

---
## Setting Up Testing
Testing a smart contract involves using different pieces of software depending on which type of test you are performing. In order to save you from the trouble of setting them up, we recommend you copy the structure from one of our [example projects](https://github.com/near-examples).
'''
'''--- docs/2.build/2.smart-contracts/testing/kurtosis-localnet.md ---
---
id: kurtosis-localnet
title: Creating a Local Development Environment
sidebar_label: Local Development
description: Using Kurtosis NEAR Package to develop locally
---

> [Kurtosis](https://www.kurtosis.com/) has created an easy way to spin up a local NEAR testing environment using a [Docker container](https://www.docker.com/).

This Kurtosis NEAR Package contains the following components:

- [Indexer for Explorer](https://github.com/near/near-indexer-for-explorer)
- [NEAR Explorer](https://github.com/near/near-explorer)
- [NEAR Wallet](https://github.com/near/near-wallet)
- Local RPC Endpoint

[Visit here](https://www.loom.com/share/8a1b8e2138334a81a380f5d523fba27e) to see a short demo of the package in action.

---

## Prerequisites {#prerequisites}

- [Docker](https://docs.docker.com/get-docker/)
- [Yarn](https://classic.yarnpkg.com/lang/en/docs/install)
- [NEAR-CLI](/tools/near-cli#setup)
- [Kurtosis CLI](https://docs.kurtosis.com/install)
  - Start Kurtosis engine after installation using: `kurtosis engine start`

---

## Setup

### Launch Kurtosis NEAR Package {#launching-cluster}

Launch your Kurtosis NEAR Package in four easy steps!

1. Launch [Docker](https://docs.docker.com/get-docker/)

2. Copy the [Kurtosis NEAR Package launch script](https://github.com/kurtosis-tech/near-package/blob/master/launch-local-near-cluster.sh) by running the following:

```bash
curl -o ~/launch-local-near-cluster.sh https://raw.githubusercontent.com/kurtosis-tech/near-package/master/launch-local-near-cluster.sh -L
```

3. Grant write permission to the script file you just downloaded:

```bash
chmod u+x ~/launch-local-near-cluster.sh
```

4. Launch the Kurtosis NEAR Package:

If you're running the NEAR-in-Kurtosis cluster on your local machine:

```bash
~/launch-local-near-cluster.sh
```

If you're running your NEAR-in-Kurtosis cluster on a machine you intend to access remotely, replace `1.2.3.4` with the IP address of the machine you're running the cluster on:

```bash
~/launch-local-near-cluster.sh '{"backend_ip_address":"1.2.3.4"}'
```

<details>
<summary>Example response: </summary>

```bash
Created directory '/Users/zerix/.neartosis' for storing all NEAR-in-Kurtosis output
INFO[2022-12-06T12:59:04+05:30] Creating a new enclave for Starlark to run inside...
INFO[2022-12-06T12:59:14+05:30] Enclave 'near' created successfully
INFO[2022-12-06T12:59:14+05:30] Kurtosis CLI is running in a non interactive terminal. Everything will work but progress information and the progress bar will not be displayed.

> print "Starting the near-package with input struct(backend_ip_address = \"127.0.0.1\")"
Starting the near-package with input struct(backend_ip_address = "127.0.0.1")

> print "Launching contract helper postgresql"
Launching contract helper postgresql

> print "Adding contract helper Posgresql DB running on port '5432'"
Adding contract helper Posgresql DB running on port '5432'

> add_service service_id="contract-helper-db"
Service 'contract-helper-db' added with service GUID 'contract-helper-db-1670311755'

> exec service_id="contract-helper-db" command=["sleep", "10"]
Command returned with exit code '0' with no output

> exec service_id="contract-helper-db" command=["psql", "-U", "near", "-c", "\\l"]
Command returned with exit code '0' and the following output:
List of databases
   Name    | Owner | Encoding |  Collate   |   Ctype    | Access privileges
-----------+-------+----------+------------+------------+-------------------
 near      | near  | UTF8     | en_US.utf8 | en_US.utf8 |
 postgres  | near  | UTF8     | en_US.utf8 | en_US.utf8 |
 template0 | near  | UTF8     | en_US.utf8 | en_US.utf8 | =c/near          +
           |       |          |            |            | near=CTc/near
 template1 | near  | UTF8     | en_US.utf8 | en_US.utf8 | =c/near          +
           |       |          |            |            | near=CTc/near
(4 rows)

> exec service_id="contract-helper-db" command=["psql", "-U", "near", "-c", "create database indexer with owner=near"]
Command returned with exit code '0' and the following output: 'CREATE DATABASE'

> exec service_id="contract-helper-db" command=["psql", "-U", "near", "-c", "create database analytics with owner=near"]
Command returned with exit code '0' and the following output: 'CREATE DATABASE'

> exec service_id="contract-helper-db" command=["psql", "-U", "near", "-c", "create database telemetry with owner=near"]
Command returned with exit code '0' and the following output: 'CREATE DATABASE'

> print "Contract helper postgresql db info struct(analytics_db = \"analytics\", db_user_password = \"near\", db_username = \"near\", indexer_db = \"indexer\", private_url = struct(ip_address = \"contract-helper-db\", path = \"\", port_number = 5432, protocol = \"postgres\"), telemetry_db = \"telemetry\")"
Contract helper postgresql db info struct(analytics_db = "analytics", db_user_password = "near", db_username = "near", indexer_db = "indexer", private_url = struct(ip_address = "contract-helper-db", path = "", port_number = 5432, protocol = "postgres"), telemetry_db = "telemetry")

> print "Launching contract helper dynamo db"
Launching contract helper dynamo db

> print "Adding contract helper DynamoDB running on default port '8000'"
Adding contract helper DynamoDB running on default port '8000'

> add_service service_id="contract-helper-dynamo-db"
Service 'contract-helper-dynamo-db' added with service GUID 'contract-helper-dynamo-db-1670311770'

> print "Contract helper dynamodb info struct(private_url = struct(ip_address = \"contract-helper-dynamo-db\", path = \"\", port_number = 8000, protocol = \"TCP\"))"
Contract helper dynamodb info struct(private_url = struct(ip_address = "contract-helper-dynamo-db", path = "", port_number = 8000, protocol = "TCP"))

> print "Launching indexer"
Launching indexer

> print "Adding indexer service..."
Adding indexer service...

> upload_files src="github.com/kurtosis-tech/near-package/static_files/near-configs/localnet" artifact_id="8f5279c5-d012-4543-88e7-e9829b6d6040"
Files uploaded with artifact ID '8f5279c5-d012-4543-88e7-e9829b6d6040'

> add_service service_id="indexer-node"
Service 'indexer-node' added with service GUID 'indexer-node-1670311774'

> exec service_id="indexer-node" command=["sleep", "10"]
Command returned with exit code '0' with no output

> exec service_id="indexer-node" command=["cat", "/root/.near/validator_key.json"]
Command returned with exit code '0' and the following output:
{
  "account_id": "test.near",
  "public_key": "ed25519:3Kuyi2DUXdoHgoaNEvCxa1m6G8xqc6Xs7WGajaqLhNmW",
  "secret_key": "ed25519:2ykcMLiM7vCmsSECcgfmUzihBtNdBv7v2CxNi94sNt4R8ar4xsrMMYvtsSNGQDfSRhNWXEnZvgx2wzS9ViBiS9jW"
}

> print "Indexer launched with struct(private_rpc_url = struct(ip_address = \"indexer-node\", path = \"\", port_number = 3030, protocol = \"http\"), public_rpc_url = struct(ip_address = \"127.0.0.1\", path = \"\", port_number = 8332, protocol = \"http\"), validator_key = {\"account_id\": \"test.near\", \"public_key\": \"ed25519:3Kuyi2DUXdoHgoaNEvCxa1m6G8xqc6Xs7WGajaqLhNmW\", \"secret_key\": \"ed25519:2ykcMLiM7vCmsSECcgfmUzihBtNdBv7v2CxNi94sNt4R8ar4xsrMMYvtsSNGQDfSRhNWXEnZvgx2wzS9ViBiS9jW\"})"
Indexer launched with struct(private_rpc_url = struct(ip_address = "indexer-node", path = "", port_number = 3030, protocol = "http"), public_rpc_url = struct(ip_address = "127.0.0.1", path = "", port_number = 8332, protocol = "http"), validator_key = {"account_id": "test.near", "public_key": "ed25519:3Kuyi2DUXdoHgoaNEvCxa1m6G8xqc6Xs7WGajaqLhNmW", "secret_key": "ed25519:2ykcMLiM7vCmsSECcgfmUzihBtNdBv7v2CxNi94sNt4R8ar4xsrMMYvtsSNGQDfSRhNWXEnZvgx2wzS9ViBiS9jW"})

> print "Launching contract helper"
Launching contract helper

> print "Adding contract helper service running on port '3000'"
Adding contract helper service running on port '3000'

> add_service service_id="contract-helper-service"
Service 'contract-helper-service' added with service GUID 'contract-helper-service-1670311796'

> print "Contract helper launchded with struct(private_url = struct(ip_address = \"contract-helper-service\", path = \"\", port_number = 3000, protocol = \"http\"), public_url = struct(ip_address = \"127.0.0.1\", path = \"\", port_number = 8330, protocol = \"http\"))"
Contract helper launchded with struct(private_url = struct(ip_address = "contract-helper-service", path = "", port_number = 3000, protocol = "http"), public_url = struct(ip_address = "127.0.0.1", path = "", port_number = 8330, protocol = "http"))

> print "Launching explorer backend"
Launching explorer backend

> print "Adding explorer backend service"
Adding explorer backend service

> add_service service_id="explorer-backend"
Service 'explorer-backend' added with service GUID 'explorer-backend-1670311799'

> print "Explorer backend launchded with struct(private_url = struct(ip_address = \"explorer-backend\", path = \"\", port_number = 8080, protocol = \"http\"), public_url = struct(ip_address = \"127.0.0.1\", path = \"\", port_number = 18080, protocol = \"http\"))"
Explorer backend launchded with struct(private_url = struct(ip_address = "explorer-backend", path = "", port_number = 8080, protocol = "http"), public_url = struct(ip_address = "127.0.0.1", path = "", port_number = 18080, protocol = "http"))

> print "Launching explorer frontend"
Launching explorer frontend

> print "Adding explorer frontend service running on port '3000'"
Adding explorer frontend service running on port '3000'

> add_service service_id="explorer-frontend"
Service 'explorer-frontend' added with service GUID 'explorer-frontend-1670311803'

> print "Explorer frontend launchded with struct(public_url = struct(ip_address = \"127.0.0.1\", path = \"\", port_number = 8331, protocol = \"http\"))"
Explorer frontend launchded with struct(public_url = struct(ip_address = "127.0.0.1", path = "", port_number = 8331, protocol = "http"))

> print "Launching wallet"
Launching wallet

> print "Adding wallet service running on port '3004"
Adding wallet service running on port '3004

> print "Replacing variable 'NODE_URL' to 'http://127.0.0.1:8332' using regexp: '([,{])NODE_URL:[^,]*([,}])'"
Replacing variable 'NODE_URL' to 'http://127.0.0.1:8332' using regexp: '([,{])NODE_URL:[^,]*([,}])'

> print "Replacing variable 'ACCOUNT_HELPER_URL' to 'http://127.0.0.1:8330' using regexp: '([,{])ACCOUNT_HELPER_URL:[^,]*([,}])'"
Replacing variable 'ACCOUNT_HELPER_URL' to 'http://127.0.0.1:8330' using regexp: '([,{])ACCOUNT_HELPER_URL:[^,]*([,}])'

> print "Replacing variable 'EXPLORER_URL' to 'http://127.0.0.1:8331' using regexp: '([,{])EXPLORER_URL:[^,]*([,}])'"
Replacing variable 'EXPLORER_URL' to 'http://127.0.0.1:8331' using regexp: '([,{])EXPLORER_URL:[^,]*([,}])'

> print "Replacing variable 'NETWORK_ID' to 'localnet' using regexp: '([,{])NETWORK_ID:[^,]*([,}])'"
Replacing variable 'NETWORK_ID' to 'localnet' using regexp: '([,{])NETWORK_ID:[^,]*([,}])'

> print "Replacing variable 'ACCOUNT_ID_SUFFIX' to 'test.near' using regexp: '([,{])ACCOUNT_ID_SUFFIX:[^,]*([,}])'"
Replacing variable 'ACCOUNT_ID_SUFFIX' to 'test.near' using regexp: '([,{])ACCOUNT_ID_SUFFIX:[^,]*([,}])'

> print "Replacing variable 'ACCESS_KEY_FUNDING_AMOUNT' to '3000000000000000000000000' using regexp: '([,{])ACCESS_KEY_FUNDING_AMOUNT:[^,]*([,}])'"
Replacing variable 'ACCESS_KEY_FUNDING_AMOUNT' to '3000000000000000000000000' using regexp: '([,{])ACCESS_KEY_FUNDING_AMOUNT:[^,]*([,}])'

> add_service service_id="wallet"
Service 'wallet' added with service GUID 'wallet-1670311807'

> print "Explorer wallet struct(public_url = struct(ip_address = \"127.0.0.1\", path = \"\", port_number = 8334, protocol = \"http\"))"
Explorer wallet struct(public_url = struct(ip_address = "127.0.0.1", path = "", port_number = 8334, protocol = "http"))

Starlark code successfully run. Output was:
{
 "contract_helper_service_url": "http://127.0.0.1:8330",
 "explorer_url": "http://127.0.0.1:8331",
 "near_node_rpc_url": "http://127.0.0.1:8332",
 "network_name": "localnet",
 "root_validator_key": {
  "account_id": "test.near",
  "public_key": "ed25519:3Kuyi2DUXdoHgoaNEvCxa1m6G8xqc6Xs7WGajaqLhNmW",
  "secret_key": "ed25519:2ykcMLiM7vCmsSECcgfmUzihBtNdBv7v2CxNi94sNt4R8ar4xsrMMYvtsSNGQDfSRhNWXEnZvgx2wzS9ViBiS9jW"
 },
 "wallet_url": "http://127.0.0.1:8334"
}
INFO[2022-12-06T13:00:10+05:30] =============================================
INFO[2022-12-06T13:00:10+05:30] ||          Created enclave: near          ||
INFO[2022-12-06T13:00:10+05:30] =============================================
============================================================ SUCCESS ================================================================================
  ACTION Paste the following in your terminal to declare the following variables so you can use them:

         export NEAR_ENV="local"
         export NEAR_CLI_LOCALNET_NETWORK_ID="localnet"
         export NEAR_NODE_URL="http://127.0.0.1:8332"
         export NEAR_CLI_LOCALNET_KEY_PATH="/Users/zerix/.neartosis/2022-12-06T12.59.04/validator-key.json"
         export NEAR_WALLET_URL="http://127.0.0.1:8334"
         export NEAR_HELPER_URL="http://127.0.0.1:8330"
         export NEAR_HELPER_ACCOUNT="test.near
\"ed25519:2ykcMLiM7vCmsSECcgfmUzihBtNdBv7v2CxNi94sNt4R8ar4xsrMMYvtsSNGQDfSRhNWXEnZvgx2wzS9ViBiS9jW\"})
ed25519:2ykcMLiM7vCmsSECcgfmUzihBtNdBv7v2CxNi94sNt4R8ar4xsrMMYvtsSNGQDfSRhNWXEnZvgx2wzS9ViBiS9jW"})
test.near"
         export NEAR_EXPLORER_URL="http://127.0.0.1:8331"

  ACTION Paste the following into your terminal now to use the 'local_near' command as a replacement for the NEAR CLI for connecting to your
         local cluster (e.g. 'local_near login'):

         alias local_near='NEAR_ENV="local" NEAR_CLI_LOCALNET_NETWORK_ID="localnet" NEAR_NODE_URL="http://127.0.0.1:8332" NEAR_CLI_LOCALNET_KEY_PATH="/Users/zerix/.neartosis/2022-12-06T12.59.04/validator-key.json" NEAR_WALLET_URL="http://127.0.0.1:8334" NEAR_HELPER_URL="http://127.0.0.1:8330" NEAR_HELPER_ACCOUNT="test.near
\"ed25519:2ykcMLiM7vCmsSECcgfmUzihBtNdBv7v2CxNi94sNt4R8ar4xsrMMYvtsSNGQDfSRhNWXEnZvgx2wzS9ViBiS9jW\"})
ed25519:2ykcMLiM7vCmsSECcgfmUzihBtNdBv7v2CxNi94sNt4R8ar4xsrMMYvtsSNGQDfSRhNWXEnZvgx2wzS9ViBiS9jW"})
test.near" NEAR_EXPLORER_URL="http://127.0.0.1:8331" near'

  ACTION If you want the 'local_near' command available in all your new terminal windows, add the above alias into your .bash_profile/.bashrc/.zshrc
         file and open a new terminal window.

  ACTION To stop your cluster, run the following:

         kurtosis enclave stop near

  ACTION To remove your cluster, run:

         kurtosis clean -a

============================================================ SUCCESS ================================================================================
```

:::tip

The URLs and validator key value above will be the same for each run of Kurtosis, so you can safely use these values in your config files.

:::

:::tip

If you're running Kurtosis on a remote machine, you'll also need to:

- Replace the `127.0.0.1` IP addresses in the environment variables with the IP address of your remote machine
- Copy the validator key from where it lives on the machine running Kurtosis (in `NEAR_CLI_LOCALNET_KEY_PATH`) to somewhere on your local machine
- Adjust the value of the `NEAR_CLI_LOCALNET_KEY_PATH` on your local machine to match the location you stored the key at

:::

</details>

If you ever forget the above URLs, you can inspect the cluster:

```
kurtosis enclave inspect near
```

### Setup Environment Variables

After deploying your Kurtosis NEAR Package, you will need to setup some environment variables to make life a lot easier. Notice the **ACTION** sections in your terminal log from the package deployment. You will be using these exact values to setup these variables.

1. Follow the first ACTION item from the deployment log by copying all of the export commands and running them in your terminal.

**Example exports: (DO NOT COPY ~ yours will be slightly different)**

```bash
export NEAR_ENV="local"
export NEAR_CLI_LOCALNET_NETWORK_ID="localnet"
export NEAR_NODE_URL="http://127.0.0.1:8332"
export NEAR_CLI_LOCALNET_KEY_PATH="/Users/zerix/.neartosis/2022-06-03T18.04.32/validator-key.json"
export NEAR_WALLET_URL="http://127.0.0.1:8334"
export NEAR_HELPER_URL="http://127.0.0.1:8330"
export NEAR_HELPER_ACCOUNT="test.near"
export NEAR_EXPLORER_URL="http://127.0.0.1:8331"
```

2. Proceed to the second ACTION item which asks you to create an alias for `local_near`. This is what we will use when running [`near-cli`](/tools/near-cli) commands with our test environment.

**Example alias: (DO NOT COPY ~ yours will be slightly different)**

```bash
alias local_near='NEAR_ENV="local" NEAR_CLI_LOCALNET_NETWORK_ID="localnet" NEAR_NODE_URL="http://127.0.0.1:8332" NEAR_CLI_LOCALNET_KEY_PATH="/Users/zerix/.neartosis/2022-06-03T18.04.32/validator-key.json" NEAR_WALLET_URL="http://127.0.0.1:8334" NEAR_HELPER_URL="http://127.0.0.1:8330" NEAR_HELPER_ACCOUNT="test.near" NEAR_EXPLORER_URL="http://127.0.0.1:8331" near'
```

Now replacing `near` with `local_near` when running [`near-cli`](/tools/near-cli) commands will perform these actions in your local test environment.

### Testing

Ensure that your alias is working correctly by checking the state of the root account `test.near`.

Run the following in your terminal:

```bash
local_near state test.near
```

This should return something similar to the following output:

```bash
Loaded master account test.near key from /Users/zerix/.neartosis/2022-06-03T18.04.32/validator-key.json with public key = ed25519:3Kuyi2DUXdoHgoaNEvCxa1m6G8xqc6Xs7WGajaqLhNmW
Account test.near
{
  amount: '1000000000000000000000000000000000',
  block_hash: 'G8jx4pYgqFSFSCDyM9MvVYj3HAdgRuxhkAHGweNhUNrY',
  block_height: 224,
  code_hash: '11111111111111111111111111111111',
  locked: '50000000000000000000000000000000',
  storage_paid_at: 0,
  storage_usage: 182,
  formattedAmount: '1,000,000,000'
}
```

**Congratulations! Setup is complete and you are ready to start exploring your local NEAR blockchain!** üéâ

:::tip

The Kurtosis Team has created a great [video presentation](https://www.loom.com/share/8a1b8e2138334a81a380f5d523fba27e) that covers the above steps as well as demoing the functionality of this local network setup.

:::

---

## Using Wallet and Explorer

### Local NEAR Wallet

Now that you have [everything setup](#setup), create an account using your local NEAR Wallet at 127.0.0.1:8334.

![Local wallet landing page](/docs/assets/kurtosis/local-wallet-landing-page.png)

The account creation is exactly the same as on mainnet or testnet but **only the passphrase recovery mode** will work here. Also note that the root account is `test.near` instead of `testnet` or `mainnet`. This means that all the accounts you create will be [subaccounts](/concepts/protocol/account-model#subaccounts) of `test.near`. (ex. `benji.test.near`)

:::tip

Because the Wallet will start on the same host and port, and the Wallet stores your account information in your browser's local storage, if you've created an account with a previous Kurtosis network then the Wallet will be storing the old account's information (which won't work with your new network). If this is the case for you, you'll need to clear the Wallet's storage by visiting [your Chrome's local storage](chrome://settings/siteData?searchSubpage=127.0.0.1), removing the `127.0.0.1` entry, and refreshing the Wallet.

:::

Now that you've created an account, try interacting with it using the local CLI. In order to use this account you will need to "login" with it via CLI which will save a full access key locally for that account. [`near login`](/tools/near-cli#near-login) is the command to perform this action but as you are on `localnet` you will need to replace `near` with `local_near`.

```bash
local_near login
```

This launches the local wallet site and will ask for confirmation for this action. Once you authorize you should see confirmation in your terminal similar to this:

```bash
Logged in as [ kevin.test.near ] with public key [ ed25519:8EaALn... ] successfully
```

- Export your account ID to an environment variable by running the following: (replacing YOUR_ACCOUNT_ID)

```bash
export ACCOUNT_ID=YOUR_ACCOUNT_ID
```

- Now create a test transaction by sending 1 $NEAR to the root account `test.near`:

```bash
local_near send $ACCOUNT_ID test.near 1
```

<details>
<summary>Example response: </summary>

```bash
Sending 1 NEAR to test.near from kevin.test.near
Loaded master account test.near key from /Users/zerix/.neartosis/2022-06-03T18.04.32/validator-key.json with public key = ed25519:3Kuyi2DUXdoHgoaNEvCxa1m6G8xqc6Xs7WGajaqLhNmW
Transaction Id 3e3H5zqj9noKGYTCMqeZ5pb4NWK7tQsjYKak6ybtpgvD
To see the transaction in the transaction explorer, please open this url in your browser
http://127.0.0.1:8331/transactions/3e3H5zqj9noKGYTCMqeZ5pb4NWK7tQsjYKak6ybtpgvD
```

</details>

### Local NEAR Explorer

Again, now that you have [everything setup](#setup) you can view the transaction details of the command you just performed at the end of [the last section](#local-near-wallet). Notice that the last line of the terminal log displays a link to the transaction details in your local NEAR Explorer.

```bash
Sending 1 NEAR to test.near from kevin.test.near
Loaded master account test.near key from /Users/zerix/.neartosis/2022-06-03T18.04.32/validator-key.json with public key = ed25519:3Kuyi2DUXdoHgoaNEvCxa1m6G8xqc6Xs7WGajaqLhNmW
Transaction Id 3e3H5zqj9noKGYTCMqeZ5pb4NWK7tQsjYKak6ybtpgvD
To see the transaction in the transaction explorer, please open this url in your browser
http://127.0.0.1:8331/transactions/3e3H5zqj9noKGYTCMqeZ5pb4NWK7tQsjYKak6ybtpgvD
```

- Click on this link or copy/paste it into your browser:

![Local explorer sending 1 NEAR](/docs/assets/kurtosis/local-explorer-send-funds.png)

Here everything behaves exactly like the `testnet` or `mainnet` NEAR Explorer except it is retrieving data from your local NEAR blockchain!

- If you ever need to open your local NEAR Explorer, you can always visit 127.0.0.1:8331 or run:

```bash
echo $NEAR_EXPLORER_URL
```

**Example Response:**

```bash
http://127.0.0.1:8331
```

![Localnet explorer](/docs/assets/kurtosis/localnet-explorer.png)

---

## Deploy a Smart Contract

With everything setup and your `test.near` account created, it's time to deploy a smart contract on `localnet`. For this example you will deploy an NFT use a pre-compiled WASM smart contract from [this NFT example](https://github.com/near-examples/nft-tutorial.git).

- Download the smart contract:

```
curl -o ~/main.wasm https://github.com/near-examples/nft-tutorial/raw/main/out/main.wasm -L
```

- Deploy the smart contract:

```
local_near deploy --wasmFile ~/main.wasm --accountId $ACCOUNT_ID
```

<details>
<summary>Example response: </summary>

```
Loaded master account test.near key from /Users/benjaminkurrek/.neartosis/2021-12-02T13.37.41/validator-key.json with public key = ed25519:AnLHi4ZAxfxFAQSXniycyZS6dpBqxhmVZH3zBCZbqAS6
Starting deployment. Account id: goteam.test.near, node: http://127.0.0.1:62285, helper: http://127.0.0.1:62286, file: /Users/benjaminkurrek/main.wasm
Transaction Id 7atHm2piVehEitYeMF2FxWuRJVd6ZdRQEo3K83P98GuR
To see the transaction in the transaction explorer, please open this url in your browser
http://127.0.0.1:62290/transactions/7atHm2piVehEitYeMF2FxWuRJVd6ZdRQEo3K83P98GuR
Done deploying to goteam.test.near
```

</details>

- Click on the clink to the Explorer and verify that the contract was deployed:

![Local explorer contract deployed](/docs/assets/kurtosis/local-explorer-contract-deployed.png)

Now, let's interact with the deployed contract.

- First, initialize the contract by running the following command:

```bash
local_near call $ACCOUNT_ID new_default_meta '{"owner_id": "'$ACCOUNT_ID'"}' --accountId $ACCOUNT_ID
```

This will initialize the contract with some default metadata and set our account ID as the owner of the contract.

- Now mint your first NFT!

```bash
local_near call $ACCOUNT_ID nft_mint '{"token_id": "team_token", "metadata": { "title": "Go Team!", "description": "Go Team!", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif", "copies": 1}, "receiver_id": "'$ACCOUNT_ID'"}' --accountId $ACCOUNT_ID --amount 0.1
```

Once the NFT has been minted, you can view the token on the local wallet's collectibles tab. If you already had the wallet site open, simply refresh. Otherwise open your local NEAR Wallet instance and view your collectible.

![Local wallet collectibles tab](/docs/assets/kurtosis/local-wallet-collectibles-tab.png)

We won't spoil what the NFT is, but once you switch over to the collectibles tab your beautiful token should be there!

---

## Connecting a dApp to `localnet`

The ability to develop decentralized applications locally is a dream come true for dApp developers and the Kurtosis NEAR Package really simplifies this process. Here you'll integrate `localnet` into one of the examples at [near.dev](http://near.dev).

### Clone Example dApp

- Clone the [NEAR Guestbook](https://github.com/near-examples/guest-book-examples) repository:

```bash
git clone https://github.com/near-examples/guest-book-examples.git
```

### Configure Network

- Open the `src/config.js` file inside the guestbook repo and scroll down to the `local` config:

```javascript
case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
        contractName: CONTRACT_NAME
      };
```

Here you will need to update all of the values **except** the `contractName`. Copy the following into your `local` case. This will automatically assign the config to your environment variables if you've specified them. This way, you don't need to change anything when running new enclaves.

```javascript
case 'local':
      return {
            networkId: process.env.NEAR_CLI_LOCALNET_NETWORK_ID || 'local',
            nodeUrl: process.env.NEAR_NODE_URL || 'http://localhost:3030',
            keyPath: process.env.NEAR_CLI_LOCALNET_KEY_PATH || `${process.env.HOME}/.near/validator_key.json`,
            walletUrl: process.env.NEAR_WALLET_URL || 'http://localhost:4000/wallet',
            contractName: CONTRACT_NAME,
        };
```

The last thing you will need to do is set your `NODE_ENV` in your terminal to `local` so your dApp will use the values we configured above.

- Run:

```bash
export NODE_ENV=local
```

**Your dApp is now fully configured to use `localnet`!** üéâ

### Create Contract Account

As mentioned earlier, you do not need to change the `contractName` in the `config.js` file you updated earlier. This is an environment variable you will configure now. Let's quickly create a subaccount from [the account you created earlier](#local-near-wallet) to deploy the guest-book contract to.

- Using the `local_near CLI`, run the following command:

```bash
local_near create-account guest-book.$ACCOUNT_ID --masterAccount $ACCOUNT_ID --initialBalance 5
```

**Example Response:**

```bash
Loaded master account test.near key from /Users/benjaminkurrek/.neartosis/2021-12-02T13.37.41/validator-key.json with public key = ed25519:AnLHi4ZAxfxFAQSXniycyZS6dpBqxhmVZH3zBCZbqAS6
Saving key to 'undefined/localnet/guest-book.goteam.test.near.json'
Account guest-book.goteam.test.near for network "localnet" was created.
```

- Export the `CONTRACT_NAME` environment variable as the account you just created:

```bash
export CONTRACT_NAME=guest-book.$ACCOUNT_ID
```

### Deploy Contract to `localnet`

With the network setup and contract account created you are now ready to launch your dApp!

- Run the following command in the root directory of the guest book repo:

```bash
yarn && yarn start
```

**Example Response:**

![Local dApp build](/docs/assets/kurtosis/local-dapp-build.png)

- Open the dApp by clicking on the server address in the terminal:

```bash
Server running at http://localhost:1234
‚ú®  Built in 1.20s.
```

You should see the Guest Book landing page:

![Local Guest Book Landing Page](/docs/assets/kurtosis/local-guest-book-landing.png)

:::tip

If you run into any problems signing into try clearing your browser's local storage. If you've used the guest-book before your browser might think you're still logged in with your `testnet` account and it will throw an error saying it can't find that account on `localnet`.

:::

Once you've logged in, you can sign a message with an optional donation.

![Local Guest Book Signed Message](/docs/assets/kurtosis/local-guest-book-signed-message.png)

- Sign the Guest Book which will create a transaction on `localnet`.

- Once complete, open your local NEAR explorer and you can view the transaction you just created!

![Local Explorer Signed Transaction](/docs/assets/kurtosis/local-explorer-signed-transaction.png)

**Congratulations! You've successfully deployed and interacted with a dApp on a local NEAR blockchain!** üéâ

---

## Managing NEAR Pacakages

The Kurtosis NEAR Pacakages you create will continue to run on your local machine for as long as your Docker engine is running. This package runs inside of a Kurtosis "enclave" which is an environment isolated from both your computer and other enclaves. In practice, this means that you can have multiple independent local NEAR clusters running on your machine simply by rerunning the script we executed from the [setup instructions](#setup).

### View Package Status

- To see the status of your existing enclaves, run:

```bash
kurtosis enclave ls
```

### View Package Details

- To see detailed information about an enclave, copy an enclave ID and run:

```bash
kurtosis enclave inspect near
```

### Terminate Package

- To shut down your NEAR Package and free up resources on your machine, run the following:

```bash
kurtosis enclave stop near
```

:::note

You will not be able to restart the cluster! If this is something you need, please [file an issue here](https://github.com/kurtosis-tech/kurtosis-cli-release-artifacts) so we can prioritize it.

:::

### Delete Package

- Stopping an enclave leaves its resources intact so that you can examine them if need be. To destroy a stopped enclave and free its resources, run:

```
kurtosis clean
```

### Delete All Package

If you would like to destroy _all_ enclaves, regardless of if they're running, pass the `-a` flag to `clean` like so:

```
kurtosis clean -a
```

This can be a handy way to clear all your Kurtosis data.

'''
'''--- docs/2.build/2.smart-contracts/testing/unit-test.md ---
---
id: unit-test
title: Unit Testing
#sidebar_label: üß´ Unit Testing
---
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Unit tests allow you to test the contract methods individually. They are suitable to check the storage is updated correctly, and that methods return their expected values. They are written in the contract's language and execute locally.

If you used one of our [examples](https://github.com/near-examples/docs-examples) as template, then you simply need to navigate to the contract's folder, and use `yarn test`. In case you didn't, then we recommend you copy the necessary node files (e.g. `package.json`) from one of our templates.

:::tip
You can run `yarn test` from the root folder of each project to run both unit and [integration](integration-test.md) tests.
:::

---

## Snippet I: Testing a Counter

The tests in the [Counter Example](https://github.com/near-examples/counters) rely on basic functions to check that the `increment`, `decrement`, and `reset` methods work properly.

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/counters/blob/main/contract-rs/src/lib.rs"
            start="50" end="71" />
  </Language>
</CodeTabs>

---

## Snippet II: Modifying the Context

While doing unit testing you can modify the [Environment variables](../anatomy/environment.md) through the `VMContextBuilder`. This will enable you to, for example, simulate calls from different users, with specific attached deposit and GAS. Here we present a snippet on how we test the `donate` method from our [Donation Example](https://github.com/near-examples/donation-examples) by manipulating the `predecessor` and `attached_deposit`.

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/donation-examples/blob/main/contract-rs/src/lib.rs"
            start="59" end="117" />
  </Language>
</CodeTabs>

---

## ‚ö†Ô∏è Limitations

Unit tests are useful to check for code integrity, and detect basic errors on isolated methods. However, since unit tests do not run on a blockchain, there are many things which they cannot detect. Unit tests are not suitable for:

- Testing [gas](../anatomy/environment.md) and [storage](../anatomy/storage.md) usage
- Testing [transfers](../anatomy/actions.md)
- Testing [cross-contract calls](../anatomy/crosscontract.md)
- Testing complex interactions, i.e. multiple users depositing money on the contract

For all these cases it is necessary to **complement** unit tests with [integration tests](integration-test.md).

'''
'''--- docs/2.build/2.smart-contracts/what-is.md ---
---
id: what-is
title: What is a Smart Contract?
sidebar_label: What is a Contract?
---

Smart contracts are pieces of **executable code** that live in a NEAR account. They can **store data**, **perform transactions** in the account‚Äôs name, and **expose methods** so other accounts can interact with them.

![img](/docs/assets/welcome-pages/contracts-landing.png)

Do not worry if you don't know how smart-contract blockchains work. As a developer, it is sufficient to understand that NEAR smart-contracts:
1. Have **limited** computational resources.
2. Interact with other contracts in an **asynchronous** way.
3. Deal with **real money**, for which security must be a top concern.

:::info HTTP Requests and Smart Contracts

Smart contracts **cannot perform HTTP requests**, meaning they can't fetch data from outside the NEAR network.

:::

---

## Where do contracts live?
Smart Contracts are deployed into [**NEAR accounts**](../../1.concepts/protocol/account-model.md). Any NEAR account can hold a contract, needing to pay for the **contract's code** and the **data it stores**. 

Once in an account, anyone can interact with the contract. Thanks to the underlying network structure, executing code from a contract is both **fast** (avg. 1.4s finality) and **cheap**. Moreover, **read-only** operations are **free for everyone**.

:::tip
Storing 100kb costs 1‚ìÉ, so deploying a contract generally costs only a few $NEARs.
:::

---

## Development flow

Just like any piece of software, smart contracts have a development flow - starting with its creation and ending with monitoring it, all of which we cover in our documentation.

![img](/docs/assets/welcome-pages/contract-lifecycle.png)
 "build/building-smart-contracts/testing/introduction",
The development flow can be summarized as follows:
- [**Scaffold**](./quickstart.md): The simplest way to create a project is by starting from a template.
- [**Build**](./anatomy/anatomy.md): Write a contract using Rust or Javascript.
- [**Test**](./testing/introduction.md): Our Sandbox enables to simulate interactions with one or multiple contracts in a realistic environment.
- [**Deploy**](./release/deploy.md): After making sure the contract is secure, developers can deploy the contract into their accounts.
- [**Use**](https://mynearwallet.com): Any user can interact with the contract through their NEAR Wallet.
- [**Monitor**](../6.data-infrastructure/what-is.md): The contract's activity can be monitored through simple APIs.

#### Supported Languages
During the whole cycle, developers can choose between [JavaScript](https://www.learn-js.org/) and [Rust](https://www.rust-lang.org/), allowing them to use their favorite language at each step of their journey.

<details>

<summary> Other languages </summary>

Theoretically, you can use any language that compiles to Wasm for developing NEAR smart contract. However, in order to have a user-friendly experience we would need to provide a library that wraps around low-level runtime APIs, while also offering other high-level functionalities.

We envision that in the future, more languages will be supported and the support will be done through the effort from the wider community, not just NEAR alone.

</details>

---

## Contract primitives
Contract primitives such as FT, NFT, and DAOs are fundamental building blocks that can be combined to create awesome user experiences such as reward tokens, decision-making tools, and marketplaces. 

:::tip

Check our section on [primitives](../5.primitives/what-is.md) to learn more about them

:::

'''
'''--- docs/2.build/3.near-components/anatomy/bos-components.md ---
---
id: bos-components
title: Historical data
sidebar_label: Handling Historical data
---

Building components that handle historical blockchain data require dedicated solutions that manage the data and reduce the latency of requests, as it's not possible to scan the whole blockchain when a user makes a request.

A simple solution for developers building on NEAR is using [QueryAPI](../environment.md), a fully managed solution to build indexer functions, extract on-chain data, store it in a database, and be able to query it using GraphQL endpoints.

:::tip
Learn more about QueryAPI in this [QueryAPI Overview](../environment.md) article.
:::

---

## Tutorials

For a technical implementation deep-dive, check these QueryAPI tutorials:

  - [Posts Indexer tutorial](../../../3.tutorials/near-components/indexer-tutorials/posts-indexer.md): this indexer creates a new row in a pre-defined database for every new Social post found on the blockchain.
  - [Hype Indexer tutorial](../../../3.tutorials/near-components/indexer-tutorials/hype-indexer.md): this indexer creates a new row in a pre-defined database for every new Social post or comment found on the blockchain that contains either `PEPE` or `DOGE` in the contents.
  - [Social Feed Indexer tutorial](../../../3.tutorials/near-components/indexer-tutorials/feed-indexer.md): this indexer keeps track of new posts, comments, and likes on Social, so a social feed can be rendered quickly.

---

## GraphQL queries 

Using [QueryAPI's GraphiQL](../../6.data-infrastructure/query-api/index-function.md#mutations-in-graphql) tab, you can access the GraphiQL Explorer that provides a user friendly GraphQL playground, where you can view and create queries and mutations based on the DB schema that you defined for the indexer.

![QueryAPI Indexer Dashboard](/docs/assets/QAPIgraphiql.png)

You can easily set some fields and select the returning data
that you want, and the tool will build a query on the mutation panel on the right.
Then you can copy the resulting query, either in your JavaScript code so that you pass actual
data manually, or you pass in the mutation data object as a second parameter.

For example, if you go and add a new mutation, click <kbd>+</kbd>, then you can do a bunch of actions here, such as creating, deleting, or inserting posts into your table.

![Playground](/docs/assets/QAPIScreen.gif)

If you want to test your mutation, using [Debug Mode](../../6.data-infrastructure/query-api/index-function.md#local-debug-mode) you can add a specific
block to the list, and then play it to see how it works. 
Based on the indexer logic you defined, you'll get a call to the GraphQL mutation with the object
and data passed into it.

:::tip Video Walkthrough

**Tip:** watch the video on how to [create mutations in GraphQL](https://www.youtube.com/watch?v=VwO6spk8D58&t=781s).

:::

---

## Generate a NEAR component using Playground

Creating a NEAR component from a GraphQL query is simple when using QueryAPI's GraphQL Playground. Just follow these steps:

- go to the GraphiQL tab
- select the query that you want to use
- click on the <kbd>Show GraphiQL Code Exporter</kbd> button
- get some default code here, copy it,
- go to the NEAR sandbox, paste it.

This will set up some boilerplate code to execute the GraphQL query, add the query that you had
in your playground and then call that query, extract the data and render it using the
render data function.

Once you have the NEAR component code, you can test it out by going to [the sandbox](https://near.org/sandbox),
pasting the generated code, and then selecting <kbd>Component Preview</kbd>.
Next, you can create a nice UI over this boilerplate code, and publish your new NEAR component.

#### Component Examples

- [Activity Feed widget](https://near.org/near/widget/ComponentDetailsPage?src=roshaan.near/widget/user-activity-feed&tab=source) running on [near.org](https://near.org)

'''
'''--- docs/2.build/3.near-components/anatomy/builtin-components.md ---
---
id: builtin-components
title: List of Native Components
---

import {WidgetEditor} from "@site/src/components/widget-editor"

A list of all the built-in components to be used on Near Components.

---

## Widget

The predefined component `Widget` allows you to include an existing component into your code, thus enabling to create complex applications by composing components.

<WidgetEditor id='1' height="100px">

```ts
const props = { name: "Anna", amount: 3 };

return <Widget src="influencer.testnet/widget/Greeter" props={props} />;
```

</WidgetEditor>

---

## IpfsImageUpload

A built-in component that enables users to directly upload an image to the InterPlanetary File System (IPFS).

<WidgetEditor id='2' height="200px">

```js
State.init({image: {}})

return <>
  <p> Raw State: {JSON.stringify(state.image)} </p>
  <IpfsImageUpload image={state.image} />
</>
```

</WidgetEditor>

---

## Files

A built-in component that enables to input files with drag and drop support. Read more about the `Files` component [here](https://www.npmjs.com/package/react-files).

<WidgetEditor id='3' height="220px">

```js
const [img, setImg] = useState(null);
const [msg, setMsg] = useState('Upload an Image')

const uploadFile = (files) => {
  setMsg('Uploading...')

  const file = fetch(
    "https://ipfs.near.social/add",
    {
      method: "POST",
      headers: { Accept: "application/json" },
      body: files[0]
    }
  )

  setImg(file.body.cid)
  setMsg('Upload an Image')
}

return <>
  <Files
    multiple={false}
    accepts={["image/*"]}
    clickable
    className="btn btn-outline-primary"
    onChange={uploadFile}
  >
    {msg}
  </Files>
  {img ? <div><img src={`https://ipfs.near.social/ipfs/${img}`} /></div> : ''}
</>;
```

</WidgetEditor>

---

## Markdown

A component that enables to render Markdown.

<WidgetEditor id='4' height="60px">

```jsx
const markdown = (`
## A title

This is some example **markdown** content, with _styled_ text
`)

return <Markdown text={markdown} />;
```

</WidgetEditor>

:::tip Markdown Editor

Checkout this [Markdown Editor](https://near.social/#/mob.near/widget/MarkdownEditorIframeExample), and [its source code](https://near.social/mob.near/widget/WidgetSource?src=mob.near/widget/MarkdownEditorIframeExample).
:::

---

## OverlayTrigger

Used to display a message or icon when the mouse is over a DOM element.

<WidgetEditor id='5' height="200px">

```javascript
const [show, setShow] = useState(false);

const overlay = (
  <div className='border m-3 p-3'>
    This is the overlay Message
  </div>
);

return (
  <OverlayTrigger
    show={show}
    delay={{ show: 250, hide: 300 }}
    placement='auto'
    overlay={overlay}
  >
    <button
      className="btn btn-outline-primary"
      onMouseEnter={() => setShow(true)}
      onMouseLeave={() => setShow(false)}
    >
      Place Mouse Over Me
    </button>
  </OverlayTrigger>
);
```

</WidgetEditor>

<details markdown="1">

<summary> Component props </summary>

The OverlayTrigger component has several props that allow you to customize its behavior:

| Prop        | Description                                                                                                                                                                                                                                                                  |
|-------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `show`      | A boolean value that determines whether the overlay is currently visible or not.                                                                                                                                                                                             |
| `trigger`   | An array of events that trigger the display of the overlay. In this example, the `trigger` prop is set to `["hover", "focus"]`, which means that the overlay will be displayed when the user hovers over or focuses on the element.                                          |
| `delay`     | An object that specifies the delay before the overlay is displayed or hidden. In this example, the `delay` prop is set to `{ show: 250, hide: 300 }`, which means that the overlay will be displayed after a 250-millisecond delay and hidden after a 300-millisecond delay. |
| `placement` | A string that specifies the position of the overlay relative to the trigger element. In this example, the `placement` prop is set to `"auto"`, which means that the position will be automatically determined based on available space.                                      |
| `overlay`   | The content that will be displayed in the overlay. In this example, the `overlay` prop is set to a `<div>` element containing the message "This is the overlay message.                                                                                                      |
</details>

---

## InfiniteScroll

Infinitely load a grid or list of items. This component allows you to create a simple, lightweight infinite scrolling page or element by supporting both window and scrollable elements.

Read more about the [react-infinite-scroller](https://www.npmjs.com/package/react-infinite-scroller) package.

<WidgetEditor id='6' height="200px">

```js
const allNumbers = Array.from(Array(100).keys())
const [lastNumber, setLastNumber] = useState(0);
const [display, setDisplay] = useState([]);

const loadNumbers = (page) => {
  const toDisplay = allNumbers
    .slice(0, lastNumber + page*10)
    .map(n => <p>{n}</p>)

  console.log(lastNumber + page*10)
  setDisplay(toDisplay);
  setLastNumber(lastNumber + page*10);
};

return (
  <InfiniteScroll
    loadMore={loadNumbers}
    hasMore={lastNumber < allNumbers.length}
    useWindow={false}
  >
    {display}
  </InfiniteScroll>
);
```

</WidgetEditor>

---

## TypeAhead

Provides a type-ahead input field for selecting an option from a list of choices. More information about the component can be found [here](https://github.com/ericgio/react-bootstrap-typeahead).

<WidgetEditor id='7' height="300px">

```jsx
const [selected, setSelected] = useState([]);
const options = ["Apple", "Banana", "Cherry", "Durian", "Elderberry"];

return <>
  <Typeahead
    options={options}
    multiple
    onChange={v => setSelected(v)}
    placeholder='Choose a fruit...'
  />
  <hr />
  <p> Selected: {selected.join(', ')} </p>
</>;
```

</WidgetEditor>

---

## Styled Components

[Styled Components](https://styled-components.com/) is a popular library for styling React components using CSS-in-JS.

<WidgetEditor id='8' height="80px">

```jsx
const Button = styled.button`
  /* Adapt the colors based on primary prop */
  background: ${(props) => (props.primary ? "palevioletred" : "white")};
  color: ${(props) => (props.primary ? "white" : "palevioletred")};

  font-size: 1em;
  margin: 1em;
  padding: 0.25em 1em;
  border: 2px solid palevioletred;
  border-radius: 10px;
`;

return (
  <div>
    <Button>Normal</Button>
    <Button primary>Primary</Button>
  </div>
);
```

</WidgetEditor>

---

## Tooltip

Displays a message once the mouse hovers over a particular item. This component was imported from [`React-Bootstrap`](https://react-bootstrap-v3.netlify.app/components/tooltips/).

<WidgetEditor id='9' height="120px">

```js
const tooltip = (
  <Tooltip id="tooltip">
    <strong>Holy guacamole!</strong> Check this info.
  </Tooltip>
);

return <>
  <OverlayTrigger placement="left" overlay={tooltip}>
    <button>Holy guacamole!</button>
  </OverlayTrigger>

  <OverlayTrigger placement="top" overlay={tooltip}>
    <button>Holy guacamole!</button>
  </OverlayTrigger>

  <OverlayTrigger placement="bottom" overlay={tooltip}>
    <button>Holy guacamole!</button>
  </OverlayTrigger>

  <OverlayTrigger placement="right" overlay={tooltip}>
    <button>Holy guacamole!</button>
  </OverlayTrigger>
</>
```

</WidgetEditor>
'''
'''--- docs/2.build/3.near-components/anatomy/near.md ---
---
id: near
title: Interacting with Near
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {WidgetEditor} from "@site/src/components/widget-editor"

The components can use the `Near` object to interact with smart contracts in the NEAR blockchain. There are three methods:

- [`Near.view`](#nearview)
- [`Near.block`](#nearblock)
- [`Near.call`](#nearcall)

---

## Near.view
Queries a read-only method from a NEAR smart contract, returning:
- **`null`**: If the query is still being processed
- **`undefined`**: If the query is complete and no value was returned by the contract
- A **value**: If the query is complete and a value was returned by the contract

<WidgetEditor>

```js
const greeting = Near.view("hello.near-examples.testnet", "get_greeting", {});

if (greeting === null) return "Loading...";

return `The contract says: ${greeting}`;
```

</WidgetEditor>

<details markdown="1">
<summary> Parameters </summary>

| param              | required     | type            | description                                                                                                                    |
|--------------------|--------------|-----------------|--------------------------------------------------------------------------------------------------------------------------------|
| `contractName`     | **required** | string          | Name of the smart contract                                                                                                     |
| `methodName`       | **required** | string          | Name of the method to call                                                                                                     |
| `args`             | _optional_   | object instance | Arguments to pass to the method                                                                                                |
| `blockId/finality` | _optional_   | string          | Block ID or finality of the transaction                                                                                        |
| `subscribe`        | _optional_   | boolean         | This feature allows users to subscribe to a query, which automatically refreshes the data for all subscribers every 5 seconds. |

</details>

:::tip
Notice that the optional parameter `subscribe` allows users to subscribe to a query, which automatically refreshes the data every 5 seconds.
:::

<hr className="subsection" />

#### Avoiding a Common Pitfall

If you want to initialize the state with the result of a `Near.view` call, be sure to check first that the value was obtained, to avoid initializing the state with `null`.

<WidgetEditor>

```js
const contractGreet = Near.view("hello.near-examples.testnet", "get_greeting", {});

// you need to first check that the value was obtained
if (contractGreet === null) return "Loading...";

const [greeting, setGreeting] = useState(contractGreet);

return `The contract says: ${greeting}`;
```

</WidgetEditor>

If you don't want to delay the render of your component, you can also use the `useEffect` hook to control the value returned by `Near.view`

<WidgetEditor>

```js
const contractGreet = Near.view('hello.near-examples.testnet', 'get_greeting');

const [greeting, setGreeting] = useState('Loading ...');

useEffect(() => {
  if (contractGreet !== null) setGreeting(contractGreet);
}, [contractGreet]);

return `The contract says: ${greeting}`;
```

</WidgetEditor>

---

## Near.call

Calls a smart contract method from the blockchain. Since a transaction needs to be signed, the user must be logged in in order to make the call.

<WidgetEditor>

```js
if (!context.accountId) return "Please login...";

const onClick = () => {
  Near.call(
    "hello.near-examples.testnet",
    "set_greeting",
    { greeting: "Hello!" }
  );
};

return <>
  <h5> Hello {context.accountId} </h5>
  <button onClick={onClick}> Set Greeting </button>
</>;
```
</WidgetEditor>

<details markdown="1">
<summary> Parameters </summary>

| param          | required     | type            | description                                                                 |
|----------------|--------------|-----------------|-----------------------------------------------------------------------------|
| `contractName` | **required** | string          | Name of the smart contract to call                                          |
| `methodName`   | **required** | string          | Name of the method to call on the smart contract                            |
| `args`         | _optional_   | object instance | Arguments to pass to the smart contract method as an object instance        |
| `gas`          | _optional_   | string / number | Maximum amount of gas to be used for the transaction (default 300Tg)        |
| `deposit`      | _optional_   | string / number | Amount of NEAR tokens to attach to the call as deposit (in yoctoNEAR units) |

</details>

:::tip
Remember that you can login using the `Login` button at the navigation bar.
:::

---

## Near.block

Queries a block from the blockchain.

<WidgetEditor height="40px">

```js
return Near.block("optimistic");
```

</WidgetEditor>

<details markdown="1">
<summary> Parameters </summary>

| param                   | required   | type | description                                                                                                                                       |
|-------------------------|------------|------|---------------------------------------------------------------------------------------------------------------------------------------------------|
| `blockHeightOrFinality` | _optional_ | any  | The block height or finality level to use for the blockchain query (desired block height, or one of the following strings: `optimistic`, `final`) |

- desired block height: The height of the specific block to query, expressed as a positive integer
- `optimistic`: Uses the latest block recorded on the node that responded to your query (< 1 second delay)
- `final`: a block that has been validated on at least 66% of the nodes in the network (approx. 2s)

</details>
'''
'''--- docs/2.build/3.near-components/anatomy/notifications.md ---
---
id: notifications
title: Social Notifications
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {WidgetEditor} from "@site/src/components/widget-editor"

Applications such as [NEAR Social](https://near.social) and the [NEAR Dev Portal](https://dev.near.org/) allow components to send notifications to their users.

Notifications are great to inform users in real time that something has happened, and can be [easily incorporated into any web app](../../../3.tutorials/near-components/push-notifications.md).

---

## Sending Notifications 

Notifications are implemented as a particular case of [indexed actions](./social.md#socialindex).

This means that to send a notification we just need to `index` the `notify` action for the indexer, with a `key` and a `value`.

- The `key` tells **which account** to notify.
- The `value` includes the [notification type](#notification-types) and the item being notified of.

<WidgetEditor>

```js
const notifyMe = () => {
  Social.set({
    index: {
      notify: JSON.stringify({
        key: context.accountId,
        value: "docs notification"
      })
    }
  });
}

return <>
  {context.accountId?
  <button onClick={notifyMe}> Get Notification </button>
  :
  <p> Please login to be notified</p>
  }
</>
```

</WidgetEditor>

In this example, the account executing the code is notifying `mob.near` that they liked their social post created at the block height `102169725`.

---

## Notification Types

Since notifications are indexed actions, anyone can create their own kind of notification.

While there is no standard for notifications, we recommend using the following types:

<Tabs>
  <TabItem value="Custom" default>

```js
  Social.set({
    index: JSON.stringify({
      notify: {
        key: "mob.near",
        value: {
          type: "custom",
          message: "A message in the notification",
          widget: "The widget to open when clicking on the notification",
          params: { parameters: "to pass to the widget", ... },
        },
      }
    })
  });
```

**Note**: currently, only near.org implements custom notifications

</TabItem>

<TabItem value="Like">

```js
  Social.set({
    index: JSON.stringify({
      notify: {
        key: "mob.near",
        value: {
          type: "like",
          item: {
            type: "social",
            path: "mob.near/post/main",
            blockHeight: 102169725
          }
        }
      }
    })
  })
```

**Reference**: [LikeButton](https://near.org/near/widget/ComponentDetailsPage?src=near/widget/LikeButton&tab=source)

</TabItem>

<TabItem value="Comment">

```js
  Social.set({
    index: JSON.stringify({
      notify: {
        key: "nearhacks.near",
        value: {
          type: "comment",
          item: {
            type: "social",
            path: "nearhacks.near/post/main",
            blockHeight: 102224773
          }
        }
      }
    })
  })
```

**Reference**: [CommentButton](https://near.org/near/widget/ComponentDetailsPage?src=near/widget/Comments.Compose&tab=source)

</TabItem>

<TabItem value="Follow">

```js
  Social.set({
    index: JSON.stringify({
      notify: {
        key: "mob.near",
        value: {
          type: "follow",
        }
      }
    })
  })
```

**Reference**: [FollowButton](https://near.org/near/widget/ComponentDetailsPage?src=near/widget/FollowButton&tab=source)

</TabItem>

</Tabs>

:::caution
There is no standard for notifications, but you can contribute to create one [in this public discussion](https://github.com/NearSocial/standards/pull/19/files).
:::

---

## Parsing Notifications

In order to get all notifications for an user, we make a call to the Social indexer.

<WidgetEditor id='1' height="190px">

```js
// login to see your notifications
const accountId = context.accountId || 'influencer.testnet'

const index = Social.index("notify", accountId, {limit: 2, order: "desc", subscribe: true});

return <>
  <h4> Notifications for {accountId} </h4>
  {index.map(e => <> {JSON.stringify(e, null, 2)} <br/></>) }
</>
```

</WidgetEditor>

:::caution
Please notice that anyone can create a notification for the user, and thus some form of filtering might be needed.
:::

:::tip
You can also check how the [Notifications Page](https://near.org/near/widget/ComponentDetailsPage?src=near/widget/NotificationsPage&tab=source) is implemented.
:::

'''
'''--- docs/2.build/3.near-components/anatomy/social.md ---
---
id: social
title: Social Interactions
---

import {WidgetEditor} from "@site/src/components/widget-editor"

NEAR components can natively communicate with the [SocialDB smart contract](https://github.com/NearSocial/social-db) (currently deployed at [social.near](https://nearblocks.io/address/social.near)).

The `SocialDB` is a contract that stores `key-value` pairs, and is used mostly to store social-related data, such as `posts`, `likes`, or `profiles`.

:::tip
Besides user data, the `SocialDB` contract stores **all existing NEAR components**.
:::

---

## Social.get

`Social.get` queries a key from the SocialDB contract and returns the data. The key being queried can contain wildcards.

For example:

  - `alice.near/profile/**`  will match the entire profile data of account alice.near.
  - `alice.near/profile/*` will match all the fields of the profile, but not the nested objects.
  - `alice.near/profile/name` will match only the name field of the profile.
  - `*/widget/*` will match all the widgets of all the accounts.

<br />

<WidgetEditor>

```js
// Ask for the `profile` key of the influencer.testnet account
const profile = Social.get("influencer.testnet/profile/*");

// Ask a component from the influencer.testnet account
const widget = Social.get("influencer.testnet/widget/Greeter");

if(profile === null || widget === null) return "Loading ..."

return (
  <div>
    <p>Profile: {JSON.stringify(profile)}</p>
    <p>Widgets: {JSON.stringify(widget)} </p>
  </div>
);
```

</WidgetEditor>

<details markdown="1">
<summary> Parameters </summary>

| param      | required     | type               | description                  |
|------------|--------------|--------------------|------------------------------|
| `patterns` | **required** | string / string[]  | the path pattern(s)          |
| `finality` | _optional_   | `"final"` / number | the block height or finality |
| `options`  | _optional_   | object             | the `options` object.        |

:::info options object

- `subscribe` _(optional)_: if true, the data will be refreshed every 5 seconds.
- `return_deleted` _(optional)_: whether to return deleted values (as `null`). Default is `false`.

:::

The block height or finality can be used to get the data at a specific block height or finality.
If the block height or finality is not specified, the data will be fetched at the `optimistic` finality (the latest block height).

For block height and finality `final`, instead of calling the NEAR RPC directly, the VM uses the Social API Server to fetch the data.

Social API server indexes the data for SocialDB and allows to fetch the data at any block height with additional options.

It also allows returning more data than an RPC call because it's not restricted by the gas limit.
In general, the API server also serves data faster than the NEAR RPC, because it doesn't execute the contract code in a virtual machine.

</details>

:::tip
While the data is fetching, `Social.get` returns `null`.
:::

---

## Social.getr
`Social.getr` is just a wrapper helper for `Social.get`, it appends `**` to each of the path pattern.

<WidgetEditor>

```js
const profile = Social.getr("influencer.testnet/profile");

return (
  <div>
    <p>Profile: {JSON.stringify(profile)}</p>
  </div>
);
```

</WidgetEditor>

<details markdown="1">
<summary> Parameters </summary>

| param      | required     | type               | description                  |
|------------|--------------|--------------------|------------------------------|
| `patterns` | **required** | string / string[]  | the path pattern(s)          |
| `finality` | _optional_   | `"final"` / number | the block height or finality |
| `options`  | _optional_   | object             | the `options` object.        |

:::info options object

- `subscribe` _(optional)_: if true, the data will be refreshed every 5 seconds.
- `return_deleted` _(optional)_: whether to return deleted values (as `null`). Default is `false`.

:::

</details>

---

## Social.keys

The `keys` method allows to get the list of keys that match a pattern. It's useful for querying the data without reading values.

It also has an additional `options` field that can be used to specify the return type and whether to return deleted keys.

<WidgetEditor height="80">

```js
const data = Social.keys(`influencer.testnet/profile/*`, "final");

return JSON.stringify(data)
```

</WidgetEditor>

<details markdown="1">
<summary> Parameters </summary>

`Social.keys` takes up to 3 arguments:

| param      | required     | type               | description                  |
|------------|--------------|--------------------|------------------------------|
| `patterns` | **required** | string / string[]  | the path pattern(s)          |
| `finality` | _optional_   | `"final"` / number | the block height or finality |
| `options`  | _optional_   | object             | the `options` object.        |

:::info options object

- `subscribe` _(optional)_: if true, the data will be refreshed every 5 seconds.
- `return_type` _(optional)_: either `"History"`, `"True"`, or `"BlockHeight"`. If not specified, it will return the `"True"`.
- `return_deleted` _(optional)_: whether to return deleted values (as `null`). Default is `false`.
- `values_only` _(optional)_: whether to return only values (don't include objects). Default is `false`.

:::

</details>

:::tip
The Social API server supports custom options `return_type: "History"`. For each matching key, it will return an array containing all the block heights when the value was changed in ascending order.
It can be used for building a feed, where the values are overwritten. 
:::

---

## Social.set

Takes a `data` object and commits it to SocialDB. The data object can contain multiple keys, and each key can contain multiple values.

Importantly, a user can only commit to **their own** space in `SocialDB` (e.g. `alice.near` can only write in `alice.near/**`), except if [**given explicit permission**](https://github.com/NearSocial/social-db#permissions) by the owner of another space. 

Each time a user wants to commit data, they will be prompted to confirm the action. On confirming, the user can choose to not be asked again in the future.

<WidgetEditor>

```js
const onClick = () => {
  Social.set({
    post: {
      main: JSON.stringify({
        type: "md",
        text: "I've read the docs!"
      })
    }
  })
}

if(!context.accountId) return "Please login...";

return <>
  <p> Save a message showing some love to the NEAR Docs </p>
  <button onClick={onClick}> Save the Message </button>
</>
```

</WidgetEditor>

<details markdown="1">
<summary> Parameters </summary>

`Social.set` arguments:

 | param     | required     | type   | description                                                                                        |
 |-----------|--------------|--------|----------------------------------------------------------------------------------------------------|
 | `data`    | **required** | object | the data object to be committed. Similar to `CommitButton`, it shouldn't start with an account ID. |
 | `options` | _optional_   | object | optional object.                                                                                   |

:::info options object

- `force` _(optional)_: whether to overwrite the data.
- `onCommit` _(optional)_: function to trigger on successful commit. Will pass the
data that was written (including `accountID`).
- `onCancel` _(optional)_: function to trigger if the user cancels the commit.

:::

</details>

:::tip
By default `Social.set` will omit saving data that is already saved (e.g. if the user already liked a post, it won't save the like again). To force saving the data, pass the `force` option.
:::

---

## Social.index
NEAR Social readily provides an indexer - a service that listen to actions in SocialDB, and caches them so they can be retrieved without needing to interact with the contract.

The indexer is very useful, for example, to rapidly store and retrieve information on all comments for a post. Without the indexer, we would need to check all entries in the contract to see who answered, surely running out of GAS before completion.

<hr className="subsection" />

### Indexing an Action
To index an action we need to add the `index` key to the data being saved, within the `index` key we will save the `action` being indexed, alongside a `key` and a `value` that identifies this specific instance.

<WidgetEditor>

```js
// General form of an indexed action
// {
//   index: {
//     actionName: JSON.stringify({ key, value })
//   }
// }

const onClick = () => {
  Social.set({
    index: {
      readDocs: JSON.stringify({key: "docs", value: "like"})
    } ,
  })
}

return <>
  {context.accountId ?
  <>
    <p> Index an action showing some love to the NEAR Docs </p>
    <button onClick={onClick}> Index Action </button>
  </> :
  <p> Login to index an action </p>}
</>
```

</WidgetEditor>

In the example above we index a `docs` action. In this case the `action` is `docs`, and the `key` that identifies it is `"read"`.

<details markdown="1">

<summary> Standards </summary>

#### Indexing a Post
To index a post, the standard is to save the action `post`, with `{key: "main", value: {type: "md"}`.

```js
{
  index: {
    post: JSON.stringify({
      key: "main",
      value: {type: "md"}
    })
  }
}
```

#### Indexing a Like
To index a like, the standard is to save the action `like`, with `{key: object-representing-the-post, value: {type: "like" }}`

```js
{
  index: {
    like: JSON.stringify({
      key: {type: 'social', path: 'influencer.testnet/post/main', blockHeight: 152959480 },
      value: {type: "like"}})
  }
}
```

</details>

<hr className="subsection" />

### Retrieving Indexed Actions

To retrieve indexed actions we use the `Social.index` method. It takes the `action` and the `key` as arguments, and returns an array of all the indexed values alongside the `blockHeight` in which they were indexed, and which user made the action.

<WidgetEditor>

```js
const readDocs = Social.index("readDocs", "docs")

return <>
  <p> Number of indexed "readDocs" actions with key "docs": {readDocs.length} </p>

  <b>Indexed actions</b>
  {JSON.stringify(readDocs)}
</>
```

</WidgetEditor>

<details markdown="1">
<summary> Parameters </summary>

`Social.index` arguments:

 | param     | required     | type   | description                                                                                |
 |-----------|--------------|--------|--------------------------------------------------------------------------------------------|
 | `action`  | **required** | string | is the `index_type` from the standard, e.g. in the path `index/like` the action is `like`. |
 | `key`     | **required** | string | is the inner indexed value from the standard.                                              |
 | `options` | _optional_   | object | the `options` object.                                                                      |

:::info options object

- `subscribe` _(optional)_: if true, the data will be refreshed every 5 seconds.
- `accountId` _(optional)_: If given, it should either be a string or an array of account IDs to filter values by them. Otherwise, not filters by account Id.
- `order` _(optional)_: Either `asc` or `desc`. Defaults to `asc`.
- `limit` _(optional)_: Defaults to `100`. The number of values to return. Index may return more than index values, if the last elements have the same block height.
- `from` _(optional)_: Defaults to `0` or `Max` depending on order.

:::

</details>
'''
'''--- docs/2.build/3.near-components/anatomy/state.md ---
---
id: state
title: Basics
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {WidgetEditor} from "@site/src/components/widget-editor"

Borrowing from React, Near Components use hooks such as [**`useState`**](#state) and [**`useEffect`**](#useeffect-hook) to handle the state's logic, and [**props**](#props) to receive parameters.

Near Components are stored in the blockchain, for which you will use the `NEAR VM` to [retrieve and execute them in the browser](../../4.web3-apps/integrate-components.md).

Using a VM enforces components to be sandboxed, making them very secure since they cannot access your `LocalStorage` or other elements in the page they are incorporated to. However, because of this, components cannot import external libraries. However, they can [**import functions**](#import) from other components.

---

## State
To handle the component's state you can use `useState` hook. The `useState` hook returns a tuple of two values: the current state and a function that updates it.

<WidgetEditor>

```jsx
const [count, setCount] = useState(0);

return (
  <div>
    <p>You clicked {count} times</p>
    <button onClick={() => setCount(count + 1)}>Click me</button>
  </div>
);

```

</WidgetEditor>

Each time a state variable is updated, the component will be **re-rendered**. This means that the **whole code will run again**.

---

## Props
Each component has access to a local variable named `props` which holds the properties received as input when the component is composed.

<WidgetEditor id='2'>

```jsx
return <>
  <p> This component props: {JSON.stringify(props)} </p>
  <Widget src="influencer.testnet/widget/Greeter" 
          props={{name: "Maria", amount: 2}} />
</>
```

</WidgetEditor>

---

## useEffect Hook

The [`useEffect` hook](https://react.dev/learn/synchronizing-with-effects) is used to handle side effects. It will execute each time one of the dependencies changes.

<WidgetEditor id='3'>

```jsx
const [count, setCount] = useState(0);
const [visible, setVisible] = useState(false);

useEffect(() => {
  if(count > 5) setVisible(true);
}, [count]);

return (
  <div>
    <p>You clicked {count} times</p>
    <p className="alert alert-danger" hidden={!visible}>
      You clicked more than 5 times
    </p>
    <button onClick={() => setCount(count + 1)}>Click me</button>
  </div>
);  
```
</WidgetEditor>

---

## Import

Components can import functions from other components. This is useful to reuse code and to create libraries of components.

<WidgetEditor id='4'>

```jsx
const {add, multiply} = VM.require('influencer.testnet/widget/Math');

return <>
  <p> 2 + 3 = {add(2, 3)} </p>
  <p> 2 * 3 = {multiply(2, 3)} </p>
</>
```

</WidgetEditor>

Where the code of the `Math` component is:

```js
function add(a, b) {
  return a + b;
}

function multiply(a, b) {
  return a * b;
}

return { add, multiply };
```
'''
'''--- docs/2.build/3.near-components/anatomy/web-methods.md ---
---
id: web-methods
title: Web Browser Methods
---

import {WidgetEditor} from "@site/src/components/widget-editor"

NEAR Components have access to classic web methods that enable them to:
- [Fetch](#fetch) data from external sources.
- [Cache](#cache) values to avoid redundant computations.
- Use [LocalStorage](#localstorage) to store data in the web browser.
- Access to the [Clipboard](#clipboard).

---

## Fetch

`fetch` allows to fetch data from the URL. It acts like a hook. It's a wrapper around the `fetch` function from the browser behind the caching layer. 

The possible returned values are:
- If the data is not cached, it returns `null` and fetches the data in the background.
- If the data is cached, it returns the cached value and then revalidates it.

<WidgetEditor height="80">

```js
const res = fetch("https://rpc.mainnet.near.org/status");

return res.body;
```

</WidgetEditor>

<hr className="subsection" />

#### Async Version

`asyncFetch` is the `async` version of [`fetch`](#fetch), meaning that it returns a promise instead of a value.

<WidgetEditor height="80">

```js
const [uptime, setUptime] = useState(null);

function reportUptime() {
  const promise = asyncFetch("https://rpc.mainnet.near.org/status")
  
  promise.then(
    res => { setUptime(res.body.uptime_sec) }
  );
}

return <>
  <p> {uptime? `Uptime: ${uptime}s` : `Fetch a value` } </p>
  <button onClick={reportUptime}>Fetch uptime</button>
</>
```

</WidgetEditor>

:::tip
In contrast with `fetch`, `asyncFetch` does **not** cache the resulting value, so it should only be used within a function to avoid frequent requests on every render.
:::

---

## Cache

The `useCache` hook takes a promise through a generator function, fetches the data and caches it. It can be used to easily use and cache data from async data sources.

The cache is global for the VM, but each cached element is identified by a unique `dataKey` within each component. 

The possible values returned are:
- `null` if the cache is cold and data is fetching
- the `cached value` while the data is being fetched 
- A new `value` if new data is fetched.

<WidgetEditor>

```js
const status = useCache(
  () =>
    asyncFetch("https://rpc.mainnet.near.org/status").then((res) => res.body),
  "mainnetRpcStatus",
  { subscribe: true }
);

return status;
```

</WidgetEditor>

<details markdown="1">
<summary> Parameters </summary>

| param              | required     | type   | description                                                          |
|--------------------|--------------|--------|----------------------------------------------------------------------|
| `promiseGenerator` | **required** | object | a function that returns a promise, which generates data.             |
| `dataKey`          | **required** | object | the unique name (within the current component) to identify the data. |
| `options`          | _optional_   | object | optional argument.                                                   |

:::info options object

- `subscribe` _(optional)_: if `true`, the data refreshes periodically by invalidating cache.

:::

:::note
- `promiseGenerator`: you don't return the promise directly, because it should only be fired once.
:::

</details>

:::tip
The [fetch](#fetch) method is built on top of the `useCache` hook.
:::

:::note
The data is being cached and compared as JSON serialized objects.
:::

---

## LocalStorage

NEAR Components have access to a simulated `localStorage` through the `Storage` object:

- [`Storage.get`](#storageget)
- [`Storage.set`](#storageset)
- [`Storage.privateGet`](#storageprivateget)
- [`Storage.privateSet`](#storageprivateset)

<WidgetEditor>

```jsx
const [time, setTime] = useState(stored || Date.now()) 

const storeValue = () => {
  const date = Date.now();
  Storage.set('time_now', date)
}

return <>
  <p> Time Now: {Date.now()} </p>
  <p> Time Stored: {Storage.get('time_now')} </p>
  <button onClick={storeValue}>Store Date.now()</button>
</>
```

</WidgetEditor>

<details markdown="1">
<summary> Parameters </summary>

#### Storage.get

`Storage.get(key, widgetSrc?)` - returns the public value for a given key under the given widgetSrc or the current component if `widgetSrc` is omitted. Can only read public values.

 | param       | required     | type   | description              |
 |-------------|--------------|--------|--------------------------|
 | `key`       | **required** | object | a user-defined key       |
 | `widgetSrc` | _optional_   | object | a user-defined component |

---

#### Storage.set

`Storage.set(key, value)` - sets the public value for a given key under the current widget. The value will be public, so other widgets can read it.

 | param   | required     | type   | description          |
 |---------|--------------|--------|----------------------|
 | `key`   | **required** | object | a user-defined key   |
 | `value` | **required** | object | a user-defined value |

---

#### Storage.privateGet

`Storage.privateGet(key)` - returns the private value for a given key under the current component.

 | param | required     | type   | description                                    |
 |-------|--------------|--------|------------------------------------------------|
 | `key` | **required** | object | a user-defined key under the current component |

---

#### Storage.privateSet

`Storage.privateSet(key, value)` - sets the private value for a given key under the current component. The value is private, only the current component can read it.

:::note
Private and public values can share the same key and don't conflict.
:::

 | param   | required     | type   | description                                    |
 |---------|--------------|--------|------------------------------------------------|
 | `key`   | **required** | object | a user-defined key under the current component |
 | `value` | **required** | object | a user-defined value                           |

</details>

---

## Clipboard

NEAR Components can **write** data to the system's clipboard through the `clipboard.writeText` method.

Writing to the clipboard is **only** allowed in **trusted actions**, for example, when the user clicks a button.

<WidgetEditor>

```js
const copyToClipboard = (test) => { clipboard.writeText("Hello World!") }

return <>
    <button onClick={copyToClipboard}> Copy </button>
    <textarea className="form-control mt-2" placeholder="Test pasting here" />
</>
```

</WidgetEditor>
'''
'''--- docs/2.build/3.near-components/bos-gateway.md ---
---
id: bos-gateway
title: Using components on WebApps
---

In order to use the components you create in a WebApp you need to use what is known as the `NEAR VM`. This virtual machine helps you to easily fetch components from the blockchain and transform them into executable code.

There are two possible scenarios:
- You want to start a WebApp [**from scratch**](#starting-a-webapp-from-scratch).
- You want to integrate components into an [**existing WebApp**](#integrating-components-into-your-webapp)

---

## Starting a WebApp from scratch

If you want to start a WebApp from scratch, the simplest option is to use `create-near-app`. To use it, you only need to have [node.js](https://nodejs.org/en/) installed on your computer.

Simply run the following command and follow the instructions:

```bash
npx create-near-app@latest
```

:::tip Tutorial
To learn more about the template created by `create-near-app` see our [Quickstart a WebApp](../../2.build/4.web3-apps/quickstart.md) tutorial.
:::

---

## Integrating Components into your WebApp

In order to integrate components into your WebApp you will leverage two libraries:
- **Wallet Selector**: Allows user to login using their preferred NEAR wallet.
- **NEAR VM**: Simplifies fetching NEAR components from the blockchain and rendering them.

The best way to learn how to integrate components into your WebApp is by following our tutorial:

:::tip Tutorial
To learn step-by-step how to integrate them, please visit our [integrating components into a WebApp](../../2.build/4.web3-apps/integrate-components.md) tutorial.
:::
'''
'''--- docs/2.build/3.near-components/environment.md ---
---
id: dev-environment
title: Choose your Dev Environment
---

The environments in which you can develop `Components` are divided into two categories:

- [Web Tools](#web-tools): Online tools that allow you to quickly start building and sharing components.
- [Local Tools](#local-tools): Tools that allow you to develop and test components locally.

:::tip Handling collaborations
If you plan to collaborate with multiple people, we recommend you to check [this repository template](https://github.com/near-examples/bos-components) which automatically deploys components each time a PR is merged. 
:::

---

## Web Tools
The quickest way to start building NEAR Components is by using one of the online tools. They are great for taking your first steps, while they let you find other developers and components in the NEAR ecosystem.

#### [NEAR Sandbox](https://near.org/sandbox)
The [near website](https://near.org/) contains its own [sandbox editor](https://near.org/sandbox). The sandbox allows you to code, preview and deploy your components directly from your browser.

#### [Jutsu.ai](https://jutsu.ai)
[Jutsu.ai](https://jutsu.ai) is a web IDE made for NEAR developers. It contains examples and tutorials to help onboarding you.

---

## Local Tools

If you want to collaborate with a team or work on a larger project, you will likely want more **version control**, automated testing and deployment, and other workflows. For this, the NEAR ecosystem offers a set of tools to easily develop and test your components entirely locally.

#### [NEAR VSCode Extension](https://marketplace.visualstudio.com/items?itemName=near-protocol.near-discovery-ide)
The [NEAR VSCode Extension](https://marketplace.visualstudio.com/items?itemName=near-protocol.near-discovery-ide) integrates with the VSCode IDE to help you develop, preview and deploy components all within VSCode.

#### [BOS Loader](../../3.tutorials/near-components/bos-loader.md)
A CLI tool to preview local components in NEAR BOS. A perfect companion to the [BOS CLI](https://github.com/FroVolod/bos-cli-rs).

#### [BOS CLI](https://github.com/FroVolod/bos-cli-rs)
A command line utility that simplifies local component development for NEAR BOS.

#### [BOS Workspace](https://github.com/nearbuilders/bos-workspace)
A comprehensive toolset for simplifying the local development of NEAR components and applications, featuring hot reload, TypeScript support, multi-app management, and a local gateway.

#### [Al√©m](https://github.com/wpdas/alem)
A web3 JavaScript/TypeScript library to create web3 applications for Near BOS. It's developer-friendly and uses React patterns, making it easy to organize files and write code. Access the [Al√©m Docs](https://alem.dev/) to get to know more.

'''
'''--- docs/2.build/3.near-components/what-is.md ---
---
id: what-is
title: What are NEAR Components?
sidebar_label: What is a Component?
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {WidgetEditor} from "@site/src/components/widget-editor"

NEAR Components are a new way to build web applications. They are composable, reusable and decentralized.

![img](/docs/assets/welcome-pages/bos-landing.png)

:::tip
You can login to interact with the examples in this section.
:::

---

## Familiar to Web Developers
NEAR Components are built on top of [React Components](https://react.dev/), meaning that they:
- Handle input through the `props` variable
- Handle state through the [`useState`](https://react.dev/reference/react/useState) hook
- Handle side effects through the [`useEffect`](https://react.dev/reference/react/useEffect) hook

<WidgetEditor id="1">

```jsx
const name = props.name || "Maria";
const [count, setCount] = useState(1);

return (
  <div>
    <p> {count} cheers for {name}! </p>
    <button onClick={() => setCount(count + 1)}>Cheers!</button>
  </div>
);
```

</WidgetEditor>

In contrast with React, NEAR Components are not wrapped in a `function` or `class` definition.

Indeed, when writing a NEAR Component, you focus on writing the body of the component, which is a function that returns the JSX to be rendered. 

---

## NEAR Native
NEAR Components can readily [interact with smart contracts](./anatomy/near.md) in the NEAR Blockchain. While `view` methods are free to query by anyone, `call` methods require the user to be logged in.

<WidgetEditor id="2">

```jsx
const counter = Near.view('counter.near-examples.testnet', 'get_num')

if(counter === null) return 'Loading...'

const add = () => {
  Near.call('counter.near-examples.testnet', 'increment')
}

const subtract = () => {
  Near.call('counter.near-examples.testnet', 'decrement')
}

return <>
  <p> Counter: {counter} </p>
  {!context.accountId &&
    <p color="red"> Please login to interact with the contract</p>
  }
  {context.accountId && 
  <>
    <button onClick={add}> + </button>
    <button onClick={subtract}> - </button>
  </>
  }
</>
```

</WidgetEditor>

---

## Social from the Get-Go

NEAR Components are easily integrated with [NEAR Social](https://near.social/), a social network built on NEAR.

<WidgetEditor id="3">

```js
const item = (blockHeight) => ({ type: 'social', path: 'influencer.testnet/post/main', blockHeight });

// retrieve indexed posts by influencer.testnet
const idx_posts = Social.index(
  'post', 'main', { accountId: ['influencer.testnet'] }
);

if (idx_posts === null) return 'Loading...';

// retrieve likes for each post
const likes = idx_posts.map(
  index => Social.index('like', item(index.blockHeight)).length
);

// retrieve data for each post
const post_data = idx_posts.map(
  index => Social.get(`${index.accountId}/post/main`, index.blockHeight)
);

// defined "Like" function
const like = (blockHeight) => Social.set(
  {index:{like: JSON.stringify({key: item(blockHeight), value: {type: 'like'}})}}
)

return <>
  <h5>Posts from <i>influencer.testnet</i></h5>
  {post_data.map((post, idx) =>
    <div className="mt-3">
      <div>{JSON.parse(post).text} - {likes[idx]} likes</div>
      {context.accountId && <button className="btn btn-danger btn-sm" onClick={() => like(idx_posts[idx].blockHeight)}>Like</button>}
    </div>
  )}
</>

```

</WidgetEditor>

---

## Fully On-Chain & Easily Composable

Leveraging the cheap storage and computation of the NEAR Blockchain, NEAR Components' code is stored fully on-chain in the SocialDB smart contract (`social.near`).

<WidgetEditor height="40px">

```js
// retrieving the code of a stored component
return Social.get('influencer.testnet/widget/Greeter')
```

</WidgetEditor>

Once deployed, a component can be imported and used by any other component. Composing components as LEGO blocks allows you to build complex applications.

<WidgetEditor id="4" height="80px">

```js
// Rendering the component with props
return <Widget src="influencer.testnet/widget/Greeter"
               props={{name: "Anna", amount: 3}} />;
```
</WidgetEditor>

---

## Multi-Chain by Design

NEAR Components can easily interact with Ethereum compatible blockchains, helping to easily create decentralized frontends for multi-chain applications.

<WidgetEditor id="5" height="100px">

```js
if (
  state.chainId === undefined &&
  ethers !== undefined &&
  Ethers.send("eth_requestAccounts", [])[0]
) {
  Ethers.provider()
    .getNetwork()
    .then((chainIdData) => {
      if (chainIdData?.chainId) {
        State.update({ chainId: chainIdData.chainId });
      }
    });
}
if (state.chainId !== undefined && state.chainId !== 1) {
  return <p>Switch to Ethereum Mainnet</p>;
}

// FETCH LIDO ABI

const lidoContract = "0xae7ab96520de3a18e5e111b5eaab095312d7fe84";
const tokenDecimals = 18;

const lidoAbi = fetch(
  "https://raw.githubusercontent.com/lidofinance/lido-subgraph/master/abis/Lido.json"
);
if (!lidoAbi.ok) {
  return "Loading";
}

const iface = new ethers.utils.Interface(lidoAbi.body);

// FETCH LIDO STAKING APR

if (state.lidoArp === undefined) {
  const apr = fetch(
    "https://api.allorigins.win/get?url=https://stake.lido.fi/api/sma-steth-apr"
  );
  if (!apr) return;
  State.update({ lidoArp: JSON.parse(apr?.body?.contents) ?? "..." });
}

// HELPER FUNCTIONS

const getStakedBalance = (receiver) => {
  const encodedData = iface.encodeFunctionData("balanceOf", [receiver]);

  return Ethers.provider()
    .call({
      to: lidoContract,
      data: encodedData,
    })
    .then((rawBalance) => {
      const receiverBalanceHex = iface.decodeFunctionResult(
        "balanceOf",
        rawBalance
      );

      return Big(receiverBalanceHex.toString())
        .div(Big(10).pow(tokenDecimals))
        .toFixed(2)
        .replace(/\d(?=(\d{3})+\.)/g, "$&,");
    });
};

const submitEthers = (strEther, _referral) => {
  if (!strEther) {
    return console.log("Amount is missing");
  }
  const erc20 = new ethers.Contract(
    lidoContract,
    lidoAbi.body,
    Ethers.provider().getSigner()
  );

  let amount = ethers.utils.parseUnits(strEther, tokenDecimals).toHexString();

  erc20.submit(lidoContract, { value: amount }).then((transactionHash) => {
    console.log("transactionHash is " + transactionHash);
  });
};

// DETECT SENDER

if (state.sender === undefined) {
  const accounts = Ethers.send("eth_requestAccounts", []);
  if (accounts.length) {
    State.update({ sender: accounts[0] });
    console.log("set sender", accounts[0]);
  }
}

//if (!state.sender)  return "Please login first";

// FETCH SENDER BALANCE

if (state.balance === undefined && state.sender) {
  Ethers.provider()
    .getBalance(state.sender)
    .then((balance) => {
      State.update({ balance: Big(balance).div(Big(10).pow(18)).toFixed(2) });
    });
}

// FETCH SENDER STETH BALANCE

if (state.stakedBalance === undefined && state.sender) {
  getStakedBalance(state.sender).then((stakedBalance) => {
    State.update({ stakedBalance });
  });
}

// FETCH TX COST

if (state.txCost === undefined) {
  const gasEstimate = ethers.BigNumber.from(1875000);
  const gasPrice = ethers.BigNumber.from(1500000000);

  const gasCostInWei = gasEstimate.mul(gasPrice);
  const gasCostInEth = ethers.utils.formatEther(gasCostInWei);

  let responseGql = fetch(
    "https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2",
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `{
          bundle(id: "1" ) {
            ethPrice
          }
        }`,
      }),
    }
  );

  if (!responseGql) return "";

  const ethPriceInUsd = responseGql.body.data.bundle.ethPrice;

  const txCost = Number(gasCostInEth) * Number(ethPriceInUsd);

  State.update({ txCost: `$${txCost.toFixed(2)}` });
}

// FETCH CSS

const cssFont = fetch(
  "https://fonts.googleapis.com/css2?family=Manrope:wght@200;300;400;500;600;700;800"
).body;
const css = fetch(
  "https://pluminite.mypinata.cloud/ipfs/Qmboz8aoSvVXLeP5pZbRtNKtDD3kX5D9DEnfMn2ZGSJWtP"
).body;

if (!cssFont || !css) return "";

if (!state.theme) {
  State.update({
    theme: styled.div`
    font-family: Manrope, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
    ${cssFont}
    ${css}
`,
  });
}
const Theme = state.theme;

// OUTPUT UI

const getSender = () => {
  return !state.sender
    ? ""
    : state.sender.substring(0, 6) +
        "..." +
        state.sender.substring(state.sender.length - 4, state.sender.length);
};

return (
  <Theme>
    <div className="LidoContainer">
      <div className="Header">Stake Ether</div>
      <div className="SubHeader">Stake ETH and receive stETH while staking.</div>

      <div className="LidoForm">
        {state.sender && (
          <>
            <div className="LidoFormTopContainer">
              <div className="LidoFormTopContainerLeft">
                <div className="LidoFormTopContainerLeftContent1">
                  <div className="LidoFormTopContainerLeftContent1Container">
                    <span>Available to stake</span>
                    <div className="LidoFormTopContainerLeftContent1Circle" />
                  </div>
                </div>
                <div className="LidoFormTopContainerLeftContent2">
                  <span>
                    {state.balance ?? (!state.sender ? "0" : "...")}&nbsp;ETH
                  </span>
                </div>
              </div>
              <div className="LidoFormTopContainerRight">
                <div className="LidoFormTopContainerRightContent1">
                  <div className="LidoFormTopContainerRightContent1Text">
                    <span>{getSender()}</span>
                  </div>
                </div>
              </div>
            </div>
            <div className="LidoSplitter" />
          </>
        )}
        <div
          className={
            state.sender ? "LidoFormBottomContainer" : "LidoFormTopContainer"
          }
        >
          <div className="LidoFormTopContainerLeft">
            <div className="LidoFormTopContainerLeftContent1">
              <div className="LidoFormTopContainerLeftContent1Container">
                <span>Staked amount</span>
              </div>
            </div>
            <div className="LidoFormTopContainerLeftContent2">
              <span>
                {state.stakedBalance ?? (!state.sender ? "0" : "...")}
                &nbsp;stETH
              </span>
            </div>
          </div>
          <div className="LidoFormTopContainerRight">
            <div className="LidoAprContainer">
              <div className="LidoAprTitle">Lido APR</div>
              <div className="LidoAprValue">{state.lidoArp ?? "..."}%</div>
            </div>
          </div>
        </div>
      </div>
      <div className="LidoStakeForm">
        <div className="LidoStakeFormInputContainer">
          <span className="LidoStakeFormInputContainerSpan1">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
              <path
                opacity="0.6"
                d="M11.999 3.75v6.098l5.248 2.303-5.248-8.401z"
              ></path>
              <path d="M11.999 3.75L6.75 12.151l5.249-2.303V3.75z"></path>
              <path
                opacity="0.6"
                d="M11.999 16.103v4.143l5.251-7.135L12 16.103z"
              ></path>
              <path d="M11.999 20.246v-4.144L6.75 13.111l5.249 7.135z"></path>
              <path
                opacity="0.2"
                d="M11.999 15.144l5.248-2.993-5.248-2.301v5.294z"
              ></path>
              <path
                opacity="0.6"
                d="M6.75 12.151l5.249 2.993V9.85l-5.249 2.3z"
              ></path>
            </svg>
          </span>
          <span className="LidoStakeFormInputContainerSpan2">
            <input
              disabled={!state.sender}
              className="LidoStakeFormInputContainerSpan2Input"
              value={state.strEther}
              onChange={(e) => State.update({ strEther: e.target.value })}
              placeholder="Amount"
            />
          </span>
          <span
            className="LidoStakeFormInputContainerSpan3"
            onClick={() => {
              State.update({
                strEther: (state.balance > 0.05
                  ? parseFloat(state.balance) - 0.05
                  : 0
                ).toFixed(2),
              });
            }}
          >
            <button
              className="LidoStakeFormInputContainerSpan3Content"
              disabled={!state.sender}
            >
              <span className="LidoStakeFormInputContainerSpan3Max">MAX</span>
            </button>
          </span>
        </div>
        {!!state.sender ? (
          <button
            className="LidoStakeFormSubmitContainer"
            onClick={() => submitEthers(state.strEther, state.sender)}
          >
            <span>Submit</span>
          </button>
        ) : (
          <Web3Connect
            className="LidoStakeFormSubmitContainer"
            connectLabel="Connect with Web3"
          />
        )}

        <div className="LidoFooterContainer">
          {state.sender && (
            <div className="LidoFooterRaw">
              <div className="LidoFooterRawLeft">You will receive</div>
              <div className="LidoFooterRawRight">${state.strEther ?? 0} stETH</div>
            </div>
          )}
          <div className="LidoFooterRaw">
            <div className="LidoFooterRawLeft">Exchange rate</div>
            <div className="LidoFooterRawRight">1 ETH = 1 stETH</div>
          </div>
          {false && (
            <div className="LidoFooterRaw">
              <div className="LidoFooterRawLeft">Transaction cost</div>
              <div className="LidoFooterRawRight">{state.txCost}</div>
            </div>
          )}
          <div className="LidoFooterRaw">
            <div className="LidoFooterRawLeft">Reward fee</div>
            <div className="LidoFooterRawRight">10%</div>
          </div>
        </div>
      </div>
    </div>
  </Theme>
);
```

</WidgetEditor>

:::danger ETH Disabled in Docs
For a working example visit the [deployed NEAR Component](https://near.social/zavodil.near/widget/Lido).
:::

---

## Next Steps
Build and deploy your first components without leaving the browser. Go to https://near.org/sandbox , create an account and start building!
'''
'''--- docs/2.build/4.web3-apps/backend/backend.md ---
---
id: backend-login
title: Authenticate NEAR Users 
---
Recently NEAR has approved a new standard that, among other things, enables users to authenticate into a backend service.

The basic idea is that the user will sign a challenge with their NEAR wallet, and the backend will verify the signature. If the signature is valid, then the user is authenticated.

---

## Backend Auth with a NEAR Wallet
Authenticating users is a common use-case for backends and web applications. This enables services to provide a personalized experience to users, and to protect sensitive data.

To authenticate a user, the backend must verify that the user is who they say they are. To do so, the backend must verify that the user has access to a full-access key that is associated with their account.

For this three basic steps are needed:

1. Create a challenge for the user to sign.
2. Ask the user to sign the challenge with the wallet.
3. Verify the signature corresponds to the user.

### 1.  Create a Challenge
Assume we want to login the user into our application named `application-name`.

We first need to create a challenge that the user will sign with their wallet. For this, it is recommended to use a cryptographically secure random number generator to create the challenge.

```js
import { randomBytes } from 'crypto'
const challenge = randomBytes(32)
const message = 'Login with NEAR'
```

:::note
Here we use [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback) to generate a 32 byte random buffer.
:::

### 2. Ask the User to Sign the Challenge
The `signMessage` method needed to sign the challenge is supported by these wallets:
- Meteor Wallet
- Here Wallet
- Near Snap
- Nightly Wallet
- WELLDONE Wallet
- NearMobileWallet
- MyNearWallet
- Sender

The message that the user needs to sign contains 4 fields:
- Message: The message that the user is signing.
- Recipient: The recipient of the message.
- Nonce: The challenge that the user is signing.
- Callback URL: The URL that the wallet will call with the signature.

```js
// Assuming you setup a wallet selector so far
const signature = wallet.signMessage({ message, recipient, nonce: challenge, callbackUrl: <server-auth-url> })
```

### 3. Verify the Signature
Once the user has signed the challenge, the wallet will call the `callbackUrl` with the signature. The backend can then verify the signature.

```js
const naj = require('near-api-js')
const js_sha256 = require("js-sha256")

export async function authenticate({ accountId, publicKey, signature }) {
  // A user is correctly authenticated if:
  // - The key used to sign belongs to the user and is a Full Access Key
  // - The object signed contains the right message and domain
  const full_key_of_user = await verifyFullKeyBelongsToUser({ accountId, publicKey })
  const valid_signature = verifySignature({ publicKey, signature })
  return valid_signature && full_key_of_user
}

export function verifySignature({ publicKey, signature }) {
  // Reconstruct the payload that was **actually signed**
  const payload = new Payload({ message: MESSAGE, nonce: CHALLENGE, recipient: APP, callbackUrl: cURL });
  const borsh_payload = borsh.serialize(payloadSchema, payload);
  const to_sign = Uint8Array.from(js_sha256.sha256.array(borsh_payload))

  // Reconstruct the signature from the parameter given in the URL
  let real_signature = Buffer.from(signature, 'base64')

  // Use the public Key to verify that the private-counterpart signed the message
  const myPK = naj.utils.PublicKey.from(publicKey)
  return myPK.verify(to_sign, real_signature)
}

export async function verifyFullKeyBelongsToUser({ publicKey, accountId }) {
  // Call the public RPC asking for all the users' keys
  let data = await fetch_all_user_keys({ accountId })

  // if there are no keys, then the user could not sign it!
  if (!data || !data.result || !data.result.keys) return false

  // check all the keys to see if we find the used_key there
  for (const k in data.result.keys) {
    if (data.result.keys[k].public_key === publicKey) {
      // Ensure the key is full access, meaning the user had to sign
      // the transaction through the wallet
      return data.result.keys[k].access_key.permission == "FullAccess"
    }
  }

  return false // didn't find it
}

// Aux method
async function fetch_all_user_keys({ accountId }) {
  const keys = await fetch(
    "https://rpc.testnet.near.org",
    {
      method: 'post',
      headers: { 'Content-Type': 'application/json; charset=utf-8' },
      body: `{"jsonrpc":"2.0", "method":"query", "params":["access_key/${accountId}", ""], "id":1}`
    }).then(data => data.json()).then(result => result)
  return keys
}

module.exports = { authenticate, verifyFullKeyBelongsToUser, verifySignature };
```

'''
'''--- docs/2.build/4.web3-apps/integrate-components.md ---
---
id: integrate-components
title: Integrating Components
---
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"
import {WidgetEditor} from "@site/src/components/widget-editor"
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

To integrate [Components](../3.near-components/what-is.md) to your frontend, you will leverage two tools:
1. `Wallet Selector`: Enables the user to select their preferred NEAR wallet in your dApp.
2. `NEAR VM`: A package that can retrieve the component's code from the blockchain and execute it in the browser. 

<br/>

Using those tools you will implement the following flow:
1. **Setup** the VM.
2. Render components using the `Widget` component in the VM.
3. **Setup** a wallet selector so users can interact with the Menu.

---

## Adding the VM & Wallet Selector
To use the `VM` and the `wallet-selector`, you must add them to your project first.

The wallet selector has multiple wallet packages to select from. [Check their website](https://github.com/near/wallet-selector#installation-and-usage) for more information.

```bash
npm install \
  @near-wallet-selector/core \
  @near-wallet-selector/my-near-wallet \
  @near-wallet-selector/modal-ui
```

Then, manually add the `VM` to your `package.json`:

```js
"dependencies": {
  ...
  "near-social-vm": "github:NearSocial/VM#2.5.5"
  ...
}
```

:::tip
Check the latest released version for the VM [here](https://github.com/NearSocial/VM/releases)
:::

---

## Setup the VM
To render components, you need to import the `useInitNear` hook from the `near-social-vm` package, as well as the `Widget` component.

```js
import { useInitNear, Widget } from 'near-social-vm';
import { useEffect } from 'react';

export default function Component({ src }) {
  const { initNear } = useInitNear();

  useEffect(() => {
    initNear && initNear({ networkId: 'testnet', selector: null });
  }, [initNear]);

  return <Widget src={src} />;
}

return <Component src="influencer.testnet/widget/Greeter" props={{name: "Anna", amount: 2}} />
```

:::tip
Notice that the VM is inherently linked to `React`, so you will need to use a reactive framework to take full advantage of the VM.
:::

---

## Setup the Wallet Selector
While the VM allows you to render components, you need to set up a wallet selector to allow users to interact with the components.

To instantiate a `Wallet Selector`, simply import all the wallets you want your users to have access to, and the setup method from the `near-wallet-selector` package.

```js
import '@near-wallet-selector/modal-ui/styles.css';
import { setupModal } from '@near-wallet-selector/modal-ui';
import { setupWalletSelector } from '@near-wallet-selector/core';
import { setupMyNearWallet } from '@near-wallet-selector/my-near-wallet';

const selector = setupWalletSelector({
  network: 'testnet,
  modules: [setupMyNearWallet()],
});
```

Then use it during the call to `initNear`:

```js
  useEffect(() => {
    initNear && initNear({ networkId: 'testnet', selector: selector });
  }, [initNear]);
```

:::tip
To learn more about the wallet selector and how it can be used, please see the [integrating NEAR to your WebApp tutorial](./integrate-contracts.md)
:::
'''
'''--- docs/2.build/4.web3-apps/integrate-contracts.md ---
---
id: integrate-contracts
title: Integrating Contracts
---
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

To integrate NEAR to your frontend, you will leverage two tools:

1. `Wallet Selector`: Enables the user to select their preferred NEAR wallet in your dApp.
2. `NEAR API JS`: A suit of tools to interact with the NEAR RPC.

Using those tools you will implement the following flow:

1. **Setup** a wallet selector.
1. Load the wallet selector **on start-up**.
2. Ask the user to **sign-in** using a NEAR wallet.
2. **Call methods** in the contract.

---

## Adding NEAR API JS and Wallet Selector

In order to use `near-api-js` and the `wallet-selector` you will need to first add them to your project.

The wallet selector has multiple wallet packages to select from, [see in their website](https://github.com/near/wallet-selector#installation-and-usage).

```bash
npm install \
  near-api-js \
  @near-wallet-selector/core \
  @near-wallet-selector/my-near-wallet \
  @near-wallet-selector/ledger \
  @near-wallet-selector/modal-ui
```

<details>

<summary>Using `near-api-js` in plain HTML</summary>

You can add `near-api-js` as a script tag in your html.

```js
<script src=" https://cdn.jsdelivr.net/npm/near-api-js@3.0.4/lib/browser-index.min.js "></script>
```

</details>

---

## Create a Wallet Object

In our examples we implement a [`./near-wallet.js`](https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/wallets/near-wallet.js) module, where we abstracted the `wallet selector` into a `Wallet` object to simplify using it.

To create a wallet, simply import the `Wallet` object from the module and initialize it. This `wallet` will later allows the user to call any contract in NEAR.

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="index.js"
            url="https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/layout.js"
            start="18" end="25" />

    <Github fname="near-wallet.js"
        url="https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/wallets/near-wallet.js"
        start="35" end="56" />

  </Language>
</CodeTabs>

Under the hood (check the `near-wallet` tab) you can see that we are actually setting up the wallet selector, and asking it if the user logged-in already. During the setup, we pass a hook to the wallet selector, which will be called each time a user logs in or out.

<details markdown="1">

<summary> Setting customs RPC endpoints </summary>

If you want to use a user-defined RPC endpoint with the Wallet Selector, you need to setup a [network options](https://github.com/near/wallet-selector/tree/main/packages/core#options) object with the custom URLs.
For example:

<CodeTabs>
  <Language value="js" language="ts">

```js title="index.js"
const CONTRACT_ADDRESS = process.env.CONTRACT_NAME;

const my_network = {
    networkId: "my-custom-network",
    nodeUrl: "https://rpc.custom-rpc.com",
    helperUrl: "https://helper.custom-helper.com",
    explorerUrl: "https://custom-explorer.com",
    indexerUrl: "https://api.custom-indexer.com",
  };

const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS, network: my_network });
```

</Language>

</CodeTabs>

:::tip

You can find the entire Wallet Selector [API reference here](https://github.com/near/wallet-selector/blob/main/packages/core/docs/api/selector.md).

:::

</details>

#### Function Call Key
When instantiating the wallet you can choose if you want to **create a [FunctionCall Key](../../1.concepts/protocol/access-keys.md#function-call-keys-function-call-keys)**.

If you create the key, then your dApp will be able to **automatically sign non-payable transactions** for the user on the specified contract.

---

## Calling View Methods

Once the wallet is up we can start calling view methods, i.e. the methods that perform read-only operations.

Because of their read-only nature, view methods are **free** to call, and do **not require** the user to be **logged in**.

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="index.js"
            url="https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/pages/hello-near/index.js"
            start="12" end="25" />

    <Github fname="near-wallet.js"
        url="https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/wallets/near-wallet.js"
        start="81" end="94" />

</Language>

</CodeTabs>

The snippet above shows how we call view methods in our examples. Switch to the `near-wallet` tab to see under the hood: we are actually making a **direct call to the RPC** using `near-api-js`.

:::tip

View methods have by default 200 TGAS for execution

:::

---

## User Sign-In / Sign-Out

In order to interact with non-view methods it is necessary for the user to first sign in using a NEAR wallet.

Signing in is as simple as requesting the `wallet` object to `signIn`, the same simplicity applies to signing-out.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="index.js"
            url="https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/components/navigation.js"
            start="9" end="23" />

    <Github fname="near-wallet.js"
            url="https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/wallets/near-wallet.js"
            start="58" end="72" />

  </Language>
</CodeTabs>

When the user clicks in the button, it will be asked to select a wallet and use it to login.

<hr className="subsection" />

### Function Call Key

If you instantiated the `Wallet` passing an account for the `createAccessKeyFor` parameter, then the wallet will create a [FunctionCall Key](../../1.concepts/protocol/access-keys.md#function-call-keys-function-call-keys) and store it in the web's local storage.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="index.js"
            url="https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/layout.js"
            start="22" end="22" />
  </Language>
</CodeTabs>

By default, such key enables to expend a maximum of `0.25‚ìÉ` on GAS calling methods in **the specified** contract **without prompting** the user to sign them.

If, on the contrary, you do not create an access key, then the user will be asked to sign every single transaction (except calls to `view methods`, since those are always free).

:::tip

Please notice that this only applies for **non-payable** methods, if you attach money to any call the user will **always** be redirected to the wallet to confirm the transaction.

:::

---

## Calling Change Methods

Once the user logs-in they can start calling change methods. Programmatically, calling change methods is similar to calling view methods, only that now you can attach money to the call, and specify how much GAS you want to use.

It is important to notice that, if you ask for money to be attached in the call, then the user will be redirected to the NEAR wallet to accept the transaction.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="index.js"
            url="https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/pages/hello-near/index.js"
            start="33" end="33" />

    <Github fname="near-wallet.js"
        url="https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/wallets/near-wallet.js"
        start="106" end="122" />

</Language>

</CodeTabs>

Under the hood (see `near-wallet` tab) we can see that we are actually asking the **wallet** to **sign a FunctionCall transaction** for us.

:::tip

Remember that you can use the `wallet` to call methods in **any** contract. If you did not asked for a function key to be created, the user will simply be prompt to confirm the transaction.

:::

<hr className="subsection" />

### Wallet Redirection

If you attach money to a change call, then the user will be redirected to their wallet to accept the transaction. After accepting, the user will be brought back to your website, with the resulting transaction hash being pass as part of the url (i.e. `your-website.com/?transactionHashes=...`).

If the method invoked returned a result, you can use the transaction hash to retrieve the result from the network. Assuming you created the `near` object as in the [example above](#connecting-to-a-contract), then you query the result by doing:

<CodeTabs>
  <Language value="js" language="js">

    <Github fname="utils.js"
            url="https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/wallets/near-wallet.js"
            start="132" end="140" />

</Language>

</CodeTabs>

---

## Handling Data Types

When calling methods in a contract, or receiving results from them, you will need to correctly encode/decode parameters. For this, it is important to know how the contracts encode timestamps (u64) and money amounts (u128).

##### Time

The block timestamp in a smart contract is encoded using nanoseconds (i.e. 19 digits: `1655373910837593990`). In contrast, `Date.now()` from javascript returns a timestamp in milliseconds (i.e 13 digits: `1655373910837`). Make sure to convert between milliseconds and nanoseconds to properly handle time variables.

##### Money

Smart contracts speak in yocto NEAR, where 1‚ìÉ = 10^24yocto, and the values are always encoded as `strings`.

- Convert from NEAR to yocto before sending it to the contract using `near-api-js.utils.format.parseNearAmount(amount.toString())`.
- Convert a response in yoctoNEAR to NEAR using `near-api-js.utils.format.formatNearAmount(amount)`

:::tip

If the contract returns a `Balance` instead of a `U128`, you will get a "scientific notation" `number` instead of a `string` (e.g. `10^6` instead of `"1000000"`). In this case, you can convert the value to NEAR by doing:

```js
function formatAmount(amount) {
  let formatted = amount.toLocaleString('fullwide', { useGrouping: false })
  formatted = utils.format.formatNearAmount(formatted)
  return Math.floor(formatted * 100) / 100
}
```

:::

---

## Leveraging NEAR API JS

NEAR API JS does not limit itself to simply calling methods in a contract. In fact, you can use it to transform your web-app into a rich user experience. While we will not cover these topics in depth, it is important for you to know that with NEAR API JS you can also:

- **[Sign and verify messages](https://github.com/near/near-api-js/blob/master/packages/cookbook/utils/verify-signature.js)**: this is very useful to prove that a message was created by the user.
- **[Create batch transactions](https://github.com/near/near-api-js/tree/master/packages/cookbook/transactions/batch-transactions.js)**: this enables to link multiple [actions](../../1.concepts/protocol/transaction-anatomy.md#actions) (e.g. multiple function calls). If one of the transactions fails, then they are all reverted.
- **[Create accounts](https://github.com/near/near-api-js/tree/master/packages/cookbook/accounts/create-testnet-account.js)**: deploy accounts for your users!

Check the [cookbook](/tools/near-api-js/cookbook) to learn how to supercharge your webapp.

'''
'''--- docs/2.build/4.web3-apps/quickstart.md ---
---
id: quickstart
title: Hello WebApp
sidebar_label: ‚≠ê Quickstart a WebApp
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Most interactions with the NEAR ecosystem can be grouped in 2 categories: 
1. Interacting with a [NEAR smart contract](./integrate-contracts.md).
2. Interacting with a [NEAR component](./integrate-components.md).

In this guide we will show you how to quickly spin-up an application where users can **login** using their wallets and interact with both **contracts** and **components**.

Furthermore, the application readily integrates a `Web3 wallet`, allowing people to use `Metamask` to interact with multi-chain components.

:::tip Searching to integrate NEAR in your App?
If you already have an application and want to integrate NEAR into it, we recommend you to first go through this guide and then check our documentation on [integrating NEAR to a frontend](./integrate-contracts.md)
:::

---

## Create NEAR App
If you already have [Node.js](https://nodejs.org/en/download) installed, simply run:

```bash 
  npx create-near-app@latest
```

Use the interactive menu to set up:
1. `A Near Gateway (Web App)`.
2. `NextJs + React`.

:::tip Using pnpm
While you can use our app with any package manager, we recommend you to skip the installation step and manually install the dependencies using `pnpm i`.
:::

Once the folder is ready - and all dependencies installed - you can start the development server using `pnpm`. 

```bash 
pnpm dev
```

Visit `http://localhost:3000` in your browser to view the dApp. Note that since the dApp uses NextJS the app might take longer to load the pages on first visit.

<details>
<summary> The app is not starting? </summary>

Make sure you are using **node >= v18**, you can easily switch versions using `nvm use 18`

</details>

---

## Landing Page

Once the app starts you will see the landing page, rendering a navigation bar that allows users to login using their NEAR wallet, and two pathways:

![img](/docs/assets/examples/hello-near-landing-page.png)
*Landing page of Hello NEAR Gateway*

Go ahead and sign in with your NEAR account. If you don't have one, you can create one on the fly.

<hr className="subsection" />

### Under the Hood

[Next.js](https://nextjs.org/) uses a template system, where each page is a React component.

Our app's template is defined at `./src/layout.js`. It does two things:

1. Initializes a [wallet selector](../../4.tools/wallet-selector.md), and stores it so other components can access it later.
2. Renders the navigation menu and the page's content.

<Github url="https://github.com/near-examples/hello-near-examples/blob/master/frontend/src/layout.js" language="jsx" start="18" end="25" />

<details>
<summary>What is the wallet selector?</summary>

The wallet selector is a component that allows users to select their preferred Near wallet to login. Our application implements a `useInitWallet` hook, that initializes a wallet selector and stores it so other components can access it later.  

</details>

<hr className="subsection" />

### Navigation Bar & Login
The navigation bar implements buttons to `login` and `logout` users with their Near wallet.

The code for the navigation bar can be found at `./src/navigation.js`. The login and logout buttons are implemented by using the `signIn` and `signOut` methods from the wallet selector previously initialized:

<Github url="https://github.com/near-examples/hello-near-examples/blob/master/frontend/src/components/navigation.js" language="jsx" start="10" end="23" />

---

## Interacting with NEAR

Now that you understand how the landing page works, we can move to the `Near Integration` page, which retrieves a greeting from the [hello.near-examples.testnet](https://testnet.nearblocks.io/address/hello.near-examples.testnet) contract.

![img](/docs/assets/examples/hello-near-gateway.png)
*View of the `Near Integration` page*

Login if you haven't done it yet and you will see a simple form that allows you to store a greeting in the smart contract.

<hr className="subsection" />

### Under the Hood
Interactions with NEAR are done using the `useStore` hook to retrieve the `wallet` we initialized on the `layout`. The wallet allows us to interact with the smart contract through the methods `viewMethod` and `callMethod`.

- `viewMethod` is used to call functions that are read-only
- `callMethod` is used to call functions that modify the state of the contract 

<Github url="https://github.com/near-examples/hello-near-examples/blob/master/frontend/src/pages/hello-near/index.js" language="jsx" start="14" end="38" />

On load, the first `useEffect` hook will call the contract's `get_greeting` method and set the `greeting` state to the result.

If the user is logged in, the `storeGreeting` method will call the contract's `set_greeting` method and set the `greeting` state to the result.

---

## Interacting with a Component

Now let's take a look at the Components page. Go ahead and click on the card titled Web3 Components at the bottom on the page. Once you do you'll be taken to the screen below:

![img](/docs/assets/examples/hello-near-components.png)
*The Near Components Page*

If you're following along, you should already be logged into your NEAR account. If you aren't, go ahead and do so now.

You'll see that once you're logged in you are able to interact with the components that come included with the app.

:::info Ethereum Components
To interact with the Ethereum components (a Lido) you will need to have Metamask, or other web3 compatible wallets 
:::

:::warning Ethereum Mainnet
While the component's code is stored in the **Near testnet**, the Lido component is connected to the **Ethereum mainnet**.
:::

<hr className="subsection" />

### Under the Hood

The source code (located in `./src/hello-components/page.js`) shows us that the page is rendering components pulled from the SocialDB:

<CodeTabs>
  <TabItem value="page.js">
    <Github url="https://github.com/near-examples/hello-near-examples/blob/master/frontend/src/pages/hello-components/index.js" start="27" end="36" language="jsx" />
  </TabItem>
  <TabItem value="vm-components.js">
      <Github url="https://github.com/near-examples/hello-near-examples/blob/master/frontend/src/components/vm-component.js" language="jsx" />
  </TabItem>
</CodeTabs>

Particularly, the `Component` in the main page are wrappers around the `Widget` component of the SocialVM.

---

## Moving Forward

That's it for our quickstart  tutorial. You have now seen a fully functional frontend that can talk with NEAR contracts and render Web3 components.

If you have any questions, do not hesitate in joining us on [Discord](https://near.chat). We regularly host Office Hours, in which you can join our voice channel and ask questions.

Happy coding!

'''
'''--- docs/2.build/4.web3-apps/what-is.md ---
---
id: what-is
title: What are Web3 Apps? 
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Web3 Applications - also known as decentralized apps (dApps) - leverage [smart contracts](../2.smart-contracts/what-is.md) and blockchain data to offer **transparency**, **security** and **giving back control** to users over their assets and data.

![img](/docs/assets/welcome-pages/examples.png)

NEAR simplifies building Web3 apps for the general public, making it easy to **interact** with different blockchains, while helping to **onboard users** that are not familiarized with crypto.

---

### Why Integrating NEAR to your App?
Any application can benefit from integrating NEAR, including games, financial services, social platforms, and more.

- **Easy Onboarding**: Users can create accounts using familiar methods such as email login. Furthermore, applications can cover all transactional costs for their users, so they never have to worry about handling crypto.

- **Ownership**: Users have true ownership of digital assets within their accounts. Fungible Tokens can be used as reward systems, Non-Fungible Tokens can denote holdings, and wallets can represent digital identities.

- **Fast, Cheap and Scalable**: Near‚Äôs efficient consensus mechanism and fee model make transactions cost effective for both users and developers.

- **Security & Transparency**: All transactions and data on the blockchain is transparent and auditable, thus ensuring trust in the application‚Äôs behavior.

'''
'''--- docs/2.build/5.primitives/dao.md ---
---
id: dao
title: Decentralized Autonomous Organizations
sidebar_label: Autonomous Organizations (DAO)
hide_table_of_contents: false
---

import {FeatureList, Column, Feature} from "@site/src/components/featurelist"

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import BOSGetDAOList from "./dao/bos/get-dao-list.md"
import BOSGetProposalList from "./dao/bos/get-proposal-list.md"
import BOSCreateDAO from "./dao/bos/create-dao.md"
import BOSCreateProposal from "./dao/bos/create-proposal.md"
import BOSVoteForProposal from "./dao/bos/vote-for-proposal.md"

import WebAppGetDAOList from "./dao/web-app/get-dao-list.md"
import WebAppGetProposalList from "./dao/web-app/get-proposal-list.md"
import WebAppCreateDAO from "./dao/web-app/create-dao.md"
import WebAppCreateProposal from "./dao/web-app/create-proposal.md"
import WebAppVoteForProposal from "./dao/web-app/vote-for-proposal.md"

import CLIGetDAOList from "./dao/near-cli/get-dao-list.md"
import CLIGetProposalList from "./dao/near-cli/get-proposal-list.md"
import CLICreateDAO from "./dao/near-cli/create-dao.md"
import CLICreateProposal from "./dao/near-cli/create-proposal.md"
import CLIVoteForProposal from "./dao/near-cli/vote-for-proposal.md"

import SmartContractCreateDAO from "./dao/smart-contract/create-dao.md"
import SmartContractCreateProposal from "./dao/smart-contract/create-proposal.md"
import SmartContractVoteForProposal from "./dao/smart-contract/vote-for-proposal.md"

Decentralized Autonomous Organizations (DAOs) are self-organized groups that form around common purposes. Membership, decision making, and funding are coordinated by publicly voting on proposals through a smart contract.

![dao](/docs/primitives/dao.png)

In contrast with [FT](ft.md) and [NFT](nft.md), DAO contract's are not standardized. Because of this, in this page we will use as
reference the [Astra dao](https://near.org/astraplusplus.ndctools.near/widget/home?page=daos) [contract](https://github.com/near-daos/sputnik-dao-contract). The main concepts covered here should
easily generalizable to other DAO implementations.

---

## Create a DAO
The simplest way to create and interact with a DAO is to go through the [AstraDAO UI](https://near.org/astraplusplus.ndctools.near/widget/home?page=daos).

You can also create a DAO by interacting with the `sputnik-dao` contract.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSCreateDAO />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppCreateDAO />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLICreateDAO />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract">
    <SmartContractCreateDAO />
  </TabItem>
</Tabs>

<hr className="subsection" />

### Voting policy
Currently, DAOs support two different types of [voting policies](https://github.com/near-daos/sputnik-dao-contract#voting-policy): `TokenWeight`, and `RoleWeight`. 

When the vote policy is `TokenWeight`, the council votes using [tokens](ft.md). The weigh of a vote is the proportion of tokens used for voting over the token's total supply.

When the vote policy is `RoleWeight(role)`, the vote weigh is computed as "one over the total number of people with the role".

<details>
<summary> Voting Threshold </summary>
Both voting policies further include a `threshold` for passing a proposal, which can be a ratio or a fixed number.

The ratio indicates that you need a proportion of people/tokens to approve the proposal (e.g. half the people need to vote, and to vote positively). A fixed number indicated that you need a specific number of votes/tokens to pass the proposal (e.g. 3 people/tokens are enough to approve the proposal).
</details>

---

## List of DAOs

Query the list of DAOs existing in Sputnik Dao.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSGetDAOList />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppGetDAOList />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIGetDAOList />
  </TabItem>
</Tabs>

---

## Query Existing Proposals

These snippets will enable you to query the proposals existing in a particular DAO.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSGetProposalList />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppGetProposalList />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIGetProposalList />
  </TabItem>
</Tabs>

---

## Create proposal

Create a proposal so other users can vote in favor or against it.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSCreateProposal />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppCreateProposal />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLICreateProposal />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract">
    <SmartContractCreateProposal />
  </TabItem>
</Tabs>

:::info
By default, only **council members** can create proposals.
:::

---

## Vote for proposal

These snippet will enable your users to cast a vote for proposal of a particular DAO.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSVoteForProposal />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppVoteForProposal />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIVoteForProposal />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract">
    <SmartContractVoteForProposal />
  </TabItem>
</Tabs>

---

## Additional Resources

1. [AstroDAO UI](https://astrodao.com/) - the web app built on top of the Sputnik DAO Contract. Allows users to create and manage DAOs.
2. [List of DAOs as a NEAR component](https://near.org/onboarder.near/widget/DAOSocialSearch)
'''
'''--- docs/2.build/5.primitives/dao/bos/create-dao.md ---
```js
const args = {
  config: {
    name: "Primitives",
    purpose: "Building primitives on NEAR",
    metadata: ""
  },
  policy: ["bob.near"]
};
Near.call(
  "sputnik-dao.near",
  "create",
  {
    name: "primitives",
    args: Buffer.from(JSON.stringify(args)).toString("base64"),
  },
  300000000000000,
  6000000000000000000000000
);
```

:::note
The full list of roles and permissions you can find [here](https://github.com/near-daos/sputnik-dao-contract#roles-and-permissions).
:::
'''
'''--- docs/2.build/5.primitives/dao/bos/create-proposal.md ---
```js
Near.call(
  "primitives.sputnik-dao.near",
  "add_proposal",
  {
    proposal: {
      description: "My first proposal",
      kind: {
        Transfer: {
          token_id: "",
          receiver_id: "bob.near",
          amount: "10000000000000000000000000",
        },
      },
    },
  },
  300000000000000,
  100000000000000000000000
);
```
'''
'''--- docs/2.build/5.primitives/dao/bos/get-dao-list.md ---
```js
const result = Near.view("sputnik-dao.near", "get_dao_list");
```

<details>
<summary>Example response</summary>
<p>

```js
[
  'ref-finance.sputnik-dao.near'
  'gaming-dao.sputnik-dao.near',
  ...
]
```

</p>

</details>
'''
'''--- docs/2.build/5.primitives/dao/bos/get-proposal-list.md ---
```js
const result = Near.view(
  "nearweek-news-contribution.sputnik-dao.near",
  "get_proposals",
  { from_index: 9262, limit: 2 }
);
```

<details>
<summary>Example response</summary>
<p>

```js
[
  {
    id: 9262,
    proposer: 'pasternag.near',
    description: 'NEAR, a top non-EVM blockchain, has gone live on Router‚Äôs Testnet Mandara. With Router Nitro, our flagship dApp, users in the NEAR ecosystem can now transfer test tokens to and from NEAR onto other supported chains. $$$$https://twitter.com/routerprotocol/status/1727732303491961232',
    kind: {
      Transfer: {
        token_id: '',
        receiver_id: 'pasternag.near',
        amount: '500000000000000000000000',
        msg: null
      }
    },
    status: 'Approved',
    vote_counts: { council: [ 1, 0, 0 ] },
    votes: { 'brzk-93444.near': 'Approve' },
    submission_time: '1700828277659425683'
  },
  {
    id: 9263,
    proposer: 'fittedn.near',
    description: 'How to deploy BOS component$$$$https://twitter.com/BitkubAcademy/status/1728003163318563025?t=PiN6pwS380T1N4JuQXSONA&s=19',
    kind: {
      Transfer: {
        token_id: '',
        receiver_id: 'fittedn.near',
        amount: '500000000000000000000000',
        msg: null
      }
    },
    status: 'InProgress',
    vote_counts: { 'Whitelisted Members': [ 1, 0, 0 ] },
    votes: { 'trendheo.near': 'Approve' },
    submission_time: '1700832601849419123'
  }
]
```

</p>

</details>
'''
'''--- docs/2.build/5.primitives/dao/bos/vote-for-proposal.md ---
```js
Near.call(
  "primitives.sputnik-dao.near",
  "act_proposal",
  { id: 0, action: "VoteApprove" },
  300000000000000
);
```

:::note
Available vote options: `VoteApprove`, `VoteReject`, `VoteRemove`.
:::
'''
'''--- docs/2.build/5.primitives/dao/near-cli/create-dao.md ---
```bash

export COUNCIL='["bob.near"]'
export ARGS=`echo '{"config": {"name": "Primitives", "purpose": "Building primitives on NEAR", "metadata":""}, "policy": '$COUNCIL'}' | base64`

near call sputnikv2.testnet create "{\"name\": \"primitives\", \"args\": \"$ARGS\"}" --accountId bob.near --amount 6 --gas 150000000000000
```

:::note
The full list of roles and permissions you can find [here](https://github.com/near-daos/sputnik-dao-contract#roles-and-permissions).
:::
'''
'''--- docs/2.build/5.primitives/dao/near-cli/create-proposal.md ---
```bash
near call primitives.sputnik-dao.near add_proposal '{"proposal": {"description": "My first proposal", "kind": { "Transfer": {"token_id": "", "receiver_id": "bob.near", "amount": "10000000000000000000000000"}}}}'  --deposit 0.1 --gas 300000000000000 --accountId bob.near
```
'''
'''--- docs/2.build/5.primitives/dao/near-cli/get-dao-list.md ---
```bash
near view sputnik-dao.near get_dao_list '{}'
```

<details>
<summary>Example response</summary>
<p>

```bash
[
  'ref-finance.sputnik-dao.near'
  'gaming-dao.sputnik-dao.near',
  ...
]
```

</p>

</details>
'''
'''--- docs/2.build/5.primitives/dao/near-cli/get-proposal-list.md ---
```bash
near view nearweek-news-contribution.sputnik-dao.near get_proposals '{"from_index": 9262, "limit": 2}'
```

<details>
<summary>Example response</summary>
<p>

```bash
[
  {
    id: 9262,
    proposer: 'pasternag.near',
    description: 'NEAR, a top non-EVM blockchain, has gone live on Router‚Äôs Testnet Mandara. With Router Nitro, our flagship dApp, users in the NEAR ecosystem can now transfer test tokens to and from NEAR onto other supported chains. $$$$https://twitter.com/routerprotocol/status/1727732303491961232',
    kind: {
      Transfer: {
        token_id: '',
        receiver_id: 'pasternag.near',
        amount: '500000000000000000000000',
        msg: null
      }
    },
    status: 'Approved',
    vote_counts: { council: [ 1, 0, 0 ] },
    votes: { 'brzk-93444.near': 'Approve' },
    submission_time: '1700828277659425683'
  },
  {
    id: 9263,
    proposer: 'fittedn.near',
    description: 'How to deploy BOS component$$$$https://twitter.com/BitkubAcademy/status/1728003163318563025?t=PiN6pwS380T1N4JuQXSONA&s=19',
    kind: {
      Transfer: {
        token_id: '',
        receiver_id: 'fittedn.near',
        amount: '500000000000000000000000',
        msg: null
      }
    },
    status: 'InProgress',
    vote_counts: { 'Whitelisted Members': [ 1, 0, 0 ] },
    votes: { 'trendheo.near': 'Approve' },
    submission_time: '1700832601849419123'
  }
]
```

</p>

</details>

'''
'''--- docs/2.build/5.primitives/dao/near-cli/vote-for-proposal.md ---
```bash
near call primitives.sputnik-dao.near act_proposal '{"id": 0, "action": "VoteApprove"}' --gas 300000000000000 --accountId bob.near
```

:::note
Available vote options: `VoteApprove`, `VoteReject`, `VoteRemove`.
:::
'''
'''--- docs/2.build/5.primitives/dao/smart-contract/create-dao.md ---

```rust
// Validator interface, for cross-contract calls
#[ext_contract(ext_dao_factory_contract)]
trait ExternalDaoFactoryContract {
  fn create(&mut self, name: AccountId, args: Base64VecU8) -> Promise;
}

// Implement the contract structure
#[near]
impl Contract {
  #[payable]
  pub fn create_dao(&mut self, name: AccountId, args: Base64VecU8) -> Promise {
    let promise = ext_dao_factory_contract::ext(self.dao_factory_contract.clone())
      .with_attached_deposit(env::attached_deposit())
      .with_static_gas(Gas(30*TGAS))
      .create(name, args);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .with_static_gas(Gas(50*TGAS))
      .external_common_callback()
    )
  }

  #[private] // Public - but only callable by env::current_account_id()
  pub fn external_common_callback(&self, #[callback_result] call_result: Result<(), PromiseError>) {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting external contract")
    }
  }
}
```

'''
'''--- docs/2.build/5.primitives/dao/smart-contract/create-proposal.md ---

```rust
// Account ID that represents a token in near-sdk v3
// Need to keep it around for backward compatibility
pub type OldAccountId = String;

// How the voting policy votes get weighted.
#[near(serializers = [json, borsh])
#[derive(Clone, PartialEq)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
pub enum WeightKind {
  // Using token amounts and total delegated at the moment.
  TokenWeight,
  // Weight of the group role. Roles that don't have scoped group are not supported.
  RoleWeight,
}

// Direct weight or ratio to total weight, used for the voting policy
#[near(serializers = [json, borsh])
#[derive(Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(untagged)]
pub enum WeightOrRatio {
  Weight(U128),
  Ratio(u64, u64),
}

// Defines configuration of the vote
#[near(serializers = [json, borsh])
#[derive(Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
pub struct VotePolicy {
  // Kind of weight to use for votes.
  pub weight_kind: WeightKind,
  // Minimum number required for vote to finalize.
  // If weight kind is TokenWeight - this is minimum number of tokens required.
  //     This allows to avoid situation where the number of staked tokens from total supply is too small.
  // If RoleWeight - this is minimum number of votes.
  //     This allows to avoid situation where the role is got too small but policy kept at 1/2, for example.
  pub quorum: U128,
  // How many votes to pass this vote.
  pub threshold: WeightOrRatio,
}

#[near(serializers = [json, borsh])]
#[derive(Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
pub enum RoleKind {
  // Matches everyone, who is not matched by other roles.
  Everyone,
  // Member greater or equal than given balance. Can use `1` as non-zero balance.
  Member(U128),
  // Set of accounts.
  Group(HashSet<AccountId>),
}

#[near(serializers = [json, borsh])]
#[derive(Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
pub struct RolePermission {
  // Name of the role to display to the user.
  pub name: String,
  // Kind of the role: defines which users this permissions apply.
  pub kind: RoleKind,
  // Set of actions on which proposals that this role is allowed to execute.
  // <proposal_kind>:<action>
  pub permissions: HashSet<String>,
  // For each proposal kind, defines voting policy.
  pub vote_policy: HashMap<String, VotePolicy>,
}

// Defines voting / decision making policy of this DAO
#[near(serializers = [json, borsh])]
#[derive(Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
pub struct Policy {
  // List of roles and permissions for them in the current policy.
  pub roles: Vec<RolePermission>,
  // Default vote policy. Used when given proposal kind doesn't have special policy.
  pub default_vote_policy: VotePolicy,
  // Proposal bond.
  pub proposal_bond: U128,
  // Expiration period for proposals.
  pub proposal_period: U64,
  // Bond for claiming a bounty.
  pub bounty_bond: U128,
  // Period in which giving up on bounty is not punished.
  pub bounty_forgiveness_period: U64,
}

// Versioned policy
#[near(serializers = [json, borsh])]
#[derive(Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
pub enum VersionedPolicy {
  // Default policy with given accounts as council.
  Default(Vec<AccountId>),
  Current(Policy),
}

// Function call arguments
#[near(serializers = [json, borsh])]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
pub struct ActionCall {
  method_name: String,
  args: Base64VecU8,
  deposit: U128,
  gas: U64,
}

// Bounty information.
#[near(serializers = [json, borsh])]
#[derive(Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
pub struct Bounty {
  /// Description of the bounty.
  pub description: String,
  /// Token the bounty will be paid out.
  /// Can be "" for $NEAR or a valid account id.
  pub token: OldAccountId,
  /// Amount to be paid out.
  pub amount: U128,
  /// How many times this bounty can be done.
  pub times: u32,
  /// Max deadline from claim that can be spend on this bounty.
  pub max_deadline: U64,
}

// Info about factory that deployed this contract and if auto-update is allowed
#[near(serializers = [json, borsh])]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
pub struct FactoryInfo {
  pub factory_id: AccountId,
  pub auto_update: bool,
}

// Function call arguments
#[near(serializers = [json, borsh])]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
pub struct PolicyParameters {
  pub proposal_bond: Option<U128>,
  pub proposal_period: Option<U64>,
  pub bounty_bond: Option<U128>,
  pub bounty_forgiveness_period: Option<U64>,
}

// Votes recorded in the proposal
#[near(serializers = [json, borsh])]
#[derive(Clone, Debug)]
pub enum Vote {
  Approve = 0x0,
  Reject = 0x1,
  Remove = 0x2,
}

// Configuration of the DAO
#[near(serializers = [json, borsh])]
#[derive(Clone, Debug)]
pub struct Config {
  // Name of the DAO.
  pub name: String,
  // Purpose of this DAO.
  pub purpose: String,
  // Generic metadata. Can be used by specific UI to store additional data.
  // This is not used by anything in the contract.
  pub metadata: Base64VecU8,
}

// Kinds of proposals, doing different action
#[near(serializers = [json, borsh])]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
pub enum ProposalKind {
  // Change the DAO config.
  ChangeConfig { config: Config },
  // Change the full policy.
  ChangePolicy { policy: VersionedPolicy },
  // Add member to given role in the policy. This is short cut to updating the whole policy.
  AddMemberToRole { member_id: AccountId, role: String },
  // Remove member to given role in the policy. This is short cut to updating the whole policy.
  RemoveMemberFromRole { member_id: AccountId, role: String },
  // Calls `receiver_id` with list of method names in a single promise.
  // Allows this contract to execute any arbitrary set of actions in other contracts.
  FunctionCall {
      receiver_id: AccountId,
      actions: Vec<ActionCall>,
  },
  // Upgrade this contract with given hash from blob store.
  UpgradeSelf { hash: Base58CryptoHash },
  // Upgrade another contract, by calling method with the code from given hash from blob store.
  UpgradeRemote {
      receiver_id: AccountId,
      method_name: String,
      hash: Base58CryptoHash,
  },
  // Transfers given amount of `token_id` from this DAO to `receiver_id`.
  // If `msg` is not None, calls `ft_transfer_call` with given `msg`. Fails if this base token.
  // For `ft_transfer` and `ft_transfer_call` `memo` is the `description` of the proposal.
  Transfer {
      // Can be "" for $NEAR or a valid account id.
      token_id: OldAccountId,
      receiver_id: AccountId,
      amount: U128,
      msg: Option<String>,
  },
  // Sets staking contract. Can only be proposed if staking contract is not set yet.
  SetStakingContract { staking_id: AccountId },
  // Add new bounty.
  AddBounty { bounty: Bounty },
  // Indicates that given bounty is done by given user.
  BountyDone {
      bounty_id: u64,
      receiver_id: AccountId,
  },
  // Just a signaling vote, with no execution.
  Vote,
  // Change information about factory and auto update.
  FactoryInfoUpdate { factory_info: FactoryInfo },
  // Add new role to the policy. If the role already exists, update it. This is short cut to updating the whole policy.
  ChangePolicyAddOrUpdateRole { role: RolePermission },
  // Remove role from the policy. This is short cut to updating the whole policy.
  ChangePolicyRemoveRole { role: String },
  // Update the default vote policy from the policy. This is short cut to updating the whole policy.
  ChangePolicyUpdateDefaultVotePolicy { vote_policy: VotePolicy },
  // Update the parameters from the policy. This is short cut to updating the whole policy.
  ChangePolicyUpdateParameters { parameters: PolicyParameters },
}

#[near(serializers = [json])]
pub struct ProposalInput {
  /// Description of this proposal.
  pub description: String,
  /// Kind of proposal with relevant information.
  pub kind: ProposalKind,
}

// Validator interface, for cross-contract calls
#[ext_contract(ext_dao_contract)]
trait ExternalDaoContract {
  fn add_proposal(&mut self, proposal: ProposalInput) -> Promise;
}

// Implement the contract structure
#[near]
impl Contract {
  #[payable]
  pub fn create_proposal(&mut self, proposal: ProposalInput) -> Promise {
    let promise = ext_dao_contract::ext(self.dao_contract.clone())
      .with_attached_deposit(env::attached_deposit())
      .with_static_gas(Gas(5*TGAS))
      .add_proposal(proposal);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .with_static_gas(Gas(50*TGAS))
      .external_proposal_callback()
    )
  }

  #[private] // Public - but only callable by env::current_account_id()
  pub fn external_proposal_callback(&self, #[callback_result] call_result: Result<u64, PromiseError>) -> Option<u64> {
    if call_result.is_err() {
      log!("There was an error contacting external contract");
      return None;
    }

    // Return the proposal id
    let id = call_result.unwrap();
    return Some(id);
  }
}
```

'''
'''--- docs/2.build/5.primitives/dao/smart-contract/vote-for-proposal.md ---

```rust
// Set of possible action to take
#[near(serializers = [json, borsh])]
#[derive(Debug)]
pub enum Action {
  // Action to add proposal. Used internally.
  AddProposal,
  // Action to remove given proposal. Used for immediate deletion in special cases.
  RemoveProposal,
  // Vote to approve given proposal or bounty.
  VoteApprove,
  // Vote to reject given proposal or bounty.
  VoteReject,
  // Vote to remove given proposal or bounty (because it's spam).
  VoteRemove,
  // Finalize proposal, called when it's expired to return the funds
  // (or in the future can be used for early proposal closure).
  Finalize,
  // Move a proposal to the hub to shift into another DAO.
  MoveToHub,
}

// Validator interface, for cross-contract calls
#[ext_contract(ext_dao_contract)]
trait ExternalDaoContract {
  fn act_proposal(&mut self, id: u64, action: Action, memo: Option<String>) -> Promise;
}

// Implement the contract structure
#[near]
impl Contract {
  #[payable]
  pub fn act_proposal(&mut self, id: u64, action: Action, memo: Option<String>) -> Promise {
    let promise = ext_dao_contract::ext(self.dao_contract.clone())
      .with_attached_deposit(env::attached_deposit())
      .with_static_gas(Gas(10*TGAS))
      .act_proposal(id, action, memo);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .external_common_callback()
    )
  }

  #[private] // Public - but only callable by env::current_account_id()
  pub fn external_common_callback(&self, #[callback_result] call_result: Result<(), PromiseError>) {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting external contract")
    }
  }
}
```

'''
'''--- docs/2.build/5.primitives/dao/web-app/create-dao.md ---

```js
import { Wallet } from './near-wallet';

const DAO_FACTORY_CONTRACT_ADDRESS = "sputnik-dao.near";
const wallet = new Wallet({ createAccessKeyFor: DAO_FACTORY_CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'create',
  args: {
    name: "primitives",
    args: btoa({
      config: {
        name: "Primitives",
        purpose: "Building primitives on NEAR",
        metadata: ""
      },
      policy: ["bob.near"]
    }),
  },
  contractId: DAO_FACTORY_CONTRACT_ADDRESS,
  gas: 300000000000000,
  deposit: 6000000000000000000000000
});
```

:::note
The full list of roles and permissions you can find [here](https://github.com/near-daos/sputnik-dao-contract#roles-and-permissions).
:::

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/dao/web-app/create-proposal.md ---

```js
import { Wallet } from './near-wallet';

const DAO_CONTRACT_ADDRESS = "primitives.sputnik-dao.near";
const wallet = new Wallet({ createAccessKeyFor: DAO_CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'add_proposal',
  args: {
    proposal: {
      description: "My first proposal",
      kind: {
        Transfer: {
          token_id: "",
          receiver_id: "bob.near",
          amount: "10000000000000000000000000",
        },
      },
    },
  },
  contractId: DAO_CONTRACT_ADDRESS,
  gas: 300000000000000,
  deposit: 100000000000000000000000
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/dao/web-app/get-dao-list.md ---

```js
import { Wallet } from './near-wallet';

const DAO_FACTORY_CONTRACT_ADDRESS = "sputnik-dao.near";
const wallet = new Wallet({ createAccessKeyFor: DAO_FACTORY_CONTRACT_ADDRESS });
 
await wallet.viewMethod({
  method: 'get_dao_list',
  args: {},
  contractId: DAO_FACTORY_CONTRACT_ADDRESS
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/dao/web-app/get-proposal-list.md ---

```js
import { Wallet } from './near-wallet';

const DAO_CONTRACT_ADDRESS = "nearweek-news-contribution.sputnik-dao.near";
const wallet = new Wallet({ createAccessKeyFor: DAO_CONTRACT_ADDRESS });
 
await wallet.viewMethod({
  method: 'get_proposals',
  args: { from_index: 9262, limit: 2 },
  contractId: DAO_CONTRACT_ADDRESS
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/dao/web-app/vote-for-proposal.md ---

```js
import { Wallet } from './near-wallet';

const DAO_CONTRACT_ADDRESS = "primitives.sputnik-dao.near";
const wallet = new Wallet({ createAccessKeyFor: DAO_CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'act_proposal',
  args: { id: 0, action: "VoteApprove" },
  contractId: DAO_CONTRACT_ADDRESS,
  gas: 300000000000000,
});
```

:::note
Available vote options: `VoteApprove`, `VoteReject`, `VoteRemove`.
:::

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/dex.md ---
---
id: dex
title: Decentralized Exchanges (DEX)
hide_table_of_contents: false
---

import {FeatureList, Column, Feature} from "@site/src/components/featurelist"

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import BOSGetPrice from "./dex/bos/get-price.md"
import BOSSwap from "./dex/bos/swap.md"
import BOSGetPools from "./dex/bos/get-pools.md"
import BOSGetDepositBalances from "./dex/bos/get-deposit-balances.md"

import WebAppGetPrice from "./dex/web-app/get-price.md"
import WebAppSwap from "./dex/web-app/swap.md"
import WebAppGetPools from "./dex/web-app/get-pools.md"
import WebAppGetDepositBalances from "./dex/web-app/get-deposit-balances.md"

import CLISwap from "./dex/near-cli/swap.md"
import CLIGetPools from "./dex/near-cli/get-pools.md"
import CLIGetDepositBalances from "./dex/near-cli/get-deposit-balances.md"

import SmartContractSwap from "./dex/smart-contract/swap.md"
import SmartContractGetPools from "./dex/smart-contract/get-pools.md"
import SmartContractGetDepositBalances from "./dex/smart-contract/get-deposit-balances.md"

A Decentralized Exchange (DEX) is an application that allows users to trade tokens (native & fungible tokens) through smart contracts.

![dex](/docs/primitives/dex.png)

In brief, DEXs work by having [pools of token pairs](https://guide.ref.finance/products/overview/pooling) (e.g. NEAR-USDC) that users can deposit tokens into.

The ratio of the tokens in the pool determines the exchange rate for a swap. Indeed, swapping is adding tokens to one side of the pool while removing tokens from the other side of the pool.

:::info

This docs refer to [Ref Finance](https://www.ref.finance/), a community built DEX in NEAR.

Please check their [docs](https://guide.ref.finance/developers-1/cli-trading) for more information.

:::

---

## Query Token Exchange Rate
One can query the exchange rate of a token pair by calling the `get-token-price` method on the DEX contract.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSGetPrice />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppGetPrice />
  </TabItem>
</Tabs>

---

## Query Whitelisted Tokens
Anyone list tokens for sale in the DEX. This is why, in order to protect users, the DEX contract has a list of whitelisted tokens that can be traded.

<Tabs groupId="code-tabs">
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    
```bash
near view v2.ref-finance.near get_whitelisted_tokens
```

</TabItem>

</Tabs>

<details>

<summary> Examples Response </summary>

```bash
  'wrap.near',
  'usdt.tether-token.near',
  'berryclub.ek.near',
  'farm.berryclub.ek.near',
  'token.v2.ref-finance.near',
  'token.paras.near',
  'marmaj.tkn.near',
  'meta-pool.near',
  ...
```

</details>

---

## Register in the DEX
In order to use the contract, make sure to register your account in the DEX by paying for the storage you will use in order to keep track of your balances.

<Tabs groupId="code-tabs">
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    
```bash
near call v2.ref-finance.near storage_deposit '' --accountId <account> --amount 0.1
```

</TabItem>

</Tabs>

---

## Deposit funds

In order to swap tokens, one must first deposit tokens into the DEX. For this, you will need to transfer the FT you want to swap to the DEX contract.

<Tabs groupId="code-tabs">
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    
```bash
near call token.v2.ref-finance.near ft_transfer_call {"receiver_id": "v2.ref-finance.near", "amount": "1000000000000", "msg": ""} --gas 300000000000000 --depositYocto 1 --accountId <account>
```

</TabItem>

</Tabs>

:::danger

Do **NOT** transfer **NEAR** tokens to Ref Finance. Instead, call `near_deposit` in the [`wrap.near`](https://nearblocks.io/address/wrap.near) contract, attaching the amount of NEAR you want to swap.

This will mint `wrap.near` for you, which you can then transfer to Ref Finance.

:::

---

## Get Deposit Balances

Query your deposit balances by calling the `get_deposits` method:

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSGetDepositBalances />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppGetDepositBalances />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIGetDepositBalances />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract">
    <SmartContractGetDepositBalances />
  </TabItem>
</Tabs>

---

### Query Pools

DEXs work by having multiple pools of token pairs (e.g. NEAR-USDC) that users can deposit tokens into.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSGetPools />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppGetPools />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIGetPools />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract">
    <SmartContractGetPools />
  </TabItem>
</Tabs>

---

## Swap tokens
In order to swap a token for another, you need to [have funds](#deposit-funds), and there needs to [**exist a pool**](#query-pools) that has **both tokens** on it.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSSwap />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppSwap />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLISwap />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract">
    <SmartContractSwap />
  </TabItem>
</Tabs>

---

## Additional Resources

1. [Claim Fungible Tokens from Lockup](https://near.org/near/widget/ComponentDetailsPage?src=whtt.near/widget/Draft-0) - the example how to claim locked tokens from the `lockup.burrow.near` contract.
2. [BSC Dex Collection](https://near.org/near/widget/ComponentDetailsPage?src=bluebiu.near/widget/Bsc.Swap.Dex) - the example of how to build simple swap page for a DEX.

'''
'''--- docs/2.build/5.primitives/dex/bos/get-deposit-balances.md ---
```js
const ammContract = "v2.ref-finance.near";
const depositBalances = Near.view(
  ammContract,
  "get_deposits",
  {
    account_id: "bob.near"
  }
);
```

<details>
<summary>Example response</summary>
<p>

```json
{
  "token.v2.ref-finance.near": "0",
  "wrap.near": "0"
}
```

</p>

</details>
'''
'''--- docs/2.build/5.primitives/dex/bos/get-pools.md ---
```js
const ammContract = "v2.ref-finance.near";
const result = Near.view(
  ammContract,
  "get_pools",
  {
    from_index: 0,
    limit: 1000
  }
);
```

<details>
<summary>Example response</summary>
<p>

```js
[
  {
    pool_kind: 'SIMPLE_POOL',
    token_account_ids: [ 'token.skyward.near', 'wrap.near' ],
    amounts: [ '51865812079751349630100', '6254162663147994789053210138' ],
    total_fee: 30,
    shares_total_supply: '1305338644973934698612124055',
    amp: 0
  },
  {
    pool_kind: 'SIMPLE_POOL',
    token_account_ids: [
      'c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.factory.bridge.near',
      'wrap.near'
    ],
    amounts: [ '783621938569399817', '1100232280852443291118200599' ],
    total_fee: 30,
    shares_total_supply: '33923015415693335344747628',
    amp: 0
  }
]
```

</p>

</details>
'''
'''--- docs/2.build/5.primitives/dex/bos/get-price.md ---
```js
const tokenContract = "token.v2.ref-finance.near";
const tokenPriceResult = fetch(
  `https://indexer.ref.finance/get-token-price?token_id=${tokenContract}`
).body;
const tokenPriceValue = JSON.parse(tokenPriceResult);
```

<details>
<summary>Example response</summary>
<p>

```json
{
  "token_contract_id": "token.v2.ref-finance.near",
  "price": "0.08153090"
}
```

</p>

</details>

:::tip
Ref Finance has a method to [get all token prices at once](https://indexer.ref.finance/list-token-price).
:::
'''
'''--- docs/2.build/5.primitives/dex/bos/swap.md ---
```js
const ammContract = "v2.ref-finance.near";
const result = Near.call(
  ammContract,
  "swap",
  {
    actions: [
      {
        pool_id: 79,
        token_in: "token.v2.ref-finance.near",
        token_out: "wrap.near",
        amount_in: "100000000000000000",
        min_amount_out: "1",
      },
    ],
  },
  300000000000000,
  1
);
```

<details>
<summary>Example response</summary>

```json
"5019606679394603179450"
```
</details>
'''
'''--- docs/2.build/5.primitives/dex/near-cli/get-deposit-balances.md ---
```bash
near view v2.ref-finance.near get_deposits '{"account_id": "bob.near"}'
```

<details>
<summary>Example response</summary>
<p>

```bash
{
  'token.v2.ref-finance.near': '0',
  'wrap.near': "0"
}
```

</p>

</details>

'''
'''--- docs/2.build/5.primitives/dex/near-cli/get-pools.md ---
```bash
near view v2.ref-finance.near get_pools '{"from_index": 0, "limit": 1000}'
```

<details>
<summary>Example response</summary>
<p>

```bash
[
  {
    pool_kind: 'SIMPLE_POOL',
    token_account_ids: [ 'token.skyward.near', 'wrap.near' ],
    amounts: [ '51865812079751349630100', '6254162663147994789053210138' ],
    total_fee: 30,
    shares_total_supply: '1305338644973934698612124055',
    amp: 0
  },
  {
    pool_kind: 'SIMPLE_POOL',
    token_account_ids: [
      'c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.factory.bridge.near',
      'wrap.near'
    ],
    amounts: [ '783621938569399817', '1100232280852443291118200599' ],
    total_fee: 30,
    shares_total_supply: '33923015415693335344747628',
    amp: 0
  }
]
```

</p>

</details>

'''
'''--- docs/2.build/5.primitives/dex/near-cli/swap.md ---
```bash
near call v2.ref-finance.near swap "{\"actions\": [{\"pool_id\": 79, \"token_in\": \"token.v2.ref-finance.near\", \"amount_in\": \"100000000000000000\", \"token_out\": \"wrap.near\", \"min_amount_out\": \"1\"}]}" --gas 300000000000000 --depositYocto 1
 --accountId bob.near
```

<details>
<summary>Example response</summary>
<p>

```bash
'5019606679394603179450'
```

</p>

</details>
'''
'''--- docs/2.build/5.primitives/dex/smart-contract/get-deposit-balances.md ---
```rust
// Validator interface, for cross-contract calls
#[ext_contract(ext_amm_contract)]
trait ExternalAmmContract {
  fn get_deposits(&self, account_id: AccountId) -> Promise;
}

// Implement the contract structure
#[near]
impl Contract {
  #[private] // Public - but only callable by env::current_account_id()
  pub fn external_get_deposits_callback(&self, #[callback_result] call_result: Result<HashMap<AccountId, U128>, PromiseError>) -> Option<HashMap<AccountId, U128>> {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting external contract");
      return None;
    }

    // Return the pools data
    let deposits_data = call_result.unwrap();
    return Some(deposits_data);
  }

  pub fn get_contract_deposits(&self) -> Promise {
    let promise = ext_amm_contract::ext(self.amm_contract.clone())
      .get_deposits(env::current_account_id());

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .external_get_deposits_callback()
    )
  }
}
```

'''
'''--- docs/2.build/5.primitives/dex/smart-contract/get-pools.md ---
```rust
#[near(serializers = [json])]
pub struct PoolInfo {
  /// Pool kind.
  pub pool_kind: String,
  /// List of tokens in the pool.
  pub token_account_ids: Vec<AccountId>,
  /// How much NEAR this contract has.
  pub amounts: Vec<U128>,
  /// Fee charged for swap.
  pub total_fee: u32,
  /// Total number of shares.
  pub shares_total_supply: U128,
  pub amp: u64,
}

// Validator interface, for cross-contract calls
#[ext_contract(ext_amm_contract)]
trait ExternalAmmContract {
  fn get_pools(&self, from_index: u64, limit: u64) -> Promise;
}

// Implement the contract structure
#[near]
impl Contract {
  #[private] // Public - but only callable by env::current_account_id()
  pub fn external_get_pools_callback(&self, #[callback_result] call_result: Result<Vec<PoolInfo>, PromiseError>) -> Option<Vec<PoolInfo>> {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting external contract");
      return None;
    }

    // Return the pools data
    let pools_data = call_result.unwrap();
    return Some(pools_data);
  }

  pub fn get_amm_pools(&self, from_index: u64, limit: u64) -> Promise {
    let promise = ext_amm_contract::ext(self.amm_contract.clone())
      .get_pools(from_index, limit);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .external_get_pools_callback()
    )
  }
}
```

'''
'''--- docs/2.build/5.primitives/dex/smart-contract/swap.md ---
```rust
#[near(serializers = [json])]
pub struct SwapAction {
    /// Pool which should be used for swapping.
    pub pool_id: u64,
    /// Token to swap from.
    pub token_in: AccountId,
    /// Amount to exchange.
    /// If amount_in is None, it will take amount_out from previous step.
    /// Will fail if amount_in is None on the first step.
    pub amount_in: Option<U128>,
    /// Token to swap into.
    pub token_out: AccountId,
    /// Required minimum amount of token_out.
    pub min_amount_out: U128,
}

// Validator interface, for cross-contract calls
#[ext_contract(ext_amm_contract)]
trait ExternalAmmContract {
  fn swap(&self, actions: Vec<SwapAction>) -> Promise;
}

// Implement the contract structure
#[near]
impl Contract {
  #[private] // Public - but only callable by env::current_account_id()
  pub fn external_call_callback(&self, #[callback_result] call_result: Result<String, PromiseError>) {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting external contract");
    }
  }

  #[payable]
  pub fn swap_tokens(&mut self, pool_id: u64, token_in: AccountId, token_out: AccountId, amount_in: U128, min_amount_out: U128) -> Promise {
    assert_eq!(env::attached_deposit(), 1, "Requires attached deposit of exactly 1 yoctoNEAR");

    let swap_action = SwapAction {
      pool_id,
      token_in,
      token_out,
      amount_in: Some(amount_in),
      min_amount_out
    };

    let mut actions = Vec::new();
    actions.push(swap_action);

    let promise = ext_amm_contract::ext(self.amm_contract.clone())
      .with_static_gas(Gas(150*TGAS))
      .with_attached_deposit(YOCTO_NEAR)
      .swap(actions);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .with_static_gas(Gas(100*TGAS))
      .external_call_callback()
    )
  }
}
```

'''
'''--- docs/2.build/5.primitives/dex/web-app/get-deposit-balances.md ---
```js
const AMM_CONTRACT_ADDRESS = "v2.ref-finance.near";
const wallet = new Wallet({ createAccessKeyFor: AMM_CONTRACT_ADDRESS });
 
await wallet.viewMethod({
  method: 'get_deposits',
  args: {
   account_id: "bob.near"
  },
  contractId: AMM_CONTRACT_ADDRESS,
});
```
_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

<details>
<summary>Example response</summary>
<p>

```json
{
  "token.v2.ref-finance.near": "0",
  "wrap.near": "0"
}
```

</p>

</details>
'''
'''--- docs/2.build/5.primitives/dex/web-app/get-pools.md ---
```js
const AMM_CONTRACT_ADDRESS = "v2.ref-finance.near";
const wallet = new Wallet({ createAccessKeyFor: AMM_CONTRACT_ADDRESS });
 
await wallet.viewMethod({
  method: 'get_pools',
  args: {
    from_index: 0,
    limit: 1000
  },
  contractId: AMM_CONTRACT_ADDRESS,
});
```
_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

<details>
<summary>Example response</summary>
<p>

```js
[
  {
    pool_kind: 'SIMPLE_POOL',
    token_account_ids: [ 'token.skyward.near', 'wrap.near' ],
    amounts: [ '51865812079751349630100', '6254162663147994789053210138' ],
    total_fee: 30,
    shares_total_supply: '1305338644973934698612124055',
    amp: 0
  },
  {
    pool_kind: 'SIMPLE_POOL',
    token_account_ids: [
      'c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.factory.bridge.near',
      'wrap.near'
    ],
    amounts: [ '783621938569399817', '1100232280852443291118200599' ],
    total_fee: 30,
    shares_total_supply: '33923015415693335344747628',
    amp: 0
  }
]
```

</p>

</details>
'''
'''--- docs/2.build/5.primitives/dex/web-app/get-price.md ---
```js
const tokenContract = "token.v2.ref-finance.near";
const tokenPriceResult = await fetch(
  `https://indexer.ref.finance/get-token-price?token_id=${tokenContract}`
);
const tokenPriceValue = await tokenPriceResult.json();
```
_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_

<details>
<summary>Example response</summary>
<p>

```json
{
  "token_contract_id": "token.v2.ref-finance.near",
  "price": "0.08153090"
}
```

</p>

</details>

:::tip
Ref Finance has a method to [get all token prices at once](https://indexer.ref.finance/list-token-price).
:::

'''
'''--- docs/2.build/5.primitives/dex/web-app/swap.md ---
```js
import { Wallet } from './near-wallet';

const AMM_CONTRACT_ADDRESS = "v2.ref-finance.near";
const wallet = new Wallet({ createAccessKeyFor: AMM_CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'swap',
  args: {
   actions: [
      {
        pool_id: 79,
        token_in: "token.v2.ref-finance.near",
        token_out: "wrap.near",
        amount_in: "100000000000000000",
        min_amount_out: "1",
      },
    ],
  },
  contractId: AMM_CONTRACT_ADDRESS,
  gas: 300000000000000,
  deposit: 1
});
```
_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_

<details>
<summary>Example response</summary>

```json
"5019606679394603179450"
```
</details>
'''
'''--- docs/2.build/5.primitives/ft.md ---
---
id: ft
title: Fungible Tokens (FT)
hide_table_of_contents: false
---

import {FeatureList, Column, Feature} from "@site/src/components/featurelist"

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import BOSGetMetadata from "./ft/bos/get-metadata.md"
import BOSCheckBalance from "./ft/bos/check-balance.md"
import BOSSendToken from "./ft/bos/send.md"
import BOSRegister from "./ft/bos/register.md"
import BOSAttachTokenToCall from "./ft/bos/attach-to-call.md"
import BOSCreateToken from "./ft/bos/create.md"

import WebAppGetMetadata from "./ft/web-app/get-metadata.md"
import WebAppCheckBalance from "./ft/web-app/check-balance.md"
import WebAppSendToken from "./ft/web-app/send.md"
import WebAppRegister from "./ft/web-app/register.md"
import WebAppAttachTokenToCall from "./ft/web-app/attach-to-call.md"
import WebAppCreateToken from "./ft/web-app/create.md"

import CLIGetMetadata from "./ft/near-cli/get-metadata.md"
import CLICheckBalance from "./ft/near-cli/check-balance.md"
import CLISendToken from "./ft/near-cli/send.md"
import CLIRegister from "./ft/near-cli/register.md"
import CLIAttachTokenToCall from "./ft/near-cli/attach-to-call.md"
import CLICreateToken from "./ft/near-cli/create.md"

import SmartContractSendToken from "./ft/smart-contract/send.md"
import SmartContractAttachTokenToCall from "./ft/smart-contract/attach-to-call.md"

Besides the native NEAR token, NEAR accounts have access to a [multitude of tokens](https://guide.ref.finance/developers-1/cli-trading#query-whitelisted-tokens) to use thoughtout the ecosystem. Moreover, it is even possible for users to create their own fungible tokens.

In contrast with the NEAR native token, fungible token (FT) are **not stored** in the user's account. In fact, each FT lives in **their own contract** which is in charge of doing **bookkeeping**. This is, the contract keeps track of how many tokens each user has, and handles transfers internally.

![FT](/docs/primitives/ft.png)

In order for a contract to be considered a FT-contract it has to follow the [**NEP-141 and NEP-148 standards**](https://nomicon.io/Standards/FungibleToken/). The **NEP-141** & **NEP-148** standards explain the **minimum interface** required to be implemented, as well as the expected functionality.

---

## Token Factory
You can create an FT using the community tool [Token Farm](https://tkn.farm/). Token farm is a token factory, you can interact with it through its graphical interface, or by making calls to its contract.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSCreateToken />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppCreateToken />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLICreateToken />
  </TabItem>
</Tabs>

The FT you create will live in the account `<your_token_symbol>.tkn.near` (e.g. `test.tkn.near`).

---

## Deploying Your Own Contract

You can also create a fungible token by deploying and initializing a [canonical FT contract](https://github.com/near-examples/FT).

On initialization you will define the token's metadata such as its name (e.g. Ethereum), symbol (e.g. ETH) and total supply (e.g. 10M). You will also define an `owner`, which will own the tokens **total supply**.

To initialize a FT contract you will need to deploy it and then call the `new` method defining the token's metadata.

```bash
near deploy <account-id> --wasmFile fungible_token.wasm

near call <account-id> new '{"owner_id": "<owner-account>", "total_supply": "1000000000000000", "metadata": { "spec": "ft-1.0.0", "name": "Example Token Name", "symbol": "EXLT", "decimals": 8 }}' --accountId <account-id>
```

:::tip
Check the [Contract Wizard](https://near.org/contractwizard.near/widget/ContractWizardUI) to create a personalized FT contract!.
:::

---

## Querying Metadata
You can query the FT's metadata by calling the `ft_metadata`.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSGetMetadata />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppGetMetadata />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIGetMetadata />
  </TabItem>
</Tabs>

---

## Checking Balance
To know how many coins a user has you will need to query the method `ft_balance_of`.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSCheckBalance />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppCheckBalance />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLICheckBalance />
  </TabItem>
</Tabs>

---

## Registering a User
In order for an user to own and transfer tokens they need to first **register** in the contract. This is done by calling `storage_deposit` and attaching 0.00125‚ìÉ.

By calling this `storage_deposit` the user can register themselves or **register other users**.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSRegister />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppRegister />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIRegister />
  </TabItem>
</Tabs>

:::info
You can make sure a user is registered by calling `storage_balance_of`.
:::

:::tip
After a user calls the `storage_deposit` the FT will appear in their Wallets. 
:::

---

## Transferring Tokens
To send FT to another account you will use the `ft_transfer` method, indicating the receiver and the amount of FT you want to send.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSSendToken />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppSendToken />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLISendToken />
  </TabItem>
  <TabItem value="üìÑ Contract"  label="üìÑ Contract"  default>
    <SmartContractSendToken />
  </TabItem>
</Tabs>

---

## Attaching FTs to a Call
Natively, only NEAR tokens (‚ìÉ) can be attached to a function calls. However, the FT standard enables to attach fungible tokens in a call by using the FT-contract as intermediary. This means that, instead of you attaching tokens directly to the call, you ask the FT-contract to do both a transfer and a function call in your name.

Let's assume that you need to deposit FTs on Ref Finance.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSAttachTokenToCall />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppAttachTokenToCall />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIAttachTokenToCall />
  </TabItem>
  <TabItem value="üìÑ Contract"  label="üìÑ Contract"  default>
    <SmartContractAttachTokenToCall />
  </TabItem>
</Tabs>

How it works:

1. You call ft_transfer_call in the FT contract passing: the receiver, a message, and the amount.
2. The FT contract transfers the amount to the receiver.
3. The FT contract calls receiver.ft_on_transfer(sender, msg, amount)
4. The FT contract handles errors in the ft_resolve_transfer callback.
5. The FT contract returns you how much of the attached amount was actually used.

---

## Handling Deposits (Contract Only)

If you want your contract to handle deposit in FTs you have to implement the `ft_on_transfer` method. When executed, such method will know:

- Which FT was transferred, since it is the predecessor account.
- Who is sending the FT, since it is a parameter
- How many FT were transferred, since it is a parameter
- If there are any parameters encoded as a message

The `ft_on_transfer` must return how many FT tokens have to **be refunded**, so the FT contract gives them back to the sender.

```rust
// Implement the contract structure
#[near(contract_state)]
impl Contract {}

#[near]
impl FungibleTokenReceiver for Contract {
  // Callback on receiving tokens by this contract.
  // `msg` format is either "" for deposit or `TokenReceiverMessage`.
  fn ft_on_transfer(
    &mut self,
    sender_id: AccountId,
    amount: U128,
    msg: String,
  ) -> PromiseOrValue<U128> {
    let token_in = env::predecessor_account_id();

    assert!(token_in == self.ft_contract, "{}", "The token is not supported");
    assert!(amount >= self.price, "{}", "The attached amount is not enough");

    env::log_str(format!("Sender id: {:?}", sender_id).as_str());

    if msg.is_empty() {
      // Your internal logic here
      PromiseOrValue::Value(U128(0))
    } else {
      let message =
        serde_json::from_str::<TokenReceiverMessage>(&msg).expect("WRONG_MSG_FORMAT");
      match message {
        TokenReceiverMessage::Action {
          buyer_id,
        } => {
          let buyer_id = buyer_id.map(|x| x.to_string());
          env::log_str(format!("Target buyer id: {:?}", buyer_id).as_str());
          // Your internal business logic
          PromiseOrValue::Value(U128(0))
        }
      }
    }
  }
}
```

---

## Additional Resources

1. [NEP-141 and NEP-148 standards](https://nomicon.io/Standards/Tokens/FungibleToken/)
2. [FT Event Standards](https://nomicon.io/Standards/Tokens/FungibleToken/Event)
3. [FT reference implementation](https://github.com/near-examples/FT)
4. [Fungible Tokens 101](../../3.tutorials/fts/0-intro.md) - a set of tutorials that cover how to create a FT contract using Rust.

'''
'''--- docs/2.build/5.primitives/ft/bos/attach-to-call.md ---
```js
const tokenContract = "token.v2.ref-finance.near";
const result = Near.call(
  tokenContract,
  "ft_transfer_call",
  {
    receiver_id: "v2.ref-finance.near",
    amount: "100000000000000000",
    msg: "",
  },
  300000000000000,
  1
);
```

<details>
<summary>Example response</summary>
<p>

```json
'100000000000000000'
```

</p>

</details>
'''
'''--- docs/2.build/5.primitives/ft/bos/check-balance.md ---
:::info
Remember about fungible token precision. You may need this value to show a response of balance requests in an understandable-to-user way in your app. How to get precision value (decimals) you may find [above](#get-token-metadata).
:::

```js
const tokenContract = "token.v2.ref-finance.near";
const userTokenBalance = Near.view(tokenContract, "ft_balance_of", {
  account_id: "bob.near",
});
```

<details>
<summary>Example response</summary>
<p>

```json
"3479615037675962643842"
```

</p>

</details>
'''
'''--- docs/2.build/5.primitives/ft/bos/create.md ---
```js
const args = {
  args: {
    owner_id: "bob.near",
    total_supply: "1000000000",
    metadata: {
      spec: "ft-1.0.0",
      name: "Test Token",
      symbol: "test",
      icon: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
      decimals: 18,
    },
  },
  account_id: "bob.near",
};

Near.call("tkn.near", "create_token", args, 300000000000000, "2234830000000000000000000");
```
'''
'''--- docs/2.build/5.primitives/ft/bos/get-metadata.md ---
```js
const tokenContract = "token.v2.ref-finance.near";
const tokenMetadata = Near.view(tokenContract, "ft_metadata", {});
```

<details>
<summary>Example response</summary>
<p>

```json
{
  "spec": "ft-1.0.0",
  "name": "Ref Finance Token",
  "symbol": "REF",
  "icon": "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='16 24 248 248' style='background: %23000'%3E%3Cpath d='M164,164v52h52Zm-45-45,20.4,20.4,20.6-20.6V81H119Zm0,18.39V216h41V137.19l-20.6,20.6ZM166.5,81H164v33.81l26.16-26.17A40.29,40.29,0,0,0,166.5,81ZM72,153.19V216h43V133.4l-11.6-11.61Zm0-18.38,31.4-31.4L115,115V81H72ZM207,121.5h0a40.29,40.29,0,0,0-7.64-23.66L164,133.19V162h2.5A40.5,40.5,0,0,0,207,121.5Z' fill='%23fff'/%3E%3Cpath d='M189 72l27 27V72h-27z' fill='%2300c08b'/%3E%3C/svg%3E%0A",
  "reference": null,
  "reference_hash": null,
  "decimals": 18
}
```

</p>

</details>
'''
'''--- docs/2.build/5.primitives/ft/bos/register.md ---
```js
Near.call(
  tokenContract,
  "storage_deposit",
  { account_id: "alice.near" },
  undefined,
  1250000000000000000000
);
```

'''
'''--- docs/2.build/5.primitives/ft/bos/send.md ---
```js
const tokenContract = "token.v2.ref-finance.near";
Near.call(
  tokenContract,
  "ft_transfer",
  {
    receiver_id: "alice.near",
    amount: "100000000000000000",
  },
  undefined,
  1
);
```
'''
'''--- docs/2.build/5.primitives/ft/near-cli/attach-to-call.md ---
```bash
near call token.v2.ref-finance.near ft_transfer_call '{"receiver_id": "v2.ref-finance.near", "amount": "100000000000000000", "msg": ""}' --gas 300000000000000 --depositYocto 1 --accountId bob.near
```

<details>
<summary>Example response</summary>
<p>

```bash
'100000000000000000'
```

</p>

</details>
'''
'''--- docs/2.build/5.primitives/ft/near-cli/check-balance.md ---
```bash
near view token.v2.ref-finance.near ft_balance_of '{"account_id": "bob.near"}'
```

<details>
<summary>Example response</summary>
<p>

```bash
'376224322825327177426'
```

</p>

</details>
'''
'''--- docs/2.build/5.primitives/ft/near-cli/create.md ---
```bash
near call tkn.near create_token '{"args":{"owner_id": "bob.near","total_supply": "1000000000","metadata":{"spec": "ft-1.0.0","name": "Test Token","symbol": "TTTEST","icon": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7","decimals": 18}},"account_id": "bob.near"}' --gas 300000000000000 --depositYocto 2234830000000000000000000 --accountId bob.near
```
'''
'''--- docs/2.build/5.primitives/ft/near-cli/get-metadata.md ---
```bash
near view token.v2.ref-finance.near ft_metadata
```

<details>
<summary>Example response</summary>
<p>

```bash
{
  spec: "ft-1.0.0",
  name: "Ref Finance Token",
  symbol: "REF",
  icon: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='16 24 248 248' style='background: %23000'%3E%3Cpath d='M164,164v52h52Zm-45-45,20.4,20.4,20.6-20.6V81H119Zm0,18.39V216h41V137.19l-20.6,20.6ZM166.5,81H164v33.81l26.16-26.17A40.29,40.29,0,0,0,166.5,81ZM72,153.19V216h43V133.4l-11.6-11.61Zm0-18.38,31.4-31.4L115,115V81H72ZM207,121.5h0a40.29,40.29,0,0,0-7.64-23.66L164,133.19V162h2.5A40.5,40.5,0,0,0,207,121.5Z' fill='%23fff'/%3E%3Cpath d='M189 72l27 27V72h-27z' fill='%2300c08b'/%3E%3C/svg%3E%0A",
  reference: null,
  reference_hash: null,
  decimals: 18
}
```

</p>

</details>
'''
'''--- docs/2.build/5.primitives/ft/near-cli/register.md ---
```bash
near call token.v2.ref-finance.near storage_deposit '{"account_id": "alice.near"}' --depositYocto 1250000000000000000000 --accountId bob.near
```

'''
'''--- docs/2.build/5.primitives/ft/near-cli/send.md ---
```bash
near call token.v2.ref-finance.near ft_transfer '{"receiver_id": "alice.near", "amount": "100000000000000000"}' --depositYocto 1 --accountId bob.near
```
'''
'''--- docs/2.build/5.primitives/ft/smart-contract/attach-to-call.md ---

```rust
#[payable]
pub fn call_with_attached_tokens(&mut self, receiver_id: AccountId, amount: U128) -> Promise {
  assert_eq!(env::attached_deposit(), 1, "Requires attached deposit of exactly 1 yoctoNEAR");

  let promise = ext(self.ft_contract.clone())
    .with_static_gas(Gas(150*TGAS))
    .with_attached_deposit(YOCTO_NEAR)
    .ft_transfer_call(receiver_id, amount, None, "".to_string());

  return promise.then( // Create a promise to callback query_greeting_callback
    Self::ext(env::current_account_id())
    .with_static_gas(Gas(100*TGAS))
    .external_call_callback()
  )
}
```
'''
'''--- docs/2.build/5.primitives/ft/smart-contract/send.md ---
```rust
#[near]
impl Contract {
  #[payable]
  pub fn send_tokens(&mut self, receiver_id: AccountId, amount: U128) -> Promise {
    assert_eq!(env::attached_deposit(), 1, "Requires attached deposit of exactly 1 yoctoNEAR");

    let promise = ext(self.ft_contract.clone())
      .with_attached_deposit(YOCTO_NEAR)
      .ft_transfer(receiver_id, amount, None);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .with_static_gas(Gas(30*TGAS))
      .external_call_callback()
    )
  }

  #[private] // Public - but only callable by env::current_account_id()
  pub fn external_call_callback(&self, #[callback_result] call_result: Result<(), PromiseError>) {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting external contract");
    }
  }
}
```
_This snippet assumes that the contract is already holding some FTs and that you want to send them to another account._

'''
'''--- docs/2.build/5.primitives/ft/web-app/attach-to-call.md ---

```js
import { Wallet } from './near-wallet';

const TOKEN_CONTRACT_ADDRESS = "token.v2.ref-finance.near";
const wallet = new Wallet({ createAccessKeyFor: TOKEN_CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'ft_transfer_call',
  args: {
    receiver_id: "v2.ref-finance.near",
    amount: "100000000000000000",
    msg: "",
  },
  contractId: TOKEN_CONTRACT_ADDRESS,
  gas: 300000000000000,
  deposit: 1
});
```

<details>
<summary>Example response</summary>
<p>

```json
'100000000000000000'
```

</p>

</details>

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/ft/web-app/check-balance.md ---

:::info
Remember about fungible token precision. You may need this value to show a response of balance requests in an understandable-to-user way in your app. How to get precision value (decimals) you may find [above](#get-token-metadata).
:::

```js
import { Wallet } from './near-wallet';

const TOKEN_CONTRACT_ADDRESS = "token.v2.ref-finance.near";
const wallet = new Wallet({ createAccessKeyFor: TOKEN_CONTRACT_ADDRESS });
 
await wallet.viewMethod({
  method: 'ft_balance_of',
  args: {
    account_id: 'bob.near'
  },
  contractId: TOKEN_CONTRACT_ADDRESS
});
```

<details>
<summary>Example response</summary>
<p>

```json
"3479615037675962643842"
```

</p>

</details>

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/ft/web-app/create.md ---
```js
import { Wallet } from './near-wallet';

const wallet = new Wallet({});

const args = {
  args: {
    owner_id: "bob.near",
    total_supply: "1000000000",
    metadata: {
      spec: "ft-1.0.0",
      name: "Test Token",
      symbol: "test",
      icon: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
      decimals: 18,
    },
  },
  account_id: "bob.near",
};

await wallet.callMethod({
  method: 'create_token',
  args,
  contractId: "tkn.near",
  gas: 300000000000000,
  deposit: "2234830000000000000000000"
});
```
_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/ft/web-app/get-metadata.md ---

```js
import { Wallet } from './near-wallet';

const TOKEN_CONTRACT_ADDRESS = "token.v2.ref-finance.near";
const wallet = new Wallet({ createAccessKeyFor: TOKEN_CONTRACT_ADDRESS });
 
await wallet.viewMethod({
  method: 'ft_metadata',
  args: {},
  contractId: TOKEN_CONTRACT_ADDRESS
});
```

<details>
<summary>Example response</summary>
<p>

```json
{
  "spec": "ft-1.0.0",
  "name": "Ref Finance Token",
  "symbol": "REF",
  "icon": "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='16 24 248 248' style='background: %23000'%3E%3Cpath d='M164,164v52h52Zm-45-45,20.4,20.4,20.6-20.6V81H119Zm0,18.39V216h41V137.19l-20.6,20.6ZM166.5,81H164v33.81l26.16-26.17A40.29,40.29,0,0,0,166.5,81ZM72,153.19V216h43V133.4l-11.6-11.61Zm0-18.38,31.4-31.4L115,115V81H72ZM207,121.5h0a40.29,40.29,0,0,0-7.64-23.66L164,133.19V162h2.5A40.5,40.5,0,0,0,207,121.5Z' fill='%23fff'/%3E%3Cpath d='M189 72l27 27V72h-27z' fill='%2300c08b'/%3E%3C/svg%3E%0A",
  "reference": null,
  "reference_hash": null,
  "decimals": 18
}
```

</p>

</details>

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/ft/web-app/register.md ---
```js
await wallet.callMethod({
  method: 'storage_deposit',
  args: {
    account_id: 'alice.near',
  },
  contractId: TOKEN_CONTRACT_ADDRESS,
  deposit: 1250000000000000000000
});
```
_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/ft/web-app/send.md ---

```js
import { Wallet } from './near-wallet';

const TOKEN_CONTRACT_ADDRESS = "token.v2.ref-finance.near";
const wallet = new Wallet({ createAccessKeyFor: TOKEN_CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'ft_transfer',
  args: {
    receiver_id: 'alice.near',
    amount: '100000000000000000',
  },
  contractId: TOKEN_CONTRACT_ADDRESS,
  deposit: 1
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/linkdrop.md ---
---
id: linkdrop
title: Linkdrops
hide_table_of_contents: false
---

import {FeatureList, Column, Feature} from "@site/src/components/featurelist"

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import BOSGetKeyPairs from "./linkdrop/bos/get-key-pairs.md"
import BOSSimpleDrop from "./linkdrop/bos/simple-drop.md"
import BOSCreateNFTDrop from "./linkdrop/bos/create-nft-drop.md"
import BOSGetDropId from "./linkdrop/bos/get-drop-id.md"
import BOSTransferNFT from "./linkdrop/bos/transfer-nft.md"
import BOSCreateFTDrop from "./linkdrop/bos/create-ft-drop.md"
import BOSTransferFT from "./linkdrop/bos/transfer-ft.md"
import BOSCreateFunctionCallDrop from "./linkdrop/bos/create-function-call-drop.md"

import WebAppGetKeyPairs from "./linkdrop/web-app/get-key-pairs.md"
import WebAppSimpleDrop from "./linkdrop/web-app/simple-drop.md"
import WebAppCreateNFTDrop from "./linkdrop/web-app/create-nft-drop.md"
import WebAppGetDropId from "./linkdrop/web-app/get-drop-id.md"
import WebAppTransferNFT from "./linkdrop/web-app/transfer-nft.md"
import WebAppCreateFTDrop from "./linkdrop/web-app/create-ft-drop.md"
import WebAppTransferFT from "./linkdrop/web-app/transfer-ft.md"
import WebAppCreateFunctionCallDrop from "./linkdrop/web-app/create-function-call-drop.md"

import CLIGetKeyPairs from "./linkdrop/near-cli/get-key-pairs.md"
import CLISimpleDrop from "./linkdrop/near-cli/simple-drop.md"
import CLICreateNFTDrop from "./linkdrop/near-cli/create-nft-drop.md"
import CLIGetDropId from "./linkdrop/near-cli/get-drop-id.md"
import CLITransferNFT from "./linkdrop/near-cli/transfer-nft.md"
import CLICreateFTDrop from "./linkdrop/near-cli/create-ft-drop.md"
import CLITransferFT from "./linkdrop/near-cli/transfer-ft.md"
import CLICreateFunctionCallDrop from "./linkdrop/near-cli/create-function-call-drop.md"

Linkdrops allow users to distribute assets and onboard people to Web3 apps through a simple web link.

![Linkdrop](/docs/primitives/linkdrop.png)

They work by storing assets and linking [AccessKeys](../../1.concepts/protocol/access-keys.md) to them. The `AccessKeys` are then distributed to users in the form of web links. These links take users to a website that automatically uses the keys to call the `claim` method in the `linkdrop` contract.

In order for a contract to be considered a Linkdrop-contract it has to follow the [**NEP-452 standard**](https://github.com/near/NEPs/blob/master/neps/nep-0452.md). The **NEP-452** explains the **minimum interface** required to be implemented, as well as the expected functionality.

---

## [Keypom](https://keypom.xyz/)

The simplest way to create Linkdrops is by using [Keypom](https://keypom.xyz/). Keypom is a community project that allows you to create Linkdrops for NEAR tokens and NFTs in a few clicks.  

![keypom](/docs/primitives/keypom.png)

---

## AccessKeys

In order to create any kind of drop, you need to first generate key pairs. You will need to create **one key per drop**. 

- The `linkdrop` contract will store the **`public`** part of the key.
- You will give the `private` part of the key to the user you want to receive the drop.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSGetKeyPairs />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppGetKeyPairs />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIGetKeyPairs />
  </TabItem>
</Tabs>

---

## $NEAR Drops

To create a $NEAR drop you will ask the contract to create a drop (`create_drop`), passing the public part of the keys you generated, and how much you want to drop on each key use (`deposit_per_use`).

The contract will create a drop and **return the numerical ID** that identifies it.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSSimpleDrop />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppSimpleDrop />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLISimpleDrop />
  </TabItem>
</Tabs>

:::info
To claim the drop, you will need to send the user a [link with the private key](#building-drop-links)
:::

---

## NFT Drops

To drop an existing NFT, you will (1) create a drop, and then (2) **transfer the NFT** to keypom.

#### 1. Creating the Drop
To create an NFT drop, you will call the `create_drop` method, now passing a `nft` argument, which will tell the linkdrop contract to wait for an NFT to be transferred. 

The contract will then create a drop and **return the numerical ID** that identifies it.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSCreateNFTDrop />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppCreateNFTDrop />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLICreateNFTDrop />
  </TabItem>
</Tabs>

#### 2. Transferring the NFT

Having the Drop ID, you now need to transfer the NFT to the linkdrop contract, specifying to which drop you want to add it.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSTransferNFT />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppTransferNFT />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLITransferNFT />
  </TabItem>
</Tabs>

:::tip
The `linkdrop` contract will validate that you are transferring the NFT to a drop that belongs to you 
:::

---

## FT Drops

The process to drop a Fungible Token is very similar to that of creating an [NFT drop](#nft-drop). You will first create the drop, and then fund it with FTs.

#### 1.Creating a drop

To create a FT drop you will call the `create_drop` method, now passing a `ftData` argument, which will tell the linkdrop contract to wait for a certain amount of FT to be transferred. 

The contract will then create a drop and **return the numerical ID** that identifies it.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSCreateFTDrop />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppCreateFTDrop />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLICreateFTDrop />
  </TabItem>
</Tabs>

#### 2. Transferring FT

Having the Drop ID, you now need to transfer the fungible tokens to the linkdrop contract.

:::note
To transfer FTs to an account, you need to first [register](./ft#register-user) the receiver account (e.g. the keypom contract) on the FT contract.
:::

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSTransferFT />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppTransferFT />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLITransferFT />
  </TabItem>
</Tabs>

---

## Function Call Drop
Linkdrop contracts allow to create `function call` drops. These drops will execute one or more methods on a contract when the user claims the drop.

:::tip
Function call drops can be thought as the abstract version of other drops: you can create a drop that will mint an NFT, register a user in a DAO, or pay for a service.
:::

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSCreateFunctionCallDrop />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppCreateFunctionCallDrop />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLICreateFunctionCallDrop />
  </TabItem>
</Tabs>

---

## Building drop links

```js
const getLinks = () => {
  const links = [];

  // It assumes that private keys have been already stored in State by using State.init() and State.update() method
  state.privKeys.map((e, i) => {
    const link =
      "https://app.mynearwallet.com" + "/linkdrop/v2.keypom.near/" + e;
    links.push(link);
  });

  return links;
};
```

<details>
<summary>Example response</summary>
<p>

```js
[
  'https://app.mynearwallet.com/linkdrop/v2.keypom.near/ed25519:2H32THYM8ob336yk81cZUxpidvKi34zLck6a97ypmCY8bbSAuEfrCTu9LWmWGiG9df2C6vkg2FGKGZzY9qE4aEcj',
  'https://app.mynearwallet.com/linkdrop/v2.keypom.near/ed25519:3eoMcqKmmY9Q6qgBy3hZy65HisZ8NXQd9aGGYUGe6RRsmNpGJS5YN64MgZaBVVYJJhbFXhQ2ca3DRRBiKh1rYM48'
]
```

</p>

</details>

:::note
If you didn't save your linkdrop links before closing NEAR App, you can always find them on [Keypom app](https://keypom.xyz/drops).
:::

---

## Additional Resources

1. [Linkdrop plus](https://near.org/near/widget/ComponentDetailsPage?src=cuongdcdev.near/widget/linkdrop_plus) allows to create a Simple Drop. Powered by [Keypom](https://keypom.xyz/)
2. [Keypom Drop Viewer](https://near.org/near/widget/ComponentDetailsPage?src=kiskesis.near/widget/Keypom-Drop-Viewer-fork) shows drops created by current logged in user.
'''
'''--- docs/2.build/5.primitives/linkdrop/bos/create-ft-drop.md ---
```js
const keypomContract = "v2.keypom.near";
const ftContract = "ft.primitives.near";
const dropAmount = "10000000000000000000000";

Near.call([
  {
    contractName: keypomContract,
    methodName: "create_drop",
    args: {
      public_keys: state.publicKeys,
      deposit_per_use: dropAmount,
      ftData: {
	    	contractId: ftContract,
	    	senderId: accountId,
	    	// This balance per use is balance of human readable FTs per use. 
	    	amount: "1"
        // Alternatively, you could use absoluteAmount, which is dependant on the decimals value of the FT
        // ex. if decimals of an ft = 8, then 1 FT token would be absoluteAmount = 100000000
	    },
    },
    deposit: "23000000000000000000000", // state.publicKeys.length * dropAmount + 3000000000000000000000,
    gas: "100000000000000"
  },
]);
```
'''
'''--- docs/2.build/5.primitives/linkdrop/bos/create-function-call-drop.md ---
```js
const accountId = context.accountId ?? props.accountId;
const keypomContract = "v2.keypom.near";
const nftContract = "nft.primitives.near";
const nftTokenId = "1";
const dropAmount = "10000000000000000000000";

Near.call([
  {
    contractName: keypomContract,
    methodName: "create_drop",
    args: {
      public_keys: state.publicKeys,
      deposit_per_use: dropAmount,
      fcData: {
        // 2D array of function calls. In this case, there is 1 function call to make for a key use
        // By default, if only one array of methods is present, this array of function calls will be used for all key uses
        methods: [
          // Array of functions for Key use 1. 
            [{
              receiverId: nftContract,
              methodName: "nft_mint",
              args: JSON.stringify({
              // Change this token_id if it already exists -> check explorer transaction
                  token_id: nftTokenId,
                  metadata: {
                    title: "My NFT drop",
                    description: "",
                    media: "",
                  }
              }),
              accountIdField: "receiver_id",
              // Attached deposit for when the receiver makes this function call
              attachedDeposit: "10000000000000000000000"
            }]
        ]
      }
    },
    deposit: "23000000000000000000000", // state.publicKeys.length * dropAmount + 3000000000000000000000,
    gas: "100000000000000",
  },
]);
```
'''
'''--- docs/2.build/5.primitives/linkdrop/bos/create-nft-drop.md ---
```js
const accountId = context.accountId ?? props.accountId;
const keypomContract = "v2.keypom.near";
const nftContract = "nft.primitives.near";
const dropAmount = "10000000000000000000000";

 Near.call([
  {
    contractName: keypomContract,
    methodName: "create_drop",
    args: {
      public_keys: state.publicKeys,
      deposit_per_use: dropAmount,
      nft: {
        // Who will be sending the NFTs to the Keypom contract
        sender_id: accountId,
        // NFT Contract Id that the tokens will come from
        contract_id: nftContract,
      },
    },
    deposit: "23000000000000000000000" // state.publicKeys.length * dropAmount + 3000000000000000000000,
    gas: "100000000000000",
  },
]);
```
'''
'''--- docs/2.build/5.primitives/linkdrop/bos/get-drop-id.md ---
```js
const accountId = context.accountId ?? props.accountId;
const keypomContract = "v2.keypom.near";

const dropSupplyForOwner = Near.view(
  keypomContract,
  "get_drop_supply_for_owner",
  { account_id: accountId }
);

const dropsForOwner = Near.view(keypomContract, "get_drops_for_owner", {
  account_id: accountId,
  from_index: (dropSupplyForOwner - 1).toString(),
});

const dropId = dropsForOwner[dropsForOwner.length - 1].drop_id;
```
'''
'''--- docs/2.build/5.primitives/linkdrop/bos/get-key-pairs.md ---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs className="file-tabs">

<TabItem value="Keypom API" label="Keypom API">

```js
const dropsNumber = "2";
const keysGeneratorUrl = "https://keypom.sctuts.com/keypair/";
const rootEntrophy = "my-password"; //If not provided, the keypair will be completely random. see: https://docs.keypom.xyz/docs/next/keypom-sdk/Core/modules 
asyncFetch(keysGeneratorUrl + dropsNumber + "/" + rootEntrophy).then((res) => {
  const keyPairs = JSON.parse(res.body);
  const pubKeys = [];
  const privKeys = [];

  keyPairs.forEach((e) => {
    pubKeys.push(e.pub);
    privKeys.push(e.priv);
  });

  const obj = {
    publicKeys: pubKeys,
    privKeys: privKeys,
  };

  State.update(obj);
});
```

</TabItem>

</Tabs>

'''
'''--- docs/2.build/5.primitives/linkdrop/bos/simple-drop.md ---
```js
const keypomContract = "v2.keypom.near";
const dropAmount = "10000000000000000000000";

Near.call([
  {
    contractName: keypomContract,
    methodName: "create_drop",
    args: {
      public_keys: state.publicKeys,
      deposit_per_use: dropAmount,
    },
    deposit: "23000000000000000000000", // state.publicKeys.length * dropAmount + 3000000000000000000000,
    gas: "100000000000000",
  },
]);
```

'''
'''--- docs/2.build/5.primitives/linkdrop/bos/transfer-ft.md ---
```js
Near.call([
  {
    contractName: ftContract,
    methodName: "ft_transfer",
    args: {
      receiver_id: keypomContract,
      amount: "1",
    },
    deposit: "1",
    gas: "300000000000000",
  },
]);
```
'''
'''--- docs/2.build/5.primitives/linkdrop/bos/transfer-nft.md ---
```js
const nftTokenId = "1";

Near.call([{
  contractName: nftContract, 
  methodName: 'nft_transfer_call', 
  args: {
    receiver_id: keypomContract,
    token_id: nftTokenId,
    msg: dropId.toString()
  },
  deposit: "1",
  gas: "300000000000000"
}]);
```
'''
'''--- docs/2.build/5.primitives/linkdrop/near-cli/create-ft-drop.md ---
```bash
near call v2.keypom.near create_drop '{"public_keys": <PUBLIC_KEYS>, "deposit_per_use": "10000000000000000000000", "ftData": {"contractId": "ft.primitives.near","senderId": "bob.near", "amount": "1"}}}' --depositYocto 23000000000000000000000 --gas 100000000000000 --accountId bob.near
```
'''
'''--- docs/2.build/5.primitives/linkdrop/near-cli/create-function-call-drop.md ---
```bash
near call v2.keypom.near create_drop '{"public_keys": <PUBLIC_KEYS>, "deposit_per_use": "10000000000000000000000", "fcData": {"methods": [[{"receiverId": "nft.primitives.near","methodName": "nft_mint","args": {"token_id": "1", "metadata": {"title": "My NFT drop","description": "","media": ""}, "accountIdField": "receiver_id", "attachedDeposit": "10000000000000000000000"}]]}}' --depositYocto 23000000000000000000000 --gas 100000000000000 --accountId bob.near
```
'''
'''--- docs/2.build/5.primitives/linkdrop/near-cli/create-nft-drop.md ---
```bash
near call v2.keypom.near create_drop '{"public_keys": <PUBLIC_KEYS>, "deposit_per_use": "10000000000000000000000", "nft": {"sender_id": "bob.near", "contract_id": "nft.primitives.near"}}' --depositYocto 23000000000000000000000 --gas 100000000000000 --accountId bob.near
```
'''
'''--- docs/2.build/5.primitives/linkdrop/near-cli/get-drop-id.md ---
```bash
near view v2.keypom.near get_drop_supply_for_owner '{"account_id": "bob.near"}'
```
'''
'''--- docs/2.build/5.primitives/linkdrop/near-cli/get-key-pairs.md ---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs className="file-tabs">

<TabItem value="Near CLI" label="Near CLI">

```bash
# This command creates a key pair locally in .near-credentials with an implicit account as the accountId (hash representation of the public key)

near generate-key
```

**Example response:**

```bash
Key pair with ed25519:33Vn9VtNEtWQPPd1f4jf5HzJ5weLcvGHU8oz7o5UnPqy public key for an account "1e5b1346bdb4fc5ccd465f6757a9082a84bcacfd396e7d80b0c726252fe8b3e8"
```

</TabItem>

<TabItem value="Keypom API" label="Keypom API">

```bash
export NUMBER_OF_DROPS=2

curl https://keypom.sctuts.com/keypair/$NUMBER_OF_DROPS/rootEntrophy
```

</TabItem>

</Tabs>
'''
'''--- docs/2.build/5.primitives/linkdrop/near-cli/simple-drop.md ---
```bash
near call v2.keypom.near create_drop '{"public_keys": <PUBLIC_KEYS>, "deposit_per_use": "10000000000000000000000"}' --depositYocto 23000000000000000000000 --gas 100000000000000 --accountId bob.near
```
'''
'''--- docs/2.build/5.primitives/linkdrop/near-cli/transfer-ft.md ---
```bash
near call ft.primitives.near ft_transfer '{"receiver_id": "v2.keypom.near", "amount": "1"}' --depositYocto 1 --gas 100000000000000 --accountId bob.near
```
'''
'''--- docs/2.build/5.primitives/linkdrop/near-cli/transfer-nft.md ---
```bash
near call nft.primitives.near nft_transfer_call '{"receiver_id": "v2.keypom.near", "token_id": <YOUR TOKEN ID>, "msg": <YOUR DROP ID>}' --depositYocto 1 --gas 100000000000000 --accountId bob.near
```
'''
'''--- docs/2.build/5.primitives/linkdrop/web-app/create-ft-drop.md ---

```js
import { Wallet } from './near-wallet';

const KEYPOM_CONTRACT_ADDRESS = "v2.keypom.near";
const FT_CONTRACT_ADDRESS = "ft.primitives.near";
const DROP_AMOUNT = "10000000000000000000000";

const wallet = new Wallet({ createAccessKeyFor: KEYPOM_CONTRACT_ADDRESS }); 

await wallet.callMethod({
  method: "create_drop",
  contractId: KEYPOM_CONTRACT_ADDRESS,
  args: {
    public_keys: state.publicKeys,
    deposit_per_use: DROP_AMOUNT,
    ftData: {
      contractId: FT_CONTRACT_ADDRESS,
      senderId: accountId, // TODO How to get account id
      // This balance per use is balance of human readable FTs per use. 
      amount: "1"
      // Alternatively, you could use absoluteAmount, which is dependant on the decimals value of the FT
      // ex. if decimals of an ft = 8, then 1 FT token would be absoluteAmount = 100000000
    },
  },
  deposit: "23000000000000000000000" // state.publicKeys.length * dropAmount + 3000000000000000000000,
  gas: "100000000000000",
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/linkdrop/web-app/create-function-call-drop.md ---

```js
import { Wallet } from './near-wallet';

const KEYPOM_CONTRACT_ADDRESS = "v2.keypom.near";
const NFT_CONTRACT_ADDRESS = "nft.primitives.near";
const NFT_TOKEN_ID = "1";
const DROP_AMOUNT = "10000000000000000000000";

const wallet = new Wallet({ createAccessKeyFor: DAO_CONTRACT_ADDRESS });

await wallet.callMethod({
  method: "create_drop",
  contractId: KEYPOM_CONTRACT_ADDRESS,
  args: {
    public_keys: state.publicKeys,
    deposit_per_use: DROP_AMOUNT,
    fcData: {
      // 2D array of function calls. In this case, there is 1 function call to make for a key use
      // By default, if only one array of methods is present, this array of function calls will be used for all key uses
      methods: [
        // Array of functions for Key use 1. 
          [{
            receiverId: NFT_CONTRACT_ADDRESS,
            methodName: "nft_mint",
            args: JSON.stringify({
            // Change this token_id if it already exists -> check explorer transaction
                token_id: NFT_TOKEN_ID,
                metadata: {
                  title: "My NFT drop",
                  description: "",
                  media: "",
                }
            }),
            accountIdField: "receiver_id",
            // Attached deposit for when the receiver makes this function call
            attachedDeposit: "10000000000000000000000"
          }]
      ]
    }
  },
  deposit: "23000000000000000000000" // state.publicKeys.length * dropAmount + 3000000000000000000000,
  gas: "100000000000000",
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/linkdrop/web-app/create-nft-drop.md ---

```js
import { Wallet } from './near-wallet';

const KEYPOM_CONTRACT_ADDRESS = "v2.keypom.near";
const NFT_CONTRACT_ADDRESS = "nft.primitives.near";
const DROP_AMOUNT = "10000000000000000000000";

const keypomConnectedWallet = new Wallet({ createAccessKeyFor: KEYPOM_CONTRACT_ADDRESS }); 
const nftConnectedWallet = new Wallet({ createAccessKeyFor: NFT_CONTRACT_ADDRESS });

await wallet.callMethod({
  method: "create_drop",
  contractId: KEYPOM_CONTRACT_ADDRESS,
  args: {
    public_keys: state.publicKeys,
    deposit_per_use: DROP_AMOUNT,
    nft: {
      // Who will be sending the NFTs to the Keypom contract
      sender_id: accountId, // TODO How to get it
      // NFT Contract Id that the tokens will come from
      contract_id: NFT_CONTRACT_ADDRESS,
    },
  },
  deposit: "23000000000000000000000" // state.publicKeys.length * dropAmount + 3000000000000000000000,
  gas: "100000000000000",
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/linkdrop/web-app/get-drop-id.md ---

```js
const dropSupplyForOwner = await wallet.viewMethod({
  contractId: KEYPOM_CONTRACT_ADDRESS
  method: 'get_drop_supply_for_owner',
  args: { account_id: accountId },
});

const dropsForOwner = await wallet.viewMethod({
  contractId: KEYPOM_CONTRACT_ADDRESS
  method: 'get_drops_for_owner',
  args: { account_id: accountId, from_index: (dropSupplyForOwner - 1).toString() }
});

const dropId = dropsForOwner[dropsForOwner.length - 1].drop_id;
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/linkdrop/web-app/get-key-pairs.md ---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs className="file-tabs">

<TabItem value="near-api-js" label="near-api-js">

```js
import { KeyPair } from 'near-api-js';

const newKeyPair = KeyPair.fromRandom('ed25519');
newKeyPair.public_key = newKeyPair.publicKey.toString();
```

</TabItem>

<TabItem value="Keypom API" label="Keypom API">

```js
const state = {};

const dropsNumber = "2";
const keysGeneratorUrl = "https://keypom.sctuts.com/keypair/";

fetch(keysGeneratorUrl + dropsNumber + "/rootEntrophy").then((res) => {
  const keyPairs = JSON.parse(res.body);
  const pubKeys = [];
  const privKeys = [];

  keyPairs.forEach((e) => {
    pubKeys.push(e.pub);
    privKeys.push(e.priv);
  });

  state.publicKeys = pubKeys;
  state.privKeys = privKeys;
});
```

</TabItem>

</Tabs>
'''
'''--- docs/2.build/5.primitives/linkdrop/web-app/simple-drop.md ---

```js
import { Wallet } from './near-wallet';

const KEYPOM_CONTRACT_ADDRESS = "v2.keypom.near";
const DROP_AMOUNT = "10000000000000000000000"; // 0.1 NEAR

const wallet = new Wallet({ createAccessKeyFor: KEYPOM_CONTRACT_ADDRESS }); 

await wallet.callMethod({
  method: "create_drop",
  contractId: KEYPOM_CONTRACT_ADDRESS,
  args: {
    public_keys: state.publicKeys,
    deposit_per_use: DROP_AMOUNT,
  },
  deposit: "23000000000000000000000" // state.publicKeys.length * dropAmount + 3000000000000000000000,
  gas: "100000000000000",
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/linkdrop/web-app/transfer-ft.md ---

```js
import { Wallet } from './near-wallet';

const KEYPOM_CONTRACT_ADDRESS = "v2.keypom.near";
const FT_CONTRACT_ADDRESS = "ft.primitives.near";

const wallet = new Wallet({ createAccessKeyFor: FT_CONTRACT_ADDRESS }); 

await wallet.callMethod({
  method: "ft_transfer",
  contractId: FT_CONTRACT_ADDRESS,
  args: {
    receiver_id: KEYPOM_CONTRACT_ADDRESS,
    amount: "1"
  },
  deposit: "1",
  gas: "100000000000000"
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/linkdrop/web-app/transfer-nft.md ---

```js
import { Wallet } from './near-wallet';

const KEYPOM_CONTRACT_ADDRESS = "v2.keypom.near";
const NFT_CONTRACT_ADDRESS = "nft.primitives.near";
const NFT_TOKEN_ID = "1";
const DROP_AMOUNT = "10000000000000000000000";

const nftConnectedWallet = new Wallet({ createAccessKeyFor: NFT_CONTRACT_ADDRESS }); 

await wallet.callMethod({
  method: "nft_transfer_call",
  contractId: NFT_CONTRACT_ADDRESS,
  args: {
    receiver_id: keypomContract,
    token_id: nftTokenId,
    msg: dropId.toString()
  },
  deposit: 1,
  gas: "100000000000000",
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/nft.md ---
---
id: nft
title: Non-Fungible Tokens (NFT)
hide_table_of_contents: false
---

import {FeatureList, Column, Feature} from "@site/src/components/featurelist"

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import BOSMintNFT from "./nft/bos/mint.md"
import BOSBuyNFT from "./nft/bos/buy.md"
import BOSQueryNFT from "./nft/bos/query.md"
import BOSTransferNFT from "./nft/bos/transfer.md"
import BOSListNFTForSale from "./nft/bos/list-for-sale.md"

import WebAppMintNFT from "./nft/web-app/mint.md"
import WebAppBuyNFT from "./nft/web-app/buy.md"
import WebAppQueryNFT from "./nft/web-app/query.md"
import WebAppTransferNFT from "./nft/web-app/transfer.md"
import WebAppListNFTForSale from "./nft/web-app/list-for-sale.md"

import CLIMintNFT from "./nft/near-cli/mint.md"
import CLIBuyNFT from "./nft/near-cli/buy.md"
import CLIQueryNFT from "./nft/near-cli/query.md"
import CLITransferNFT from "./nft/near-cli/transfer.md"
import CLIListNFTForSale from "./nft/near-cli/list-for-sale.md"

import SmartContractMintNFT from "./nft/smart-contract/mint.md"
import SmartContractBuyNFT from "./nft/smart-contract/buy.md"
import SmartContractQueryNFT from "./nft/smart-contract/query.md"
import SmartContractTransferNFT from "./nft/smart-contract/transfer.md"

In contrast with fungible tokens, non-fungible tokens (NFT) are unitary and therefore unique. This makes NFTs ideal to represent ownership of assets such as a piece of digital content, or a ticket for an event.

As with fungible tokens, NFTs are **not stored** in the user's wallet, instead, each NFT lives in a **NFT contract**. The NFT contract works as a bookkeeper, this is: it is in charge of handling the creation, storage and transfers of NFTs.

In order for a contract to be considered a NFT-contract it has to follow the [**NEP-171 and NEP-177 standards**](https://nomicon.io/Standards/Tokens/NonFungibleToken). The **NEP-171** & **NEP-177** standards explain the **minimum interface** required to be implemented, as well as the expected functionality.

:::info NFT & Marketplaces

Be mindful of not confusing an NFT with an NFT-marketplace. NFT simply store information (metadata), while NFT-marketplaces are contracts where NFT can be listed and exchanged for a price.

:::

---

## Community Projects
The easiest way to create and handle NFTs is by using one of the existing community projects.

1. [Paras](https://paras.id/) - a classic NFT marketplace. Just login with your NEAR account, create a collection and share the link with your community.
2. [Mintbase](https://www.mintbase.xyz/) - a marketplace that allows to create NFT collections, and buy NFTs using credit cards or stablecoins.
3. [Enleap](https://enleap.app/) - a no-code launchpad for NFTs. Provides NFT minting, staking, whitelist managing, tracking functionality.

---

## Deploying a NFT Contract
If you want to deploy your own NFT contract, you can create one using our [reference implementation](https://github.com/near-examples/NFT) 

Simply personalize it and deploy it to your account.

```bash
near deploy <account-id> --wasmFile contract.wasm --initFunction new
```

:::tip

Check the [Contract Wizard](https://near.org/contractwizard.near/widget/ContractWizardUI) to create a personalized NFT contract!.

:::

---

## Minting a NFT
To create a new NFT (a.k.a. minting it) you will call the `nft_mint` method passing as arguments the metadata that defines the NFT.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSMintNFT />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppMintNFT />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIMintNFT />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract" default>
    <SmartContractMintNFT />
  </TabItem>
</Tabs>

:::info

See the [metadata standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata) for the full list of `TokenMetadata` parameters.

:::

:::warning

Values of gas and deposit might vary depending on which NFT contract you are calling.

:::

<hr className="subsection" />

### Minting Collections

Many times people want to create multiple 100 copies of an NFT (this is called a collection). In such cases, what you actually need to do is to mint 100 different NFTs with the same metadata (but different `token-id`).

:::tip

Notice that [minting in Mintbase](#minting-a-nft) allows you to pass a `num_to_mint` parameter.

:::

<hr className="subsection" />

### Royalties
You might have noticed that one of the parameters is a structure called royalties. Royalties enable you to create a list of users that should get paid when the token is sell in a marketplace. For example, if `anna` has `5%` of royalties, each time the NFT is sell, `anna` should get a 5% of the selling price.

---

## Querying NFT data
You can query the NFT's information and metadata by calling the `nft_token`.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSQueryNFT />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppQueryNFT />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIQueryNFT />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract">
    <SmartContractQueryNFT />
  </TabItem>
</Tabs>

---

## Transferring a NFT
Transferring an NFT can happen in two scenarios: (1) you ask to transfer an NFT, and (2) an [authorized account](#approving-users) asks to transfer the NFT.

In both cases, it is necessary to invoke the `nft_transfer` method, indicating the token id, the receiver, and an (optionally) an [approval_id](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement).

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSTransferNFT />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppTransferNFT />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLITransferNFT />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract">
    <SmartContractTransferNFT />  
  </TabItem>
</Tabs>

---

## Attaching NFTs to a Call
Natively, only NEAR tokens (‚ìÉ) can be attached to a function calls. However, the NFT standard enables to attach a non-fungible tokens in a call by using the NFT-contract as intermediary. This means that, instead of you attaching tokens directly to the call, you ask the NFT-contract to do both a transfer and a function call in your name.

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">

```bash
near call <nft-contract> nft_transfer_call '{"receiver_id": "<receiver-contract>", "token_id": "<token_id>", "msg": "<a-string-message>"}' --accountId <your-account> --depositYocto 1
```

</TabItem>

</Tabs>

:::info

Optionally, a [`memo` parameter](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core#nft-interface) can be passed to provide more information to your contract.

:::

<hr className="subsection" />

### How Does it Work?
Assume you want to attach an NFT (üé´) to a call on the receiver contract. The workflow is as follows:
1. You call `nft_transfer_call` in the NFT-contract passing: the receiver, a message, and the token-id of üé´.
2. The NFT contract transfers the NFT üé´ to the receiver.
3. The NFT contract calls **`receiver.nft_on_transfer(sender, token-owner, token-id, msg)`**.
4. The NFT contract handles errors in the `nft_resolve_transfer` callback.
5. The NFT contract returns `true` if it succeeded.

#### The nft_on_transfer method
From the workflow above it follows that the receiver we want to call needs to implement the `nft_on_transfer` method. When executed, such method will know:
- Who is sending the NFT, since it is a parameter
- Who is the current owner, since it is a parameter
- Which NFT was transferred, since it is a parameter.
- If there are any parameters encoded as a message

The `nft_on_transfer` **must return true** if the NFT has to be **returned to the sender**.

---

## Approving Users

You can authorize other users to transfer an NFT you own. This is useful, for example, to enable listing your NFT in a marketplace. In such scenario, you **trust** that the marketplace will only transfer the NFT upon receiving a certain amount of money in exchange.

<Tabs groupId="code-tabs">
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">

```bash
near call <nft-contract> nft_approve '{
"token_id": "<token-unique-id>",
"account_id": "<authorized-account>",
"msg": "<json-structure>"
}' --accountId <your-account> --depositYocto 1
```

</TabItem>

</Tabs>

:::info

If the `msg` parameter is included, then a cross-contract call will be made to `<authorized_account>.nft_on_approve(msg)`. Which in turn will make a callback to `nft_resolve_transfer` in your NFT contract.

:::

---

## List a NFT for sale

Basic NFT contracts following [the NEP-171 and NEP-177 standards](https://nomicon.io/Standards/Tokens/NonFungibleToken) do not implement marketplace functionality.

For this purpose, there are ecosystem apps such as [Paras](https://paras.id/) or [Mintbase](https://www.mintbase.xyz/), that use dedicated marketplace contracts.

In order to put a NFT for a sale on a marketplace you need to do two actions: 

1. Cover data storage costs in the marketplace contract. 
2. Approve the marketplace to sell the NFT in your NFT contract.

<br />

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSListNFTForSale />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppListNFTForSale />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIListNFTForSale />
  </TabItem>
</Tabs>

---

## Buy a NFT

Basic NFT contracts following [the NEP-171 and NEP-177 standards](https://nomicon.io/Standards/Tokens/NonFungibleToken) do not implement marketplace functionality.

For this purpose, there are ecosystem apps such as [Paras](https://paras.id/) or [Mintbase](https://www.mintbase.xyz/), that use dedicated marketplace contracts.

<Tabs groupId="code-tabs">
  <TabItem value="‚öõÔ∏è Component" label="‚öõÔ∏è Component" default>
    <BOSBuyNFT />
  </TabItem>
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppBuyNFT />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIBuyNFT />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract" default>
    <SmartContractBuyNFT />
  </TabItem>
</Tabs>

---

## Additional Resources

1. [NFT Tutorial](/tutorials/nfts/js/introduction) (NEAR examples, JavaScript SDK) - a set of tutorials that cover how to create a NFT contract using JavaScript.
2. [NFT Tutorial](/tutorials/nfts/introduction) (NEAR examples, Rust SDK) - a set of tutorials that cover how to create a NFT contract using Rust.
3. [NFT Tutorial by Keypom](https://github.com/keypom/nft-tutorial-series) (a fork of the NEAR example tutorial).
4. [Paras API documentation](https://parashq.github.io/).
5. [Mintbase API documentation](https://docs.mintbase.xyz/dev/mintbase-graph).
6. [Mintbase JS SDK](https://docs.mintbase.xyz/dev/mintbase-sdk-ref) - a set of methods to get data from blockchain, interact with Mintbase contracts, etc.
'''
'''--- docs/2.build/5.primitives/nft/bos/buy.md ---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="Paras" label="Paras" default>

```js
const tokenData = Near.call(
  "x.paras.near",
  "nft_buy",
  {
    token_series_id: "299102",
    receiver_id: "bob.near",
  },
  undefined,
  205740000000000000000000 // NFT price + storage cost
);
```

**Example response:**

```json
"299102:1"
```

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
const tokenData = Near.call(
  "simple.market.mintbase1.near",
  "buy",
  {
    nft_contract_id: "rubennnnnnnn.mintbase1.near",
    token_id: "38",
    referrer_id: null,
  },
  undefined,
  1000000000000000000000 // NFT price + storage cost (optional, depends on a contract)
);
```

**Example response:**

```json
{
  "payout": {
    "rub3n.near": "889200000000000000000",
    "rubenm4rcus.near": "85800000000000000000"
  }
}
```

</TabItem>

</Tabs>
'''
'''--- docs/2.build/5.primitives/nft/bos/list-for-sale.md ---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="Paras" label="Paras">

```js
Near.call(
  "marketplace.paras.near",
  "storage_deposit",
  {
    receiver_id: "bob.near"
  },
  undefined,
  9390000000000000000
);

Near.call(
  "nft.primitives.near",
  "nft_approve",
  {
    token_id: "1e95238d266e5497d735eb30",
    account_id: "marketplace.paras.near",
    msg: {
      price: "200000000000000000000000",
      market_type: "sale",
      ft_token_id: "near"
    }
  }
);
```

The method `nft_approve` will call `nft_on_approve` in `marketplace.paras.near`.

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
Near.call(
  "simple.market.mintbase1.near",
  "deposit_storage",
  {
    autotransfer: true
  },
  undefined,
  9390000000000000000
);

Near.call(
  "nft.primitives.near",
  "nft_approve",
  {
    token_id: "3c46b76cbd48e65f2fc88473",
    account_id: "simple.market.mintbase1.near",
    msg: {
      price: "200000000000000000000000"
    }
  }
);
```

The method `nft_approve` will call `nft_on_approve` in `simple.market.mintbase1.near`.

</TabItem>

</Tabs>

'''
'''--- docs/2.build/5.primitives/nft/bos/mint.md ---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="NFT Primitive" label="Reference" default>

```js
const tokenData = Near.call(
  "nft.primitives.near",
  "nft_mint",
  {
    token_id: "1",
    receiver_id: "bob.near", 
    token_metadata: {
      title: "NFT Primitive Token",
      description: "Awesome NFT Primitive Token",
      media: "string", // URL to associated media, preferably to decentralized, content-addressed storage
    }
  },
  undefined,
  10000000000000000000000, // Depends on your NFT metadata
);
```

</TabItem>

<TabItem value="Paras" label="Paras">

```js
const tokenData = Near.call(
  "x.paras.near",
  "nft_mint",
  {
    token_series_id: "490641",
    receiver_id: "bob.near",
  },
  undefined,
  10000000000000000000000 // Depends on your NFT metadata
);
```

:::note
In order to use `nft_mint` method of the `x.paras.near` contract you have to be a creator of a particular token series.
:::

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
const tokenData = Near.call(
  "thomasettorreiv.mintbase1.near",
  "nft_batch_mint",
  {
    num_to_mint: 1,
    owner_id: "bob.near",
    metadata: {},
  },
  undefined,
  10000000000000000000000
);
```

:::note
In order to use `nft_batch_mint` method of Mintbase store contract your account have to be a in the contract minters list.
:::

</TabItem>

</Tabs>
'''
'''--- docs/2.build/5.primitives/nft/bos/query.md ---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="NFT Primitive" label="Reference" default>

```js
const tokenData = Near.view("nft.primitives.near", "nft_token", {
  token_id: "1",
});
```

<details>

<summary> Example response </summary>

```json
{
  "token_id": "1",
  "owner_id": "bob.near",
  "metadata": {
    "title": "string", // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    "description": "string", // free-form description
    "media": "string", // URL to associated media, preferably to decentralized, content-addressed storage
    "media_hash": "string", // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    "copies": 1, // number of copies of this set of metadata in existence when token was minted.
    "issued_at": 1642053411068358156, // When token was issued or minted, Unix epoch in milliseconds
    "expires_at": 1642053411168358156, // When token expires, Unix epoch in milliseconds
    "starts_at": 1642053411068358156, // When token starts being valid, Unix epoch in milliseconds
    "updated_at": 1642053411068358156, // When token was last updated, Unix epoch in milliseconds
    "extra": "string", // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    "reference": "string", // URL to an off-chain JSON file with more info.
    "reference_hash": "string" // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
  }
}
```

</details>

</TabItem>

<TabItem value="Paras" label="Paras">

```js
const tokenData = fetch("https://api-v2-mainnet.paras.id/token?token_id=84686:1154");
```

<details>

<summary> Example response </summary>

```json
{
  "status": 1,
  "data": {
    "results": [
      {
        "_id": "61dfbf27284abc1cc0b87c9d",
        "contract_id": "x.paras.near",
        "token_id": "84686:1154",
        "owner_id": "bob.near",
        "token_series_id": "84686",
        "edition_id": "1154",
        "metadata": {
          "title": "Tokenfox Silver Coin #1154",
          "description": "Holding this silver coin in your wallet will bring you health and happiness \uD83D\uDE0A",
          "media": "bafkreihpapfu7rzsmejjgl2twllge6pbrfmqaahj2wkz6nq55c6trhhtrq",
          "media_hash": null,
          "copies": 4063,
          "issued_at": null,
          "expires_at": null,
          "starts_at": null,
          "updated_at": null,
          "extra": null,
          "reference": "bafkreib6uj5kxbadfvf6qes5flema7jx6u5dj5zyqcneaoyqqzlm6kpu5a",
          "reference_hash": null,
          "collection": "Tokenfox Collection Cards",
          "collection_id": "tokenfox-collection-cards-by-tokenfoxnear",
          "creator_id": "tokenfox.near",
          "blurhash": "U7F~gc00_3D%00~q4n%M_39F-;RjM{xuWBRj",
          "score": 0,
          "mime_type": "image/png"
        },
        "royalty": {
          "tokenfox.near": 1000
        },
        "price": null,
        "approval_id": null,
        "ft_token_id": null,
        "has_price": null,
        "is_creator": true,
        "total_likes": 8,
        "likes": null,
        "categories": [],
        "view": 4
      }
    ],
    "count": 1,
    "skip": 0,
    "limit": 10
  }
}
```

</details>

:::info

See the [Paras API documentation](https://parashq.github.io/) for the full list of methods.

:::

:::note

Paras API methods returns data from all NFT contracts in NEAR. You might want to pass more parameters like `contract_id` or `owner_id` to make the response more accurate.

:::

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
const tokenData = fetch("https://graph.mintbase.xyz", {
  method: "POST",
  headers: {
    "mb-api-key": "anon",
    "Content-Type": "application/json",
    "x-hasura-role": "anonymous",
  },
  body: JSON.stringify({
    query: `
      query getToken{
        tokens: nft_tokens(
          where: {
            token_id: { _eq: "84686:1154" }
          }
        ) {
          tokenId: token_id
          ownerId: owner
          contractId: nft_contract_id
          reference
          issuedAt: issued_at
          copies
          metadataId: metadata_id
        }
      }
    `,
  }),
});
```

<details>

<summary> Example response </summary>

```json
{
  "ok": true,
  "status": 200,
  "contentType": "application/json",
  "body": {
    "data": {
      "tokens": [
        {
          "tokenId": "84686:1154",
          "ownerId": "bob.near",
          "contractId": "x.paras.near",
          "reference": "bafkreib6uj5kxbadfvf6qes5flema7jx6u5dj5zyqcneaoyqqzlm6kpu5a",
          "issuedAt": "2022-01-13T05:56:51.068358",
          "copies": 4063,
          "metadataId": "x.paras.near:5210047642790498956c9669d6a37b98"
        }
      ]
    }
  }
}
```

</details>

:::note

In the future, users may be required to register using an api key. For now, simply passing the value `anon` for `mb-api-key` will work.

:::

</TabItem>

</Tabs>

'''
'''--- docs/2.build/5.primitives/nft/bos/transfer.md ---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="NFT Primitive" label="Reference" default>

```js
const tokenData = Near.call(
  "nft.primitives.near",
  "nft_transfer",
  {
    token_id: "1",
    receiver_id: "bob.near"
  },
  undefined,
  1,
);
```

</TabItem>

<TabItem value="Paras" label="Paras">

```js
const tokenData = Near.call(
  "x.paras.near",
  "nft_transfer",
  {
    token_id: "490641",
    receiver_id: "bob.near"
  },
  undefined,
  1
);
```

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
const tokenData = Near.call(
  "thomasettorreiv.mintbase1.near",
  "nft_transfer",
  {
    token_id: "490641",
    receiver_id: "bob.near"
  },
  undefined,
  1
);
```

</TabItem>

</Tabs>

'''
'''--- docs/2.build/5.primitives/nft/near-cli/buy.md ---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="Paras" label="Paras" default>

```bash
near call x.paras.near buy '{"token_series_id": "299102", "receiver_id": "bob.near"}' --accountId bob.near --deposit 0.20574
```

**Example response:**

```json
"299102:1"
```

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```bash
near call simple.market.mintbase1.near buy '{"nft_contract_id": "rubennnnnnnn.mintbase1.near", "token_id": "38"}' --accountId bob.near --deposit 0.001
```

**Example response:**

```json
{
  "payout": {
    "rub3n.near": "889200000000000000000",
    "rubenm4rcus.near": "85800000000000000000"
  }
}
```

</TabItem>

</Tabs>

'''
'''--- docs/2.build/5.primitives/nft/near-cli/list-for-sale.md ---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="Paras" label="Paras">

```bash
near call marketplace.paras.near storage_deposit '{"receiver_id": "bob.near"}' --accountId bob.near --deposit 0.00939

near call nft.primitives.near nft_approve '{"token_id": "1e95238d266e5497d735eb30", "account_id": "marketplace.paras.near", "msg": {"price": "200000000000000000000000", "market_type": "sale", "ft_token_id": "near"}}' --accountId bob.near
```

Method `nft_approve` of a NFT contract also calls the `nft_on_approve` method in `marketplace.paras.near` as a callback.

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```bash
near call simple.market.mintbase1.near deposit_storage '{"autotransfer": "true"}' --accountId bob.near --deposit 0.00939

near call nft.primitives.near nft_approve '{"token_id": "3c46b76cbd48e65f2fc88473", "account_id": "simple.market.mintbase1.near", "msg": {"price": "200000000000000000000000"}}' --accountId bob.near
```

Method `nft_approve` of a NFT contract also calls the `nft_on_approve` method in `simple.market.mintbase1.near` as a callback.

</TabItem>

</Tabs>

'''
'''--- docs/2.build/5.primitives/nft/near-cli/mint.md ---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="NFT Primitive" label="Reference" default>

```bash
near call nft.primitives.near nft_mint '{"token_id": "1", "receiver_id": "bob.near", "token_metadata": {"title": "NFT Primitive Token", "description": "Awesome NFT Primitive Token", "media": "string"}}' --depositYocto 10000000000000000000000, --accountId bob.near
```

</TabItem>

<TabItem value="Paras" label="Paras">

```bash
near call x.paras.near nft_mint '{"token_series_id": "490641", "receiver_id": "bob.near"}' --depositYocto 10000000000000000000000 --accountId bob.near
```

:::note
In order to use `nft_mint` method of the `x.paras.near` contract you have to be a creator of a particular token series.
:::

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```bash
near call thomasettorreiv.mintbase1.near nft_batch_mint '{"num_to_mint": 1, "owner_id": "bob.near", "metadata": {}}' --accountId bob.near --depositYocto 10000000000000000000000
```

:::note
In order to use `nft_batch_mint` method of Mintbase store contract your account have to be a in the contract minters list.
:::

</TabItem>

</Tabs>

'''
'''--- docs/2.build/5.primitives/nft/near-cli/query.md ---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="NFT Primitive" label="Reference" default>

```bash
near view nft.primitives.near nft_token '{"token_id": "1"}'
```

<details>

<summary> Example response </summary>

```json
{
  "token_id": "1",
  "owner_id": "bob.near",
  "metadata": {
    "title": "string", // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    "description": "string", // free-form description
    "media": "string", // URL to associated media, preferably to decentralized, content-addressed storage
    "media_hash": "string", // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    "copies": 1, // number of copies of this set of metadata in existence when token was minted.
    "issued_at": 1642053411068358156, // When token was issued or minted, Unix epoch in milliseconds
    "expires_at": 1642053411168358156, // When token expires, Unix epoch in milliseconds
    "starts_at": 1642053411068358156, // When token starts being valid, Unix epoch in milliseconds
    "updated_at": 1642053411068358156, // When token was last updated, Unix epoch in milliseconds
    "extra": "string", // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    "reference": "string", // URL to an off-chain JSON file with more info.
    "reference_hash": "string" // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
  }
}
```
</details>

</TabItem>

<TabItem value="Paras" label="Paras">

```bash
near view x.paras.near nft_token '{"token_id": "84686:1154"}'
```

<details>

<summary> Example response </summary>

```json
{
  "token_id": "84686:1154",
  "owner_id": "bob.near",
  "metadata": {
    "title": "Tokenfox Silver Coin #1154",
    "description": null,
    "media": "bafkreihpapfu7rzsmejjgl2twllge6pbrfmqaahj2wkz6nq55c6trhhtrq",
    "media_hash": null,
    "copies": 4063,
    "issued_at": "1642053411068358156",
    "expires_at": null,
    "starts_at": null,
    "updated_at": null,
    "extra": null,
    "reference": "bafkreib6uj5kxbadfvf6qes5flema7jx6u5dj5zyqcneaoyqqzlm6kpu5a",
    "reference_hash": null
  },
  "approved_account_ids": {}
}
```

</details>

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```bash
near view anthropocene.mintbase1.near nft_token '{"token_id": "17960"}'
```

<details>

<summary> Example response </summary>

```json
{
  "token_id": "17960",
  "owner_id": "876f40299dd919f39252863e2136c4e1922cd5f78759215474cbc8f1fc361e14",
  "approved_account_ids": {},
  "metadata": {
    "title": null,
    "description": null,
    "media": null,
    "media_hash": null,
    "copies": 1,
    "issued_at": null,
    "expires_at": null,
    "starts_at": null,
    "updated_at": null,
    "extra": null,
    "reference": "F-30s_uQ3ZdAHZClY4DYatDPapaIRNLju41RxfMXC24",
    "reference_hash": null
  },
  "royalty": {
    "split_between": {
      "seventhage.near": {
        "numerator": 10000
      }
    },
    "percentage": {
      "numerator": 100
    }
  },
  "split_owners": null,
  "minter": "anthropocene.seventhage.near",
  "loan": null,
  "composeable_stats": { "local_depth": 0, "cross_contract_children": 0 },
  "origin_key": null
}
```

</details>

:::note
When someone creates a NFT on Mintbase they need to deploy their own NFT contract using Mintbase factory. Those smart contract are subaccounts of mintbase1.near, e.g. `anthropocene.mintbase1.near`.
:::

</TabItem>

</Tabs>

'''
'''--- docs/2.build/5.primitives/nft/near-cli/transfer.md ---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="NFT Primitive" label="Reference" default>

```bash
near call nft.primitives.near nft_transfer '{"token_id": "1", "receiver_id": "bob.near"}' --accountId bob.near --deposit 0.000000000000000000000001
```

</TabItem>

<TabItem value="Paras" label="Paras">

```bash
near call x.paras.near nft_transfer '{"token_id": "490641", "receiver_id": "bob.near"}' --accountId bob.near --deposit 0.000000000000000000000001
```

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```bash
near call thomasettorreiv.mintbase1.near nft_transfer '{"token_id": "490641" "receiver_id": "bob.near"}' --accountId bob.near --deposit 0.000000000000000000000001
```

</TabItem>

</Tabs>

'''
'''--- docs/2.build/5.primitives/nft/smart-contract/buy.md ---
This is an example on how you can make your smart contract buy a NFT on some marketplace (Paras this case).

:::info
Please note that in this example the contract will be the owner of the NFT, however, some marketplaces allow you to buy NFT for somebody else.
:::

```rust
const NFT_MARKETPLACE_CONTRACT: &str = "paras-marketplace-v2.testnet";

// Define the contract structure
#[near(contract_state)]
pub struct Contract {
  nft_marketplace_contract: AccountId
}

impl Default for Contract {
    // The default trait with which to initialize the contract
    fn default() -> Self {
        Self {
          nft_marketplace_contract: NFT_MARKETPLACE_CONTRACT.parse().unwrap()
        }
    }
}

// Validator interface, for cross-contract calls
#[ext_contract(ext_nft_contract)]
trait ExternalNftContract {
  fn buy(&self, nft_contract_id: AccountId, token_id: TokenId, ft_token_id: Option<AccountId>, price: Option<U128>) -> Promise;
}

// Implement the contract structure
#[near]
impl Contract {
  #[payable]
  pub fn buy(&mut self, nft_contract_id: AccountId, token_id: TokenId, ft_token_id: Option<AccountId>, price: Option<U128>) -> Promise {
    let promise = ext_nft_contract::ext(self.nft_marketplace_contract.clone())
      .with_static_gas(Gas(30*TGAS))
      .with_attached_deposit(env::attached_deposit())
      .buy(nft_contract_id, token_id, ft_token_id, price);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .with_static_gas(Gas(30*TGAS))
      .buy_callback()
    )
  }

  #[private] // Public - but only callable by env::current_account_id()
  pub fn buy_callback(&self, #[callback_result] call_result: Result<(), PromiseError>) {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting NFT contract");
    }
  }
}
```

'''
'''--- docs/2.build/5.primitives/nft/smart-contract/mint.md ---
```rust
// Validator interface, for cross-contract calls
#[ext_contract(ext_nft_contract)]
trait ExternalNftContract {
  fn nft_mint(&self, token_series_id: String, receiver_id: AccountId) -> Promise;
}

// Implement the contract structure
#[near]
impl Contract {
  #[payable]
  pub fn nft_mint(&mut self, token_series_id: String, receiver_id: AccountId) -> Promise {
    let promise = ext_nft_contract::ext(self.nft_contract.clone())
      .with_static_gas(Gas(30*TGAS))
      .with_attached_deposit(env::attached_deposit())
      .nft_mint(token_series_id, receiver_id);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .with_static_gas(Gas(30*TGAS))
      .nft_mint_callback()
    )
  }

  #[private] // Public - but only callable by env::current_account_id()
  pub fn nft_mint_callback(&self, #[callback_result] call_result: Result<TokenId, PromiseError>) -> Option<TokenId> {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting NFT contract");
      return None;
    }

    // Return the token data
    let token_id: TokenId = call_result.unwrap();
    return Some(token_id);
  }
}

'''
'''--- docs/2.build/5.primitives/nft/smart-contract/query.md ---
```rust
// Validator interface, for cross-contract calls
#[ext_contract(ext_nft_contract)]
trait ExternalNftContract {
  fn nft_token(&self, token_id: TokenId) -> Promise;
}

// Implement the contract structure
#[near]
impl Contract {
  pub fn nft_token(&self, token_id: TokenId) -> Promise {
    let promise = ext_nft_contract::ext(self.nft_contract.clone())
      .nft_token(token_id);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .nft_token_callback()
    )
  }

  #[private] // Public - but only callable by env::current_account_id()
  pub fn nft_token_callback(&self, #[callback_result] call_result: Result<Token, PromiseError>) -> Option<Token> {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting NFT contract");
      return None;
    }

    // Return the token data
    let token_data: Token = call_result.unwrap();
    return Some(token_data);
  }
}
```

'''
'''--- docs/2.build/5.primitives/nft/smart-contract/transfer.md ---
:::info
Please notice that a contract can only transfer an NFT that they own, or an NFT that they were approved to transfer.
:::

```rust
const YOCTO_NEAR: u128 = 1;

#[ext_contract(ext_nft_contract)]
trait ExternalNftContract {
  fn nft_transfer(&self, receiver_id: AccountId, token_id: TokenId) -> Promise;
}

impl Contract {
  #[payable]
  pub fn nft_transfer(&mut self, receiver_id: AccountId, token_id: TokenId) -> Promise {
    let promise = ext_nft_contract::ext(self.nft_contract.clone())
      .with_attached_deposit(YOCTO_NEAR)
      .nft_transfer(receiver_id, token_id);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .nft_transfer_callback()
    )
  }

  #[private] // Public - but only callable by env::current_account_id()
  pub fn nft_transfer_callback(&self, #[callback_result] call_result: Result<(), PromiseError>) {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting NFT contract");
    }
  }
}
```
'''
'''--- docs/2.build/5.primitives/nft/web-app/buy.md ---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="Paras" label="Paras" default>

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "x.paras.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'nft_buy',
  args: {
    token_series_id: "299102",
    receiver_id: "bob.near",
  },
  contractId: CONTRACT_ADDRESS,
  deposit: 205740000000000000000000 // attached deposit in yoctoNEAR, covers NFT price + storage cost
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_

<details>

<summary>Example response</summary>

```json
"299102:1"
```

</details>

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "simple.market.mintbase1.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'buy',
  args: {
    nft_contract_id: "rubennnnnnnn.mintbase1.near",
    token_id: "38"
  },
  contractId: CONTRACT_ADDRESS,
  deposit: 1000000000000000000000 // attached deposit in yoctoNEAR, covers NFT price + storage cost (optional)
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_

<details>

<summary>Example response</summary>

```json
{
  "payout": {
    "rub3n.near": "889200000000000000000",
    "rubenm4rcus.near": "85800000000000000000"
  }
}
```

</details>

:::tip

Check how to do this using the [`Mintbase JS`](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/sdk/buy)

:::

</TabItem>

</Tabs>

'''
'''--- docs/2.build/5.primitives/nft/web-app/list-for-sale.md ---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="Paras" label="Paras">

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "marketplace.paras.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'storage_deposit',
  args: {
    receiver_id: "bob.near"
  },
  contractId: CONTRACT_ADDRESS,
  gas: 300000000000000, // attached GAS (optional)
  deposit: 9390000000000000000 // attached deposit in yoctoNEAR (optional)
});

await wallet.callMethod({
  method: 'nft_approve',
  args: {
    token_id: "1e95238d266e5497d735eb30",
    account_id: "marketplace.paras.near",
    msg: {
      price: "200000000000000000000000",
      market_type: "sale",
      ft_token_id: "near"
    }
  },
  contractId: "nft.primitives.near"
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

Method `nft_approve` of a NFT contract also calls the `nft_on_approve` method in `marketplace.paras.near` as a callback.

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "simple.market.mintbase1.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'deposit_storage',
  args: {
      autotransfer: true
    },
  contractId: CONTRACT_ADDRESS,
  gas: 300000000000000, // attached GAS (optional)
  deposit: 9390000000000000000 // attached deposit in yoctoNEAR (optional)
});

await wallet.callMethod({
  method: 'nft_approve',
  args: {
    args: {
      token_id: "3c46b76cbd48e65f2fc88473",
      account_id: "simple.market.mintbase1.near",
      msg: {
        price: "200000000000000000000000"
      }
    },
  },
  contractId: "nft.primitives.near"
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

Method `nft_approve` of a NFT contract also calls the `nft_on_approve` method in `simple.market.mintbase1.near` as a callback.

:::tip

Check how to also do this using the [`Mintbase JS`](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/sdk/list)

:::

</TabItem>

</Tabs>

'''
'''--- docs/2.build/5.primitives/nft/web-app/mint.md ---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="NFT Primitive" label="Reference" default>

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "nft.primitives.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'nft_mint',
  args: {
    token_id: "1",
    receiver_id: "bob.near", 
    token_metadata: {
      title: "NFT Primitive Token",
      description: "Awesome NFT Primitive Token",
      media: "string", // URL to associated media, preferably to decentralized, content-addressed storage
    }
  },
  contractId: CONTRACT_ADDRESS,
  deposit: 10000000000000000000000
});
```

</TabItem>

<TabItem value="Paras" label="Paras">

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "x.paras.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'nft_mint',
  args: {
    token_series_id: "490641",
    receiver_id: "bob.near",
  },
  contractId: CONTRACT_ADDRESS,
  deposit: 10000000000000000000000 // Depends on your NFT metadata
});
```

:::note
In order to use `nft_mint` method of the `x.paras.near` contract you have to be a creator of a particular token series.
:::

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "thomasettorreiv.mintbase1.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'nft_batch_mint',
  args: {
    num_to_mint: 1,
    owner_id: "bob.near",
    metadata: {},
  },
  contractId: CONTRACT_ADDRESS,
  deposit: 10000000000000000000000 // Depends on your NFT metadata
});
```

:::note
In order to use `nft_batch_mint` method of Mintbase store contract your account have to be a in the contract minters list.
:::

:::tip
Check how to do this using [`Mintbase JS`](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/sdk/mint)
:::

</TabItem>

</Tabs>

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 
'''
'''--- docs/2.build/5.primitives/nft/web-app/query.md ---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="NFT Primitive" label="Reference" default>

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "nft.primitives.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
const response = await wallet.viewMethod({
  method: 'nft_token',
  args: {
    token_id: "1"
  }
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

<details>

<summary> Example response </summary>

```json
{
  "token_id": "1",
  "owner_id": "bob.near",
  "metadata": {
    "title": "string", // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    "description": "string", // free-form description
    "media": "string", // URL to associated media, preferably to decentralized, content-addressed storage
    "media_hash": "string", // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    "copies": 1, // number of copies of this set of metadata in existence when token was minted.
    "issued_at": 1642053411068358156, // When token was issued or minted, Unix epoch in milliseconds
    "expires_at": 1642053411168358156, // When token expires, Unix epoch in milliseconds
    "starts_at": 1642053411068358156, // When token starts being valid, Unix epoch in milliseconds
    "updated_at": 1642053411068358156, // When token was last updated, Unix epoch in milliseconds
    "extra": "string", // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    "reference": "string", // URL to an off-chain JSON file with more info.
    "reference_hash": "string" // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
  }
}
```
</details>

</TabItem>

<TabItem value="Paras" label="Paras">

```js
const tokenData = fetch("https://api-v2-mainnet.paras.id/token?token_id=84686:1154");
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

<details>

<summary> Example response </summary>

```json
{
  "status": 1,
  "data": {
    "results": [
      {
        "_id": "61dfbf27284abc1cc0b87c9d",
        "contract_id": "x.paras.near",
        "token_id": "84686:1154",
        "owner_id": "bob.near",
        "token_series_id": "84686",
        "edition_id": "1154",
        "metadata": {
          "title": "Tokenfox Silver Coin #1154",
          "description": "Holding this silver coin in your wallet will bring you health and happiness \uD83D\uDE0A",
          "media": "bafkreihpapfu7rzsmejjgl2twllge6pbrfmqaahj2wkz6nq55c6trhhtrq",
          "media_hash": null,
          "copies": 4063,
          "issued_at": null,
          "expires_at": null,
          "starts_at": null,
          "updated_at": null,
          "extra": null,
          "reference": "bafkreib6uj5kxbadfvf6qes5flema7jx6u5dj5zyqcneaoyqqzlm6kpu5a",
          "reference_hash": null,
          "collection": "Tokenfox Collection Cards",
          "collection_id": "tokenfox-collection-cards-by-tokenfoxnear",
          "creator_id": "tokenfox.near",
          "blurhash": "U7F~gc00_3D%00~q4n%M_39F-;RjM{xuWBRj",
          "score": 0,
          "mime_type": "image/png"
        },
        "royalty": {
          "tokenfox.near": 1000
        },
        "price": null,
        "approval_id": null,
        "ft_token_id": null,
        "has_price": null,
        "is_creator": true,
        "total_likes": 8,
        "likes": null,
        "categories": [],
        "view": 4
      }
    ],
    "count": 1,
    "skip": 0,
    "limit": 10
  }
}
```

</details>

:::info

See the [Paras API documentation](https://parashq.github.io/) for the full list of methods.

:::

:::note

Paras API methods returns data from all NFT contracts in NEAR. You might want to pass more parameters like `contract_id` or `owner_id` to make the response more accurate.

:::

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
const tokenData = fetch("https://graph.mintbase.xyz", {
  method: "POST",
  headers: {
    "mb-api-key": "anon",
    "Content-Type": "application/json",
    "x-hasura-role": "anonymous",
  },
  body: JSON.stringify({
    query: `
      query getToken{
        tokens: nft_tokens(
          where: {
            token_id: { _eq: "84686:1154" }
          }
        ) {
          tokenId: token_id
          ownerId: owner
          contractId: nft_contract_id
          reference
          issuedAt: issued_at
          copies
          metadataId: metadata_id
        }
      }
    `,
  }),
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_

<details>

<summary> Example response </summary>

```json
{
  "ok": true,
  "status": 200,
  "contentType": "application/json",
  "body": {
    "data": {
      "tokens": [
        {
          "tokenId": "84686:1154",
          "ownerId": "bob.near",
          "contractId": "x.paras.near",
          "reference": "bafkreib6uj5kxbadfvf6qes5flema7jx6u5dj5zyqcneaoyqqzlm6kpu5a",
          "issuedAt": "2022-01-13T05:56:51.068358",
          "copies": 4063,
          "metadataId": "x.paras.near:5210047642790498956c9669d6a37b98"
        }
      ]
    }
  }
}
```

</details>

:::note

In the future, users may be required to register using an api key. For now, simply passing the valueanon for `mb-api-key` will work.

:::

:::tip

Check how to do this also using the [`Mintbase JS`](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/data/api/tokenbyid)

:::

</TabItem>

</Tabs>

'''
'''--- docs/2.build/5.primitives/nft/web-app/transfer.md ---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="NFT Primitive" label="Reference" default>

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "nft.primitives.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'nft_transfer',
  args: {
    token_id: "1",
    receiver_id: "bob.near"
  },
  contractId: CONTRACT_ADDRESS,
  deposit: 1
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

</TabItem>

<TabItem value="Paras" label="Paras">

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "x.paras.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'nft_transfer',
  args: {
    token_id: "490641",
    receiver_id: "bob.near"
  },
  contractId: CONTRACT_ADDRESS,
  deposit: 1
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "thomasettorreiv.mintbase1.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'nft_transfer',
  args: {
    token_id: "490641",
    receiver_id: "bob.near"
  },
  contractId: CONTRACT_ADDRESS,
  deposit: 1
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_

:::tip

Check how to also do this using [`Mintbase JS`](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/sdk/transfer)

:::

</TabItem>

</Tabs>

'''
'''--- docs/2.build/5.primitives/oracles.md ---
---
id: oracles
title: Price Oracles
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Oracles are smart contracts that enable you to query the current price of an asset.

Since smart contracts cannot connect to
internet and pull information, Oracles rely on having someone constantly updating their prices. Because of that, be mindful
when using an oracle that there might be a delay between the market's latest information and the Oracles data.

Oracle contract's are not standardized. We will here list different providers and how to use their Oracle as they are built.

---

## Price Oracles

- Account: **priceoracle.near** | **priceoracle.testnet**
- Creator: [NearDefi](https://github.com/NearDeFi)
- Smart contract: https://github.com/NearDeFi/price-oracle
- Bot to fill contract: https://github.com/NearDeFi/near-price-oracle-bot

---

## Query Assets

<Tabs>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">

```bash
near view priceoracle.near get_assets
``` 

</TabItem>

</Tabs>

<details>

<summary>Example response</summary>

```json
[
  [
    'wrap.near',
    {
      reports: [
        {
          oracle_id: 'thorinoracle.near',
          timestamp: '1669795900809627816',
          price: { multiplier: '17030', decimals: 28 }
        },
        {
          oracle_id: 'npo-aurora.near',
          timestamp: '1706631791706032710',
          price: { multiplier: '30641', decimals: 28 }
        },
        {
          oracle_id: 'gloriafoster.near',
          timestamp: '1706631808550973590',
          price: { multiplier: '30666', decimals: 28 }
        },
        ...
```

</details>

---

## Get Assets Price

<Tabs>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">

```bash
near view priceoracle.near get_price_data
```

</TabItem>

</Tabs>

<details>

<summary>Example response</summary>

```json
{
  timestamp: '1706631861981947371',
  recency_duration_sec: 90,
  prices: [
    {
      asset_id: 'wrap.near',
      price: { multiplier: '30702', decimals: 28 }
    },
    {
      asset_id: 'aurora',
      price: { multiplier: '235662', decimals: 20 }
    },
    {
      asset_id: 'meta-pool.near',
      price: { multiplier: '38770', decimals: 28 }
    },
    {
      asset_id: 'linear-protocol.near',
      price: { multiplier: '36432', decimals: 28 }
    },
```

</details>

:::tip

Divide the returned `multiplier` by `10000` to obtain the price in USD.

:::

'''
'''--- docs/2.build/5.primitives/what-is.md ---
---
id: what-is
title: What are Primitives? 
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Primitives are fundamental building blocks that can be combined to create a fully functional application. Blockchain primitives include [Fungible Tokens (FT)](#fungible-tokens-ft), [Non Fungible Tokens (NFT)](#non-fungible-tokens-nft), [Decentralized Autonomous organizations (DAO)](#decentralized-autonomous-organizations-dao), [Link Drops](#linkdrops) and more.

![img](/docs/assets/welcome-pages/primitives-landing.png)

---

#### Fungible Tokens (FT)
[Fungible tokens](./ft.md) represent an **asset** on a blockchain that is **interchangeable**. Besides the native NEAR token, users can issue their own fungible tokens or use those that are already present in the ecosystem.

:::tip
Fungible Tokens are ideal to create **reward systems**, **fair tickets** and any other type of **token**.
:::

<hr class="subsection" />

#### Non Fungible Tokens (NFT)
In contrast with fungible tokens, each [non-fungible token (NFT)](./nft.md) is **unitary** and therefore **unique**. Users can create their own non-fungible token, transfer to other users, or exchange them in marketplaces.

:::tip
NFTs are ideal to represent **ownership of assets** such as **collectibles**, **event tickets** and other unique assets.
:::

<hr class="subsection" />

#### Decentralized Autonomous organizations (DAO)
[Decentralized Autonomous Organizations (DAOs)](./dao.md) are **self-organized groups** that form around common purposes. Membership, decision making, and funding are **coordinated** by **publicly voting** on proposals through a smart contract.

:::tip
DAOs are ideal to create **decentralized governance**, **funding**, and **decision-making** tools.
:::

<hr class="subsection" />

### LinkDrops
[LinkDrops](./linkdrop.md) are an easy way to **distribute digital assets** (NFTs, FTs) via links. You simply **provide a link** for users and they can **claim** your drop.

:::tip
LinkDrops are ideal to do **drops**, and **onboard new users** into Web3 apps.
:::
'''
'''--- docs/2.build/6.data-infrastructure/big-query.md ---
---
id: big-query
title: BigQuery Public Dataset
sidebar_label: BigQuery
---

Blockchain data indexing in NEAR Public Lakehouse is for anyone wanting to understand blockchain data. This includes:

- **Users**: create queries to track NEAR assets, monitor transactions, or analyze on-chain events at a massive scale.
- **Researchers**: use indexed data for data science tasks, including on-chain activities, identifying trends, or feeding AI/ML pipelines for predictive analysis.
- **Startups**: can use NEAR's indexed data for deep insights on user engagement, smart contract utilization, or insights across tokens and NFT adoption.

Benefits:

- **NEAR instant insights**: Historical on-chain data queried at scale.
- **Cost-effective**: eliminate the need to store and process bulk NEAR protocol data; query as little or as much data as preferred.
- **Easy to use**: no prior experience with blockchain technology is required; bring a general knowledge of SQL to unlock insights.

## Getting started

1. Login into your [Google Cloud Account](https://console.cloud.google.com/).
2. Open the [NEAR Protocol BigQuery Public Dataset](https://console.cloud.google.com/marketplace/product/bigquery-public-data/crypto-near-mainnet).
3. Click in the <kbd>[VIEW DATASET](https://console.cloud.google.com/bigquery?p=bigquery-public-data&d=crypto_near_mainnet_us&page=dataset)</kbd> button.
4. Click in the <kbd>+</kbd> to create a new tab and write your query, click in the <kbd>RUN</kbd> button, and check the `Query results` below the query.
5. Done :)

:::info

The [NEAR Public Lakehouse repository](https://github.com/near/near-public-lakehouse) contains the source code for ingesting NEAR Protocol data stored as JSON files in AWS S3 by [NEAR Lake Indexer](https://github.com/near/near-lake-indexer).

:::

### Example Queries

- _How many unique signers and accounts have interacted with my smart contract per day?_

```sql
SELECT
  ra.block_date collected_for_day,
  COUNT(DISTINCT t.signer_account_id) as total_signers,
  COUNT(DISTINCT ra.receipt_predecessor_account_id) as total_accounts
FROM `bigquery-public-data.crypto_near_mainnet_us.receipt_actions` ra
  JOIN `bigquery-public-data.crypto_near_mainnet_us.receipt_origin_transaction` ro ON ro.receipt_id = ra.receipt_id
  JOIN `bigquery-public-data.crypto_near_mainnet_us.transactions` t ON ro.originated_from_transaction_hash = t.transaction_hash
WHERE ra.action_kind = 'FUNCTION_CALL'
  AND ra.receipt_receiver_account_id = 'social.near' -- change to your contract
GROUP BY 1
ORDER BY 1 DESC;
```

## How much it costs?

- NEAR pays for the storage and doesn't charge you to use the public dataset.
  > To learn more about BigQuery public datasets [check this page](https://cloud.google.com/bigquery/public-data).
- Google GCP charges for the queries that you perform on the data. For example, in today's price "Sep 1st, 2023" the On-demand (per TB) query pricing is $6.25 per TB where the first 1 TB per month is free.
  > Check [Google's pricing page](https://cloud.google.com/bigquery/pricing#analysis_pricing_models) for detailed pricing info, options, and best practices.

:::tip
You can check how much data it will query before running it in the BigQuery console UI. Again, since BigQuery uses a columnar data structure and partitions, it's recommended to select only the columns and partitions (`block_date`) needed to avoid unnecessary query costs.
:::

![Query Costs](/docs/BQ_Query_Cost.png "BQ Query Costs")

## Architecture

The data is loaded in a streaming fashion using [Databricks Autoloader](https://docs.gcp.databricks.com/ingestion/auto-loader/index.html) into raw/bronze tables, and transformed with [Databricks Delta Live Tables](https://www.databricks.com/product/delta-live-tables) streaming jobs into cleaned/enriched/silver tables.

The silver tables are also copied into the [GCP BigQuery Public Dataset](https://cloud.google.com/bigquery/public-data).

![Architecture](/docs/Architecture.png "Architecture")

:::info

[Databricks Medallion Architecture](https://www.databricks.com/glossary/medallion-architecture).

:::

## Available Data

The current data that NEAR is providing was inspired by [NEAR Indexer for Explorer](https://github.com/near/near-indexer-for-explorer/).

:::info
NEAR plans to improve the data available in the NEAR Public Lakehouse making it easier to consume by denormalizing some tables.
:::

The tables available in the NEAR Public Lakehouse are:

- **blocks**: A structure that represents an entire block in the NEAR blockchain. `Block` is the main entity in NEAR Protocol blockchain. Blocks are produced in NEAR Protocol every second.
- **chunks**: A structure that represents a chunk in the NEAR blockchain. `Chunk` of a `Block` is a part of a `Block` from a `Shard`. The collection of `Chunks` of the `Block` forms the NEAR Protocol Block. `Chunk` contains all the structures that make the `Block`: `Transactions`, [`Receipts`](https://nomicon.io/RuntimeSpec/Receipts), and `Chunk Header`.
- **transactions**: [`Transaction`](../../2.build/6.data-infrastructure/lake-data-structures/transaction.mdx#definition) is the main way of interaction between a user and a blockchain. Transaction contains: Signer account ID, Receiver account ID, and Actions.
- **execution_outcomes**: Execution outcome is the result of execution of `Transaction` or `Receipt`. In the result of the Transaction execution will always be a Receipt.
- **receipt_details**: All cross-contract (we assume that each account lives in its own shard) communication in Near happens through Receipts. Receipts are stateful in a sense that they serve not only as messages between accounts but also can be stored in the account storage to await `DataReceipts`. Each receipt has a `predecessor_id` (who sent it) and `receiver_id` the current account.
- **receipt_origin**: Tracks the transaction that originated the receipt.
- **receipt_actions**: Action Receipt represents a request to apply actions on the `receiver_id` side. It could be derived as a result of a `Transaction` execution or another `ACTION` Receipt processing. Action kind can be: `ADD_KEY`, `CREATE_ACCOUNT`, `DELEGATE_ACTION`, `DELETE_ACCOUNT`, `DELETE_KEY`, `DEPLOY_CONTRACT`, `FUNCTION_CALL`, `STAKE`, `TRANSFER`.
- **receipts (view)**: It's recommended to select only the columns and partitions (`block_date`) needed to avoid unnecessary query costs. This view join the receipt details, the transaction that originated the receipt and the receipt execution outcome.
- **account_changes**: Each account has an associated state where it stores its metadata and all the contract-related data (contract's code + storage).

:::note References

- [Protocol documentation](../../1.concepts/welcome.md)
- [Near Data flow](../../1.concepts/data-flow/near-data-flow.md)
- [Lake Data structures](./lake-data-structures/toc.mdx)
- [Protocol specification](https://nomicon.io/)

:::note Additional information about the data

- Skipped Blocks: NEAR Blockchain can contain skipped blocks, e.g. block `57730443`. For these cases we can find the block for the chunk data using the `prev_block_hash` column, e.g. `SELECT * FROM chunks c JOIN blocks b ON c.chunk.header.prev_block_hash = b.header.prev_hash`.

:::

'''
'''--- docs/2.build/6.data-infrastructure/lake-framework/building-indexers/js-lake-indexer.md ---
---
id: js-lake-indexer
title: JS basic tutorial
sidebar_label: JS basic tutorial
---

# NEAR Lake indexer basic tutorial

:::info Source code for the tutorial

[`near-examples/near-lake-raw-printer-js`](https://github.com/near-examples/near-lake-raw-printer-js): source code for the tutorial on how to create an indexer that prints block height and number of shards

:::

Recently we have [published a JavaScript version of the NEAR Lake Framework](https://www.npmjs.com/package/near-lake-framework) on npmjs.org

We want to empower you with a basic tutorial on how to use the JavaScript Library. Let's get started!

## Requirements

Before we get started, please, ensure you have:

- [nodejs](https://nodejs.org/en/download/) installed

## Create a project

Create an indexer project:

```bash
mkdir near-lake-raw-printer-js && cd near-lake-raw-printer-js
```

Now we're going to call `npm init`, we can continue with the default values pressing Enter on every question in the interactive mode:
```bash
npm init
```

```
version: (1.0.0)
description:
entry point: (index.js)
test command:
git repository:
keywords:
author:
license: (ISC)
About to write to /Users/near/projects/near-lake-raw-printer-js/package.json:

{
  "name": "near-lake-raw-printer-js",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}

Is this OK? (yes)
```

`package.json` is ready. Let's install `near-lake-framework`

## Install dependencies

Install `near-lake-framework`

```bash
npm install near-lake-framework --save
```

Install `typescript` as dev dependency

```bash
npm install typescript --save-dev
```

## Setup TypeScript

Now we can create `tsconfig.json` for TypeScript settings:

```bash
touch tsconfig.json
```

Paste the content to the file:

```json title=tsconfig.json
{
  "compilerOptions": {
    "lib": [
      "ES2018",
      "dom"
    ]
  }
}
```

Now let's add the `scripts` section to the `package.json`

```json
"scripts": {
  "start": "tsc && node index.js"
}
```

After that your `package.json` should look similar to:

```json title=package.json
{
  "name": "near-lake-raw-printer",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "tsc && node index.js"
  },
  "dependencies": {
    "near-lake-framework": "^1.0.1"
  },
  "devDependencies": {
    "typescript": "^4.6.4"
  }
}
```

Now let's create `index.ts`

```bash
touch index.ts
```

Open `index.ts` in your favorite editor to start coding.

## Import `near-lake-framework`

In the `index.ts` file let's import the necessary dependencies:

```ts
import { startStream, types } from 'near-lake-framework';
```

We've imported the main function `startStream` which will be called to actually run the indexer, and `types` that hold the `LakeConfig` type we need to contruct.

## Create a config

To get indexer running we need to start it with a config. We need to create an instance of `LakeConfig`

```ts
const lakeConfig: types.LakeConfig = {
    s3BucketName: "near-lake-data-mainnet",
    s3RegionName: "eu-central-1",
    startBlockHeight: 63804051,
};
```

## Create indexer handler

Indexer will be streaming the [`StreamerMessage`](/build/data-infrastructure/lake-data-structures/toc) instances we need to handle according to our needs.

In `near-lake-framework` JS library the handler have to be presented as a callback function. This function have to:
- be asynchronous
- accept an argument of type [`StreamerMessage`](/build/data-infrastructure/lake-data-structures/toc)
- return nothing (`void`)

Creating the callback:

```ts
async function handleStreamerMessage(streamerMessage: types.StreamerMessage): Promise<void> {
    //
}
```

For this tutorial our requirement is to log the block height and the numer of shards. That's simple:

```ts
async function handleStreamerMessage(streamerMessage: types.StreamerMessage): Promise<void> {
    console.log(`
        Block #${streamerMessage.block.header.height}
        Shards: ${streamerMessage.shards.length}
    `);
}
```

## Starting the stream

And the last thing to write is the call to `startStream` with the config and pass the callback function.

```ts
(async () => {
    await startStream(lakeConfig, handleStreamerMessage);
})();
```

That's it. Now we can compile the code and run it

## Compile and run

:::danger Credentials

To be able to access the data from [NEAR Lake](/tools/realtime#near-lake-indexer) you need to provide credentials. Please, see the [Credentials](../running-near-lake/credentials.md) article

:::

We've added the `start` command to the `scripts`, so the compilation and run should as easy as

```bash
npm run start
```

You should see something like the following:

```bash
Block #63804051 Shards: 4
Block #63804052 Shards: 4
Block #63804053 Shards: 4
Block #63804054 Shards: 4
Block #63804055 Shards: 4
Block #63804056 Shards: 4
Block #63804057 Shards: 4
Block #63804058 Shards: 4
Block #63804059 Shards: 4
Block #63804060 Shards: 4
```

You can stop the indexer by pressing CTRL+C

## What's next?

You can play around and change the content of the callback function [`handleStreamerMessage`](#create-indexer-handler) to handle the data differently.

You can find the [source code for this tutorial on the GitHub](https://github.com/near-examples/near-lake-raw-printer-js).

'''
'''--- docs/2.build/6.data-infrastructure/lake-framework/building-indexers/nft-indexer.md ---
---
sidebar_label: NFT Indexer
---

# Building an NFT indexer

:::note Source code for the tutorial

[`near-examples/near-lake-nft-indexer`](https://github.com/near-examples/near-lake-nft-indexer): source code for this tutorial

:::

## The End

This tutorial ends with a working NFT indexer built on top [NEAR Lake Framework JS](/concepts/advanced/near-lake-framework). The indexer is watching for `nft_mint` [Events](https://nomicon.io/Standards/EventsFormat) and prints some relevant data:
- `receiptId` of the [Receipt](/build/data-infrastructure/lake-data-structures/receipt) where the mint has happened
- Marketplace
- NFT owner account name
- Links to the NFTs on the marketplaces

The final source code is available on the GitHub [`near-examples/near-lake-nft-indexer`](https://github.com/near-examples/near-lake-nft-indexer)

## Motivation

NEAR Protocol had introduced a nice feature [Events](https://nomicon.io/Standards/EventsFormat). The Events allow a contract developer to add standardized logs to the [`ExecutionOutcomes`](/build/data-infrastructure/lake-data-structures/execution-outcome) thus allowing themselves or other developers to read those logs in more convenient manner via API or indexers.

The Events have a field `standard` which aligns with NEPs. In this tutorial we'll be talking about [NEP-171 Non-Fungible Token standard](https://github.com/near/NEPs/discussions/171).

In this tutorial our goal is to show you how you can "listen" to the Events contracts emit and how you can benefit from them.

As the example we will be building an indexer that watches all the NFTs minted following the [NEP-171 Events](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event) standard, assuming we're collectors who don't want to miss a thing. Our indexer should notice every single NFT minted and give us a basic set of data like: in what Receipt it was minted, and show us the link to a marketplace (we'll cover [Paras](https://paras.id) and [Mintbase](https://mintbase.io) in our example).

We will use JS version of [NEAR Lake Framework](/concepts/advanced/near-lake-framework) in this tutorial. Though the concept is the same for Rust, but we want to show more people that it's not that complex to build your own indexer.

## Preparation

:::danger Credentials

Please, ensure you've the credentials set up as described on the [Credentials](../running-near-lake/credentials.md) page. Otherwise you won't be able to get the code working.

:::

You will need:

- `node` [installed and configured](https://nodejs.org/en/download/)

Let's create our project folder

```bash
mkdir lake-nft-indexer && cd lake-nft-indexer
```

Let's add the `package.json`

```json title=package.json
{
  "name": "lake-nft-indexer",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "tsc && node index.js"
  },
  "dependencies": {
    "near-lake-framework": "^1.0.2"
  },
  "devDependencies": {
    "typescript": "^4.6.4"
  }
}
```

You may have noticed we've added `typescript` as a dev dependency. Let's configure the TypeScript. We'll need to create `tsconfig.json` file for that

```json title=tsconfig.json
{
  "compilerOptions": {
    "lib": [
      "ES2019",
      "dom"
    ]
  }
}
```

:::warning ES2019 edition

Please, note the `ES2019` edition used. We require it because we are going to use `.flatMap()` and `.flat()` in our code. These methods were introduces in `ES2019`. Though you can use even more recent

:::

Let's create empty `index.ts` in the project root and thus finish the preparations.

```bash
npm install
```

Now we can start a real work.

## Set up NEAR Lake Framework

In the `index.ts` let's import `startStream` function and `types` from `near-lake-framework`:

```ts title=index.ts
import { startStream, types } from 'near-lake-framework';
```

Add the instantiation of `LakeConfig` below:

```ts title=index.js
const lakeConfig: types.LakeConfig = {
  s3BucketName: "near-lake-data-mainnet",
  s3RegionName: "eu-central-1",
  startBlockHeight: 66264389,
};
```

Just a few words on the config, we have set `s3BucketName` for mainnet, default `s3RegionName` and a fresh-ish block height for `startBlockHeight`. You can go to [NEAR Explorer](https://nearblocks.io) and get **the freshest** block height for your setup. Though you can use the same as we do.

Now we need to create a callback function that we'll be called to handle [`StreamerMessage`](/build/data-infrastructure/lake-data-structures/toc) our indexer receives.

```ts title=index.ts
async function handleStreamerMessage(
  streamerMessage: types.StreamerMessage
): Promise<void> {

}
```

:::info Callback function requirements

In `near-lake-framework` JS library the handler have to be presented as a callback function. This function have to:
- be asynchronous
- accept an argument of type [`StreamerMessage`](/build/data-infrastructure/lake-data-structures/toc)
- return nothing (`void`)

:::

And an actual start of our indexer in the end of the `index.ts`

```ts title=index.ts
(async () => {
  await startStream(lakeConfig, handleStreamerMessage);
})();
```

The final `index.ts` at this moment should look like the following:

```ts title=index.ts
import { startStream, types } from 'near-lake-framework';

const lakeConfig: types.LakeConfig = {
  s3BucketName: "near-lake-data-mainnet",
  s3RegionName: "eu-central-1",
  startBlockHeight: 66264389,
};

async function handleStreamerMessage(
  streamerMessage: types.StreamerMessage
): Promise<void> {

}

(async () => {
  await startStream(lakeConfig, handleStreamerMessage);
})();
```

## Events and where to catch them

First of all let's find out where we can catch the Events. We hope you are familiar with how the [Data Flow in NEAR Blockchain](/concepts/data-flow/near-data-flow), but let's revise our knowledge:
- Mint an NFT is an action in an NFT contract (doesn't matter which one)
- Actions are located in a [Receipt](/build/data-infrastructure/lake-data-structures/receipt)
- A result of the Receipt execution is [ExecutionOutcome](/build/data-infrastructure/lake-data-structures/execution-outcome)
- `ExecutionOutcome` in turn, catches the logs a contract "prints"
- [Events](https://nomicon.io/Standards/EventsFormat) built on top of the logs

This leads us to the realization that we can watch only for ExecutionOutcomes and ignore everything else `StreamerMessage` brings us.

Also, we need to define an interface to catch the Events. Let's copy the interface definition from the [Events Nomicon page](https://nomicon.io/Standards/EventsFormat#events) and paste it before the `handleStreamerMessage` function.

```ts title=index.ts
interface EventLogData {
  standard: string,
  version: string,
  event: string,
  data?: unknown,
};
```

## Catching only the data we need

Inside the callback function `handleStreamerMessage` we've prepared in the [Preparation](#preparation) section let's start filtering the data we need:

```ts title=index.ts
async function handleStreamerMessage(
  streamerMessage: types.StreamerMessage
): Promise<void> {
  const relevantOutcomes = streamerMessage
    .shards
    .flatMap(shard => shard.receiptExecutionOutcomes)

}
```

We have iterated through all the [Shards](/build/data-infrastructure/lake-data-structures/shard) and collected the lists of all ExecutionOutcomes into a single list (in our case we don't care on which Shard did the mint happen)

Now we want to deal only with those ExecutionOutcomes that contain logs of Events format. Such logs start with `EVENT_JSON:` according to the [Events docs](https://nomicon.io/Standards/EventsFormat#events).

Also, we don't require all the data from ExecutionOutcome, let's handle it:

```ts title=index.ts
async function handleStreamerMessage(
  streamerMessage: types.StreamerMessage
): Promise<void> {
  const relevantOutcomes = streamerMessage
    .shards
    .flatMap(shard => shard.receiptExecutionOutcomes)
    .map(outcome => ({
      receipt: {
        id: outcome.receipt.receiptId,
        receiverId: outcome.receipt.receiverId,
      },
      events: outcome.executionOutcome.outcome.logs.map(
        (log: string): EventLogData => {
          const [_, probablyEvent] = log.match(/^EVENT_JSON:(.*)$/) ?? []
          try {
            return JSON.parse(probablyEvent)
          } catch (e) {
            return
          }
        }
      )
      .filter(event => event !== undefined)
    }))

}
```

Let us explain what we are doing here:

1. We are walking through the ExecutionOutcomes
2. We are constructing a list of objects containing `receipt` (it's id and the receiver) and `events` containing the Events
3. In order to collect the Events we are iterating through the ExecutionOutcome's logs trying to parse Event using regular expression. We're returning `undefined` if we fail to parse `EventLogData`
4. Finally once `events` list is collected we're filtering it dropping the `undefined`

Fine, so now we have only a list of our objects that contain some Receipt data and the list of successfully parsed `EventLogData`.

The goal for our indexer is to return the useful data about a minted NFT that follows NEP-171 standard. We need to drop irrelevant standard Events:

```ts title=index.ts
    .filter(relevantOutcome =>
      relevantOutcome.events.some(
        event => event.standard === "nep171" && event.event === "nft_mint"
      )
    )
```

## Almost done

So far we have collected everything we need corresponding to our requirements.

We can print everything in the end of the `handleStreamerMessage`:

```ts title=index.ts
  relevantOutcomes.length && console.dir(relevantOutcomes, { depth: 10 })
```

The final look of the `handleStreamerMessage` function:

```ts title=index.ts
async function handleStreamerMessage(
  streamerMessage: types.StreamerMessage
): Promise<void> {
  const relevantOutcomes = streamerMessage
    .shards
    .flatMap(shard => shard.receiptExecutionOutcomes)
    .map(outcome => ({
      receipt: {
        id: outcome.receipt.receiptId,
        receiverId: outcome.receipt.receiverId,
      },
      events: outcome.executionOutcome.outcome.logs.map(
        (log: string): EventLogData => {
          const [_, probablyEvent] = log.match(/^EVENT_JSON:(.*)$/) ?? []
          try {
            return JSON.parse(probablyEvent)
          } catch (e) {
            return
          }
        }
      )
      .filter(event => event !== undefined)
    }))
    .filter(relevantOutcome =>
      relevantOutcome.events.some(
        event => event.standard === "nep171" && event.event === "nft_mint"
      )
    )

  relevantOutcomes.length && console.dir(relevantOutcomes, { depth: 10 })
}

```

And if we run our indexer we will be catching `nft_mint` event and print the data in the terminal.

```bash
npm run start
```

:::note

Having troubles running the indexer? Please, check you haven't skipped the [Credentials](../running-near-lake/credentials.md) part :)

:::

Not so fast! Remember we were talking about having the links to the marketplaces to see the minted tokens? We're gonna extend our data with links whenever possible. At least we're gonna show you how to deal with the NFTs minted on [Paras](https://paras.id) and [Mintbase](https://mintbase.io).

## Crafting links to Paras and Mintbase for NFTs minted there

At this moment we have an array of objects we've crafted on the fly that exposes receipt, execution status and event logs. We definitely know that all the data we have at this moment are relevant for us, and we want to extend it with the links to that minted NFTs at least for those marketplaces we know.

We know and love Paras and Mintbase.

### Paras token URL

We did the research for you and here's how the URL to token on Paras is crafting:

```
https://paras.id/token/[1]::[2]/[3]
```

Where:

- [1] - Paras contract address (`x.paras.near`)
- [2] - First part of the `token_id` (`EventLogData.data` for Paras is an array of objects with `token_ids` key in it. Those IDs represented by numbers with column `:` between them)
- [3] - `token_id` itself

Example:

```
https://paras.id/token/x.paras.near::387427/387427:373
```

Let's add the interface for later use somewhere after `interface EventLogData`:

```ts
interface ParasEventLogData {
  owner_id: string,
  token_ids: string[],
};
```

### Mintbase token URL

And again we did the research for you:

```
https://www.mintbase.io/thing/[1]:[2]
```

Where:

- [1] - `meta_id` (`EventLogData.data` for Mintbase is an array of stringified JSON that contains `meta_id`)
- [2] - Store contract account address (basically Receipt's receiver ID)

Example:

```
https://www.mintbase.io/thing/70eES-icwSw9iPIkUluMHOV055pKTTgQgTiXtwy3Xus:vnartistsdao.mintbase1.near
```

Let's add the interface for later use somewhere after `interface EventLogData`:

```ts
interface MintbaseEventLogData {
  owner_id: string,
  memo: string,
}
```

Now it's a perfect time to add another `.map()`, but it might be too much. So let's proceed with a forloop to craft the output data we want to print.

```ts title=index.ts
let output = []
for (let relevantOutcome of relevantOutcomes) {
  let marketplace = "Unknown"
  let nfts = []

}
```

We're going to print the marketplace name, Receipt id so you would be able to search for it on [NEAR Explorer](https://nearblocks.io) and the list of links to the NFTs along with the owner account name.

Let's start crafting the links. Time to say "Hi!" to [Riqi](https://twitter.com/hdriqi) (just because we can):

```ts title=index.ts
let output = []
  for (let relevantOutcome of relevantOutcomes) {
    let marketplace = "Unknown"
    let nfts = []
    if (relevantOutcome.receipt.receiverId.endsWith(".paras.near")) {
      marketplace = "Paras"
      nfts = relevantOutcome.events.flatMap(event => {
        return (event.data as ParasEventLogData[])
          .map(eventData => ({
            owner: eventData.owner_id,
            links: eventData.token_ids.map(
              tokenId => `https://paras.id/token/${relevantOutcome.receipt.receiverId}::${tokenId.split(":")[0]}/${tokenId}`
            )
           })
        )
      })
    }
```

A few words about what is going on here. If the Receipt's receiver account name ends with `.paras.near` (e.g. `x.paras.near`) we assume it's from Paras marketplace, so we are changing the corresponding variable.

After that we iterate over the Events and its `data` using the `ParasEventLogData` we've defined earlier. Collecting a list of objects with the NFTs owner and NFTs links.

Mintbase turn, we hope [Nate](https://twitter.com/nategeier) and his team have [migrated to NEAR Lake Framework](../../lake-framework/migrating-to-near-lake-framework.md) already, saying "Hi!" and crafting the link:

```ts title=index.ts
  } else if (relevantOutcome.receipt.receiverId.match(/\.mintbase\d+\.near$/)) {
      marketplace = "Mintbase"
      nfts = relevantOutcome.events.flatMap(event => {
        return (event.data as MintbaseEventLogData[])
          .map(eventData => {
          const memo = JSON.parse(eventData.memo)
          return {
            owner: eventData.owner_id,
            links: [`https://mintbase.io/thing/${memo["meta_id"]}:${relevantOutcome.receipt.receiverId}`]
          }
        })
      })
    }
```

Almost the same story as with Paras, but a little bit more complex. The nature of Mintbase marketplace is that it's not a single marketplace! Every Mintbase user has their own store and a separate contract. And it looks like those contract addresses follow the same principle they end with `.mintbaseN.near` where `N` is number (e.g. `nate.mintbase1.near`).

After we have defined that the ExecutionOutcome receiver is from Mintbase we are doing the same stuff as with Paras:

1. Changing the `marketplace` variable
2. Collecting the list of NFTs with owner and crafted links

And if we can't determine the marketplace, we still want to return something, so let's return Events data as is:

```ts title=index.ts
  } else {
    nfts = relevantOutcome.events.flatMap(event => event.data)
  }
```

It's time to push the collected data to the `output`

```ts title=index.ts
  output.push({
    receiptId: relevantOutcome.receipt.id,
    marketplace,
    nfts,
  })
```

And make it print the output to the terminal:

```ts title=index.ts
if (output.length) {
  console.log(`We caught freshly minted NFTs!`)
  console.dir(output, { depth: 5 })
}
```

All together:

```ts title=index.ts
  let output = []
  for (let relevantOutcome of relevantOutcomes) {
    let marketplace = "Unknown"
    let nfts = []
    if (relevantOutcome.receipt.receiverId.endsWith(".paras.near")) {
      marketplace = "Paras"
      nfts = relevantOutcome.events.flatMap(event => {
        return (event.data as ParasEventLogData[])
          .map(eventData => ({
            owner: eventData.owner_id,
            links: eventData.token_ids.map(
              tokenId => `https://paras.id/token/${relevantOutcome.receipt.receiverId}::${tokenId.split(":")[0]}/${tokenId}`
            )
           })
        )
      })
    } else if (relevantOutcome.receipt.receiverId.match(/\.mintbase\d+\.near$/)) {
      marketplace = "Mintbase"
      nfts = relevantOutcome.events.flatMap(event => {
        return (event.data as MintbaseEventLogData[])
          .map(eventData => {
          const memo = JSON.parse(eventData.memo)
          return {
            owner: eventData.owner_id,
            links: [`https://mintbase.io/thing/${memo["meta_id"]}:${relevantOutcome.receipt.receiverId}`]
          }
        })
      })
    } else {
      nfts = relevantOutcome.events.flatMap(event => event.data)
    }
    output.push({
      receiptId: relevantOutcome.receipt.id,
      marketplace,
      createdOn,
      nfts,
    })
  }
  if (output.length) {
    console.log(`We caught freshly minted NFTs!`)
    console.dir(output, { depth: 5 })
  }
```

OK, how about the date and time of the NFT mint? Let's add to the beginning of the `handleStreamerMessage` function

```ts title=index.ts
const createdOn = new Date(streamerMessage.block.header.timestamp / 1000000)
```

Update the `output.push()` expression:

```ts title=index.ts
output.push({
  receiptId: relevantOutcome.receipt.id,
  marketplace,
  createdOn,
  nfts,
})
```

And not that's it. Run the indexer to watch for NFT minting and never miss a thing.

```bash
npm run start
```

:::note

Having troubles running the indexer? Please, check you haven't skipped the [Credentials](../running-near-lake/credentials.md) part :)

:::

Example output:

```
We caught freshly minted NFTs!
[
  {
    receiptId: '2y5XzzL1EEAxgq8EW3es2r1dLLkcecC6pDFHR12osCGk',
    marketplace: 'Paras',
    createdOn: 2022-05-24T09:35:57.831Z,
    nfts: [
      {
        owner: 'dccc.near',
        links: [ 'https://paras.id/token/x.paras.near::398089/398089:17' ]
      }
    ]
  }
]
We caught freshly minted NFTs!
[
  {
    receiptId: 'BAVZ92XdbkAPX4DkqW5gjCvrhLX6kGq8nD8HkhQFVt5q',
    marketplace: 'Mintbase',
    createdOn: 2022-05-24T09:36:00.411Z,
    nfts: [
      {
        owner: 'chiming.near',
        links: [
          'https://mintbase.io/thing/HOTcn6LTo3qTq8bUbB7VwA1GfSDYx2fYOqvP0L_N5Es:vnartistsdao.mintbase1.near'
        ]
      }
    ]
  }
]
```

## Conclusion

What a ride, yeah? Let's sum up what we have done:

- You've learnt about [Events](https://nomicon.io/Standards/EventsFormat)
- Now you understand how to follow for the Events
- Knowing the fact that as a contract developer you can use Events and emit your own events, now you know how to create an indexer that follows those Events
- We've had a closer look at NFT minting process, you can experiment further and find out how to follow `nft_transfer` Events

The material from this tutorial can be extrapolated for literally any event that follows the [Events format](https://nomicon.io/Standards/EventsFormat)

Not mentioning you have a dedicated indexer to find out about the newest NFTs minted out there and to be the earliest bird to collect them.

Let's go hunt doo, doo, doo ü¶à

:::note Source code for the tutorial

[`near-examples/near-lake-nft-indexer`](https://github.com/near-examples/near-lake-nft-indexer): source code for this tutorial

:::

'''
'''--- docs/2.build/6.data-infrastructure/lake-framework/building-indexers/primitives.md ---
---
id: primitives
title: NEAR Lake Primitive Types
sidebar_label: Lake Primitive Types
---

# NEAR Lake Primitive Types

This article contains the primitive types used by the [NEAR Lake Framework package](https://www.npmjs.com/package/@near-lake/framework). These types are used to define the data structures used by the framework as well as provide some popular helper functions.

## `Block`

:::info Important Notes on `Block`

- All the entities located on different shards were merged into one single list without differentiation.
- `Block` is not the fairest name for this structure either. NEAR Protocol is a sharded blockchain, so its block is actually an ephemeral structure that represents a collection of real blocks called chunks in NEAR Protocol.

:::

### `Block` Structure Definition

The `Block` type is used to represent a block in the NEAR Lake Framework. It is comprised by the following structure:

```ts
export class Block {
    constructor(
        readonly streamerMessage: StreamerMessage,
        private executedReceipts: Receipt[],
        readonly postponedReceipts: Receipt[],
        readonly transactions: Transaction[],
        private _actions: Map<string, Action>,
        private _events: Map<string, Event[]>,
        private _stateChanges: StateChange[]) { 

        }
    ... // helper methods and getters omitted for brevity
}
```

#### `streamerMessage`

Low-level structure for backward compatibility. As implemented in previous versions of [`near-lake-framework`](https://www.npmjs.com/package/near-lake-framework). 

#### `postponedReceipts`

Receipts included on the chain but not executed yet marked as ‚Äúpostponed‚Äù: they are represented by the same structure `Receipt` (see the corresponding section in this doc for more details).

#### `transactions`

List of included `Transactions`, converted into `Receipts`.

:::info Heads up!

**Note:**  You might want to know about `Transactions` to know where the action chain has begun. Unlike Ethereum, where a Transaction contains everything you may want to know about a particular interaction on  the Ethereum blockchain, Near Protocol because of its asynchronous nature converts a `Transaction` into a `Receipt` before executing it. Thus, On NEAR, `Receipts` are more important for figuring out what happened on-chain as a result of a Transaction signed by a user. Read more about [Transactions on Near](https://nomicon.io/RuntimeSpec/Transactions) here.

:::

### `Block` Helper Methods

```ts
export class Block {
    ... // constructor omitted for brevity
    get blockHash(): string {}
    get prevBlockHash(): string {}
    get blockHeight(): number {}

    header(): BlockHeader {}
    receipts(): Receipt[] {}
    actions(): Action[] {}
    events(): Event[] {}
    stateChanges(): StateChange[] {}

    actionByReceiptId(receipt_id: string): Action | undefined {}
    eventsByReceiptId(receipt_id: string): Event[] {}
    eventsByAccountId(account_id: string): Event[] {}

    private buildActionsHashmap() {}
    private buildEventsHashmap(): Map<string, Event[]> {}

    static fromStreamerMessage(streamerMessage: StreamerMessage): Block {}
}
```

#### `blockHash`

Returns the block hash. A shortcut to get the data from the block header.

#### `prevBlockHash`

Returns the previous block hash. A shortcut to get the data from the block header.

#### `blockHeight`

Returns the block height. A shortcut to get the data from the block header.

#### `header(): BlockHeader`

Returns a `BlockHeader` structure of the block

See `BlockHeader` structure sections for details.

#### `receipts(): Receipt[]`

Returns a slice of `Receipts` executed in the block.

Basically is a getter for the `executedReceipts` field.

#### `actions(): Action[]`

Returns an Array of `Actions` executed in the block.

#### `events(): Event[]`

Returns `Events` emitted in the block.

#### `stateChanges(): StateChange[]`

Returns an Array of `StateChange` occurred in the block.

#### `actionByReceiptId(receipt_id: string): Action | undefined`

Returns `Action`s of the provided `receipt_id` from the block if any. Returns `undefined` if there is no corresponding `Action`.

This method uses the internal `Block` `action` field which is empty by default and will be filled with the block‚Äôs actions on the first call to optimize memory usage.

The result is either `Action | undefined` since there might be a request for an `Action` by `receipt_id` from another block, in which case this method will be unable to find the `Action` in the current block. In the other case, the request might be for an `Action` for a `receipt_id` that belongs to a `DataReceipt` where an action does not exist.

#### `eventsByReceiptId(receipt_id: string): Event[]`

Returns an Array of Events emitted by `ExecutionOutcome` for the given `receipt_id`. There might be more than one `Event` for the `Receipt` or there might be none of them. In the latter case, this method returns an empty Array.

#### `eventsByAccountId(account_id: string): Event[]`

Returns an Array of Events emitted by `ExecutionOutcome` for the given `account_id`. There might be more than one `Event` for the `Receipt` or there might be none of them. In the latter case, this method returns an empty Array.

---

## `BlockHeader`

Replacement for `BlockHeaderView` from `near-primitives`. Shrunken and simplified. 

:::note
The original `BlockHeaderView` is still accessible via the `.streamerMessage` attribute.
:::

### `BlockHeader` Structure Definition

```ts
export class BlockHeader {
    constructor(
        readonly height: number,
        readonly hash: string,
        readonly prevHash: string,
        readonly author: string,
        readonly timestampNanosec: string,
        readonly epochId: string,
        readonly nextEpochId: string,
        readonly gasPrice: string,
        readonly totalSupply: string,
        readonly latestProtocolVersion: number,
        readonly randomValue: string,
        readonly chunksIncluded: number,
        readonly validatorProposals: ValidatorStakeView[]) { 
        }
    ... // helper method omitted for brevity
}
```

---

## `Receipt`

This field is a simplified representation of the `ReceiptView` structure from `near-primitives`.

### `Receipt` Structure Definition

```ts
export class Receipt implements Events {
  constructor(
    readonly receiptKind: ReceiptKind, 
    readonly receiptId: string, 
    readonly receiverId: string, 
    readonly predecessorId: string, 
    readonly status: ExecutionStatus, 
    readonly executionOutcomeId?: string | undefined, 
    readonly logs: string[] = []) {
    }
  ... // helper methods omitted for brevity
}
```

### `Receipt` Fields

#### `receiptKind`

Defined the type of the `Receipt`: `Action` or `Data` representing the `ActionReceipt` and `DataReceipt`.

#### `receiptId`

The ID of the `Receipt` of the `CryptoHash` type.

#### `receiverId`

The receiver account id of the `Receipt`.

#### `predecessorId`

The predecessor account id of the `Receipt`.

#### `status`

Represents the status of `ExecutionOutcome` of the `Receipt`.

See the `ExecutionStatus` enum section for the details.

#### `executionOutcomeId`

The id of the `ExecutionOutcome` for the `Receipt`. Returns `null` if the `Receipt` isn‚Äôt executed yet and has a postponed status.

#### `logs`

The original logs of the corresponding `ExecutionOutcome` of the `Receipt`.

Note: not all of the logs might be parsed as JSON Events (`Events`).

### `Receipt` Helper Methods

```ts
export class Receipt {
    ... // constructor omitted for brevity
    get events(): Event[] {}

    static fromOutcomeWithReceipt(outcomeWithReceipt: OutcomeWithReceipt): Receipt {}
}
```

#### `Receipt.events(): Events[]`

Returns an Array of `Events` for the `Receipt`, if any. This might be empty if the `logs` field is empty or doesn‚Äôt contain JSON Events compatible log records.

---

## `Event`

This structure is an ephemeral entity to provide access to the [Events Standard](https://github.com/near/NEPs/blob/master/neps/nep-0297.md) structure and keep data about the related `Receipt` for convenience.

### Interface for Capturing Data About an Event in `handleStreamerMessage()`

The interface to capture data about an event has the following arguments:

- `standard`: name of standard, e.g. nep171
- `version`: e.g. 1.0.0
- `event`: type of the event, e.g. nft_mint
- `data`: associate event data. Strictly typed for each set `{standard, version, event}` inside corresponding NEP

### `Event` Structure Definition

```ts
export class Event {
    constructor(
      readonly relatedReceiptId: string, 
      readonly rawEvent: RawEvent) {
      }
    ... // helper methods omitted for brevity
}
```

### `Event` Methods

```ts
export class Event {
    ... // constructor omitted for brevity
    static fromLog(log: string): Event {}
}
```

---

## `Transaction`

A representation of the `IndexerTransactionWithOutcome` from `near-indexer-primitives` which is an ephemeral structure combining `SignedTransactionView` from `near-primitives` and `IndexerExecutionOutcomeWithOptionalReceipt` from `near-indexer-primitives`.

This structure is very similar to `Receipt`. Unlike `Receipt`, a `Transaction` has a few additional fields like `signerId`, `signature`, and `operations`.

### `Transaction` Structure Definition

```ts
export class Transaction {
    constructor(
      readonly transactionHash: string, 
      readonly signerId: string, 
      readonly signerPublicKey: string, 
      readonly signature: string, 
      readonly receiverId: string, 
      readonly status: ExecutionStatus, 
      readonly executionOutcomeId: string, 
      readonly operations: Operation[]) { 
      }
}
```

#### `Transaction.transactionHash`

Returns the hash of the `Transaction` in `CryptoHash`.

#### `Transaction.signerId`

Returns the signer account id of the `Transaction`.

#### `Transaction.signerPublicKey`

Returns the `PublicKey` of the signer of the `Transaction`.

#### `Transaction.signature`

Returns the `Signature` the `Transaction` was signed with.

#### `Transaction.receiverId`

Returns the receiver account id of the `Transaction`.

#### `Transaction.status`

Returns the status of the `Transaction` as `ExecutionStatus`.

#### `Transaction.executionOutcomeId`

Returns the id of the `ExecutionOutcome` for the `Transaction`.

#### `Transaction.operations`

Returns an Array of `Operation` for the `Transaction`.

---

## `StateChange`

This structure is almost an identical copy of the `StateChangeWithCauseView` from `near-primitives` with a propagated additional field `affectedAccountId`.

### `StateChange` Structure Definition

```ts
export class StateChange {
    constructor(
      readonly cause: StateChangeCause, 
      readonly value: StateChangeValue
    ) {}
    
    get affectedAccountId(): string {}

    static fromStateChangeView(stateChangeView: StateChangeWithCauseView) {}
}
```

#### `StateChange.cause`

Returns the `cause` of the `StateChange`.

#### `StateChange.value`

Returns the `value` of the `StateChange`.

#### `StateChange.affectedAccountId(): string`

Returns the account id of the `StateChange`.

#### `StateChange.fromStateChangeView(stateChangeView: StateChangeWithCauseView): StateChange`

Returns the `StateChange` from the `StateChangeWithCauseView`. Created for backward compatibility.

'''
'''--- docs/2.build/6.data-infrastructure/lake-framework/building-indexers/python-lake-indexer.md ---
---
sidebar_label: "Python tutorial"
---

# NEAR Lake indexer basic tutorial

:::info Source code for the tutorial

[`frolvanya/near-lake-raw-printer`](https://github.com/frolvanya/near-lake-raw-printer): source code for the tutorial on how to create an indexer that prints block height and number of shards

:::

Recently we have [published a Python version of the NEAR Lake Framework](https://pypi.org/project/near-lake-framework/) on pypi.org

We want to empower you with a basic tutorial on how to use the Python Package. Let's get started!

## Create a project

Create an indexer project:

```bash
mkdir near-lake-raw-printer && cd near-lake-raw-printer
touch main.py
```

## Install dependencies

Install `near-lake-framework`

```bash
pip3 install near-lake-framework
```

## Import `near-lake-framework`

In the `main.py` file let's import the necessary dependencies:

```python title=main.py
from near_lake_framework import near_primitives, LakeConfig, streamer
```

We've imported the main function `streamer` which will be called to actually run the indexer, `near_primitives` and `LakeConfig` type we need to contruct.

## Create a config

Add the instantiation of `LakeConfig` below:

```python title=main.py
config = LakeConfig.mainnet()
config.start_block_height = 69030747
config.aws_access_key_id = os.getenv("AWS_ACCESS_KEY_ID")
config.aws_secret_key = os.getenv("AWS_SECRET_ACCESS_KEY")
```

Just a few words on the config, function `mainnet()` has set `s3_bucket_name`, `s3_region_name` for mainnet.
You can go to [NEAR Explorer](https://nearblocks.io) and get **the most recent** block height to set `config.start_block_height`.

## Starting the stream

Let's call `streamer` function with the `config`:

```python title=main.py
stream_handle, streamer_messages_queue = streamer(config)
while True:
    streamer_message = await streamer_messages_queue.get()
    print(f"Block #{streamer_message.block.header.height} Shards: {len(streamer_message.shards)}")
```

And an actual start of our indexer in the end of the `main.py`

```python title=main.py
loop = asyncio.get_event_loop()
loop.run_until_complete(main())
```

## All together

```python title=main.py
import asyncio
import os

from near_lake_framework import LakeConfig, streamer, near_primitives

async def main():    
    config = LakeConfig.mainnet()
    config.start_block_height = 69030747
    config.aws_access_key_id = os.getenv("AWS_ACCESS_KEY_ID")
    config.aws_secret_key = os.getenv("AWS_SECRET_ACCESS_KEY")

    stream_handle, streamer_messages_queue = streamer(config)
    while True:
        streamer_message = await streamer_messages_queue.get()
        print(f"Block #{streamer_message.block.header.height} Shards: {len(streamer_message.shards)}")

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
```

That's it. Now we run `main.py`

```bash
python3 main.py
```

You should see something like the following:

```bash
Received 400 blocks from S3
Block #69030747 Shards: 4
Block #69030748 Shards: 4
Block #69030749 Shards: 4
Block #69030750 Shards: 4
Block #69030751 Shards: 4
Block #69030752 Shards: 4
Block #69030753 Shards: 4
Block #69030754 Shards: 4
```

You can stop the indexer by pressing CTRL+C

:::danger Credentials

To be able to access the data from [NEAR Lake](/tools/realtime#near-lake-indexer) you need to provide credentials. Please, see the [Credentials](../../lake-framework/running-near-lake/credentials.md) article

:::

You can find the [source code for this tutorial on the GitHub](https://github.com/frolvanya/near-lake-raw-printer).

'''
'''--- docs/2.build/6.data-infrastructure/lake-framework/building-indexers/python-nft-indexer.md ---
---
sidebar_label: "NFT indexer for Python"
---

# Building an NFT indexer for Python

:::note Source code for the tutorial

[`frolvanya/near-lake-nft-indexer`](https://github.com/frolvanya/near-lake-nft-indexer): source code for this tutorial

:::

## The Goal

This tutorial ends with a working NFT indexer built on top [NEAR Lake Framework for Python](/concepts/advanced/near-lake-framework). The indexer is watching for `nft_mint` [Events](https://nomicon.io/Standards/EventsFormat) and prints some relevant data:
- `receipt_id` of the [Receipt](/build/data-infrastructure/lake-data-structures/receipt) where the mint has happened
- Marketplace
- NFT owner account name
- Links to the NFTs on the marketplaces

The final source code is available on the GitHub [`frolvanya/near-lake-nft-indexer`](https://github.com/frolvanya/near-lake-nft-indexer)

## Motivation

NEAR Protocol had introduced a nice feature [Events](https://nomicon.io/Standards/EventsFormat). The Events allow a contract developer to add standardized logs to the [`ExecutionOutcomes`](/build/data-infrastructure/lake-data-structures/execution-outcome) thus allowing themselves or other developers to read those logs in more convenient manner via API or indexers.

The Events have a field `standard` which aligns with NEPs. In this tutorial we'll be talking about [NEP-171 Non-Fungible Token standard](https://github.com/near/NEPs/discussions/171).

In this tutorial our goal is to show you how you can "listen" to the Events contracts emit and how you can benefit from them.

As the example we will be building an indexer that watches all the NFTs minted following the [NEP-171 Events](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event) standard, assuming we're collectors who don't want to miss a thing. Our indexer should notice every single NFT minted and give us a basic set of data like: in what Receipt it was minted, and show us the link to a marketplace (we'll cover [Paras](https://paras.id) and [Mintbase](https://mintbase.io) in our example).

We will use Python version of [NEAR Lake Framework](/concepts/advanced/near-lake-framework) in this tutorial. Though the concept is the same for Rust, but we want to show more people that it's not that complex to build your own indexer.

## Preparation

:::danger Credentials

Please, ensure you've the credentials set up as described on the [Credentials](../running-near-lake/credentials.md) page. Otherwise you won't be able to get the code working.

:::

Let's create our project folder

```bash
mkdir lake-nft-indexer && cd lake-nft-indexer
touch main.py
```

## Set up NEAR Lake Framework

In the `main.py` let's import `stream` function and `near_primitives` from `near-lake-framework`:

```python title=main.py
from near_lake_framework import near_primitives, LakeConfig, streamer
```

Add the main function

```python title=main.py
async def main():
    print("Starting NFT indexer")
```

Add the instantiation of `LakeConfig` below:

```python title=main.py
config = LakeConfig.mainnet()
config.start_block_height = 69030747
config.aws_access_key_id = os.getenv("AWS_ACCESS_KEY_ID")
config.aws_secret_key = os.getenv("AWS_SECRET_ACCESS_KEY")
```

Just a few words on the config, function `mainnet()` has set `s3_bucket_name`, `s3_region_name` for mainnet.
You can go to [NEAR Explorer](https://nearblocks.io) and get **the most recent** block height to set `config.start_block_height`.

Let's call `streamer` function with the `config`

```python title=main.py
stream_handle, streamer_messages_queue = streamer(config)
while True:
    streamer_message = await streamer_messages_queue.get()
```

And an actual start of our indexer in the end of the `main.py`

```python title=main.py
loop = asyncio.get_event_loop()
loop.run_until_complete(main())
```

The final `main.py` at this moment should look like the following:

```python title=main.py
from near_lake_framework import LakeConfig, streamer, near_primitives
async def main():
    print("Starting NFT indexer")
    
    config = LakeConfig.mainnet()
    config.start_block_height = 69030747
    config.aws_access_key_id = os.getenv("AWS_ACCESS_KEY_ID")
    config.aws_secret_key = os.getenv("AWS_SECRET_ACCESS_KEY")

    stream_handle, streamer_messages_queue = streamer(config)
    while True:
        streamer_message = await streamer_messages_queue.get()

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
```

Now we need to create a callback function that we'll be called to handle [`StreamerMessage`](/build/data-infrastructure/lake-data-structures/toc) our indexer receives.

```python title=main.py
async def handle_streamer_message(streamer_message: near_primitives.StreamerMessage):
    pass
```

## Events and where to catch them

First of all let's find out where we can catch the Events. We hope you are familiar with how the [Data Flow in NEAR Blockchain](/concepts/data-flow/near-data-flow), but let's revise our knowledge:
- Mint an NFT is an action in an NFT contract (doesn't matter which one)
- Actions are located in a [Receipt](/build/data-infrastructure/lake-data-structures/receipt)
- A result of the Receipt execution is [ExecutionOutcome](/build/data-infrastructure/lake-data-structures/execution-outcome)
- `ExecutionOutcome` in turn, catches the logs a contract "prints"
- [Events](https://nomicon.io/Standards/EventsFormat) built on top of the logs

This leads us to the realization that we can watch only for ExecutionOutcomes and ignore everything else `StreamerMessage` brings us.

## Catching only the data we need

Inside the callback function `handle_streamer_message` we've prepared in the [Preparation](#preparation) section let's start filtering the data we need:

```python title=main.py
async def handle_streamer_message(streamer_message: near_primitives.StreamerMessage):
    for shard in streamer_message.shards:
        for receipt_execution_outcome in shard.receipt_execution_outcomes:
            for log in receipt_execution_outcome.execution_outcome.outcome.logs:
                pass
```

We have iterated through the logs of all ExecutionOutcomes of [Shards](/build/data-infrastructure/lake-data-structures/shard) (in our case we don't care on which Shard did the mint happen)

Now we want to deal only with those ExecutionOutcomes that contain logs of Events format. Such logs start with `EVENT_JSON:` according to the [Events docs](https://nomicon.io/Standards/EventsFormat#events).

```python title=main.py
async def handle_streamer_message(streamer_message: near_primitives.StreamerMessage):
    for shard in streamer_message.shards:
        for receipt_execution_outcome in shard.receipt_execution_outcomes:
            for log in receipt_execution_outcome.execution_outcome.outcome.logs:
                if not log.startswith("EVENT_JSON:"):
                    continue
                try:
                    parsed_log = json.loads(log[len("EVENT_JSON:") :])
                except json.JSONDecodeError:
                    print(
                        f"Receipt ID: `{receipt_execution_outcome.receipt.receipt_id}`\nError during parsing logs from JSON string to dict"
                    )
                    continue
```

Let us explain what we are doing here:

1. We are walking through the logs in ExecutionOutcomes
2. We are filtering ExecutionOutcomes that contain logs of Events format
3. In order to collect the Events we are iterating through the ExecutionOutcome's logs trying to parse Event using `json.loads`

The goal for our indexer is to return the useful data about a minted NFT that follows NEP-171 standard. We need to drop irrelevant standard Events:

```python title=main.py
    if (
        parsed_log.get("standard") != "nep171"
        or parsed_log.get("event") != "nft_mint"
    ):
        continue
```

## Almost done

So far we have collected everything we need corresponding to our requirements.

The final look of the `handle_streamer_message` function:

```python title=main.py
async def handle_streamer_message(streamer_message: near_primitives.StreamerMessage):
    for shard in streamer_message.shards:
        for receipt_execution_outcome in shard.receipt_execution_outcomes:
            for log in receipt_execution_outcome.execution_outcome.outcome.logs:
                if not log.startswith("EVENT_JSON:"):
                    continue
                try:
                    parsed_log = json.loads(log[len("EVENT_JSON:") :])
                except json.JSONDecodeError:
                    print(
                        f"Receipt ID: `{receipt_execution_outcome.receipt.receipt_id}`\nError during parsing logs from JSON string to dict"
                    )
                    continue

                if (
                    parsed_log.get("standard") != "nep171"
                    or parsed_log.get("event") != "nft_mint"
                ):
                    continue

                print(parsed_log)
```

Now let's call `handle_streamer_message` inside the loop in `main` function

```python title=main.py
await handle_streamer_message(streamer_message)
```

And if we run our indexer we will be catching `nft_mint` event and print logs in the terminal.

```bash
python3 main.py
```

:::note

Having troubles running the indexer? Please, check you haven't skipped the [Credentials](../running-near-lake/credentials.md) part :)

:::

Not so fast! Remember we were talking about having the links to the marketplaces to see the minted tokens? We're gonna extend our data with links whenever possible. At least we're gonna show you how to deal with the NFTs minted on [Paras](https://paras.id) and [Mintbase](https://mintbase.io).

## Crafting links to Paras and Mintbase for NFTs minted there

At this moment we have an access to logs that follows NEP-171 standard. We definitely know that all the data we have at this moment are relevant for us, and we want to extend it with the links to that minted NFTs at least for those marketplaces we know.

We know and love Paras and Mintbase.

### Paras token URL

We did the research for you and here's how the URL to token on Paras is crafting:

```
https://paras.id/token/[1]::[2]/[3]
```

Where:

- [1] - Paras contract address (`x.paras.near`)
- [2] - First part of the `token_id` (`parsed_log["data"]` for Paras is an array of objects with `token_ids` key in it. Those IDs represented by numbers with column `:` between them)
- [3] - `token_id` itself

Example:

```
https://paras.id/token/x.paras.near::387427/387427:373
```

### Mintbase token URL

And again we did the research for you:

```
https://www.mintbase.io/thing/[1]:[2]
```

Where:

- [1] - `meta_id` (`parsed_log["data"]` for Mintbase is an array of stringified JSON that contains `meta_id`)
- [2] - Store contract account address (basically Receipt's receiver ID)

Example:

```
https://www.mintbase.io/thing/70eES-icwSw9iPIkUluMHOV055pKTTgQgTiXtwy3Xus:vnartistsdao.mintbase1.near
```

Let's start crafting the links:

```python title=main.py
def format_paras_nfts(data, receipt_execution_outcome):
    links = []

    for data_element in data:
        for token_id in data_element.get("token_ids", []):
            first_part_of_token_id = token_id.split(":")[0]
            links.append(
                f"https://paras.id/token/{receipt_execution_outcome.receipt.receiver_id}::{first_part_of_token_id}/{token_id}"
            )

    return {"owner": data[0].get("owner_id"), "links": links}

def format_mintbase_nfts(data, receipt_execution_outcome):
    links = []
    for data_block in data:
        try:
            memo = json.loads(data_block.get("memo"))
        except json.JSONDecodeError:
            print(
                f"Receipt ID: `{receipt_execution_outcome.receipt.receipt_id}`\nMemo: `{memo}`\nError during parsing Mintbase memo from JSON string to dict"
            )
            return

        meta_id = memo.get("meta_id")
        links.append(
            f"https://www.mintbase.io/thing/{meta_id}:{receipt_execution_outcome.receipt.receiver_id}"
        )

    return {"owner": data[0].get("owner_id"), "links": links}
```

We're going to print the receipt_id, so you would be able to search for it on [NEAR Explorer](https://nearblocks.io), marketplace name and the list of links to the NFTs along with the owner account name.

```python title=main.py
if receipt_execution_outcome.receipt.receiver_id.endswith(
    ".paras.near"
):
    output = {
        "receipt_id": receipt_execution_outcome.receipt.receipt_id,
        "marketplace": "Paras",
        "nfts": format_paras_nfts(
            parsed_log["data"], receipt_execution_outcome
        ),
    }
```

A few words about what is going on here. If the Receipt's receiver account name ends with `.paras.near` (e.g. `x.paras.near`) we assume it's from Paras marketplace, so we are changing the corresponding variable.

Mintbase turn, we hope [Nate](https://twitter.com/nategeier) and his team have [migrated to NEAR Lake Framework](../migrating-to-near-lake-framework.md) already, saying "Hi!" and crafting the link:

```python title=main.py
    elif re.search(
        ".mintbase\d+.near", receipt_execution_outcome.receipt.receiver_id
    ):
        output = {
            "receipt_id": receipt_execution_outcome.receipt.receipt_id,
            "marketplace": "Mintbase",
            "nfts": format_mintbase_nfts(
                parsed_log["data"], receipt_execution_outcome
            ),
        }
    else:
        continue
```

Almost the same story as with Paras, but a little bit more complex. The nature of Mintbase marketplace is that it's not a single marketplace! Every Mintbase user has their own store and a separate contract. And it looks like those contract addresses follow the same principle they end with `.mintbaseN.near` where `N` is number (e.g. `nate.mintbase1.near`).

After we have defined that the ExecutionOutcome receiver is from Mintbase we are doing the same stuff as with Paras:

1. Setting the `marketplace` variable to Mintbase
2. Collecting the list of NFTs with owner and crafted links

And make it print the output to the terminal:

```python title=main.py
print(json.dumps(output, indent=4))
```

All together:

```python title=main.py
def format_paras_nfts(data, receipt_execution_outcome):
    links = []

    for data_element in data:
        for token_id in data_element.get("token_ids", []):
            first_part_of_token_id = token_id.split(":")[0]
            links.append(
                f"https://paras.id/token/{receipt_execution_outcome.receipt.receiver_id}::{first_part_of_token_id}/{token_id}"
            )

    return {"owner": data[0].get("owner_id"), "links": links}

def format_mintbase_nfts(data, receipt_execution_outcome):
    links = []
    for data_block in data:
        try:
            memo = json.loads(data_block.get("memo"))
        except json.JSONDecodeError:
            print(
                f"Receipt ID: `{receipt_execution_outcome.receipt.receipt_id}`\nMemo: `{memo}`\nError during parsing Mintbase memo from JSON string to dict"
            )
            return

        meta_id = memo.get("meta_id")
        links.append(
            f"https://www.mintbase.io/thing/{meta_id}:{receipt_execution_outcome.receipt.receiver_id}"
        )

    return {"owner": data[0].get("owner_id"), "links": links}

async def handle_streamer_message(streamer_message: near_primitives.StreamerMessage):
    for shard in streamer_message.shards:
        for receipt_execution_outcome in shard.receipt_execution_outcomes:
            for log in receipt_execution_outcome.execution_outcome.outcome.logs:
                if not log.startswith("EVENT_JSON:"):
                    continue
                try:
                    parsed_log = json.loads(log[len("EVENT_JSON:") :])
                except json.JSONDecodeError:
                    print(
                        f"Receipt ID: `{receipt_execution_outcome.receipt.receipt_id}`\nError during parsing logs from JSON string to dict"
                    )
                    continue

                if (
                    parsed_log.get("standard") != "nep171"
                    or parsed_log.get("event") != "nft_mint"
                ):
                    continue

                if receipt_execution_outcome.receipt.receiver_id.endswith(
                    ".paras.near"
                ):
                    output = {
                        "receipt_id": receipt_execution_outcome.receipt.receipt_id,
                        "marketplace": "Paras",
                        "nfts": format_paras_nfts(
                            parsed_log["data"], receipt_execution_outcome
                        ),
                    }
                elif re.search(
                    ".mintbase\d+.near", receipt_execution_outcome.receipt.receiver_id
                ):
                    output = {
                        "receipt_id": receipt_execution_outcome.receipt.receipt_id,
                        "marketplace": "Mintbase",
                        "nfts": format_mintbase_nfts(
                            parsed_log["data"], receipt_execution_outcome
                        ),
                    }
                else:
                    continue

                print(json.dumps(output, indent=4))
```

And not that's it. Run the indexer to watch for NFT minting and never miss a thing.

```bash
python3 main.py
```

:::note

Having troubles running the indexer? Please, check you haven't skipped the [Credentials](../running-near-lake/credentials.md) part :)

:::

Example output:

```
{
    "receipt_id": "8rMK8rxb3WmFcSfM3ahFoeeoBF92pad3tpsqKoSWurr2",
    "marketplace": "Mintbase",
    "nfts": {
        "owner": "vn-artists-dao.near",
        "links": [
            "https://www.mintbase.io/thing/aqdCBHB9_2XZY7pwXRRu5rGDeLQl7Q8KgNud1wKgnGo:vnartistsdao.mintbase1.near"
        ]
    }
}
{
    "receipt_id": "ArRh94Fe1LKF9yPrAdzrMozWoxMVQbEW2Z2Zf4fsSsce",
    "marketplace": "Paras",
    "nfts": {
        "owner": "eeaeb516e0945893ac01eaf547f499abdbd344831c5fcbefa1a5c0a9f303cc5c",
        "links": [
            "https://paras.id/token/x.paras.near::432714/432714:1"
        ]
    }
}
```

## Conclusion

What a ride, yeah? Let's sum up what we have done:

- You've learnt about [Events](https://nomicon.io/Standards/EventsFormat)
- Now you understand how to follow for the Events
- Knowing the fact that as a contract developer you can use Events and emit your own events, now you know how to create an indexer that follows those Events
- We've had a closer look at NFT minting process, you can experiment further and find out how to follow `nft_transfer` Events

The material from this tutorial can be extrapolated for literally any event that follows the [Events format](https://nomicon.io/Standards/EventsFormat)

Not mentioning you have a dedicated indexer to find out about the newest NFTs minted out there and to be the earliest bird to collect them.

Let's go hunt doo, doo, doo ü¶à

:::note Source code for the tutorial

[`near-examples/near-lake-nft-indexer`](https://github.com/near-examples/near-lake-nft-indexer): source code for this tutorial

:::

'''
'''--- docs/2.build/6.data-infrastructure/lake-framework/migrating-to-near-lake-framework.md ---
---
sidebar_label: Migrating to NEAR Lake framework
---

# Migrating to NEAR Lake Framework

We encourage everyone who don't have a hard requirement to use [NEAR Indexer Framework](/concepts/advanced/near-indexer-framework) consider the migration to [NEAR Lake Framework](/concepts/advanced/near-lake-framework).

In this tutorial we'll show you how to migrate the project using [indexer-tx-watcher-example](https://github.com/near-examples/indexer-tx-watcher-example) as a showcase.

:::info Source code

The source code for the migrated indexer can be found on GitHub https://github.com/near-examples/indexer-tx-watcher-example-lake/tree/0.4.0

:::

:::info Diffs

We've [posted the diffs for the reference in the end](#diffs) of the article, you can scroll down to them if diffs are all you need in order to migrate your indexer

:::

## Changing the dependencies

First of all we'll start from the dependencies in `Cargo.toml`

```toml title=src/Cargo.toml

[package]
name = "indexer-tx-watcher-example"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[dependencies]
actix = "=0.11.0-beta.2"
actix-rt = "=2.2.0"  # remove it once actix is upgraded to 0.11+
base64 = "0.11"
clap = "3.0.0-beta.1"
openssl-probe = { version = "0.1.2" }
serde = { version = "1", features = ["derive"] }
serde_json = "1.0.55"
tokio = { version = "1.1", features = ["sync"] }
tracing = "0.1.13"
tracing-subscriber = "0.2.4"

near-indexer = { git = "https://github.com/near/nearcore", rev = "25b000ae4dd9fe784695d07a3f2e99d82a6f10bd" }
```

- Update `edition` to `2021`
- Drop `actix` crates
- Drop `openssl-probe` crate
- Add `futures` and `itertools`
- Add features to `tokio` as we will be using tokio runtime
- Add `tokio-stream` crate
- Replace `near-indexer` with `near-lake-framework`

So in the end we'll have this after all:

```toml title=src/Cargo.toml
[package]
name = "indexer-tx-watcher-example"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[dependencies]
base64 = "0.11"
clap = { version = "3.1.6", features = ["derive"] }
futures = "0.3.5"
serde = { version = "1", features = ["derive"] }
serde_json = "1.0.55"
itertools = "0.9.0"
tokio = { version = "1.1", features = ["sync", "time", "macros", "rt-multi-thread"] }
tokio-stream = { version = "0.1" }
tracing = "0.1.13"
tracing-subscriber = "0.2.4"

near-lake-framework = "0.4.0"

```

## Change the clap configs

Currently we have structure `Opts` that has a subcommand with `Run` and `Init` command. Since [NEAR Lake Framework](/concepts/advanced/near-lake-framework) doesn't need `data` and config files we don't need `Init` at all. So we need to combine some structures into `Opts` itself.

```rust title=src/config.rs
...
/// NEAR Indexer Example
/// Watches for stream of blocks from the chain
#[derive(Clap, Debug)]
#[clap(version = "0.1", author = "Near Inc. <hello@nearprotocol.com>")]
pub(crate) struct Opts {
    /// Sets a custom config dir. Defaults to ~/.near/
    #[clap(short, long)]
    pub home_dir: Option<std::path::PathBuf>,
    #[clap(subcommand)]
    pub subcmd: SubCommand,
}

#[derive(Clap, Debug)]
pub(crate) enum SubCommand {
    /// Run NEAR Indexer Example. Start observe the network
    Run(RunArgs),
    /// Initialize necessary configs
    Init(InitConfigArgs),
}

#[derive(Clap, Debug)]
pub(crate) struct RunArgs {
    /// account ids to watch for
    #[clap(long)]
    pub accounts: String,
}

#[derive(Clap, Debug)]
pub(crate) struct InitConfigArgs {
    ...
}
...
```

We are going:

- Drop `InitConfigArgs` completely
- Move the content from `RunArgs` to `Opts` and then drop `RunArgs`
- Drop `home_dir` from `Opts`
- Add `block_height` to `Opts` to know from which block height to start indexing
- Refactor `SubCommand` to have to variants: mainnet and testnet to define what chain to index
- And add `Clone` detive to the structs for later

```rust title=src/config.rs
/// NEAR Indexer Example
/// Watches for stream of blocks from the chain
#[derive(Clap, Debug, Clone)]
#[clap(version = "0.1", author = "Near Inc. <hello@nearprotocol.com>")]
pub(crate) struct Opts {
    /// block height to start indexing from
    #[clap(long)]
    pub block_height: u64,
    /// account ids to watch for
    #[clap(long)]
    pub accounts: String,
    #[clap(subcommand)]
    pub subcmd: SubCommand,
}

#[derive(Clap, Debug, Clone)]
pub(crate) enum SubCommand {
    Mainnet,
    Testnet,
}
```

In the end of the file we have one implementation we need to replace.

```rust title=src/config.rs
...
impl From<InitConfigArgs> for near_indexer::InitConfigArgs {
    ...
}
```

We want to be able to cast `Opts` to `near_lake_framework::LakeConfig`. So we're going to create a new implementation.

```rust title=src/config.rs
impl From<Opts> for near_lake_framework::LakeConfig {
    fn from(opts: Opts) -> Self {
        let mut lake_config =
            near_lake_framework::LakeConfigBuilder::default().start_block_height(opts.block_height);

        match &opts.subcmd {
            SubCommand::Mainnet => {
                lake_config = lake_config.mainnet();
            }
            SubCommand::Testnet => {
                lake_config = lake_config.testnet();
            }
        };

        lake_config.build().expect("Failed to build LakeConfig")
    }
}
```

And the final move is to change `init_logging` function to remove redundant log subscriptions:

```rust title=src/config.rs

...
pub(crate) fn init_logging() {
    let env_filter = EnvFilter::new(
        "tokio_reactor=info,near=info,stats=info,telemetry=info,indexer_example=info,indexer=info,near-performance-metrics=info",
    );
    tracing_subscriber::fmt::Subscriber::builder()
        .with_env_filter(env_filter)
        .with_writer(std::io::stderr)
        .init();
}
...
```

Replace it with

```rust title=src/config.rs
...
pub(crate) fn init_logging() {
    let env_filter = EnvFilter::new("near_lake_framework=info");
    tracing_subscriber::fmt::Subscriber::builder()
        .with_env_filter(env_filter)
        .with_writer(std::io::stderr)
        .init();
}
...
```

Finally we're done with `src/config.rs` and now we can move on to `src/main.rs`

## Replacing the indexer instantiation

Since we can use `tokio` runtime and make our `main` function asynchronous it's shorted to show the recreating of the `main` function than the process of refactoring.

Let's start from import section

### Imports before

```rust title=src/main.rs
use std::str::FromStr;

use std::collections::{HashMap, HashSet};

use clap::Clap;
use tokio::sync::mpsc;
use tracing::info;

use configs::{init_logging, Opts, SubCommand};

mod configs;
```

### Imports after

We're adding `near_lake_framework` imports and remove redundant import from `configs`.

```rust title=src/main.rs
use std::str::FromStr;

use std::collections::{HashMap, HashSet};

use clap::Clap;
use tokio::sync::mpsc;
use tracing::info;

use near_lake_framework::near_indexer_primitives;
use near_lake_framework::LakeConfig;

use configs::{init_logging, Opts};
```

### Creating `main()`

Let's create an async `main()` function, call `init_logging` and read the `Opts`.

```rust title=src/main.rs
#[tokio::main]
async fn main() -> Result<(), tokio::io::Error> {
    init_logging();

    let opts: Opts = Opts::parse();

```

Let's cast `LakeConfig` from `Opts` and instantiate [NEAR Lake Framework](/concepts/advanced/near-lake-framework)'s `stream`

```rust title=src/main.rs
#[tokio::main]
async fn main() -> Result<(), tokio::io::Error> {
    init_logging();

    let opts: Opts = Opts::parse();

    let config: LakeConfig = opts.clone().into();

    let (_, stream) = near_lake_framework::streamer(config);

```

Copy/paste the code of reading `accounts` arg to `Vec<AccountId`> from the old `main()`

```rust title=src/main.rs
#[tokio::main]
async fn main() -> Result<(), tokio::io::Error> {
    init_logging();

    let opts: Opts = Opts::parse();

    let config: LakeConfig = opts.clone().into();

    let (_, stream) = near_lake_framework::streamer(config);

    let watching_list = opts
        .accounts
        .split(',')
        .map(|elem| {
            near_indexer_primitives::types::AccountId::from_str(elem).expect("AccountId is invalid")
        })
        .collect();
```

Now we can call `listen_blocks` function we have used before in our indexer while it was built on top of [NEAR Indexer Framework](/concepts/advanced/near-indexer-framework). And return `Ok(())` so our `main()` would be happy.

### Final async main with NEAR Lake Framework stream
```rust title=src/main.rs
#[tokio::main]
async fn main() -> Result<(), tokio::io::Error> {
    init_logging();

    let opts: Opts = Opts::parse();

    let config: LakeConfig = opts.clone().into();

    let (_, stream) = near_lake_framework::streamer(config);

    let watching_list = opts
        .accounts
        .split(',')
        .map(|elem| {
            near_indexer_primitives::types::AccountId::from_str(elem).expect("AccountId is invalid")
        })
        .collect();

    listen_blocks(stream, watching_list).await;

    Ok(())
}
```

We're done. That's pretty much entire `main()` function. Drop the old one if you haven't yet.

## Changes in other function related to data types

Along with [NEAR Lake Framework](/concepts/advanced/near-lake-framework) release we have extracted the structures created for indexers into a separate crate. This was done in order to avoid dependency on `nearcore` as now you can depend on a separate crate that is already [published on crates.io](https://crates.io/crates/near-indexer-primitives) or on NEAR Lake Framework that exposes that crate.

### `listen_blocks`

A function signature needs to be changed to point to new place for data types

```rust title=src/main.rs
async fn listen_blocks(
    mut stream: mpsc::Receiver<near_indexer::StreamerMessage>,
    watching_list: Vec<near_indexer::near_primitives::types::AccountId>,
 ) {
```

```rust title=src/main.rs
async fn listen_blocks(
    mut stream: mpsc::Receiver<near_indexer_primitives::StreamerMessage>,
    watching_list: Vec<near_indexer_primitives::types::AccountId>,
 ) {
```

And another 3 places where `near_indexer::near_primitives` needs to be replaced with `near_indexer_primitives`

```rust title=src/main.rs

if let near_indexer_primitives::views::ReceiptEnumView::Action {
```

```rust title=src/main.rs
if let near_indexer_primitives::views::ReceiptEnumView::Action {
```

```rust title=src/main.rs
if let near_indexer_primitives::views::ActionView::FunctionCall {
```

## `is_tx_receiver_watched()`

And final change for data types in the function `is_tx_receiver_watched()`

```rust title=src/main.rs
fn is_tx_receiver_watched(
    tx: &near_indexer_primitives::IndexerTransactionWithOutcome,
    watching_list: &[near_indexer_primitives::types::AccountId],
) -> bool {
    watching_list.contains(&tx.transaction.receiver_id)
}
```

## Credentials
[Configure the Credentials](./running-near-lake/credentials.md) in order to access the data from NEAR Lake Framework

## Conclusion

And now we have a completely migrated to [NEAR Lake Framework](/concepts/advanced/near-lake-framework) indexer.

We are posting the complete diffs for the reference

## Diffs

```diff title=Cargo.toml
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -2,18 +2,18 @@
 name = "indexer-tx-watcher-example"
 version = "0.1.0"
 authors = ["Near Inc <hello@nearprotocol.com>"]
-edition = "2018"
+edition = "2021"

 [dependencies]
-actix = "=0.11.0-beta.2"
-actix-rt = "=2.2.0"  # remove it once actix is upgraded to 0.11+
 base64 = "0.11"
-clap = "3.0.0-beta.1"
-openssl-probe = { version = "0.1.2" }
+clap = { version = "3.1.6", features = ["derive"] }
+futures = "0.3.5"
 serde = { version = "1", features = ["derive"] }
 serde_json = "1.0.55"
-tokio = { version = "1.1", features = ["sync"] }
+itertools = "0.9.0"
+tokio = { version = "1.1", features = ["sync", "time", "macros", "rt-multi-thread"] }
+tokio-stream = { version = "0.1" }
 tracing = "0.1.13"
 tracing-subscriber = "0.2.4"

-near-indexer = { git = "https://github.com/near/nearcore", rev = "25b000ae4dd9fe784695d07a3f2e99d82a6f10bd" }
+near-lake-framework = "0.4.0"
```

```diff title=src/configs.rs
--- a/src/configs.rs
+++ b/src/configs.rs
@@ -1,99 +1,50 @@
-use clap::Clap;
+use clap::Parser;

 use tracing_subscriber::EnvFilter;

 /// NEAR Indexer Example
 /// Watches for stream of blocks from the chain
-#[derive(Clap, Debug)]
+#[derive(Parser, Debug, Clone)]
 #[clap(version = "0.1", author = "Near Inc. <hello@nearprotocol.com>")]
 pub(crate) struct Opts {
-    /// Sets a custom config dir. Defaults to ~/.near/
-    #[clap(short, long)]
-    pub home_dir: Option<std::path::PathBuf>,
-    #[clap(subcommand)]
-    pub subcmd: SubCommand,
-}
-
-#[derive(Clap, Debug)]
-pub(crate) enum SubCommand {
-    /// Run NEAR Indexer Example. Start observe the network
-    Run(RunArgs),
-    /// Initialize necessary configs
-    Init(InitConfigArgs),
-}
-
-#[derive(Clap, Debug)]
-pub(crate) struct RunArgs {
+    /// block height to start indexing from
+    #[clap(long)]
+    pub block_height: u64,
     /// account ids to watch for
     #[clap(long)]
     pub accounts: String,
+    #[clap(subcommand)]
+    pub subcmd: SubCommand,
 }

-#[derive(Clap, Debug)]
-pub(crate) struct InitConfigArgs {
-    /// chain/network id (localnet, testnet, devnet, betanet)
-    #[clap(short, long)]
-    pub chain_id: Option<String>,
-    /// Account ID for the validator key
-    #[clap(long)]
-    pub account_id: Option<String>,
-    /// Specify private key generated from seed (TESTING ONLY)
-    #[clap(long)]
-    pub test_seed: Option<String>,
-    /// Number of shards to initialize the chain with
-    #[clap(short, long, default_value = "1")]
-    pub num_shards: u64,
-    /// Makes block production fast (TESTING ONLY)
-    #[clap(short, long)]
-    pub fast: bool,
-    /// Genesis file to use when initialize testnet (including downloading)
-    #[clap(short, long)]
-    pub genesis: Option<String>,
-    /// Download the verified NEAR genesis file automatically.
-    #[clap(long)]
-    pub download_genesis: bool,
-    /// Specify a custom download URL for the genesis file.
-    #[clap(long)]
-    pub download_genesis_url: Option<String>,
-    /// Download the verified NEAR config file automtically.
-    #[clap(long)]
-    pub download_config: bool,
-    /// Specify a custom download URL for the config file.
-    #[clap(long)]
-    pub download_config_url: Option<String>,
-    /// Specify the boot nodes to bootstrap the network
-    #[clap(long)]
-    pub boot_nodes: Option<String>,
-    /// Specify a custom max_gas_burnt_view limit.
-    #[clap(long)]
-    pub max_gas_burnt_view: Option<u64>,
+#[derive(Parser, Debug, Clone)]
+pub(crate) enum SubCommand {
+    Mainnet,
+    Testnet,
 }

 pub(crate) fn init_logging() {
-    let env_filter = EnvFilter::new(
-        "tokio_reactor=info,near=info,stats=info,telemetry=info,indexer_example=info,indexer=info,near-performance-metrics=info",
-    );
+    let env_filter = EnvFilter::new("near_lake_framework=info");
     tracing_subscriber::fmt::Subscriber::builder()
         .with_env_filter(env_filter)
         .with_writer(std::io::stderr)
         .init();
 }

-impl From<InitConfigArgs> for near_indexer::InitConfigArgs {
-    fn from(config_args: InitConfigArgs) -> Self {
-        Self {
-            chain_id: config_args.chain_id,
-            account_id: config_args.account_id,
-            test_seed: config_args.test_seed,
-            num_shards: config_args.num_shards,
-            fast: config_args.fast,
-            genesis: config_args.genesis,
-            download_genesis: config_args.download_genesis,
-            download_genesis_url: config_args.download_genesis_url,
-            download_config: config_args.download_config,
-            download_config_url: config_args.download_config_url,
-            boot_nodes: config_args.boot_nodes,
-            max_gas_burnt_view: config_args.max_gas_burnt_view,
-        }
+impl From<Opts> for near_lake_framework::LakeConfig {
+    fn from(opts: Opts) -> Self {
+        let mut lake_config =
+            near_lake_framework::LakeConfigBuilder::default().start_block_height(opts.block_height);
+
+        match &opts.subcmd {
+            SubCommand::Mainnet => {
+                lake_config = lake_config.mainnet();
+            }
+            SubCommand::Testnet => {
+                lake_config = lake_config.testnet();
+            }
+        };
+
+        lake_config.build().expect("Failed to build LakeConfig")
     }
 }
```

```diff title=src/main.rs
--- a/src/main.rs
+++ b/src/main.rs
@@ -2,11 +2,14 @@

 use std::collections::{HashMap, HashSet};

-use clap::Clap;
+use clap::Parser;
 use tokio::sync::mpsc;
 use tracing::info;

-use configs::{init_logging, Opts, SubCommand};
+use near_lake_framework::near_indexer_primitives;
+use near_lake_framework::LakeConfig;
+
+use configs::{init_logging, Opts};

 mod configs;

@@ -15,60 +18,34 @@
 /// We want to catch all *successful* transactions sent to one of the accounts from the list.
 /// In the demo we'll just look for them and log them but it might and probably should be extended based on your needs.

-fn main() {
-    // We use it to automatically search the for root certificates to perform HTTPS calls
-    // (sending telemetry and downloading genesis)
-    openssl_probe::init_ssl_cert_env_vars();
+#[tokio::main]
+async fn main() -> Result<(), tokio::io::Error> {
     init_logging();

     let opts: Opts = Opts::parse();

-    let home_dir = opts.home_dir.unwrap_or_else(near_indexer::get_default_home);
+    let config: LakeConfig = opts.clone().into();

-    match opts.subcmd {
-        SubCommand::Run(args) => {
-            // Create the Vec of AccountId from the provided ``--accounts`` to pass it to `listen_blocks`
-            let watching_list = args
-                .accounts
-                .split(',')
-                .map(|elem| {
-                    near_indexer::near_primitives::types::AccountId::from_str(elem)
-                        .expect("AccountId is invalid")
-                })
-                .collect();
-
-            // Inform about indexer is being started and what accounts we're watching for
-            eprintln!(
-                "Starting indexer transaction watcher for accounts: \n {:#?}",
-                &args.accounts
-            );
-
-            // Instantiate IndexerConfig with hardcoded parameters
-            let indexer_config = near_indexer::IndexerConfig {
-                home_dir,
-                sync_mode: near_indexer::SyncModeEnum::FromInterruption,
-                await_for_node_synced: near_indexer::AwaitForNodeSyncedEnum::WaitForFullSync,
-            };
+    let (_, stream) = near_lake_framework::streamer(config);

-            // Boilerplate code to start the indexer itself
-            let sys = actix::System::new();
-            sys.block_on(async move {
-                eprintln!("Actix");
-                let indexer = near_indexer::Indexer::new(indexer_config);
-                let stream = indexer.streamer();
-                actix::spawn(listen_blocks(stream, watching_list));
-            });
-            sys.run().unwrap();
-        }
-        SubCommand::Init(config) => near_indexer::indexer_init_configs(&home_dir, config.into()),
-    }
+    let watching_list = opts
+        .accounts
+        .split(',')
+        .map(|elem| {
+            near_indexer_primitives::types::AccountId::from_str(elem).expect("AccountId is invalid")
+        })
+        .collect();
+
+    listen_blocks(stream, watching_list).await;
+
+    Ok(())
 }

 /// The main listener function the will be reading the stream of blocks `StreamerMessage`
 /// and perform necessary checks
 async fn listen_blocks(
-    mut stream: mpsc::Receiver<near_indexer::StreamerMessage>,
-    watching_list: Vec<near_indexer::near_primitives::types::AccountId>,
+    mut stream: mpsc::Receiver<near_indexer_primitives::StreamerMessage>,
+    watching_list: Vec<near_indexer_primitives::types::AccountId>,
 ) {
     eprintln!("listen_blocks");
     // This will be a map of correspondence between transactions and receipts
@@ -120,7 +97,7 @@
                         &execution_outcome.receipt.receiver_id,
                         execution_outcome.execution_outcome.outcome.status
                     );
-                    if let near_indexer::near_primitives::views::ReceiptEnumView::Action {
+                    if let near_indexer_primitives::views::ReceiptEnumView::Action {
                         signer_id,
                         ..
                     } = &execution_outcome.receipt.receipt
@@ -128,19 +105,20 @@
                         eprintln!("{}", signer_id);
                     }

-                    if let near_indexer::near_primitives::views::ReceiptEnumView::Action {
-                        actions,
-                        ..
+                    if let near_indexer_primitives::views::ReceiptEnumView::Action {
+                        actions, ..
                     } = execution_outcome.receipt.receipt
                     {
                         for action in actions.iter() {
-                            if let near_indexer::near_primitives::views::ActionView::FunctionCall {
+                            if let near_indexer_primitives::views::ActionView::FunctionCall {
                                 args,
                                 ..
                             } = action
                             {
                                 if let Ok(decoded_args) = base64::decode(args) {
-                                    if let Ok(args_json) = serde_json::from_slice::<serde_json::Value>(&decoded_args) {
+                                    if let Ok(args_json) =
+                                        serde_json::from_slice::<serde_json::Value>(&decoded_args)
+                                    {
                                         eprintln!("{:#?}", args_json);
                                     }
                                 }
@@ -156,8 +134,8 @@
 }

 fn is_tx_receiver_watched(
-    tx: &near_indexer::IndexerTransactionWithOutcome,
-    watching_list: &[near_indexer::near_primitives::types::AccountId],
+    tx: &near_indexer_primitives::IndexerTransactionWithOutcome,
+    watching_list: &[near_indexer_primitives::types::AccountId],
 ) -> bool {
     watching_list.contains(&tx.transaction.receiver_id)
 }
```

'''
'''--- docs/2.build/6.data-infrastructure/lake-framework/near-lake-state-changes-indexer.md ---
---
id: near-lake-state-changes-indexer
title: NEAR Lake Indexer Tutorial
---

:::note Source code for the tutorial

[`near-examples/near-lake-accounts-watcher`](https://github.com/near-examples/near-lake-accounts-watcher/tree/0.2.0): source code for a video tutorial on how to use the NEAR Lake Framework

:::

:::info Version 0.2.0

The video is based on the [`near-lake-framework`](/concepts/advanced/near-lake-framework) version 0.2.0

At the same time we're keeping the source code up to date with the latest version of the published crate.

:::

We've created a video tutorial to empower the release announcement of [NEAR Lake Framework](/concepts/advanced/near-lake-framework).

In this tutorial you will build an indexer application to watch for any `StateChange`s affecting the account or a list of account provided.

<iframe
 width="560"
 height="315"
 src="https://www.youtube.com/embed/GsF7I93K-EQ"
 title="YouTube video player"
 frameborder="0"
 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
 allowfullscreen>
</iframe>

'''
'''--- docs/2.build/6.data-infrastructure/lake-framework/near-lake.md ---
---
id: near-lake
sidebar_label: Lake Overview
title: NEAR Lake Indexer
---

NEAR Lake is an indexer built on top of [NEAR Indexer Framework](/concepts/advanced/near-indexer-framework) to watch the network and store all the [events](../../../4.tools/events.md) as JSON files on AWS S3.

:::info GitHub repo

You can find the Lake Indexer source code in [this GitHub repository](https://github.com/near/near-lake-indexer/).

:::

### How it works

:::tip

[Pagoda Inc.](https://pagoda.co) runs NEAR Lake nodes to store the data in JSON format on AWS S3.
There is no need to run your own NEAR Lake unless you have specific reasons to do that.

:::

There are AWS S3 buckets created:

- `near-lake-data-testnet` (`eu-central-1` region)
- `near-lake-data-mainnet` (`eu-central-1` region)

All the buckets are set up the way the requester pays for the access. Anyone can read from these buckets by connecting to them with their own AWS credentials to be charged by Amazon.

### Data structure

The data structure used by Lake Indexer is the following:

```
    <block_height>/
      block.json
      shard_0.json
      shard_1.json
      ...
      shard_N.json
```

`<block_height>` is a 12-character-long [`u64`](https://doc.rust-lang.org/std/primitive.u64.html) string with leading zeros (e.g "000042839521"). See [this issue for reasoning](https://github.com/near/near-lake/issues/23).

`block_json` contains JSON-serialized `BlockView` struct. **NB!** this struct might change in the future, we will announce it

`shard_N.json` where N is [`u64`](https://doc.rust-lang.org/std/primitive.u64.html) starting from `0`. Represents the index number of the shard. In order to find out the expected number of shards in the block you can look in `block.json` at `.header.chunks_included`

### How to use it

We have created the [NEAR Lake Framework](/concepts/advanced/near-lake-framework) to have a simple straightforward way to create an indexer on top of the data stored by NEAR Lake itself.

:::info NEAR Lake Framework

You can check the NEAR Lake Framework release announcement on the [NEAR Governance Forum](https://gov.near.org/t/announcement-near-lake-framework-brand-new-word-in-indexer-building-approach/17668).

:::

We have prepared this video tutorial with a simple example to give you an overview and some practical ideas.

<iframe
 width="560"
 height="315"
 src="https://www.youtube.com/embed/GsF7I93K-EQ"
 title="NEAR Lake Indexer"
 frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
 allowfullscreen>
</iframe>

'''
'''--- docs/2.build/6.data-infrastructure/lake-framework/running-near-lake/credentials.md ---
---
sidebar_label: "Credentials"
---

# Credentials

:::info DevConsole

Please, keep in mind, currently using the AWS Credentials is the only way to access the data provided by [NEAR Lake](/tools/realtime#near-lake-indexer) ecosystem. But it is about to change with Pagoda DevConsole release. Stay tuned!

:::

To access the data provided by [NEAR Lake](/tools/realtime#near-lake-indexer) you need to provide valid AWS credentials in order to be charged by the AWS for the S3 usage.

### AWS S3 Credentials

To be able to get objects from the AWS S3 bucket you need to provide the AWS credentials.

AWS default profile configuration with aws configure looks similar to the following:

```
~/.aws/credentials
```

```
[default]
aws_access_key_id=AKIAIOSFODNN7EXAMPLE
aws_secret_access_key=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
```

[AWS docs: Configuration and credential file settings](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html)

#### Environment varibales

Alternatively, you can provide your AWS credentials via environment variables with constant names:

```
$ export AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE
$ AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
$ AWS_DEFAULT_REGION=eu-central-1
```

'''
'''--- docs/2.build/6.data-infrastructure/lake-framework/running-near-lake/lake-start-options.md ---
---
sidebar_label: "Start options"
---

# Extending Lake indexer with start options

## The End

This tutorial ends with the example code of the simple indexer built on top of [NEAR Lake Framework](/concepts/advanced/near-lake-framework) that can start:
- from specified block height (out of the box)
  ```bash
  ./target/release/indexer mainnet from-block 65359506
  ```
- from the latest final block from the network
  ```bash
  ./target/release/indexer mainnet from-latest
  ```
- from the block indexer has indexed the last before it was interrupted
  ```bash
  ./target/release/indexer mainnet from-interruption
  ```

## Motivation

To find out whether you need an indexer for you project and to create one means you're covering only one side of things - the development.

There is another important side - the maintenance. This involves:
- indexer needs to be upgraded with a newer version of dependencies
- indexer needs to be updates with a new features you've made
- your server needs some maintenance
- incident had happened
- etc.

Almost in all of the above cases you might want to start or restart your indexer not only from the specific block you need to provide, but from the block it was stopped, or from the latest final block in the network.

[NEAR Lake Framework](/concepts/advanced/near-lake-framework) doesn't provide such options. Actually, we didn't empower the library with these options to start indexer intentionally.

:::info Intent

We want to keep [NEAR Lake Framework](/concepts/advanced/near-lake-framework) crate in the narrowest possible way. The goal for the library is to do a single job and allow it to be empowered with any features but outside of the crate itself

:::

Though, the possibility to start indexer from the latest block or from the block after the one it has indexed the last, might be very useful.

Also, during [the April Data Platform Community Meeting](https://github.com/near/indexers-docs/blob/main/blog/2022-05-11-community-meeting-record.mdx) we had a question whether we plan to add this feature to the library. We've promised to create a tutorial showing how to do it by your own. So here it is.

## Preparation

In this tutorial we're not going to focus our attention on the indexer itself, but on the start options instead.

:::note

To simplify the code samples in the tutorial, we're writing entire application in a single file `src/main.rs`.

**Please, do not take it as a design advice. We do it only for the simplicity**

:::

Let's prepare a project with a base dependencies, so we can focus on the main goal of this tutorial.

Create a new Rust project

```bash
cargo new --bin indexer && cd indexer
```

Replace the content of the `Cargo.toml` file with this:

```toml title=Cargo.toml
[package]
name = "indexer"
version = "0.1.0"
edition = "2021"
rust-version = "1.60.0"

[dependencies]
clap = { version = "3.1.6", features = ["derive"] }
futures = "0.3.5"
itertools = "0.9.0"
tokio = { version = "1.1", features = ["sync", "time", "macros", "rt-multi-thread"] }
tokio-stream = { version = "0.1" }
tracing = "0.1.13"
tracing-subscriber = "0.2.4"
serde = { version = "1", features = ["derive"] }
serde_json = "1.0.55"

near-lake-framework = "0.3.0"

```

Replace the content of `src/main.rs` with this:

```rust
use clap::{Parser, Subcommand};
use futures::StreamExt;
use tracing_subscriber::EnvFilter;

// TODO: StartOptions

#[tokio::main]
async fn main() -> Result<(), tokio::io::Error> {
    init_tracing();

    let opts = Opts::parse();

    // TODO: Config

    let stream = near_lake_framework::streamer(config);

    let mut handlers = tokio_stream::wrappers::ReceiverStream::new(stream)
        .map(handle_streamer_message)
        .buffer_unordered(1usize);

    while let Some(_handle_message) = handlers.next().await {}

    Ok(())
}

async fn handle_streamer_message(
    streamer_message: near_lake_framework::near_indexer_primitives::StreamerMessage,
) {
    eprintln!(
        "{} / shards {}",
        streamer_message.block.header.height,
        streamer_message.shards.len()
    );
    std::fs::write("last_indexed_block", streamer_message.block.header.height.to_string().as_bytes()).unwrap();
}

fn init_tracing() {
    let mut env_filter = EnvFilter::new("near_lake_framework=info");

    if let Ok(rust_log) = std::env::var("RUST_LOG") {
        if !rust_log.is_empty() {
            for directive in rust_log.split(',').filter_map(|s| match s.parse() {
                Ok(directive) => Some(directive),
                Err(err) => {
                    eprintln!("Ignoring directive `{}`: {}", s, err);
                    None
                }
            }) {
                env_filter = env_filter.add_directive(directive);
            }
        }
    }

    tracing_subscriber::fmt::Subscriber::builder()
        .with_env_filter(env_filter)
        .with_writer(std::io::stderr)
        .init();
}
```

This code is not going to build yet. Meanwhile let's have a quick look of what we've copy/pasted for now:

- We have imported [`clap`](https://docs.rs/clap/latest/clap/) to set up what command line arguments we're going to accept
- Also, we've important necessary stuff like `futures` and `tracing_subscriber`
- `init_tracing` in the end of the file is a helper function that subscribes our application to the logs from `near-lake-framework`
- An asynchronous `main` function with the indexer boilerplate code, but missing the `LakeConfig` creation part we're going to cover in the tutorial.
- You can find a few `// TODO: ...` sections we've marked for you to find places to write the code from this tutorial.

OK, all the preparations are done. Let's move on.

## Design the `StartOptions`

So we want to be able to pass a command that defines the way our indexer should start. In this tutorial we'll be using `clap`.

We need a structure that receives the chain id. This will allow us to use command:

```bash
./target/release/indexer mainnet ...
```

OR

```bash
./target/release/indexer testnet ...
```

Let's replace the `// TODO: StartOptions` in the `src/main.rs` with:

```rust title=src/main.rs
#[derive(Parser, Debug, Clone)]
#[clap(version = "0.1", author = "Near Inc. <hello@nearprotocol.com>")]
struct Opts {
    #[clap(subcommand)]
    pub chain_id: ChainId,
}

#[derive(Subcommand, Debug, Clone)]
enum ChainId {
    #[clap(subcommand)]
    Mainnet(StartOptions),
    #[clap(subcommand)]
    Testnet(StartOptions),
}

```

Now we want to create a `StartOptions` structure that will allow us to tell our indexer where to start indexing from. The command should look like:

```bash
./target/release mainnet from-latest
```

Our variants are:

- `from-block N`, where `N` is the block height to start from
- `from-latest` to start from latest final block in the network
- `from-interruption` to start from the block indexer was previously interrupted

Let's replace the comment `// TODO: StartOptions` with the enum:

```rust title=src/main.rs
#[derive(Subcommand, Debug, Clone)]
pub(crate) enum StartOptions {
    FromBlock { height: u64 },
    FromLatest,
    FromInterruption,
}
```

Pretty simple and straightforward, agree?

## Creating a `LakeConfig`

In order to create `LakeConfig` we're going to use a config builder [`LakeConfigBuilder`](https://docs.rs/near-lake-framework/0.3.0/near_lake_framework/struct.LakeConfigBuilder.html). Fotunately, we've imported it already.

Let's instantiate a builder in place of `// TODO: Config` comment:

```rust title=src/main.src
    let mut lake_config_builder = near_lake_framework::LakeConfigBuilder::default();
```

Notice that `lake_config_builder` is defined as mutable.

Now we need to set the chain we are going to index by matching `ChainId` provided:

```rust title=src/main.src
    let mut lake_config_builder = near_lake_framework::LakeConfigBuilder::default();

    match &opts.chain_id {
        ChainId::Mainnet(start_options) => {
            lake_config_builder = lake_config_builder
                .mainnet();
        }
        ChainId::Testnet(start_options) => {
            lake_config_builder = lake_config_builder
                .testnet();
        }
    }
```

As you can see, depending on the variant of the `ChainId` enum we modify the `lake_config_builder` with one of the shortcuts `mainnet()` or `testnet()`.

The only parameter left to set is the most important for us in this tutorial `start_block_height`

Normally, we just pass the block height number `u64` but we're implementing the start options here.

## Start options logic

Let's create a separate function that will hold the logic of identification the `start_block_height` and call it `get_start_block_height`.

**Just read the code, don't copy, it's not final approach yet**

### `FromBlock { height: u64 }`

Let's start from implementation `from-block N` as the simplest one:

```rust title=src/main.rs
async fn get_start_block_height(start_options: &StartOptions) -> u64 {
    match start_options {
        StartOptions::FromBlock { height } => height,

    }
}
```

OK, it's simple enough, what's about other match arms for `StartOptions`:

```rust title=src/main.rs
async fn get_start_block_height(start_options: &StartOptions) -> u64 {
    match start_options {
        StartOptions::FromBlock { height } => height,
        StartOptions::FromLatest =>
    }
}
```

Er, how should we get the latest block from the network? We should query the JSON RPC and get the final block, extract its height and call it a day.

### `FromLatest`

In order to query the JSON RPC from within Rust code we need to use [`near-jsonrpc-client-rs` crate](https://github.com/near/near-jsonrpc-client-rs)

You can find a [bunch of useful examples](https://github.com/near/near-jsonrpc-client-rs/tree/master/examples) in the corresponding folder of the project's repository on GitHub.

Add it to `Cargo.toml` in the end:

```toml title=Cargo.toml
near-jsonrpc-client = "0.3.0"
```

The code for getting the final block height would look like the following:

```rust
use near_jsonrpc_client::{methods, JsonRpcClient};
use near_lake_framework::near_indexer_primitives::types::{BlockReference, Finality};

async fn final_block_height() -> u64 {
    let client = JsonRpcClient::connect("https://rpc.mainnet.near.org");
    let request = methods::block::RpcBlockRequest {
        block_reference: BlockReference::Finality(Finality::Final),
    };

    let latest_block = client.call(request).await.unwrap();

    latest_block.header.height
}
```

Nice and easy. Though, a hardcoded value of `"https://rpc.mainnet.near.org"` looks not so great. Especially when we want to support both networks.

But we can handle it by passing the JSON RPC URL to the `get_start_block_function` like this:

```rust title=src/main.rs

async fn get_start_block_height(
    start_options: &StartOptions,
    rpc_url: &str,
) -> u64 {
    ...
}

    ...
    match &opts.chain_id {
        ChainId::Mainnet(start_options) => {
            lake_config_builder = lake_config_builder
                .mainnet()
                .start_block_height(
                    get_start_block_height(
                        start_options,
                        "https://rpc.mainnet.near.org",
                    ).await
                );
        }
        ChainId::Testnet(start_options) => {
            lake_config_builder = lake_config_builder
                .testnet()
                .start_block_height(
                    get_start_block_height(
                        start_options,
                        "https://rpc.testnet.near.org",
                    ).await
                )
        }
    }

```

Meh. It's ugly and why should we pass it everytime if it is required in only one case from three possible?

Instead we can pass to the `get_start_block_height` function the entire `Opts`.

```rust title=src/main.rs
async fn get_start_block_height(opts: &Opts) -> u64 {
    match opts.chain_id {
        ChainId::Mainnet(start_options) => {
            match start_options {
                StartOptions::FromBlock { height } => height,
                StartOptions::FromLatest =>
            }
        }
    }
}
```

At least we have everything we need. Though, it still looks ugly and will definitely involve code duplication.

What we propose instead to is create `impl Opts` with a few useful methods to get JSON RPC URL and to get `StartOptions` instance.

**Now you may proceed copying the code safely**

Somewhere under the `StartOptions` definition add the following:

```rust title=src/main.rs
impl Opts {
    pub fn rpc_url(&self) -> &str {
        match self.chain_id {
            ChainId::Mainnet(_) => "https://rpc.mainnet.near.org",
            ChainId::Testnet(_) => "https://rpc.testnet.near.org",
        }
    }

    pub fn start_options(&self) -> &StartOptions {
        match &self.chain_id {
            ChainId::Mainnet(args) | ChainId::Testnet(args) => args
        }
    }
}
```

And now we can create our `get_start_block_height` function with the helper function that will query the final block `final_block_height` (we're going to reuse it, watch for the hands):

```rust title=src/main.rs
async fn get_start_block_height(opts: &Opts) -> u64 {
    match opts.start_options() {
        StartOptions::FromBlock { height } => *height,
        StartOptions::FromLatest => final_block_height(opts.rpc_url()).await,
        // a placeholder
        StartOptions::FromInterruption => 0,
    }
}

async fn final_block_height(rpc_url: &str) -> u64 {
    let client = JsonRpcClient::connect(rpc_url);
    let request = methods::block::RpcBlockRequest {
        block_reference: BlockReference::Finality(Finality::Final),
    };

    let latest_block = client.call(request).await.unwrap();

    latest_block.header.height
}
```

You may have noticed the `FromInterruption` and a comment about the placeholder. The reason we've made is to be able to build the application right now to test out that `FromLatest` works as expected.

### Testing `FromLatest`

:::danger Credentials

Please, ensure you've the credentials set up as described on the [Credentials](credentials.md) page. Otherwise you won't be able to get the code working.

:::

Let's try to build and run our code

```bash
cargo build --release

./target/release/indexer mainnet from-latest
```

Once the code is built you should see something like that in your terminal:

```
65364116 / shards 4
65364117 / shards 4
65364118 / shards 4
65364119 / shards 4
65364120 / shards 4
```

You can stop it by pressing `CTRL+C`

And now we can move on to `FromInterruption`

### `FromInterruption`

In order to let an indexer know at what block it was interrupted, the indexer needs to store the block height somewhere. And it should do it in the and of the `handle_message` function.

In the boilerplate code you've copy/pasted in the beginning of this tutorial you can notice a line of code:

```rust
    std::fs::write("last_indexed_block", streamer_message.block.header.height.to_string().as_bytes()).unwrap();
```

It saves the last indexed block height into a file `last_indexed_block` right near the indexer binary.

In the real world indexer you'd probably go with some other storage, depending on the toolset you're using.

But to show you the concept, we've decided to go with the easiest approach by saving it to the file.

Now we need to implement the reading the value from the file.

:::note

If it is a first start of your indexer and you ask it to start from interruption it wouldn't be able to find `last_indexed_block` and would just fail.

It's not the behavior we expect. That's why we assume you want it to start from interruption (if possible) or from the latest.

:::

Let's finish up our `get_start_block_height`

```rust title=src/main.rs
async fn get_start_block_height(opts: &Opts) -> u64 {
    match opts.start_options() {
        StartOptions::FromBlock { height } => *height,
        StartOptions::FromLatest => final_block_height(opts.rpc_url()).await,
        // a placeholder
        StartOptions::FromInterruption => {
            match &std::fs::read("last_indexed_block") {
                Ok(contents) => {
                    String::from_utf8_lossy(contents).parse().unwrap()
                }
                Err(e) => {
                    eprintln!("Cannot read last_indexed_block.\n{}\nStart indexer from latest final", e);
                    latest_block_height(opts.rpc_url()).await
                }
            }
        },
    }
}
```

What we are doing here:

- Trying to read the file `last_indexed_block`
- If the `Result` is `Ok`, we are reading the `contents` and parsing it
- If the `Result` is `Err` we print a message about the error and call `last_block_height` to get the final block from the network (the fallback we were talking earlier)

### Testing `FromInterruption`

In order to ensure everything works as expected we will start index from the genesis to store the last indexed block. And then we will start it from interruption to ensure we're not starting from latest.

Let's build and run from genesis.

:::info Genesis Trick

To start NEAR Lake Framework based indexer from the genesis block, you need to just specify the `start_block_height` as `0`.

:::

```bash
cargo build --release
./target/release/indexer mainnet from-block 0
```

You will see something like:

```
9820210 / shards 1
9820214 / shards 1
9820216 / shards 1
9820219 / shards 1
9820221 / shards 1
9820226 / shards 1
9820228 / shards 1
9820230 / shards 1
9820231 / shards 1
9820232 / shards 1
9820233 / shards 1
9820235 / shards 1
9820236 / shards 1
9820237 / shards 1
9820238 / shards 1
```

Stop it by pressing `CTRL+C`

Memorize the last block height you see. In our example it is `9820238`

Restart the indexer from interruption

```bash
./target/release/indexer mainnet from-interruption
```

You should see the indexer logs beginning from the block you've memorized.

Perfect! It's all done. Now you can adjust the code you got in the result to your needs and use it in your indexers.

## Summary

You've seen the way how you can empower your indexer with the starting options. As you can see there is nothing complex here.

You can find the source code in the [`near-examples/lake-indexer-start-options`](https://github.com/near-examples/lake-indexer-start-options)

'''
'''--- docs/2.build/6.data-infrastructure/lake-framework/running-near-lake/run-near-lake.md ---
---
id: run-lake-indexer
sidebar_label: Running Lake Indexer
---

# Running NEAR Lake Indexer

:::info

NEAR Lake is a blockchain indexer built on top of [NEAR Indexer microframework](https://github.com/nearprotocol/nearcore/tree/master/chain/indexer)
to watch the network and store all the events as JSON files on AWS S3.

:::

## How to start

The Lake Indexer setup consists of the following components:

- AWS S3 Bucket as a storage
- NEAR Lake binary that operates as a regular NEAR Protocol peer-to-peer node, so you will operate it as
  any other [Regular/RPC Node in NEAR](https://near-nodes.io/rpc/hardware-rpc)

### Prepare Development Environment

Before you proceed, make sure you have the following software installed:

- [Rust compiler](https://rustup.rs/) of the version that is mentioned in `rust-toolchain` file in the root of
  [nearcore](https://github.com/nearprotocol/nearcore) project.
- Ensure you have [AWS Credentials configured](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html)
  From AWS Docs:

  > For example, the files generated by the AWS CLI for a default profile configured with aws configure looks similar to the following.
  >
  > ~/.aws/credentials
  >
  > ```
  > [default]
  > aws_access_key_id=AKIAIOSFODNN7EXAMPLE
  > aws_secret_access_key=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
  > ```

### Compile NEAR Lake

```bash
$ cargo build --release
```

### Configure NEAR Lake

To connect NEAR Lake to the specific chain you need to have necessary configs, you can generate it as follows:

```bash
$ ./target/release/near-lake --home ~/.near/testnet init --chain-id testnet --download-config --download-genesis
```

The above code will download the official genesis config and generate necessary configs. You can replace `testnet` in the command above to different network ID (`betanet`, `mainnet`).

:::info nearcore configuration

According to changes in `nearcore` config generation we don't fill all the necessary fields in the config file.
While [this issue is open](https://github.com/nearprotocol/nearcore/issues/3156) you need to download config you want and replace the generated one manually.

- [testnet config.json](https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore-deploy/testnet/config.json)
- [betanet config.json](https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore-deploy/betanet/config.json)
- [mainnet config.json](https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore-deploy/mainnet/config.json)

:::

Configs for the specified network are in the `--home` provided folder. We need to ensure that NEAR Lake follows
all the necessary shards, so `"tracked_shards"` parameters in `~/.near/testnet/config.json` needs to be configured properly.
Currently, `nearcore` treats empty value for `"tracked_shards"` as "do not track any shard" and **any value** as "track all shards".
For example, in order to track all shards, you just add the shard #0 to the list:

```
...
"tracked_shards": [0],
...
```

### Run NEAR Lake

Commands to run NEAR Lake, after `./target/release/near-lake`

| Command | Key/Subcommand                | Required/Default                                                       | Responsible for                                                                                                                                                                                                                                                                                                                                                               |
| ------- | ----------------------------- | ---------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|         | `--home`                      | Default <br />`~/.near`                                                | Tells the node where too look for necessary files: <br />`config.json`<br />, <br />`genesis.json`<br />, <br />`node_key.json`<br />, and <br />`data`<br /> folder                                                                                                                                                                                                          |
| `init`  |                               |                                                                        | Tells the node to generate config files in `--home-dir`                                                                                                                                                                                                                                                                                                                       |
|         | `--chain-id`                  | Required<br /><br /> _ `localnet`<br /> _ `testnet`<br /> \* `mainnet` | Defines the chain to generate config files for                                                                                                                                                                                                                                                                                                                                |
|         | `--download-config`           | Optional                                                               | If provided tells the node to download `config.json` from the public URL. You can download them manually<br /><br /> - [testnet config.json](https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore-deploy/testnet/config.json)<br /> - [mainnet config.json](https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore-deploy/mainnet/config.json)      |
|         | `--download-genesis`          | Optional                                                               | If provided tells the node to download `genesis.json` from the public URL. You can download them manually<br /><br /> - [testnet genesis.json](https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore-deploy/testnet/genesis.json)<br /> - [mainnet genesis.json](https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore-deploy/mainnet/genesis.json) |
|         | TODO:<br />Other `neard` keys |                                                                        |                                                                                                                                                                                                                                                                                                                                                                               |
| `run`   |                               |                                                                        | Runs the node                                                                                                                                                                                                                                                                                                                                                                 |
|         | `--bucket`                    | Required                                                               | AWS S3 Bucket name                                                                                                                                                                                                                                                                                                                                                            |
|         | `--region`                    | Required                                                               | AWS S3 Bucket region                                                                                                                                                                                                                                                                                                                                                          |
|         | `--fallback-region`           | Default eu-central-1                                                   | AWS S3 Fallback region                                                                                                                                                                                                                                                                                                                                                        |
|         | `--endpoint`                  | Optional                                                               | AWS S3 compatible API endpoint                                                                                                                                                                                                                                                                                                                                                |
|         | `--stream-while-syncing`      | Optional                                                               | If provided Indexer streams blocks while they appear on the node instead of waiting the node to be fully synced                                                                                                                                                                                                                                                               |
|         | `--concurrency`               | Default 1                                                              | Defines the concurrency for the process of saving block data to AWS S3                                                                                                                                                                                                                                                                                                        |
|         | `sync-from-latest`            | One of the `sync-` subcommands is required                             | Tells the node to start indexing from the latest block in the network                                                                                                                                                                                                                                                                                                         |
|         | `sync-from-interruption`      | One of the `sync-` subcommands is required                             | Tells the node to start indexing from the block the node was interrupted on (if it is a first start it will fallback to `sync-from-latest`)                                                                                                                                                                                                                                   |
|         | `sync-from-block --height N`  | One of the <br />`sync-`<br /> subcommands is required                 | Tells the node to start indexing from the specified block height `N` (**Ensure** you node data has the block you want to start from)                                                                                                                                                                                                                                          |

```bash
$ ./target/release/near-lake --home ~/.near/testnet run --stream-while-syncing --concurrency 50 sync-from-latest
```

After the network is synced, you should see logs of every block height currently received by NEAR Lake.

## Syncing

Whenever you run NEAR Lake for any network except localnet you'll need to sync with the network.
This is required because it's a natural behavior of `nearcore` node and NEAR Lake is a wrapper
for the regular `nearcore` node. In order to work and index the data your node must be synced
with the network. This process can take a while, so we suggest to download a fresh backup of
the `data` folder and put it in you `--home-dir` of your choice (by default it is `~/.near`)

:::tip
Running your NEAR Lake node on top of a backup data will reduce the time of syncing process
because your node will download only the data after the backup was cut and it takes reasonable amount time.
:::

All the backups can be downloaded from the public S3 bucket which contains latest daily snapshots:

You will need [AWS CLI](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-welcome.html) to be installed in order to download the backups.

### Mainnet

```
$ aws s3 --no-sign-request cp s3://near-protocol-public/backups/mainnet/rpc/latest .
$ LATEST=$(cat latest)
$ aws s3 --no-sign-request cp --no-sign-request --recursive s3://near-protocol-public/backups/mainnet/rpc/$LATEST ~/.near/data
```

### Testnet

```
$ aws s3 --no-sign-request cp s3://near-protocol-public/backups/testnet/rpc/latest .
$ LATEST=$(cat latest)
$ aws s3 --no-sign-request cp --no-sign-request --recursive s3://near-protocol-public/backups/testnet/rpc/$LATEST ~/.near/data
```

## Running NEAR Lake as an archival node

It's not necessary but in order to index everything in the network it is better to do it from the genesis.
`nearcore` node is running in non-archival mode by default. That means that the node keeps data only
for [5 last epochs](https://docs.near.org/concepts/basics/epoch). In order to index data from the genesis
you need to turn the node in archival mode.

To do it you need to update `config.json` located in `--home-dir` (by default it is `~/.near`).

Find next keys in the config and update them as following:

```json
{
  ...
  "archive": true,
  "tracked_shards": [0],
  ...
}
```

The syncing process in archival mode can take a lot of time, so it's better to download a backup provided by NEAR
and put it in your `data` folder. After that your node will download only the data after the backup was cut and it
takes reasonable amount time.

All the backups can be downloaded from the public [S3 bucket](https://near-nodes.io/intro/node-data-snapshots) which contains the latest daily snapshots.

See [this link](https://near-nodes.io/archival/run-archival-node-with-nearup) for reference

## Using the data

We write all the data to AWS S3 buckets:

- `near-lake-data-testnet` (`eu-central-1` region) for testnet
- `near-lake-data-mainnet` (`eu-central-1` region) for mainnet

## Custom S3 storage

In case you want to run you own `near-lake` instance and store data in some S3 compatible storage ([Minio](https://min.io/) or [Localstack](https://localstack.cloud/) as example)
You can override default S3 API endpoint by using `--endpoint` option

- run `minio`

```bash
$ mkdir -p /data/near-lake-custom && minio server /data
```

- run `near-lake`

```bash
$ ./target/release/near-lake --home ~/.near/testnet run --endpoint http://127.0.0.1:9000 --bucket near-lake-custom sync-from-latest
```

### Data structure

The data structure we use is the following:

```
<block_height>/
  block.json
  shard_0.json
  shard_1.json
  ...
  shard_N.json
```

- `<block_height>` is a 12-character-long `u64` string with leading zeros (e.g `000042839521`). [See this issue for a reasoning](https://github.com/near/near-lake/issues/23)
- `block_json` contains JSON-serialized [`BlockView`](https://github.com/near/nearcore/blob/e9a28c46c2bea505b817abf484e6015a61ea7d01/core/primitives/src/views.rs#L711-L716) struct. **Note:** this struct might change in the future, we will announce it
- `shard_N.json` where `N` is `u64` starting from `0`. Represents the index number of the shard. In order to find out the expected number of shards in the block you can look in `block.json` at `.header.chunks_included`

### Access the data

All NEAR Lake AWS S3 buckets have [Request Payer](https://docs.aws.amazon.com/AmazonS3/latest/userguide/RequesterPaysBuckets.html) enabled. It means that anyone with their own AWS credentials can List and Read the bucket's content and **be charged for it by AWS**. Connections to the bucket have to be done with AWS credentials provided. See [NEAR Lake Framework](https://github.com/near/near-lake-framework) for a reference.

### NEAR Lake Framework

Once we [set up the public access to the buckets](https://github.com/near/near-lake/issues/22) anyone will be able to build their own code to read it through.

For our own needs we are working on [NEAR Lake Framework](https://github.com/near/near-lake-framework) to have a simple way to create an indexer on top of the data stored by NEAR Lake itself.

:::note
See the official NEAR Lake Framework [announcement on the NEAR Gov Forum](https://gov.near.org/t/announcement-near-lake-framework-brand-new-word-in-indexer-building-approach/17668).
:::

'''
'''--- docs/2.build/6.data-infrastructure/query-api/best-practices.md ---
---
id: best-practices
title: Indexing best practices
sidebar_label: Best Practices
---

In this article you can find suggested best practices when building blockchain indexers using [QueryAPI](intro.md).
If you're planning to design a production-ready indexer, please check the recommendations for [indexing development](#indexing-development) and [database design](#database-design).

## Indexing development

This section presents a recommended workflow when building a new indexer using QueryAPI.

### Design APIs for your UIs

If your application requires front-end User Interfaces (UIs), your first step should be to define the APIs that will be used by your front-end UI. The main objective here is to reduce the overall number of requests that each page makes to render all content. Once you define these APIs, you will have a an good overview of the data that you need to index from the blockchain. 

### Create a Database

Once you have a better idea of the indexed data, you can design the database to store the indexing results.

When defining your SQL database schema, consider these recommendations:
  -  Design for `UPSERT`s, so that indexed data can be replaced if needed
  -  Use foreign keys between entities for GraphQL linking
  -  Think of indexes (e.g. by accounts, by dates, etc.)
  -  Use views to generate more GraphQL queries ‚Äì¬†when you `CREATE VIEW`, QueryAPI generates a separate GraphQL query for it.

:::tip
Check the [Database design section](#database-design) to learn how to design optimal database schemas for your indexer.
:::

### Find blocks to test on

Using exploring tools such as [NearBlocks](https://nearblocks.io/), you can find a few `block_height`s with transactions to your smart contracts that you need to index. These example blocks will help you to test and debug while writing your indexer code.

### Write JS code and debug

1. Start from a simple [`indexingLogic.js`](index-function.md) to get blockchain data dumped in a database, in a raw form. For example, start by getting the [FunctionCall](../../2.smart-contracts/anatomy/actions.md#function-call)'s arguments from the smart contract that you want to index. Then, use the [GraphQL playground](index-function.md#mutations-in-graphql) to understand the raw dump and further analyze the data.

   ![Playground](/docs/assets/QAPIScreen.gif)

:::tip

  -  Check the [NEAR Lake Primitives](https://near.github.io/near-lake-framework-js/) documentation
  -  Use [`context.db`](context.md#db) object to access your database tables
  -  Write logs

:::

2. Once you have figured out a good logic to process the raw data, test the processing logic by [enabling debug mode](index-function.md#local-debug-mode) in the `indexingLogic.js` editor, and set a list of block heights that contains different cases that your processing logic must handle.

   ![QueryAPI Dashboard](/docs/assets/QAPIdebug.png)

3. Once your index logic extracts all data correctly as expected, you might find that you need to create new tables or change your schema to better organize the data. In that case, fork the indexer, change the  SQL schema and update the indexer logic to process and store structured data.

4. If there were changes in smart contracts, e.g. changes in method and event definitions, you might need to implement conditional logic on the block height.

### Deploy code and check logs

Make sure to `try { } catch { }` exceptions while processing each block. In the `catch` section, log exceptional blocks and debug them by enabling debug mode. (set the block `height` of the problematic blocks, and run a local debug)

```js
try {
  console.log("Creating a Post Snapshot");
  const postData = {
    post_id: post_id,
    account_id: accountId,
    block_height: block_height,
  };
  await context.db.Posts.insert(postData);
  console.log(
    `Post Snapshot with post_id ${post_id} at block_height ${block_height} has been added to the database`
  );
  return null;
} catch (e) {
  console.log(
    `Error creating Post Snapshot with post_id ${post_id} at block_height ${block_height}: ${e}`
  );
  return e;
}
```

### Fix bugs and redeploy

You may have to do several iterations to fix all bugs in your indexer to process all the blocks correctly. Currently QueryAPI does not allow to clean the database and change the schema, so you will need to fork your indexer, update the schema or `indexingLogic`, and try again. The new indexer can be named `YourIndexName_v2`, `YourIndexerName_v3`, `..._v4`, and so on. If you don't do that, your new indexing logic will re-run on old blocks, and if you don‚Äôt handle re-indexing in your `indexingLogic.js`, the same old data will be inserted again into the database, bringing further errors.

:::tip

Remember to clean out old, unused indexers. If you get `YourIndexerName_v8` to work, delete `..._v7`, `..._v6`, so they can free resources taken from QueryAPI workers.

:::

### Generate GraphQL queries and export

When your indexer is deployed and ready, you can generate and export GraphQL queries that can be used in your front-end application, NEAR component, or any other integration.

To generate GraphQL queries:
  -  [Use GraphiQL playground](index-function.md#mutations-in-graphql)
  -  Click through and debug queries
  -  [Use code exporter to NEAR components](index-function.md#create-a-bos-component-from-query)
  -  Change `query` to `subscription` for WebSockets

## Database design

Designing an optimal database schema depends on the type of indexer that you want to build.
Focusing on the two most common blockchain indexing use cases, you can consider:

- a database schema for an indexer doing blockchain analytics, reporting, business intelligence, and big-data queries.
- a database schema for an indexer built as a backend for a web3 dApp building interactive and responsive UIs, that tracks interactions over a specific smart contract.

:::info

QueryAPI uses [PostgreSQL 14.9](https://www.postgresql.org/docs/14/index.html). You can find additional documentation about PostgresSQL data definition language [in this link](https://postgrespro.com/docs/postgresql/14/ddl).

:::

### Schema for Blockchain analytics

- Consider using summary tables for precomputed analytics. Example:

```sql
CREATE TABLE summary_account_transactions_per_day (
    dim_signer_account_id TEXT NOT NULL,
    dim_transaction_date DATE NOT NULL,
    metric_total_transactions BIGINT NOT NULL,
    PRIMARY KEY (dim_signer_account_id, dim_transaction_date)
);

INSERT INTO summary_account_transactions_per_day (dim_signer_account_id, dim_transaction_date, metric_total_transactions)
SELECT
    t.signer_account_id AS dim_signer_account_id,
    t.transaction_date AS dim_transaction_date,
    COUNT(*) AS metric_total_transactions
FROM
    transactions t
WHERE
    t.transaction_date = CURRENT_DATE
GROUP BY
    t.signer_account_id, t.transaction_date
ON CONFLICT (dim_signer_account_id, dim_transaction_date)
DO UPDATE SET
    metric_total_transactions = EXCLUDED.metric_total_transactions;
```

- If you want to do a SQL `JOIN` query, use a `VIEW`. For example:

```sql
CREATE VIEW
  posts_with_latest_snapshot AS
SELECT
  ps.post_id,
  p.parent_id,
  p.author_id,
  ps.block_height,
  ps.editor_id,
  ps.labels,
  ps.post_type,
  ps.description,
  ps.name,
  ps.sponsorship_token,
  ps.sponsorship_amount,
  ps.sponsorship_supervisor
FROM
  posts p
  INNER JOIN (
    SELECT
      post_id,
      MAX(block_height) AS max_block_height
    FROM
      post_snapshots
    GROUP BY
      post_id
  ) latest_snapshots ON p.id = latest_snapshots.post_id
  INNER JOIN post_snapshots ps ON latest_snapshots.post_id = ps.post_id
  AND latest_snapshots.max_block_height = ps.block_height;
```

### Schema for interactive UIs

#### Indexing

Add indexes for efficient querying. Example:

```sql
CREATE INDEX idx_transactions_signer_account_id ON transactions(signer_account_id);
```

#### Partitioning

Utilize partitioning for large tables.

```sql
CREATE TABLE transactions_partitioned_by_account_id (
    transaction_hash text NOT NULL,
    signer_account_id text NOT NULL,
    receipt_conversion_tokens_burnt numeric(45) NULL,
    PRIMARY KEY (signer_account_id, transaction_hash)
)
PARTITION BY LIST (signer_account_id);
```

'''
'''--- docs/2.build/6.data-infrastructure/query-api/context.md ---
---
id: context-object
title: QueryAPI Context object
sidebar_label: Context object
---

## Overview

The `context` object is a global object made available to developers building indexers with [QueryAPI](intro.md). It provides helper methods to interact with the resources spun up alongside the indexers, such as the GraphQL Endpoint and the database. There are also helper methods to allow specific API calls.

:::caution Under development

The formatting and changes in this document are still in progress. These changes are not fully featured yet but will be by the time they hit production. Specifically, [auto-complete](#auto-complete) and the `context.db.TableName.methodName` format. 

:::

## Main Methods

:::tip
All methods are asynchronous, hence why all examples have the `await` keyword in front of the function call. 
:::

### GraphQL

When an indexer is published, the SQL DDL written under the `schema.sql` tab is used to spin up a Postgres database. This DB is integrated with Hasura to provide a GraphQL endpoint. This endpoint can be used to interact with your database. 
Making calls to the Hasura GraphQL endpoint requires an API call, which is restricted in the environment. So, the GraphQL method allows calls to the endpoint related to the indexer. 

:::tip

The GraphQL method was previously the only way to interact with the database. Now, the [DB methods](#db) provide a more accessible functionality. The GraphQL method is better suited for more complex queries and mutations. Also, more information about GraphQL calls can be [found here](https://graphql.org/learn/queries/).

:::

#### Input

```js
await context.graphql(operation, variables) 
```

The operation is a string formatted to match a GraphQL query. The variables are any data objects used in the query.
 
#### Example

```js
const mutationData = {
  post: {
    account_id: accountId,
    block_height: blockHeight,
    block_timestamp: blockTimestamp,
    content: content,
    receipt_id: receiptId,
  },
};

// Call GraphQL mutation to insert a new post
await context.graphql(
  `mutation createPost($post: dataplatform_near_social_feed_posts_insert_input!){
    insert_dataplatform_near_social_feed_posts_one(
    object: $post
    ) {
      account_id
      block_height
    }
  }`,
  mutationData
);
```

The above is a snippet from the social feed indexer. In this example, you have a mutation (which mutates or changes data in the database, instead of a query that merely reads) called `createPost`. The mutation name can be anything. You specify a variable `post` and execute a graphQL method, which inserts the `post` object and returns `account_id` and `block_height` from the newly inserted object. Finally, you pass in `mutationData` as the variable, which is automatically linked to `post` since it's the only field.

:::tip

You can find other examples of `context.graphql` in the [social_feed indexers](../../../3.tutorials/near-components/indexer-tutorials/feed-indexer.md). 

:::

### Set

Each indexer, by default, has a table called `indexer_storage`. It has a field for `key` and `value`, functioning like a key-value store. This table can, of course, be removed from the DDL before publishing. However, it kept the `set` method as an easy way to set some value for a key in that table. This method is used in the default code to set the `height` on each invocation. 

#### Input

```js
await context.set(key, value)
```

#### Example

```js
const h = block.header().height;
await context.set("height", h);
```

### Log

Your indexing code is executed on a cloud compute instance. Therefore, things like `console.log` are surfaced to the machine itself. To surface `console.log` statements not only to the machine but also back to you under _Indexer Status_, QueryAPI needs to write these logs to the logging table, which is separate from the developer's schema. This [happens in the runner](how-works.md), and QueryAPI maps `console.log` statements in the developer's code to call this function instead, so you can simply use `console.log`, and QueryAPI takes care of the rest.

## DB

The DB object is a sub-object under `context`. It is accessed through `context.db`. Previously, the GraphQL method was the only way to interact with the database. However, writing GraphQL queries and mutations is pretty complicated and overkill for simple interactions. So, simpler interactions are instead made available through the `db` sub-object. This object is built by reading your schema, parsing its information, and generating methods for each table. See below for what methods are generated for each table. The format to access the below methods is as follows: `context.db.[tableName].[methodName]`. Concrete examples are also given below. 

:::info Note

One thing to note is that the process where the code is read is not fully featured.
If an `ALTER TABLE ALTER COLUMN` statement is used in the SQL schema, for example, it will fail to parse.
Should this failure occur, the context object will still be generated but `db` methods will be unavailable. An error will appear on the page saying `types could not be generated`. A more detailed error can be viewed in the browser's console. 

:::

### DB Methods

These DB methods are generated when the schema is read. The tables in the schema are parsed, and methods are set under each table name. This makes using the object more intuitive and declarative. 

If the schema is invalid for generating types, then an error will pop up both on screen and in the console. Here's an example:

![auto complete](/docs/queryapi/autocomp-error.png)

### Methods

:::note

Except for [upsert](#upsert), all of the below methods are used in [social_feed_test indexer](https://near.org/dev-queryapi.dataplatform.near/widget/QueryApi.App?selectedIndexerPath=darunrs.near/social_feed_test). However, keep in mind the current code uses the outdated call structure. An upcoming change will switch to the new method of `context.db.TableName.methodName` instead of `context.db.methodName_tableName`.

:::

### Insert

This method allows inserting one or more objects into the table preceding the function call. The inserted objects are then returned back with all of their information. Later on, we may implement returning specific fields but for now, we are returning them all. This goes for all methods. 

#### Input

```js
await context.db.TableName.insert(objects)
```

Objects can be a single object or an array of them. 

#### Example

```js
const insertPostData = {
  account_id: accountId,
  block_height: blockHeight,
  block_timestamp: blockTimestamp,
  content: content,
  receipt_id: receiptId
};
// Insert new post to Posts table
await context.db.Posts.insert(insertPostData);
```

In this example, you insert a single object. But, if you want to insert multiple objects, then you just pass in an array with multiple objects. Such as `[ insertPostDataA, insertPostDataB ]`. 

### Select

This method returns rows that match the criteria included in the call. For now, QueryAPI only supports explicit matches. For example, providing `{ colA: valueA, colB: valueB }` means that rows where `colA` and `colB` match those **EXACT** values will be returned.

There is also a `limit` parameter which specifies the maximum amount of objects to get. There are no guarantees on ordering. If there are 10 and the limit is 5, any of them might be returned. 

#### Input

```js
await context.db.TableName.select(fieldsToMatch, limit = null)
```

The `fieldsToMatch` is an object that contains `column names: value`, where the value will need to be an exact match for that column. The `limit` parameter defaults to `null`, which means no limit. If a value is provided, it overrides the `null` value and is set to whatever was passed in. All matching rows up to the limit are returned. 

#### Example

```js
const posts = await context.db.Posts.select(
  {
    account_id: postAuthor,
    block_height: postBlockHeight
  },
  1
);
```

In this example, any rows in the `posts` table where the `account_id` column value matches `postAuthor` **AND** `block_height` matches `postBlockheight` will be returned. 

### Update

This method updates all rows that match the `whereObj` values by setting the `updateObj` values. It then returns all impacted rows. The `whereObj` is subject to the same restrictions as the select‚Äôs `whereObj`. 

#### Input

```js
await context.db.TableName.update(whereObj, updateObj)
```

#### Example

```js
await context.db.Posts.update(
  {id: post.id}, 
  {last_comment_timestamp: currentTimestamp});
```

In this example, any rows in the `posts` table where the `id` column matches the value `post.id` will have their `last_comment_timestamp` column value overwritten to the value of `currentTimestamp`. All impacted rows are then returned.

### Upsert

Upsert is a combination of insert and update. First, the insert operation is performed. However, if the object already exists, the update portion is called instead. As a result, the input to the function are objects to be inserted, a `conflictColumns` object, which specifies which column values must conflict for the update operation to occur, and an `updateColumns` which specifies which columns have their values overwritten by the incoming object‚Äôs values. The `conflictColumns` and `updateColumns` parameters are both arrays. As usual, all impacted rows are returned. 

#### Input

```js
await context.db.upsert(objects, conflictColumns, updateColumns)
```

The Objects parameter is either one or an array of objects. The other two parameters are arrays of strings. The strings should correspond to column names for that table. 

#### Example

```js
const insertPostDataA = {
  id: postId
  account_id: accountIdA,
  block_height: blockHeightA,
  block_timestamp: blockTimeStampA
};

const insertPostDataB = {
  id: postId
  account_id: accountIdB,
  block_height: blockHeightB,
  block_timestamp: blockTimeStampB
};
// Insert new post to Posts table
await context.db.Posts.upsert(
  [ insertPostDataA, insertPostDataB ], 
  [‚Äòaccount_id‚Äô, ‚Äòid‚Äô], 
  [‚Äòblock_height‚Äô, ‚Äòblock_timestamp‚Äô);
```

In this example, two objects are being inserted. However, if a row already exists in the table where the `account_id` and `id` are the same, then `block_height` and `block_timestamp` would be overwritten in those rows to the value in the object in the call which is conflicting. 

### Delete

This method deletes all objects in the row that match the object passed in. Caution should be taken when using this method. It currently only supports **AND** and exact match, just like in the [select method](#select). That doubles as a safety measure against accidentally deleting a bunch of data. All deleted rows are returned so you can always insert them back if you get back more rows than expected. (Or reindex your indexer if needed) 

#### Input

```js
await context.db.TableName.delete(whereObj)
```

As stated, only a single object is allowed. 

#### Example

```js
await context.db.delete_post_likes(
  { 
    account_id: likeAuthorAccountId, 
    post_id: postId
  }
);
```

In this example, any rows where `account_id` and `post_id` match the supplied value are deleted. All deleted rows are returned. 

### Auto Complete

:::tip
Autocomplete works while writing the schema and before publishing to the chain. In other words, you don't need to publish the indexer to get autocomplete.
:::

As mentioned, the [DB methods](#db-methods) are generated when the schema is read. 
In addition to that, TypeScript types are generated which represent the table itself. These types are set as the parameter types. This provides autocomplete and strong typing in the IDE. These restrictions are not enforced on the runner side and are instead mainly as a suggestion to help guide the developer to use the methods in a way that is deemed correct by QueryAPI.

:::info Types

You can also generate types manually. Clicking the `<>` button generates the types. It can be useful for debugging and iterative development while writing the schema.

![auto complete](/docs/queryapi/autocomp-types.png)

:::

#### Compatibility

By default, current indexers have a `context` object included as a parameter in the top-level `async function getBlock`. This prevents autocomplete, as the local `context` object shadows the global one, preventing access to it. Users need to manually remove the `context` parameter from their indexers to get the autocomplete feature. For example:

```js
async function getBlock(block: Block, context) {
```

should become

```js
async function getBlock(block: Block) {
```

#### Examples

Here are some screenshots that demonstrate autocomplete on methods, strong typing, and field names:

![auto complete](/docs/queryapi/autocomp1.jpg)

![auto complete](/docs/queryapi/autocomp2.jpg)

![auto complete](/docs/queryapi/autocomp3.jpg)

![auto complete](/docs/queryapi/autocomp4.jpg)

![auto complete](/docs/queryapi/autocomp5.jpg)

'''
'''--- docs/2.build/6.data-infrastructure/query-api/how-works.md ---
---
id: how-it-works
title: How QueryAPI works
sidebar_label: How it works
---

QueryApi is a streaming indexer implementation that executes custom indexing logic written by developers on the NEAR blockchain.
QueryApi allows hosted execution of complex queries (ones that can‚Äôt be answered by a [simple RPC](../../../5.api/rpc/introduction.md) or [Enhanced API](https://docs.pagoda.co/api) call), data hosting, and its exposure via GraphQL endpoints.

## Components involved 

The QueryApi implementation integrates many different components in a single and streamlined solution.
In a high-level overview, the main components are:

:::info Components
`NEAR Protocol` -> `NEAR Lake` -> `Coordinator` -> `Runner` -> `Database` -> `API`
:::

### Detailed overview

An in-depth, detailed overview of the QueryApi components:

[![QueryAPI](/docs/qapi-components.png)](/docs/qapi-components.png)

### Description

- **Protocol:** the underlying NEAR Layer-1 Blockchain, where data `Blocks` and `Chunks` are produced.
- **NEAR Lake:** an indexer which watches the Layer-1 network and stores all the events as JSON files on AWS S3. Changes are indexed as new `Blocks` arrive.
- **Coordinator:** the QueryApi coordinator indexer filters matching data `Blocks`, runs historical processing threads, and queues developer's JS code to be indexed with these matched blocks.
- **Runner:** executes the user's indexer code, which outputs the data to the database.
- **Database:** a Postgres database where the developer's indexer data is stored, using a logical DB per user, and a logical schema per indexer function.
- **API:** a Hasura server running on Google Cloud Platform exposes a GraphQL endpoint so users can access their data from anywhere.

## Historical backfill

When an indexer is created, two processes are triggered:

- real-time - starts from the block the indexer was registered (`block_X`), and will execute the indexer function on every matching block from there on.
- historical - starts from the configured `start_from_block` height, and will execute the indexer function for all matching blocks up until `block_X`.

The historical backfill process can be broken down in to two parts: _indexed_, and _unindexed_ blocks.

**Indexed** blocks come from the `near-delta-lake` bucket in S3. This bucket is populated via a DataBricks job which streams blocks from NEAR Lake, and for every account, stores the block heights that contain transactions made against them. This processed data allows QueryAPI to quickly fetch a list of block heights that match the contract ID defined on the Indexer, rather than filtering through all blocks.

NEAR Delta Lake is not updated in real time, so for the historical process to close the gap between it and the starting point of the real-time process, it must also manually process the remaining blocks. This is the **unindexed** portion of the backfill.

## Provisioning

In summary, QueryAPI provisioning consists of the following steps:

1. Create `database` in [Postgres](#postgres), named after account, if necessary
2. Add `database` to Hasura
3. Create `schema` in `database`
4. Run DDL in `schema`
5. Track all tables in `schema` in [Hasura](#hasura)
6. Track all foreign key relationships in `schema` in [Hasura](#hasura)
7. Add all permissions to all tables in `schema` for account

:::note
This is the workflow for the initial provisioning. Nothing happens for the remaining provisions, as QueryAPI checks if it has been provisioned, and then skips these steps.
:::

:::info
To check if an Indexer has been provisioned, QueryAPI checks if both the `database` and `schema` exist. This check is what prevents the app from attempting to provision an already provisioned indexer.
:::

### Low level details

There are two main pieces to provisioning: [Postgres](#postgres) and [Hasura](#hasura).

#### Postgres

The dynamic piece in this process is the user-provided `schema.sql` file, which uses Data Definition Language (DDL) to describe the structure of the user's database. The `schema` DDL will be executed within a new Postgres Schema named after the account + function name. For example, if you have an `account.near` and `my_function`, the schema's name will be `account_near_my_function`. Each schema exists within a separate virtual database for that account, named after the account, i.e. `account_near`.

#### Hasura

After creating the new schema, Hasura is configured to expose this schema via a GraphQL endpoint. First, the database is added as a data source to Hasura. By default, all tables are hidden, so to expose them they must be "tracked". 

Foreign keys in Postgres allow for nested queries via GraphQL, for example a `customer` table may have a foreign relationship to an `orders` table, this enables the user to query the orders from a customer within a single query. These are not enabled by default, so they must be "tracked" too.

Finally, necessary permissions are added to the tables. These permissions control which GraphQL operations will be exposed. For example, the `SELECT` permission allows all queries, and `DELETE` will expose all delete mutations. A role, named after the account, is used to group these permissions. Specifying the role in the GraphQL request applies these permissions to that request, preventing access to other users data.

## Who hosts QueryAPI

[Pagoda Inc.](https://pagoda.co) runs and manages all the infrastructure of QueryAPI, including NEAR Lake nodes to store the data in JSON format on AWS S3.

- NEAR Lake indexing is hosted on AWS S3 buckets.
- Coordinator and Runners are hosted on GCP.
- Hasura GraphQL API server is hosted on GCP.

:::caution Pricing
QueryAPI is currently free. Pagoda doesn't charge for storage of your indexer code and data as well as running the indexer, but usage pricing will be introduced once QueryApi is out of beta.
:::

'''
'''--- docs/2.build/6.data-infrastructure/query-api/index-function.md ---
---
id: index-functions
title: Indexing Functions
sidebar_label: Indexing Functions
---

:::info
QueryAPI is a fully managed service that allows you to create and manage indexers on-chain seamlessly.
:::

## Indexing

Let's review a [very simple indexer](https://near.org/dataplatform.near/widget/QueryApi.App?selectedIndexerPath=roshaan.near/demo-indexer), which will help you to understand
how the indexer's indexing logic works.

```js title=indexingLogic.js
import { Block } from "@near-lake/primitives";

/**
 * getBlock(block, context) applies your custom logic to a Block on Near and commits the data to a database.
 *
 * @param {block} Block - A Near Protocol Block
 * @param {context} - A set of helper methods to retrieve and commit state
 */
async function getBlock(block: Block, context) {
  const h = block.header().height;
  await context.set("height", h);
}
```

In the `getBlock()` function, you're given a block, which is a block on the Near blockchain, as
well as a `context` object, which gives you a set of helper methods to be able to commit
what you want to the database that QueryAPI has provisioned for you.

The code is going into the header of the `block`
and getting the block's `height`, and then is using the `context` object to set a key value store.

Next, if you check out the database schema:

```sql title=schema.sql
CREATE TABLE
  "indexer_storage" (
    "function_name" TEXT NOT NULL,
    "key_name" TEXT NOT NULL,
    "value" TEXT NOT NULL,
    PRIMARY KEY ("function_name", "key_name")
  )
```

It's a very simple schema where you can store the `function_name`, `key_name`, and `value`.

:::tip
That's all this indexer function is doing: it sets the `height` value equal to the current block's height.
:::

<!-- ![QueryAPI Indexer Dashboard](/docs/assets/QAPIScreen2.png) -->

## Local Debug Mode

While you're iterating on your indexer development, it's critical to have some type of debugging
functionality to be able to test with, and the _Debug Mode_ is very helpful for that.

![QueryAPI Dashboard](/docs/assets/QAPIdebug.png)

For example, if you want to test the [simple indexer](#indexing) explained in the previous section
using the local debugging mode:

- Enable <kbd>Debug Mode</kbd> on the **Indexer Editor**
- Add a block to your debug list (e.g., `97779559`)
- Go into your web browser's Console
- Finally, click <kbd>Play</kbd>.

On your browser's Console, you should see the indexer's debug execution where it sets the `height` key to `97779559`:

![QueryAPI Indexer Dashboard](/docs/assets/QAPIdebuglog.png)

:::info Local tests
All debug mode tests are happening **locally**, so they do not reach the database.
All your queries and mutations will return empty objects.
:::

:::tip
You can also click <kbd>Follow the Network</kbd> and it will show how your indexer logic works throughout.
:::

## Contract filters

A contract filter is used by QueryAPI to do backend optimizations to
help do historical indexing faster.
While creating an indexer, when you define a contract filter,
QueryAPI will send any single transaction event that passes this filter to your indexer function
so you can index it.

If you only want to index events from a single contract, simply define the contract name on the **Contract Filter** text box.
In some cases you might want to either support indexing on multiple contracts,
or simply support every single contract that exists on the Near blockchain.

#### Single contract filter

For example, if you check out the [simple indexer](https://near.org/dataplatform.near/widget/QueryApi.App?selectedIndexerPath=roshaan.near/demo-indexer), you'll see that in this case
you have a `social.near` contract filter.
In this example, the indexer is only concerned on indexing events from `social.near`'s contract.

#### Multiple contracts filter

For example, if you want to index all the contracts from AstroDAO, where there is an account created
for each and every different DAO, you should define `*.sputnik-dao.near` as the contract filter.
Likewise, if you want to get events from every contract on the blockchain, simply define `*` as the filter.

## Feed-indexer logic

Then we call context.graphql, which allows us to make arbitrary mutations and queries
to our database that we provision for you.
If you're interested in how to create GraphQL queries, there's a whole bunch of resources
online.
In this case, we are passing in our mutation data, which has a post object, and it's inserting
it inside Postgres, I mean, inside of Postgres using GraphQL.
But it's very easy to create these mutations.

## Mutations in GraphQL

If you go to the GraphiQL tab, you can access the GraphiQL Explorer that provides a user friendly GraphQL playground, where you can view and create queries and mutations based on the DB schema that you defined for the indexer.

![QueryAPI Indexer Dashboard](/docs/assets/QAPIgraphiql.png)

You can easily set some fields and select the returning data
that you want, and the tool will build a query on the mutation panel on the right.
Then you can copy the resulting query, either in your JavaScript code so that you pass actual
data manually, or you pass in the mutation data object as a second parameter.

For example, if you go and add a new mutation, click <kbd>+</kbd>, then you can do a bunch of actions here, such as creating, deleting, or inserting posts into your table.

![Playground](/docs/assets/QAPIScreen.gif)

If you want to test your mutation, using [Debug Mode](#local-debug-mode) you can add a specific
block to the list, and then play it to see how it works. 
Based on the indexer logic you defined, you'll get a call to the GraphQL mutation with the object
and data passed into it.

:::tip Video Walkthrough

**Tip:** watch the video on how to [create mutations in GraphQL](https://www.youtube.com/watch?v=VwO6spk8D58&t=781s).

:::

## Create a NEAR component from query

Creating a NEAR component from a GraphQL query is simple when using the GraphQL Playground. Just follow these steps:

- go to the GraphiQL tab
- select the query that you want to use
- click on the <kbd>Show GraphiQL Code Exporter</kbd> button
- get some default code here, copy it,
- go to the NEAR sandbox, paste it.

This will set up some boilerplate code to execute the GraphQL query, add the query that you had
in your playground and then call that query, extract the data and render it using the
render data function.

Once you have the NEAR component code, you can test it out by going to [the sandbox](https://near.org/sandbox),
pasting the generated code, and then selecting <kbd>Component Preview</kbd>.
Next, you can create a nice UI over this boilerplate code, and publish your new NEAR component.

'''
'''--- docs/2.build/6.data-infrastructure/query-api/indexers.md ---
---
id: indexers
title: QueryAPI Indexing Example
sidebar_label: Getting Started
---

With QueryAPI you can quickly create your own indexer by:

* Writing your own custom indexer function;
* Specifying the schema for your own custom hosted database and write to it with your indexer function;
* Retrieving that data through a GraphQL API.

:::tip

You can watch a complete video walkthrough of Query API [following this link](https://www.youtube.com/watch?v=VwO6spk8D58).

:::

:::info

NEAR QueryAPI is currently under development. Users who want to test-drive this solution need to be added to the allowlist before creating or forking QueryAPI indexers. 

You can request access through [this link](http://bit.ly/near-queryapi-beta).

:::

## How it Works

QueryAPI works by:

1. Writing the indexer name to the blockchain, registering its creation;
2. Creating the tables as specified in the schema to the GraphQL database, exposing a GraphQL endpoint to query the data;
3. Spinning up a cloud process that runs your indexer function, writing to the GraphQL database;

You can access the [NEAR QueryAPI by following this link](https://near.org/dataplatform.near/widget/QueryApi.App).

This should take you to a dashboard that looks like this:

![QueryAPI Dashboard](/docs/assets/QAPIScreen.png)

:::tip Video Walkthrough

**Tip:** Watch the [QueryAPI widget introduction](https://www.youtube.com/watch?v=VwO6spk8D58&t=109s).

:::

## Creating an Indexer

Clicking on "Create New Indexer" will redirect you in-browser to a Component code editor that looks like this:

![QueryAPI Indexer Dashboard](/docs/assets/QAPIScreen2.png)

This is the interface through which you can create a new Indexer. On here you can specify:

* the filtering, transforming logic in `indexingLogic.js`
* the database schema in `schema.sql`
* the GraphQL queries in `GraphiQL`
* the indexer name on Indexer Name
* from which block to start indexing

### Design Workflow

To design and create your indexer, you can follow this recommended workflow:

1. Using [nearblocks.io](https://nearblocks.io), find transactions to smart contracts that you want to index
2. Take the block `height` and put it into the [Debug Mode filter](../query-api/index-function.md#local-debug-mode), open your browser's _Developer Console_, and hit <kbd>Play</kbd>
4. Inspect the block and write JavaScript code using [NEAR Lake Primitives](../lake-framework/building-indexers/primitives.md) to extract data from a `block` object. (This JS code will be your [`IndexingLogic.js`](#indexinglogicjs))
   > **Tip:** Use `context.log` for debugging to ensure you are getting the right results
4. Add more blocks for debugging, or start following the blockchain to see how new blocks are handled
5. Create tables that you need to store the data using Postgres [CREATE table syntax](https://www.postgresql.org/docs/current/sql-createtable.html). (This SQL code will be your [`schema.sql`](#schemasql))

:::tip Video Walkthrough

**Tip:** Watch the [introduction to indexing functions](https://www.youtube.com/watch?v=VwO6spk8D58&t=411s).

:::

### `IndexingLogic.js`

The indexer code editor is pre-populated with a template that looks like this:

```js
import { Block } from "@near-lake/primitives";
/**
 * Note: We only support javascript at the moment. We will support Rust, Typescript in a further release.
 */

/**
 * getBlock(block, context) applies your custom logic to a Block on Near and commits the data to a database.
 *
 * Learn more about indexers here:  https://docs.near.org/concepts/advanced/indexers
 *
 * @param {block} Block - A Near Protocol Block
 * @param {context} - A set of helper methods to retrieve and commit state
 */
async function getBlock(block: Block, context) {
  // Add your code here
  const h = block.header().height;
  await context.set("height", h);
}
```

This editor with this code shows the `indexingLogic.js` file that is selected. This logic in particular will perform the filtering of blockchain transactions, transforming and saving the data you specify to a GraphQL database you define in `schema.sql`.

:::info Saving data

You will likely want to save the data you capture from your indexer to your defined tables in the GraphQL database. You can do this easily by using the [`context.db`](../query-api/context.md#db) object [`insert`](../query-api/context.md#insert) method.   For example, if you have a table called `transactions` with columns `id`, `sender`, `receiver`, `amount`, `block_height`, you can insert a mutation query for one new element in the table like this:

```js
const tx = {
    block_height: h,
    sender: "senderId",
    receiver: "receiverId",
    amount: 100,
};

await context.db.Transactions.insert(tx);
```

:::

:::info Using GraphQL mutations

You can also insert elements using GraphQL mutation queries in your `indexingLogic.js` file:

```js
await context.graphql(`
  mutation MyMutation($transaction: some_table_insert_input!) {
    insert_<ACCOUNT_NAME>_near_transactions_one(
      object: $transaction
    ) {
      affected_rows
    }
  }
`);
```

Creating GraphQL queries within strings can be difficult, especially considering that the table names vary depending on your indexer name and account ID. An easier way to do this would be by visiting the GraphQL Playground site and creating the queries there.

> **Tip:** watch the video on how to [create queries in Playground](https://www.youtube.com/watch?v=VwO6spk8D58&t=1207s).

:::

### `schema.sql`

This tab in the editor will be pre-populated with a template that looks like this:

```sql
CREATE TABLE "indexer_storage" (
  "function_name" TEXT NOT NULL,
  "key_name" TEXT NOT NULL,
  "value" TEXT NOT NULL,
  PRIMARY KEY ("function_name", "key_name")
);
```

This is the database schema that will be used to store the data you specify in `indexingLogic.js`. You can add more tables and columns to this schema as you see fit. They will be created as soon as you create the indexer.

Creating this default table will allow you to use the [`context.set`](../query-api/context.md#set) helper method to write data. It takes two arguments: a key argument that accepts a string and a value argument,  which will be written to the `key_name` and `value` columns.

:::caution Note on schema migration
You are able to update `indexingLogic.js` after you have registered/created your indexer, but you are only allowed to specify `schema.sql` once before you submit your indexer. If you want to update your schema, you will have to create a new indexer.
:::

### `GraphiQL`

The GraphiQL tab in the editor will allow you to view the returned data from your GraphQL endpoint. This is best verified after you have created the indexer.

:::tip Video Walkthrough

**Tip:** Watch how to [create mutations in GraphQL](https://www.youtube.com/watch?v=VwO6spk8D58&t=781s).

:::

### Publishing

Clicking the <kbd>Publish</kbd> button will open the following pop-up. From here, you can configure the Indexer name, start block, and contract filter.

![Publishing QueryAPI Indexer](/docs/assets/QAPIPublish.png)

#### Start Block Options
- `Start from latest block`: Start indexing from the tip of the network. The exact block height is not guaranteed. Useful for testing indexing for events happening in real-time.
- `Continue from last processed block`: Update the configuration of the Indexer, and resume indexing from the last processed block. The block at which the configuration is updated is not guaranteed. Useful for fixing bugs encountered on specific blocks, adding additional logs, etc.
- `Start from block height`: Start indexing from the height specified, i.e., when the contract was deployed, or when a specific event occurs.

:::info
`Continue from last processed block` is only available for existing indexers. Updating the contract filter is disabled for this option, as it will create a backlog of blocks for two different contracts. 
:::

:::warning
`Start from latest block` and `Start from block height` supersede the existing process. All queued blocks at the time of update will be cleared.
:::

## Performing Queries on the Public GraphQL API

In this section, we will provide a brief overview of how to query from a component in NEAR.

It is helpful to create a helper method which will allow us to fetch from our GraphQL API. Let's call it`fetchGraphQL`. It takes three parameters:

1. `queriesDoc`: A string containing the queries you would like to execute.
2. `queryName`: The specific query you want to run.
3. `variables`: Any variables to pass in that your query supports, such as `offset` and `limit` for pagination.

```javascript
function fetchGraphQL(queriesDoc, queryName, variables) {
  return asyncFetch(
    QUERY_API_ENDPOINT,
    {
      method: "POST",
      headers: { "x-hasura-role": `<your_account_name>_near` },
      body: JSON.stringify({
        queries: queriesDoc,
        variables: variables,
        operationName: queryName,
      }),
    }
  );
}
```

To use the `fetchGraphQL` function, first define a string of queries, e.g `transactionQueriesDoc` containing your desired queries:

```javascript
const transactionQueriesDoc = `query TransactionsQuery {
  root_near_transactions {
    id
    sender
    receiver
    amount
    block_height
  }
}
...
query AnotherQuery {
  root_near_accounts {
    id
  }
}`;
```

Next, call the `fetchGraphQL` function with the appropriate parameters and process the results. In this example, we fetch transaction data and update the application state:

```javascript
fetchGraphQL(transactionQueriesDoc, "TransactionsQuery", {})
  .then((result) => {
    if (result.status === 200) {
      let data = result.body.data;
      if (data) {
        const transactions = data.root_near_transactions;
        // Perform any necessary operations on the fetched data
        ...
        // Update state with the new transactions data
        State.update({
          transactions: transactions,
        });
      }
    }
  });
```

We have just shown how to fetch data from the indexers that we have created from within NEAR. To view a more complex example, see this widget which fetches posts with proper pagination: [Posts Widget powered By QueryAPI](https://near.org/dataplatform.near/widget/QueryApi.Examples.Feed.Posts).

:::tip Video Walkthrough

**Tip:** Watch an [end-to-end example](https://www.youtube.com/watch?v=VwO6spk8D58&t=943s).

:::

'''
'''--- docs/2.build/6.data-infrastructure/query-api/intro.md ---
---
id: intro
title: QueryAPI Overview
sidebar_label: Introduction
---

Near QueryAPI is a fully managed solution to build indexer functions,
extract on-chain data, store it in a database, and be able to query it using GraphQL endpoints.

## Indexing complexity

Blockchain Indexers are known to be challenging to create, maintain, and operate.
You have to focus on the business logic of your indexer, while you also have to
take care of everything else around it.
A dedicated team member could be needed to deal with all these challenges.

Common indexing challenges include:

#### Creation

- Design Database Schema and provision it with correct configurations for security, data retention, and performance. 
- Write and test indexer code that interacts with the database 
- Deploy Indexer to a Cloud provider. Ensure network permissions firewalls, PCs, or other network-related settings are setup correctly. 
- Create an API endpoint to retrieve data from your database for your fronted applications 

#### Maintenance

- Monitor the performance of your database and scale it as needed 
- Manage permissions and database access with changing requirements 

#### Operation

- Re-index data due to issues and updates. Ensuring that production environments don't get disrupted. 
- Perform database schema migrations
- Scale the API as your application grows 
- Keep up with all the underlying blockchain nodes and upgrades

## QueryAPI

As you can see, running indexers is a complex and comprehensive set of processes and
Near QueryAPI tries to cover most (or all) of these needs, offering an open-source solution for creating, managing, and exploring indexers.

### NEAR Component

QueryAPI has a [`QueryApi.App` NEAR widget](https://near.org/#/dataplatform.near/widget/QueryApi.App), hosted under the `dataplatform.near` account.
With this component, you can see all the public indexers currently available on the Near blockchain.

If you would like to create a new indexer, simply click [**Create New Indexer**](https://near.org/#/dataplatform.near/widget/QueryApi.App/?view=create-new-indexer).

![QueryAPI Dashboard](/docs/assets/QAPIScreen.png)

### Indexers stored on-chain

QueryAPI stores all the indexer logic and schemas used to provision the databases on-chain.
Whenever you interact with the QueryAPI NEAR component, in the background it's making an RPC query to [`queryapi.dataplatform.near`](https://stats.gallery/mainnet/queryapi.dataplatform.near/contract?t=week),
where a smart contract stores all of your indexer logic as well as your schemas.

For example, if you select the _feed-indexer_ and click on [**View indexer**](https://near.org/dataplatform.near/widget/QueryApi.App?selectedIndexerPath=dataplatform.near/feed-indexer) you'll see all the details about an indexer that powers the [near.org](https://near.org)'s main posts feed.
You're free to review the JavaScript code of the indexer function, or check the SQL that defines the database schema.

## Known limitations

- Currently under closed beta testing.
- Only supports JavaScript indexers. (we plan to support Rust in the future)
- It always takes the latest `@near-lake/primitives` library. 
- It doesn't support schema migrations.
  - If you have an indexer whose schema needs to change, you may need to create a new indexer and do a historical backfill on that new indexer again.
- There's no way to stop or restart your indexer, truncating all tables.
- Historical backfill works in parallel to the real-time indexing.
  - Historical processing won't happen in order. (it will happen at the same time as top of network)
  - Keep that in mind to ensure you don't have unintended side effects.

:::tip Join the Beta

If you want to join the closed beta, please [fill out this form](http://bit.ly/near-queryapi-beta) for access.

:::

:::info Pricing

Pagoda currently doesn't charge for storing your indexer code and data or running the indexer, but we will introduce this soon. 

:::

'''
'''--- docs/2.build/6.data-infrastructure/query-api/migrate.md ---
---
id: migrate-from-near-lake
title: Migrate from NEAR Lake framework
sidebar_label: Migrate from Lake framework
---

:::info

NEAR QueryAPI is currently under development. Users who want to test-drive this solution need to be added to the allowlist before creating or forking QueryAPI indexers. 

You can request access through [this link](http://bit.ly/near-queryapi-beta).

:::

In this article you'll learn how to migrate your [NEAR Lake Framework](../../../1.concepts/3.advanced/near-lake-framework.md) JavaScript indexer to [Near QueryAPI](intro.md), a fully managed solution to build indexer functions,
extract on-chain data, store it in a database, and be able to query it using GraphQL endpoints.

:::info Supported languages
Currently QueryAPI only supports JavaScript, so if your indexer code uses TypeScript, Python, or Rust, you'll have to re-write your indexing logic in JS before you can migrate it.
:::

## Basic migration
build/near-data-infrastructure/lake-framework/building-indexers/js-lake-indexer
Let's take a [basic JS indexer](../lake-framework/building-indexers/js-lake-indexer.md) built with NEAR Lake Framework as an example.
This indexer simply logs the Block height and the number of shards for each indexed block, using an [indexer handler](../lake-framework/building-indexers/js-lake-indexer.md#create-indexer-handler) function `handleStreamerMessage`.

Migrating this basic indexer to QueryAPI is simple. You only need to migrate the code from the `handleStreamerMessage` function:

```js
async function handleStreamerMessage(streamerMessage: types.StreamerMessage): Promise<void> {
    console.log(`
        Block #${streamerMessage.block.header.height}
        Shards: ${streamerMessage.shards.length}
    `);
}
```

### Migrating to QueryAPI

1. To start the migration process, [create a new indexer](../query-api/indexers.md#creating-an-indexer) using [QueryAPI](https://near.org/dataplatform.near/widget/QueryApi.App?view=create-new-indexer). You should see a similar interface like this:

![QueryAPI Indexer Dashboard](/docs/assets/QAPIScreen2.png)

2. Since QueryAPI keeps a compatibility layer with Lake Framework, you don't need to change any references to `streamerMessage` in your indexer function. Just change the function definition to:

```js
function handleStreamerMessage(streamerMessage) {
    // ... Lake framework indexer code
}
```

3. Next, add your migrated indexer function to the `getBlock(...)` method, and simply call your function passing `block.streamerMessage` as parameter:

```js
async function getBlock(block: Block) {
  // Add your code here

  function handleStreamerMessage(streamerMessage) {
    console.log(`
        Block #${streamerMessage.block.header.height}
        Shards: ${streamerMessage.shards.length}
    `);
    }

  handleStreamerMessage(block.streamerMessage);
}
```

That's all! The basic Lake Framework JS indexer has been migrated to QueryAPI, and you can test it out by using [Debug Mode](index-function.md#local-debug-mode). If you run the indexer using local debug mode, you should see an output like:

```
    Block #106812523
    Shards: 4
```

### Database storage

If you want to take advantage of QueryAPI's database features, you can also store the indexer results in a Postgres DB. 

1. First, create the database schema:

```sql
CREATE TABLE
  "basic" (
    "block_height" BIGINT NOT NULL,
    "shards" INTEGER NOT NULL,
    PRIMARY KEY ("block_height")
  );
```

2. In your indexer JavaScript code, use the [`context.db`](context.md#db) object  to store the results:

```js
    const basicData = {
      block_height: streamerMessage.block.header.height,
      shards: streamerMessage.shards.length,
    };

    context.db.Basic.insert(basicData);
```

## Advanced migration

For this example, let's take the TypeScript [NFT indexer](../lake-framework/building-indexers/nft-indexer.md) built with NEAR Lake Framework as reference. This indexer is watching for `nft_mint` [Events](https://nomicon.io/Standards/EventsFormat) and prints some relevant data about minted NFTs.

As with the previous example, moving this NFT indexer to QueryAPI requires to migrate the code from the [`handleStreamerMessage`](https://github.com/near-examples/near-lake-nft-indexer/blob/5acd543c54ce8025bdc9a88d111df43d8d4d05b8/index.ts#L32) function. But since it was done in TypeScript, it also needs some additional work as it needs to re-written in JavaScript.

### Migrating to QueryAPI

To migrate the code, you can take advantage of the [`near-lake-primitives`](https://near.github.io/near-lake-framework-js/modules/_near_lake_primitives.html) provided by QueryAPI, and simplify the indexer logic. For example:

- to get all [`Events`](https://near.github.io/near-lake-framework-js/classes/_near_lake_primitives.events.Event.html) in a `Block`, you can simply call `block.events()`.
- you don't need to iterate through shards and execution outcomes, nor manually parse the `EVENT_JSON` logs to detect events (it's handled by QueryAPI)

Here's a JavaScript implementation of the NFT indexer using QueryAPI features, that provides the same output as the original indexer:

```js
async function getBlock(block: Block) {
  let output = [];

  for (let ev of block.events()) {
    const r = block.actionByReceiptId(ev.relatedReceiptId);
    const createdOn = new Date(block.streamerMessage.block.header.timestamp / 1000000);

    try {
      let event = ev.rawEvent;

      if (event.standard === "nep171" && event.event === "nft_mint") {
        let nfts = [];
        let marketplace = "unknown";

        if (r.receiverId.endsWith(".paras.near"))
        {
          marketplace = "Paras";
          nfts = event.data.map(eventData => ({
                owner: eventData.owner_id,
                links: eventData.token_ids.map(
                  tokenId => `https://paras.id/token/${r.receiverId}::${tokenId.split(":")[0]}/${tokenId}`)
                })
              );
        }
        else if (r.receiverId.match(/\.mintbase\d+\.near$/))
        {
          marketplace = "Mintbase";
          nfts = event.data.map(eventData => {
            const memo = JSON.parse(eventData.memo)
            return {
              owner: eventData.owner_id,
              links: [`https://mintbase.io/thing/${memo["meta_id"]}:${r.receiverId}`]
            }
          });
        }

        output.push({
          receiptId: ev.relatedReceiptId,
          marketplace,
          createdOn,
          nfts,
        });

      }
    } catch (e) {
      console.log(e);
    }
  }

  if (output.length) {
    console.log(`We caught freshly minted NFTs!`);
    console.dir(output, { depth: 5 });
  }
}
```

That's all! The NFT indexer has been migrated to QueryAPI, and you can test it out by using [Debug Mode](index-function.md#local-debug-mode). If you run the indexer using local debug mode, you should see an output like:

```
Block Height #66264722

We caught freshly minted NFTs!

[
  {
    "receiptId": "BAVZ92XdbkAPX4DkqW5gjCvrhLX6kGq8nD8HkhQFVt5q",
    "marketplace": "Mintbase",
    "createdOn": "2022-05-24T09:36:00.411Z",
    "nfts": [
      {
        "owner": "chiming.near",
        "links": [
          "https://mintbase.io/thing/HOTcn6LTo3qTq8bUbB7VwA1GfSDYx2fYOqvP0L_N5Es:vnartistsdao.mintbase1.near"
        ]
      }
    ]
  }
]
```

### Database storage

If you want to take advantage of QueryAPI's database features, you can also store the indexer results in a Postgres DB. 

1. First, create the database schema:

```sql
CREATE TABLE
  "nfts" (
    "id" SERIAL NOT NULL,
    "marketplace" TEXT,
    "block_height" BIGINT,
    "timestamp" DATETIME,
    "receipt_id" TEXT,
    "nft_data" TEXT,
    PRIMARY KEY ("id", "block_height")
  );
```

2. In your indexer JavaScript code, use the [`context.db`](context.md#db) object  to store the results:

```js
// ... previous code ...
        output.push({
          receiptId: ev.relatedReceiptId,
          marketplace,
          createdOn,
          nfts,
        });

        const nftMintData = {
          marketplace: marketplace,
          block_height: block.header().height,
          timestamp: createdOn,
          receipt_id: r.receiptId,
          nft_data: JSON.stringify(event.data),
        };

        context.db.Nfts.insert(nftMintData);
      }
    } catch (e) {
      console.log(e);
    }
  }
// ... code continues ...
```

:::tip
You can find the migrated NFT indexer source code by [clicking here](https://near.org/dataplatform.near/widget/QueryApi.App?selectedIndexerPath=bucanero.near/nft_migrated).
:::

'''
'''--- docs/2.build/6.data-infrastructure/query-api/query-data.md ---
---
id: query-data
title: Accessing and Querying Historical data
sidebar_label: Access & Query Historical data
---

In this article, you'll find a high-level overview about the two most common use-cases for blockchain indexing, and how they can be solved using NEAR [QueryAPI](intro.md) and [BigQuery](../big-query.md).

## Overview

Building a blockchain indexer depends on the kind of historical blockchain data that you want to access and query. Let's consider these two most common blockchain indexing use cases:

- an indexer doing [blockchain analytics](#analytics), reporting, business intelligence, and big-data queries.
- an indexer built as a backend for a [web3 dApp](#webapps) building interactive and responsive UIs, that tracks interactions over a specific smart contract.

:::tip

Want to learn more about indexing? Check the [Introduction to Indexers](../../../1.concepts/3.advanced/indexers.md) article.

:::

## Analytics

When building a Blockchain analytics solution, you'll be creating queries to track NEAR assets, monitor transactions, or analyze on-chain events at a massive scale. Handling that huge amount of data in an optimal way so you can provide accurate results quickly requires a well designed solution.

Near [BigQuery solution](../big-query.md) provides instant insights, and let you access Historical on-chain data and queries at scale. It also eliminates your need to store and process bulk NEAR protocol data; you can just query as little or as much data as you want.

BigQuery does not require prior experience with blockchain technology. As long as you have a general knowledge of SQL, you'll be able create queries and unlock insights about transactions, smart contract utilization, user engagement, trends, and much more.

:::tip

Learn more about BigQuery in [this article](../big-query.md).

:::

### Analytics use cases

Common Blockchain analytics use cases that can be managed with [BigQuery](../big-query.md):

- create queries to track NEAR assets
- monitor transactions
- analyze on-chain events at a massive scale.
- use indexed data for data science tasks, including on-chain activities
- identifying trends
- feeding AI/ML pipelines for predictive analysis
- use NEAR's indexed data for deep insights on user engagement
- smart contract utilization
- insights across tokens and NFT adoption.

## WebApps

Building Web3 apps that handle historical blockchain data require dedicated solutions that manage the data and reduce the latency of requests, as it's not possible to scan the whole blockchain when a user makes a request.
For example, if your dApp needs to keep track of minted NFTs from a specific smart contract, you'll need to keep historical data related to that contract, the NFTs, and all the transactions in an optimized way so the dApp can provide fast responses to the user.

A simple solution for developers building [NEAR Components](../../3.near-components/what-is.md) is using [QueryAPI](intro.md), a fully managed solution to build indexer functions, extract on-chain data, store it in a database, and be able to query it using GraphQL endpoints.

In the NFT example, with QueryApi you can create an indexer that follow the activity of your `my-nft-contract.near` smart contract, records all activities related to it (such as minting and transfers), and provides simple endpoints to communicate with your dApp, when your application needs to display all the minted NFTs, or the related transactions to a specific NFT.

QueryApi can also reduce app development time, by letting you auto-generate [NEAR component code](index-function.md#create-a-bos-component-from-query) straight from a GraphQL query. By creating the boilerplate code, you can use it to render a UI and publish your new NEAR component.

:::tip

Learn more about QueryAPI in this [Overview article](intro.md).

:::

### dApp use cases

For a technical implementation deep-dive, check these QueryAPI tutorials:
build/near-data-infrastructure/lake-framework/building-indexers/nft-indexer
  - [NFTs Indexer](../lake-framework/building-indexers/nft-indexer.md): an indexer that keeps track of newly minted NFT on Near blockchain.
  - [Posts Indexer](../../../3.tutorials/near-components/indexer-tutorials/posts-indexer.md): this indexer keeps track of every new NEAR Social post found on the blockchain.
  - [Social Feed Indexer](../../../3.tutorials/near-components/indexer-tutorials/feed-indexer.md): this indexer keeps track of new posts, comments, and likes on NEAR Social, so a social feed can be rendered quickly.

'''
'''--- docs/2.build/6.data-infrastructure/what-is.md ---
---
id: what-is
title: What is Data Infrastructure? 
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

NEAR offers ready-to-use solutions to access and monitor on-chain data easily. This is very useful to automate actions based on specific **events**, cache data to **reduce latency**, gather **usage data** of the blockchain, and even **study user preferences**.

![img](/docs/assets/welcome-pages/data-lake.png)

NEAR offers three main solutions to access and monitor on-chain data: [**BigQuery Public Dataset**](#bigquery-public-dataset), [**QueryAPI**](#queryapi-indexers-made-simple), and [**NEAR Lake**](#near-lake). Each of these solutions is designed to fit different needs and use cases, and can be used in combination to create a complete data infrastructure for your application.
 
---

## [BigQuery: Public Dataset](./big-query.md)
A large dataset with on-chain data publicly available on Google Cloud Platform. Obtain near real-time blockchain data using simple SQL queries. **All the data, zero setup**.

- Instant insights: Historic on-chain data queried at scale. No need to run your own infrastructure.
- Cost-effective: Eliminate the need to store and process bulk NEAR Protocol data. Query as little or as much data as you like.
- As easy as SQL: No prior experience with blockchain technology is required. Just bring a general knowledge of SQL to unlock insights.

<hr subclass="subsection" />

## [QueryAPI: Indexers Made Simple](./query-api/intro.md)

A fully managed solution to build indexer functions, extract on-chain data, and easily query it using GraphQL endpoints and subscriptions.

- Your data, your way: Decide how you want to store data. Design the tables and databases that better suit your needs.
- Indexers made simple: Create the logic of your indexer and we will execute it for you. Forget about infrastructure‚Äîfocus on solutions.
- Plug & play to your app: Fetch your data from any application through our API. Leverage GraphQL to query exactly what you need.

<hr subclass="subsection" />

## [NEAR Lake](./lake-framework/near-lake.md)
A solution that watches over the NEAR network and stores all the events for your easy access.

- Cost-efficient solution: Cost-efficient solution for building self-hosted indexers in Rust, JavaScript, Python, Go and other languages
- Streamlined data management: Use NEAR Lake Framework to stream blocks to your server directly from NEAR Lake
'''
'''--- docs/2.build/welcome.md ---
---
id: welcome
title: Build on NEAR
sidebar_label: Home
hide_table_of_contents: true
hide_breadcrumb: true
---

import {FeatureList, Column, Feature} from "@site/src/components/featurelist"

Welcome! Here you will find all the information on what you can **build** on NEAR and **how to** build it. Do not worry if you are new to Web3 or Blockchain, we are here to **guide you** through the process of learning.

<FeatureList>
  <Column title="Contracts">
    <Feature url="/build/smart-contracts/what-is" title="What is a Contract?"
             subtitle="Learn what a smart contract is" image="contract.png" />
    <Feature url="/build/smart-contracts/quickstart" title="Build a Contract"
             subtitle="Spin-up your first smart contract" image="smartcontract.png" />
    <Feature url="/build/smart-contracts/testing/introduction" title="Test a Contract" subtitle="Write unit & integration tests" image="test.png" />
    <Feature url="/build/smart-contracts/release/deploy" title="Deploy a Contract" subtitle="Deploy the contract to the network" image="near-cli.png" />
  </Column>
  <Column title="Components">
    <Feature url="/build/near-components/what-is" title="What is a Component?"
             subtitle="Learn about multi-chain components" image="bos-lido.png" />
    <Feature url="/build/near-components/dev-environment" title="Dev Environment"
             subtitle="Choose your dev environment" image="update.png" />
    <Feature url="/build/near-components/anatomy/state" title="Build a Component"
             subtitle="Learn everything a Component can do" image="multiple.png" />
    <Feature url="/build/web3-apps/integrate-components" title="Use Components in a WebApp"
             subtitle="Use the contract in a frontend" image="frontend-bos.png"  />
  </Column>
  <Column title="Applications">
    <Feature url="/build/web3-apps/what-is" title="What are Web3 Apps?"
             subtitle="Learn about decentralized apps" image="near-logo.png" />
    <Feature url="/build/web3-apps/quickstart" title="Quickstart a Web3 App"
             subtitle="Use the contract in a frontend" image="quickstart.png"  />
    <Feature url="/build/web3-apps/integrate-contracts" title="Integrate Contracts"
             subtitle="Integrate with Contracts" image="bos-contract.png"  />
    <Feature url="/build/web3-apps/integrate-components" title="Integrate Components"
             subtitle="Use the contract in a frontend" image="frontend.png"  />
  </Column>
  <Column title="Primitives">
    <Feature url="/build/primitives/ft" title="Fungible Tokens" subtitle="Learn how to use and make FT" image="ft.png" />
    <Feature url="/build/primitives/nft" title="Non-Fungible Tokens" subtitle="Enter the NFT space" image="nft.png" />
    <Feature url="/build/primitives/dao" title="Autonomous Organizations" subtitle="Understand DAOs" image="dao.png" />
    <Feature url="/build/primitives/linkdrop" title="Linkdrops" subtitle="Drop assets & onboard users" image="key.png" />
    <Feature url="/build/primitives/oracles" title="Oracles" subtitle="On-chain oracles to query prices" image="oracle.png" />
  </Column>
  <Column title="Data Infrastructure">
    <Feature url="/build/data-infrastructure/big-query" title="Google BigQuery" 
             subtitle="Query network data efficiently" image="experiment.png" />
    <Feature url="/build/data-infrastructure/query-api/intro" title="QueryAPI" subtitle="The simplest way to build indexers" image="blocks.png" />
    <Feature url="/build/data-infrastructure/lake-framework/near-lake" title="NEAR Lake" subtitle="An Indexer that stores chain events" image="monitor.png" />
  </Column>
</FeatureList>

'''
'''--- docs/3.tutorials/crosswords/01-basics/00-overview.md ---
---
id: overview
sidebar_position: 1
sidebar_label: "Crossword Game Overview"
title: "Basics overview laying out what will be accomplished in this first section."
---

import basicCrossword from '/docs/assets/crosswords/basics-crossword.jpg';
import rustScary from '/docs/assets/crosswords/rust-scary--ksart.near.png';
import rustGood from '/docs/assets/crosswords/rust-good--ksart.near.png';

# Basics overview

This first chapter of the crossword puzzle tutorial will introduce fundamental concepts to smart contract development in a beginner-friendly way. By the end of this chapter you'll have a proof-of-concept contract that can be interacted with via [NEAR CLI](https://docs.near.org/tools/near-cli) and a simple frontend that uses the [`near-api-js` library](https://www.npmjs.com/package/near-api-js).

## It's not as bad as you think

Rust is a serious systems programming language. There are pointers, lifetimes, macros, and other things that may look foreign. Don't worry if this is how you feel:

<figure>
    <img src={rustScary} alt="Programmer looking at Rust code and looking worried. Art created by ksart.near" width="600"/>
    <figcaption>Art by <a href="https://twitter.com/ksartworks" target="_blank">ksart.near</a></figcaption>
</figure>
<br/>

The good news is the Rust SDK takes care of a lot of the heavy lifting.

We'll also have the compiler on our side, often telling us exactly what went wrong and offering suggestions. As we go through this tutorial, you'll begin to see patterns that we'll use over and over again.

So don't worry, writing smart contracts in Rust on NEAR doesn't require a heavy engineering background.

<img src={rustGood} alt="Programmer looking quite relieved at the Rust code from the NEAR SDK. Art created by ksart.near" width="600"/>

## Assumptions for this first chapter

- There will be only one crossword puzzle with one solution.
- The user solving the crossword puzzle will not be able to know the solution.
- Only the author of the crossword puzzle smart contract can set the solution.

## Completed project

Here's the final code for this chapter:

https://github.com/near-examples/crossword-tutorial-chapter-1

## How it works

<img src={basicCrossword} alt="Basic crossword puzzle" width="600" />

We'll have a rule about how to get the words in the proper order. We collect words in ascending order by number, and if there's and across and a down for a number, the across goes first.

So in the image above, the solution will be **near nomicon ref finance**. 

Let's begin!

'''
'''--- docs/3.tutorials/crosswords/01-basics/01-set-up-skeleton.md ---
---
sidebar_position: 2
sidebar_label: "Set up Rust and a contract skeleton" 
title: "Set up Rust, get a NEAR testnet account, NEAR CLI, and get a basic smart contract skeleton ready"
---
import {Github} from "@site/src/components/codetabs"

# Getting started

In this tutorial we'll get a testnet account, use NEAR CLI to add a key to our computer's file system, and set up the basic skeleton of a Rust smart contract.

## Getting a testnet account

Visit [NEAR Wallet for testnet](https://testnet.mynearwallet.com/) and register for a free account. For the purposes of this tutorial, you may skip the option to add two-factor authentication if you wish.

:::note What just happened?
When you created your NEAR testnet account, a private key was created and placed into your browser's local storage. You may inspect this using developer tools and see it. 
:::

## Creating a new key on your computer

We'll want to use a command-line interface (CLI) tool to deploy a contract, but at the moment the private key only exists in the browser. Next we'll _add a new key_ to the testnet account and have this stored locally on our computer as a JSON file. (Yes, you can have multiple keys on your NEAR account, which is quite powerful!)

Let's install NEAR CLI. (Please ensure you [have NodeJS](https://nodejs.org/) > 12.)

    npm install -g near-cli

You may now run:

    near

to see various commands, which are covered [in detail here](https://docs.near.org/tools/near-cli).

We'll start by "logging in" with this command:

    near login

This will bring you to NEAR Wallet again where you can confirm the creation of a **full-access** key. We'll get to full-access and function-call access keys later, just know that for powerful actions like "deploy" we'll need a full-access key. Follow the instructions from the login command to create a key on your hard drive. This will be located in your operating system's home directory in a folder called `.near-credentials`.

:::note How was a key added?
When you typed `near login`, NEAR CLI generated a key pair: a private and public key. It kept the private key tucked away in a JSON file and sent the public key as a URL parameter to NEAR Wallet. The URL is long and contains other info instructing NEAR Wallet to "add a full access key" to the account. Our browser's local storage had a key (created when the account was made) that is able to do several things, including adding another key. It took the public key from the URL parameter, used it as an argument, and voil√†: the testnet account has an additional key!
:::

You can see the keys associated with your account by running the following command, replacing `friend.testnet` with your account name:

    near keys friend.testnet

## Setting up Rust

You may have found the [online Rust Book](https://doc.rust-lang.org/stable/book), which is a great resource for getting started with Rust. However, there are key items that are different when it comes to blockchain development. Namely, that smart contracts are [technically libraries and not binaries](https://learning-rust.github.io/docs/cargo-crates-and-basic-project-structure/#crate), but for now just know that we won't be using some commands commonly found in the Rust Book.

:::caution We won't be using
    cargo run
during smart contract development.
:::

Instead, we'll be iterating on our smart contract by building it and running tests.

### Install Rust using `rustup`

Please see the directions from the [Rustup site](https://rustup.rs/#). For OS X or Unix, you may use:

    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

(Taken from the [Rust installation guide](https://www.rust-lang.org/tools/install))

### Add Wasm toolchain

Smart contracts compile to WebAssembly (Wasm) so we'll add the toolchain for Rust.

    rustup target add wasm32-unknown-unknown

(More info on [targets and this toolchain here](https://doc.rust-lang.org/edition-guide/rust-2018/platform-and-target-support/webassembly-support.html).)

## Start writing Rust! 

There's a basic repository that's helpful to clone or download [located here](https://github.com/near/boilerplate-template-rs). 

The first thing we'll do is modify the manifest file at `Cargo.toml`:

```diff
[package]
-  name = "rust-template"
+  name = "my-crossword"
version = "0.1.0"
- authors = ["Near Inc <hello@near.org>"]
+ authors = ["NEAR Friend <friend@example.com>"]
edition = "2018"
```

By changing the `name` here, we'll be changing the compiled Wasm file's name after running the build script. (`build.sh` for OS X and Linux, `build.bat` for Windows.) After running the build script, we can expect to find our compiled Wasm smart contract in `res/my_crossword.wasm`.

Now let's look at our main file, in `src/lib.rs`:

<Github language="rust" start="8" end="44" url="https://github.com/near/boilerplate-template-rs/blob/f1edeead98a9ec12c3f6db311f62025305f57874/contract/src/lib.rs" />

As you can see, this is a stub that's ready to be filled in. Let's pause and point out a few items:

- Note the [**near** macro](/sdk/rust/contract-structure/near-bindgen) is above the struct and the impl
- Here the main struct is called `Contract`, while in other examples it might be `Counter` or something else. This is purely stylistic, but you may learn more from the link in the previous bullet.
- You may notice the word "Borsh" and wonder what that means. This is a binary serializer. Eventually, we'll want to save data as ones and zeroes to validators' hard drives, and do it efficiently. We use Borsh for this, as is explained [on this website](https://borsh.io).

Next, let's modify this contract little by little‚Ä¶

'''
'''--- docs/3.tutorials/crosswords/01-basics/02-add-functions-call.md ---
---
sidebar_position: 3
sidebar_label: "Add basic code, create a subaccount, and call methods"
title: "Alter the smart contract, learning about basics of development"
---
import {Github} from "@site/src/components/codetabs"

import teachingDeployment from '/docs/assets/crosswords/teaching--jeheycell.near--artcultureac.jpeg';
import createAccount from '/docs/assets/crosswords/creating account with text--seanpineda.near--_seanpineda.png';
import chalkboardErase from '/docs/assets/crosswords/erasing-subaccount-chalkboard--iambon.near--JohnreyBona.mp4';

# Modifying the contract

This section will modify the smart contract skeleton from the previous section. This tutorial will start by writing a contract in a somewhat useless way in order to learn the basics. Once we've got a solid understanding, we'll iterate until we have a crossword puzzle.

## Add a const, a field, and functions

Let's modify the contract to be:

<Github language="rust" start="1" end="29" url="https://github.com/near-examples/crossword-snippets/blob/00223633f3e6b5b7137097e996b0aee90d632b0f/src/lib.rs" />

We've done a few things here:
1. Set a constant for the puzzle number.
2. Added the field `crossword_solution` to our main struct.
3. Implemented three functions: one that's view-only and two that are mutable, meaning they have the ability to change state.
4. Used logging, which required the import of `env` from our `near_sdk` crate.

Before moving on, let's talk about these changes and how to think about them, beginning with the constant:

`const PUZZLE_NUMBER: u8 = 1;`

This is an in-memory value, meaning that when the smart contract is spun up and executed in the virtual machine, the value `1` is contained in the contract code. This differs from the next change, where a field is added to the struct containing the `#[near]` macro. The field `crossword_solution` has the type of `String` and, like any other fields added to this struct, the value will live in **persistent storage**. With NEAR, storage is "paid for" via the native NEAR token (‚ìÉ). It is not "state rent" but storage staking, paid once, and returned when storage is deleted. This helps incentivize users to keep their state clean, allowing for a more healthy chain. Read more about [storage staking here](https://docs.near.org/concepts/storage/storage-staking).

Let's now look at the three new functions:

```rust
pub fn get_puzzle_number(&self) -> u8 {
    PUZZLE_NUMBER
}
```

As is covered in the [mutability section of these docs](/sdk/rust/contract-interface/contract-mutability), a "view-only" function will have open parenthesis around `&self` while "change methods" or mutable functions will have `&mut self`. In the function above, the `PUZZLE_NUMBER` is returned. A user may call this method using the proper RPC endpoint without signing any transaction, since it's read-only. Think of it like a GET request, but using RPC endpoints that are [documented here](https://docs.near.org/api/rpc/contracts#call-a-contract-function).

Mutable functions, on the other hand, require a signed transaction. The first example is a typical approach where the user supplies a parameter that's assigned to a field:

```rust
pub fn set_solution(&mut self, solution: String) {
    self.crossword_solution = solution;
}
```

The next time the smart contract is called, the contract's field `crossword_solution` will have changed.

The second example is provided for demonstration purposes:

```rust
pub fn guess_solution(&mut self, solution: String) {
    if solution == self.crossword_solution {
        env::log_str("You guessed right!")
    } else {
        env::log_str("Try again.")
    }
}
```

Notice how we're not saving anything to state and only logging? Why does this need to be mutable?

Well, logging is ultimately captured inside blocks added to the blockchain. (More accurately, transactions are contained in chunks and chunks are contained in blocks. More info in the [Nomicon spec](https://nomicon.io/Architecture.html?highlight=chunk#blockchain-layer-concepts).) So while it is not changing the data in the fields of the struct, it does cost some amount of gas to log, requiring a signed transaction by an account that pays for this gas.

---

## Building and deploying

Here's what we'll want to do:

<figure>
    <img src={teachingDeployment} alt="Teacher shows chalkboard with instructions on how to properly deploy a smart contract. 1. Build smart contract. 2. Create a subaccount (or delete and recreate if it exists) 3. Deploy to subaccount. 4. Interact. Art created by jeheycell.near"/>
    <figcaption className="full-width">Art by <a href="https://twitter.com/artcultureac" target="_blank">jeheycell.near</a></figcaption>
</figure>

### Build the contract

The skeleton of the Rust contract we copied from the previous section has a `build.sh` and `build.bat` file for OS X / Linux and Windows, respectively. For more details on building contracts, please see [this section](/sdk/rust/building/basics).

Run the build script and expect to see the compiled Wasm file copied to the `res` folder, instead of buried  in the default folder structure Rust sets up.

    ./build.sh

### Create a subaccount

If you've followed from the previous section, you have NEAR CLI installed and a full-access key on your machine. While developing, it's a best practice to create a subaccount and deploy the contract to it. This makes it easy to quickly delete and recreate the subaccount, which wipes the state swiftly and starts from scratch. Let's use NEAR CLI to create a subaccount and fund with 1 NEAR:

    near create-account crossword.friend.testnet --masterAccount friend.testnet --initialBalance 1 

If you look again in your home directory's `.near-credentials`, you'll see a new key for the subaccount with its own key pair. This new account is, for all intents and purposes, completely distinct from the account that created it. It might as well be `alice.testnet`, as it has, by default, no special relationship with the parent account. To be clear, `friend.testnet` cannot delete or deploy to `crossword.friend.testnet` unless it's done in a single transaction using Batch Actions, which we'll cover later.

:::info Subaccount nesting
It's possible to have the account `another.crossword.friend.testnet`, but this account must be created by `crossword.friend.testnet`. 

`friend.testnet` **cannot** create `another.crossword.friend.testnet` because accounts may only create a subaccount that's "one level deeper."

See this visualization where two keys belonging to `mike.near` are able to create `new.mike.near`. We'll get into concepts around access keys later.

<figure>
    <img src={createAccount} alt="Depiction of create account where two figures put together a subaccount. Art created by seanpineda.near"/>
    <figcaption className="full-width">Art by <a href="https://twitter.com/_seanpineda" target="_blank">seanpineda.near</a></figcaption>
</figure>

:::

We won't get into top-level accounts or implicit accounts, but you may read more [about that here](https://docs.near.org/docs/concepts/account).

Now that we have a key pair for our subaccount, we can deploy the contract to testnet and interact with it!

#### What's a codehash?

We're almost ready to deploy the smart contract to the account, but first let's take a look at the account we're going to deploy to. Remember, this is the subaccount we created earlier. To view the state easily with NEAR CLI, you may run this command:

    near state crossword.friend.testnet

What you'll see is something like this:

```js
{
  amount: '6273260568737488799170194446',
  block_hash: 'CMFVLYy6UP6c6vrWiSf1atWviayfZF2fgPoqKeUVtLhi',
  block_height: 61764892,
  code_hash: '11111111111111111111111111111111',
  locked: '0',
  storage_paid_at: 0,
  storage_usage: 4236,
  formattedAmount: '6,273.260568737488799170194446'
}
```

Note the `code_hash` here is all ones. This indicates that there is no contract deployed to this account.

Let's deploy the contract (to the subaccount we created) and then check this again.

### Deploy the contract

Ensure that in your command line application, you're in the directory that contains the `res` directory, then run:

```bash
    near deploy crossword.friend.testnet --wasmFile res/my_crossword.wasm
```

Congratulations, you've deployed the smart contract! Note that NEAR CLI will output a link to [NEAR Explorer](https://nearblocks.io/) where you can inspect details of the transaction.

Lastly, let's run this command again and notice that the `code_hash` is no longer all ones. This is the hash of the smart contract deployed to the account.

```bash
    near state crossword.friend.testnet
```

**Note**: deploying a contract is often done on the command line. While it may be _technically_ possible to deploy via a frontend, the CLI is likely the best approach. If you're aiming to use a factory model, (where a smart contract deploys contract code to a subaccount) this isn't covered in the tutorial, but you may reference the [contracts in SputnikDAO](https://github.com/near-daos/sputnik-dao-contract). 

### Call the contract methods (interact!)

Let's first call the method that's view-only:

```bash
    near view crossword.friend.testnet get_puzzle_number
```

Your command prompt will show the result is `1`. Since this method doesn't take any arguments, we don't pass any. We could have added `'{}'` to the end of the command as well.

Next, we'll add a crossword solution as a string (later we'll do this in a better way) argument:

```bash
    near call crossword.friend.testnet set_solution '{"solution": "near nomicon ref finance"}' --accountId friend.testnet
```

:::info Windows users
Windows users will have to modify these commands a bit as the Command Prompt doesn't like single quotes as we have above. The command must use escaped quotes like so:

```bash
    near call crossword.friend.testnet set_solution "{\"solution\": \"near nomicon ref finance\"}" --accountId friend.testnet
```

:::

Note that we used NEAR CLI's [`view` command](https://docs.near.org/docs/tools/near-cli#near-view), and didn't include an `--accountId` flag. As mentioned earlier, this is because we are not signing a transaction. This second method uses the NEAR CLI [`call` command](https://docs.near.org/docs/tools/near-cli#near-call) which does sign a transaction and requires the user to specify a NEAR account that will sign it, using the credentials files we looked at.

The last method we have will check the argument against what is stored in state and write a log about whether the crossword solution is correct or incorrect.

Correct:

```bash
    near call crossword.friend.testnet guess_solution '{"solution": "near nomicon ref finance"}' --accountId friend.testnet
```

You'll see something like this:

![Command line shows log for successful solution guess](/docs/assets/crosswords/cli-guess-solution.png)

Notice the log we wrote is output as well as a link to NEAR Explorer.

Incorrect:

```bash
    near call crossword.friend.testnet guess_solution '{"solution": "wrong answers here"}' --accountId friend.testnet
```

As you can imagine, the above command will show something similar, except the logs will indicate that you've given the wrong solution.

## Reset the account's contract and state

We'll be iterating on this smart contract during this tutorial, and in some cases it's best to start fresh with the NEAR subaccount we created. The pattern to follow is to **delete** the account (sending all remaining testnet ‚ìÉ to a recipient) and then **create the account** again.

<video autoPlay controls loop>
    <source src={chalkboardErase} type="video/mp4" />
    Sorry, your browser doesn't support embedded videos.
</video>

<figure>
    <figcaption>Deleting a recreating a subaccount will clear the state and give us a fresh start.<br/>Animation by <a href="https://twitter.com/JohnreyBona" target="_blank">iambon.near</a></figcaption>
</figure>

Using NEAR CLI, the commands will look like this:

```bash
    near delete crossword.friend.testnet friend.testnet
    near create-account crossword.friend.testnet --masterAccount friend.testnet
```

The first command deletes `crossword.friend.testnet` and sends the rest of its NEAR to `friend.testnet`.

## Wrapping up

So far, we're writing a simplified version of smart contract and approaching the crossword puzzle in a novice way. Remember that blockchain is an open ledger, meaning everyone can see the state of smart contracts and transactions taking place. 

:::info How would you do that?
You may hit an RPC endpoint corresponding to `view_state` and see for yourself. Note: this quick example serves as demonstration purposes, but note that the string being returned is Borsh-serialized and contains more info than just the letters.

```bash
    curl -d '{"jsonrpc": "2.0", "method": "query", "id": "see-state", "params": {"request_type": "view_state", "finality": "final", "account_id": "crossword.friend.testnet", "prefix_base64": ""}}' -H 'Content-Type: application/json' https://rpc.testnet.near.org
```

![Screenshot of a terminal screen showing a curl request to an RPC endpoint that returns state of a smart contract](/docs/assets/crosswords/rpc-api-view-state.png)

More on this RPC endpoint in the [NEAR docs](https://docs.near.org/docs/api/rpc/contracts#view-contract-state).
:::

In this section, we saved the crossword solution as plain text, which is likely not a great idea if we want to hide the solution to players of this crossword puzzle. Even though we don't have a function called `show_solution` that returns the struct's `crossword_solution` field, the value is stored transparently in state. We won't get into viewing contract state at this moment, but know it's rather easy [and documented here](https://docs.near.org/docs/api/rpc/contracts#view-contract-state).

The next section will explore hiding the answer from end users playing the crossword puzzle.

'''
'''--- docs/3.tutorials/crosswords/01-basics/03-hashing-and-unit-tests.md ---
---
sidebar_position: 4
sidebar_label: "Hash the solution, unit tests, and an init method"
title: "Introduction to basic hashing and adding unit tests"
---
import {Github} from "@site/src/components/codetabs"

import batchCookieTray from '/docs/assets/crosswords/batch-of-actions--dobulyo.near--w_artsu.jpg';

# Hash the solution, add basic unit tests

In the previous section, we stored the crossword solution as plain text as a `String` type on the smart contract. If we're trying to hide the solution from the users, this isn't a great approach as it'll be public to anyone looking at the state. Let's instead hash our crossword solution and store that instead. There are different ways to hash data, but let's use `sha256` which is one of the hashing algorithms available in [the Rust SDK](https://docs.rs/near-sdk/latest/near_sdk/env/fn.sha256.html).

:::info Remind me about hashing
Without getting into much detail, hashing is a "one-way" function that will output a result from a given input. If you have input (in our case, the crossword puzzle solution) you can get a hash, but if you have a hash you cannot get the input. This basic idea is foundational to information theory and security.

Later on in this tutorial, we'll switch from using `sha256` to using cryptographic key pairs to illustrate additional NEAR concepts.

Learn more about hashing from [Evgeny Kapun](https://github.com/abacabadabacaba)'s presentation on the subject. You may find other NEAR-related videos from the channel linked in the screenshot below.

[![Evgeny Kapun presents details on hashing](/docs/assets/crosswords/kapun-hashing.png)](https://youtu.be/PfabikgnD08)
:::

## Helper unit test during rapid iteration

As mentioned in the first section of this **Basics** chapter, our smart contract is technically a library as defined in the manifest file. For our purposes, a consequence of writing a library in Rust is not having a "main" function that runs. You may find many online tutorials where the command `cargo run` is used during development. We don't have this luxury, but we can use unit tests to interact with our smart contract. This is likely more convenient than building the contract, deploying to a blockchain network, and calling a method.

We'll add a dependency to the [hex crate](https://crates.io/crates/hex) to make things easier. As you may remember, dependencies live in the manifest file.

<Github language="rust" start="10" end="12" url="https://github.com/near-examples/crossword-tutorial-chapter-1/blob/481a83f0c90398f3234ce8006af4e232d6c779d7/contract/Cargo.toml" />

Let's write a unit test that acts as a helper during development. This unit test will sha256 hash the input **"near nomicon ref finance"** and print it in a human-readable, hex format. (We'll typically put unit tests at the bottom of the `lib.rs` file.)

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::{get_logs, VMContextBuilder};
    use near_sdk::{testing_env, AccountId};

    #[test]
    fn debug_get_hash() {
        // Basic set up for a unit test
        testing_env!(VMContextBuilder::new().build());

        // Using a unit test to rapidly debug and iterate
        let debug_solution = "near nomicon ref finance";
        let debug_hash_bytes = env::sha256(debug_solution.as_bytes());
        let debug_hash_string = hex::encode(debug_hash_bytes);
        println!("Let's debug: {:?}", debug_hash_string);
    }
}
```

:::info What is that `{:?}` thing?
Take a look at different formatting traits that are covered in the [`std` Rust docs](https://doc.rust-lang.org/std/fmt/index.html#formatting-traits) regarding this. This is a `Debug` formatting trait and can prove to be useful during development.
:::

Run the unit tests with the command:

```
cargo test -- --nocapture
```

You'll see this output:

```
‚Ä¶
running 1 test
Let's debug: "69c2feb084439956193f4c21936025f14a5a5a78979d67ae34762e18a7206a0f"
test tests::debug_get_hash ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

This means when you sha256 the input **"near nomicon ref finance"** it produces the hash:
`69c2feb084439956193f4c21936025f14a5a5a78979d67ae34762e18a7206a0f`

:::tip Note on the test flags
You may also run tests using:

```
cargo test
```

Note that the test command we ran had additional flags. Those flags told Rust *not to hide the output* from the tests. You can read more about this in [the cargo docs](https://doc.rust-lang.org/cargo/commands/cargo-test.html#display-options). Go ahead and try running the tests using the command above, without the additional flags, and note that we won't see the debug message.
:::

The unit test above is meant for debugging and quickly running snippets of code. Some may find this a useful technique when getting familiar with Rust and writing smart contracts. Next we'll write a real unit test that applies to this early version of our crossword puzzle contract.

## Write a regular unit test

Let's add this unit test (inside the `mod tests {}` block, under our previous unit test) and analyze it:

<Github language="rust" start="63" end="93" url="https://github.com/near-examples/crossword-tutorial-chapter-1/blob/5bce1c2a604fcb179e9789de1f299063f91abb4d/contract/src/lib.rs" />

The first few lines of code will be used commonly when writing unit tests. It uses the `VMContextBuilder` to create some basic context for a transaction, then sets up the testing environment.

Next, an object is created representing the contract and the `set_solution` function is called. After that, the `guess_solution` function is called twice: first with the incorrect solution and then the correct one. We can check the logs to determine that the function is acting as expected.

:::info Note on assertions
This unit test uses the [`assert_eq!`](https://doc.rust-lang.org/std/macro.assert_eq.html) macro. Similar macros like [`assert!`](https://doc.rust-lang.org/std/macro.assert.html) and [`assert_ne!`](https://doc.rust-lang.org/std/macro.assert_ne.html) are commonly used in Rust. These are great to use in unit tests. However, these will add unnecessary overhead when added to contract logic, and it's recommended to use the [`require!` macro](https://docs.rs/near-sdk/4.0.0-pre.2/near_sdk/macro.require.html). See more information on this and [other efficiency tips here](/sdk/rust/contract-size).
:::

Again, we can run all the unit tests with:

```
cargo test -- --nocapture
```

:::tip Run only one test
To only run this latest test, use the command:

```
cargo test check_guess_solution -- --nocapture
```

:::

## Modifying `set_solution`

The [overview section](00-overview.md) of this chapter tells us we want to have a single crossword puzzle and the user solving the puzzle should not be able to know the solution. Using a hash addresses this, and we can keep `crossword_solution`'s field type, as `String` will work just fine. The overview also indicates we only want the author of the crossword puzzle to be able to set the solution. As it stands, our function `set_solution` can be called by anyone with a full-access key. It's trivial for someone to create a NEAR account and call this function, changing the solution. Let's fix that.

Let's have the solution be set once, right after deploying the smart contract.

Here we'll use the [`#[near]` macro](https://docs.rs/near-sdk/latest/near_sdk/attr.near.html) on a function called `new`, which is a common pattern.

<Github language="rust" start="10" end="17" url="https://github.com/near-examples/crossword-tutorial-chapter-1/blob/94f42e75cf70ed2aafb9c29a1faa1e21f079a49e/contract/src/lib.rs" />

Let's call this method on a fresh contract.

```bash
# Build (for Windows it's build.bat)
./build.sh

# Create fresh account if you wish, which is good practice
near delete crossword.friend.testnet friend.testnet
near create-account crossword.friend.testnet --masterAccount friend.testnet

# Deploy
near deploy crossword.friend.testnet --wasmFile res/my_crossword.wasm

# Call the "new" method
near call crossword.friend.testnet new '{"solution": "69c2feb084439956193f4c21936025f14a5a5a78979d67ae34762e18a7206a0f"}' --accountId crossword.friend.testnet
```

Now the crossword solution, as a hash, is stored instead. If you try calling the last command again, you'll get the error message, thanks to the `#[init]` macro:
`The contract has already been initialized`

## First use of Batch Actions

This is close to what we want, but what if a person deploys their smart contract and **someone else** quickly calls the `new` function before them? We want to make sure the same person who deployed the contract sets the solution, and we can do this using Batch Actions. Besides, why send two transactions when we can do it in one? (Technical details covered in the spec for a [batch transaction here](https://nomicon.io/RuntimeSpec/Transactions.html?highlight=batch#batched-transaction).)

<figure>
    <img src={batchCookieTray} alt="Cookie sheet representing a transaction, where cookies are Deploy and FunctionCall Actions. Art created by dobulyo.near."/>
    <figcaption className="full-width">Art by <a href="https://twitter.com/w_artsu" target="_blank">dobulyo.near</a></figcaption>
</figure><br/>

:::info Batch Actions in use
Batch Actions are common in this instance, where we want to deploy and call an initialization function. They're also common when using a factory pattern, where a subaccount is created, a smart contract is deployed to it, a key is added, and a function is called.

Here's a truncated snippet from a useful (though somewhat advanced) repository with a wealth of useful code:
<Github language="rust" start="172" end="177" url="https://github.com/near/core-contracts/blob/1720c0cfee238974ebeae8ad43076abeb951504f/staking-pool-factory/src/lib.rs" />

We'll get into Actions later in this tutorial, but in the meantime here's a handy [reference from the spec](https://nomicon.io/RuntimeSpec/Actions.html).
:::

As you can from the info bubble above, we can batch [Deploy](https://docs.rs/near-sdk/3.1.0/near_sdk/struct.Promise.html#method.deploy_contract) and [FunctionCall](https://docs.rs/near-sdk/3.1.0/near_sdk/struct.Promise.html#method.function_call) Actions. This is exactly what we want to do for our crossword puzzle, and luckily, NEAR CLI has a [flag especially for this](https://docs.near.org/tools/near-cli#near-deploy).

Let's run this again with the handy `--initFunction` and `--initArgs` flags:

```bash
# Create fresh account if you wish, which is good practice
near delete crossword.friend.testnet friend.testnet
near create-account crossword.friend.testnet --masterAccount friend.testnet

# Deploy
near deploy crossword.friend.testnet --wasmFile res/my_crossword.wasm \
  --initFunction 'new' \
  --initArgs '{"solution": "69c2feb084439956193f4c21936025f14a5a5a78979d67ae34762e18a7206a0f"}'
```

Now that we're using Batch Actions, no one can call this `new` method before us.

:::note Batch action failures
If one Action in a set of Batch Actions fails, the entire transaction is reverted. This is good to note because sharded, proof-of-stake systems do not work like proof-of-work where a complex transaction with multiple cross-contract calls reverts if one call fails. With NEAR, cross-contract calls use callbacks to ensure expected behavior, but we'll get to that later.
:::

## Get ready for our frontend

In the previous section we showed that we could use a `curl` command to view the state of the contract without explicitly having a function that returns a value from state. Now that we've demonstrated that and hashed the solution, let's add a short view-only function `get_solution`.

In the next section we'll add a simple frontend for our single, hardcoded crossword puzzle. We'll want to easily call a function to get the final solution hash. We can use this opportunity to remove the function `get_puzzle_number` and the constant it returns, as these were use for informative purposes.

We'll also modify our `guess_solution` to return a boolean value, which will also make things easier for our frontend.

<Github language="rust" start="19" end="34" url="https://github.com/near-examples/crossword-tutorial-chapter-1/blob/94f42e75cf70ed2aafb9c29a1faa1e21f079a49e/contract/src/lib.rs" />

The `get_solution` method can be called with:

```
near view crossword.friend.testnet get_solution
```

In the next section we'll add a simple frontend. Following chapters will illustrate more NEAR concepts built on top of this idea.

'''
'''--- docs/3.tutorials/crosswords/01-basics/04-simple-frontend.md ---
---
sidebar_position: 5
sidebar_label: "Add simple frontend"
title: "Add a simple frontend to the crossword puzzle that checks the solution's hash"
---
import {Github} from "@site/src/components/codetabs"

import nearReactFriends from '/docs/assets/crosswords/near-and-react--dakila.near--rodolf_dtbbx.png';

# Add a simple frontend

This will be the final section in this chapter, where we'll add a simple frontend using React and [`near-api-js`](https://docs.near.org/tools/near-api-js/quick-reference) to communicate with the smart contract.

<figure>
    <img src={nearReactFriends} alt="Two characters hanging out, NEAR and React. Art created by dakila.near" width="600"/>
    <figcaption>Dynamic duo of NEAR as the backend and React as a frontend.<br/>Art by <a href="https://twitter.com/rodolf_dtbbx" target="_blank">dakila.near</a></figcaption>
</figure>
<br/>

There will be three main files we'll be working with:
1. `src/index.js` will be the entry point, where NEAR network configuration will be set up, and the view-only call to `get_solution` will happen.
2. `src/App.js` is then called and sets up the crossword table and checks to see if a solution has been found.
3. `src/utils.js` is used to make a view-only call to the blockchain to get the solution, and other helper functions.

## Entry point

We'll go over a pattern that may look familiar to folks who have surveyed the [NEAR examples site](https://github.com/near-examples). We'll start with an asynchronous JavaScript function that sets up desired logic, then pass that to the React app.

<Github language="js" start="3" end="22" url="https://github.com/near-examples/crossword-tutorial-chapter-1/blob/3e497b4815600b8382614f76c7812520710f704d/src/index.js" />

Let's talk through the code above, starting with the imports.

We import from:

- `config.js` which, at the moment, is a common pattern. This file contains details on the different networks. (Which RPC endpoint to hit, which NEAR Wallet site to redirect to, which NEAR Explorer as well‚Ä¶)
- `utils.js` for that view-only function call that will call `get_solution` to retrieve the correct solution hash when a person has completed the crossword puzzle correctly.
- `hardcoded-data.js` is a file containing info on the crossword puzzle clues. This chapter has covered the crossword puzzle where the solution is **near nomicon ref finance**, and according to the chapter overview we've committed to serving *one* puzzle. We'll improve our smart contract later, allowing for multiple crossword puzzles, but for now it's hardcoded here.

Next, we define an asynchronous function called `initCrossword` that will be called before passing data to the React app. It's often useful to set up a connection with the blockchain here, but in our case all we need to do is retrieve the crossword puzzle solution as a hash. Note that we're attempting to pass this environment variable `NEAR_ENV` into our configuration file. `NEAR_ENV` is used to designate the blockchain network (testnet, betanet, mainnet) and is also [used in NEAR CLI](https://docs.near.org/develop/deploy). 

Lastly, we'll call `initCrossword` and, when everything is complete, pass data to the React app contained in `App.js`.

## React app

Here's a large portion of the `App.js` file, which will make use of a fork of a React crossword library by Jared Reisinger.

<Github language="js" start="3" end="54" url="https://github.com/near-examples/crossword-tutorial-chapter-1/blob/3e497b4815600b8382614f76c7812520710f704d/src/App.js" />

We'll discuss a few key points in the code above, but seeing as we're here to focus on a frontend connection to the blockchain, will brush over other parts that are library-specific.

The two imports worth highlighting are:

- `parseSolutionSeedPhrase` from the utility file we'll cover shortly. This will take the solution entered by the user and put it in the correct order according to the rules discussed in [the chapter overview](00-overview.md#how-it-works).
- `sha256` will take the ordered solution from above and hash it. Then we'll compare that hash with the one retrieved from the smart contract.

```js
const [solutionFound, setSolutionFound] = useState(false);
```

We're using [React Hooks](https://reactjs.org/docs/hooks-state.html) here, setting up the variable `solutionFound` that will be changed when the player of the crossword puzzle enters the final letter of the crossword puzzle, having entries for all the letters on the board.

The `onCrosswordComplete` and `checkSolution` blocks of code fire events to check the final solution entered by the user, hash it, and compare it to the `solutionHash` that was passed in from the view-only call in `index.js` earlier.

Finally, we return the [JSX](https://reactjs.org/docs/introducing-jsx.html) for our app and render the crossword puzzle! In this basic case we'll change this heading to indicate when the user has completed the puzzle successfully:

```html
<h3>Status: { solutionFound }</h3>
```

## Utility functions

We'll be using two utility functions here:

- `parseSolutionSeedPhrase` which will take a completed crossword puzzle and place the answers in the proper order. (Ascending by number, across answers come before down ones.)
- `viewMethodOnContract` makes the view-only call to the smart contract to retrieve the solution hash.

We'll only focus on the second method:

<Github language="js" start="8" end="12" url="https://github.com/near-examples/crossword-tutorial-chapter-1/blob/3e497b4815600b8382614f76c7812520710f704d/src/utils.js" />

This API doesn't look warm and friendly yet. You caught us! We'd love some help to improve our API as [detailed in this issue](https://github.com/near/near-api-js/issues/612), but for now, this is a concise way to get data from a view-only method.

We haven't had the frontend call a mutable method for our project yet. We'll get into that in the coming chapters when we'll want to have a prize sent to the first person to solve the puzzle.

## Run the React app

Let's run our frontend on testnet! We won't add any new concepts at this point in the chapter, but note that the [near examples](https://github.com/near-examples) typically create an account for you automatically with a NodeJS command. We covered the important pattern of creating a subaccount and deploying the smart contract to it, so let's stick with that pattern as we start up our frontend.

```bash
# Go into the directory containing the Rust smart contract we've been working on
cd contract

# Build (for Windows it's build.bat)
./build.sh

# Create fresh account if you wish, which is good practice
near delete crossword.friend.testnet friend.testnet
near create-account crossword.friend.testnet --masterAccount friend.testnet

# Deploy
near deploy crossword.friend.testnet --wasmFile res/my_crossword.wasm \
  --initFunction 'new' \
  --initArgs '{"solution": "69c2feb084439956193f4c21936025f14a5a5a78979d67ae34762e18a7206a0f"}'
  
# Return to the project root and start the React app
cd ..
env CONTRACT_NAME=crossword.friend.testnet npm run start
```

The last line sends the environment variable `CONTRACT_NAME` into the NodeJS script. This is picked up in the `config.js` file that's used to set up the contract account and network configuration:

<Github language="js" start="1" end="2" url="https://github.com/near-examples/crossword-tutorial-chapter-1/blob/3e497b4815600b8382614f76c7812520710f704d/src/config.js" />

After running the last command to start the React app, you'll be given a link to a local website, like `https://localhost:1234`. When you visit the site you'll see the simple frontend that interacts with our smart contract:

![Crossword puzzle frontend showing a filled out puzzle with clues on the right sidebar](/docs/assets/crosswords/basics-final-frontend.png)

Again, the full code for this chapter is [available here](https://github.com/near-examples/crossword-tutorial-chapter-1).

'''
'''--- docs/3.tutorials/crosswords/02-beginner/00-overview.md ---
---
sidebar_position: 1
sidebar_label: "Overview"
title: "Highlights of some beginner topics covered."
---

import chapter2Correct from '/docs/assets/crosswords/chapter-2-solve.gif';
import multipleCrosswords from '/docs/assets/crosswords/puzzle-piggy-bank--r3v.near--rev_rodrigueza.png';

# Diving deeper

In the last chapter we installed Rust and got up and running with a simple smart contract. The contract has a few issues, however, and isn't as powerful as we'd like it to be. For instance, we can only store one crossword puzzle in the smart contract, the frontend is  hardcoded, and we don't offer any incentives to the person who wins.

Let's give the smart contract the ability to store multiple crosswords and offer the winner a prize, paid in NEAR.

<figure>
    <img src={multipleCrosswords} alt="Man holding a book full of crossword puzzles, in his other hand he's holding a piggy bank. Art created by r3v.near"/>
    <figcaption className="full-width">Art by <a href="https://twitter.com/rev_rodrigueza" target="_blank">r3v.near</a></figcaption>
</figure>
<br/>

In this chapter we'll:

- Allow the contract to store multiple crossword puzzles
- Store the positions of the clues in the contract
- Allow users to log in with a NEAR account
- Give a prize (in NEAR tokens) to the first person to solve the puzzle
- Explore using Rust structs and enums
- more‚Ä¶

<figure>
    <img src={chapter2Correct} width="600" alt="A user fills in the last clue in a crossword puzzle and an overlay appears saying that a transaction is pending" />
    <figcaption>A user solves the crossword puzzle, interacts with the blockchain, and gets a prize</figcaption>
</figure>

As we implement the list above, we'll learn key concepts about NEAR:

- [Actions](https://nomicon.io/RuntimeSpec/Actions.html)
- Full and function-call [access keys](https://docs.near.org/concepts/basics/account#access-keys)
- NEAR's specialized [Collections](https://docs.near.org/concepts/storage/data-storage#rust-collection-types) that are generally preferable to, say, Rust's standard HashMap 
- The flow of logging in to a decentralized app (dApp)
- more‚Ä¶

Let's jump right in!

## Completed project

Here's the final code for this chapter:

https://github.com/near-examples/crossword-tutorial-chapter-2

'''
'''--- docs/3.tutorials/crosswords/02-beginner/01-collections.md ---
---
sidebar_position: 2
sidebar_label: "Store multiple puzzles"
title: "Store multiple crossword puzzles using a specialized collection in NEAR called a LookupMap"
---
import {Github} from "@site/src/components/codetabs"

import bookPagination from '/docs/assets/crosswords/paging-through-hashes-swing--pierced_staggg.near--pierced_stag.jpg';
import guardsAroundContract from '/docs/assets/crosswords/guards-contract-permissions--connoisseur_dane.near--connoisseurdane.png';

# Using collections

As mentioned in the previous chapter, the [online Rust Book](https://doc.rust-lang.org/stable/book) is a great reference for folks getting started with Rust, but there are concepts that differ when we're dealing with the blockchain. One of these differences is the use of collections.

The reference-level documentation of the Rust SDK explains this concept well:

:::note  Motivation for specialized collections
>Collections that offer an alternative to standard containers from [Rust's] std::collections::* by **utilizing the underlying blockchain trie storage more efficiently**.<br/>
>For example, the following smart contract does not work with state efficiently, because **it will load the entire HashMap at the beginning of the contract call**, and will save it entirely at the end, in cases when there is state modification. **This is fine for small number of elements, but very inefficient for large numbers**.

‚Äî [NEAR SDK reference documentation](https://docs.rs/near-sdk/latest/near_sdk/collections/index.html)
:::

In chapter 1, we set the crossword puzzle solution hash when we first deployed the contract and called the initialization method `new`, passing it. This would only allow us to have only one puzzle, but let's allow for many.

At a high level, let's discuss what we'll want to add if our contract is to store multiple crossword puzzles. First, we'll have the concept of many puzzles where some of them will have different states (unfinished and finished) and we'll want to know which ones are unsolved in quick way. Another thing, which is a general rule of thumb when writing smart contracts, is to anticipate what might happen if it gets a lot of usage. What if we end up with 10,000 crossword puzzles? How might that affect how many data structures we use and which ones?

## LookupMap and UnorderedSet

Let's try having two specialized NEAR collections:

1. A [LookupMap](https://docs.rs/near-sdk/latest/near_sdk/collections/struct.LookupMap.html) which will store key-value pairs. (Solution hash ¬ª Puzzle object)
2. An [UnorderedSet](https://docs.rs/near-sdk/latest/near_sdk/collections/struct.UnorderedSet.html) containing a set (list with no duplicates) of the solution hashes for puzzles which have not been solved yet.

As you look at the list of specialized collections in the Rust SDK, you might notice some begin with `Lookup` while others have `Unordered`. As is written in the reference documentation, the `Lookup` is non-iterable while the `Unordered` collections are iterable. This means if you will need to loop through the list of contents of this data structure, you'll likely use an iterable data structure. If you'll only ever be adding and retrieving data by the key, and the key will always be known, it's more efficient to use a non-iterable collection.

So why would we have two data structures here? Again, if we end up with a large number of puzzles, we might not be able to loop through all the puzzles, looking for ones that are unsolved. Because of the limit of gas execution per transaction, we must be conscious that there can be operations which will eventually exceed this limit. I suppose we could assume  that our `UnorderedSet` of unsolved puzzles wouldn't contain tens of thousands of puzzles. That's one way to avoid running into limits, but we could also learn how to utilize **pagination** through an iterable collection like an `UnorderedSet` which we'll get to later.

<figure>
    <img src={bookPagination} alt="Book showing pagination of hashes. Art created by pierced_staggg.near" width="600"/>
    <figcaption>Think of our collection as having multiple pages of puzzle hashes.<br/>Art by <a href="https://twitter.com/pierced_stag" target="_blank">pierced_staggg.near</a></figcaption>
</figure>
<br/>

As we remember from the previous chapter, every smart contract has a primary struct containing the `#[near(contract_state)]` macro. 

:::note Naming the primary struct
Note in the [previous chapter](../01-basics/01-set-up-skeleton.md#start-writing-rust) we named our primary struct `Contract`, but in this chapter we'll call it `Crossword.`

The name of the struct doesn't matter and there's nothing special about naming it `Contract`, though you might see that convention used in several smart contracts on NEAR. We've named it something different simply to illustrate that there's no magic behind the scenes. This *does* mean, however, that our `impl` block will also be `Crossword`.
:::

Here's how our struct will look with the iterable and non-iterable NEAR collections:

<Github language="rust" start="73" end="79" url="https://github.com/near-examples/crossword-tutorial-chapter-2/blob/276217ad82c64c610148e998ec926942ba910a12/contract/src/lib.rs" />

Above, we have the `puzzles` and `unsolved_puzzles` fields which are collections.

We also have an `owner_id` so we can exercise a common pattern in smart contract development: implementing a rudimentary permission system which can restrict access to certain functions. We'll expand on this thought in a moment.

The snippet below shows the first method in the implementation of the `Crossword` struct, where the `new` function sets up these two specialized collections.

<Github language="rust" start="81" end="90" url="https://github.com/near-examples/crossword-tutorial-chapter-2/blob/276217ad82c64c610148e998ec926942ba910a12/contract/src/lib.rs" />

So during the initialization function (`new`) we're setting the `owner_id`. For our purposes the owner will likely be the contract itself, but there can be several reasons to have it be a DAO or another user. Next, let's look at the `b"c"` and `b"u"` bits for the collection fields.

## Collections have prefixes

Above, the `new` function is initializing the struct's fields by giving them a unique prefix. You can learn more about [the prefixes here](/sdk/rust/contract-structure/nesting#traditional-approach-for-unique-prefixes), but know that these prefixes (`c` and `u`) should be short and different.

Let's take a peek at how we'll add a new crossword puzzle. Note that there will be a new struct here, `Answer`, which we haven't defined yet. We'll also be introducing the concept of enums, like `PuzzleStatus::Solved` and `PuzzleStatus::Unsolved`. We'll be covering these in the next section.

Unlike the previous chapter where there was only one crossword puzzle, we'll be inserting into our new collections, so let's create a `new_puzzle` method.

<Github language="rust" start="147" end="163" url="https://github.com/near-examples/crossword-tutorial-chapter-2/blob/8ec941c82539e6eafa4971444e1da9e4819330d3/contract/src/lib.rs" />

Now we're set up to store multiple puzzles!

## Permissions or permissionless?

<figure>
    <img src={guardsAroundContract} alt="Guards or bouncers in front of a futuristic club with the label of a NEAR smart contract. Art created by connoisseur_dane.near" width="600"/>
    <figcaption>Guarding which accounts can enter the smart contract logic.<br/>Art by <a href="https://twitter.com/connoisseurdane" target="_blank">connoisseur_dane.near</a></figcaption>
</figure>
<br/>

**Is NEAR permissionless?**

Yes. 

**What did you mean by a permission system earlier, and what are the ways you can control permissions?**

There are two ways that permissions can be controlled:

1. In the smart contract code itself
2. When using function-call access keys

We'll get to the second topic in later in this chapter, but will focus on the first item.

As you can see in the previous snippet, the first thing that happens in the `new_puzzle` method is a check. It looks to see if the predecessor (the person who most recently called this method, sometimes the same as the signer) is the same as the `owner_id` that we set during the contract's initialization.

If someone else is trying to call `new_puzzle`, this check will fail and the smart contract will panic, going no further. This example is the simplest form of a permission. Much more complex system can exist for users. The SputnikDAO smart contracts, for instance, implement custom policies. It's up the smart contract developer to write their roles/policies and apply them to users. Sometimes an allow-list (or whitelist) is used.

In short, **any account with a full-access key can call any method on a smart contract**, but that doesn't mean the smart contract will let them continue execution. It's up to the developer to protect their functions with guards like the one in `new_puzzle`.

---

Let's dive into structs and enums next.

'''
'''--- docs/3.tutorials/crosswords/02-beginner/02-structs-enums.md ---
---
sidebar_position: 3
sidebar_label: "Using structs and enums"
title: "How to think about structs and enums when writing a Rust smart contract on NEAR"
---

import basicCrossword from '/docs/assets/crosswords/basics-crossword.jpg';
import enumBox from '/docs/assets/crosswords/enum-a-d-block--eizaconiendo.near--eiza_coniendo.png';

# Structs and enums

## Overview

### Structs

If you're not familiar with Rust, it may be confusing that there are no classes or inheritance like other programming languages. We'll be exploring how to [use structs](https://doc.rust-lang.org/book/ch05-01-defining-structs.html), which are someone similar to classes, but perhaps simpler.

Remember that there will be only one struct that gets the [`#[near_bindgen]` macro](/sdk/rust/contract-structure/near-bindgen) placed on it; our primary struct or singleton if you wish. Oftentimes the primary struct will contain additional structs that may, in turn, contain more structs in a neat and orderly way. You may also have structs that are used to return data to an end user, like a frontend. We'll be covering both of these cases in this chapter.

### Enums

Enums are short for enumerations, and can be particularly useful if you have entities in your smart contract that transition to different states. For example, say you have a series of blockchain games where players can join, battle, and win. There might be an enumeration for  `AcceptingPlayers`, `GameInProgress`, and `GameCompleted`. Enums are also used to define discrete types of concept, like months in a year.

For our crossword puzzle, one example of an enum is the direction of the clue: either across (A) or down (D) as illustrated below. These are the only two options.

<figure>
    <img src={enumBox} alt="Children's toy of a box that has blocks that only fit certain shapes, resembling the letters A and D. Art created by eizaconiendo.near" width="600"/>
    <figcaption>Art by <a href="https://twitter.com/eiza_coniendo" target="_blank">eizaconiendo.near</a></figcaption>
</figure>
<br/>

Rust has an interesting feature where enums can contain additional data. You can see [examples of that here](https://doc.rust-lang.org/rust-by-example/custom_types/enum.html).

## Using structs

### Storing contract state

We're going to introduce several structs all at once. These structs are addressing a need from the previous chapter, where the puzzle itself was hardcoded and looked like this:

<img src={basicCrossword} alt="Basic crossword puzzle from chapter 1" width="600" />

In this chapter, we want the ability to add multiple, custom crossword puzzles. This means we'll be storing information about the clues in the contract state. Think of a grid where there are x and y coordinates for where a clue starts. We'll also want to specify:

1. Clue number
2. Whether it's **across** or **down**
3. The length, or number of letters in the answer

Let's dive right in, starting with our primary struct:

```rust
#[near(contract_state]
#[derive(PanicOnDefault)]
pub struct Crossword {
    puzzles: LookupMap<String, Puzzle>,  // ‚üµ Puzzle is a struct we're defining
    unsolved_puzzles: UnorderedSet<String>,
}
```

:::note Let's ignore a couple of things‚Ä¶
For now, let's ignore the macros about the structs that begin with `derive` and `near`.
:::

Look at the fields inside the `Crossword` struct above, and you'll see a couple types. `String` is a part of Rust's standard library, but `Puzzle` is something we've created:

```rust
#[near(serializers = [borsh])]
#[derive(Debug)]
pub struct Puzzle {
    status: PuzzleStatus,  // ‚üµ An enum we'll get to soon
    /// Use the CoordinatePair assuming the origin is (0, 0) in the top left side of the puzzle.
    answer: Vec<Answer>,  // ‚üµ Another struct we've defined
}
```

Let's focus on the `answer` field here, which is a vector of `Answer`s. (A vector is nothing fancy, just a bunch of items or a "growable array" as described in the [standard Rust documentation](https://doc.rust-lang.org/std/vec/struct.Vec.html).

```rust
#[near(serializers = [json, borsh])]
#[derive(Debug)]
pub struct Answer {
    num: u8,
    start: CoordinatePair,  // ‚üµ Another struct we've defined
    direction: AnswerDirection,  // ‚üµ An enum we'll get to soon
    length: u8,
    clue: String,
}
```

Now let's take a look at the last struct we'e defined, that has cascaded down from fields on our primary struct: the `CoordinatePair`.

```rust
#[near(serializers = [json, borsh])]
#[derive(Debug)]
pub struct CoordinatePair {
    x: u8,
    y: u8,
}
```

:::info Summary of the structs shown
There are a handful of structs here, and this will be a typical pattern when we use structs to store contract state.

```
Crossword ‚üµ primary struct with #[near(contract_state)]
‚îî‚îÄ‚îÄ Puzzle
   ‚îî‚îÄ‚îÄ Answer
      ‚îî‚îÄ‚îÄ CoordinatePair
```
:::

### Returning data

Since we're going to have multiple crossword puzzles that have their own, unique clues and positions in a grid, we'll want to return puzzle objects to a frontend.  

:::tip Quick note on return values
By default, return values are serialized in JSON unless explicitly directed to use Borsh for binary serialization.

For example, if we call this function:

```rust
pub fn return_some_words() -> Vec<String> {
    vec!["crossword".to_string(), "puzzle".to_string()]
}
```

The return value would be a JSON array:

`["crossword", "puzzle"]`

While somewhat advanced, you can learn more about [changing the serialization here](/sdk/rust/contract-interface/serialization-interface#overriding-serialization-protocol-default).
:::

We have a struct called `JsonPuzzle` that differs from the `Puzzle` struct we've shown. It has one difference: the addition of the `solution_hash` field.

```rust
#[near(serializers = [json])]
pub struct JsonPuzzle {
    /// The human-readable (not in bytes) hash of the solution
    solution_hash: String,  // ‚üµ this field is not contained in the Puzzle struct
    status: PuzzleStatus,
    answer: Vec<Answer>,
}
```

This is handy because our primary struct has a key-value pair where the key is the solution hash (as a `String`) and the value is the `Puzzle` struct.

```rust
pub struct Crossword {
    puzzles: LookupMap<String, Puzzle>,
    //               key ‚Üó        ‚Üñ value
    ‚Ä¶
```

Our `JsonPuzzle` struct returns the information from both the key and the value.

We can move on from this topic, but suffice it to say, sometimes it's helpful to have structs where the intended use is to return data in a more meaningful way than might exist from the structs used to store contract data.

### Using returned objects in a callback

Don't be alarmed if this section feels confusing at this point, but know we'll cover Promises and callbacks later.

Without getting into detail, a contract may want to make a cross-contract call and "do something" with the return value. Sometimes this return value is an object we're expecting, so we can define a struct with the expected fields to capture the value. In other programming languages this may be referred to as "casting" or "marshaling" the value.

A real-world example of this might be the [Storage Management standard](https://nomicon.io/Standards/StorageManagement.html), as used in a [fungible token](https://github.com/near-examples/FT).

Let's say a smart contract wants to determine if `alice.near` is "registered" on the `nDAI` token. More technically, does `alice.near` have a key-value pair for herself in the fungible token contract.

```rust
#[near(serializers = [json])]
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

// ‚Ä¶
// Logic that calls the nDAI token contract, asking for alice.near's storage balance.
// ‚Ä¶

#[private]
pub fn my_callback(&mut self, #[callback] storage_balance: StorageBalance) {
    // ‚Ä¶
}
```

The crossword puzzle will eventually use a cross-contract call and callback, so we can look forward to that. For now just know that if your contract expects to receive a return value that's not a primitive (unsigned integer, string, etc.) and is more complex, you may use a struct to give it the proper type.

## Using enums

In the section above, we saw two fields in the structs that had an enum type:

1.`AnswerDirection` ‚Äî this is the simplest type of enum, and will look familiar from other programming languages. It provides the only two options for how a clue in oriented in a crossword puzzle: across and down.  

```rust
#[near(serializers = [json, borsh])]
#[derive(Debug)]
pub enum AnswerDirection {
    Across,
    Down,
}
```

2. `PuzzleStatus` ‚Äî this enum can actually store a string inside the `Solved` structure. (Note that we could have simply stored a string instead of having a structure, but a structure might make this easier to read.)

As we improve our crossword puzzle, the idea is to give the winner of the crossword puzzle (the first person to solve it) the ability to write a memo. (For example: "Took me forever to get clue six!", "Alice rules!" or whatever.)

```rust
#[near(serializers = [json, borsh])]
#[derive(Debug)]
pub enum PuzzleStatus {
    Unsolved,
    Solved { memo: String },
}
```

'''
'''--- docs/3.tutorials/crosswords/02-beginner/03-actions.md ---
---
sidebar_position: 4
sidebar_label: "Actions and sending NEAR"
title: "There are several Actions an account can do, including sending the winner of the crossword puzzle NEAR using the Transfer Action"
---
import {Github} from "@site/src/components/codetabs"

import allActions from '/docs/assets/crosswords/crossword-actions.png';
import transferNEAR from '/docs/assets/crosswords/transfer-brand-blue--qiqi04.near--blankworl.png';
import yoctoNEAR from '/docs/assets/crosswords/yoctoNEAR-magnifying--jrbemint.near--JrbeMad.jpg';
import signerPredecessorCurrent from '/docs/assets/crosswords/predecessor-signer-current--yasuoarts.near--YasuoArt69.png';

# Actions (including sending NEAR)

We're going to introduce a new Action: `Transfer`. In this chapter, we'd like the first person to solve the crossword puzzle to earn some prize money, sent in NEAR.

<figure>
    <img src={transferNEAR} alt="Two hands exchanging a coin emblazoned with the NEAR Protocol logo. Art created by qiqi04.near" width="400"/>
    <figcaption className="small">Art by <a href="https://twitter.com/blankworl" target="_blank">qiqi04.near</a></figcaption>
</figure>
<br/>

We've already used Actions in the [previous chapter](../01-basics/03-hashing-and-unit-tests.md#using-batch-actions), when we deployed and initialized the contract, which used the `DeployContract` and `FunctionCall` Action, respectively.

The full list of Actions are available at the [NEAR specification site](https://nomicon.io/RuntimeSpec/Actions.html).

By the end of this entire tutorial we'll have used all the Actions highlighted below:

<img src={allActions} alt="All Actions that will be used when the entire crossword puzzle tutorial is complete" width="600"/>

## Actions from within a contract

When we deployed and initialized the contract, we used NEAR CLI in our Terminal or Command Prompt app. At a high level, this might feel like we're lobbing a transaction into the blockchain, instructing it to do a couple actions.

It's important to note that you can also execute Actions inside a smart contract, which is what we'll be doing. In the sidebar on the left, you'll see a section called [**Promises**](/sdk/rust/promises/intro), which provides examples of this. Perhaps it's worth mentioning that for the Rust SDK, Promises and Actions are somewhat synonymous.

:::note Actions only effect the current contract
A contract cannot use the `AddKey` Action on another account, including the account that just called it. It can only add a key to *itself*, if that makes sense.

The same idea applies for the other actions as well. You cannot deploy a contract to someone else's account, or delete a different account. (Thankfully üòÖ)

Similarly, when we use the `Transfer` Action to send the crossword puzzle winner their prize, the amount is being subtracted from the account balance of the account where the crossword contract is deployed.

The only interesting wrinkle (and what may *seem like* an exception) is when a subaccount is created using the `CreateAccount` Action. During that transaction, you may use Batch Actions to do several things like deploy a contract, transfer NEAR, add a key, call a function, etc. This is common in smart contracts that use a factory pattern, and we'll get to this in future chapters of this tutorial.
:::

## Define the prize amount

Let's make it simple and hardcode the prize amount. This is how much NEAR will be given to the first person who solves the crossword puzzle, and will apply to all the crossword puzzles we add. We'll make this amount adjustable in future chapters.

At the top of the `lib.rs` file we'll add this constant:

<Github language="rust" start="10" end="11" url="https://github.com/near-examples/crossword-tutorial-chapter-2/blob/1909630a10291081cb00b2780c1ae8889d98f620/contract/src/lib.rs" />

As the code comment mentions, this is 5 NEAR, but look at all those zeroes in the code!

That's the value in yoctoNEAR. This concept is similar to other blockchains. Bitcoin's smallest unit is a satoshi and Ethereum's is a wei.

<figure>
    <img src={yoctoNEAR} alt="Depiction of bills of NEAR, coins for partial NEAR, and then a magnifying glass showing a tiny yoctoNEAR next to an ant. Art created by jrbemint.near"/>
    <figcaption className="full-width">Art by <a href="https://twitter.com/JrbeMad" target="_blank">jrbemint.near</a></figcaption>
</figure>

## Adding `Transfer`

In the last chapter we had a simple function called `guess_solution` that returned `true` if the solution was correct, and `false` otherwise. We'll be replacing that function with `submit_solution` as shown below:

<Github language="rust" start="92" end="124" url="https://github.com/near-examples/crossword-tutorial-chapter-2/blob/83d4d8925e6d30e04e8e4cb5e9a0a6d3763fce40/contract/src/lib.rs" />

Note the last line in this function, which sends NEAR to the predecessor.

:::info Returning a Promise
The last line of the function above ends with a semicolon. If the semicolon were removed, that would tell Rust that we'd like to return this Promise object.

It would be perfectly fine to write the function like this:

```rust
pub fn submit_solution(&mut self, solution: String, memo: String) -> Promise {
    // ‚Ä¶
    // Transfer the prize money to the winner
    Promise::new(env::predecessor_account_id()).transfer(PRIZE_AMOUNT)
}
```
:::

## Predecessor, signer, and current account

When writing a smart contract you'll commonly want to use `env` and the details it provides. We used this in the last chapter for:

- logging (ex: `env::log_str("hello friend")`)
- hashing using sha256 (ex: `env::sha256(solution.as_bytes())`)

There are more functions detailed in the [SDK reference docs](https://docs.rs/near-sdk/latest/near_sdk/env/index.html).

Let's cover three commonly-used functions regarding accounts: predecessor, signer, and current account.

<figure>
    <img src={signerPredecessorCurrent} alt="Illustration of Alice sending a transaction to a smart contract named Banana, which does a cross-contract call to the smart contract Cucumber. Art created by yasuoarts.near"/>
    <figcaption className="full-width">Alice sends a transaction to the contract on banana.near, which does a cross-contract call to cucumber.near.<br/>From the perspective of a contract on cucumber.near, we see a list of the predecessor, signer, and current account.<br/>Art by <a href="https://twitter.com/YasuoArt69" target="_blank">yasuoarts.near</a></figcaption>
</figure><br/><br/>

1. [predecessor account](https://docs.rs/near-sdk/latest/near_sdk/env/fn.predecessor_account_id.html) ‚Äî `env::predecessor_account_id()`

    This is the account that was the immediate caller to the smart contract. If this is a simple transaction (no cross-contract calls) from **alice.near** to **banana.near**, the smart contract at **banana.near** considers Alice the predecessor. In this case, Alice would *also* be the signer.

    :::tip When in doubt, use predecessor
    As we explore the differences between predecessor and signer, know that it's a more common **best practice to choose the predecessor**. 

    Using the predecessor guards against a potentially malicious contract trying to "fool" another contract that only checks the signer. 
    :::

2. [signer account](https://docs.rs/near-sdk/latest/near_sdk/env/fn.signer_account_id.html) ‚Äî `env::signer_account_id()`

    The signer is the account that originally *signed* the transaction that began the blockchain activity, which may or may not include cross-contract calls. If a function calls results in several cross-contract calls, think of the signer as the account that pushed over the first domino in that chain reaction.

    :::caution Beware of middlemen
    If your smart contract is checking the ownership over some assets (fungible token, NFTs, etc.) it's probably a bad idea to use the signer account.

    A confused or malicious contract might act as a middleman and cause unexpected behavior. If **alice.near** accidentally calls **evil.near**, the contract at that account might do a cross-contract call to **vulnerable-nft.near**, instructing it to transfer an NFT.

    If **vulnerable-nft.near** only checks the signer account to determine ownership of the NFT, it might unwittingly give away Alice's property. Checking the predecessor account eliminates this problem.
    :::

3. [current account](https://docs.rs/near-sdk/latest/near_sdk/env/fn.current_account_id.html) ‚Äî `env::current_account_id()`

    The current account is "me" from the perspective of a smart contract.

    :::tip Why would I use that?
    There might be various reasons to use the current account, but a common use case is checking ownership or handling callbacks to cross-contract calls. 
    
    Many smart contracts will want to implement some sort of permission system. A common, rudimentary permission allows certain functions to only be called by the contract owner, AKA the person who owns a private key to the account for this contract.

    The contract can check that the predecessor and current account are the same, and trust offer more permissions like changing contract settings, upgrading the contract, or other privileged modifications.
    :::
'''
'''--- docs/3.tutorials/crosswords/02-beginner/04-adding-a-puzzle.md ---
---
sidebar_position: 4
sidebar_label: "Add a puzzle"
title: "Adding a new puzzle now that we're using a collection that can contain multiple crossword puzzles"
---

import blankCrossword from '/docs/assets/crosswords/chapter-2-crossword-blank.png';
import teachingDeployment from '/docs/assets/crosswords/teaching-just-teacher--herogranada.near--GranadaHero.jpeg';
import recreatingSubaccount from '/docs/assets/crosswords/erase-recreate-subaccount--3one9.near--3one92.gif';

# Adding a puzzle

We're going to make a new puzzle, which means we need to provide the smart contract with a set of clues and info about the answers.

Of course, we'll not be sending the *answers* to the smart contract, otherwise everyone could see. We will, however, send details about each clue, including:

- The clue number
- Whether it's a down or across clue
- The coordinates (x and y position)
- The length of the clue. (How many letters)

Essentially, we're going to tell the smart contract enough information for an empty puzzle like this:

<img src={blankCrossword} alt="Blank crossword for chapter 2 of the crossword puzzle smart contract tutorial" width="600"/>
<br/>

(Note that we aren't showing the human-readable clues in the above screenshot, but we will provide that as well.)

## Building and deploying

Let's use the same steps we learned from the first chapter:

<figure>
    <img src={teachingDeployment} alt="Teacher shows chalkboard with instructions on how to properly deploy a smart contract. 1. Build smart contract. 2. Create a subaccount (or delete and recreate if it exists) 3. Deploy to subaccount. 4. Interact. Art created by herogranada.near" width="600"/>
    <figcaption>Art by <a href="https://twitter.com/GranadaHero" target="_blank">herogranada.near</a></figcaption>
</figure>
<br/>

Navigate to the `contract` directory, then run the build script for your system:

    ./build.sh

If following from the previous chapter, you'll likely have a subaccount already created. For the purpose of demonstration, we're calling the subaccount (where we deploy the contract) `crossword.friend.testnet` and the parent account is thus `friend.testnet`.

Let's delete the subaccount and recreate it, to start from a blank slate.

<figure>
    <img src={recreatingSubaccount} alt="Animation of an alien in space with a computer deleting and re-writing the account crossword.friend.testnet Art by 3one9.near" width="600"/>
    <figcaption>Art by <a href="https://twitter.com/3one92" target="_blank">3one9.near</a></figcaption>
</figure>
<br/>

Here's how to delete and recreate the subaccount using NEAR CLI:

```bash
# Delete the subaccount and send remaining balance to friend.testnet
near delete crossword.friend.testnet friend.testnet
# Create the subaccount again 
near create-account crossword.friend.testnet --masterAccount friend.testnet
# Deploy, calling the "new" method with the parameter for owner_id
near deploy crossword.friend.testnet --wasmFile res/crossword_tutorial_chapter_2.wasm --initFunction new --initArgs '{"owner_id": "crossword.friend.testnet"}'
```

Now we're ready to construct our new crossword puzzle and add it via the `new_puzzle` method. Let's start with the clues for this new puzzle.

## The clues

We're going to use these clues below for our improved puzzle. The **Answer** column will not get sent to the smart contract when we call `new_puzzle`.

| Number | Answer    | Clue | (x, y) coords | length |
| ----------- | ----------- | ----------- | ----------- | ----------- |
| 1 | paras | NFT market on NEAR that specializes in cards and comics. | (1, 1) | 5 |
| 2 | rainbowbridge | You can move assets between NEAR and different chains, including Ethereum, by visiting ______.app | (0, 2) | 13 |
| 3 | mintbase | NFT market on NEAR with art, physical items, tickets, and more. | (9, 1) | 8 |
| 4 | yoctonear | The smallest denomination of the native token on NEAR. | (3, 8) | 9 |
| 5 | cli | You typically deploy a smart contract with the NEAR ___ tool. | (5, 8) | 3 |

The x and y coordinates have their origin in the upper-left side of the puzzle grid, and each row and column start at 0.

## Solution hash

Let's derive the sha256 hash using an [easy online tool](https://www.wolframalpha.com/input/?i=sha256+%22paras+rainbowbridge+mintbase+yoctonear+cli%22) (there are many other offline methods as well) to discover the solution hash:

    d1a5cf9ad1adefe0528f7d31866cf901e665745ff172b96892693769ad284010

## Add the puzzle

Add a new puzzle using NEAR CLI with this long command, replacing `crossword.friend.testnet` with your subaccount:

```
near call crossword.friend.testnet new_puzzle '{
  "solution_hash": "d1a5cf9ad1adefe0528f7d31866cf901e665745ff172b96892693769ad284010",
  "answers": [
   {
     "num": 1,
     "start": {
       "x": 1,
       "y": 1
     },
     "direction": "Down",
     "length": 5,
     "clue": "NFT market on NEAR that specializes in cards and comics."
   },
   {
     "num": 2,
     "start": {
       "x": 0,
       "y": 2
     },
     "direction": "Across",
     "length": 13,
     "clue": "You can move assets between NEAR and different chains, including Ethereum, by visiting ______.app"
   },
   {
     "num": 3,
     "start": {
       "x": 9,
       "y": 1
     },
     "direction": "Down",
     "length": 8,
     "clue": "NFT market on NEAR with art, physical items, tickets, and more."
   },
   {
     "num": 4,
     "start": {
       "x": 3,
       "y": 8
     },
     "direction": "Across",
     "length": 9,
     "clue": "The smallest denomination of the native token on NEAR."
   },
   {
     "num": 5,
     "start": {
       "x": 5,
       "y": 8
     },
     "direction": "Down",
     "length": 3,
     "clue": "You typically deploy a smart contract with the NEAR ___ tool."
   }
  ]
}' --accountId crossword.friend.testnet
```

Note that our contract name and the account we're calling this from are both `crossword.friend.testnet`. That's because we added a check at the top of `new_puzzle` to make sure the predecessor is the `owner_id`.

Now our smart contract has information about this second crossword puzzle.

Let's explore how to make our frontend have a login button and truly turn this into a decentralized app (dApp)!

'''
'''--- docs/3.tutorials/crosswords/02-beginner/05-logging-in.md ---
---
sidebar_position: 5
sidebar_label: "Access keys and login 1/2"
title: "Covering access keys and login"
---

import chapter1Correct from '/docs/assets/crosswords/chapter-1-crossword-correct.gif';
import accessKeys from '/docs/assets/crosswords/keys-cartoon-good--alcantara_gabriel.near--Bagriel_5_10.png';
import functionCallAction from '/docs/assets/crosswords/function-call-action.png';
import tutorialAccessKeys from '/docs/assets/crosswords/access-keys.png';

# Logging in with NEAR

## Previously‚Ä¶

In the previous chapter we simply displayed whether the crossword puzzle was solved or not, by checking the solution hash against the user's answers.

<img src={chapter1Correct} width="600"/><br/><br/>

## Updates to transfer prize money

In this chapter, our smart contract will send 5 ‚ìÉ to the first person who solves the puzzle. For this, we're going to require the user to have a NEAR account and log in.

:::note Better onboarding to come
Later in this tutorial we won't require the user to have a NEAR account.

Since logging in is important for many decentralized apps, we'll show how this is done in NEAR and how it's incredibly unique compared to other blockchains.
:::

This transfer will occur when the first user to solve the puzzle calls the `submit_solution` method with the solution. During the execution of that function it will check that the user submitted the correct answer, then transfer the prize.

We'll be able to see this transfer (and other steps that occurred) in [NearBlocks Explorer](https://testnet.nearblocks.io).

But first let's talk about one of the most interesting superpowers of NEAR: access keys.

## Access keys

You might be familiar with other blockchains where your account name is a long string of numbers and letters. NEAR has an account system where your name is human-readable, like `friend.testnet` for testnet or `friend.near` for mainnet.

You can add (and remove) keys to your account on NEAR. There are two types of keys: full and function-call access keys.

The illustration below shows a keychain with a full-access key (the large, gold one) and two function-call access keys.

<figure>
    <img src={accessKeys} width="600" alt="A keychain with three keys. A large, gold key represents the full-access keys on NEAR. The two other keys are gray and smaller, and have detachable latches on them. They represent function-call access key. Art created by alcantara_gabriel.near" />
    <figcaption>Art by <a href="https://twitter.com/Bagriel_5_10" target="_blank">alcantara_gabriel.near</a></figcaption>
</figure>

### Full-access keys

Full-access keys are the ones you want to protect the most. They can transfer all the funds from your account, delete the account, or perform any of the other [Actions on NEAR](03-actions.md).

When we used the `near login` command in the [previous chapter](../01-basics/01-set-up-skeleton.md#creating-a-new-key-on-your-computer), that command asked the full-access key in the NEAR Wallet to use the `AddKey` Action to create another full-access key: the one we created locally on our computer. NEAR CLI uses that new key to deploy, make function calls, etc.

### Function-call access keys

Function-call access keys are sometimes called "limited access keys" because they aren't as powerful as the full access keys.

A Function-call access key will specify:

- What contract it's allowed to call
- What method name(s) it's allowed to call (you can also specify all functions)
- How much allowance it's allowed to use on these function calls

It's only allowed to perform the `FunctionCall` Action.

<img src={functionCallAction} alt="List of NEAR Actions with a highlight on the FunctionCall Action" width="600"/>

### Example account with keys

Let's look at this testnet account that has one full-access key and two function-call access keys. As you can see, we use the NEAR CLI [command `keys`](https://docs.near.org/tools/near-cli#near-keys) to print this info.

<img src={tutorialAccessKeys} alt="Terminal screen showing the access keys for an account, there is one full-access key and two function-call access keys"/>

Let's look deeper into each key.

#### First key

```js
{
  access_key: {
    nonce: 72772126000000, // Large nonce, huh!
      permission: {
      FunctionCall: {
        allowance: '777000000000000000000000000', // Equivalent to 777 NEAR
          method_names: [], // Any methods can be called
          receiver_id: 'puzzle.testnet' // This key can only call methods on puzzle.testnet
      }
    }
  },
  public_key: 'ed25519:9Hhm77W4KCFzFgK55sZgEMesYRaL8wV1kpqh8qntnSPV'
}
```

The first key in the image above is a function-call access key that can call the smart contract `puzzle.testnet` on **any method**. If you don't specify which methods it's allowed to call, it is allowed to call them all. Note the empty array (`[]`) next to `method_names`, which indicates this.

We won't discuss the nonce too much, but know that in order to prevent the possibility of [replay attacks](https://en.wikipedia.org/wiki/Replay_attack), the nonce for a newly-created key is large and includes info on the block height as well as a random number.

The allowance is the amount, in yoctoNEAR, that this key is allowed to use during function calls. This **cannot** be used to transfer NEAR. It can only be used in gas for function calls.

The allowance on this key is intentionally large for demonstration purposes. `777000000000000000000000000` yoctoNEAR is `777` NEAR, which is unreasonably high for an access key. So high, in fact, that it exceeded the amount of NEAR on the contract itself when created. This shows that you can create an access key that exceeds the account balance, and that it doesn't subtract the allowance at the time of creation.

So the key is simply allowed to use the allowance in NEAR on gas, deducting from the account for each function call.

#### Second key

```js
{
  access_key: {
    nonce: 72777733000000,
    permission: {
      FunctionCall: {
        allowance: '250000000000000000000000', // 0.25 NEAR, which is a typical allowance
        method_names: [ 'foo', 'bar' ], // Can call methods foo and bar only
        receiver_id: 'puzzle.testnet'
      }
    }
  },
  public_key: 'ed25519:CM4JtNo2sL3qPjWFn4MwusMQoZbHUSWaPGCCMrudZdDU'
},
```

This second key specifies which methods can be called, and has a lower allowance.

Note that the allowance for this key (a quarter of a NEAR) is the default allowance when a person "logs in" in with the NEAR Wallet.

In NEAR, "logging in" typically means adding a key like this to your account. We'll cover this more in a moment.

#### Third key

```js
{
  access_key: { nonce: 72770704000019, permission: 'FullAccess' },
  public_key: 'ed25519:FG4HjEPsvP5beScC3hkTLztQH8k9Qz9maTaumvPDa5t3'
}
```

The third key is a full-access key.

Since this key can perform all the Actions, there aren't additional details or restrictions like the function-call access keys we saw.

## What does "log in" mean in a blockchain context?

Let's take a step back from NEAR and talk about how login works broadly using web3 wallets.

A web3 wallet (like Ethereum's MetaMask, Cosmos's Keplr, or the NEAR Wallet) stores a private key for an account. When interacting with decentralized apps, a user will typically use the wallet to sign transactions and send them to the blockchain for processing.

However, web3 wallets can also be used to sign any kind of message, and it doesn't need to send anything to the blockchain. This is sometimes called "offline signing" and protocols will sometimes create standards around how to sign data.

In other ecosystems, the idea of "logging in" with a web3 wallet uses this offline signing. A user is asked to sign a structured message and a backend can confirm that the message was signed by a given account.

NEAR keys can also sign and verify messages in this manner. In fact, there are a couple simple examples of how to achieve this in the [`near-api-js` cookbook](https://github.com/near/near-api-js/blob/master/packages/cookbook/utils/verify-signature.js).

There are potential drawbacks to this offline signing technique, particularly if a signed message gets intercepted by a malicious party. They might be able to send this signature to a backend and log in on your behalf. Because this all takes place offline, there's no mechanism on-chain to revoke your login or otherwise control access. We quickly see that using a web3 wallet for signed typed data runs into limitations.

So signing a message is fine, but what if we could do better?

With NEAR, we can leverage access keys to improve a user's login experience and give the power back to the user.

If I log into the [Guest Book example site](https://github.com/near-examples/guest-book-examples/tree/main/frontend), I create a unique key just for that dApp, adding it to my account. When I'm done I can remove the key myself. If I suspect someone has control of my key (if a laptop is stolen, for example) I can remove the key as long as I have a full-access key in my control.

Logging in with NEAR truly gives the end user control of their account and how they interact with dApps, and does so on the protocol level.

---

The concept of access keys is so important that we've spent longer than usual on the topic without actually implementing code for our improved crossword puzzle.

Let's move to the next section and actually add the login button.  

'''
'''--- docs/3.tutorials/crosswords/02-beginner/06-logging-in-implementation.md ---
---
sidebar_position: 6
sidebar_label: "Access keys and login 2/2"
title: "Implementing the login button"
---
import {Github} from "@site/src/components/codetabs"

import loggingIn from '/docs/assets/crosswords/logging-in.png';
import explorerTransfer from '/docs/assets/crosswords/chapter-2-explorer-transfer.jpg';

# Add the login functionality

## Plan

We're going to add a login button that uses `near-api-js` to login with NEAR.

Below is the workflow of logging in: 

<img src={loggingIn} alt="Three steps to logging in. 1. click the login button we will build. 2. It creates a private key in the browser local storage. 3. Redirected to NEAR Wallet where you sign, creating a new key"/><br/><br/>

1. User clicks the login button
2. `near-api-js` creates a private key in the browser
3. A redirect to NEAR Wallet occurs, passing the public key. NEAR Wallet (often) has a full-access key capable of the `AddKey` action. The user follows a wizard, ultimately authorizing the creation of a new key.

## Adding the button

In the `src` directory we'll look at:

- `index.js`
- `App.js`

We won't go over every change, but instead point to the new logic.

First we set up a `WalletConnection` object from our JavaScript library:

<Github language="js" start="12" end="20" url="https://github.com/near-examples/crossword-tutorial-chapter-2/blob/1d64bf29c3376a18c71e5c5a075e29824d7a55f5/src/index.js" />

It's then used in React:

```js
const signIn = () => {
  walletConnection.requestSignIn(
    nearConfig.contractName,
    '', // title. Optional, by the way
    '', // successUrl. Optional, by the way
    '', // failureUrl. Optional, by the way
  );
};

const signOut = () => {
  walletConnection.signOut();
  ‚Ä¶
};

‚Ä¶

return (
  <div id="page">
    <h1>NEAR Crossword Puzzle</h1>
    <div id="crossword-wrapper">
      <div id="login">
        { currentUser
          ? <button onClick={signOut}>Log out</button>
          : <button onClick={signIn}>Log in</button>
        }
      </div>
      ‚Ä¶
    </div>
  </div>
);
```

Once logged in, that `WalletConnection` object will be tied to the logged-in user, and they'll use that key to sign transactions and interact with the contract.

:::info Transactions that redirect to NEAR Wallet
In our improved crossword puzzle, the function-call access key for the logged-in user will be signing a transaction to submit their solution.

You may notice, however, that sometimes you'll be redirected to NEAR Wallet, and other times you aren't.

This goes back to an earlier rule we mentioned: function-call access keys cannot send NEAR. They cannot perform the `Transfer` Action.

If a function call requires even 1 yoctoNEAR, NEAR Wallet (or any other wallet containing a full-access key) is required to sign the transaction.
:::

## Call the contract function from JavaScript

The frontend code contains a check to see if the user has completed the crossword puzzle successfully. In there we'll add logic to call the `submit_solution` function on the smart contract.

```js
// Send the 5 NEAR prize to the logged-in winner
let functionCallResult = await walletConnection.account().functionCall({
  contractId: nearConfig.contractName,
  methodName: 'submit_solution',
  args: {solution: seedPhrase, memo: "Yay I won!"},
  gas: DEFAULT_FUNCTION_CALL_GAS, // optional param, by the way
  attachedDeposit: 0,
  walletMeta: '', // optional param, by the way
  walletCallbackUrl: '' // optional param, by the way
});

if (functionCallResult && functionCallResult.transaction && functionCallResult.transaction.hash) {
  // Display a link the NEAR Explorer
  console.log('Transaction hash for explorer', functionCallResult.transaction.hash)
}
```

:::tip try‚Ä¶catch blocks
It's not a bad idea to wrap these type of calls in try‚Ä¶catch blocks to properly handle any errors that come from the blockchain.

These errors can be quite helpful to the developer and the end user.
:::

## Fetch the puzzle, finish up

In the previous chapter, the frontend had a hardcoded file containing information about the clues for a simple crossword puzzle. In this chapter, we've given the coordinates and details about the clues, but the frontend needs to fetch this information.

We're going to modify the logic surrounding our view-only call to `get_unsolved_puzzles` on the contract. This method now returns the clue information, so we've implemented a function that puts it in the proper format for React to construct the crossword puzzle.

This is a tutorial about Rust smart contract development, so we won't focus on the details of this, but know we've added the function `mungeBlockchainCrossword`. This allows us to keep adding custom crossword puzzles and have the frontend be dynamic.

We'll also make other minor changes like adding a page for when there are no puzzles available, and adding a loading screen.

## Run the React app

If you've been following this guide closely, you'll likely just need to start the React app with:

    env CONTRACT_NAME=crossword.friend.testnet npm run start

As a helpful reminder, below has the steps necessary to recreate the subaccount, build the contract, deploy the subaccount, and call methods on the contract:

```bash
# Go into the directory containing the Rust smart contract we've been working on
cd contract

# Build (for Windows it's build.bat)
./build.sh

# Create fresh account if you wish, which is good practice
near delete crossword.friend.testnet friend.testnet
near create-account crossword.friend.testnet --masterAccount friend.testnet

# Deploy
near deploy crossword.friend.testnet --wasmFile res/crossword_tutorial_chapter_2.wasm --initFunction new --initArgs '{"owner_id": "crossword.friend.testnet"}'
# Add the crossword puzzle
near call crossword.friend.testnet new_puzzle '{"solution_hash":"d1a5cf9ad1adefe0528f7d31866cf901e665745ff172b96892693769ad284010","answers":[{"num": 1,"start": {"x": 1,"y": 1},"direction": "Down","length": 5,"clue": "NFT market on NEAR that specializes in cards and comics."},{"num": 2,"start": {"x": 0,"y": 2},"direction": "Across","length": 13,"clue": "You can move assets between NEAR and different chains, including Ethereum, by visiting ______.app"},{"num": 3,"start": {"x": 9,"y": 1},"direction": "Down","length": 8,"clue": "NFT market on NEAR with art, physical items, tickets, and more."},{"num": 4,"start": {"x": 3,"y": 8},"direction": "Across","length": 9,"clue": "The smallest denomination of the native token on NEAR."},{"num": 5,"start": {"x": 5,"y": 8},"direction": "Down","length": 3,"clue": "You typically deploy a smart contract with the NEAR ___ tool."}]}' --accountId crossword.friend.testnet
  
# Return to the project root and start the React app
cd ..
env CONTRACT_NAME=crossword.friend.testnet npm run start
```

## For kicks

For fun, try interacting with the smart contract using the React frontend and the CLI. We can check the status of the puzzle using the CLI, solve the puzzle with the frontend, and check the status again.

Before and after solving the puzzle, run this command:

```bash
    near view crossword.friend.testnet get_puzzle_status '{"solution_hash": "d1a5cf9ad1adefe0528f7d31866cf901e665745ff172b96892693769ad284010"}'
```

This will return our enum `PuzzleStatus`. Before solving the puzzle it should print:

```json
    'Unsolved'
```

and after:

```json
    { Solved: { memo: 'Yay I won!' } }
```

After you solve the crossword puzzle you'll see a screen with a link to NEAR Explorer to look at the details of the transaction. Notice we have our `Transfer` Action in there:

<figure>
    <img src={explorerTransfer} alt="Screenshot from the NEAR Explorer highlighting a place in the transaction where 5 NEAR is sent to mike.testnet"/>
</figure>
<br/>

---

That's it for this chapter! As a reminder the full code is available at:

https://github.com/near-examples/crossword-tutorial-chapter-2

'''
'''--- docs/3.tutorials/crosswords/03-intermediate/00-overview.md ---
---
sidebar_position: 1
sidebar_label: "Overview"
title: "Intermediate concepts (cross-contract calls and more)"
---

import accessKeys from '/docs/assets/crosswords/keys-cartoon-good--alcantara_gabriel.near--Bagriel_5_10.png';

# Intermediate concepts

This chapter will go a bit faster than the previous ones.

We're going to be covering an important part of smart contract development: cross-contract calls.

## Cross-contract calls

A cross-contract call is when a smart contract calls another smart contract. For instance, if `alice.near` calls contract A, and contract A makes a call to contract B.

NEAR has asynchronous transactions, and some cross-contract calls will have callbacks in order to determine the result of the call. This works a bit different from other blockchains, as we'll explain more in this chapter.

## Access keys

Last chapter covered access keys, and we implemented a login system where a user "logs in" by adding a function-call access key to their account which is tied to the crossword puzzle dApp.

Login is a common use case for access keys, but let's think bigger!

Remember the two (smaller, gray) function-call access keys from the keychain illustration?

<figure>
    <img src={accessKeys} width="600" alt="A keychain with three keys. A large, gold key represents the full-access keys on NEAR. The two other keys are gray and smaller, and have detachable latches on them. They represent function-call access key. Art created by alcantara_gabriel.near" />
    <figcaption>Art by <a href="https://twitter.com/Bagriel_5_10" target="_blank">alcantara_gabriel.near</a></figcaption>
</figure><br/>

Notice that they have a clasp to make them removable.

While it's unlikely you'll want to give another person a full-access key, there are times when you could give a function-call access key to another person or make it public. Why? This can help enable a smooth onboarding experience, as we'll do soon.

## Completed project

Here's the final code for this chapter:

https://github.com/near-examples/crossword-tutorial-chapter-3

'''
'''--- docs/3.tutorials/crosswords/03-intermediate/01-access-key-solution.md ---
---
sidebar_position: 2
sidebar_label: "Solution as seed phrase"
title: "Replacing the solution hash with an access key"
---

import puzzleFrontrun from '/docs/assets/crosswords/puzzle-frontrun.png';
import padlockSafe from '/docs/assets/crosswords/safe-with-access-key--soulless.near--ZeroSerotonin__.png';

# Replacing our solution hash

So far in this tutorial, the user sends the plaintext solution to the crossword puzzle smart contract, where it's hashed and compared with the known answer.

This works, but we might want to be more careful and avoid sending the plaintext solution.

## Why?

Blockchains rely on many computers processing transactions. When you send a transaction to the blockchain, it doesn't immediately get processed. In some Layer 1 blockchains it can take minutes or longer. On NEAR transactions settle within a couple seconds, but nonetheless there's a small period of waiting time.

When we previously sent the crossword puzzle solution in plain text (via the parameter `solution` to `submit_solution`) it means it's visible to everyone before it gets processed.

At the time of this writing, there haven't been outstanding incidents of validators "front-running" transactions, but it's something to be aware of. Front-running is when a validator sees a transaction that might be profitable and does it themselves.

There have been several incidents of this and it continues to be an issue.

<figure>
    <img src={puzzleFrontrun} alt="Tweet talking about a puzzle where tens of thousands of dollars were taken because of a frontrun attack" width="600"/>
    <figcaption>Real-life example of a puzzle being front-run.<br/>Read <a href="https://twitter.com/_anishagnihotri/status/1444113372715356162" target="_blank">Anish Agnihotri's thread</a></figcaption>
</figure>
<br/>

## How?

We're doing to do something unique ‚Äî and frankly unusual ‚Äî with our crossword puzzle. We're going to use function-call access keys in a new way.

Our crossword puzzle smart contract will add a function-call access key to itself. The private key is derived from the solution, used as a seed phrase.

:::info What's a seed phrase, again?
A private key is essentially a very large number. So large that the number of possible private keys is approaching the estimated number of atoms in the known universe.

It would be pretty long if we wrote it down, so it's often made human-readable with numbers and letters. However, even the human-readable version is hard to memorize and prone to mistakes.

A seed phrase is a series of words (usually 12 or 24 words) that create a private key. (There's actually a [bit more to it](https://learnmeabitcoin.com/technical/mnemonic).)

Seed phrases typically use a [BIP-30 wordlist](https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md), but *they do not need to* use a wordlist or have a certain number of words. As long as the words create entropy, a crossword puzzle solution can act as a deterministic seed phrase.
:::

So when we add a new puzzle, we'll use the `AddKey` Action to add a limited, function-call access key can that *only* call the `submit_solution` method.

The first user to solve the puzzle will essentially "discover" the private key and call that method. Think of it like a safe that contains a function-call access key.

<figure>
    <img src={padlockSafe} alt="A small safe with a padlock containing words to a seed phrase, and you can see through the safe, showing it holds a function-call access key. Art created by soulless.near."/>
    <figcaption className="full-width">Open the safe using answers to the puzzle, revealing the function-call access key.<br/>Art by <a href="https://twitter.com/ZeroSerotonin__" target="_blank">soulless.near</a></figcaption>
</figure><br/>

Our method `submit_solution` no longer needs to hash the plaintext answer, but instead looks at the key that signed this transaction. Cool, huh!

## Onboarding

In the previous chapter we implemented login to the crossword, but this requires a person to have a NEAR account.

If the end user is discovering a key that exists on the crossword contract, they don't even need a NEAR account, right? Well, that's partly accurate, but we'll still need to send the prize in NEAR somewhere.

What if we could make the winner an account on the fly? Is that possible? Yes, and that's what we're going to do in this chapter.

'''
'''--- docs/3.tutorials/crosswords/03-intermediate/02-use-seed-phrase.md ---
---
sidebar_position: 3
sidebar_label: "Seed phrase logic"
title: "Implementing the seed phrase logic from the necessary libraries"
---

# Seed phrase and key derivation

There are two separate things we'll want to do:

1. **Create a random seed phrase** for the user when they visit the crossword puzzle. This will be used if they win and don't have a NEAR account and wish to create one. They can then paste this seed phrase into NEAR Wallet afterward to import their account (which is basically like "logging in" and is currently possible at https://testnet.mynearwallet.com/recover-seed-phrase).
2. **Turn the crossword solution into a key pair**, instead of just hashing it.

## near-seed-phrase library

We can add the `near-seed-phrase` package to our project with:

    npm install near-seed-phrase --save

:::note Code snippets for this chapter
At this point in the tutorial, it's more difficult to share code snippets that are both meaningful and meant to be copy/pasted into a project.

The snippets provided might differ slightly from the implementation of the [completed code for chapter 3](https://github.com/near-examples/crossword-tutorial-chapter-3), which might be the best place to look for the functioning code.
:::

## Generate random seed phrase for new account creation (if the winner doesn't already have an account)

```js
import { generateSeedPhrase } from 'near-seed-phrase';

// Create a random key in here
let seedPhrase = generateSeedPhrase(); // generateSeedPhrase() returns an object {seedPhrase, publicKey, secretKey}
localStorage.setItem('playerKeyPair', JSON.stringify(seedPhrase));
```

## Parse solution as seed phrase 

(This security measure prevents front-running.)

```js
import { parseSeedPhrase } from 'near-seed-phrase';
// Get the seed phrase from the completed puzzle. 
// The original puzzle creator would have already called this same function with the same inputs and would have 
// already called `AddKey` on this contract to add the key related to this seed phrase. Here, using this deterministic 
// function, the front-end will automatically generate that same key based on the inputs from the winner.
const seedPhrase = parseSolutionSeedPhrase(data, gridData); // returns a string of space-separated words
// Get the public and private key derived from the seed phrase
const {secretKey, publicKey} = parseSeedPhrase(seedPhrase);

// Set up the account and connection, acting on behalf of the crossword account
const keyStore = new nearAPI.keyStores.InMemoryKeyStore(); // Another type of key
const keyPair = nearAPI.utils.key_pair.KeyPair.fromString(secretKey);
await keyStore.setKey(nearConfig.networkId, nearConfig.contractName, keyPair);
nearConfig.keyStore = keyStore;
const near = await nearAPI.connect(nearConfig);
const crosswordAccount = await near.account(nearConfig.contractName);

// Call the submit_solution method using the discovered function-call access key
let transaction = await crosswordAccount.functionCall(‚Ä¶);
```

The last line should look familiar. We did something similar in the last chapter, except we used the `WalletConnection`'s account to do the function call.

This time we're using an `InMemoryKeyStore` instead of the browser, as you can see toward the middle of the snippet.

### Key stores

We have now used almost all the key stores available in `near-api-js`:

1. `UnencryptedFileSystemKeyStore` ‚Äî early on, when we used the NEAR CLI command `near login`, this created a file in our operating system's home directory containing a private, full-access key to our account.
2. `BrowserLocalStorageKeyStore` ‚Äî in the last chapter, when the user first logs in, the function-call access key is saved in the browser's local storage.
3. `InMemoryKeyStore` ‚Äî for this chapter, we'll simply use the computer's memory to store the private key derived from the crossword solution.

:::tip You can have multiple key stores
Technically, there's another type of key store called the `MergeKeyStore`.

Say you want to look for private keys in various directories. You can essentially have a list of `UnencryptedFileSystemKeyStore` key stores that look in different places.

Use the `MergeKeyStore` when you might want to look for a private key in more than one place.
:::

'''
'''--- docs/3.tutorials/crosswords/03-intermediate/03-linkdrop.md ---
---
sidebar_position: 4
sidebar_label: "Linkdrop contract"
title: "Introducing the linkdrop contract we can use"
---
import {Github} from "@site/src/components/codetabs"

import createMainnetAccount from '/docs/assets/crosswords/create-mainnet-account.png';
import createTestnetAccount from '/docs/assets/crosswords/create-testnet-wallet-account.png';

# The linkdrop contract

We're going to take a small detour to talk about the linkdrop smart contract.  It's best that we first understand this contract and its purpose, then discuss calling a method on this contract.

[The linkdrop contract](https://github.com/near/near-linkdrop) is deployed to the accounts `testnet` and `near`, which are known as the top-level accounts of the testnet and mainnet network, respectively. (Anyone can create a linkdrop-style contract elsewhere, but the one shown here is the main one that others are patterned off of.)

## Testnet

There‚Äôs nothing special about testnet accounts; there is no real-world cost to you as a developer when creating testnet accounts, so feel free to create or delete at your convenience.

When a user signs up for a testnet account on NEAR Wallet, they'll see this:

<img src={createTestnetAccount} width="400" />

Let's discuss how this testnet account gets created. 

Notice the new account will end in `.testnet`. This is because the account `testnet` will create a subaccount (like we learned about [earlier in this tutorial](../01-basics/02-add-functions-call.md#create-a-subaccount)) called `vacant-name.testnet`.

There are two ways to create this subaccount:

1. Use a full-access key for the account `testnet` to sign a transaction with the `CreateAccount` Action.
2. In a smart contract deployed to the `testnet` account, call the `CreateAccount` Action, which is an async method that returns a Promise. (More info about writing a [`CreateAccount` Promise](/sdk/rust/promises/create-account).)

(In the example below that uses NEAR CLI to create a new account, it's calling `CreateAccount` on the linkdrop contract that is deployed to the top level "near" account on mainnet.)

## Mainnet

On mainnet, the account `near` also has the linkdrop contract deployed to it.

Using NEAR CLI, a person can create a mainnet account by calling the linkdrop contract, like shown below:

<img src={createMainnetAccount} />

The above command calls the `create_account` method on the account `near`, and would create `aloha.near` **if it's available**, funding it with 15 ‚ìÉ.

We'll want to write a smart contract that calls that same method. However, things get interesting because it's possible `aloha.near` is already taken, so we'll need to learn how to handle that.

## A simple callback

### The `create_account` method

Here, we'll show the implementation of the `create_account` method. Note the `#[payable]` macro, which allows this function to accept an attached deposit. (Remember in the CLI command we were attaching 15 ‚ìÉ.)

<Github language="rust" start="125" end="149" url="https://github.com/near/near-linkdrop/blob/ba94a9c7292d3b48a0a8ba380fb0e7ff6b24efc6/src/lib.rs" />

The most important part of the snippet above is around the middle where there's:

```rs
Promise::new(...)
    ...
    .then(
        Self::ext(env::current_account_id())
            .on_account_created(...)
    )
```

This translates to, "we're going to attempt to perform an Action, and when we're done, please call myself at the method `on_account_created` so we can see how that went."

:::caution This doesn't work

Not infrequently, developers will attempt to do this in a smart contract:

```rust
let creation_result = Promise::new("aloha.mike.near")
  .create_account();

// Check creation_result variable (can't do it!)
if creation_result {...}

```

In other programming languages promises might work like this, but we must use callbacks instead. 
:::

### The callback

Now let's look at the callback:

<Github language="rust" start="151" end="164" url="https://github.com/near/near-linkdrop/blob/ba94a9c7292d3b48a0a8ba380fb0e7ff6b24efc6/src/lib.rs" />

This calls the private helper method `is_promise_success`, which basically checks to see that there was only one promise result, because we only attempted one Promise:

<Github language="rust" start="32" end="42" url="https://github.com/near/near-linkdrop/blob/ba94a9c7292d3b48a0a8ba380fb0e7ff6b24efc6/src/lib.rs" />

Note that the callback returns a boolean. This means when we modify our crossword puzzle to call the linkdrop contract on `testnet`, we'll be able to determine if the account creation succeeded or failed.

And that's it! Now we've seen a method and a callback in action for a simple contract.

:::tip This is important
Understanding cross-contract calls and callbacks is quite important in smart contract development.

Since NEAR's transactions are asynchronous, the use of callbacks may be a new paradigm shift for smart contract developers from other ecosystems. 

Feel free to dig into the linkdrop contract and play with the ideas presented in this section.

There are two additional examples that are helpful to look at:
1. [High-level cross-contract calls](https://github.com/near/near-sdk-rs/blob/master/examples/cross-contract-calls/high-level/src/lib.rs) ‚Äî this is similar what we've seen in the linkdrop contract.
2. [Low-level cross-contract calls](https://github.com/near/near-sdk-rs/blob/master/examples/cross-contract-calls/low-level/src/lib.rs) ‚Äî a different approach where you don't use the traits we mentioned.
:::

---

Next we'll modify the crossword puzzle contract to check for the signer's public key, which is how we now determine if they solved the puzzle correctly.

'''
'''--- docs/3.tutorials/crosswords/03-intermediate/04-cross-contract-calls.md ---
---
sidebar_position: 5
sidebar_label: "Cross-contract calls, etc."
title: "Adding cross-contract calls, access key shuffling, etc."
---
import {Github} from "@site/src/components/codetabs"

# Updating the contract

import shuffleKeys from '/docs/assets/crosswords/shuffle-keys.gif';
import clionSuggestion from '/docs/assets/crosswords/clion-suggestion.gif';
import carpenterAddingKey from '/docs/assets/crosswords/create-key-carpenter-near--carlcarlkarl.near--CarlCarlKarl.jpg';
import recycleKey from '/docs/assets/crosswords/remove-key-recycle--eerie_ram.near--eerie_ram.png';

To reiterate, we'd like anyone to be able to participate in the crossword puzzle, even folks who don't have a NEAR account.

The first person to win will "reserve their spot" and choose where to send the prize money: either an account they own or an account they'd like to create.

## Reserving their spot

### The plan

When a user first visits the crossword, they only see the crossword. No login button and no fields (like a `memo` field) to fill out.

On their first visit, our frontend will create a brand new, random seed phrase in their browser. We'll use this seed phrase to create the user's unique key pair. If a random seed phrase is already there, it skips this part. (We covered the code for this in [a previous section](02-use-seed-phrase.md#generate-random-seed-phrase).)

If the user is the first to solve the puzzle, it discovers the function-call access key and calls `submit_solution` with that key. It's basically using someone else's key, as this key is on the crossword account.

**We'll be adding a new parameter** to the `submit_solution` so the user can include the random, public key we just stored in their browser. 

During the execution of `submit_solution`, because contracts can use Promises to perform Actions, we'll remove the solution public key and add the user's public key.

This will lock out other attempts to solve the crossword puzzle and ensure there is only one winner.

<img src={shuffleKeys} width="600"/><br/><br/>

This means that a puzzle can have three states it can be in:

1. Unsolved
2. Solved and not yet claimed (not paid out)
3. Claimed and finalized

The previous chapter [we discussed enums](../02-beginner/02-structs-enums.md#using-enums), so this is simply modifying the enumeration variants.  

### The implementation

First, let's see how the `submit_solution` will verify the correct solution.

<Github language="rust" start="145" end="151" url="https://github.com/near-examples/crossword-tutorial-chapter-3/blob/ec07e1e48285d31089b7e8cec9e9cf32a7e90c35/contract/src/lib.rs" />

Instead of hashing the plaintext, we simply check that the public key matches what we know the answer is. (The answer being the series of words representing the solution to the crossword puzzle, used as a seed phrase to create a key pair, including a public key.)

Further down in the `submit_solution` method we'll follow our plan by **adding a function-call access key** (that only the winner has) and removing the access key that was discovered by the winner, so no one else can use it.

<figure>
    <img src={carpenterAddingKey} alt="Illustration of a carpenter who has created a key. Art by carlcarlkarl.near" width="400"/>
    <figcaption className="small">Our smart contract is like this carpenter adding a key to itself.<br/>Art by <a href="https://twitter.com/CarlCarlKarl" target="_blank">carlcarlkarl.near</a></figcaption>
</figure>
<br/>

<Github language="rust" start="175" end="181" url="https://github.com/near-examples/crossword-tutorial-chapter-3/blob/ec07e1e48285d31089b7e8cec9e9cf32a7e90c35/contract/src/lib.rs" />

The first promise above adds an access key, and the second deletes the access key on the account that was derived from the solution as a seed phrase.

<figure>
    <img src={recycleKey} alt="Book showing pagination of hashes. Art created by eerie_ram.near" width="600"/>
    <figcaption>We delete the function-call access key so there is only one winner.<br/>Art by <a href="https://twitter.com/eerie_ram" target="_blank">eerie_ram.near</a></figcaption>
</figure>
<br/>

Note that the new function-call access key is able to call two methods we'll be adding:

1. `claim_reward` ‚Äî when the user has an existing account and wishes to send the prize to it
2. `claim_reward_new_account` ‚Äî when the user doesn't have an account, wants to create one and send the prize to it

Both functions will do cross-contract calls and use callbacks to see the result. We finally get to the meat of this chapter, let's go! 

## Cross-contract calls

### The traits

We're going to be making a cross-contract call to the linkdrop account deployed to the `testnet` account. We're also going to have callbacks for that, and for a simple transfer to a (potentially existing) account. We'll create the traits that define both those methods.

<Github language="rust" start="19" end="45" url="https://github.com/near-examples/crossword-tutorial-chapter-3/blob/ec07e1e48285d31089b7e8cec9e9cf32a7e90c35/contract/src/lib.rs" />

:::tip
It's not necessary to create the trait for the callback as we could have just implemented the functions `callback_after_transfer` and `callback_after_create_account` in our `Crossword` struct implementation. We chose to define the trait and implement it to make the code a bit more readable.
:::

### `claim_reward`

Again, this function is called when the user solves the crossword puzzle and wishes to send the prize money to an existing account.

Seems straightforward, so why would we need a callback? We didn't use a callback in the previous chapter when the user logged in, so what gives?

It's possible that while claiming the prize, the user accidentally fat-fingers their username, or their cat jumps on their keyboard. Instead of typing `mike.testnet` they type `mike.testnzzz` and hit send. In short, if we try to send the prize to a non-existent account, we want to catch that.

For brevity, we'll skip some code in this function to focus on the Promise and callback:

```rust
pub fn claim_reward(
    &mut self,
    crossword_pk: PublicKey,
    receiver_acc_id: String,
    memo: String,
    ) -> Promise {
        let signer_pk = env::signer_account_pk();
        ...
        Promise::new(receiver_acc_id.parse().unwrap())
            .transfer(reward_amount)
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_ACCOUNT_CALLBACK)
                    .callback_after_transfer(
                        crossword_pk,
                        receiver_acc_id,
                        memo,
                        env::signer_account_pk(),
                    ),
            )
    }
```

:::tip Your IDE is your friend

Oftentimes, the IDE can help you.

For instance, in the above snippet we have `receiver_acc_id.parse().unwrap()` which might look confusing. You can lean on code examples or documentation to see how this is done, or you can utilize the suggestions from your IDE.

:::

This `claim_reward` method will attempt to use the `Transfer` Action to send NEAR to the account specified. It might fail on a protocol level (as opposed to a smart contract failure), which would indicate the account doesn't exist.

Let's see how we check this in the callback:

<Github language="rust" start="381" end="411" url="https://github.com/near-examples/crossword-tutorial-chapter-3/blob/ec07e1e48285d31089b7e8cec9e9cf32a7e90c35/contract/src/lib.rs" />

:::info The `#[private]` macro
Notice that above the function, we have declared it to be private.

This is an ergonomic helper that checks to make sure the predecessor is the current account ID.

We actually saw this done "the long way" in the callback for the linkdrop contract in [the previous section](03-linkdrop.md#the-callback).

Every callback will want to have this `#[private]` macro above it.
:::

The snippet above essentially says it expects there to be a Promise result for exactly one Promise, and then sees if that was successful or not. Note that we're not actually getting a *value* in this callback, just if it succeeded or failed.

If it succeeded, we proceed to finalize the puzzle, like setting its status to be claimed and finished, removing it from the `unsolved_puzzles` collection, etc.

### `claim_reward_new_account`

Now we want to handle a more interesting case. We're going to do a cross-contract call to the smart contract located on `testnet` and ask it to create an account for us. This name might be unavailable, and this time we get to write a callback that *gets a value*.

Again, for brevity, we'll show the meat of the `claim_reward_new_account` method:

```rust
pub fn claim_reward_new_account(
    &mut self,
    crossword_pk: PublicKey,
    new_acc_id: String,
    new_pk: PublicKey,
    memo: String,
) -> Promise {
    ...
    ext_linkdrop::ext(AccountId::from(self.creator_account.clone()))
        .with_attached_deposit(reward_amount)
        .with_static_gas(GAS_FOR_ACCOUNT_CREATION) // This amount of gas will be split
        .create_account(new_acc_id.parse().unwrap(), new_pk)
        .then(
            // Chain a promise callback to ourselves
            Self::ext(env::current_account_id())
                .with_static_gas(GAS_FOR_ACCOUNT_CALLBACK)
                .callback_after_create_account(
                    crossword_pk,
                    new_acc_id,
                    memo,
                    env::signer_account_pk(),
                ),
        )
}
```

Then the callback:

<Github language="rust" start="413" end="448" url="https://github.com/near-examples/crossword-tutorial-chapter-3/blob/ec07e1e48285d31089b7e8cec9e9cf32a7e90c35/contract/src/lib.rs" />

In the above snippet, there's one difference from the callback we saw in `claim_reward`: we capture the value returned from the smart contract we just called. Since the linkdrop contract returns a bool, we can expect that type. (See the comments with "NOTE:" above, highlighting this.)

## Callbacks

The way that the callback works is that you start with the `Self::ext()` and pass in the current acount ID using `env::current_account_id()`. This is essentially saying that you want to call a function that lives on the current account ID.

You then have a couple of config options that each start with `.with_*`:

1. You can attach a deposit of ‚ìÉ, in yocto‚ìÉ to the call by specifying the `.with_attached_deposit()` method but it is defaulted to 0 (1 ‚ìÉ = 1000000000000000000000000 yocto‚ìÉ, or 1^24 yocto‚ìÉ).
2. You can attach a static amount of GAS by specifying the `.with_static_gas()` method but it is defaulted to 0.
3. You can attach an unused GAS weight by specifying the `.with_unused_gas_weight()` method but it is defaulted to 1. The unused GAS will be split amongst all the functions in the current execution depending on their weights. If there is only 1 function, any weight above 1 will result in all the unused GAS being attached to that function. If you specify a weight of 0, however, the unused GAS will not be attached to that function. If you have two functions, one with a weight of 3, and one with a weight of 1, the first function will get 3/4 of the unused GAS and the other function will get 1/4 of the unused GAS.

After you've added the desired configurations to the call, you execute the function and pass in the parameters. In this case, we call the function `callback_after_create_account` and pass in the crossword public key, the new account ID, the memo, and the signer's public key.

This function will be called with static GAS equal to `GAS_FOR_ACCOUNT_CALLBACK` and will have no deposit attached. In addition, since the `with_unused_gas_weight()` method wasn't called, it will default to a weight of 1 meaning that it will split all the unused GAS with the `create_account` function to be added on top of the `GAS_FOR_ACCOUNT_CALLBACK`.

```rust
.then(
    // Chain a promise callback to ourselves
    Self::ext(env::current_account_id())
        .with_static_gas(GAS_FOR_ACCOUNT_CALLBACK)
        .callback_after_create_account(
            crossword_pk,
            new_acc_id,
            memo,
            env::signer_account_pk(),
        ),
)
```

:::tip Consider changing contract state in callback
It's not always the case, but often you'll want to change the contract state in the callback.

The callback is a safe place where we have knowledge of what's happened after cross-contract calls or Actions. If your smart contract is changing state *before* doing a cross-contract call, make sure there's a good reason for it. It might be best to move this logic into the callback.
:::

So what parameters should I pass into a callback?

There's no one-size-fits-all solution, but perhaps there's some advice that can be helpful.

Try to pass parameters that would be unwise to trust coming from another source. For instance, if an account calls a method to transfer some digital asset, and you need to do a cross-contract call, don't rely on the results of contract call to determine ownership. If the original function call determines the owner of a digital asset, pass this to the callback.

Passing parameters to callbacks is also a handy way to save fetching data from persistent collections twice: once in the initial method and again in the callback. Instead, just pass them along and save some CPU cycles.

## Checking the public key

The last simple change in this section is to modify the way we verify if a user has found the crossword solution.

In previous chapters we hashed the plaintext solution and compared it to the known solution's hash.

Here we're able to simply check the signer's public key, which is available in the `env` object [under `signer_account_pk`](https://docs.rs/near-sdk/latest/near_sdk/env/fn.signer_account_pk.html).

We'll do this check in both when the solution is submitted, and when the prize is claimed.

### When the crossword is solved

```rust
// The solver_pk parameter is the public key generated and stored in their browser
pub fn submit_solution(&mut self, solver_pk: PublicKey) {
    let answer_pk = env::signer_account_pk();
    // check to see if the answer_pk from signer is in the puzzles
    let mut puzzle = self
        .puzzles
        .get(&answer_pk)
        .expect("ERR_NOT_CORRECT_ANSWER");
```

### When prize is claimed

```rust
pub fn claim_reward(
    &mut self,
    crossword_pk: PublicKey,
    receiver_acc_id: String,
    memo: String,
) -> Promise {
    let signer_pk = env::signer_account_pk();
    ...
    // Check that puzzle is solved and the signer has the right public key
    match puzzle.status {
        PuzzleStatus::Solved {
            solver_pk: puzzle_pk,
        } => {
            // Check to see if signer_pk matches
            assert_eq!(signer_pk, puzzle_pk, "You're not the person who can claim this, or else you need to use your function-call access key, friend.");
        }
        _ => {
            env::panic_str("puzzle should have `Solved` status to be claimed");
        }
    };
    ...
}
```

'''
'''--- docs/3.tutorials/crosswords/03-intermediate/05-base64vecu8.md ---
---
sidebar_position: 6
sidebar_label: "Base64 params, wrap up"
title: "Using base64-encoded arguments when we create a new crossword puzzle"
---
import {Github} from "@site/src/components/codetabs"

# Final modifications

import base64Encode from '/docs/assets/crosswords/boop-base64-encode.gif';

Let's modify our `new_puzzle` method a bit, and demonstrate how a smart contract author might use base64-encoded arguments.

In the previous chapter we had a fairly long NEAR CLI command that called the `new_puzzle`, providing it the parameters for all the clues. Having these lengthy parameters on the CLI might get cumbersome. There may be issues needing to escape single or double quotes, and each operating system may wish for a different format on the Terminal or Command Prompt.

We're going to send all the arguments as a base64-encoded string, and make this a bit simpler. For this, we're going to use [`Base64VecU8` from the SDK](https://docs.rs/near-sdk/latest/near_sdk/json_types/struct.Base64VecU8.html). 

:::note `Base64VecU8` is great for binary payloads
What we're doing makes sense, but it's worth noting that it's perhaps more common to use `Base64VecU8` when sending binary parameters.

Read more [about it here](/sdk/rust/contract-interface/serialization-interface#base64vecu8).
:::

First we'll set up a struct for the arguments we're expecting:

<Github language="rust" start="111" end="117" url="https://github.com/near-examples/crossword-tutorial-chapter-3/blob/ec07e1e48285d31089b7e8cec9e9cf32a7e90c35/contract/src/lib.rs" />

Then we modify our `new_puzzle` method like so:

<Github language="rust" start="290" end="297" url="https://github.com/near-examples/crossword-tutorial-chapter-3/blob/ec07e1e48285d31089b7e8cec9e9cf32a7e90c35/contract/src/lib.rs" />

We can take our original arguments and base64 encode them, using whatever method you prefer. There are plenty of online tool, Terminal commands, and open source applications like [Boop](https://boop.okat.best).

We'll copy this:

```json
{
  "answer_pk": "ed25519:7PkKPmVUXcupA5oU8d6TbgyMwzFe8tPV6eV1KGwgo9xg",
  "dimensions": {
   "x": 11,
   "y": 10
  },
  "answers": [
   {
     "num": 1,
     "start": {
       "x": 0,
       "y": 1
     },
     "direction": "Across",
     "length": 12,
     "clue": "NEAR transactions are more ______ instead of atomic."
   },
   {
     "num": 2,
     "start": {
       "x": 6,
       "y": 0
     },
     "direction": "Down",
     "length": 7,
     "clue": "In a smart contract, when performing an Action, you use this in Rust."
   },
   {
     "num": 3,
     "start": {
       "x": 9,
       "y": 0
     },
     "direction": "Down",
     "length": 6,
     "clue": "In docs.rs when you search for the near-sdk crate, these items a considered a what: collections, env, json_types."
   },
   {
     "num": 4,
     "start": {
       "x": 1,
       "y": 1
     },
     "direction": "Down",
     "length": 10,
     "clue": "A series of words that can deterministically generate a private key."
   },
   {
     "num": 5,
     "start": {
       "x": 1,
       "y": 3
     },
     "direction": "Across",
     "length": 3,
     "clue": "When doing high-level cross-contract calls, we import this that ends in _contract. When calling ourselves in a callback, it is convention to call it THIS_self."
   },
   {
     "num": 6,
     "start": {
       "x": 0,
       "y": 8
     },
     "direction": "Across",
     "length": 8,
     "clue": "Use this to determine the execution outcome of a cross-contract call or Action."
   },
   {
     "num": 7,
     "start": {
       "x": 4,
       "y": 6
     },
     "direction": "Across",
     "length": 4,
     "clue": "You chain this syntax onto a promise in order to schedule a callback afterward."
   }
  ]
}
```

and base64 encode it:

<figure>
    <img src={base64Encode} alt="Animated gif of parameters getting base64 encoded with the program Boop" width="600"/>
</figure>
<br/>

Now we can build and run the new crossword puzzle contract as we have before:

```bash
./build.sh

export NEAR_ACCT=crossword.friend.testnet
export PARENT_ACCT=friend.testnet
near delete $NEAR_ACCT $PARENT_ACCT
near create-account $NEAR_ACCT --masterAccount $PARENT_ACCT
near deploy $NEAR_ACCT --wasmFile res/crossword_tutorial_chapter_3.wasm --initFunction new --initArgs '{"owner_id": "'$NEAR_ACCT'", "creator_account": "testnet"}'
near call $NEAR_ACCT new_puzzle '{
  "args": "ewogICJhbnN3ZXJfcGsiOiAiZWQyNTUxOTo3UGtLUG1WVVhjdXBBNW9VOGQ2VGJneU13ekZlOHRQVjZlVjFLR3dnbzl4ZyIsCiAgImRpbWVuc2lvbnMiOiB7CiAgICJ4IjogMTEsCiAgICJ5IjogMTAKICB9LAogICJhbnN3ZXJzIjogWwogICB7CiAgICAgIm51bSI6IDEsCiAgICAgInN0YXJ0IjogewogICAgICAgIngiOiAwLAogICAgICAgInkiOiAxCiAgICAgfSwKICAgICAiZGlyZWN0aW9uIjogIkFjcm9zcyIsCiAgICAgImxlbmd0aCI6IDEyLAogICAgICJjbHVlIjogIk5FQVIgdHJhbnNhY3Rpb25zIGFyZSBtb3JlIF9fX19fXyBpbnN0ZWFkIG9mIGF0b21pYy4iCiAgIH0sCiAgIHsKICAgICAibnVtIjogMiwKICAgICAic3RhcnQiOiB7CiAgICAgICAieCI6IDYsCiAgICAgICAieSI6IDAKICAgICB9LAogICAgICJkaXJlY3Rpb24iOiAiRG93biIsCiAgICAgImxlbmd0aCI6IDcsCiAgICAgImNsdWUiOiAiSW4gYSBzbWFydCBjb250cmFjdCwgd2hlbiBwZXJmb3JtaW5nIGFuIEFjdGlvbiwgeW91IHVzZSB0aGlzIGluIFJ1c3QuIgogICB9LAogICB7CiAgICAgIm51bSI6IDMsCiAgICAgInN0YXJ0IjogewogICAgICAgIngiOiA5LAogICAgICAgInkiOiAwCiAgICAgfSwKICAgICAiZGlyZWN0aW9uIjogIkRvd24iLAogICAgICJsZW5ndGgiOiA2LAogICAgICJjbHVlIjogIkluIGRvY3MucnMgd2hlbiB5b3Ugc2VhcmNoIGZvciB0aGUgbmVhci1zZGsgY3JhdGUsIHRoZXNlIGl0ZW1zIGEgY29uc2lkZXJlZCBhIHdoYXQ6IGNvbGxlY3Rpb25zLCBlbnYsIGpzb25fdHlwZXMuIgogICB9LAogICB7CiAgICAgIm51bSI6IDQsCiAgICAgInN0YXJ0IjogewogICAgICAgIngiOiAxLAogICAgICAgInkiOiAxCiAgICAgfSwKICAgICAiZGlyZWN0aW9uIjogIkRvd24iLAogICAgICJsZW5ndGgiOiAxMCwKICAgICAiY2x1ZSI6ICJBIHNlcmllcyBvZiB3b3JkcyB0aGF0IGNhbiBkZXRlcm1pbmlzdGljYWxseSBnZW5lcmF0ZSBhIHByaXZhdGUga2V5LiIKICAgfSwKICAgewogICAgICJudW0iOiA1LAogICAgICJzdGFydCI6IHsKICAgICAgICJ4IjogMSwKICAgICAgICJ5IjogMwogICAgIH0sCiAgICAgImRpcmVjdGlvbiI6ICJBY3Jvc3MiLAogICAgICJsZW5ndGgiOiAzLAogICAgICJjbHVlIjogIldoZW4gZG9pbmcgaGlnaC1sZXZlbCBjcm9zcy1jb250cmFjdCBjYWxscywgd2UgaW1wb3J0IHRoaXMgdGhhdCBlbmRzIGluIF9jb250cmFjdC4gV2hlbiBjYWxsaW5nIG91cnNlbHZlcyBpbiBhIGNhbGxiYWNrLCBpdCBpcyBjb252ZW50aW9uIHRvIGNhbGwgaXQgVEhJU19zZWxmLiIKICAgfSwKICAgewogICAgICJudW0iOiA2LAogICAgICJzdGFydCI6IHsKICAgICAgICJ4IjogMCwKICAgICAgICJ5IjogOAogICAgIH0sCiAgICAgImRpcmVjdGlvbiI6ICJBY3Jvc3MiLAogICAgICJsZW5ndGgiOiA4LAogICAgICJjbHVlIjogIlVzZSB0aGlzIHRvIGRldGVybWluZSB0aGUgZXhlY3V0aW9uIG91dGNvbWUgb2YgYSBjcm9zcy1jb250cmFjdCBjYWxsIG9yIEFjdGlvbi4iCiAgIH0sCiAgIHsKICAgICAibnVtIjogNywKICAgICAic3RhcnQiOiB7CiAgICAgICAieCI6IDQsCiAgICAgICAieSI6IDYKICAgICB9LAogICAgICJkaXJlY3Rpb24iOiAiQWNyb3NzIiwKICAgICAibGVuZ3RoIjogNCwKICAgICAiY2x1ZSI6ICJZb3UgY2hhaW4gdGhpcyBzeW50YXggb250byBhIHByb21pc2UgaW4gb3JkZXIgdG8gc2NoZWR1bGUgYSBjYWxsYmFjayBhZnRlcndhcmQuIgogICB9CiAgXQp9"
}' --accountId $NEAR_ACCT
```

Back at the project root (not in the `contract` directory) we can run our app and see the new crossword puzzle:

    CONTRACT_NAME=crossword.friend.testnet npm run start

## Wrapping up

Once you understand cross-contract calls and callbacks and where the logic should go, you can build just about anything on NEAR.

This might be a good time for a reminder that this crossword puzzle, which checks permissions to methods based on a public key, is a bit unusual. It's more common to have simple collections or mappings for allowed users, or utilize the `owner_id` field we set up. The account and access key system in NEAR is quite powerful, and hopefully this tutorial helps stretch the limits of what's possible, like the seamless onboarding we have with the crossword puzzle.

Again, the final code for this chapter:

https://github.com/near-examples/crossword-tutorial-chapter-3

Happy hacking!
'''
'''--- docs/3.tutorials/examples/advanced-xcc.md ---
---
id: advanced-xcc
title: Complex Cross Contract Call
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

This example presents 3 instances of complex cross-contract calls. Particularly, it shows:

1. How to batch multiple function calls to a same contract.
2. How to call multiple contracts in parallel, each returning a different type.
3. Different ways of handling the responses in the callback.

:::info Simple Cross-Contract Calls

Check the tutorial on how to use [simple cross-contract calls](xcc.md)

:::

---

## Obtaining the Cross Contract Call Example

You have two options to start the Donation Example:

1. You can use the app through `Github Codespaces`, which will open a web-based interactive environment.
2. Clone the repository locally and use it from your computer.

| Codespaces                                                                                                                      | Clone locally                                               |
| ------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- |
| [![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://codespaces.new/near-examples/cross-contract-calls?quickstart=1) | üåê `https://github.com/near-examples/cross-contract-calls` |

---

## Structure of the Example

The smart contract is available in two flavors: Rust and JavaScript

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

```bash
‚îå‚îÄ‚îÄ sandbox-ts # sandbox testing
‚îÇ    ‚îú‚îÄ‚îÄ external-contracts
‚îÇ    ‚îÇ    ‚îú‚îÄ‚îÄ counter.wasm
‚îÇ    ‚îÇ    ‚îú‚îÄ‚îÄ guest-book.wasm
‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ hello-near.wasm
‚îÇ    ‚îî‚îÄ‚îÄ main.ava.ts
‚îú‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îú‚îÄ‚îÄ internal
‚îÇ    ‚îÇ    ‚îú‚îÄ‚îÄ batch_actions.ts
‚îÇ    ‚îÇ    ‚îú‚îÄ‚îÄ constants.ts
‚îÇ    ‚îÇ    ‚îú‚îÄ‚îÄ multiple_contracts.ts
‚îÇ    ‚îÇ    ‚îú‚îÄ‚îÄ similar_contracts.ts
‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ utils.ts
‚îÇ    ‚îî‚îÄ‚îÄ contract.ts
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ tsconfig.json
```

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

```bash
‚îå‚îÄ‚îÄ tests # sandbox testing
‚îÇ    ‚îú‚îÄ‚îÄ external-contracts
‚îÇ    ‚îÇ    ‚îú‚îÄ‚îÄ counter.wasm
‚îÇ    ‚îÇ    ‚îú‚îÄ‚îÄ guest-book.wasm
‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ hello-near.wasm
‚îÇ    ‚îî‚îÄ‚îÄ main.ava.ts
‚îú‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îú‚îÄ‚îÄ batch_actions.rs
‚îÇ    ‚îú‚îÄ‚îÄ lib.rs
‚îÇ    ‚îú‚îÄ‚îÄ multiple_contracts.rs
‚îÇ    ‚îî‚îÄ‚îÄ similar_contracts.rs
‚îú‚îÄ‚îÄ Cargo.toml # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ rust-toolchain.toml
```

  </TabItem>

</Tabs>

---

## Smart Contract

### Batch Actions

You can aggregate multiple actions directed towards one same contract into a batched transaction.
Methods called this way are executed sequentially, with the added benefit that, if one fails then
they **all get reverted**.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="contract.ts"
          url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/contract.ts"
          start="38" end="41" />
    <Github fname="batch_actions.ts"
          url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/batch_actions.ts"
          start="5" end="17" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="batch_actions.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-rs/src/batch_actions.rs"
            start="8" end="20" />
  </Language>
</CodeTabs>

#### Getting the Last Response

In this case, the callback has access to the value returned by the **last
action** from the chain.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="contract.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/contract.ts"
      start="43" end="46" />
    <Github fname="batch_actions.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/batch_actions.ts"
      start="19" end="29" />
    <Github fname="utils.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/utils.ts"
      start="3" end="20" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="batch_actions.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-rs/src/batch_actions.rs"
            start="22" end="35" />
  </Language>
</CodeTabs>

---

### Calling Multiple Contracts

A contract can call multiple other contracts. This creates multiple transactions that execute
all in parallel. If one of them fails the rest **ARE NOT REVERTED**.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="contract.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/contract.ts"
      start="48" end="51" />
    <Github fname="multiple_contracts.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/multiple_contracts.ts"
      start="6" end="21" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="multiple_contracts.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-rs/src/multiple_contracts.rs"
            start="16" end="55" />
  </Language>
</CodeTabs>

#### Getting All Responses

In this case, the callback has access to an **array of responses**, which have either the
value returned by each call, or an error message.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="contract.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/contract.ts"
      start="53" end="58" />
    <Github fname="multiple_contracts.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/multiple_contracts.ts"
      start="24" end="41" />
    <Github fname="utils.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/utils.ts"
      start="3" end="20" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="multiple_contracts.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-rs/src/multiple_contracts.rs"
            start="58" end="92" />
  </Language>
</CodeTabs>

---

### Multiple Calls - Same Result Type

This example is a particular case of the previous one ([Calling Multiple Contracts](#2-calling-multiple-contracts)).
It simply showcases a different way to check the results by directly accessing the `promise_result` array.

In this case, we call multiple contracts that will return the same type:

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="contract.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/contract.ts"
      start="65" end="70" />
    <Github fname="similar_contracts.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/similar_contracts.ts"
      start="6" end="35" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="similar_contracts.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-rs/src/similar_contracts.rs"
            start="8" end="31" />
  </Language>
</CodeTabs>

#### Getting All Responses

In this case, the callback again has access to an **array of responses**, which we can iterate checking the
results.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="contract.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/contract.ts"
      start="62" end="65" />
    <Github fname="similar_contracts.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/similar_contracts.ts"
      start="37" end="54" />
    <Github fname="utils.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/utils.ts"
      start="3" end="20" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="similar_contracts.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-rs/src/similar_contracts.rs"
            start="32" end="57" />
  </Language>
</CodeTabs>

---

### Testing the Contract

The contract readily includes a set of unit and sandbox testing to validate its functionality. To execute the tests, run the following commands:

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```bash
cd contract-advanced-ts
yarn
yarn test
```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
  
  ```bash
  cd contract-advanced-rs
  cargo test
  ```

  </TabItem>

</Tabs>

:::tip
The `integration tests` use a sandbox to create NEAR users and simulate interactions with the contract.
:::

<hr class="subsection" />

### Deploying the Contract to the NEAR network

In order to deploy the contract you will need to create a NEAR account.

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```bash
# Optional - create an account
near create-account <accountId> --useFaucet

# Deploy the contract
cd contract-advanced-ts
yarn build
near deploy <accountId> ./build/cross_contract.wasm --initFunction init --initArgs '{"hello_account":"hello.near-example.testnet","guestbook_account":"guestbook_account.near-example.testnet","counter_account":"counter_account.near-example.testnet"}'
```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

```bash
# Optional - create an account
near create-account <accountId> --useFaucet

# Deploy the contract
cd contract-advanced-rs
cargo near build

# During deploying pass {"hello_account":"hello.near-example.testnet","guestbook_account":"guestbook_account.near-example.testnet","counter_account":"counter_account.near-example.testnet"} as init arguments
cargo near deploy <accountId>
```

  </TabItem>
</Tabs>

<hr class="subsection" />

### CLI: Interacting with the Contract

To interact with the contract through the console, you can use the following commands:

```bash
# Execute contracts sequentially
# Replace <accountId> with your account ID
near call <accountId> batch_actions --accountId <accountId> --gas 300000000000000   

# Execute contracts in parallel
# Replace <accountId> with your account ID
near call <accountId>  multiple_contracts --accountId <accountId> --gas 300000000000000   

# Execute multiple instances of the same contract in parallel
# Replace <accountId> with your account ID
near call <accountId> similar_contracts --accountId <accountId> --gas 300000000000000   
```

:::info
If at some point you get an "Exceeded the prepaid gas" error, try to increase the gas amount used within the functions when calling other contracts
:::

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- node: `18.19.1`
- rustc: `1.77.0`

:::

'''
'''--- docs/3.tutorials/examples/blockvote-js-edition.md ---
---
id: blockvote-js
sidebar_label: BlockVote JS
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

# BlockVote JS Edition

BlockVote JS Edition is a blockchain-based voting application built using JavaScript on the Near Protocol blockchain. The application allows users to securely cast their votes in an election and have them recorded on the blockchain, ensuring that the results are transparent and cannot be altered.

![image](/docs/assets/blockvote.png)

## Installation

To install BlockVote JS Edition, follow these steps please:

1. Clone the repository to your local machine using the following command:

```bash
git clone https://github.com/doriancrutcher/BlockVote-JS-Edition-Tutorial.git
```

2. Navigate to the project directory:

```bash
cd BlockVote-JS-Edition-Tutorial
```

3. Install the required dependencies using the following command:

```bash
yarn install-deps
```

4. Start the application:

```bash
yarn start
```

:::note

If you don't have `yarn` installed, you can install it by running `npm install -g yarn`.

:::

## Usage

This application allows users to create a poll with two candidates, and each user can only vote in a poll once. Results are shown after the vote is cast.

To create a poll, follow these steps:

1. Enter the names and URL links for the two candidates in the input fields.
2. Click on the "Create Poll" button to create the poll.
3. Share the poll link with others to allow them to vote.

To vote in a poll, follow these steps:

1. Click on the name of the candidate you want to vote for.
2. You will only be able to vote once in each poll.
3. After you vote, the poll results will be displayed on the screen.

That's it! If you have any questions or issues while using the BlockVote JS Edition, feel free to open an issue on the [project's GitHub page](https://github.com/doriancrutcher/BlockVote-JS-Edition-Tutorial).

## Smart Contract

The contract contains several view and call methods that allow users to interact with the contract, including:

### View Methods

- `getUrl`: retrieves the URL link for a specific candidate based on the candidate's name and prompt.
- `didParticipate`: checks whether a specific user has participated in a given prompt.
- `participateArray`: retrieves the list of users who have participated in a given prompt.
- `getAllPrompts`: retrieves a list of all prompts currently available in the contract.
- `getVotes`: retrieves the vote tallies for a specific prompt.
- `getCandidatePair`: retrieves the names of the two candidates for a specific prompt.

<CodeTabs>
<Language value="js" language="js">
    <Github fname="contract.ts" 
            url="https://github.com/doriancrutcher/BlockVote-JS-Edition-Tutorial/blob/main/contract/src/contract.ts"
            start="20" end="60" />
  </Language>
</CodeTabs>

### Call Methods

- `addCandidatePair`: adds a candidate pair for a specific prompt to the contract's unordered map of candidate pairs.
- `initializeVotes`: initializes the vote tallies for a specific prompt
- `addToPromptArray`: adds a prompt to the contract's unordered set of prompts
- `clearPromptArray`: clears all prompts and associated data from the contract (candidate pairs, vote tallies, and user participation)
- `addVote`: casts a vote for a specific candidate in a prompt by updating the vote tally for that candidate in the contract's unordered map of vote tallies. The method takes in the prompt and the index of the candidate
- `recordUser`: records the participation of a user in a specific prompt by adding the user's account ID to an array in the contract's unordered map of user participation

<CodeTabs>
<Language value="js" language="js">
    <Github fname="contract.ts" 
            url="https://github.com/doriancrutcher/BlockVote-JS-Edition-Tutorial/blob/main/contract/src/contract.ts"
            start="61" end="110" />
  </Language>
</CodeTabs>

## Testing

When writing smart contracts, it is very important to test all methods exhaustively. In this project, you have two types of tests: unit tests and integration tests. Before digging into them, it's important to run the tests present in the dApp through the command `yarn test`.

### Unit Tests

Unit tests are designed to test individual functions and methods in the smart contract. These tests are run in isolation, meaning that they do not interact with other components of the system. The purpose of unit tests is to ensure that each individual function or method behaves as expected.

In this project, you can run the unit tests by executing the command `yarn test:unit`.

### Integration Tests

These tests are run to ensure that the different components of the system work together as expected. In the context of a smart contract, integration tests are used to test the interactions between the contract and the blockchain.

In this project, you can run the integration tests by executing the command `yarn test`.

These tests use a combination of `ava` and `near-workspaces`

<CodeTabs>
<Language value="js" language="js">
    <Github fname="contract.ts" 
            url="https://github.com/doriancrutcher/BlockVote-JS-Edition-Tutorial/blob/main/integration-tests/src/main.ava.ts"
            start="6" end="92" />
  </Language>
</CodeTabs>

'''
'''--- docs/3.tutorials/examples/coin-flip.md ---
---
id: coin-flip
title: Coin Flip
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Coin Flip is a game where the player tries to guess the outcome of a coin flip. It is one of the simplest contracts implementing random numbers.

![img](/docs/assets/examples/coin-flip.png)

---

## Starting the Game
You have two options to start the example:
1. **Recommended:** use the app through Gitpod (a web-based interactive environment)
2. Clone the project locally.

| Gitpod                                                                                                                                                            | Clone locally                                          |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | -----------------------------------------------------  |
| <a href="https://gitpod.io/#https://github.com/near-examples/coin-flip-examples.git"><img src="https://gitpod.io/button/open-in-gitpod.svg" alt="Open in Gitpod" /></a> | `https://github.com/near-examples/coin-flip-examples.git` |

If you choose Gitpod, a new browser window will open automatically with the code. Give it a minute, and the front-end will pop up (ensure the pop-up window is not blocked).

If you are running the app locally, you should build and deploy a contract (JavaScript or Rust version) and a client manually.

---

## Interacting With the Counter
Go ahead and log in with your NEAR account. If you don't have one, you can create one on the fly. Once logged in, use the `tails` and `heads` buttons to try to guess the next coin flip outcome.

![img](/docs/assets/examples/coin-flip.png)
*Frontend of the Game*

---

## Structure of a dApp

Now that you understand what the dApp does, let us take a closer look to its structure:

1. The frontend code lives in the `/frontend` folder.
2. The smart contract code in Rust is in the `/contract-rs` folder.
3. The smart contract code in JavaScript is in the `/contract-ts` folder.

:::note
Both Rust and JavaScript versions of the contract implement the same functionality.
:::

### Contract
The contract presents 2 methods: `flip_coin`, and `points_of`.

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="contract.ts" 
            url="https://github.com/near-examples/coin-flip-examples/blob/main/contract-ts/src/contract.ts"
            start="23" end="56" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="lib.rs" 
            url="https://github.com/near-examples/coin-flip-examples/blob/main/contract-rs/src/lib.rs"
            start="46" end="70" />
  </Language>
</CodeTabs>

### Frontend
The frontend is composed by a single HTML file (`/index.html`). This file defines the components displayed in the screen.

The website's logic lives in `/assets/js/index.js`, which communicates with the contract through a `wallet`. You will notice in `/assets/js/index.js` the following code:

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="index.js"
            url="https://github.com/near-examples/coin-flip-workshop-js/blob/main/frontend/index.js"
            start="10" end="19" />            
  </Language>
</CodeTabs>

It indicates our app, when it starts, to check if the user is already logged in and execute either `signedInFlow()` or `signedOutFlow()`.

---

## Testing

When writing smart contracts, it is very important to test all methods exhaustively. In this
project you have integration tests. Before digging into them, go ahead and perform the tests present in the dApp through the command `yarn test` for the JavaScript version, or `./test.sh` for the Rust version.

### Integration test

Integration tests can be written in both Rust and JavaScript. They automatically deploy a new
contract and execute methods on it. In this way, integration tests simulate interactions
from users in a realistic scenario. You will find the integration tests for the `coin-flip`
in `contract-ts/sandbox-ts` (for the JavaScript contract) and `contract-rs/tests` (for the Rust contract).

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="main.test.js"
            url="https://github.com/near-examples/coin-flip-examples/blob/main/contract-ts/sandbox-ts/main.ava.ts"
            start="30" end="53" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="lib.rs" 
            url="https://github.com/near-examples/coin-flip-examples/blob/main/contract-rs/tests/tests.rs"
            start="25" end="82" />
  </Language>
</CodeTabs>

---

## A Note On Randomness

Randomness in the blockchain is a complex subject. We recommend you to read and investigate about it.
You can start with our [security page on it](../../2.build/2.smart-contracts/security/random.md).

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- node: `18.19.1`
- rustc: `1.77.0`

:::

'''
'''--- docs/3.tutorials/examples/count-near.md ---
---
id: count-near
title: Count on NEAR
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Our counter example is a friendly decentralized app that stores a number and exposes methods to `increment`,
`decrement`, and `reset` it.

![img](/docs/assets/examples/count-on-near-banner.png)

---

## Obtaining the Counter Example

You have two options to start the Counter Example.

1. You can use the app through `GitHub Codespaces`, which will open a web-based interactive environment.
2. Clone the repository locally and use it from your computer.

| Codespaces                                                                                                             | Clone locally                                  |
| ---------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------- |
| [![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://codespaces.new/near-examples/counters) | üåê `https://github.com/near-examples/counters` |

---

## Structure of the Example

The example is divided in two main components:

1. The smart contract, available in two flavors: Rust and JavaScript
2. The frontend, that interacts with an already deployed contract.

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

```bash
‚îå‚îÄ‚îÄ sandbox-ts # sandbox testing
‚îÇ    ‚îú‚îÄ‚îÄ src
‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ main.ava.ts
‚îÇ    ‚îú‚îÄ‚îÄ ava.config.cjs
‚îÇ    ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îî‚îÄ‚îÄ contract.ts
‚îú‚îÄ‚îÄ package.json # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ tsconfig.json # test script
```

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

```bash
‚îå‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îî‚îÄ‚îÄ lib.rs
‚îú‚îÄ‚îÄ tests # sandbox test
‚îÇ    ‚îî‚îÄ‚îÄ test_basics.rs
‚îú‚îÄ‚îÄ Cargo.toml # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ rust-toolchain.toml
```

  </TabItem>

</Tabs>

---

## Frontend

The counter example includes a frontend interface designed to interact seamlessly with an existing smart contract that has been deployed. This interface allows users to increase or decrease the counter as needed.

<hr class="subsection" />

### Running the Frontend

To start the frontend you will need to install the dependencies and start the server.

```bash
cd frontend
yarn
yarn start
```

Go ahead and login with your NEAR account. If you don't have one, you will be able to create one in the moment. Once logged in, use the `+` and `-` buttons to increase and decrease the counter. Then, use the Gameboy buttons to reset it and make the counter blink an eye!

![img](/docs/assets/examples/count-on-near.png)
_Frontend of the Counter_

<hr class="subsection" />

### Understanding the Frontend

The frontend is composed by a single HTML file (`/index.html`). This file defines the components displayed in the screen.

The website's logic lives in `/index.js`, which communicates with the contract through `/near-wallet.js`. You will notice in `/index.js` the following code:

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="index.js"
            url="https://github.com/near-examples/counters/blob/main/frontend/index.js"
            start="10" end="21" />
  </Language>
</CodeTabs>

It indicates our app, when it starts, to check if the user is already logged in and execute either `signedInFlow()` or `signedOutFlow()`.

---

## Smart Contract

The contract presents 4 methods: `get_num`, `increment`, `decrement`, and `reset`. The method `get_num` retrieves the current value, and the rest modify it.

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="contract.ts"
            url="https://github.com/near-examples/counters/blob/main/contract-ts/src/contract.ts"
            start="3" end="29" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/counters/blob/main/contract-rs/src/lib.rs"
            start="5" end="37" />
  </Language>
</CodeTabs>

---

### Testing the Contract

The contract readily includes a set of unit and sandbox testing to validate its functionality. To execute the tests, run the following commands:

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```bash
cd contract-ts
yarn
yarn test
```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
  
  ```bash
  cd contract-rs
  cargo test
  ```

  </TabItem>

</Tabs>

:::tip
The `integration tests` use a sandbox to create NEAR users and simulate interactions with the contract.
:::

<hr class="subsection" />

### Deploying the Contract to the NEAR network

In order to deploy the contract you will need to create a NEAR account.

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```bash
# Optional - create an account
near create-account <accountId> --useFaucet

# Deploy the contract
cd contract-ts
yarn build
near deploy <accountId> ./build/counter.wasm
```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

```bash
# Optional - create an account
near create-account <accountId> --useFaucet

# Deploy the contract
cd contract-rs
cargo build
near deploy <accountId> ./target/wasm32-unknown-unknown/release/counter.wasm
```

  </TabItem>
</Tabs>

:::tip
To interact with your contract from the [frontend](#frontend), simply replace the variable `CONTRACT_NAME` in the `index.js` file.
:::

<hr class="subsection" />

### CLI: Interacting with the Contract

To interact with the contract through the console, you can use the following commands

```bash
# Get the current number of the counter
near view counter.near-examples.testnet get_num

# Increment the counter 
# Replace <accountId> with your account ID
near call counter.near-examples.testnet increment --accountId <accountId>

# Decrement the counter
# Replace <accountId> with your account ID
near call counter.near-examples.testnet decrement --accountId <accountId>

# Reset the counter to zero 
# Replace <accountId> with your account ID
near call counter.near-examples.testnet reset --accountId <accountId>
```

:::tip
If you're using your own account, replace `counter.near-examples.testnet` with your `accountId`.
:::

---

## Moving Forward

A nice way to learn is by trying to expand the contract. Modify it by adding a parameter to `increment` and `decrement`,
so the user can choose by how much to change the value. For this, you will need to use knowledge from the [anatomy](../../2.build/2.smart-contracts/anatomy/anatomy.md)
and [storage](../../2.build/2.smart-contracts/anatomy/storage.md) sections.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- node: `18.19.1`
- rustc: `1.77.0`

:::

'''
'''--- docs/3.tutorials/examples/donation.md ---
---
id: donation
title: Donation
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Our donation example enables to forward NEAR Tokens to an account while keeping track of it. It is one of the simplest examples on making a contract handle tranfers.

![img](/docs/assets/examples/donation.png)
_Frontend of the Donation App_

---

## Obtaining the Donation Example

You have two options to start the Donation Example.

1. You can use the app through `Github Codespaces`, which will open a web-based interactive environment.
2. Clone the repository locally and use it from your computer.

| Codespaces                                                                                                                      | Clone locally                                               |
| ------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- |
| [![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://codespaces.new/near-examples/donation-examples) | üåê `https://github.com/near-examples/donation-examples.git` |

---

## Structure of the Example

The example is divided in two main components:

1. The smart contract, available in two flavors: rust and javascript
2. The frontend, that interacts with an already deployed contract.

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

```bash
‚îå‚îÄ‚îÄ sandbox-ts # sandbox testing
‚îÇ    ‚îú‚îÄ‚îÄ src
‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ main.ava.ts
‚îÇ    ‚îú‚îÄ‚îÄ ava.config.cjs
‚îÇ    ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îú‚îÄ‚îÄ contract.ts
‚îÇ    ‚îú‚îÄ‚îÄ model.ts
‚îÇ    ‚îî‚îÄ‚îÄ utils.ts
‚îú‚îÄ‚îÄ package.json # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ tsconfig.json # test script
```

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

```bash
‚îå‚îÄ‚îÄ tests # workspaces testing
‚îÇ    ‚îú‚îÄ‚îÄ workspaces.rs
‚îú‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îú‚îÄ‚îÄ donation.rs
‚îÇ    ‚îî‚îÄ‚îÄ lib.rs
‚îú‚îÄ‚îÄ Cargo.toml # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ rust-toolchain.toml
```

  </TabItem>

</Tabs>

---

## Frontend

The donation example includes a frontend that interacts with an already deployed smart contract, allowing user to donate NEAR tokens to a faucet service.

<hr class="subsection" />

### Running the Frontend

To start the frontend you will need to install the dependencies and start the server.

```bash
cd frontend
yarn
yarn start
```

Go ahead and login with your NEAR account. If you don't have one, you will be able to create one in the moment. Once logged in, input the amount of NEAR you want to donate and press the donate button. You will be redirected to the NEAR Wallet to confirm the transaction. After confirming it, the donation will be listed in the "Latest Donations".

<hr class="subsection" />

### Understanding the Frontend

The frontend is composed by a single HTML file (`/index.html`), while the logic lives in `/index.js`, which communicates with the contract through `/near-interface.js`.

<Language value="" language="js">
  <Github fname="index.js"
          url="https://github.com/near-examples/donation-examples/blob/main/frontend/index.js"
          start="71" end="93" />
  <Github fname="near-interface.js"
          url="https://github.com/near-examples/donation-examples/blob/main/frontend/near-interface.js"
          start="29" end="32" />
  <Github fname="near-wallet.js"
          url="https://github.com/near-examples/donation-examples/blob/main/frontend/near-wallet.js"
          start="105" end="113" />
</Language>

An interesting aspect of the donation example is that it showcases how to retrieve a result after being redirected to the
NEAR wallet to accept a transaction.

---

## Smart Contract

The contract exposes methods to donate tokens (`donate`), and methods to retrieve the recorded donations (e.g. `get_donation_for_account`).

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="contract.ts"
            url="https://github.com/near-examples/donation-examples/blob/main/contract-ts/src/contract.ts"
            start="16" end="44" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/donation-examples/blob/main/contract-rs/src/donation.rs"
            start="17" end="74" />
  </Language>
</CodeTabs>

<hr class="subsection" />

### Testing the Contract

The contract readily includes a set of unit and sandbox testing to validate its functionality. To execute the tests, run the following commands:

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

  ```bash
  cd contract-ts
  yarn
  yarn test
  ```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
  
  ```bash
  cd contract-rs
  cargo test
  ```

  </TabItem>

</Tabs>

:::tip
The `integration tests` use a sandbox to create NEAR users and simulate interactions with the contract.
:::

<hr class="subsection" />

### Deploying the Contract to the NEAR network

In order to deploy the contract you will need to create a NEAR account.

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```bash
# Optional - create an account
near create-account <accountId> --useFaucet

# Deploy the contract
cd contract-ts
yarn build
near deploy <accountId> ./build/donation.wasm
```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

```bash
# Optional - create an account
near create-account <accountId> --useFaucet

# Deploy the contract
cd contract-rs
cargo near build
near deploy <accountId> ./target/wasm32-unknown-unknown/release/donation.wasm
```

  </TabItem>
</Tabs>

:::tip
To interact with your contract from the [frontend](#frontend), simply replace the variable `CONTRACT_NAME` in the `index.js` file.
:::

<hr class="subsection" />

### CLI: Interacting with the Contract

To interact with the contract through the console, you can use the following commands

```bash
# Get donations 
# Optional arguments for pagination
near view donation.near-examples.testnet get_donations --args='{"from_index": 0,"limit": 10}'

# Get beneficiary
near view donation.near-examples.testnet get_beneficiary

# Get number of donors
near view donation.near-examples.testnet number_of_donors

# Get donation for an account 
# Require accountId
near view donation.near-examples.testnet get_donation_for_account --args='{"account_id":<accountId>}'

# Donate to the contract 
# Replace <accountId> with your account ID
# Require deposit
near call donation.near-examples.testnet donate --accountId <accountId> --deposit 0.1
```

:::tip
If you're using your own account, replace `donation.near-examples.testnet` with your `accountId`.
:::

---

## Moving Forward

A nice way to learn is by trying to expand a contract. Modify the donation example so it accumulates the tokens in the contract
instead of sending it immediately. Then, make a method that only the `beneficiary` can call to retrieve the tokens.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- node: `18.19.1`
- rustc: `1.77.0`

:::

'''
'''--- docs/3.tutorials/examples/factory.md ---
---
id: factory
title: Factory
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

A factory is a smart contract that stores a compiled contract on itself, and automatizes deploying it into
sub-accounts.

We have two factory examples:

1. [**Token Factory**](https://github.com/near-examples/token-factory): A factory that creates [fungible tokens](../fts/0-intro.md) contracts.
2. [**A Generic Factory**](https://github.com/near-examples/factory-rust): A factory that creates [donation contracts](./donation.md), but allows to change the contract it deploys.

:::info
In this page we will focus on the Donation factory, to learn more about the token factory visit its repository.
:::

---

## Generic Factory

The [Generic Factory](https://github.com/near-examples/factory-rust/) presents a contract factory that:

1. Creates sub-accounts of itself and deploys its contract on them (`create_factory_subaccount_and_deploy`).
2. Can change the stored contract using the `update_stored_contract` method.

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="deploy.rs"
            url="https://github.com/near-examples/factory-rust/blob/main/src/deploy.rs"
            start="14" end="66" />
    <Github fname="manager.rs"
            url="https://github.com/near-examples/factory-rust/blob/main/src/manager.rs"
            start="5" end="19" />
  </Language>
</CodeTabs>

---

## Quickstart

1. Make sure you have installed [rust](https://www.rust-lang.org/).
2. Install the [`NEAR CLI`](https://github.com/near/near-cli#setup)

<hr className="subsection" />

### Build and Deploy the Factory

You can automatically compile and deploy the contract in the NEAR testnet by running:

```bash
./deploy.sh
```

Once finished, check the `neardev/dev-account` file to find the address in which the contract was deployed:

```bash
cat ./neardev/dev-account
# e.g. dev-1659899566943-21539992274727
```

<hr className="subsection" />

### Deploy the Stored Contract Into a Sub-Account

`create_factory_subaccount_and_deploy` will create a sub-account of the factory and deploy the
stored contract on it.

```bash
near call <factory-account> create_factory_subaccount_and_deploy '{ "name": "sub", "beneficiary": "<account-to-be-beneficiary>"}' --deposit 1.24 --accountId <account-id> --gas 300000000000000
```

This will create the `sub.<factory-account>`, which will have a `donation` contract deployed on it:

```bash
near view sub.<factory-account> get_beneficiary
# expected response is: <account-to-be-beneficiary>
```

<hr className="subsection" />

### Update the Stored Contract

`update_stored_contract` enables to change the compiled contract that the factory stores.

The method is interesting because it has no declared parameters, and yet it takes
an input: the new contract to store as a stream of bytes.

To use it, we need to transform the contract we want to store into its `base64`
representation, and pass the result as input to the method:

```bash
# Use near-cli to update stored contract
export BYTES=`cat ./src/to/new-contract/contract.wasm | base64`
near call <factory-account> update_stored_contract "$BYTES" --base64 --accountId <factory-account> --gas 30000000000000
```

> This works because the arguments of a call can be either a `JSON` object or a `String Buffer`

---

## Factories - Concepts & Limitations

Factories are an interesting concept, here we further explain some of their implementation aspects,
as well as their limitations.

<hr className="subsection" />

### Automatically Creating Accounts

NEAR accounts can only create sub-accounts of itself, therefore, the `factory` can only create and
deploy contracts on its own sub-accounts.

This means that the factory:

1. **Can** create `sub.factory.testnet` and deploy a contract on it.
2. **Cannot** create sub-accounts of the `predecessor`.
3. **Can** create new accounts (e.g. `account.testnet`), but **cannot** deploy contracts on them.

It is important to remember that, while `factory.testnet` can create `sub.factory.testnet`, it has
no control over it after its creation.

<hr className="subsection" />

### The Update Method

The `update_stored_contracts` has a very short implementation:

```rust
#[private]
pub fn update_stored_contract(&mut self) {
  self.code = env::input().expect("Error: No input").to_vec();
}
```

On first sight it looks like the method takes no input parameters, but we can see that its only
line of code reads from `env::input()`. What is happening here is that `update_stored_contract`
**bypasses** the step of **deserializing the input**.

You could implement `update_stored_contract(&mut self, new_code: Vec<u8>)`,
which takes the compiled code to store as a `Vec<u8>`, but that would trigger the contract to:

1. Deserialize the `new_code` variable from the input.
2. Sanitize it, making sure it is correctly built.

When dealing with big streams of input data (as is the compiled `wasm` file to be stored), this process
of deserializing/checking the input ends up **consuming the whole GAS** for the transaction.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- node: `18.19.1`
- rustc: `1.77.0`

:::

'''
'''--- docs/3.tutorials/examples/frontend-multiple-contracts.md ---
---
id: frontend-multiple-contracts
title: Frontend Interacting with Multiple Contracts
sidebar_label: Frontend & Multiple Contracts
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

This example showcases how to interact with multiple contracts from a single frontend.

Particularly, this example shows how to:

1. Query data from multiple contracts.
2. Call methods in multiple contracts simultaneously.

---

## Query Data from Multiple Contracts

To query multiple contracts simply perform multiple `view` calls:

<Language value="js" language="ts">
  <Github fname="index.js"
        url="https://github.com/near-examples/frontend-multiple-contracts/blob/main/frontend/index.js"
        start="70" end="76" />
</Language>

---

## Dispatching Multiple Transactions

The `wallet` object enables to dispatch multiple transactions simultaneously. However, please notice that the transactions execute independently.

Dispatching multiple transactions at once is just a nice way to improve UX, because the user interacts with the wallet only once.

<Language value="js" language="ts">
  <Github fname="index.js"
          url="https://github.com/near-examples/frontend-multiple-contracts/blob/main/frontend/index.js"
          start="39" end="66" />
</Language>

In this example, the user signs two independent transactions:

1. A transaction to call `set_greeting` in our [Hello NEAR example](https://github.com/near-examples/hello-near-examples)
2. A transaction to call `add_message` in our [GuestBook example](https://github.com/near-examples/guest-book-examples)

:::caution
Even when the user accepts signing the transactions at the same time, the
transactions remain **independent**. This is, if one fails, the other is **NOT** rolled back.
:::

---

## Batch Actions

You can aggregate multiple [actions](../../2.build/2.smart-contracts/anatomy/actions.md) directed towards a same contract into a single transaction. Batched actions execute **sequentially**, with the added benefit that, if **one fails** then they **all** get reverted.

```js
  // Register a user and transfer them FT on a single take
  const REGISTER_DEPOSIT = "1250000000000000000000";

  const ftTx = {
    receiverId: FT_ADDRESS,
    actions: [
      {
        type: 'FunctionCall',
        params: {
          methodName: 'storage_deposit',
          args: { account_id: "<receiver-account>" },
          gas: THIRTY_TGAS, deposit: REGISTER_DEPOSIT
        }
      },
      {
        type: 'FunctionCall',
        params: {
          methodName: 'ft_transfer',
          args: { receiver_id: "<receiver-account>", amount: amount_in_yocto },
          gas: THIRTY_TGAS, deposit: 1 }
      }
    ]
  }

  // Ask the wallet to sign and send the transaction
  await wallet.signAndSendTransactions({ transactions: [ ftTx ] })
```

'''
'''--- docs/3.tutorials/examples/guest-book.md ---
---
id: guest-book
title: Guest Book
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Our Guest Book example is a simple app composed by two main components:

1. A smart contract that stores messages from users, allowing to attach money to them.
2. A simple web-based frontend that displays the last 10 messages posted.

![img](/docs/assets/examples/guest-book.png)

---

## Obtaining the Guest book Example

You have two options to start the Guest book Example.

1. You can use the app through `GitHub Codespaces`, which will open a web-based interactive environment.
2. Clone the repository locally and use it from your computer.

| Codespaces                                                                                                                        | Clone locally                                             |
| --------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------- |
| [![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://codespaces.new/near-examples/guest-book-examples) | üåê `https://github.com/near-examples/guest-book-examples` |

---

## Structure of the Example

The example is divided in two main components:

1. The smart contract, available in two flavors: Rust and JavaScript
2. The frontend, that interacts with an already deployed contract.

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

```bash
‚îå‚îÄ‚îÄ sandbox-ts # sandbox testing
‚îÇ    ‚îú‚îÄ‚îÄ src
‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ main.ava.ts
‚îÇ    ‚îú‚îÄ‚îÄ ava.config.cjs
‚îÇ    ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îú‚îÄ‚îÄ contract.ts
‚îÇ    ‚îî‚îÄ‚îÄ model.ts
‚îú‚îÄ‚îÄ package.json # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ tsconfig.json # test script
```

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

```bash
‚îå‚îÄ‚îÄ tests # workspaces testing
‚îÇ    ‚îú‚îÄ‚îÄ workspaces.rs
‚îú‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îî‚îÄ‚îÄ lib.rs
‚îú‚îÄ‚îÄ Cargo.toml # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ rust-toolchain.toml
```

  </TabItem>

</Tabs>

---

## Frontend

The guest book example includes a frontend that interacts with an already deployed smart contract, allowing user to sign a message.

<hr class="subsection" />

### Running the Frontend

To start the frontend you will need to install the dependencies and start the server.

```bash
cd frontend
yarn
yarn start
```

Go ahead and login with your NEAR account. If you don't have one, you will be able to create one in the moment. Once logged in, you will be able to sign a message in the guest book. You can further send some money alongside your message. If you attach more than 0.01‚ìÉ then your message will be marked as "premium".

<hr class="subsection" />

### Understanding the Frontend

The frontend is composed by a single HTML file (`/index.html`) and uses REACT. Check `/App.js` and `/index.js` to understand how
components are displayed in the screen.

You will notice in `/src/App.jsx` the following code:

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="App.jsx"
            url="https://github.com/near-examples/guest-book-examples/blob/main/frontend/src/App.jsx"/>
  </Language>
</CodeTabs>

It setups the necessary variables and starts the app.

---

## Smart Contract

The contract presents 3 methods: `add_message`, `get_message` and `total_messages`.

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="contract.ts"
            url="https://github.com/near-examples/guest-book-examples/blob/main/contract-ts/src/contract.ts"
            start="4" end="27" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/guest-book-examples/blob/main/contract-rs/src/lib.rs"
            start="31" end="64" />
  </Language>
  
</CodeTabs>

<hr class="subsection" />

### Testing the Contract

The contract readily includes a set of unit and sandbox testing to validate its functionality. To execute the tests, run the following commands:

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```bash
cd contract-ts
yarn
yarn test
```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
  
  ```bash
  cd contract-rs
  cargo test
  ```

  </TabItem>

</Tabs>

:::tip
The `integration tests` use a sandbox to create NEAR users and simulate interactions with the contract.
:::

<hr class="subsection" />

### Deploying the Contract to the NEAR network

In order to deploy the contract you will need to create a NEAR account.

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```bash
# Optional - create an account
near create-account <accountId> --useFaucet

# Deploy the contract
cd contract-ts
yarn build
near deploy <accountId> ./build/guestbook.wasm
```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

```bash
# Optional - create an account
near create-account <accountId> --useFaucet

# Deploy the contract
cd contract-rs
cargo near build
near deploy <accountId> ./target/wasm32-unknown-unknown/release/guestbook.wasm
```

  </TabItem>
</Tabs>

:::tip
To interact with your contract from the [frontend](#frontend), simply replace the variable `CONTRACT_NAME` in the `index.js` file.
:::

<hr class="subsection" />

### CLI: Interacting with the Contract

To interact with the contract through the console, you can use the following commands

```bash
# Get messages with optional arguments for pagination
near view guestbook.near-examples.testnet get_messages --args='{"from_index": "0","limit": "10"}'

# Get total number of messages
near view guestbook.near-examples.testnet total_messages

# Add a message
# Replace <accountId> with your account ID
# Required a text
# Optional deposit to make the message premium
near call guestbook.near-examples.testnet add_message '{"text":"Hello Near"}' --accountId <accountId> --deposit 0.1
```

:::tip
If you're using your own account, replace `guestbook.near-examples.testnet` with your `accountId`.
:::

---

## Moving Forward

A nice way to learn is by trying to expand a contract. You can modify the guestbook example to incorporate a feature where users can give likes to messages. Additionally, implement a method to toggle the like.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- node: `18.19.1`
- rustc: `1.77.0`

:::

'''
'''--- docs/3.tutorials/examples/update.md ---
---
id: update-contract-migrate-state
title: Self Upgrade & State Migration
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Three examples on how to handle updates and [state migration](../../2.build/2.smart-contracts/release/upgrade.md):
1. [State Migration](https://github.com/near-examples/update-migrate-rust/tree/main/basic-updates): How to implement a `migrate` method to migrate state between contract updates.
2. [State Versioning](https://github.com/near-examples/update-migrate-rust/tree/main/enum-updates): How to use readily use versioning on a state, to simplify updating it later.
3. [Self Update](https://github.com/near-examples/update-migrate-rust/tree/main/self-updates): How to implement a contract that can update itself.

---

## State Migration
The [State Migration example](https://github.com/near-examples/update-migrate-rust/tree/main/basic-updates) shows how to handle state-breaking changes
between contract updates.

It is composed by 2 contracts:
1. Base: A Guest Book where people can write messages.
2. Update: An update in which we remove a parameter and change the internal structure.

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="migrate.rs"
            url="https://github.com/near-examples/update-migrate-rust/blob/main/basic-updates/update/src/migrate.rs"
            start="18" end="45" />
  </Language>
</CodeTabs>

#### The Migration Method
The migration method deserializes the current state (`OldState`) and iterates through the messages, updating them
to the new `PostedMessage` that includes the `payment` field.

:::tip
Notice that migrate is actually an [initialization method](../../2.build/2.smart-contracts/anatomy/anatomy.md#initialization-method) that ignores the existing state (`[#init(ignore_state)]`), thus being able to execute and rewrite the state.
:::

---

## State Versioning
The [State Versioning example](https://github.com/near-examples/update-migrate-rust/tree/main/enum-updates) shows how to use
[Enums](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html) to implement state versioning on a contract.

Versioning simplifies updating the contract since you only need to add a new new version of the structure.
All versions can coexist, thus you will not need to change previously existing structures. 

The example is composed by 2 contracts:
1. Base: The Guest Book contract using versioned `PostedMessages` (`PostedMessagesV1`).
2. Update: An update that adds a new version of `PostedMessages` (`PostedMessagesV2`).

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="versioned_msg.rs"
            url="https://github.com/near-examples/update-migrate-rust/blob/main/enum-updates/update/src/versioned_msg.rs"
            start="18" end="36" />
  </Language>
</CodeTabs>

---

## Self Update
The [Self Update example](https://github.com/near-examples/update-migrate-rust/tree/main/self-updates) shows how to implement a contract
that can update itself.

It is composed by 2 contracts:
1. Base: A Guest Book were people can write messages, implementing a `update_contract` method.
2. Update: An update in which we remove a parameter and change the internal structure.

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="update.rs"
            url="https://github.com/near-examples/update-migrate-rust/blob/main/self-updates/base/src/update.rs"
            start="10" end="31" />
  </Language>
</CodeTabs>

'''
'''--- docs/3.tutorials/examples/xcc.md ---
---
id: xcc
title: Cross Contract Call
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

This example performs the simplest cross-contract call possible: it calls our [Hello NEAR](https://github.com/near-examples/hello-near-examples) example to set and retrieve a greeting.
It is one of the simplest examples on making a cross-contract call, and the perfect gateway to the world of interoperative contracts.

:::info Advanced Cross-Contract Calls
Check the tutorial on how to perform cross-contract calls [in batches and in parallel](./advanced-xcc)
:::

---

## Obtaining the Cross Contract Call Example

You have two options to start the project:

1. You can use the app through `Github Codespaces`, which will open a web-based interactive environment.
2. Clone the repository locally and use it from your computer.

| Codespaces                                                                                                                                      | Clone locally                                              |
| ----------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------- |
| [![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://codespaces.new/near-examples/cross-contract-calls?quickstart=1) | üåê `https://github.com/near-examples/cross-contract-calls` |

---

## Structure of the Example

The smart contract is available in two flavors: Rust and JavaScript

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

```bash
‚îå‚îÄ‚îÄ sandbox-ts # sandbox testing
‚îÇ    ‚îú‚îÄ‚îÄ hello-near
‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ hello-near.wasm
‚îÇ    ‚îî‚îÄ‚îÄ main.ava.ts
‚îú‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îî‚îÄ‚îÄ contract.ts
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ tsconfig.json
```

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

```bash
‚îå‚îÄ‚îÄ tests # sandbox testing
‚îÇ    ‚îú‚îÄ‚îÄ hello-near
‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ hello-near.wasm
‚îÇ    ‚îî‚îÄ‚îÄ tests.rs
‚îú‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îú‚îÄ‚îÄ external.rs
‚îÇ    ‚îî‚îÄ‚îÄ lib.rs
‚îú‚îÄ‚îÄ Cargo.toml # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ rust-toolchain.toml
```

  </TabItem>

</Tabs>

---

## Smart Contract

### Contract
The contract exposes methods to query the greeting and change it. These methods do nothing but calling `get_greeting` and
`set_greeting` in the `hello-near` example.

<CodeTabs>
<Language value="js" language="ts">
    <Github fname="contract.ts"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-ts/src/contract.ts"
            start="17" end="39" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/lib.rs"
            start="22" end="51" />
            <Github fname="external.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/external.rs"
            start="2" end="12" />
  </Language>
</CodeTabs>

### Testing the Contract

The contract readily includes a set of unit and sandbox testing to validate its functionality. To execute the tests, run the following commands:

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```bash
cd contract-simple-ts
yarn
yarn test
```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
  
  ```bash
  cd contract-simple-rs
  cargo test
  ```

  </TabItem>

</Tabs>

:::tip
The `integration tests` use a sandbox to create NEAR users and simulate interactions with the contract.
:::

In this project in particular, the integration tests first deploy the `hello-near` contract. Then,
they test that the cross-contract call correctly sets and retrieves the message. You will find the integration tests
in `sandbox-ts/` for the JavaScript version and in `tests/` for the Rust version.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="main.ava.ts"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-ts/sandbox-ts/main.ava.ts"
            start="8" end="52" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/tests/tests.rs"
            start="4" end="77" />
  </Language>
</CodeTabs>

<hr class="subsection" />

### Deploying the Contract to the NEAR network

In order to deploy the contract you will need to create a NEAR account.

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```bash
# Optional - create an account
near create-account <accountId> --useFaucet

# Deploy the contract
cd contract-simple-ts
yarn build
near deploy <accountId> ./build/cross_contract.wasm init --initFunction init --initArgs '{"hello_account":"hello.near-example.testnet"}'
```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

```bash
# Optional - create an account
near create-account <accountId> --useFaucet

# Deploy the contract
cd contract-simple-rs

cargo near build

# During deploying pass {"hello_account":"hello.near-example.testnet"} as init arguments
cargo near deploy <accountId>
```
  </TabItem>
</Tabs>

<hr class="subsection" />

### CLI: Interacting with the Contract

To interact with the contract through the console, you can use the following commands:

```bash
# Get message from the hello-near contract
# Replace <accountId> with your account ID
near call <accountId> query_greeting --accountId <accountId>

# Set a new message for the hello-near contract
# Replace <accountId> with your account ID
near call <accountId> change_greeting '{"new_greeting":"XCC Hi"}' --accountId <accountId>
```

---

## Moving Forward

A nice way to learn is by trying to expand a contract. Modify the cross contract example to use the [guest-book](guest-book.md)
contract!. In this way, you can try to make a cross-contract call that attaches money. Remember to correctly [handle the callback](../../2.build/2.smart-contracts/anatomy/crosscontract.md#callback-method),
and to return the money to the user in case of error.

### Advanced Cross Contract Calls

Your contract can perform multiple cross-contract calls in simultaneous, creating promises that execute in parallel, or as a batch transaction. Check the [advanced cross contract calls
tutorial](./advanced-xcc) to learn more.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- node: `18.19.1`
- rustc: `1.77.0`

:::

'''
'''--- docs/3.tutorials/fts/0-intro.md ---
---
id: introduction
title: Fungible Tokens Zero to Hero
sidebar_label: Introduction
---

> In this _Zero to Hero_ series, you'll find a set of tutorials covering every aspect of a fungible token (FT) smart contract.
> You'll start by interacting with a pre-deployed contract and by the end you'll have built a fully-fledged FT smart contract that supports every extension of the standards.

---

## Prerequisites

To complete these tutorials successfully, you'll need:

- [Rust](/build/smart-contracts/quickstart#prerequisites)
- [A NEAR testnet account](https://testnet.mynearwallet.com)
- [NEAR-CLI](/tools/near-cli#setup)

:::info New to Rust?
If you are new to Rust and want to dive into smart contract development, our [Quick-start guide](../../2.build/2.smart-contracts/quickstart.md) is a great place to start.
:::

---

## Overview

These are the steps that will bring you from **_Zero_** to **_Hero_** in no time! üí™

| Step | Name                                                         | Description                                                                                                                                     |
| ---- | ------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| 1    | [Pre-deployed contract](/tutorials/fts/predeployed-contract) | Receive FTs without the need to code, create, or deploy a smart contract.                                                                       |
| 2    | [Contract architecture](/tutorials/fts/skeleton)             | Learn the basic architecture of the FT smart contract and compile the code.                                                                     |
| 3    | [Defining a Token](/tutorials/fts/defining-a-token)          | Flesh out what it means to have a FT and how you can customize your own                                                                         |
| 4    | [Circulating Supply](/tutorials/fts/circulating-supply)      | Learn how to create an initial supply and have the token show up in your wallet.                                                                |
| 5    | [Registering Accounts](/tutorials/fts/registering-accounts)  | Explore how you can implement and understand the storage management standard to avoid malicious users from draining your funds.                 |
| 6    | [Transferring FTs](/tutorials/fts/transfers)                 | Learn how to transfer FTs and discover some of the true powers that the core standard brings                                                    |
| 7    | [Marketplace](/tutorials/fts/marketplace)                    | Learn about how common marketplaces operate on NEAR and dive into some of the code that allows buying and selling NFTs by using Fungible Tokens |

<!--
1. [Events](/tutorials/fts/events): in this tutorial you'll explore the events extension, allowing the contract to react on certain events.
1. [Marketplace](/tutorials/fts/marketplace): in the last tutorial you'll be exploring some key aspects of the marketplace contract.
-->

---

## Next steps

Ready to start? Jump to the [Pre-deployed Contract](/tutorials/fts/predeployed-contract) tutorial and begin your learning journey!

If you already know about fungible tokens and smart contracts, feel free to skip and jump directly to the tutorial of your interest. The tutorials have been designed so you can start at any given point!

:::info Questions?
üëâ Join us on [Discord](https://near.chat/) and let us know in the `#development` channels. üëà

We also host daily [Office Hours](https://pages.near.org/developers/get-help/office-hours/) live where the DevRel team will answer any questions you may have. ü§î

Monday ‚Äì Friday 11AM ‚Äì 12PM Pacific (6PM ‚Äì 7PM UTC)
:::

'''
'''--- docs/3.tutorials/fts/0-predeployed.md ---
---
id: predeployed-contract
title: Pre-deployed Contract
sidebar_label: Pre-deployed Contract
---

> Learn how to easily receive fungible tokens without doing any software development by using a readily-available FT smart contract.

## Prerequisites

To complete this tutorial successfully, you'll need:

- [A NEAR testnet account](https://testnet.mynearwallet.com)
- [NEAR-CLI](/tools/near-cli#setup)

## Using the FT contract

### Setup

- Log in to your newly created account with `near-cli` by running the following command in your terminal:

```bash
near login
```

 - Set an environment variable for your account ID to make it easy to copy and paste commands from this tutorial:

```bash
export NEARID=YOUR_ACCOUNT_NAME
```
:::note

Be sure to replace `YOUR_ACCOUNT_NAME` with the account name you just logged in with including the `.testnet`.

:::

- Test that the environment variable is set correctly by running:

```bash
echo $NEARID
```

### Receiving Fungible Tokens

NEAR has deployed a new Fungible Token contract to the account `ft.predeployed.examples.testnet` which allows users to freely receive some `gtNEAR` - a new fungible token aimed to promote the power of teamwork! Each `gtNEAR` is equal to `1e24 yocto-gtNEAR` similar to how 1 $NEAR is equal to 1e24 yoctoNEAR.

Using this pre-deployed contract, let's get some gtNEAR!

Start by calling the method `ft_mint` which is a custom function implemented on this contract in order to send your account some `gtNEAR`! The following command will send `0.01 gtNEAR` to your account.

```bash
near call ft.predeployed.examples.testnet ft_mint '{"account_id": "'$NEARID'", "amount": "10000000000000000000000"}' --accountId $NEARID
```

<details>
<summary>Example response: </summary>
<p>

```json
Log [ft.predeployed.examples.testnet]: EVENT_JSON:{"standard":"nep141","version":"1.0.0","event":"ft_mint","data":[{"owner_id":"benjiman.testnet","amount":"10000000000000000000000","memo":"FTs Minted"}]}
Transaction Id Fhqa8YDLKxnxM9jjHCPN4hn1w1RKESYrav3kwDjhWWUu
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/Fhqa8YDLKxnxM9jjHCPN4hn1w1RKESYrav3kwDjhWWUu
''
```

</p>
</details>

- To view tokens owned by an account you can call the FT contract with the following `near-cli` command:

```bash
near view ft.predeployed.examples.testnet ft_balance_of '{"account_id": "'$NEARID'"}'
```

<details>
<summary>Example response: </summary>
<p>

```json
'2250000000000000000000'
```

</p>
</details>

***Congratulations! You just received your first Team Tokens on the NEAR blockchain!*** üéâ

üëâ Now try going to your [NEAR Wallet](https://testnet.mynearwallet.com) and view your FTs in the "Balances" tab. üëà 

:::note Pre-deployed Contract
The contract used in this section has been modified such that you can infinitely get `gtNEAR` by calling `ft_mint`. This function is not part of the FT [standards](https://nomicon.io/Standards/Tokens/FungibleToken/Core) and has been implemented for the purpose of this tutorial.
:::

---

## Final remarks

This basic example illustrates all the required steps to call an FT smart contract on NEAR and receive your own fungible tokens.

Now that you're familiar with the process, you can jump to [Contract Architecture](/tutorials/fts/skeleton) and learn more about the smart contract structure and how you can build your own FT contract from the ground up.

***Happy minting!*** ü™ô

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.4.0`
:::

'''
'''--- docs/3.tutorials/fts/1-skeleton.md ---
---
id: skeleton
title: Skeleton and Rust Architecture
sidebar_label: Contract Architecture
---
import {Github} from "@site/src/components/codetabs"

> In this article, you'll learn about the basic architecture behind the FT contract that you'll develop while following this _"Zero to Hero"_ series.
> You'll discover the contract's layout and you'll see how the Rust files are structured in order to build a feature-complete smart contract.

:::info New to Rust?
If you are new to Rust and want to dive into smart contract development, our [Quick-start guide](../../2.build/2.smart-contracts/quickstart.md) is a great place to start.
:::

---

## Introduction

This tutorial presents the code skeleton for the FT smart contract and its file structure.
You'll find how all the functions are laid out as well as the missing Rust code that needs to be filled in.
Once every file and function has been covered, you'll go through the process of building the mock-up contract to confirm that your Rust toolchain works as expected.

## File structure

The repository comes with many different folders. Each folder represents a different milestone of this tutorial starting with the skeleton folder and ending with the finished contract folder. If you step into any of these folders, you'll find that they each follow a regular [Rust](https://www.rust-lang.org/) project. The file structure for these smart contracts have:

- `Cargo.toml` file to define the code dependencies (similar to `package.json` in JavaScript and node projects)
- `src` folder where all the Rust source files are stored
- `target` folder where the compiled `wasm` will output to
- `build.sh` script that has been added to provide a convenient way to compile the source code

### Source files

| File                             | Description                                                                      |
| -------------------------------- | -------------------------------------------------------------------------------- |
| [ft_core.rs](#corers)       | Contains the logic for transferring and controlling FTs. This file represents the implementation of the [core](https://nomicon.io/Standards/Tokens/FungibleToken/Core) standard. |              |
| [lib.rs](#librs)                 | Holds the smart contract initialization functions and dictates what information is kept on-chain.                               |
| [metadata.rs](#metadatars)       | Defines the metadata structure. This file represents the implementation of the [metadata](https://nomicon.io/Standards/Tokens/FungibleToken/Metadata) extension of the standard.                                      |
| [storage.rs](#storagers)               | Contains the logic for registration and storage.  This file represents the implementation of the [storage management](https://nomicon.io/Standards/StorageManagement) standard.                                                   |                          

```
skeleton
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ build.sh
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ ft_core.rs
    ‚îú‚îÄ‚îÄ lib.rs
    ‚îú‚îÄ‚îÄ metadata.rs
    ‚îî‚îÄ‚îÄ storage.rs
```

:::tip
Explore the code in our [GitHub repository](https://github.com/near-examples/ft-tutorial/tree/main/1.skeleton).
:::

---

## `ft_core.rs`

> Core logic that allows you to transfer FTs between users and query for important information.

| Method                   | Description                                                                                                                                                                                                                                                                                   |
| ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **ft_transfer**         | Transfers a specified amount of FTs to a receiver ID.|
| **ft_transfer_call**    | Transfers a specified amount of FTs to a receiver and attempts to perform a cross-contract call on the receiver‚Äôs contract to execute the `ft_on_transfer` method. The implementation of this `ft_on_transfer` method is up to the contract writer. You‚Äôll see an example implementation in the marketplace section of this tutorial. Once `ft_on_transfer` finishes executing, `ft_resolve_transfer` is called to check if things were successful or not.|
| **ft_total_supply**            | Returns the total amount of fungible tokens in circulation on the contract. |
| **ft_balance_of**            | Returns how many fungible tokens a specific user owns.|
| **ft_on_transfer**      | Method that lives on a receiver's contract. It is called when FTs are transferred to the receiver's contract account via the `ft_transfer_call` method. It returns how many FTs should be refunded back to the sender. |
| **ft_resolve_transfer** | Invoked after the `ft_on_transfer` is finished executing. This function will refund any FTs not used by the receiver contract and will return the net number of FTs sent to the receiver after the refund (if any). |

<Github language="rust" start="61" end="166" url="https://github.com/near-examples/ft-tutorial/blob/main/1.skeleton/src/ft_core.rs" />

You'll learn more about these functions in the [circulating supply](/tutorials/fts/circulating-supply) and [transfers](/tutorials/fts/transfers) sections of the tutorial series.

---

## `lib.rs`

> This file outlines what information the contract stores and keeps track of.

| Method               | Description                                                                                     |
| -------------------- | ----------------------------------------------------------------------------------------------- |
| **new_default_meta** | Initializes the contract with default `metadata` so the user doesn't have to provide any input. In addition, a total supply is passed in which is sent to the owner |
| **new**              | Initializes the contract with the user-provided `metadata` and total supply.                                     |

:::info Keep in mind
The initialization functions (`new`, `new_default_meta`) can only be called once.
:::

<Github language="rust" start="34" end="58" url="https://github.com/near-examples/ft-tutorial/blob/main/1.skeleton/src/lib.rs" />

You'll learn more about these functions in the [define a token](2-define-a-token.md) section of the tutorial series.

---

## `metadata.rs`

> This file is used to outline the metadata for the Fungible Token itself.
> In addition, you can define a function to view the contract's metadata which is part of the standard's [metadata](https://nomicon.io/Standards/Tokens/FungibleToken/Metadata) extension.

| Name              | Description                                                                                                   |
| ----------------- | ------------------------------------------------------------------------------------------------------------- |
| **FungibleTokenMetadata** | This structure defines the metadata for the fungible token.       |
| **ft_metadata**  | This function allows users to query for the token's metadata                                      |

<Github language="rust" start="10" end="30" url="https://github.com/near-examples/ft-tutorial/blob/main/1.skeleton/src/metadata.rs" />

You'll learn more about these functions in the [define a token](2-define-a-token.md) section of the tutorial series.

---

## `storage.rs`

> Contains the registration logic as per the [storage management](https://nomicon.io/Standards/StorageManagement) standard.

| Method                  | Description                                                                                                   |
| ----------------------- | ------------------------------------------------------------------------------------------------------------- |
| **storage_deposit**          | Payable method that receives an attached deposit of ‚ìÉ for a given account. This will register the user on the contract. |
| **storage_balance_bounds** | Returns the minimum and maximum allowed storage deposit required to interact with the contract. In the FT contract's case, min = max.|
| **storage_balance_of** | Returns the total and available storage paid by a given user. In the FT contract's case, available is always 0 since it's used by the contract for registration and you can't overpay for storage.  |

<Github language="rust" start="79" end="106" url="https://github.com/near-examples/ft-tutorial/blob/main/1.skeleton/src/storage.rs" />

:::tip
You'll learn more about these functions in the [storage](4.storage.md) section of the tutorial series.
:::

## Building the skeleton

- If you haven't cloned the main repository yet, open a terminal and run:

```sh
git clone https://github.com/near-examples/ft-tutorial/
```

- Next, build the skeleton contract with the build script found in the `1.skeleton/build.sh` file.

```sh
cd ft-tutorial/1.skeleton
./build.sh
cd ..
```

Since this source is just a skeleton you'll get many warnings about unused code, such as:

```
   = note: `#[warn(dead_code)]` on by default

warning: constant is never used: `GAS_FOR_RESOLVE_TRANSFER`
 --> src/ft_core.rs:5:1
  |
5 | const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(5_000_000_000_000);
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: constant is never used: `GAS_FOR_FT_TRANSFER_CALL`
 --> src/ft_core.rs:6:1
  |
6 | const GAS_FOR_FT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: `fungible-token` (lib) generated 25 warnings
    Finished release [optimized] target(s) in 1.93s
‚ú®  Done in 2.03s.
```

Don't worry about these warnings, you're not going to deploy this contract yet.
Building the skeleton is useful to validate that your Rust toolchain works properly and that you'll be able to compile improved versions of this FT contract in the upcoming tutorials.

---

## Conclusion

You've seen the layout of this FT smart contract, and how all the functions are laid out across the different source files.
Using `yarn`, you've been able to compile the contract, and you'll start fleshing out this skeleton in the next [section](/tutorials/fts/circulating-supply) of the tutorial.

:::note Versioning for this article
At the time of this writing, this example works with the following versions:

- rustc: `1.6.0`
- near-sdk-rs: `4.0.0`
:::

'''
'''--- docs/3.tutorials/fts/2-define-a-token.md ---
---
id: defining-a-token
title: Defining a Fungible Token
sidebar_label: Defining Your Token
---
import {Github} from "@site/src/components/codetabs"

This is the first of many tutorials in a series where you'll be creating a complete FT smart contract from scratch that conforms with all the NEAR [FT standards](https://nomicon.io/Standards/Tokens/FungibleToken/Core). Today you'll learn what a Fungible Token is and how you can define one on the NEAR blockchain. You will be modifying a bare-bones [skeleton smart contract](/tutorials/fts/skeleton) by filling in the necessary code snippets needed to add this functionality.

## Introduction

To get started, switch to the `1.skeleton` folder in our repo. If you haven't cloned the repository, refer to the [Contract Architecture](/tutorials/fts/skeleton) to get started.

If you wish to see the finished code for this portion of the tutorial, that can be found on the `2.defining-a-token` folder.

## Modifications to the skeleton contract {#modifications}

At its very core, a fungible token is an exchangeable asset that **is divisible** but is **not unique**. For example, if Benji had 1 Canadian dollar, it would be worth the exact same as Matt's Canadian dollar. Both their dollars are fungible and exchangeable. In this case, the fungible token is the canadian dollar. All fiat currencies are fungible and exchangeable.

Non-fungible tokens, on the other hand, are **unique** and **indivisible** such as a house or a car. You **cannot** have another asset that is exactly the same. Even if you had a specific car model, such as a Corvette 1963 C2 Stingray, each car would have a separate serial number with a different number of kilometers driven etc...

Now that you understand what a fungible token is, let's look at how you can define one in the contract itself.

### Defining a fungible token {#defining-a-fungible-token}

Start by navigating to the `1.skeleton/src/metadata.rs` file. This is where you'll define the metadata for the fungible token itself. There are several ways NEAR allows you to customize your token, all of which are found in the [metadata](https://nomicon.io/Standards/Tokens/FungibleToken/Core#metadata) standard. Let's break them up into the optional and non-optional portions.

Required:
- **spec**: Indicates the version of the standard the contract is using. This should be set to `ft-1.0.0`.
- **name**: The human readable name of the token such as "Wrapped NEAR" or "TEAM Tokens".
- **symbol**: The abbreviation of the token such as `wNEAR` or `gtNEAR`.
- **decimals**: used in frontends to show the proper significant digits of a token. This concept is explained well in this [OpenZeppelin post](https://docs.openzeppelin.com/contracts/3.x/erc20#a-note-on-decimals).

Optional:
- **icon**: The image for the token (must be a [data URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs)).
- **reference**: A link to any supplementary JSON details for the token stored off-chain.
- **reference_hash**: A hash of the referenced JSON.

With this finished, you can now add these fields to the metadata in the contract.

<Github language="rust" start="8" end="18" url="https://github.com/near-examples/ft-tutorial/blob/main/2.define-a-token/src/metadata.rs" />

Now that you've defined what the metadata will look like, you need someway to store it on the contract. Switch to the `1.skeleton/src/lib.rs` file and add the following to the `Contract` struct. You'll want to store the metadata on the contract under the `metadata` field.

<Github language="rust" start="18" end="23" url="https://github.com/near-examples/ft-tutorial/blob/main/2.define-a-token/src/lib.rs" />

You've now defined *where* the metadata will live but you'll also need someway to pass in the metadata itself. This is where the initialization function comes into play.

#### Initialization Functions

You'll now create what's called an initialization function; you can name it `new`. This function needs to be invoked when you first deploy the contract. It will initialize all the contract's fields that you've defined with default values. It's important to note that you **cannot** call these methods more than once.

<Github language="rust" start="56" end="72" url="https://github.com/near-examples/ft-tutorial/blob/main/2.define-a-token/src/lib.rs" />

More often than not when doing development, you'll need to deploy contracts several times. You can imagine that it might get tedious to have to pass in metadata every single time you want to initialize the contract. For this reason, let's create a function that can initialize the contract with a set of default `metadata`. You can call it `new_default_meta`.

<Github language="rust" start="36" end="52" url="https://github.com/near-examples/ft-tutorial/blob/main/2.define-a-token/src/lib.rs" />

This function is simply calling the previous `new` function and passing in some default metadata behind the scenes.

At this point, you've defined the metadata for your fungible tokens and you've created a way to store this information on the contract. The last step is to introduce a getter that will query for and return the metadata. Switch to the `1.skeleton/src/metadata.rs` file and add the following code to the `ft_metadata` function.

<Github language="rust" start="20" end="30" url="https://github.com/near-examples/ft-tutorial/blob/main/2.define-a-token/src/metadata.rs" />

This function will get the `metadata` object from the contract which is of type `FungibleTokenMetadata` and will return it.

## Interacting with the contract on-chain

Now that the logic for defining a custom fungible token is complete and you've added a way to query for the metadata, it's time to build and deploy your contract to the blockchain.

### Deploying the contract {#deploy-the-contract}

We've included a very simple way to build the smart contracts throughout this tutorial using a bash script. The following command will build the contract and copy over the `.wasm` file to a folder `out/contract.wasm`. The build script can be found in the `1.skeleton/build.sh` file.

```bash
cd 1.skeleton && ./build.sh && cd ..
```

There will be a list of warnings on your console, but as the tutorial progresses, these warnings will go away. You should now see the folder `out/` with the file `contract.wasm` inside. This is what we will be deploying to the blockchain.

For deployment, you will need a NEAR account with the keys stored on your local machine. Navigate to the [NEAR wallet](https://testnet.mynearwallet.com//) site and create an account.

:::info
Please ensure that you deploy the contract to an account with no pre-existing contracts. It's easiest to simply create a new account or create a sub-account for this tutorial.
:::

Log in to your newly created account with `near-cli` by running the following command in your terminal.

```bash
near login
```

To make this tutorial easier to copy/paste, we're going to set an environment variable for your account ID. In the command below, replace `YOUR_ACCOUNT_NAME` with the account name you just logged in with including the `.testnet` portion:

```bash
export FT_CONTRACT_ID="YOUR_ACCOUNT_NAME"
```

Test that the environment variable is set correctly by running:

```bash
echo $FT_CONTRACT_ID
```

Verify that the correct account ID is printed in the terminal. If everything looks correct you can now deploy your contract.
In the root of your FT project run the following command to deploy your smart contract.

```bash
near deploy $FT_CONTRACT_ID out/contract.wasm
```

At this point, the contract should have been deployed to your account and you're ready to move onto creating your personalized fungible token.

### Creating the fungible token {#initialize-contract}

The very first thing you need to do once the contract has been deployed is to initialize it. For simplicity, let's call the default metadata initialization function you wrote earlier so that you don't have to type the metadata manually in the CLI.

```bash
near call $FT_CONTRACT_ID new_default_meta '{"owner_id": "'$FT_CONTRACT_ID'", "total_supply": "0"}' --accountId $FT_CONTRACT_ID
```

### Viewing the contract's metadata

Now that the contract has been initialized, you can query for the metadata by calling the function you wrote earlier.

```bash
near view $FT_CONTRACT_ID ft_metadata
```

This should return an output similar to the following:

```bash
{
  spec: 'ft-1.0.0',
  name: 'Team Token FT Tutorial',
  symbol: 'gtNEAR',
  icon: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/
        /*
        ...lots of base64 data...
        */
        j4Mvhy9H9NlnieJ4iwoo9ZlyLGx4pnrPWeB4CVGRZZcJ7Vohwhi0z5MJY4cVL4MdP/Z',
  reference: null,
  reference_hash: null,
  decimals: 24
}
```

**Go team!** You've now verified that everything works correctly and you've defined your own fungible token!

In the next tutorial, you'll learn about how to create a total supply and view the tokens in the wallet.

## Conclusion

In this tutorial, you went through the basics of setting up and understanding the logic behind creating a fungible token on the blockchain using a skeleton contract.

You first looked at [what a fungible token is](#modifications) and how it differs from a non-fungible token. You then learned how to customize and create your own fungible tokens and how you could modify the skeleton contract to achieve this. Finally you built and deployed the contract and interacted with it using the NEAR CLI.

## Next Steps

In the [next tutorial](/tutorials/fts/circulating-supply), you'll find out how to create an initial supply of tokens and have them show up in the NEAR wallet.

'''
'''--- docs/3.tutorials/fts/3-circulating-supply.md ---
---
id: circulating-supply
title: Creating a Circulating Supply
sidebar_label: Circulating Supply
---
import {Github} from "@site/src/components/codetabs"

In the previous tutorial, you looked at what a fungible token was and how you could define one in your smart contract. In this tutorial, you'll learn how to create a circulating supply belonging to the contract owner and view all the tokens, with their metadata, in the NEAR wallet.

To get started, either work off the code you wrote in the previous tutorial or switch to the `2.define-a-token` folder in our repo. If you haven't cloned the repository, refer to the [Contract Architecture](1-skeleton.md) to start.

If you wish to see the finished code for this tutorial, you can find it in the `3.initial-supply` folder.

## Introduction

Every fungible token contract on NEAR has what's known as a circulating supply. This is the number of tokens that exist on the contract and are actively available to trade.

When creating your contract, there are many different ways you could implement this to start. A few examples could be:
- Specify a starting total supply and distribute it based on a set of parameters (Benji gets 20%, Josh gets 2.5%, and the rest goes to Mike).
- Have a first come first serve pool where everybody claims up to X amount of tokens.
- Create tokens on demand resulting in a steady increase of the circulating supply overtime up to a specified cap.

The simplest approach, however, is to specify a total supply when initializing the contract. The entire circulating supply is then created and sent to the owner of the contract. The owner would then be able to transfer or sell the tokens as they wish. Once the initial supply is created, no more FTs could be minted. This means that the circulating supply will always be equal to the total supply.

## Modifications to contract

In order to implement this logic, you'll need to keep track of two things in your smart contract:
- A mapping of an account to the number of tokens they own.
- The total supply of tokens.

The mapping is so that you can easily check or modify the tokens owned by any given account at anytime within your contract. You'll also need to keep track of the total supply since it's required by the standard that you have a function to query for the supply of tokens on the contract.

### Setting the supply

Head over to the `src/lib.rs` file and add the following code to the `Contract` struct.

<Github language="rust" start="21" end="32" url="https://github.com/near-examples/ft-tutorial/blob/main/3.initial-supply/src/lib.rs" />

You'll now want to add the functionality for depositing the tokens into the owner's account. Do this by creating a helper function that takes an amount and an account ID and performs the deposit logic for you. First create a new file `src/internal.rs` such that your file structure now looks as follows.

```
src
  ‚îú‚îÄ‚îÄ ft_core.rs
  ‚îú‚îÄ‚îÄ internal.rs
  ‚îú‚îÄ‚îÄ lib.rs
  ‚îú‚îÄ‚îÄ metadata.rs
  ‚îî‚îÄ‚îÄ storage.rs
```

In the `internal.rs` file, add the following code to create a function called `internal_deposit` which takes an `AccountId` and a `Balance` and adds the amount to the account's current supply of FTs. 

<Github language="rust" start="1" end="18" url="https://github.com/near-examples/ft-tutorial/blob/main/3.initial-supply/src/internal.rs" />

Now that the functionality for depositing FTs is in place, switch back to the `src/lib.rs` file and add the `internal` module:

<Github language="rust" start="8" end="10" url="https://github.com/near-examples/ft-tutorial/blob/main/3.initial-supply/src/lib.rs" />

In addition, add the following code to the `new` initialization function.

```rust
#[init]
pub fn new(
    owner_id: AccountId,
    total_supply: U128,
    metadata: FungibleTokenMetadata,
) -> Self {
    // Create a variable of type Self with all the fields initialized. 
    let mut this = Self {
        // Set the total supply
        total_supply: total_supply.0,
        // Storage keys are simply the prefixes used for the collections. This helps avoid data collision
        accounts: LookupMap::new(StorageKey::Accounts.try_to_vec().unwrap()),
        metadata: LazyOption::new(
            StorageKey::Metadata.try_to_vec().unwrap(),
            Some(&metadata),
        ),
    };

    // Set the owner's balance to the total supply.
    this.internal_deposit(&owner_id, total_supply.into());

    // Return the Contract object
    this
}
```

This will initialize the total supply to what you passed in and will call the `internal_deposit` function to add the total supply to the owner's account.

### Getting the supply

Now that you've created a way to set the total supply, you'll also want a way to query for it as well as the balance for a specific user. The [standard](https://nomicon.io/Standards/Tokens/FungibleToken/Core) dictates that you should have two methods on your smart contract for doing these operations:
- **`ft_total_supply`**
- **`ft_balance_of`**

Head on over to the `src/ft_core.rs` file and add the following code to these functions.

<Github language="rust" start="83" end="91" url="https://github.com/near-examples/ft-tutorial/blob/main/3.initial-supply/src/ft_core.rs" />

At this point, you have everything you need to create an initial supply of tokens and query for the balance of a given account. There is, however, a problem that we need to solve. How will the wallet know that the total supply was created and is owned by the contract owner? How would it even know that our contract is a fungible token contract? If you were to deploy the contract and run through the setup process, you would be able to query for the information from the contract but you wouldn't see any FTs in the owner's NEAR wallet.

## Events

Have you ever wondered how the wallet knows which FTs you own and how it can display them in the [balances tab](https://testnet.mynearwallet.com/)? Originally, an [indexer](/tools/indexer-for-explorer) was used and it listened for any functions starting with `ft_` on your account. These contracts were then flagged on your account as likely FT contracts. 

When you navigated to your balances tab, the wallet would then query all those contracts for the number of FTs you owned using the `ft_balance_of` function you just wrote.

### The problem {#the-problem}

This method of flagging contracts was not reliable as each FT-driven application might have its own way of minting or transferring FTs. In addition, it's common for apps to transfer or mint many tokens at a time using batch functions. 

### The solution {#the-solution}

A standard was introduced so that smart contracts could emit an event anytime FTs were transferred, minted, or burnt. This event was in the form of a log. No matter how a contract implemented the functionality, an indexer could now listen for those standardized logs.

As per the standard, you need to implement a logging functionality that gets fired when FTs are transferred or minted. In this case, the contract doesn't support burning so you don't need to worry about that for now.

It's important to note the standard dictates that the log should begin with `"EVENT_JSON:"`. The structure of your log should, however, always contain the 3 following things: 

- **standard**: the current name of the standard (e.g. nep141)
- **version**: the version of the standard you're using (e.g. 1.0.0)
- **event**: a list of events you're emitting.

The event interface differs based on whether you're recording transfers or mints. The interface for both events is outlined below.

**Transfer events**:
- **old_owner_id**: the old owner of the FTs.
- **new_owner_id**: the new owner that the FTs are being transferred to.
- **amount**: the number of tokens transferred.
- *Optional* - **memo**: an optional message to include with the event.

**Minting events**:
- **owner_id**: the owner that the FTs are being minted to.
- **amount**: the amount of FTs being minted.
- *Optional* - **memo**: an optional message to include with the event.

### Examples {#examples}

In order to solidify your understanding of the standard, let's walk through two scenarios and see what the logs should look like.

#### Scenario A - simple mint

In this scenario, the Benji mints 50 FTs to himself and doesn't include a message. The log should look as follows.

```json
EVENT_JSON:{
  "standard": "nep141",
  "version": "1.0.0",
  "event": "ft_mint",
  "data": [
    {"owner_id": "benji.testnet", "amount": "50"}
  ]
}
```

#### Scenario B - batch transfer

In this scenario, Benji wants to perform a batch transfer. He will send FTs to Jada, Mike, Josh, and Maria. The log is as follows.

```json
EVENT_JSON:{
    "standard": "nep141",
    "version": "1.0.0",
    "event": "ft_transfer",
    "data": [
        {"old_owner_id": "benji.near", "new_owner_id": "josh.near", "amount": "1", "memo": "go team"},
        {"old_owner_id": "benji.near", "new_owner_id": "mike.near", "amount": "9000"},
        {"old_owner_id": "benji.near", "new_owner_id": "jada.near", "amount": "500"},
        {"old_owner_id": "benji.near", "new_owner_id": "maria.near", "amount": "500"}
    ]
}
```

## Modifications to the contract {#modifications-to-the-contract}

At this point, you should have a good understanding of what the end goal should be so let's get to work! Open the `src` directory and create a new file called `events.rs`. This is where your log structs will live.

### Creating the events file {#events-rs}

Copy the following into your file. This will outline the structs for your `EventLog`, `FtMintLog`, and `FtTransferLog`. In addition, we've added a way for `EVENT_JSON:` to be prefixed whenever you log the `EventLog`. 

<Github language="rust" start="1" end="121" url="https://github.com/near-examples/ft-tutorial/blob/main/3.initial-supply/src/events.rs" />

### Adding modules and constants {#lib-rs}

Now that you've created a new file, you need to add the module to the `lib.rs` file.

<Github language="rust" start="1" end="13" url="https://github.com/near-examples/ft-tutorial/blob/main/3.initial-supply/src/lib.rs" />

### Logging the total supply minted

Now that all the tools are set in place, you can implement the actual logging functionality. Since the contract will only be minting tokens at the very start when it's initialized, it's trivial where you should place the log. Open the `src/lib.rs` file and navigate to the bottom of the `new` initialization function. This is where you'll construct the log for minting.

<Github language="rust" start="63" end="97" url="https://github.com/near-examples/ft-tutorial/blob/main/3.initial-supply/src/lib.rs" />

With that finished, you've successfully implemented the backbone of the events standard and it's time to start testing.

## Deploying the contract {#redeploying-contract}

Since the current contract you have is already initialized, let's create a sub-account and deploy to that instead.

### Creating a sub-account

Run the following command to create a sub-account `events` of your main account with an initial balance of 25 NEAR which will be transferred from the original to your new account.

```bash
near create-account events.$FT_CONTRACT_ID --masterAccount $FT_CONTRACT_ID --initialBalance 25
```

Next, you'll want to export an environment variable for ease of development:

```bash
export EVENTS_FT_CONTRACT_ID=events.$FT_CONTRACT_ID
```

Using the build script, build the deploy the contract as you did in the previous tutorials:

```bash
cd 2.define-a-token && ./build.sh && cd .. && near deploy $EVENTS_FT_CONTRACT_ID out/contract.wasm 
```

### Initialization {#initialization}

Now that the contract is deployed, it's time to initialize it and mint the total supply. Let's create an initial supply of 1000 `gtNEAR`. Since it has 24 decimal places, you should put `1000` followed by 24 zeros in the total supply field.

```bash
near call $EVENTS_FT_CONTRACT_ID new_default_meta '{"owner_id": "'$EVENTS_FT_CONTRACT_ID'", "total_supply": "1000000000000000000000000000"}' --accountId $EVENTS_FT_CONTRACT_ID
```

You can check to see if everything went through properly by looking at the output in your CLI:

```bash
Scheduling a call: events.goteam.testnet.new_default_meta({"owner_id": "events.goteam.testnet", "total_supply": "1000000000000000000000000000"})
Doing account.functionCall()
Receipt: BmD2hQJCUEMmvaUd45qrt7S55cewUXQSTPWT21Um3gXd
	Log [events.goteam.testnet]: EVENT_JSON:{"standard":"nep141","version":"1.0.0","event":"ft_mint","data":[{"owner_id":"events.goteam.testnet","amount":"1000000000000000000000000000","memo":"Initial token supply is minted"}]}
Transaction Id BrEBqE9S3tTBcgDUU6ZyszjAbaR4wkPyEN1viYKaXpgh
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/BrEBqE9S3tTBcgDUU6ZyszjAbaR4wkPyEN1viYKaXpgh
''
```

You can see that the event was properly logged!

### Querying Supply Information {#testing}

You can now test if your view functions work properly. First, try to query for the total supply.

```bash
near view $EVENTS_FT_CONTRACT_ID ft_total_supply
```

This should return an output similar to the following:

```bash
'1000000000000000000000000000'
```

Hurray! Now you can check if the balance of the owner account works properly. If you call the following function, it should return the same number as the total supply.

```bash
near view $EVENTS_FT_CONTRACT_ID ft_balance_of '{"account_id": "'$EVENTS_FT_CONTRACT_ID'"}'
```
Returns:

```bash
'1000000000000000000000000000'
```

If you query for the balance of some other account, it should return `0`.

```bash
near view $EVENTS_FT_CONTRACT_ID ft_balance_of '{"account_id": "benjiman.testnet"}'
```

## Viewing FTs in the wallet {#viewing-fts-in-wallet}

Now that your contract implements the necessary functions that the wallet uses to pickup your contract and display the FTs, you should be able to see your tokens on display in the [balances tab](https://testnet.mynearwallet.com/).

<img width="65%" src="/docs/assets/fts/filled-fts-in-wallet.png" />

üéâüéâüéâ **This is awesome! Go team!** üéâüéâüéâ You can now see your very first fungible tokens in the wallet!

## Conclusion

Today you went through and created the logic for minting a total supply. You then implemented some of the core standard logic and the [events standard](https://nomicon.io/Standards/Tokens/FungibleToken/Event). You created events for [minting](#modifications-to-the-contract) FTs on initialization. You then deployed and [tested](#testing) your changes and saw your very first FTs in the wallet!

In the next tutorial, you'll look at the basics of registering accounts so that they can transfer and receive FTs.

'''
'''--- docs/3.tutorials/fts/4.storage.md ---
---
id: registering-accounts
title: Registering Accounts
sidebar_label: Registering Accounts
---
import {Github} from "@site/src/components/codetabs"

In the previous tutorial, you looked at how to mint an initial circulating supply of tokens and how you could log events as per the [events standard](https://nomicon.io/Standards/Tokens/FungibleToken/Event). You then deployed the contract and saw the FTs in your wallet balance. In this tutorial, you'll learn about the [storage management](https://nomicon.io/Standards/StorageManagement) standard and how you can register accounts in your FT contract in order to prevent a malicious party from draining your contract of all its funds.

## Introduction

Whenever a new person receives any fungible tokens, they're added to the `accounts` lookup map on the contract. By doing this, you're adding bytes to the contract. If you made it so any user could receive FTs for free, that system could easily be abused. Users could essentially "drain" the contract of all it's funds by sending small amounts of FTs to many accounts. For this reason, you'll want to charge users for the information they're storing and the bytes they're using on the contract. This way of charging users, however, should be standardized so it works across all contracts.

*Enter the [storage management](https://nomicon.io/Standards/StorageManagement) standard*

<img width="65%" src="/docs/assets/fts/storage-standard-meme.png" />

### Storage Management Standard

The storage management standard is a set of rules that govern how a contract should charge users for storage. It outlines functions and behaviors such that all contracts implementing the standard are interoperable with each other. The 3 functions you'll need to implement are:
- **`storage_deposit`** - Allows a user to deposit some amount of storage to the contract. If the user over deposits, they're refunded for the excess $NEAR.
- **`storage_balance_of`** - Query for the storage paid by a given user
- **`storage_balance_bounds`** - Query for the minimum and maximum amount of storage needed to interact with a given contract.

With these functions outlined, you could make a reasonable assumption that the flow would be:
1. If a user doesn't exist on the contract, they need to deposit some storage to cover the bytes they use.
2. Once the user deposits $NEAR via the `storage_deposit` function, they're free to interact with the contract.

You might be asking yourself what the deposit amount should be. There are two ways you can go about getting this information:
- Dynamically calculate the bytes every individual user would take up in the `storage_deposit` function by inserting them into `accounts` map, measuring the bytes, and then removing them from the map after.
- Calculate the bytes for inserting a largest possible account ID once upon initializing the contract and simply charge every user the same amount.

For the purpose of simplicity, we'll assume the second method.

## Modifications to the Contract

This "bytes for longest account ID" should be stored in the contract's state such that we can pull the value during the `storage_deposit` function and ensure the user attaches enough $NEAR. Open the `src/lib.rs` file and add the following code to the `Contract` struct. If you're just joining us now, you can find the skeleton code for this tutorial in the `3.initial-supply` folder.

<Github language="rust" start="21" end="35" url="https://github.com/near-examples/ft-tutorial/blob/main/4.storage/src/lib.rs" />

You'll now need a way to calculate this amount which will be done in the initialization function. Move to the `src/internal.rs` file and add the following private function `measure_bytes_for_longest_account_id` which will add the longest possible account ID and remove it while measuring how many bytes the operation took. It will then set the `bytes_for_longest_account_id` field to the result.

<Github language="rust" start="36" end="45" url="https://github.com/near-examples/ft-tutorial/blob/main/4.storage/src/internal.rs" />

You'll also want to create a function for "registering" an account after they've paid for storage. To do this, you can simply insert them into the `accounts` map with a balance of 0. This way, you know that any account currently in the map is considered "registered" and have paid for storage. Any account that attempts to receive FTs must be in the map with a balance of 0 or greater. If they aren't, the contract should throw.

<Github language="rust" start="29" end="34" url="https://github.com/near-examples/ft-tutorial/blob/main/4.storage/src/internal.rs" />

Let's also create a function to panic with a custom message if the user doesn't exist yet.

<Github language="rust" start="5" end="14" url="https://github.com/near-examples/ft-tutorial/blob/main/4.storage/src/internal.rs" />

Now when you call the `internal_deposit` function, rather than defaulting the user's balance to `0` if they don't exist yet via:
```rust
let balance = self.accounts.get(&account_id).unwrap_or(0);
```
You can replace it with the following:
<Github language="rust" start="16" end="27" url="https://github.com/near-examples/ft-tutorial/blob/main/4.storage/src/internal.rs#L16-L27" />

With this finished, your `internal.rs` should look as follows:

```rust
use near_sdk::{require};

use crate::*;

impl Contract {
    pub(crate) fn internal_unwrap_balance_of(&self, account_id: &AccountId) -> Balance {
      ...
    }

    pub(crate) fn internal_deposit(&mut self, account_id: &AccountId, amount: Balance) {
      ...
    }

    pub(crate) fn internal_register_account(&mut self, account_id: &AccountId) {
      ...
    }

    pub(crate) fn measure_bytes_for_longest_account_id(&mut self) {
      ...
    }
}
```

There's only one problem you need to solve with this. When initializing the contract, the implementation will throw. This is because you call `internal_deposit` and the owner doesn't have a balance yet. To fix this, let's modify the initialization function to register the owner before depositing the FTs in their account. In addition, you should measure the bytes for the registration in this function.

<Github language="rust" start="66" end="106" url="https://github.com/near-examples/ft-tutorial/blob/main/4.storage/src/lib.rs" />

### Implementing Storage Standard

With this finished, you're now ready to implement the storage management standard. If you remember, the three functions you'll be implementing, we can break each down into their core functionality and decide how to proceed.

- **`storage_balance_bounds`** - Query for the minimum and maximum amount of storage needed to interact with a given contract.

Since you're creating a fungible token contract and the storage price won't change (unless the $NEAR cost per byte changes), the minimum and maximum storage costs should be the same. These values should be equal to the amount of bytes for the longest account ID you calculated in the `measure_bytes_for_longest_account_id` function multiplied by the current $NEAR price per byte. Switch to the `src/storage.rs` file to get started.

<Github language="rust" start="119" end="129" url="https://github.com/near-examples/ft-tutorial/blob/main/4.storage/src/storage.rs" />

- **`storage_balance_of`** - Query for the storage paid by a given user.

As we mentioned earlier, you can tell if somebody has paid for storage by checking if they're in the `accounts` map. If they are, you know that they've paid the amount returned by `storage_balance_bounds`.

<Github language="rust" start="131" end="138" url="https://github.com/near-examples/ft-tutorial/blob/main/4.storage/src/storage.rs" />

- **`storage_deposit`** - Allows a user to deposit some amount of storage to the contract. If the user over deposits, they're refunded for the excess $NEAR.

In order to implement this logic, you first need to get the attached deposit. You'll also need to ensure that the user hasn't already paid for storage (i.e. they're in the `accounts` map). If they are, simply refund the caller for the $NEAR they attached to the call.

If the user isn't registered yet, you should get the storage cost by calling `storage_balance_bounds` and make sure they've attached enough to cover that amount. Once this if finished, you can register them and refund any excess $NEAR.

<Github language="rust" start="78" end="117" url="https://github.com/near-examples/ft-tutorial/blob/main/4.storage/src/storage.rs" />

With this finished, you're ready to build and deploy the contract!

## Deploying the contract {#redeploying-contract}

Since the current contract you have is already initialized, let's create a sub-account and deploy to again.

### Creating a sub-account

Run the following command to create a sub-account `storage` of your main account with an initial balance of 25 NEAR which will be transferred from the original to your new account.

```bash
near create-account storage.$FT_CONTRACT_ID --masterAccount $FT_CONTRACT_ID --initialBalance 25
```

Next, you'll want to export an environment variable for ease of development:

```bash
export STORAGE_FT_CONTRACT_ID=storage.$FT_CONTRACT_ID
```

Using the build script, build the deploy the contract as you did in the previous tutorials:

```bash
cd 3.initial-supply && ./build.sh && cd .. && near deploy $STORAGE_FT_CONTRACT_ID out/contract.wasm
```

### Initialization {#initialization}

Now that the contract is deployed, it's time to initialize it and mint the total supply. Let's once again create an initial supply of 1000 `gtNEAR`.

```bash
near call $STORAGE_FT_CONTRACT_ID new_default_meta '{"owner_id": "'$STORAGE_FT_CONTRACT_ID'", "total_supply": "1000000000000000000000000000"}' --accountId $STORAGE_FT_CONTRACT_ID
```

If you now query for the storage paid by the owner, you should see that they're registered!
  
```bash
near view $STORAGE_FT_CONTRACT_ID storage_balance_of '{"account_id": "'$STORAGE_FT_CONTRACT_ID'"}'
```

This should return a struct. The Total amount is roughly `0.00125 $NEAR` to register and the user has 0 available $NEAR since it's all being used up to pay for registration.

```bash
{ total: '1250000000000000000000', available: '0' }
```

You can also query for the storage balance required to interact with the contract:

```bash
near view $STORAGE_FT_CONTRACT_ID storage_balance_bounds
```

You'll see that it returns the same amount as the `storage_balance_of` query above with the min equal to the max:

```bash
{ min: '1250000000000000000000', max: '1250000000000000000000' }
```

## Conclusion

Today you went through and created the logic for registering users on the contract. This logic adheres to the [storage management standard](https://nomicon.io/Standards/StorageManagement) and is customized to meet our needs when writing a FT contract. You then built, deployed, and tested those changes. In the [next tutorial](5.transfers.md), you'll look at the basics of how to transfer FTs to other users.

'''
'''--- docs/3.tutorials/fts/5.transfers.md ---
---
id: transfers
title: Transferring Fungible Tokens
sidebar_label: Transferring FTs
---
import {Github} from "@site/src/components/codetabs"

In this tutorial, you'll learn how to implement the [core standards](https://nomicon.io/Standards/Tokens/FungibleToken/Core) into your smart contract. You'll implement the logic that allows you to transfer and receive tokens. If you're joining us for the first time, feel free to clone [this repository](https://github.com/near-examples/ft-tutorial) and follow along in the `4.storage` folder.

:::tip
If you wish to see the finished code for this _Core_ tutorial, you can find it in the `5.transfers` folder.
:::

## Introduction {#introduction}

Up until this point, you've created a simple FT smart contract that allows the owner to mint a total supply of tokens and view information about the Fungible Token itself. In addition, you've added the functionality to register accounts and emit events. Today, you'll expand your smart contract to allow for users to transfer and receive fungible tokens.

The logic for doing a simple transfer is quite easy to understand. Let's say Benji wants to transfer Mike 100 of his fungible tokens. The contract should do a few things:
- Check if Benji owns at least 100 tokens.
- Make sure Benji is calling the function.
- Ensure Mike is registered on the contract.
- Take 100 tokens out of Benji's account.
- Put 100 tokens into Mike's account.

At this point, you're ready to move on and make the necessary modifications to your smart contract.

## Modifications to the contract

Let's start our journey in the `src/ft_core.rs` file.

### Transfer function {#transfer-function}

You'll start by implementing the `ft_transfer` logic which is found in the `src/ft_core.rs` file. This function will transfer the specified `amount` to the `receiver_id` with an optional `memo` such as `"Happy Birthday Mike!"`.

<Github language="rust" start="60" end="72" url="https://github.com/near-examples/ft-tutorial/blob/main/5.transfers/src/ft_core.rs" />

There are a couple things to notice here. 

1. We've introduced a new function called `assert_one_yocto()`. This method will ensure that the user is signing the transaction with a full access key by requiring a deposit of exactly 1 yoctoNEAR, the smallest possible amount of $NEAR that can be transferred. Since the transfer function is potentially transferring very valuable assets, you'll want to make sure that whoever is calling the function has a full access key.

2. We've introduced an `internal_transfer` method. This will perform all the logic necessary to transfer the tokens internally.

### Internal helper functions

Let's quickly move over to the `ft-contract/src/internal.rs` file so that you can implement the `internal_transfer` method which is the core of this tutorial. This function will take the following parameters:

- **sender_id**: the account that's attempting to transfer the tokens.
- **receiver_id**: the account that's receiving the tokens.
- **amount**: the amount of FTs being transferred.
- **memo**: an optional memo to include.

The first thing you'll want to do is make sure the sender isn't sending tokens to themselves and that they're sending a positive number. After that, you'll want to withdraw the tokens from the sender's balance and deposit them into the receiver's balance. You've already written the logic to deposit FTs by using the `internal_deposit` function. 

Let's use similar logic to implement `internal_withdraw`:

<Github language="rust" start="29" end="40" url="https://github.com/near-examples/ft-tutorial/blob/main/5.transfers/src/internal.rs" />

In this case, the contract will get the account's balance and ensure they are registered by calling the `internal_unwrap_balance_of` function. It will then subtract the amount from the user's balance and re-insert them into the map.

Using the `internal_deposit` and `internal_withdraw` functions together, the core of the `internal_transfer` function is complete. 

There's only one more thing you need to do. When transferring the tokens, you need to remember to emit a log as per the [events](https://nomicon.io/Standards/Tokens/FungibleToken/Event) standard:

<Github language="rust" start="42" end="67" url="https://github.com/near-examples/ft-tutorial/blob/main/5.transfers/src/internal.rs" />

Now that this is finished, the simple transfer case is done! You can now transfer FTs between registered users!

### Transfer call function {#transfer-call-function}

In this section, you'll learn about a new function `ft_transfer_call`. This will transfer FTs to a receiver and also call a method on the receiver's contract all in the same transaction.

Let's consider the following scenario. An account wants to transfer FTs to a smart contract for performing a service. The traditional approach would be to perform the service and then ask for the tokens in two separate transactions. If we introduce a ‚Äútransfer and call‚Äù workflow baked into a single transaction, the process can be greatly improved:

<Github language="rust" start="74" end="104" url="https://github.com/near-examples/ft-tutorial/blob/main/5.transfers/src/ft_core.rs" />

This function will do several things:

1. Ensures the caller attached exactly 1 yocto for security purposes. 
2. Transfer the tokens using the `internal_transfer` you just wrote.
3. Creates a promise to call the method `ft_on_transfer` on the `receiver_id`'s contract.
4. After the promise finishes executing, the function `ft_resolve_transfer` is called. 

:::info
This is a very common workflow when dealing with cross contract calls. You first initiate the call and wait for it to finish executing. Then, you invoke a function that resolves the result of the promise and act accordingly. 

Learn more [here](../../2.build/2.smart-contracts/anatomy/crosscontract.md).
:::

When calling `ft_on_transfer`, it will return how many tokens the contract should refund the original sender. 

This is important for a couple of reasons:
1. If you send the receiver too many FTs and their contract wants to refund the excess.
2. If any of the logic panics, all of the tokens should be refunded back to the sender. 

This logic will all happen in the `ft_resolve_transfer` function:

<Github language="rust" start="174" end="221" url="https://github.com/near-examples/ft-tutorial/blob/main/5.transfers/src/ft_core.rs" />

The first thing you'll do is check the status of the promise. If anything failed, you'll refund the sender for the full amount of tokens. If the promise succeeded, you'll extract the amount of tokens to refund the sender based on the value returned from `ft_on_transfer`. Once you have the amount needed to be refunded, you'll perform the actual refund logic by using the `internal_transfer` function you wrote previously.

You'll then return the net amount of tokens that were transferred to the receiver. If the sender transferred 100 tokens but 20 were refunded, this function should return 80.

With that finished, you've now successfully added the necessary logic to allow users to transfer FTs. It's now time to deploy and do some testing.

## Deploying the contract {#redeploying-contract}

Let's create a new sub-account to deploy the contract to. Since these changes are only additive and non state breaking, you could have deployed a patch fix to the contract you deployed in the storage section as well. To learn more about upgrading contracts, see the [upgrading a contract](/tutorials/nfts/upgrade-contract) section in the NFT Zero to Hero tutorial.

### Creating a sub-account

Run the following command to create a sub-account `transfer` of your main account with an initial balance of 25 NEAR which will be transferred from the original to your new account.

```bash
near create-account transfer.$FT_CONTRACT_ID --masterAccount $FT_CONTRACT_ID --initialBalance 25
```

Next, you'll want to export an environment variable for ease of development:

```bash
export TRANSFER_FT_CONTRACT_ID=transfer.$FT_CONTRACT_ID
```

Using the build script, build the deploy the contract as you did in the previous tutorials:

```bash
cd 1.skeleton && ./build.sh && cd .. && near deploy --wasmFile out/contract.wasm --accountId $TRANSFER_FT_CONTRACT_ID
```

:::tip
If you haven't completed the previous tutorials and are just following along with this one, simply create an account and login with your CLI using `near login`. You can then export an environment variable `export TRANSFER_FT_CONTRACT_ID=YOUR_ACCOUNT_ID_HERE`. In addition, you can find the contract code by going to the `5.transfers` folder. Instead of building using `1.skeleton`, you can build by going to the `5.transfers` folder and running `./build.sh`.
:::

### Initialization {#initialization}

Now that the contract is deployed, it's time to initialize it and mint the total supply. Let's once again create an initial supply of 1000 `gtNEAR`.

```bash
near call $TRANSFER_FT_CONTRACT_ID new_default_meta '{"owner_id": "'$TRANSFER_FT_CONTRACT_ID'", "total_supply": "1000000000000000000000000000"}' --accountId $TRANSFER_FT_CONTRACT_ID
```

You can check if you own the FTs by running the following command:

```bash
near view $TRANSFER_FT_CONTRACT_ID ft_balance_of '{"account_id": "'$TRANSFER_FT_CONTRACT_ID'"}'
```

### Testing the transfer function

Let's test the transfer function by transferring 1 `gtNEAR` from the owner account to the account `benjiman.testnet`

:::note
The FTs won't be recoverable unless the account `benjiman.testnet` transfers them back to you. If you don't want your FTs lost, make a new account and transfer the token to that account instead.
:::

You'll first need to register the account `benjiman.testnet` by running the following command.

```bash
near call $TRANSFER_FT_CONTRACT_ID storage_deposit '{"account_id": "benjiman.testnet"}' --accountId $TRANSFER_FT_CONTRACT_ID --amount 0.01
```

Once the account is registered, you can transfer the FTs by running the following command. Take note that you're also attaching exactly 1 yoctoNEAR by using the `--depositYocto` flag. 

```bash
near call $TRANSFER_FT_CONTRACT_ID ft_transfer '{"receiver_id": "benjiman.testnet", "amount": "1000000000000000000000000", "memo": "Go Team :)"}' --accountId $TRANSFER_FT_CONTRACT_ID --depositYocto 1
```

You should see the `FtTransferEvent` being emitted in the console. At this point, if you check for the total supply, it should still be 1000 `gtNEAR` but if you check both the balance of Benji and the balance of the owner, they should reflect the transfer.

```bash
near view $TRANSFER_FT_CONTRACT_ID ft_balance_of '{"account_id": "'$TRANSFER_FT_CONTRACT_ID'"}'
```
```bash
near view $TRANSFER_FT_CONTRACT_ID ft_balance_of '{"account_id": "benjiman.testnet"}'
```
```bash
near view $TRANSFER_FT_CONTRACT_ID ft_total_supply
```

### Testing the transfer call function

Now that you've tested the `ft_transfer` function, it's time to test the `ft_transfer_call` function. If you try to transfer tokens to a receiver that does **not** implement the `ft_on_transfer` function, the contract will panic and the FTs will be **refunded**. Let's test this functionality below.

You can try to transfer the FTs to the account `no-contract.testnet` which, as the name suggests, doesn't have a contract. This means that the receiver doesn't implement the `ft_on_transfer` function and the FTs should remain yours after the transaction is complete. You'll first have to register the account, however.

```bash
near call $TRANSFER_FT_CONTRACT_ID storage_deposit '{"account_id": "no-contract.testnet"}' --accountId $TRANSFER_FT_CONTRACT_ID --amount 0.01
```

```bash
near call $TRANSFER_FT_CONTRACT_ID ft_transfer_call '{"receiver_id": "no-contract.testnet", "amount": "1000000000000000000000000", "msg": "foo"}' --accountId $TRANSFER_FT_CONTRACT_ID --depositYocto 1 --gas 200000000000000
```

The output response should be as follows.

```bash
Scheduling a call: transfer.dev-1660680326316-91393402417293.ft_transfer_call({"receiver_id": "no-contract.testnet", "amount": "1000000000000000000000000", "msg": "foo"}) with attached 0.000000000000000000000001 NEAR
Doing account.functionCall()
Receipts: AJ3yWv7tSiZRLtoTkyTgfdzmQP1dpjX9DxJDiD33uwTZ, EKtpDFoJWNnbyxJ7SriAFQYX8XV9ZTzwmCF2qhSaYMAc, 21UzDZ791pWZRKAHv8WaRKN8mqDVrz8zewLWGTNZTckh
	Log [transfer.dev-1660680326316-91393402417293]: EVENT_JSON:{"standard":"nep141","version":"1.0.0","event":"ft_transfer","data":[{"old_owner_id":"transfer.dev-1660680326316-91393402417293","new_owner_id":"no-contract.testnet","amount":"1000000000000000000000000"}]}
Receipt: 5N2WV8picxwUNC5TYa3A3v4qGquQAhkU6P81tgRt1UFN
	Failure [transfer.dev-1660680326316-91393402417293]: Error: Cannot find contract code for account no-contract.testnet
Receipt: AdT1bSZNCu9ACq7m6ynb12GgSb3zBenfzvvzRwfYPBmg
	Log [transfer.dev-1660680326316-91393402417293]: EVENT_JSON:{"standard":"nep141","version":"1.0.0","event":"ft_transfer","data":[{"old_owner_id":"no-contract.testnet","new_owner_id":"transfer.dev-1660680326316-91393402417293","amount":"1000000000000000000000000","memo":"Refund"}]}
Transaction Id 2XVy8MZU8TWreW8C9zK6HSyBsxE5hyTbyUyxNdncxL8g
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/2XVy8MZU8TWreW8C9zK6HSyBsxE5hyTbyUyxNdncxL8g
'0'
```

There should be a transfer event emitted for the initial transfer of tokens and then also for the refund. In addition, `0` should have been returned from the function because the sender ended up transferring net 0 tokens to the receiver since all the tokens were refunded.

If you query for the balance of `no-contract.testnet`, it should still be 0.

```bash
near view $TRANSFER_FT_CONTRACT_ID ft_balance_of '{"account_id": "no-contract.testnet"}'
```

Hurray! At this point, your FT contract is fully complete and all the functionality is working as expected. Go forth and experiment! The world is your oyster and don't forget, go team!

## Conclusion

In this tutorial, you learned how to expand a FT contract by adding ways for users to transfer FTs. You [broke down](#introduction) the problem into smaller, more digestible subtasks and took that information and implemented both the [FT transfer](#transfer-function) and [FT transfer call](#transfer-call-function) functions. In addition, you deployed another [contract](#redeploying-contract) and [tested](#testing-changes) the transfer functionality.

In the [next tutorial](/tutorials/fts/marketplace), you'll learn about how an NFT marketplace can operate to purchase NFTs by using Fungible Tokens.

'''
'''--- docs/3.tutorials/fts/6-marketplace.md ---
---
id: marketplace
title: Integrating FT Payments into an NFT Marketplace
sidebar_label: Adding FTs to a Marketplace
---
import {Github} from "@site/src/components/codetabs"

In this tutorial, you'll learn the basics of how an NFT marketplace contract works and how you can modify it to allow for purchasing NFTs using Fungible Tokens. In the previous tutorials, you went through and created a fully fledged FT contract that incorporates all the standards found in the [FT standard](https://nomicon.io/Standards/Tokens/FungibleToken/Core). 

## Introduction

Throughout this tutorial, you'll learn how a marketplace contract could work on NEAR. This is meant to be an example and there is no canonical implementation. Feel free to branch off and modify this contract to meet your specific needs.

Using the same repository as the previous tutorials, if you visit the `market-contract` directory, you should have the necessary files to complete the tutorial.

## File structure {#file-structure}

This directory contains both the build script, dependencies as well as the actual contract code as outlined below.

```
market-contract
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ build.sh
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ external.rs
    ‚îú‚îÄ‚îÄ ft_balances.rs
    ‚îú‚îÄ‚îÄ internal.rs
    ‚îú‚îÄ‚îÄ lib.rs
    ‚îú‚îÄ‚îÄ nft_callbacks.rs
    ‚îú‚îÄ‚îÄ sale.rs
    ‚îî‚îÄ‚îÄ sale_views.rs
```

Let's start by building both the finished FT contract and the marketplace contract. Make sure you're in the root directory and run the following command in your terminal:

```bash
yarn build && cd market-contract && ./build.sh && cd ..
```
This will install the dependencies for the marketplace contract as well as the FT contract. In addition, it will compile them to `wasm` such that your `ft-tutorial/out` directory looks like this:

```
ft-tutorial
‚îî‚îÄ‚îÄ out
    ‚îú‚îÄ‚îÄ contract.wasm
    ‚îú‚îÄ‚îÄ nft-contract.wasm
    ‚îî‚îÄ‚îÄ market.wasm
```

Note that there's also a pre-build nft contract wasm file in the directory which you'll use to place the NFTs for sale.

## Understanding the contract

The marketplace contract used in this tutorial is a modified version of the contract created at the end of the NFT zero to hero tutorial. If you'd like to learn about the backbone of how the NFTs are put for sale and the process by which they are minted / sold, check out the [NFT zero to hero tutorial](/tutorials/nfts/marketplace).

The core functionalities are the same in the sense that both this contract and the marketplace contract built in the NFT zero to hero have the following features:
- Users can put NFTs for sale and specify sale conditions
- Users must pay for storage deposit to put NFTs for sale and they can withdraw the storage at any time
- Users can update the price of an NFT or remove the sale entirely
- Buyers can purchase the NFTs by calling `offer`.

The only difference is that this marketplace has removed the ability to purchase NFTs for `$NEAR` and instead allows users to buy them with Fungible Tokens. The fungible token is specified when the contract is initialized and only **1 type of fungible token** can be used to purchase NFTs. You can't, for example, offer 100 Team Tokens for an NFT and 5000 Mike Tokens for another.

In addition, the marketplace does **not** support royalties. This is because FT transfers are less Gas efficient than regular $NEAR transfers. In addition, each user would have to be registered and it's much easier to say "hey seller, make sure you're registered before your NFT is sold" rather than enforcing that the seller and **all** accounts in the payout object are registered. When an NFT is sold, the entire price is sent directly to the seller.

### Purchasing Flow

In order to purchase an NFT, the contract utilizes the "transfer and call" workflow that the FT contract provides. The marketplace contract implements the `ft_on_transfer` method that is called whenever someone transfers FTs to the marketplace contract.

The marketplace keeps track of a balance for each user that outlines how many FTs they've sent to the contract. Each time `ft_on_transfer` is called, the marketplace contract will update the balance for the user. When that user wishes to purchase an NFT, they call `offer` and pass in the amount of tokens they're willing to spend. The marketplace will then decrement from their balance and transfer the NFT to the buyer / send the FTs to the seller.

It's important to note that the seller **must** be registered in the FT contract before a sale is made otherwise the `ft_transfer` method will panic and the seller won't receive any tokens.

## Looking at the Code

Most of the code is the same as what's been outlined in the [NFT zero to hero tutorial](/tutorials/nfts/marketplace) but we'll go through a refresher in case you're new or have forgotten some of the details.

### Main Library File

Starting at the `lib.rs` file, this outlines what information is stored on the contract as well as some other crucial functions that you'll learn about below.

### Initialization function {#initialization-function}

The first function you'll look at is the initialization function. This takes an `owner_id` as well as the `ft_id` as the parameters and will default all the storage collections to their default values. The `ft_id` outlines the account ID for the fungible token that the contract will allow.

<Github language="rust" start="94" end="118" url="https://github.com/near-examples/ft-tutorial/blob/main/market-contract/src/lib.rs" />

### Storage management model {#storage-management-model}

Next, let's talk about the storage management model chosen for this contract. Users will need to deposit $NEAR onto the marketplace to cover the storage costs. Whenever someone puts an NFT for sale, the marketplace needs to store that information which costs $NEAR. Users can either deposit a large amount of $NEAR so that they never have to worry about storage again or they can deposit the minimum amount to cover 1 sale on an as-needed basis.

You might be thinking about the scenario when a sale is purchased. What happens to the storage that is now being released on the contract? This is why we have a storage withdrawal function. This allows users to withdraw any excess storage that is not being used. Let's go through some scenarios to understand the logic. The required storage for 1 sale is 0.01 NEAR on the marketplace contract.

**Scenario A**

- Benji wants to list his NFT on the marketplace but has never paid for storage. 
- He deposits exactly 0.01 NEAR using the `storage_deposit` method. This will cover 1 sale.
- He lists his NFT on the marketplace and is now using up 1 out of his prepaid 1 sales and has no more storage left. If he were to call `storage_withdraw`, nothing would happen.
- Dorian loves his NFT and quickly purchases it before anybody else can. This means that Benji's sale has now been taken down (since it was purchased) and Benji is using up 0 out of his prepaid 1 sales. In other words, he has an excess of 1 sale or 0.01 NEAR.
- Benji can now call `storage_withdraw` and will be transferred his 0.01 NEAR back. On the contract's side, after withdrawing, he will have 0 sales paid for and will need to deposit storage before trying to list anymore NFTs.

**Scenario B**

- Dorian owns one hundred beautiful NFTs and knows that he wants to list all of them.
- To avoid having to call `storage_deposit` everytime he wants to list an NFT, he calls it once. Since Dorian is a baller, he attaches 10 NEAR which is enough to cover 1000 sales. He now has an excess of 9 NEAR or 900 sales.
- Dorian needs the 9 NEAR for something else but doesn't want to take down his 100 listings. Since he has an excess of 9 NEAR, he can easily withdraw and still have his 100 listings. After calling `storage_withdraw` and being transferred 9 NEAR, he will have an excess of 0 sales.

With this behavior in mind, the following two functions outline the logic.

<Github language="rust" start="120" end="183" url="https://github.com/near-examples/ft-tutorial/blob/main/market-contract/src/lib.rs" />

In this contract, the storage required for each sale is 0.01 NEAR but you can query that information using the `storage_minimum_balance` function. In addition, if you wanted to check how much storage a given account has paid, you can query the `storage_balance_of` function.

## FT Deposits

If you want to learn more about how NFTs are put for sale, check out the [NFT zero to hero tutorial](/tutorials/nfts/marketplace). Once NFTs are put for sale, the owner has three options:
- Update the price of the NFT
- Remove the sale from the marketplace
- Wait for somebody to purchase it

In order to purchase NFTs, buyers need to deposit FTs in the contract and call the `offer` function. All the logic for FT deposits is outlined in the `src/ft_balances.rs` file. Starting with the `ft_on_approve` function, this is called when a user transfers FTs to the marketplace contract. The logic can be seen below.

<Github language="rust" start="35" end="77" url="https://github.com/near-examples/ft-tutorial/blob/main/market-contract/src/ft_balances.rs" />

Once FTs are deposited into the contract, users can either withdraw their FTs or they can use them to purchase NFTs. The withdrawing flow is outlined in the `ft_withdraw` function. It's important to note that you should decrement the user's balance **before** calling the `ft_transfer` function to avoid a common exploit scenario where a user spams the `ft_withdraw`. If you were to decrement their balance in the callback function (if the transfer was successful), they could spam the `ft_withdraw` during the time it takes the callback function to execute. A better pattern is to decrement their balance before the transfer and then if the promise was **unsuccessful*, revert the balance back to what it was before.

<Github language="rust" start="79" end="149" url="https://github.com/near-examples/ft-tutorial/blob/main/market-contract/src/ft_balances.rs" />

## Purchasing NFTs

Now that you're familiar with the process of both adding storage and depositing FTs on the marketplace, let's go through what you can do once a sale has been listed. The `src/sale.rs` file outlines the functions for updating the price, removing, and purchasing NFTs. In this tutorial, we'll focus **only** on the purchasing flow. If you'd like to learn about the sale objects, updating the price, and removing a sale, check out the [NFT zero to hero tutorial](/tutorials/nfts/marketplace).

For purchasing NFTs, you must call the `offer` function. It takes an `nft_contract_id`, `token_id`, and the amount you wish to offer as parameters. Behind the scenes, this function will make sure your offer amount is greater than the list price and also that you have enough FTs deposited. It will then call a private method `process_purchase` which will perform a cross-contract call to the NFT contract to invoke the `nft_transfer` function where the NFT will be transferred to the seller. 

<Github language="rust" start="67" end="144" url="https://github.com/near-examples/ft-tutorial/blob/main/market-contract/src/sale.rs" />

Once the transfer is complete, the contract will call `resolve_purchase` where it will check the status of the transfer.If the transfer succeeded, it will send the FTs to the seller. If the transfer didn't succeed, it will increment the buyer's FT balance (acting as a refund).

<Github language="rust" start="146" end="192" url="https://github.com/near-examples/ft-tutorial/blob/main/market-contract/src/sale.rs" />

## View Methods 

There are several view functions that the marketplace contract exposes. All of these functions are the same as the [NFT zero to hero tutorial](/tutorials/nfts/marketplace) except for one extra function we've added. In the `src/ft_balances.rs` file, we've added the `ft_balance_of` function. This function returns the balance of a given account.

## Testing

Now that you *hopefully* have a good understanding of how the marketplace contract works and how you can use the powers of the FT standard to purchase NFTs, let's move onto testing everything. 

### Deploying and Initializing the Contracts

The first thing you'll want to do is deploy a new FT, NFT, and marketplace contract. Start by building and then you can use `dev-accounts` to quickly deploy.

```bash
yarn build && cd market-contract && ./build.sh && cd ..
```

To deploy the FT contract and export an environment variable, run the following command:

```bash
export FT_CONTRACT=<new-ft-account-id>
near create-account $FT_CONTRACT --useFaucet
near deploy $FT_CONTRACT out/contract.wasm
```

Next, you'll deploy the NFT and marketplace contracts.

```bash
export NFT_CONTRACT=<new-nft-account-id>
near create-account $NFT_CONTRACT --useFaucet
near deploy $NFT_CONTRACT out/nft-contract.wasm

export MARKETPLACE_CONTRACT=<new-marketplace-account-id>
near create-account $MARKETPLACE_CONTRACT --useFaucet
near deploy $MARKETPLACE_CONTRACT out/market.wasm
```

Check and see if your environment variables are all correct by running the following command. Each output should be different.

```bash
echo $FT_CONTRACT && echo $MARKETPLACE_CONTRACT && echo $NFT_CONTRACT
```
An example output is:

```bash
dev-1660831615048-16894106456797
dev-1660831638497-73655245450834
dev-1660831648913-23890994169259
```

Once that's finished, go ahead and initialize each contract by running the following commands.

```bash
near call $FT_CONTRACT new_default_meta '{"owner_id": "'$FT_CONTRACT'", "total_supply": "1000000000000000000000000000"}' --accountId $FT_CONTRACT
```
```bash
near call $MARKETPLACE_CONTRACT new '{"owner_id": "'$MARKETPLACE_CONTRACT'", "ft_id": "'$FT_CONTRACT'"}' --accountId $MARKETPLACE_CONTRACT
```
```bash
near call $NFT_CONTRACT new_default_meta '{"owner_id": "'$NFT_CONTRACT'"}' --accountId $NFT_CONTRACT
```

Let's check if each contract was initialized correctly. You can do this by checking the metadata of the FT and NFT contracts:

```bash
near view $FT_CONTRACT ft_metadata && near view $NFT_CONTRACT nft_metadata
```
In addition, you can check the sales of the marketplace contract and it should return 0.

```bash
near view $MARKETPLACE_CONTRACT get_supply_sales
```

### Placing a Token For Sale

Now that the marketplace and NFT contracts are initialized, let's place a token for sale. Start by creating a new buyer and seller account by running the following command. In this case, we'll create a sub-account of the FT contract.

```bash
near create-account buyer.$FT_CONTRACT --masterAccount $FT_CONTRACT --initialBalance 25 && export BUYER_ID=buyer.$FT_CONTRACT
```
```bash
near create-account seller.$FT_CONTRACT --masterAccount $FT_CONTRACT --initialBalance 25 && export SELLER_ID=seller.$FT_CONTRACT
```

Check if everything went well by running the following command.

```bash
echo $BUYER_ID && echo $SELLER_ID
```
This should return something similar to:
```bash
buyer.dev-1660831615048-16894106456797
seller.dev-1660831615048-16894106456797
```
The next thing you'll want to do is mint a token to the seller.

```bash
near call $NFT_CONTRACT nft_mint '{"token_id": "market-token", "metadata": {"title": "Marketplace Token", "description": "testing out the marketplace", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$SELLER_ID'"}' --accountId $NFT_CONTRACT --amount 0.1
```
Now you'll need to place the token for sale. This requires paying for storage as well as calling the `nft_approve` function.

```bash
near call $MARKETPLACE_CONTRACT storage_deposit --accountId $SELLER_ID --amount 0.1
```
In this case, we'll place the token for sale for `10 gtNEAR`.
```bash
near call $NFT_CONTRACT nft_approve '{"token_id": "market-token", "account_id": "'$MARKETPLACE_CONTRACT'", "msg": "{\"sale_conditions\":\"10000000000000000000000000\"}"}' --accountId $SELLER_ID --amount 0.1
```

If you now query for the supply of sales again on the marketplace, it should be 1.

```bash
near view $MARKETPLACE_CONTRACT get_supply_sales
```

In addition, if you query for the sales by the owner ID, it should reflect the `10 gtNEAR` price.
    
```bash
near view $MARKETPLACE_CONTRACT get_sales_by_owner_id '{"account_id": "'$SELLER_ID'"}'
```

Expected output:

```bash
[
  {
    owner_id: 'seller.dev-1660831615048-16894106456797',
    approval_id: 0,
    nft_contract_id: 'dev-1660831648913-23890994169259',
    token_id: 'market-token',
    sale_conditions: '10000000000000000000000000'
  }
]
```

### Deposit FTs into the Marketplace

Now that you have an NFT up for sale for `10 gtNEAR` on the marketplace contract, the buyer needs to deposit some FTs. The first thing you need to do is register both the marketplace contract and the buyer on the FT contract otherwise you won't be able to transfer any FTs.

```bash
near call $FT_CONTRACT storage_deposit '{"account_id": "'$MARKETPLACE_CONTRACT'"}' --accountId $FT_CONTRACT --amount 0.1
```
```bash
near call $FT_CONTRACT storage_deposit '{"account_id": "'$BUYER_ID'"}' --accountId $FT_CONTRACT --amount 0.1
```
After this, you should transfer the buyer some FTs so that they can deposit at least `10 gtNEAR`. Lets start with 50 `gtNEAR`. Run the following command to send the buyer FTs on behalf of the FT contract owner.

```bash
near call $FT_CONTRACT ft_transfer '{"receiver_id": "'$BUYER_ID'", "amount": "50000000000000000000000000", "memo": "Go Team!"}' --accountId $FT_CONTRACT --depositYocto 1
```

You'll now need to deposit those tokens into the marketplace contract.

```bash
near call $FT_CONTRACT ft_transfer_call '{"receiver_id": "'$MARKETPLACE_CONTRACT'", "amount": "50000000000000000000000000", "msg": "Wooooooo!"}' --accountId $BUYER_ID --depositYocto 1 --gas 200000000000000
```

If you now query for your balance on the marketplace contract, it should be `50 gtNEAR`.

```bash
near view $MARKETPLACE_CONTRACT ft_deposits_of '{"account_id": "'$BUYER_ID'"}'
```

### Purchasing the NFT

Now that the buyer has deposited FTs into the marketplace and the token is up for sale, let's go ahead and make an offer! If you try to offer more FTs than what you have, the contract will panic. Similarly, if you try to offer lower than the sale price, the contract will also panic. Since the sale price is `10 gtNEAR`, let's try to offer `20 gtNEAR` and see what happens. The expected outcome is:
- The NFT will be transferred to the buyer
- `20 gtNEAR` will be sent to the seller
- The buyer will have `30 gtNEAR` left to withdraw.

There is one thing we're forgetting, however. We need to make sure that the seller is registered on the FT contract so let's go ahead and do that now.

```bash
near call $FT_CONTRACT storage_deposit '{"account_id": "'$SELLER_ID'"}' --accountId $FT_CONTRACT --amount 0.1
```

Now let's make an offer!

```bash
near call $MARKETPLACE_CONTRACT offer '{"nft_contract_id": "'$NFT_CONTRACT'", "token_id": "market-token", "amount": "20000000000000000000000000"}' --accountId $BUYER_ID --depositYocto 1 --gas 300000000000000
```

If everything went well, you should see 2 events in your terminal. One event is the NFT transfer coming from the NFT contract when the token was transferred from the seller to the buyer. The other event is the FT transfer for when the seller receives their fungible tokens.

```bash
Log [dev-1660831638497-73655245450834]: Memo: payout from market
Log [dev-1660831638497-73655245450834]: EVENT_JSON:{"standard":"nep171","version":"nft-1.0.0","event":"nft_transfer","data":[{"authorized_id":"dev-1660831638497-73655245450834","old_owner_id":"seller.dev-1660831615048-16894106456797","new_owner_id":"buyer.dev-1660831615048-16894106456797","token_ids":["market-token"],"memo":"payout from market"}]}
Receipt: BBvHig5zg1n2vmxFPTpxED4FNCAU1ZzZ3H8EBqqaeRw5
Log [dev-1660831638497-73655245450834]: EVENT_JSON:{"standard":"nep141","version":"1.0.0","event":"ft_transfer","data":[{"old_owner_id":"dev-1660831638497-73655245450834","new_owner_id":"seller.dev-1660831615048-16894106456797","amount":"20000000000000000000000000","memo":"Sale from marketplace"}]}
```

Let's call some view methods to double check if everything went well. First let's check if the seller now has `20 gtNEAR`.

```bash
near view $FT_CONTRACT ft_balance_of '{"account_id": "'$SELLER_ID'"}'
```

Next, let's check if the buyer has `30 gtNEAR` left to withdraw.

```bash
near view $MARKETPLACE_CONTRACT ft_deposits_of '{"account_id": "'$BUYER_ID'"}'
```

Finally, let's check if the NFT is now owned by the buyer.

```bash
near view $NFT_CONTRACT nft_token '{"token_id": "market-token"}'
```

### Withdrawing the Excess Deposits

Now that the buyer purchased the NFT with `20 gtNEAR`, they should have `30 gtNEAR` left to withdraw. If they withdraw the tokens, they should be left with a balance of `30 gtNEAR` on the FT contract.

```bash
near call $MARKETPLACE_CONTRACT ft_withdraw '{"amount": "30000000000000000000000000"}' --accountId $BUYER_ID --depositYocto 1 --gas 300000000000000
```

If you now query for the buyer's balance, it should be `30 gtNEAR`.

```bash
near view $FT_CONTRACT ft_balance_of '{"account_id": "'$BUYER_ID'"}'
```

And just like that you're finished! You went through and put an NFT up for sale and purchased it using fungible tokens! **Go team üöÄ**

## Conclusion

In this tutorial, you learned about the basics of a marketplace contract and how it works. You went through the core logic both at a high level and looked at the code. You deployed an NFT, marketplace, and FT contract, initialized them all and then put an NFT for sale and sold it for fungible tokens! What an amazing experience! Go forth and expand these contracts to meet whatever needs you have. The world is your oyster and thank you so much for following along with this tutorial series. Don't hesitate to ask for help or clarification on anything in our discord or social media channels. **Go Team!**

'''
'''--- docs/3.tutorials/fts/simple-fts.md ---
---
id: simple-fts
title: Minting Fungible Tokens
---

In this tutorial, you'll learn how to easily create your own Fungible Tokens (FT) without doing any software development by using a readily-available smart contract.
This article will show you how to use an existing [FT smart contract](0-predeployed.md), and you'll learn [how to mint](#minting-your-fts) fungible tokens and [view them](#checking-your-wallet) in your Wallet.

## Prerequisites

To complete this tutorial successfully, you'll need:

- [A NEAR account](#wallet)
- [NEAR command-line interface](/tools/near-cli#setup) (`near-cli`)

### Wallet

To store your fungible tokens you'll need a [NEAR Wallet](https://testnet.mynearwallet.com//).
If you don't have one yet, you can create one easily by following [these instructions](https://testnet.mynearwallet.com/create).

Once you have your Wallet account, you can click on the [Balances Tab](https://testnet.mynearwallet.com//?tab=balances) where all your Fungible Tokens will be listed:

![Wallet](/docs/assets/fts/empty-wallet-ft-tab.png)

## Using the FT contract

Now that you have all the tools in place, you're ready to start using the FT smart contract to [mint your FTs](#minting-your-fts).

:::note
If you don't have the command line interface, please [follow these steps](/tools/near-cli#setup).
:::

Ensure you have credentials stored locally for the `testnet` account you will be using to mint tokens with by running the following `near-cli` command in your terminal:

```bash
near login
```

To make this tutorial easier to copy/paste, we're going to set an environment variable for your account ID. In the command below, replace `YOUR_ACCOUNT_NAME` with the account name you just logged in with including the `.testnet`):

```bash
export ID=YOUR_ACCOUNT_NAME
```

Test that the environment variable is set correctly by running:

```bash
echo $ID
```

### Minting your FTs

NEAR has already deployed a contract to the account `ft.examples.testnet` which allows anyone to freely mint `TeamTokens`. This is the account you'll be interacting with to mint your fungible tokens.

Now let's mint some tokens! The command below will mint `25` TeamTokens to your account.
If you look carefully, the `receiver_id` defines the new owner of the tokens you are minting, while `--accountId` specifies which accounted will be used to sign and pay for this transaction. 
Also, there is a `--deposit` flag which attaches `.001` $NEAR to the call to [pay for storage](/concepts/storage/storage-staking) on the fungible token contract. The amount is slightly less than this but you will be refunded the difference. (See the transaction in your wallet) The amount of tokens to be minted is set to 25 but you can increase this value up to 1000.

```bash
near call ft.examples.testnet ft_mint '{"receiver_id": "'$ID'", "amount": "25"}' --deposit 0.1 --accountId $ID
```

After minting your tokens you can query the contract to view the balance of any accountId passed. This is done by performing a contract `view` call and using the `ft_balance_of` endpoint on the fungible token contract. Run the following in your terminal to view the balance:

```bash
near view ft.examples.testnet ft_balance_of '{"account_id": "'$ID'"}'
```

<details>
<summary>Example response: </summary>
<p>

```json
View call: ft.examples.testnet.ft_balance_of({"account_id": "benji_test.testnet"})
'25'
```

</p>
</details>

### Checking your Wallet

:::tip
After you mint your fungible token you can [view it in your NEAR Wallet](https://testnet.mynearwallet.com/)!
:::

> <br/>
>
> ![Wallet with token](/docs/assets/fts/teamtoken.png)
> <br/>

**_Congratulations! You just minted your first Fungible Token on the NEAR blockchain!_** üéâ

## Final remarks

This basic example illustrates all the required steps to call a FT smart contract on NEAR and start minting your own fungible tokens.

**_Happy minting!_** ü™ô

## Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `2.1.1`

'''
'''--- docs/3.tutorials/near-components/blog-posts.md ---
---
id: blog-posts
title: Blog Posts
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

The Blog post components enable your gateway to promote regular Near Social posts into fully fledged blog posts.
In this article you'll learn how to set up the required components so you can define a custom URL to show a clean feed of blog posts.

## Setup

To set up the Blog post features on your [`near-discovery`](https://github.com/near/near-discovery/) gateway:

1. Add the [`Blog.Feed`](https://near.org/near/widget/ComponentDetailsPage?src=near/widget/Blog.Feed) and [`BlogPostPage`](https://near.org/near/widget/ComponentDetailsPage?src=near/widget/BlogPostPage) components
2. Add `near/widget/Blog.Feed` and `near/widget/BlogPostPage` to your configuration

<Tabs>
<TabItem value="discovery" label="near-discovery" default>

- Edit your `bos-components.ts` configuration file:

<Github fname="bos-components.ts" language="js" value="near-discovery"
    url="https://github.com/near/near-discovery/blob/c275ab7d70a6ee7baf3a88ace1c2e02f605da644/src/data/bos-components.ts"
    start="160" end="165" />

</TabItem>

<TabItem value="viewer" label="nearsocial viewer">

- Edit your `widgets.js` configuration file:

```js title="src/data/widgets.js"
const MainnetWidgets = {
  blog: 'near/widget/Blog.Feed',
  blogPost: 'near/widget/BlogPostPage',
  image: "mob.near/widget/Image",
  default: "mob.near/widget/Homepage",
  viewSource: "mob.near/widget/WidgetSource",
  widgetMetadataEditor: "mob.near/widget/WidgetMetadataEditor",
```

</TabItem>

</Tabs>

### Blog feed URL

To set a custom URL such as `/bosblog` for your Blog feed, and define which users will be shown on it, do the following changes on your `near-discovery` gateway:

<Tabs>
<TabItem value="discovery" label="near-discovery" default>

1. Create a folder `src/pages/<customURL>` for your desired custom path (e.g., `/bosblog`)
2. Add this [`index.tsx`](https://github.com/near/near-discovery/blob/c275ab7d70a6ee7baf3a88ace1c2e02f605da644/src/pages/bosblog/index.tsx) file to `src/pages/bosblog/`:

<Github fname="index.tsx" language="js" value="near-discovery"
    url="https://github.com/near/near-discovery/blob/c275ab7d70a6ee7baf3a88ace1c2e02f605da644/src/pages/bosblog/index.tsx"
    start="1" end="50" />

</TabItem>

<TabItem value="viewer" label="nearsocial viewer">

1. Add this `BlogPage.js` file to `src/pages/`:

```js title="src/pages/BlogPage.js"
import React, { useEffect, useState } from "react";
import { Widget } from "near-social-vm";
import { useParams } from "react-router-dom";
import { useQuery } from "../hooks/useQuery";
import { useHashRouterLegacy } from "../hooks/useHashRouterLegacy";

export default function BlogPage(props) {
  useHashRouterLegacy();

  const { widgetSrc } = useParams();
  const query = useQuery();
  const [widgetProps, setWidgetProps] = useState({});
  const src = widgetSrc || props.widgets.default;
  const contributors = ['near', 'jacksonthedev.near'];

  useEffect(() => {
    setWidgetProps(
      [...query.entries()].reduce((props, [key, value]) => {
        props[key] = value;
        return props;
      }, {})
    );
  }, [query]);

  if (widgetProps.accountId && widgetProps.blockHeight) {
    return (
    <div className="d-inline-block position-relative overflow-hidden">
      <Widget src={props.widgets.blogPost} props={widgetProps} />{" "}
    </div>
    );
  }

  widgetProps.contributors = contributors;

  return (
    <div className="d-inline-block position-relative overflow-hidden">
      <Widget src={props.widgets.blog} props={widgetProps} />{" "}
    </div>
  );
}
```

2. Update your `App.js` router file, adding the new route to your custom path (e.g., `/bosblog`):

```js title="src/App.js"
import BlogPage from "./pages/BlogPage";
```

```js title="src/App.js"
            <Route path={"/signin"}>
              <NavigationWrapper {...passProps} />
              <SignInPage {...passProps} />
            </Route>
            <Route path={"/bosblog"}>
              <NavigationWrapper {...passProps} />
              <BlogPage {...passProps} />
            </Route>
```

</TabItem>

</Tabs>

3. Edit the `contributors` list, with the account(s) that you want to showcase on your blog feed:

   ```js
   const contributors = ['near', 'jacksonthedev.near'];
   ```

That's all, your gateway setup is done and you're ready to show your blog feed.
Check the next sections if you want to learn more about the blog post [content formatting](#blog-post-formatting) and how to promote social messages into blog posts.

:::tip

In this code example, only promoted blog posts from users `near` and `jacksonthedev.near` will appear in the Blog feed when someone browses the `/bosblog` URL.

:::

### Promoting posts

If you're using `near-discovery` you're all set, the <kbd>Promote</kbd> menu is already available using the [`v1.Posts.Feed`](https://near.org/near/widget/ComponentDetailsPage?src=near/widget/v1.Posts.Feed) component.

If you're using a different gateway or your own custom feed, and you want to allow users to promote social messages into blog posts, you can integrate this `promoteToBlog` code snippet:

```js
const { accountId, blockHeight, item } = props;

const promoteToBlog = () => {
  if (state.loading) {
    return;
  }

  if (!context.accountId && props.requestAuthentication) {
    props.requestAuthentication();
    return;
  } else if (!context.accountId) {
    return;
  }

  State.update({
    loading: true,
  });

  const data = {
    index: {
      promote: JSON.stringify({
        key: context.accountId,
        value: {
          operation: "add",
          type: "blog",
          post: item,
          blockHeight,
        },
      }),
    },
  };

  Social.set(data, {
    onCommit: () => State.update({ loading: false }),
    onCancel: () =>
      State.update({
        loading: false,
      }),
  });
};
```

:::tip

Check the [`Posts.Menu`](https://near.org/near/widget/ComponentDetailsPage?src=near/widget/Posts.Menu&tab=source) component for a complete implementation that includes a drop-down menu and a button to promote a blog post.

:::

---

## Blog post formatting

When writing blog posts, you can format the content using standard [Markdown syntax](https://www.markdownguide.org/basic-syntax/).
Markdown is an easy-to-read, easy-to-write language for formatting plain text.

The only two special cases that you should keep in mind when writing a blog post are:
- the blog post's title
- an optional header image

#### Header image

To define an image for your blog post, just add a markdown image link at the top of your post:

```md
![header-image](https://example.com/image.png)
```

#### Blog post title

To set the post's title, define it using a top heading tag:

```md
# This is the title of a demo blog post
```

:::tip

If you're new to Markdown, you might want to check this page about [basic writing and formatting syntax](https://www.markdownguide.org/basic-syntax/).

:::

---

## Writing a blog post

Adding a new blog post is simple. To publish a new blog post, you only need to:
1. Write a regular Near Social message
2. Promote the message and convert it to a Blog post

<img src="/docs/bosblog/blog-promote1.png" width="60%" />

#### Promote a message to blog post

Once the message has been posted, promoting it to a blog post is straight forward.
Just click on the 3 dots next to your post (`...`), and select the `Promote this Post to Blog` option:

![blog post](/docs/bosblog/blog-promote2.png)

:::note

You can find the published blog post example in [this link](https://near.org/near/widget/BlogPostPage?accountId=bucanero.near&blockHeight=117452680&returnLocation=/near/widget/ProfilePage?accountId=bucanero.near&tab=blog).

:::

That's it, your blog post has been promoted and published, and you can find it under the `Blog` tab in your [social profile](https://near.org/near/widget/ProfilePage?accountId=bucanero.near&tab=blog):

![blog post](/docs/bosblog/blog-promote3.png)

'''
'''--- docs/3.tutorials/near-components/bos-ethersjs-best-practices.md ---
---
id: ethers-js-best-practices
title: Best Practices for Ethereum developers on NEAR
---

import {WidgetEditor} from "@site/src/components/widget-editor"

In this example, we will create an Ethereum dApp on NEAR that functions as a portfolio manager, displaying the current balances for a list of tokens. Additionally, we will display current market value of each asset in the portfolio.

We will be using several technologies:
- NEAR Components for the user interface (UI).
- [Ethers.js](bos-ethersjs.md) for retrieving balance data from the blockchain.
- CoinGecko API for fetching static content with information about tokens and their current prices.
- [Social-DB](https://github.com/NearSocial/social-db) for storing the list of tokens to be tracked.
- GitHub Actions for caching static content, speeding up loading, and circumventing rate limits.

## Step 1: Load balances from chain

Let's start with a simple example and consider an application where we want to display a user's balances for multiple tokens.

### Source code

```js
// Load current sender address if it was not loaded yet
if (state.sender == undefined && Ethers.provider()) {
  Ethers.provider()
    .send("eth_requestAccounts", [])
    .then((accounts) => {
      if (accounts.length) {
        // save sender address to the state
        State.update({ sender: accounts[0] });
      }
    });
}

// Load ERC20 ABI JSON
const erc20Abi = fetch(
  "https://ipfs.near.social/ipfs/bafkreifgw34kutqcnusv4yyv7gjscshc5jhrzw7up7pdabsuoxfhlnckrq"
);
if (!erc20Abi.ok) {
  return "Loading";
}

// Create contract interface
const iface = new ethers.utils.Interface(erc20Abi.body);

// specify list of tokens
const tokens = [
  "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599", // WBTC
  "0x6b175474e89094c44da98b954eedeac495271d0f", // DAI
  "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984", // UNI
];

// load receiver's balance for a giver token
const getTokenBalance = (receiver, tokenId) => {
  // encode `balanceOf` request
  const encodedData = iface.encodeFunctionData("balanceOf", [receiver]);

  // send request to the network
  return Ethers.provider()
    .call({
      to: tokenId,
      data: encodedData,
    })
    .then((rawBalance) => {
      // decode response
      const receiverBalanceHex = iface.decodeFunctionResult(
        "balanceOf",
        rawBalance
      );

      return Big(receiverBalanceHex).toFixed(0);
    });
};

const loadTokensData = () => {
  // load balances of all tokens
  tokens.map((tokenId) => {
    getTokenBalance(state.sender, tokenId).then((value) => {
      // save balance of every token to the state
      State.update({ [tokenId]: { balance: value, ...state[tokenId] } });
    });
  });
};

const renderToken = (tokenId) => (
  <li>
    {tokenId}: {state[tokenId].balance}
  </li>
);

if (state.sender) {
  loadTokensData();

  return (
    <>
      <ul>{tokens.map((tokenId) => renderToken(tokenId))}</ul>
      <p>Your account: {state.sender} </p>
    </>
  );
} else {
  // output connect button for anon user
  return <Web3Connect />;
}
```

You can see how it works here: [step_1](https://near.org/near/widget/ComponentDetailsPage?src=zavodil.near/widget/token-balances-step-1&tab=source).

Once the web3 connection is enabled, the output will appear as follows:

```
0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599: 726220
0x6b175474e89094c44da98b954eedeac495271d0f: 140325040242585301886
0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984: 127732731780832810
```

:::tip
When developing NEAR components, it's recommended to always present some content even if the user hasn't connected their wallet yet. In this example, the component uses the `<Web3Connect>` button to prompt the user to connect their wallet if they haven't already.
:::

## Step 2: Load static data

To format the list, we must determine the decimal precision for each asset. While it's possible to retrieve this information from the ERC-20 contract for each token, it's important to note that the ERC-20 contract lacks certain valuable data such as the token icon and description. As a solution, we can leverage the CoinGecko API to retrieve token details, including the current market price.

Let's add a function to load token data for a given token from the Coingecko:

```js
const loadCoingeckData = (tokenId) => {
    let dataUrl = `https://api.coingecko.com/api/v3/coins/ethereum/contract/${tokenId}`;

    const data = fetch(dataUrl);
    if (data.ok) {
        return {
            name: data.body.name,
            icon: data.body.image.small,
            decimals: data.body.detail_platforms["ethereum"].decimal_place,
            price: Number(data.body.market_data.current_price.usd),
        };
    }
};
```

Other available API methods are listed in the [Coingecko API documentation](https://www.coingecko.com/en/api).

Now that we have the data, let's modify the loadTokensData function to save the token information in the state:

```js
const loadTokensData = () => {
  // load balances of all tokens
  tokens.map((tokenId) => {
    getTokenBalance(state.sender, tokenId).then((value) => {
      // save balance of every token to the state
      State.update({ [tokenId]: { balance: value, ...state[tokenId] } });
    });
  });

  tokens.map((tokenId) => {
    const tokenData = loadCoingeckData(tokenId);
    // save balance of every token to the state
    State.update({ [tokenId]: { ...tokenData, ...state[tokenId] } });
  });
};
```

And lets update the `renderToken` function to display data we just got:

```js 
const renderToken = (tokenId) => {
  const tokenBalance = Big(state[tokenId].balance ?? 0)
    .div(new Big(10).pow(state[tokenId].decimals ?? 1))
    .toFixed(4);
  const tokenBalanceUSD = (tokenBalance * state[tokenId].price).toFixed(2);
  return (
    <li>
      {state[tokenId].name}: {tokenBalance}{" "}
      <img src={state[tokenId].icon} width="16" alt={state[tokenId].symbol} />
      {`(${tokenBalanceUSD} USD)`}
    </li>
  );
};
```

You can see how it works here: [step_2](https://near.org/near/widget/ComponentDetailsPage?src=zavodil.near/widget/token-balances-step-2&tab=source).

Output will be like this:
```
Wrapped Bitcoin: 0.0073 wbtc (247.64 USD)
Dai: 140.3250 dai (140.21 USD)
Uniswap: 0.1277 uni (0.54 USD)
```

:::info
Please note that the `fetch` function caches data and will be executed only once during loading.
:::

:::tip
Utilize any available web-services to provide data for your application on NEAR, ensuring that the user experience is on par with traditional web 2.0 applications.
:::

## Step 3. Save data in social-db

Now, instead of hardcoding the list of tokens directly within the application code, let's transition them to an onchain data repository named social-db. This approach allows us to adjust the list of trackable tokens without having to modify the application's code. It also offers users the flexibility to select from pre-existing token lists or formulate their own.

Learn more about how [key-value storage social-db works](https://github.com/NearSocial/social-db/blob/master/README.md).

Here is an example of a simple application for [setting tokens list in social-db](https://near.org/near/widget/ComponentDetailsPage?src=zavodil.near/widget/tokens-db&tab=source). 

In this format, the data from the example will be stored in social-db.

```
{
"0x6b175474e89094c44da98b954eedeac495271d0f": "",
"0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599": "",
"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984": ""
}
```

Viewing this data from the blockchain is accessible for every NEAR app or, for example, through an [Explorer app](https://near.org/zavodil.near/widget/Explorer?path=zavodil.near/tokens-db/**).

Let's add a function to our application that will read the list of tokens.

```js
// set list of tokens
if (!state.tokensLoaded) {
    // load tokens list from the Social DB
    const tokens = Social.get(`zavodil.near/tokens-db/*`, "final");

    if (tokens) {
        State.update({
            tokensLoaded: true,
            tokens,
        });
    }
}

const tokens = Object.keys(state.tokens ?? {});
```
:::info
In this case, `zavodil.near` is the NEAR account of the user who created this list of tokens. Any other user can create their own list, and it will also be available in `social-db`.
:::

You can see how it works here: [step_3](https://near.org/near/widget/ComponentDetailsPage?src=zavodil.near/widget/token-balances-step-3&tab=source). The output of the data in the application remains unchanged, but now it no longer contains hardcoded values.

:::tip
Use social-db, an on-chain data storage, to decouple the data and the application. 
:::

## Step 4. Caching Data Through GitHub Actions

Ethereum-based applications frequently depend on static content sources to present details about tokens or contracts. Often, frontends pull this data from platforms like CoinGecko or CoinMarketCap, leveraging API keys to enhance the data retrieval rate limit. Without these API keys, and given a significant volume of data, fetching from these platforms can be sluggish or even disrupted. We'll showcase a serverless approach utilizing GitHub Actions. This method preserves the decentralized nature of NEAR gateways (where securely storing API keys isn't feasible), all while ensuring user ease-of-use and swift data loading.

Let's create a Node.js application that will iterate through a list of tokens from `social-db` and display the retrieved data along with a timestamp of the operation.

```js
import * as nearAPI from "near-api-js";
import * as cg from "coingecko-api-v3";

const CONTRACT_ID = "social.near";
const ETHEREUM_NETWORK_ID = "ethereum";
const FETCH_TIMEOUT = 7000;

async function connect() {
    const config = {
        networkId: "mainnet",
        keyStore: new nearAPI.keyStores.InMemoryKeyStore(),
        nodeUrl: "https://rpc.mainnet.near.org",
        walletUrl: "https://wallet.mainnet.near.org",
        helperUrl: "https://helper.mainnet.near.org",
        explorerUrl: "https://nearblocks.io",
    };
    const near = await nearAPI.connect(config);
    const account = await near.account(CONTRACT_ID);

    const contract = new nearAPI.Contract(
        account, // the account object that is connecting
        CONTRACT_ID, // name of contract you're connecting to
        {
            viewMethods: ["get"], // view methods do not change state but usually return a value
            changeMethods: [], // change methods modify state
            sender: account, // account object to initialize and sign transactions.
        }
    );

    return contract;
}

// load data from the social-db
const contract = await connect();
const data = await contract.get({ keys: ["zavodil.near/tokens-db/*"] });
const tokens = data["zavodil.near"]["tokens-db"];

// init coingecko client
const client = new cg.CoinGeckoClient({
    timeout: 5000,
    autoRetry: false,
});

let res = {};
for (let i = 0; i < Object.keys(tokens).length; i++) {
    const tokenId = Object.keys(tokens)[i];

    try {
        // load data from coingecko
        const data = await client.contract({
            id: ETHEREUM_NETWORK_ID,
            contract_address: tokenId,
        });
        // format output
        const tokenData = {
            name: data["name"],
            symbol: data["symbol"],
            icon: data["image"]?.["thumb"],
            decimals: data["detail_platforms"]?.[ETHEREUM_NETWORK_ID]?.["decimal_place"],
            price: data["market_data"]?.["current_price"]?.["usd"],
        };
        // store output
        res[tokenId] = tokenData;

        // add timeout to avoid rate limits
        await new Promise((resolve) => {
            setTimeout(resolve, FETCH_TIMEOUT);
        });
    } catch (ex) {
        console.error(tokenId, ex)
    }
}

// output results
console.log(
    JSON.stringify({
        timestamp: Date.now(),
        data: res,
    })
);

```

Example [of this code on a github](https://github.com/zavodil/tokens-db/),  you can clone the repository and modify the data retrieval request as needed.

Now, we can create a GitHub worker that will execute this script and save the data to a file named `tokens-db.json`. Here are the instructions for the worker:

```yml
name: Tokens Data Updater
on:
  workflow_dispatch:
  schedule:
    - cron:  '*/15 * * * *'

jobs:
  updateStats:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Prepare        
        uses: actions/setup-node@v3
        with:
            node-version: 16
      - run: npm i      
      - name: Tokens Data
        run: node load > tokens-db.json              
        env:
          EXPORT_MODE: CS
      - uses: EndBug/add-and-commit@v9 
        with: 
          author_name: "Tokens Data Updater"
          add: 'tokens-db.json --force'
          message: "Tokens Data fetching"
```

Don't forget to grant the worker the necessary permissions to add files to your repository (Open GitHub Repository: Settings->Actions->General)

The output of this worker will be the [tokens-db.json](https://raw.githubusercontent.com/zavodil/tokens-db/main/tokens-db.json) file which will be regularly updated with current data. You can easily add any private API keys required for bypassing rate limits in the worker.

Now, let's get back to the NEAR application. We need to modify the code to read data from the cached file created by GitHub Actions instead of fetching it from CoinGecko every time.

To do this, we'll make changes to the `loadTokensData` function:

```js
const loadTokensData = () => {
    let cacheTokenData = {};
    // load data generated by github action
    const cachedData = fetch(
        `https://raw.githubusercontent.com/zavodil/tokens-db/main/tokens-db.json`
    );
    if (cachedData.ok) {
        const cache = JSON.parse(cachedData.body);
        const cacheDate = new Date(cache.timestamp);
        const timeDifference = Date.now() - cacheDate.getTime();
        if (timeDifference <= 30 * 60 * 1000) {  // use cached data if it is not outdated (30 min)
            cacheTokenData = cache.data;
        }

        tokens.map((tokenId) => {
            const tokenData = cacheTokenData.hasOwnProperty(tokenId)
                ? cacheTokenData?.[tokenId]
                : // load data from coingecko if we don't have cached data only
                loadCoingeckData(tokenId);
            // save balance of every token to the state
            State.update({ [tokenId]: { ...tokenData, ...state[tokenId] } });
        });
    }
};

```

You can see how it works here: [step_4](https://near.org/near/widget/ComponentDetailsPage?src=zavodil.near/widget/token-balances-step-4&tab=source). The output of the data in the application remains the same, but now it operates more efficiently.

:::tip
Use GitHub Actions as a serverless backend for securing API keys, caching data etc. 
:::

'''
'''--- docs/3.tutorials/near-components/bos-ethersjs.md ---
---
id: ethers-js
title: NEAR for Ethereum developers
---

import {WidgetEditor} from "@site/src/components/widget-editor"

NEAR components are chain-agnostic, enabling you to create decentralized frontends tailored for any Ethereum dApps. Throughout this article, we'll navigate prevalent use-cases with code snippets. You‚Äôll also find links to exemplary NEAR components for reference.

---

## Interact with Ethereum using Ethers.js

The NEAR VM has imported the [Ethers.js](https://docs.ethers.org/) library, allowing for seamless interaction with Ethereum nodes using JavaScript in a NEAR component.

The `Ethers` object exposes the provider connection:
- `Ethers.provider()` is a read-only connection to the blockchain, which allows querying the blockchain state (e.g., account, block or transaction details), querying event logs or evaluating read-only code using call.
  - `Ethers.provider().getSigner()` abstracts the class that interacts with an account
    - `Ethers.provider().getSigner().getBalance()` returns a Promise that resolves to the account address.
  - `Ethers.provider().getBlockNumber()` looks up the current block number (i.e. height)
  - `Ethers.provider().getFeeData()` gets the best guess at the recommended FeeData

You can see various ways of using `Ethers` objects on the [Ethers documentation portal](https://docs.ethers.org/)).

---
    
Furthermore, numerous [basic tools](https://docs.ethers.org/v6/api/utils/)  can be found in the ethers.utils object (be aware of the lowercase 'e').
- `ethers.utils.parseUnits(value, unit)` converts the decimal string value to a BigInt, assuming unit decimal places. The unit may the number of decimal places or the name of a unit (e.g. "gwei" for 9 decimal places).
- `ethers.utils.formatEther(wei)` converts value into a decimal string using 18 decimal places.

#### Example showing the difference between `Ethers.provider()` and `ethers.utils`:
```ts
    Ethers.provider()
        .getSigner()
        .getBalance()
        .then((balance) => {
            console.log("Your ETH balance: ", ethers.utils.formatEther(balance))
        });
```

## FAQ

### How to get a user account?

```ts
const receiver = Ethers.provider().send("eth_requestAccounts", [])[0];
```

### How to get the current chain ID?

```ts
Ethers.provider().getNetwork().then((chainIdData) => {
    console.log(chainIdData.chainId);
});
```

### How to show a Web3Login button?

```ts
<Web3ConnectButton 
    className="my-class" 
    connectLabel="Connect Web3 Wallet" 
    disconnectLabel="Disconnect Web3 Wallet"
    connectingLabel="Connecting..." 
/>
```

### How to load a contract ABI?

```ts
const abi = fetch(`https://eth.blockscout.com/api?module=contract&action=getabi&address=0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2`);

if (!abi.ok) {
    return "Loading";
}

console.log(abi.body.result);
```

### How to load data from EVM nodes?

```ts
// create a contract interface
const iface = new ethers.utils.Interface(abi.body.result);

// encode the balanceOf get request
const encodedBalanceData = iface.encodeFunctionData("balanceOf", [receiver]);

// perform a call
Ethers.provider().call({
    to: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    data: encodedBalanceData,
})
.then((rawBalance) => {
    // decode the result
    const receiverBalanceHex = iface.decodeFunctionResult(
        "balanceOf",
        rawBalance
    );
    console.log(Big(receiverBalanceHex).toFixed());
});
```

### How to send a transaction to Ethereum nodes?

```ts
// create a contract instance
const wEthContract = new ethers.Contract(
    "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    abi.body.result,
    Ethers.provider().getSigner()
);

// perform a given method (withdraw in this case)
wEthContract
    .withdraw(balance, {
        value: 0
    })
    .then((transactionHash) => {
        console.log(transactionHash);
    });
```

### How to convert HEX values to human readable numbers?

```ts
// use Big().toFixed method

Big(balanceHex).toFixed()
```

### How to locate the ABI of a Smart Contract?

Utilize platforms like etherscan.com and blockscout.com, or delve into the project's GitHub repositories and documentation.

### Is there an example of applications with a description of how they were created? 

Yes, there is an article that describes [best practices for creating applications for Ethereum developers on NEAR](bos-ethersjs-best-practices.md), with a breakdown of individual steps.

## Examples

Below is a curated list of NEAR components, developed by the community, that epitomize the best practices for creating NEAR components:

- [Unwrap ETH](https://near.org/near/widget/ComponentDetailsPage?src=zavodil.near/widget/unwrap-weth&tab=source)
- [ERC-20 Token sender](https://near.org/near/widget/ComponentDetailsPage?src=zavodil.near/widget/erc20-sender&tab=source)
- [Lido Component](https://near.org/near/widget/ComponentDetailsPage?src=zavodil.near/widget/Lido&tab=source)
- [Swap component](https://near.org/near/widget/ComponentDetailsPage?src=zavodil.near/widget/swap&tab=source) (a set of swap dApps for Ethereum Mainnet, Polygon Mainnet, Polygon zkevm, Aurora, NEAR, etc)
- [1inch](https://near.org#/near/widget/ComponentDetailsPage?src=chanon.near/widget/1inch)
- [Liquity](https://near.org/near/widget/ComponentDetailsPage?src=garlicfaucet.near/widget/liquityWidget)

'''
'''--- docs/3.tutorials/near-components/bos-loader.md ---
---
id: bos-loader
title: BOS Loader
---

# BOS Loader

In this article you'll learn how to develop, test, and deploy BOS components using CLI tools. You can use this workflow to tap into the colaboration, pull-request, and other GitHub benefits while still deploying components to the BOS. 

[BOS Component Loader](https://github.com/near/bos-loader) serves a local directory of component files as a JSON payload properly formatted to be plugged into a BOS `redirectMap`. When paired with a viewer configured to call out to this loader, it enables local component development.

## Development flow

1. _(Optional)_ Download and install [`bos` CLI](https://bos.cli.rs).

   :::info
   You need `bos` CLI if you have component code on the BOS already that you want to use or if you want to manage component deploys locally instead of the GitHub actions CI/CD.
   :::

2. To get component code saved on the BOS, use `bos` to download the source code. Otherwise, create a `src` folder.

3. Create a component within that src folder like `src/<component name>.jsx`.

   :::tip
   It's common practice to use `.` delimited component names for namespacing. You can handle this with folders for better files organization.
   
   For example, `AppName.Component` ‚Üí `AppName/Component.jsx`.
   :::

5. Download and install [BOS Component Loader](https://github.com/near/bos-loader/releases) (`bos-loader`).

6. Run `bos-loader <youraccount.near> --path src` (or run from `src` folder)

7. Open https://near.org/flags, and set the loader URL to `http://127.0.0.1:3030`.

8. Open `https://near.org/<youraccount.near>/widget/<component name>` (case sensitive)

   :::info
   If you're testing on `testnet`, use your testnet account and open https://test.near.org instead.
   
   Run `bos-loader <youraccount.testnet> --path src` locally, set loader URL in https://test.near.org/flags and open `https://test.near.org/<youraccount.testnet>/widget/<component name>` to view your component locally.
   :::

   :::tip
   You can work on multiple components at once by embedding them in a wrapper component.
   :::

9. Make changes to the component's code.

   :::info
   You must refresh the browser's web page to see the changes.
   :::

10. When you're done, use the <kbd>X</kbd> on the banner to stop loading locally.

## Component deployment

At this point, your new component is ready to be deployed. To deploy, you can use either of the following two paths: 

 - Use `bos` CLI to deploy from command line:

   ```
   bos deploy
   ```

 - Set up a [GitHub actions](https://github.com/FroVolod/bos-cli-rs/blob/master/README.md#reusable-workflow) deployment workflow. Check [this document](https://github.com/FroVolod/bos-cli-rs/blob/master/README.md#github-actions) for instructions.

You should now be able to see your component in discovery. Happy Hacking! 

'''
'''--- docs/3.tutorials/near-components/design-system.md ---
---
id: ds-components
title: Design Components
---

# Design System Components

When building components, the NEAR VM provides a complete set of [Radix primitives](https://www.radix-ui.com/docs/primitives/overview/introduction) to simplify UI development.

## Radix UI

Using embedded Radix primitives on the NEAR VM is simple and straight-forward. You don't need to import any files:

```js
return (
    <Label.Root className="LabelRoot">
      Hello World!
    </Label.Root>
);
```

:::caution Limitations

Currently, NEAR VM impose some limitations on the Radix UI framework:

- `Form` component is not available.
- You can't use `.Portal` definitions.
- Using CSS is different. You'll have to use a `styled.div` wrapper.

:::

### Using CSS

Here is an example on how to use CSS through the `styled.div` wrapper:

```js
const Wrapper = styled.div`
  .SwitchRoot {
    ...
  }
  .SwitchThumb {
    ...
  }
`;

return (
  <Wrapper>
    <Switch.Root className="SwitchRoot">
      <Switch.Thumb className="SwitchThumb" />
    </Switch.Root>
  </Wrapper>
);
```

:::tip Using Wrapper

[Example widget using Wrapper](https://near.org/#/near/widget/ComponentDetailsPage?src=near/widget/RadixTooltipTest)

:::

### Using `styled-components`

You can use [`styled-components`](../../2.build/3.near-components/anatomy/builtin-components.md) in combination with Radix UI primitives. Here's an example:

```js
const SwitchRoot = styled("Switch.Root")`
  all: unset;
  display: block;
  width: 42px;
  height: 25px;
  background-color: var(--blackA9);
  border-radius: 9999px;
  position: relative;
  box-shadow: 0 2px 10px var(--blackA7);

  &[data-state="checked"] {
    background-color: black;
  }
`;

const SwitchThumb = styled("Switch.Thumb")`
  all: unset;
  display: block;
  width: 21px;
  height: 21px;
  background-color: white;
  border-radius: 9999px;
  box-shadow: 0 2px 2px var(--blackA7);
  transition: transform 100ms;
  transform: translateX(2px);
  will-change: transform;

  &[data-state="checked"] {
    transform: translateX(19px);
  }
`;

return (
  <SwitchRoot>
    <SwitchThumb />
  </SwitchRoot>
);
```

:::tip Using styled components

[Example widget using styled components to style Radix UI](https://near.org/#/near/widget/ComponentDetailsPage?src=near/widget/RadixSwitchTest).

:::

### Forward references

The NEAR VM re-implements [React's forwardRef](https://react.dev/reference/react/forwardRef#reference) as `ref="forwardedRef"`.

You can use `ref="forwardedRef"` to forward references through `<Widget />` to support Radix's `asChild` property:

```js title='Dialog.jsx'
<AlertDialog.Trigger asChild>
  <Widget
    src="near/widget/TestButton"
    props={{ label: "Click Me" }}
  />
</AlertDialog.Trigger>
```

```js title='TestButton.jsx'
const Button = styled.button`
  background: #f00;
`;

return (
  <Button type="button" ref="forwardedRef">
    {props.label}: Forwarded
  </Button>
);
```

## DIG components

These are the Design Interface Guidelines (DIG) components available on the NEAR VM:

- [DIG.Button](https://near.org/#/near/widget/ComponentDetailsPage?src=near/widget/DIG.Button)
- [DIG.Theme](https://near.org/#/near/widget/ComponentDetailsPage?src=near/widget/DIG.Theme)

### `DIG.Button`

A fully featured button component that can act as a `<button>` or `<a>` tag.

:::info DIG.Button properties
[Click here](https://near.org/#/near/widget/ComponentDetailsPage?src=near/widget/DIG.Button&tab=about) for properties and details.

:::

### `DIG.Theme`

This component wraps all of NEAR Components so you don't need to render it yourself.

:::tip
You can use any of the [CSS variables](https://near.org/near/widget/ComponentDetailsPage?src=near/widget/DIG.Theme&tab=source) defined inside `DIG.Theme`.
:::

'''
'''--- docs/3.tutorials/near-components/hello-lido.md ---
---
id: lido
title: Lido Example
---

# Hello Lido!

If you are ready to explore further, the [Lido component](https://near.org/zavodil.near/widget/Lido) serves as an excellent fully-fledged example, as it demonstrates how to interact with a smart contract deployed on the Ethereum mainnet.

:::info Ethers.js

This component uses the [Ethers JavaScript](https://ethers.org) library to interact with Ethereum smart contracts. Follow [this link](https://docs.ethers.org/v6/) for the official `ethers.js` documentation.

:::

:::info Web3 connect

The Lido example uses the [Web3Connect component](https://near.org/near/widget/ComponentDetailsPage?src=a_liutiev.near/widget/button_web3connect) to provide a [WalletConnect modal](https://github.com/WalletConnect/web3modal) so the user can connect with any Web3 Ethereum wallet like Ledger or MetaMask.

:::

### Fork the component

1. Navigate to [the component](https://near.org/near/widget/ComponentDetailsPage?src=zavodil.near/widget/Lido)
2. Select `Fork`
3. Feel free to make any changes
4. Click on <kbd>Save</kbd> to deploy the component

:::note
To deploy the component, you'll need to sign in with a NEAR account and to make a deposit of a small amount of NEAR for the storage cost. This is because the components are stored in the NEAR network.
:::

### Source code

```js
if (
  state.chainId === undefined &&
  ethers !== undefined &&
  Ethers.send("eth_requestAccounts", [])[0]
) {
  Ethers.provider()
    .getNetwork()
    .then((chainIdData) => {
      if (chainIdData?.chainId) {
        State.update({ chainId: chainIdData.chainId });
      }
    });
}
if (state.chainId !== undefined && state.chainId !== 1) {
  return <p>Switch to Ethereum Mainnet</p>;
}

// FETCH LIDO ABI

const lidoContract = "0xae7ab96520de3a18e5e111b5eaab095312d7fe84";
const tokenDecimals = 18;

const lidoAbi = fetch(
  "https://raw.githubusercontent.com/lidofinance/lido-subgraph/master/abis/Lido.json"
);
if (!lidoAbi.ok) {
  return "Loading";
}

const iface = new ethers.utils.Interface(lidoAbi.body);

// FETCH LIDO STAKING APR

if (state.lidoArp === undefined) {
  const apr = fetch(
    "https://api.allorigins.win/get?url=https://stake.lido.fi/api/sma-steth-apr"
  );
  if (!apr) return;
  State.update({ lidoArp: JSON.parse(apr?.body?.contents) ?? "..." });
}

// HELPER FUNCTIONS

const getStakedBalance = (receiver) => {
  const encodedData = iface.encodeFunctionData("balanceOf", [receiver]);

  return Ethers.provider()
    .call({
      to: lidoContract,
      data: encodedData,
    })
    .then((rawBalance) => {
      const receiverBalanceHex = iface.decodeFunctionResult(
        "balanceOf",
        rawBalance
      );

      return Big(receiverBalanceHex.toString())
        .div(Big(10).pow(tokenDecimals))
        .toFixed(2)
        .replace(/\d(?=(\d{3})+\.)/g, "$&,");
    });
};

const submitEthers = (strEther, _referral) => {
  if (!strEther) {
    return console.log("Amount is missing");
  }
  const erc20 = new ethers.Contract(
    lidoContract,
    lidoAbi.body,
    Ethers.provider().getSigner()
  );

  let amount = ethers.utils.parseUnits(strEther, tokenDecimals).toHexString();

  erc20.submit(lidoContract, { value: amount }).then((transactionHash) => {
    console.log("transactionHash is " + transactionHash);
  });
};

// DETECT SENDER

if (state.sender === undefined) {
  const accounts = Ethers.send("eth_requestAccounts", []);
  if (accounts.length) {
    State.update({ sender: accounts[0] });
    console.log("set sender", accounts[0]);
  }
}

//if (!state.sender)  return "Please login first";

// FETCH SENDER BALANCE

if (state.balance === undefined && state.sender) {
  Ethers.provider()
    .getBalance(state.sender)
    .then((balance) => {
      State.update({ balance: Big(balance).div(Big(10).pow(18)).toFixed(2) });
    });
}

// FETCH SENDER STETH BALANCE

if (state.stakedBalance === undefined && state.sender) {
  getStakedBalance(state.sender).then((stakedBalance) => {
    State.update({ stakedBalance });
  });
}

// FETCH TX COST

if (state.txCost === undefined) {
  const gasEstimate = ethers.BigNumber.from(1875000);
  const gasPrice = ethers.BigNumber.from(1500000000);

  const gasCostInWei = gasEstimate.mul(gasPrice);
  const gasCostInEth = ethers.utils.formatEther(gasCostInWei);

  let responseGql = fetch(
    "https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2",
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: `{
          bundle(id: "1" ) {
            ethPrice
          }
        }`,
      }),
    }
  );

  if (!responseGql) return "";

  const ethPriceInUsd = responseGql.body.data.bundle.ethPrice;

  const txCost = Number(gasCostInEth) * Number(ethPriceInUsd);

  State.update({ txCost: `$${txCost.toFixed(2)}` });
}

// FETCH CSS

const cssFont = fetch(
  "https://fonts.googleapis.com/css2?family=Manrope:wght@200;300;400;500;600;700;800"
).body;
const css = fetch(
  "https://pluminite.mypinata.cloud/ipfs/Qmboz8aoSvVXLeP5pZbRtNKtDD3kX5D9DEnfMn2ZGSJWtP"
).body;

if (!cssFont || !css) return "";

if (!state.theme) {
  State.update({
    theme: styled.div`
    font-family: Manrope, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
    ${cssFont}
    ${css}
`,
  });
}
const Theme = state.theme;

// OUTPUT UI

const getSender = () => {
  return !state.sender
    ? ""
    : state.sender.substring(0, 6) +
        "..." +
        state.sender.substring(state.sender.length - 4, state.sender.length);
};

return (
  <Theme>
    <div className="LidoContainer">
      <div className="Header">Stake Ether</div>
      <div className="SubHeader">Stake ETH and receive stETH while staking.</div>

      <div className="LidoForm">
        {state.sender && (
          <>
            <div className="LidoFormTopContainer">
              <div className="LidoFormTopContainerLeft">
                <div className="LidoFormTopContainerLeftContent1">
                  <div className="LidoFormTopContainerLeftContent1Container">
                    <span>Available to stake</span>
                    <div className="LidoFormTopContainerLeftContent1Circle" />
                  </div>
                </div>
                <div className="LidoFormTopContainerLeftContent2">
                  <span>
                    {state.balance ?? (!state.sender ? "0" : "...")}&nbsp;ETH
                  </span>
                </div>
              </div>
              <div className="LidoFormTopContainerRight">
                <div className="LidoFormTopContainerRightContent1">
                  <div className="LidoFormTopContainerRightContent1Text">
                    <span>{getSender()}</span>
                  </div>
                </div>
              </div>
            </div>
            <div className="LidoSplitter" />
          </>
        )}
        <div
          className={
            state.sender ? "LidoFormBottomContainer" : "LidoFormTopContainer"
          }
        >
          <div className="LidoFormTopContainerLeft">
            <div className="LidoFormTopContainerLeftContent1">
              <div className="LidoFormTopContainerLeftContent1Container">
                <span>Staked amount</span>
              </div>
            </div>
            <div className="LidoFormTopContainerLeftContent2">
              <span>
                {state.stakedBalance ?? (!state.sender ? "0" : "...")}
                &nbsp;stETH
              </span>
            </div>
          </div>
          <div className="LidoFormTopContainerRight">
            <div className="LidoAprContainer">
              <div className="LidoAprTitle">Lido APR</div>
              <div className="LidoAprValue">{state.lidoArp ?? "..."}%</div>
            </div>
          </div>
        </div>
      </div>
      <div className="LidoStakeForm">
        <div className="LidoStakeFormInputContainer">
          <span className="LidoStakeFormInputContainerSpan1">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
              <path
                opacity="0.6"
                d="M11.999 3.75v6.098l5.248 2.303-5.248-8.401z"
              ></path>
              <path d="M11.999 3.75L6.75 12.151l5.249-2.303V3.75z"></path>
              <path
                opacity="0.6"
                d="M11.999 16.103v4.143l5.251-7.135L12 16.103z"
              ></path>
              <path d="M11.999 20.246v-4.144L6.75 13.111l5.249 7.135z"></path>
              <path
                opacity="0.2"
                d="M11.999 15.144l5.248-2.993-5.248-2.301v5.294z"
              ></path>
              <path
                opacity="0.6"
                d="M6.75 12.151l5.249 2.993V9.85l-5.249 2.3z"
              ></path>
            </svg>
          </span>
          <span className="LidoStakeFormInputContainerSpan2">
            <input
              disabled={!state.sender}
              className="LidoStakeFormInputContainerSpan2Input"
              value={state.strEther}
              onChange={(e) => State.update({ strEther: e.target.value })}
              placeholder="Amount"
            />
          </span>
          <span
            className="LidoStakeFormInputContainerSpan3"
            onClick={() => {
              State.update({
                strEther: (state.balance > 0.05
                  ? parseFloat(state.balance) - 0.05
                  : 0
                ).toFixed(2),
              });
            }}
          >
            <button
              className="LidoStakeFormInputContainerSpan3Content"
              disabled={!state.sender}
            >
              <span className="LidoStakeFormInputContainerSpan3Max">MAX</span>
            </button>
          </span>
        </div>
        {!!state.sender ? (
          <button
            className="LidoStakeFormSubmitContainer"
            onClick={() => submitEthers(state.strEther, state.sender)}
          >
            <span>Submit</span>
          </button>
        ) : (
          <Web3Connect
            className="LidoStakeFormSubmitContainer"
            connectLabel="Connect with Web3"
          />
        )}

        <div className="LidoFooterContainer">
          {state.sender && (
            <div className="LidoFooterRaw">
              <div className="LidoFooterRawLeft">You will receive</div>
              <div className="LidoFooterRawRight">${state.strEther ?? 0} stETH</div>
            </div>
          )}
          <div className="LidoFooterRaw">
            <div className="LidoFooterRawLeft">Exchange rate</div>
            <div className="LidoFooterRawRight">1 ETH = 1 stETH</div>
          </div>
          {false && (
            <div className="LidoFooterRaw">
              <div className="LidoFooterRawLeft">Transaction cost</div>
              <div className="LidoFooterRawRight">{state.txCost}</div>
            </div>
          )}
          <div className="LidoFooterRaw">
            <div className="LidoFooterRawLeft">Reward fee</div>
            <div className="LidoFooterRawRight">10%</div>
          </div>
        </div>
      </div>
    </div>
  </Theme>
);
```

#### Fork the component

1. Navigate to [the component](https://near.org/near/widget/ComponentDetailsPage?src=zavodil.near/widget/Lido)
2. Select `Fork`
3. Feel free to make any changes
4. Click on <kbd>Save</kbd> to deploy the component

:::note
To deploy the component, you'll need to sign in with a NEAR account and to make a deposit of a small amount of NEAR for the storage cost. This is because NEAR components are stored in the NEAR network.
:::

'''
'''--- docs/3.tutorials/near-components/hello-near.md ---
---
id: interaction
title: Smart Contract Interaction
---

Your frontend can interact with different blockchains using the built-in BOS API. Let's see how to create an application that reads and stores a greeting from a NEAR smart contract. 

![widgets](/docs/hello-near-logedin.png)
*View of our Hello Near app when the user is logged-in*

:::info
Check the finished example at [near.social code page](https://near.social/#/mob.near/widget/WidgetSource?src=gagdiez.near/widget/HelloNear).
:::

---

## The Contract

We have deployed a `Hello World` smart contract in the NEAR network at `hello.near-examples.near`. The contract exposes two methods:
- `set_greeting(greeting: string): void`, which accepts a greeting and stores it in the contract state.
- `get_greeting(): string` which returns the stored greeting.

---

## Retrieving the Greeting
Since we want to interact with the NEAR network, we will use the `Near` object from the BOS API.

```ts
const contract = "hello.near-examples.near";
const greeting = Near.view(contract, "get_greeting", {});

return <div>{greeting} World</div>;
```

Assuming the contract is storing `"Hello"`, this will render a simple:

```json
Hello World
```

---

## Changing the Greeting
To modify the greeting, we simply need to use `Near.call` to call the `set_greeting` method. This however, requires us to have a frontend in which the user can input the new greeting.

Lets create it in two steps:
1. Build the HTML that will be rendered
2. Add the logic to handle the function call

<hr className="subsection" />

### 1. HTML Components
Use the following code to create a simple frontend, composed by a title, an input form to change the greeting, and a button to submit the change.

```js
const contract = "hello.near-examples.near";
const greeting = Near.view(contract, "get_greeting", {});

// Define components
const greetingForm = (
  <>
    <div className="border border-black p-3">
      <label>Update greeting</label>
      <input placeholder="Howdy" onChange={onInputChange} />
      <button className="btn btn-primary mt-2" onClick={onBtnClick}>
        Save
      </button>
    </div>
  </>
);

const notLoggedInWarning = <p> Login to change the greeting </p>;

// Render
return (
  <>
    <div className="container border border-info p-3">
      <h3 className="text-center">
        The contract says:
        <span className="text-decoration-underline"> {greeting} </span>
      </h3>

      <p className="text-center py-2">
        Look at that! A greeting stored on the NEAR blockchain.
      </p>

      {context.accountId ? greetingForm : notLoggedInWarning}
    </div>
  </>
);
```

:::info Relevant HTML
There are two important things to notice in the code above:

1. **onChange & onClick**: We have prepared our `<input>` and `<button>` to act when something happens. Particularly, we will build two methods: one when the input changes, and one when the button is pressed.

2. **context.accountId**: We check if `context.accountId` is set, which tells us if the user has logged in using their NEAR account, and thus can interact with NEAR contracts.
:::

<hr className="subsection" />

### 2. Handling User's Input
Having our component's view ready, we now need to define the logic for when the user inputs a new greeting and presses the `Submit` button. This is, we need to define the `onInputChange` and `onBtnClick` methods.

#### onInputChange
When the user inputs a new greeting, we want to store it somewhere until the `Submit` button is pressed, for this, we can use the [application's State](../../2.build/3.near-components/anatomy/state.md).

In BOS, the state is initialized through `State.init`, updated with `State.update`, and accessed through the `state` variable (notice the lowercase). Lets store the new greeting in the App's state:

```js
State.init({ new_greeting: "" });

const onInputChange = ({ target }) => {
  State.update({ new_greeting: target.value });
};
```

#### onBtnClick
The only thing left to do, is to handle when the user clicks the `Submit` button. What we want is to check if the user changed the greeting, and submit it to the contract.

```js
const onBtnClick = () => {
  if (!state.new_greeting) {
    return;
  }

  Near.call(contract, "set_greeting", {
    greeting: state.new_greeting,
  });
};
```

---

## Complete Example
We have deployed a complete version of this example on the NEAR blockchain, so you can see its code and play with it.

:::tip
- **Code**: Check the code of this example at the [near.social code page](https://near.social/#/mob.near/widget/WidgetSource?src=gagdiez.near/widget/HelloNear).

- **Try It**: Interact with the application at the [near.social page](https://near.social/#/gagdiez.near/widget/HelloNear).
:::

'''
'''--- docs/3.tutorials/near-components/iframes.md ---
---
id: using-iframes
title: Using IFrames
---

# Iframes

In this tutorial you'll learn [how to use](#using-iframes-on-bos-vm) the `iframe` VM tag and the [Iframe resizer](#iframe-resizer) library, so you can embed external HTML or use custom DOM elements when building NEAR components.
You can use it along the rest of approved VM tags to simplify your component development.

## Using IFrames on NEAR VM

Iframes can be used to embed external HTML or to use custom DOM
elements, for example `canvas`.

### Properties

The `iframe` tag takes the following properties: `className`, `style`, `src`,
`srcDoc`, `title`, `message`, and `onMessage`. The iframe has a sandbox property
set to `sandbox="allow-scripts"`, which only allows scripts.

:::info

`message` and `onMessage` are used to communicate with this iframe
instance.

:::

| param | description |
|-------|-------------|
| `message` | it's passed to the iframe every time the deep equal is different, or the iframe is recreated. The message is passed using `contentWindow.postMessage(message, "*")` on the iframe. |
| `onMessage(data)` | it's called when the iframe passes a message to `window.top`. Only `event.data` is passed to the `onMessage` |

### Events

The VM exposes the following `<iframe>` events:
- `onLoad()`: support for `onLoad` event without any event info
   ```js
   <iframe onLoad={() => { console.log('iframe loaded') }}>
   ```

- `onResized()`: support for `onResized` [Iframe Resizer](#iframe-resizer) event with an object only containing the new `width` and `height`
   ```js
   <iframe iframeResizer={{
      onResized: ({width, height}) => { console.log('iframe resized', width, height) },
   }}>
   ```

### Example

The following example demonstrates how you can use an iframe to call
`eval`:
```js
State.init({
  text: `"b" + "a" + +"a" + "a"`,
});

const code = `
<div>Expression: <pre id="exp" /></div>
<div>Results: <pre id="res" /></div>

<script>
    window.top.postMessage("loaded", "*");
    window.addEventListener("message", (event) => {
        const data = event.data
        document.getElementById("exp").innerHTML = JSON.stringify(data);
        try {
            const result = eval(data.exp);
            document.getElementById("res").innerHTML = result;
            event.source.postMessage(result, "*");
        } catch (e) {
            // ignore
        }
    }, false);
</script>
`;

return (
  <div>
    <input
      value={state.text || ""}
      onChange={(e) => State.update({ text: e.target.value })}
    />
    Iframes below
    <div className="d-flex">
      <iframe
        className="w-50 border"
        srcDoc={code}
        message={{ exp: state.text || "" }}
        onMessage={(res1) => State.update({ res1 })}
      />
      <iframe
        className="w-50 border"
        srcDoc={code}
        message={{ exp: (state.text || "") + " + ' banana'" }}
        onMessage={(res2) => State.update({ res2 })}
      />
    </div>
    Result:{" "}
    <pre>
      res1 = {JSON.stringify(state.res1)}
      res2 = {JSON.stringify(state.res2)}
    </pre>
  </div>
);
```

![iframes](https://user-images.githubusercontent.com/470453/216140589-801a49e8-9ff1-4b76-9019-499b375989cc.png)

## Iframe Resizer

[Iframe Resizer](https://github.com/davidjbradshaw/iframe-resizer) is a critical library for rendering responsive iframes. This library automatically resizes the `iframe` to match the child content size to avoid scrollbars on the `iframe` itself.

:::caution don't forget 

The child page rendered by the `iframe` **must include** this script in order for the resizing to work:

```html
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/iframe-resizer/4.3.6/iframeResizer.contentWindow.js"></script>
```

:::

:::note

NEAR VM uses the React flavor of [this plugin](https://github.com/davidjbradshaw/iframe-resizer-react).

:::

### Basic Example

You can use the Iframe resizer library like this:

```js
return (
  <div>
    <iframe
      iframeResizer
      src="https://davidjbradshaw.com/iframe-resizer/example/frame.content.html"
    />
  </div>
);
```

If you need to pass in options to override the default behavior:

```js
return (
  <div>
    <iframe
      iframeResizer={{ log: true }}
      src="https://davidjbradshaw.com/iframe-resizer/example/frame.content.html"
    />
  </div>
);
```

![iframe resizer](https://user-images.githubusercontent.com/1475067/231292519-51f571c6-5f7b-4076-a1bb-91fd8a99c775.png)

:::tip

You can check [this example](https://near.org/near/widget/ComponentDetailsPage?src=calebjacob.near/widget/IframeResizerTest) to see a complete component using Iframe Resizer.

:::

### `srcDoc` Example

An example of a valid `srcDoc` for a secure Iframe using `iframeResizer`:

```js
const code = `
<script>
// ...your code...

// define message handler
const handleMessage = (m) => {
  console.log('received message', m)
  document.getElementById("messageText").innerHTML = m;
};

// finally, configure iframe resizer options before importing the script
window.iFrameResizer = {
    onMessage: handleMessage
  }
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/iframe-resizer/4.3.6/iframeResizer.contentWindow.js"></script>
<p id="messageText">loading...</p>
`;

return (
  <div>
    <iframe
      iframeResizer
      className="w-100"
      srcDoc={code}
      message="my message"
    />
  </div>
);
```

'''
'''--- docs/3.tutorials/near-components/indexer-tutorials/feed-indexer.md ---
---
id: feed-indexer
title: Social Feed Indexer
sidebar_label: Social Feed Indexer
---

:::info

NEAR QueryAPI is currently under development. Users who want to test-drive this solution need to be added to the allowlist before creating or forking QueryAPI indexers. 

You can request access through [this link](http://bit.ly/near-queryapi-beta).

:::

## Running `feed-indexer`

The indexer `indexingLogic.js` is comprised of functions that help handle, transform and record data. The main logic for handling transaction data as it occurs from the blockchain can be found underneath the comment marked:

```js
// Add your code here
```

A schema is also specified for the tables in which data from relevant transactions is to be persisted, this can be found in the `schema.sql` tab.

:::tip

This indexer can be found by [following this link](https://near.org/dataplatform.near/widget/QueryApi.App?selectedIndexerPath=dataplatform.near/social_feed).

:::

## Schema Definition

:::note

Note that database tables are named as `roshaan_near_feed_indexer_posts` which follows the format `<account_name>_near_<indexer_name>_<table_name>`.

:::

### Schema-Defined Table Names

```sql
CREATE TABLE
  "posts" (
    "id" SERIAL NOT NULL,
    "account_id" VARCHAR NOT NULL,
    "block_height" DECIMAL(58, 0) NOT NULL,
    "receipt_id" VARCHAR NOT NULL,
    "content" TEXT NOT NULL,
    "block_timestamp" DECIMAL(20, 0) NOT NULL,
    "accounts_liked" JSONB NOT NULL DEFAULT '[]',
    "last_comment_timestamp" DECIMAL(20, 0),
    CONSTRAINT "posts_pkey" PRIMARY KEY ("id")
  );

CREATE TABLE
  "comments" (
    "id" SERIAL NOT NULL,
    "post_id" SERIAL NOT NULL,
    "account_id" VARCHAR NOT NULL,
    "block_height" DECIMAL(58, 0) NOT NULL,
    "content" TEXT NOT NULL,
    "block_timestamp" DECIMAL(20, 0) NOT NULL,
    "receipt_id" VARCHAR NOT NULL,
    CONSTRAINT "comments_pkey" PRIMARY KEY ("id")
  );

CREATE TABLE
  "post_likes" (
    "post_id" SERIAL NOT NULL,
    "account_id" VARCHAR NOT NULL,
    "block_height" DECIMAL(58, 0),
    "block_timestamp" DECIMAL(20, 0) NOT NULL,
    "receipt_id" VARCHAR NOT NULL,
    CONSTRAINT "post_likes_pkey" PRIMARY KEY ("post_id", "account_id")
  );

CREATE UNIQUE INDEX "posts_account_id_block_height_key" ON "posts" ("account_id" ASC, "block_height" ASC);

CREATE UNIQUE INDEX "comments_post_id_account_id_block_height_key" ON "comments" (
  "post_id" ASC,
  "account_id" ASC,
  "block_height" ASC
);

CREATE INDEX
  "posts_last_comment_timestamp_idx" ON "posts" ("last_comment_timestamp" DESC);

ALTER TABLE
  "comments"
ADD
  CONSTRAINT "comments_post_id_fkey" FOREIGN KEY ("post_id") REFERENCES "posts" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

ALTER TABLE
  "post_likes"
ADD
  CONSTRAINT "post_likes_post_id_fkey" FOREIGN KEY ("post_id") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;
```

The tables declared in the schema definition are created when the indexer is deployed. In this schema definition, three tables are created: `posts`, `comments` and `post_likes`. Indexes are then defined for each and then foreign key dependencies.

## Main Function

The main function can be explained in two parts. The first filters relevant transactional data for processing by the helper functions defined earlier in the file scope, the second part uses the helper functions to ultimately save the relevant data to for querying by applications.

### Filtering for Relevant Data

```js
const SOCIAL_DB = "social.near";

  const nearSocialPosts = block
    .actions()
    .filter((action) => action.receiverId === SOCIAL_DB)
    .flatMap((action) =>
      action.operations
        .map((operation) => operation["FunctionCall"])
        .filter((operation) => operation?.methodName === "set")
        .map((functionCallOperation) => {
          try {
            const decodedArgs = base64decode(functionCallOperation.args);
            return {
              ...functionCallOperation,
              args: decodedArgs,
              receiptId: action.receiptId,
            };
          } catch (error) {
            console.log(
              "Failed to decode function call args",
              functionCallOperation,
              error
            );
          }
        })
        .filter((functionCall) => {
          try {
            const accountId = Object.keys(functionCall.args.data)[0];
            return (
              Object.keys(functionCall.args.data[accountId]).includes("post") ||
              Object.keys(functionCall.args.data[accountId]).includes("index")
            );
          } catch (error) {
            console.log(
              "Failed to parse decoded function call",
              functionCall,
              error
            );
          }
        })
    );
```

We first designate the near account ID that is on the receiving end of the transactions picked up by the indexer, as `SOCIAL_DB = "social.near"` and later with the equality operator for this check. This way we only filter for transactions that are relevant to the `social.near` account ID for saving data on-chain.

The filtering logic then begins by calling `block.actions()` where `block` is defined within the `@near-lake/primtives` package. The output from this filtering is saved in a `nearSocialPosts` variable for later use by the helper functions. The `.filter()` line helps specify for transactions exclusively that have interacted with the SocialDB. `.flatMap()` specifies the types of transaction and looks for attributes in the transaction data on which to base the filter.

Specifically, `.flatMap()` filters for `FunctionCall` call types, calling the `set` method of the SocialDB contract. In addition, we look for transactions that include a `receiptId` and include either `post` or `index` in the function call argument data.

### Processing Filtered Data

```js
if (nearSocialPosts.length > 0) {
    console.log("Found Near Social Posts in Block...");
    const blockHeight = block.blockHeight;
    const blockTimestamp = block.header().timestampNanosec;
    await Promise.all(
      nearSocialPosts.map(async (postAction) => {
        const accountId = Object.keys(postAction.args.data)[0];
        console.log(`ACCOUNT_ID: ${accountId}`);

        // if creates a post
        if (
          postAction.args.data[accountId].post &&
          Object.keys(postAction.args.data[accountId].post).includes("main")
        ) {
          console.log("Creating a post...");
          await handlePostCreation(
            ... // arguments required for handlePostCreation
          );
        } else if (
          postAction.args.data[accountId].post &&
          Object.keys(postAction.args.data[accountId].post).includes("comment")
        ) {
          // if creates a comment
          await handleCommentCreation(
            ... // arguments required for handleCommentCreation
          );
        } else if (
          Object.keys(postAction.args.data[accountId]).includes("index")
        ) {
          // Probably like or unlike action is happening
          if (
            Object.keys(postAction.args.data[accountId].index).includes("like")
          ) {
            console.log("handling like");
            await handleLike(
              ... // arguments required for handleLike
            );
          }
        }
      })
    );
  }
```

This logic is only entered if there are any `nearSocialPosts`, in which case it first declares the `blockHeight` and `blockTimestamp` variables that will be relevant when handling (transforming and persisting) the data. Then the processing for every transaction (or function call) is chained as a promise for asynchronous execution.

Within every promise, the `accountId` performing the call is extracted from the transaction data first. Then, depending on the attributes in the transaction data, there is logic for handling post creation, comment creation, or a like/unlike.

## Helper Functions

### `base64decode`

```js
function base64decode(encodedValue) {
    let buff = Buffer.from(encodedValue, "base64");
    return JSON.parse(buff.toString("utf-8"));
  }
```

This function decodes a string that has been encoded in Base64 format. It takes a single argument, **`encodedValue`**, which is the Base64-encoded string to be decoded. The function returns the decoded string as a JavaScript object. Specifically:

1. The **`Buffer.from()`** method is called with two arguments: **`encodedValue`** and **`"base64"`**. This creates a new **`Buffer`** object from the **`encodedValue`** string and specifies that the encoding format is Base64.
2. The **`JSON.parse()`** method is called with the **`Buffer`** object returned by the **`Buffer.from()`** method as its argument. This parses the **`Buffer`** object as a JSON string and returns a JavaScript object.
3. The **`toString()`** method is called on the **`Buffer`** object with **`"utf-8"`** as its argument. This converts the **`Buffer`** object to a string in UTF-8 format.
4. The resulting string is returned as a JavaScript object.

### `handlePostCreation`

```js
async function handlePostCreation(
    accountId,
    blockHeight,
    blockTimestamp,
    receiptId,
    content
  ) {
    try {
      const postData = {
        account_id: accountId,
        block_height: blockHeight,
        block_timestamp: blockTimestamp,
        content: content,
        receipt_id: receiptId,
      };

      // Call GraphQL mutation to insert a new post
      await context.db.Posts.insert(postData);

      console.log(`Post by ${accountId} has been added to the database`);
    } catch (e) {
      console.log(
        `Failed to store post by ${accountId} to the database (perhaps it is already stored)`
      );
    }
  }
```

An object containing the relevant data to populate the `posts` table defined in the schema is created first to then be passed into the graphQL `createPost()` query that creates a new row in the table.

### `handleCommentCreation`

```js
async function handleCommentCreation(
    accountId,
    blockHeight,
    blockTimestamp,
    receiptId,
    commentString
  ) {
    try {
      const comment = JSON.parse(commentString);
      const postAuthor = comment.item.path.split("/")[0];
      const postBlockHeight = comment.item.blockHeight;

      // find post to retrieve Id or print a warning that we don't have it
      try {
        // Call GraphQL query to fetch posts that match specified criteria
        const posts = await context.db.Posts.select(
          { account_id: postAuthor, block_height: postBlockHeight },
          1
        );
        console.log(`posts: ${JSON.stringify(posts)}`);
        if (posts.length === 0) {
          return;
        }

        const post = posts[0];

        try {
          delete comment["item"];
          const commentData = {
            account_id: accountId,
            receipt_id: receiptId,
            block_height: blockHeight,
            block_timestamp: blockTimestamp,
            content: JSON.stringify(comment),
            post_id: post.id,
          };
          // Call GraphQL mutation to insert a new comment
          await context.db.Comments.insert(commentData);

          // Update last comment timestamp in Post table
          const currentTimestamp = Date.now();
          await context.db.Posts.update(
            { id: post.id },
            { last_comment_timestamp: currentTimestamp }
          );
          console.log(`Comment by ${accountId} has been added to the database`);
        } catch (e) {
          console.log(
            `Failed to store comment to the post ${postAuthor}/${postBlockHeight} by ${accountId} perhaps it has already been stored. Error ${e}`
          );
        }
      } catch (e) {
        console.log(
          `Failed to store comment to the post ${postAuthor}/${postBlockHeight} as we don't have the post stored.`
        );
      }
    } catch (error) {
      console.log("Failed to parse comment content. Skipping...", error);
    }
  }
```

To save or create a comment the relevant post is fetched first. If no posts are found the comment will not be created. If there is a post created in the graphQL DB, the `mutationData` object is constructed for the `createComment()` graphQL query that adds a row to the `comments` table. Once this row has been added, the relevant row in the `posts` table is updated to this comment‚Äôs timestamp.

### `handleLike`

```js
async function handleLike(
    accountId,
    blockHeight,
    blockTimestamp,
    receiptId,
    likeContent
  ) {
    try {
      const like = JSON.parse(likeContent);
      const likeAction = like.value.type; // like or unlike
      const [itemAuthor, _, itemType] = like.key.path.split("/", 3);
      const itemBlockHeight = like.key.blockHeight;
      console.log("handling like", receiptId, accountId);
      switch (itemType) {
        case "main":
          try {
            const posts = await context.db.Posts.select(
              { account_id: itemAuthor, block_height: itemBlockHeight },
              1
            );
            if (posts.length == 0) {
              return;
            }

            const post = posts[0];
            switch (likeAction) {
              case "like":
                await _handlePostLike(
                  post.id,
                  accountId,
                  blockHeight,
                  blockTimestamp,
                  receiptId
                );
                break;
              case "unlike":
                await _handlePostUnlike(post.id, accountId);
                break;
            }
          } catch (e) {
            console.log(
              `Failed to store like to post ${itemAuthor}/${itemBlockHeight} as we don't have it stored in the first place.`
            );
          }
          break;
        case "comment":
          // Comment
          console.log(`Likes to comments are not supported yet. Skipping`);
          break;
        default:
          // something else
          console.log(`Got unsupported like type "${itemType}". Skipping...`);
          break;
      }
    } catch (error) {
      console.log("Failed to parse like content. Skipping...", error);
    }
  }
```

As with `handleCommentCreation` , first the relevant post is sought from the DB store. If the relevant post is found, the logic proceeds to handling the like being either a like or a dislike.

### `_handlePostLike`

```js
async function _handlePostLike(
    postId,
    likeAuthorAccountId,
    likeBlockHeight,
    blockTimestamp,
    receiptId
  ) {
    try {
      const posts = await context.db.Posts.select({ id: postId });
      if (posts.length == 0) {
        return;
      }
      const post = posts[0];
      let accountsLiked =
        post.accounts_liked.length === 0
          ? post.accounts_liked
          : JSON.parse(post.accounts_liked);

      if (accountsLiked.indexOf(likeAuthorAccountId) === -1) {
        accountsLiked.push(likeAuthorAccountId);
      }

      // Call GraphQL mutation to update a post's liked accounts list
      await context.db.Posts.update(
        { id: postId },
        { accounts_liked: JSON.stringify(accountsLiked) }
      );

      const postLikeData = {
        post_id: postId,
        account_id: likeAuthorAccountId,
        block_height: likeBlockHeight,
        block_timestamp: blockTimestamp,
        receipt_id: receiptId,
      };
      // Call GraphQL mutation to insert a new like for a post
      await context.db.PostLikes.insert(postLikeData);
    } catch (e) {
      console.log(`Failed to store like to in the database: ${e}`);
    }
  }
```

As with `handleLike`, the relevant `post` is first sought from the graphQL DB table defined in `schema.sql`. If a post is found, the `accountsLiked` array is defined from the post‚Äôs previous array plus the additional account that has performed the like account in `accountsLiked.push(likeAuthorAccountId)`. The graphQL query then updates the `posts` table to include this information. Lastly, the `postLikeMutation` object is created with the required data for adding a new row to the `post_likes` table.

### `_handlePostUnlike`

```js
async function _handlePostUnlike(postId, likeAuthorAccountId) {
    try {
      const posts = await context.db.Posts.select({ id: postId });
      if (posts.length == 0) {
        return;
      }
      const post = posts[0];
      let accountsLiked =
        post.accounts_liked.length === 0
          ? post.accounts_liked
          : JSON.parse(post.accounts_liked);

      console.log(accountsLiked);

      let indexOfLikeAuthorAccountIdInPost =
        accountsLiked.indexOf(likeAuthorAccountId);
      if (indexOfLikeAuthorAccountIdInPost > -1) {
        accountsLiked.splice(indexOfLikeAuthorAccountIdInPost, 1);
        // Call GraphQL mutation to update a post's liked accounts list
        await context.db.Posts.update(
          { id: postId },
          { accounts_liked: JSON.stringify(accountsLiked) }
        );
      }
      // Call GraphQL mutation to delete a like for a post
      await context.db.PostLikes.delete({
        account_id: likeAuthorAccountId,
        post_id: postId,
      });
    } catch (e) {
      console.log(`Failed to delete like from the database: ${e}`);
    }
  }
```

Here we also search for an existing relevant post in the `posts` table and if one has been found, the `accountsLiked` is defined as to update it removing the account ID of the account that has performed the like action. Then a graphQL `delete` query is called to remove the like from the `post_likes` table.

## Querying data from the indexer

The final step is querying the indexer using the public GraphQL API. This can be done by writing a GraphQL query using the GraphiQL tab in the code editor.

For example, here's a query that fetches `likes` from the _Feed Indexer_, ordered by `block_height`:

```graphql
query MyQuery {
  <user-name>_near_feed_indexer_post_likes(order_by: {block_height: desc}) {
    account_id
    block_height
    post_id
  }
}
```

Once you have defined your query, you can use the GraphiQL Code Exporter to auto-generate a JavaScript or NEAR Widget code snippet. The exporter will create a helper method `fetchGraphQL` which will allow you to fetch data from the indexer's GraphQL API. It takes three parameters:

- `operationsDoc`: A string containing the queries you would like to execute.
- `operationName`: The specific query you want to run.
- `variables`: Any variables to pass in that your query supports, such as `offset` and `limit` for pagination.

Next, you can call the `fetchGraphQL` function with the appropriate parameters and process the results. 

Here's the complete code snippet for a NEAR component using the _Feed Indexer_:

```js
const QUERYAPI_ENDPOINT = `https://near-queryapi.api.pagoda.co/v1/graphql/`;

State.init({
data: []
});

const query = `query MyFeedQuery {
    <user-name>_near_feed_indexer_post_likes(order_by: {block_height: desc}) {
      account_id
      block_height
      post_id
    }
  }`

function fetchGraphQL(operationsDoc, operationName, variables) {
      return asyncFetch(
        QUERYAPI_ENDPOINT,
        {
          method: "POST",
          headers: { "x-hasura-role": `<user-name>_near` },
          body: JSON.stringify({
            query: operationsDoc,
            variables: variables,
            operationName: operationName,
          }),
        }
      );
    }

fetchGraphQL(query, "MyFeedQuery", {}).then((result) => {
  if (result.status === 200) {
    if (result.body.data) {
      const data = result.body.data.<user-name>_near_feed_indexer_post_likes;
      State.update({ data })
      console.log(data);
    }
  }
});

const renderData = (a) => {
  return (
    <div key={JSON.stringify(a)}>
        {JSON.stringify(a)}
    </div>
  );
};

const renderedData = state.data.map(renderData);
return (
  {renderedData}
);
```

:::tip

To view a more complex example, see this widget which fetches posts with proper pagination: [Posts Widget powered By QueryAPI](https://near.org/edit/roshaan.near/widget/query-api-feed-infinite).

:::

'''
'''--- docs/3.tutorials/near-components/indexer-tutorials/hype-indexer.md ---
---
id: hype-indexer
title: Hype Indexer
sidebar_label: Hype Indexer
---

:::info

NEAR QueryAPI is currently under development. Users who want to test-drive this solution need to be added to the allowlist before creating or forking QueryAPI indexers. 

You can request access through [this link](http://bit.ly/near-queryapi-beta).

:::

## Overview

This indexer creates a new row in a pre-defined `posts` or `comments` table created by the user in the GraphQL database for every new post or comment found on the blockchain that contains either "PEPE" or "DOGE" in the contents. This is a simple example that shows how to specify two tables, filter blockchain transaction data for a specific type of transaction and its contents, and save the data to the database.

:::tip

This indexer can be found by [following this link](https://near.org/#/dataplatform.near/widget/QueryApi.App?selectedIndexerPath=bucanero.near/hype-indexer).

:::

## Defining the Database Schema

The first step to creating an indexer is to define the database schema. This is done by editing the `schema.sql` file in the code editor. The schema for this indexer looks like this:

```sql
CREATE TABLE
  "posts" (
    "id" TEXT NOT NULL,
    "account_id" VARCHAR NOT NULL,
    "block_height" DECIMAL(58, 0) NOT NULL,
    "block_timestamp" DECIMAL(20, 0) NOT NULL,
    "receipt_id" VARCHAR NOT NULL,
    "content" TEXT NOT NULL,
    CONSTRAINT "posts_pkey" PRIMARY KEY ("id")
  );

CREATE TABLE
  "comments" (
    "id" SERIAL NOT NULL,
    "post_id" TEXT NOT NULL,
    "account_id" VARCHAR NOT NULL,
    "block_height" DECIMAL(58, 0) NOT NULL,
    "block_timestamp" DECIMAL(20, 0) NOT NULL,
    "receipt_id" VARCHAR NOT NULL,
    "content" TEXT NOT NULL,
    CONSTRAINT "comments_pkey" PRIMARY KEY ("id")
  );
```

This schema defines two tables: `posts` and `comments`. The `posts` table has columns:

- `id`: a unique identifier for each row in the table
- `account_id`: the account ID of the user who created the post
- `block_height`: the height of the block in which the post was created
- `block_timestamp`: the timestamp of the block in which the post was created
- `receipt_id`: the receipt ID of the transaction that created the post
- `content`: the content of the post

The `comments` table has columns:

- `id`: a unique identifier for each row in the table
- `post_id`: the ID of the post that the comment was made on
- `account_id`: the account ID of the user who created the comment
- `block_height`: the height of the block in which the comment was created
- `block_timestamp`: the timestamp of the block in which the comment was created
- `receipt_id`: the receipt ID of the transaction that created the comment
- `content`: the content of the comment

## Defining the indexing logic

The next step is to define the indexing logic. This is done by editing the `indexingLogic.js` file in the code editor. The logic for this indexer can be divided into two parts:

1. Filtering blockchain transactions for a specific type of transaction
2. Saving the data from the filtered transactions to the database

### Filtering Blockchain transactions

The first part of the logic is to filter blockchain transactions for a specific type of transaction. This is done by using the `getBlock` function. This function takes in a block and a context and returns a promise. The block is a Near Protocol block, and the context is a set of helper methods to retrieve and commit state. The `getBlock` function is called for every block on the blockchain.

The `getBlock` function for this indexer looks like this:

```js
import { Block } from "@near-lake/primitives";

async function getBlock(block: Block, context) {
  const SOCIAL_DB = "social.near";

  function base64decode(encodedValue) {
    let buff = Buffer.from(encodedValue, "base64");
    return JSON.parse(buff.toString("utf-8"));
  }

  function get_near_social_posts_comments(
    block_type = block,
    DB = SOCIAL_DB,
    decodeFunction = base64decode
  ) {
    const nearSocialPostsComments = block_type
      .actions()
      .filter((action) => action.receiverId === DB)
      .flatMap((action) =>
        action.operations
          .map((operation) => operation["FunctionCall"])
          .filter((operation) => operation?.methodName === "set")
          .map((functionCallOperation) => ({
            ...functionCallOperation,
            args: decodeFunction(functionCallOperation.args),
            receiptId: action.receiptId, // providing receiptId as we need it
          }))
          .filter((functionCall) => {
            const accountId = Object.keys(functionCall.args.data)[0];
            return (
              Object.keys(functionCall.args.data[accountId]).includes("post") ||
              Object.keys(functionCall.args.data[accountId]).includes("index")
            );
          })
      );
    return nearSocialPostsComments;
  }

  const nearSocialPostsComments = get_near_social_posts_comments();

  ... // Further filtering for posts/comments that contain "PEPE" or "DOGE" in the contents and saving the data to the database is done in the next section
}
```

Again, like with the [`posts-indexer`](./posts-indexer.md) or the [`feed-indexer`](./feed-indexer.md), this filter selects transactions that are of type `FunctionCall` to the `set` method on the contract `social.near` on the network. In addition, it searches for `post` or `index` string in the data for the call.

### Saving the data to the Database

The second part of the logic is to save the data from the filtered transactions to the database. This section also performs the filtering of transactions for posts and comments that contain "PEPE" or "DOGE" in the contents.

The logic for this looks like:

```js
  ... // Logic for filtering blockchain transactions is above

  if (nearSocialPostsComments.length > 0) {
    const blockHeight = block.blockHeight;
    const blockTimestamp = Number(block.header().timestampNanosec);
    await Promise.all(
      nearSocialPostsComments.map(async (postAction) => {
        const accountId = Object.keys(postAction.args.data)[0];
        console.log(`ACCOUNT_ID: ${accountId}`);

        const isPost =
          postAction.args.data[accountId].post &&
          Object.keys(postAction.args.data[accountId].post).includes("main");
        const isComment =
          postAction.args.data[accountId].post &&
          Object.keys(postAction.args.data[accountId].post).includes("comment");

        if (isPost) {
          const isHypePost =
            postAction.args.data[accountId].post.main.includes("PEPE") ||
            postAction.args.data[accountId].post.main.includes("DOGE");
          if (!isHypePost) {
            return;
          }
          console.log("Creating a post...");
          const postId = `${accountId}:${blockHeight}`;
          await createPost(
            postId,
            accountId,
            blockHeight,
            blockTimestamp,
            postAction.receiptId,
            postAction.args.data[accountId].post.main
          );
        }
        if (isComment) {
          const commentString = JSON.parse(
            postAction.args.data[accountId].post.comment
          );
          const isHypeComment =
            commentString.includes("PEPE") || commentString.includes("DOGE");
          if (!isHypeComment) {
            return;
          }
          console.log("Creating a comment...");
          const postBlockHeight =
            postAction.args.data[accountId].post.blockHeight;
          const postId = `${accountId}:${postBlockHeight}`;
          await createComment(
            accountId,
            postId,
            blockHeight,
            blockTimestamp,
            postAction.receiptId,
            commentString
          );
        }
      })
    );
  }

  ... // Definitions for createPost and createComment are below
```

#### `createPost`
Creating a post is done by using the [`context.db.Posts.insert()`](../../../2.build/6.data-infrastructure/query-api/context.md#insert) function:

```js
  async function createPost(
    postId,
    accountId,
    blockHeight,
    blockTimestamp,
    receiptId,
    postContent
  ) {
    try {
      const postObject = {
          id: postId,
          account_id: accountId,
          block_height: blockHeight,
          block_timestamp: blockTimestamp,
          receipt_id: receiptId,
          content: postContent,
      };
      await context.db.Posts.insert(postObject);
      console.log("Post created!");
    } catch (error) {
      console.error(error);
    }
  }
```

#### `createComment`

Creating a comment is done by using the [`context.db.Comments.insert()`](../../../2.build/6.data-infrastructure/query-api/context.md#insert) function:

```js
  async function createComment(
    accountId,
    postId,
    blockHeight,
    blockTimestamp,
    receiptId,
    commentContent
  ) {
    try {
      const commentObject = {
          account_id: accountId,
          post_id: postId,
          block_height: blockHeight,
          block_timestamp: blockTimestamp,
          receipt_id: receiptId,
          content: commentContent,
      };
      await context.db.Comments.insert(commentObject);
      console.log("Comment created!");
    } catch (error) {
      console.error(error);
    }
  }
```

## Querying data from the indexer

The final step is querying the indexer using the public GraphQL API. This can be done by writing a GraphQL query using the GraphiQL tab in the code editor.

For example, here's a query that fetches `posts` and `comments` from the _Hype Indexer_, ordered by `block_height`:

```graphql
query MyQuery {
  <user-name>_near_hype_indexer_posts(order_by: {block_height: desc}) {
    account_id
    block_height
    content
  }
  <user-name>_near_hype_indexer_comments(order_by: {block_height: desc}) {
    account_id
    block_height
    content
  }
}
```

Once you have defined your query, you can use the GraphiQL Code Exporter to auto-generate a JavaScript or NEAR Widget code snippet. The exporter will create a helper method `fetchGraphQL` which will allow you to fetch data from the indexer's GraphQL API. It takes three parameters:

- `operationsDoc`: A string containing the queries you would like to execute.
- `operationName`: The specific query you want to run.
- `variables`: Any variables to pass in that your query supports, such as `offset` and `limit` for pagination.

Next, you can call the `fetchGraphQL` function with the appropriate parameters and process the results. 

Here's the complete code snippet for a NEAR component using the _Hype Indexer_:

```js
const QUERYAPI_ENDPOINT = `https://near-queryapi.api.pagoda.co/v1/graphql/`;

State.init({
data: []
});

const query = `query MyHypeQuery {
    <user-name>_near_hype_indexer_posts(order_by: {block_height: desc}) {
      account_id
      block_height
      content
    }
    <user-name>_near_hype_indexer_comments(order_by: {block_height: desc}) {
      account_id
      block_height
      content
    }
  }`

function fetchGraphQL(operationsDoc, operationName, variables) {
      return asyncFetch(
        QUERYAPI_ENDPOINT,
        {
          method: "POST",
          headers: { "x-hasura-role": `<user-name>_near` },
          body: JSON.stringify({
            query: operationsDoc,
            variables: variables,
            operationName: operationName,
          }),
        }
      );
    }

fetchGraphQL(query, "MyHypeQuery", {}).then((result) => {
  if (result.status === 200) {
    if (result.body.data) {
      const data = result.body.data.<user-name>_near_hype_indexer_posts;
      State.update({ data })
      console.log(data);
    }
  }
});

const renderData = (a) => {
  return (
    <div key={JSON.stringify(a)}>
        {JSON.stringify(a)}
    </div>
  );
};

const renderedData = state.data.map(renderData);
return (
  {renderedData}
);
```

:::tip

To view a more complex example, see this widget which fetches posts with proper pagination: [Posts Widget powered By QueryAPI](https://near.org/edit/roshaan.near/widget/query-api-feed-infinite).

:::

'''
'''--- docs/3.tutorials/near-components/indexer-tutorials/nft-indexer.md ---
---
id: nft-indexer
title: Minted NFTs Indexer
sidebar_label: NFTs Indexer
---

:::info

NEAR QueryAPI is currently under development. Users who want to test-drive this solution need to be added to the allowlist before creating or forking QueryAPI indexers.

You can request access through [this link](http://bit.ly/near-queryapi-beta).

:::

## Overview

This tutorial creates a working NFT indexer using [NEAR QueryAPI](../../../2.build/6.data-infrastructure/query-api/intro.md), and builds a [NEAR component](../../../2.build/3.near-components/what-is.md) that presents the data. The indexer is watching for `nft_mint` [Events](https://nomicon.io/Standards/EventsFormat) and captures some relevant data:

- `receiptId` of the [Receipt](/build/data-infrastructure/lake-data-structures/receipt) where the mint has happened
- `receiverId`
- Marketplace
- Links to the transaction on NEAR Explorer

In this tutorial you'll learn how you can listen to [Events](https://nomicon.io/Standards/EventsFormat) generated by smart contracts and how you can index them.

:::tip

The indexer's source code can be found by [following this link](https://near.org/dataplatform.near/widget/QueryApi.App?selectedIndexerPath=bucanero.near/nft_v4).

:::

### NFT Events

NEAR Protocol supports [Events](https://nomicon.io/Standards/EventsFormat). These `Events` allow a contract developer to add standardized logs to the [`ExecutionOutcomes`](/build/data-infrastructure/lake-data-structures/execution-outcome) thus allowing themselves or other developers to read those logs in more convenient manner via API or indexers. Events have a field `standard` which aligns with NEPs. In this tutorial we'll be talking about [NEP-171 Non-Fungible Token standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core).

The indexer watches all the NFTs minted following the [NEP-171 Events](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event) standard. It should detect every single NFT minted, and store a basic set of data like: in what Receipt it was minted, and which marketplace created it (for example, [Paras](https://paras.id), [ShardDog](https://shard.dog), and [Mintbase](https://mintbase.io)).

## Defining the Database Schema

The first step to creating an indexer is to define the database schema. This is done by editing the `schema.sql` file in the code editor. The schema for this indexer looks like this:

```sql
CREATE TABLE
  "nfts" (
    "id" SERIAL NOT NULL,
    "marketplace" TEXT,
    "block_height" BIGINT,
    "block_timestamp" BIGINT,
    "receipt_id" TEXT,
    "receiver_id" TEXT,
    "nft_data" TEXT,
    PRIMARY KEY ("id", "block_height", "block_timestamp")
  );
```

This schema defines one table: `nfts`. The table has these columns:

- `id`: a unique identifier for each row in the table
- `marketplace`: the marketplace where the NFT was created
- `block_height`: the height of the block in which the NFT was created
- `block_timestamp`: the timestamp of the block in which the NFT was created
- `receipt_id`: the receipt ID of the transaction that created the NFT
- `receiver_id`: the receiver ID of the transaction that created the NFT
- `nft_data`: the content of the minted NFT

## Defining the indexing logic

The next step is to define the indexing logic. This is done by editing the `indexingLogic.js` file in the code editor. The logic for this indexer can be divided into two parts:

1. Filtering blockchain transactions for a specific type of transaction
2. Saving the data from the filtered transactions to the database

### Filtering Blockchain transactions

The first part of the logic is to filter blockchain transactions for a specific type of transaction, where the `Event` is a [NEP-171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core) `nft_mint`. This is done by using the `getBlock` function. This function takes in a block and a context and returns a promise. The `block` is a Near Protocol block, and the `context` is a set of helper methods to retrieve and commit state. The `getBlock` function is called for every block on the blockchain.

The `getBlock` function for this NFT indexer looks like this:

```js
async function getBlock(block: Block) {
  for (let ev of block.events()) {
    const r = block.actionByReceiptId(ev.relatedReceiptId);
    const createdOn = block.streamerMessage.block.header.timestamp;

    try {
      let event = ev.rawEvent;

      if (event.standard === "nep171" && event.event === "nft_mint") {
        console.log(event);

        let marketplace = "unknown";
        if (r.receiverId.endsWith(".paras.near")) marketplace = "Paras";
        else if (r.receiverId.endsWith(".sharddog.near"))
          marketplace = "ShardDog";
        else if (r.receiverId.match(/\.mintbase\d+\.near$/))
          marketplace = "Mintbase";

        const nftMintData = {
          marketplace: marketplace,
          block_height: block.header().height,
          block_timestamp: createdOn,
          receipt_id: r.receiptId,
          receiver_id: r.receiverId,
          nft_data: JSON.stringify(event.data),
        };

        await context.db.Nfts.insert(nftMintData);

        console.log(`NFT by ${r.receiptId} has been added to the database`);
      }
    } catch (e) {
      console.log(e);
    }
  }
}
```

This indexer filters [Blocks](https://near.github.io/near-lake-framework-js/classes/_near_lake_primitives.block.Block.html) that have [Events](https://near.github.io/near-lake-framework-js/classes/_near_lake_primitives.events.Event.html) of type `nft_mint` and standard `nep171`. In addition, it stores the JSON event data and identifies the NFT marketplace.

### Saving the data to the Database

The second part of the logic is to save the data from the filtered transactions to the database.
This is solved easily by using the [`context.db.Nfts.insert`](../../../2.build/6.data-infrastructure/query-api/context.md#insert) helper method:

The logic for this looks like:

```js
const nftMintData = {
  marketplace: marketplace,
  block_height: h,
  block_timestamp: createdOn,
  receipt_id: r.receiptId,
  receiver_id: r.receiverId,
  nft_data: JSON.stringify(event.data),
};

// store result to the database
await context.db.Nfts.insert(nftMintData);
```

## NEAR Component

The final step is querying the indexer using GraphQL from a [NEAR component](../queryapi-ws.md) with WebSockets.

Here's a simple GraphQL query that gets the last `${LIMIT}` minted NFTs:

```graphql
IndexerQuery {
    bucanero_near_nft_v4_nfts(order_by: {block_timestamp: desc}, limit: ${LIMIT}) {
      block_height
      block_timestamp
      id
      marketplace
      nft_data
      receipt_id
      receiver_id
    }
```

### Setup

Here's a code snippet that subscribes and processes the most recent activity (last 10 NFTs) from the [NFT indexer](#queryapi-indexer):

:::tip

The code below is only a snippet. If you want the full source code to play around with the component, you can fork the [NFT Activity Feed source code](https://near.org/near/widget/ComponentDetailsPage?src=bucanero.near/widget/query-api-nft-feed) and build your own NEAR component.

:::

```js
const GRAPHQL_ENDPOINT = "near-queryapi.api.pagoda.co";

const LIMIT = 10;
const accountId = props.accountId || "bucanero.near" || context.accountId;

State.init({
  widgetActivities: [],
  widgetActivityCount: 0,
  startWebSocketWidgetActivity: null,
  initialFetch: false,
});

const widgetActivitySubscription = `
  subscription IndexerQuery {
    bucanero_near_nft_v4_nfts(order_by: {block_timestamp: desc}, limit: ${LIMIT}) {
      block_height
      block_timestamp
      id
      marketplace
      nft_data
      receipt_id
      receiver_id
    }
  }
`;

const subscriptionWidgetActivity = {
  type: "start",
  id: "widgetNftActivity", // You can use any unique identifier
  payload: {
    operationName: "IndexerQuery",
    query: widgetActivitySubscription,
    variables: {},
  },
};
function processWidgetActivity(activity) {
  return { ...activity };
}
function startWebSocketWidgetActivity(processWidgetActivities) {
  let ws = State.get().ws_widgetActivity;

  if (ws) {
    ws.close();
    return;
  }

  ws = new WebSocket(`wss://${GRAPHQL_ENDPOINT}/v1/graphql`, "graphql-ws");

  ws.onopen = () => {
    console.log(`Connection to WS has been established`);
    ws.send(
      JSON.stringify({
        type: "connection_init",
        payload: {
          headers: {
            "Content-Type": "application/json",
            "Hasura-Client-Name": "hasura-console",
            "x-hasura-role": "bucanero_near",
          },
          lazy: true,
        },
      })
    );

    setTimeout(() => ws.send(JSON.stringify(subscriptionWidgetActivity)), 50);
  };

  ws.onclose = () => {
    State.update({ ws_widgetActivity: null });
    console.log(`WS Connection has been closed`);
  };

  ws.onmessage = (e) => {
    const data = JSON.parse(e.data);
    console.log("received data", data);
    if (data.type === "data" && data.id === "widgetNftActivity") {
      processWidgetActivities(data.payload.data);
    }
  };

  ws.onerror = (err) => {
    State.update({ ws_widgetActivity: null });
    console.log("WebSocket error", err);
  };

  State.update({ ws_widgetActivity: ws });
}
```

:::info
Pay attention to the `widgetActivitySubscription` GraphQL query and the `subscriptionWidgetActivity` JSON payload.
:::

---

### Processing

This is the JS function that process the incoming widget activities generated by the QueryAPI indexer, allowing the NEAR component to create a feed based on the blockchain's widget activity:

:::tip

You can fork the [NFT Activity Feed source code](https://near.org/near/widget/ComponentDetailsPage?src=bucanero.near/widget/query-api-nft-feed) and build your own NEAR component.

:::

```js
function processWidgetActivities(incoming_data) {
  let incoming_widgetActivities =
    incoming_data.bucanero_near_nft_v4_nfts.flatMap(processWidgetActivity);
  const newActivities = [
    ...incoming_widgetActivities.filter((activity) => {
      return (
        state.widgetActivities.length == 0 ||
        activity.block_timestamp > state.widgetActivities[0].block_timestamp
      );
    }),
  ];
  if (newActivities.length > 0 && state.widgetActivities.length > 0) {
  }
  const prevActivities = state.prevActivities || [];
  State.update({ widgetActivities: [...newActivities, ...prevActivities] });
}

if (state.ws_widgetActivity === undefined) {
  State.update({
    startWebSocketWidgetActivity: startWebSocketWidgetActivity,
  });
  state.startWebSocketWidgetActivity(processWidgetActivities);
}
```

---

### Rendering

Finally, rendering the activity feed on the NEAR component is straight-forward, by iterating through the `state.widgetActivities` map:

```js
return (
  <div>
    <Title>
      NFT Minting Activity Feed{" "}
      <TextLink href="https://near.org/dataplatform.near/widget/QueryApi.App">
        {" "}
        Powered By QueryAPI{" "}
      </TextLink>
    </Title>
    <RowContainer>
      {state.widgetActivities.map((activity, i) => (
        <Card>
          <div>
            <Widget
              src="mob.near/widget/TimeAgo"
              props={{ blockHeight: activity.block_height }}
            />{" "}
            ago
          </div>
          <CardBody>
            <div key={i}>
              <Text bold>NFT Marketplace: {activity.marketplace}</Text>
              <TextLink
                href={`https://nearblocks.io/address/${activity.receiver_id}`}
              >
                {activity.receiver_id}
              </TextLink>
              <Text bold>Receipt ID: {activity.receipt_id}</Text>
            </div>
          </CardBody>
          <CardFooter>
            <TextLink
              href={`https://legacy.nearblocks.io/?query=${activity.receipt_id}`}
            >
              View details on NEAR Explorer
            </TextLink>
          </CardFooter>
        </Card>
      ))}
    </RowContainer>
  </div>
);
```

'''
'''--- docs/3.tutorials/near-components/indexer-tutorials/posts-indexer.md ---
---
id: posts-indexer
title: Posts Indexer
sidebar_label: Posts Indexer
---

:::info

NEAR QueryAPI is currently under development. Users who want to test-drive this solution need to be added to the allowlist before creating or forking QueryAPI indexers. 

You can request access through [this link](http://bit.ly/near-queryapi-beta).

:::

## Overview

This indexer creates a new row in a pre-defined `posts` table created by the user in the GraphQL database for every new post found on the blockchain. This is a simple example that shows how to specify a single table, filter blockchain transaction data for a specific type of transaction, and save the data to the database.

:::tip

This indexer can be found by [following this link](https://near.org/dataplatform.near/widget/QueryApi.App?selectedIndexerPath=bucanero.near/posts-example).

:::

## Defining the Database Schema

The first step to creating an indexer is to define the database schema. This is done by editing the `schema.sql` file in the code editor. The schema for this indexer looks like this:

```sql
CREATE TABLE
  "posts" (
    "id" SERIAL NOT NULL,
    "account_id" VARCHAR NOT NULL,
    "block_height" DECIMAL(58, 0) NOT NULL,
    "receipt_id" VARCHAR NOT NULL,
    "content" TEXT NOT NULL,
    "block_timestamp" DECIMAL(20, 0) NOT NULL,
    CONSTRAINT "posts_pkey" PRIMARY KEY ("id")
  );
```

This schema defines a table called `posts` with columns:

- `id`: a unique identifier for each row in the table
- `account_id`: the account ID of the user who created the post
- `block_height`: the height of the block in which the post was created
- `receipt_id`: the receipt ID of the transaction that created the post
- `content`: the content of the post
- `block_timestamp`: the timestamp of the block in which the post was created

## Defining the Indexing Logic

The next step is to define the indexing logic. This is done by editing the `indexingLogic.js` file in the code editor. The logic for this indexer can be divided into two parts:

1. Filtering blockchain transactions for a specific type of transaction
2. Saving the data from the filtered transactions to the database

### Filtering Blockchain Transactions

The first part of the logic is to filter blockchain transactions for a specific type of transaction. This is done by using the `getBlock` function. This function takes in a block and a context and returns a promise. The block is a Near Protocol block, and the context is a set of helper methods to retrieve and commit state. The `getBlock` function is called for every block on the blockchain.

The `getBlock` function for this indexer looks like this:

```js
import { Block } from "@near-lake/primitives";

async function getBlock(block: Block, context) {
  function base64decode(encodedValue) {
    let buff = Buffer.from(encodedValue, "base64");
    return JSON.parse(buff.toString("utf-8"));
  }

  const SOCIAL_DB = "social.near";

  const nearSocialPosts = block
    .actions()
    .filter((action) => action.receiverId === SOCIAL_DB)
    .flatMap((action) =>
      action.operations
        .map((operation) => operation["FunctionCall"])
        .filter((operation) => operation?.method_name === "set")
        .map((functionCallOperation) => ({
          ...functionCallOperation,
          args: base64decode(functionCallOperation.args),
          receiptId: action.receiptId,
        }))
        .filter((functionCall) => {
          const accountId = Object.keys(functionCall.args.data)[0];
          return (
            Object.keys(functionCall.args.data[accountId]).includes("post") ||
            Object.keys(functionCall.args.data[accountId]).includes("index")
          );
        })
    );

  ... // Further logic for saving nearSocialPosts to the database
}
```

This function first defines a helper function called `base64decode` that decodes base64 encoded data. It then defines a constant called `SOCIAL_DB` that is the name of the smart contract that stores the posts in NEAR. It then filters the blockchain transactions for a specific type of transaction. This is done by:

1. Filtering the blockchain transactions for transactions where the `receiverId` is the `SOCIAL_DB` database
2. Mapping the operations of the filtered transactions to the `FunctionCall` operation
3. Filtering the `FunctionCall` operations for operations where the `method_name` is `set`
4. Mapping the filtered `FunctionCall` operations to an object that contains the `FunctionCall` operation, the decoded `args` of the `FunctionCall` operation, and the `receiptId` of the transaction
5. Filtering the mapped objects for objects where the `args` contain a `post` or `index` key

This function returns an array of objects that contain the `FunctionCall` operation, the decoded `args` of the `FunctionCall` operation, and the `receiptId` of the transaction. This array is called `nearSocialPosts`.

### Saving the Data to the Database

The second part of the logic is to save the data from the filtered transactions to the database. This is done by using the [`context.db.Posts.insert()`](../../../2.build/6.data-infrastructure/query-api/context.md#insert) function. The `context.db.Posts.insert()` function will be called for every filtered transaction as defined by the `.map()` function called on the array of `nearSocialPosts`.

The function for this indexer looks like this:

```js
  ... // Logic for filtering blockchain transactions, defining nearSocialPosts

  if (nearSocialPosts.length > 0) {
    const blockHeight = block.blockHeight;
    const blockTimestamp = Number(block.header().timestampNanosec);
    await Promise.all(
      nearSocialPosts.map(async (postAction) => {
        const accountId = Object.keys(postAction.args.data)[0];
        console.log(`ACCOUNT_ID: ${accountId}`);

        // create a post if indeed a post
        if (
          postAction.args.data[accountId].post &&
          Object.keys(postAction.args.data[accountId].post).includes("main")
        ) {
          try {
            console.log("Creating a post...");
            const postData = {
                account_id: accountId,
                block_height: blockHeight,
                block_timestamp: blockTimestamp,
                receipt_id: postAction.receiptId,
                content: postAction.args.data[accountId].post.main,
            };
            await context.db.Posts.insert(postData);
            console.log(`Post by ${accountId} has been added to the database`);
          } catch (e) {
            console.error(`Error creating a post by ${accountId}: ${e}`);
          }
        }
      })
    );
  }
```

## Querying data from the indexer

The final step is querying the indexer using the public GraphQL API. This can be done by writing a GraphQL query using the GraphiQL tab in the code editor.

For example, here's a query that fetches `posts` from the _Posts Indexer_, ordered by `block_height`:

```graphql
query MyQuery {
  <user-name>_near_posts_indexer_posts(order_by: {block_height: desc}) {
    content
    block_height
    account_id
  }
}
```

Once you have defined your query, you can use the GraphiQL Code Exporter to auto-generate a JavaScript or NEAR Widget code snippet. The exporter will create a helper method `fetchGraphQL` which will allow you to fetch data from the indexer's GraphQL API. It takes three parameters:

- `operationsDoc`: A string containing the queries you would like to execute.
- `operationName`: The specific query you want to run.
- `variables`: Any variables to pass in that your query supports, such as `offset` and `limit` for pagination.

Next, you can call the `fetchGraphQL` function with the appropriate parameters and process the results. 

Here's the complete code snippet for a NEAR component using the _Posts Indexer_:

```js
const QUERYAPI_ENDPOINT = `https://near-queryapi.api.pagoda.co/v1/graphql/`;

State.init({
data: []
});

const query = `query MyPostsQuery {
    <user-name>_near_posts_indexer_posts(order_by: {block_height: desc}) {
      content
      block_height
      account_id
    }
  }`

function fetchGraphQL(operationsDoc, operationName, variables) {
      return asyncFetch(
        QUERYAPI_ENDPOINT,
        {
          method: "POST",
          headers: { "x-hasura-role": `<user-name>_near` },
          body: JSON.stringify({
            query: operationsDoc,
            variables: variables,
            operationName: operationName,
          }),
        }
      );
    }

fetchGraphQL(query, "MyPostsQuery", {}).then((result) => {
  if (result.status === 200) {
    if (result.body.data) {
      const data = result.body.data.<user-name>_near_posts_indexer_posts;
      State.update({ data })
      console.log(data);
    }
  }
});

const renderData = (a) => {
  return (
    <div key={JSON.stringify(a)}>
        {JSON.stringify(a)}
    </div>
  );
};

const renderedData = state.data.map(renderData);
return (
  {renderedData}
);
```

:::tip

To view a more complex example, see this widget which fetches posts with proper pagination: [Posts Widget powered By QueryAPI](https://near.org/edit/roshaan.near/widget/query-api-feed-infinite).

:::

'''
'''--- docs/3.tutorials/near-components/push-notifications.md ---
---
id: push-notifications
title: Push Notifications
---
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Push messages enable your gateway to send notifications on desktop and mobile devices even when the users are not active.

To implement push notifications, you need to:

1. Create a Service Worker
2. Ask the user for permission to send push notifications
2. Send the `client identifier` information to our notification server
3. Add logic to display the notifications

:::tip Example
Check our working example at https://github.com/near-examples/BOS-notifications
:::

---

## Create the Service Worker
Push notifications work by having a [service worker](https://codelabs.developers.google.com/codelabs/push-notifications#2) on the client side that listens for messages from the NEAR notifications server.

<CodeTabs>
    <Github fname="main.js" language="js" value="Create"
            url="https://github.com/near-examples/BOS-notifications/blob/main/app/scripts/main.js"
            start="16" end="22" />
</CodeTabs>

Browsers readily provide native support for service workers, so you can easily check if a service worker exists, and create one if not.

---

## Subscribe to our Notifications

In order to have the `service worker` display notifications, you need to subscribe it to a notifications server.

A notification server is identified by its `public key`, constraining that only the server holding the `private` counterpart can push notifications to the user.

<CodeTabs>
    <Github fname="main.js" language="js" value="Subscribe"
            url="https://github.com/near-examples/BOS-notifications/blob/main/app/scripts/main.js"
            start="44" end="50" />
</CodeTabs>

:::tip Permission
When you subscribe to the service, the user will be asked for permission to be sent notifications.
:::

---

## Create a Stream in our Server

After you subscribe the user to a notifications server, share it with us so we can start sending you notifications!

For this, make a `post` request to our server, add which account you want to be notified for, and a URL identifying your gateway.

<CodeTabs>
    <Github fname="main.js" language="js" value="Stream"
            url="https://github.com/near-examples/BOS-notifications/blob/main/app/scripts/main.js"
            start="52" end="64" />
</CodeTabs>

:::tip
The `gateway` parameter is there just to help us keep track of who receives notifications.
:::

---

## Handle Notifications

When the user receives a notification, the `service worker` will be triggered, and you can add logic to display the notification.

<CodeTabs>
    <Github fname="sw.js" language="js" value="Notifications"
            url="https://github.com/near-examples/BOS-notifications/blob/main/app/scripts/sw.js"
            start="20" end="37" />
</CodeTabs>

Feel free to personalize the notification as you wish, and to add logic on what to do once the notification is clicked. In our example, we just open the Post page.

<CodeTabs>
    <Github fname="sw.js" language="js" value="Notifications"
            url="https://github.com/near-examples/BOS-notifications/blob/main/app/scripts/sw.js"
            start="39" end="51" />
</CodeTabs>
'''
'''--- docs/3.tutorials/near-components/queryapi-ws.md ---
---
id: queryapi-websockets
title: WebSocket-enabled Components with QueryAPI
sidebar_label: WebSockets & QueryAPI
---

In this article you'll learn how to create a NEAR component that gathers information from a [QueryAPI indexer](../../2.build/6.data-infrastructure/query-api/intro.md) using WebSockets.
In this example, the QueryAPI indexer monitors the widget activity on the blockchain, and the NEAR component gets that information using WebSockets.

:::info

[QueryAPI](../../2.build/6.data-infrastructure/query-api/intro.md) is a fully managed solution to build indexer functions, extract on-chain data, store it in a database, and be able to query it using GraphQL endpoints.

:::

## QueryAPI indexer

The [Widget Activity indexer](https://near.org/dataplatform.near/widget/QueryApi.App?selectedIndexerPath=roshaan.near/widget-activity-feed) keeps track of any widget activity on the `social.near` smart contract. Whenever a Widget transaction is found, the data is stored in a Postgres database.

### DB schema

The schema for the indexer's database is pretty simple:

```sql title=schema.sql
CREATE TABLE
  "widget_activity" (
    "id" SERIAL NOT NULL,
    "account_id" VARCHAR NOT NULL,
    "widget_name" VARCHAR NOT NULL,
    "block_height" DECIMAL(58, 0) NOT NULL,
    "receipt_id" VARCHAR NOT NULL,
    "block_timestamp" DECIMAL(20, 0) NOT NULL,
    CONSTRAINT "widgets_pkey" PRIMARY KEY ("id")
  );

CREATE INDEX
  idx_widget_activity_block_timestamp ON widget_activity (block_timestamp);
```

### Indexer logic

In the following code snippet, you can find the simple indexer logic that filters widget transactions from the `social.near` smart contract, and if it finds widget development activity, then it adds a record to the `widget_activity` table defined previously.

:::tip

To learn more, check the complete source code of the [Widget Activity indexer](https://near.org/dataplatform.near/widget/QueryApi.App?selectedIndexerPath=roshaan.near/widget-activity-feed).

:::

```js title=indexerLogic.js
  // Add your code here
  const SOCIAL_DB = "social.near";

  const nearSocialWidgetTxs = block
    .actions()
    .filter((action) => action.receiverId === SOCIAL_DB)
    .flatMap((action) =>
      action.operations
        .map((operation) => operation["FunctionCall"])
        .filter((operation) => operation?.methodName === "set")
        .map((functionCallOperation) => ({
          ...functionCallOperation,
          args: base64decode(functionCallOperation.args),
          receiptId: action.receiptId, // providing receiptId as we need it
        }))
        .filter((functionCall) => {
          const accountId = Object.keys(functionCall.args.data)[0];
          return Object.keys(functionCall.args.data[accountId]).includes(
            "widget"
          );
        })
    );

  if (nearSocialWidgetTxs.length > 0) {
    console.log("Found NEAR Widget Development Activity...");
    const blockHeight = block.blockHeight;
    const blockTimestamp = block.header().timestampNanosec;
    console.log(nearSocialWidgetTxs);
    await Promise.all(
      nearSocialWidgetTxs.map(async (widgetEditTx) => {
        const accountId = Object.keys(widgetEditTx.args.data)[0];
        const widgetName = Object.keys(
          widgetEditTx.args.data[accountId]["widget"]
        )[0];

        console.log(`ACCOUNT_ID: ${accountId}`);
        console.log(widgetName);
        await handleWidgetTx(
          accountId,
          widgetName,
          blockHeight,
          blockTimestamp,
          widgetEditTx.receiptId
        );
        console.log(widgetEditTx);
      })
    );
  }
}
```

---

This is the JS function that calls the GraphQL mutation `InsertWidgetActivity` and adds a record to the `widget_activity` table:

:::tip

Learn more about [QueryAPI indexing functions](../../2.build/6.data-infrastructure/query-api/index-function.md) and how to build your own indexers.

:::

```js title=indexerLogic.js
  async function handleWidgetTx(
    accountId,
    widgetName,
    blockHeight,
    blockTimestamp,
    receiptId
  ) {
    console.log(accountId, blockHeight, blockTimestamp, receiptId);
    try {
      const mutationData = {
        activity: {
          account_id: accountId,
          widget_name: widgetName,
          block_height: blockHeight,
          block_timestamp: blockTimestamp,
          receipt_id: receiptId,
        },
      };
      await context.graphql(
        `mutation InsertWidgetActivity($activity: roshaan_near_widget_activity_feed_widget_activity_insert_input = {}) {
  insert_roshaan_near_widget_activity_feed_widget_activity_one(object: $activity) {
    id
  }
}`,
        mutationData
      );
    } catch (e) {
      console.log(`Could not add widget activity to DB, ${e}`);
    }
  }
```

## Using WebSockets

Once you have a QueryAPI indexer running, you can use WebSockets to get the data in your NEAR Component. You only need to create a `WebSocket` object pointing to the QueryAPI's GraphQL endpoint.

### Setup

Here's a code snippet from the NEAR component that subscribes and processes any activity from the [Widget Activity indexer](#queryapi-indexer):

:::tip

The code below is only a snippet. If you want the full source code to play around with the component, you can fork the [Widget Activity Feed source code](https://near.org#/near/widget/ComponentDetailsPage?src=roshaan.near/widget/query-api-widget-feed) and build your own NEAR component.

:::

```js
const GRAPHQL_ENDPOINT = "near-queryapi.api.pagoda.co";

const LIMIT = 10;
const accountId = props.accountId || "roshaan.near" || context.accountId;

State.init({
  widgetActivities: [],
  widgetActivityCount: 0,
  startWebSocketWidgetActivity: null,
  initialFetch: false,
  soundEffect:
    "https://bafybeic7uvzmhuwjficgctpleov5i43rteavwmktyyjrauwi346ntgja4a.ipfs.nftstorage.link/",
});

const widgetActivitySubscription = `
  subscription IndexerQuery {
    roshaan_near_widget_activity_feed_widget_activity(
      order_by: {block_timestamp: desc}
      limit: ${LIMIT}
    ) {
      account_id
      block_height
      block_timestamp
      id
      receipt_id
      widget_name
    }
  }
`;

const subscriptionWidgetActivity = {
  type: "start",
  id: "widgetActivity", // You can use any unique identifier
  payload: {
    operationName: "IndexerQuery",
    query: widgetActivitySubscription,
    variables: {},
  },
};
function processWidgetActivity(activity) {
  return { ...activity };
}
function startWebSocketWidgetActivity(processWidgetActivities) {
  let ws = State.get().ws_widgetActivity;

  if (ws) {
    ws.close();
    return;
  }

  ws = new WebSocket(`wss://${GRAPHQL_ENDPOINT}/v1/graphql`, "graphql-ws");

  ws.onopen = () => {
    console.log(`Connection to WS has been established`);
    ws.send(
      JSON.stringify({
        type: "connection_init",
        payload: {
          headers: {
            "Content-Type": "application/json",
            "Hasura-Client-Name": "hasura-console",
            "x-hasura-role": "roshaan_near",
          },
          lazy: true,
        },
      })
    );

    setTimeout(() => ws.send(JSON.stringify(subscriptionWidgetActivity)), 50);
  };

  ws.onclose = () => {
    State.update({ ws_widgetActivity: null });
    console.log(`WS Connection has been closed`);
  };

  ws.onmessage = (e) => {
    const data = JSON.parse(e.data);
    console.log("received data", data);
    if (data.type === "data" && data.id === "widgetActivity") {
      processWidgetActivities(data.payload.data);
    }
  };

  ws.onerror = (err) => {
    State.update({ ws_widgetActivity: null });
    console.log("WebSocket error", err);
  };

  State.update({ ws_widgetActivity: ws });
}
```

:::info
Pay attention to the `subscriptionWidgetActivity` JSON payload.
:::

---

### Processing

This is the JS function that process the incoming widget activities generated by the QueryAPI indexer, allowing the NEAR component to create a feed based on the blockchain's widget activity:

:::tip

You can fork the [Widget Activity Feed source code](https://near.org#/near/widget/ComponentDetailsPage?src=roshaan.near/widget/query-api-widget-feed) and build your own NEAR component.

:::

```js
function processWidgetActivities(incoming_data) {
  let incoming_widgetActivities =
    incoming_data.roshaan_near_widget_activity_feed_widget_activity.flatMap(
      processWidgetActivity
    );
  const newActivities = [
    ...incoming_widgetActivities.filter((activity) => {
      return (
        state.widgetActivities.length == 0 ||
        activity.block_timestamp > state.widgetActivities[0].block_timestamp
      );
    }),
  ];
  const prevActivities = state.prevActivities || [];
  State.update({ widgetActivities: [...newActivities, ...prevActivities] });
}

if (state.ws_widgetActivity === undefined) {
  State.update({
    startWebSocketWidgetActivity: startWebSocketWidgetActivity,
  });
  state.startWebSocketWidgetActivity(processWidgetActivities);
}
```

---

### Rendering

Finally, rendering the activity feed on the NEAR component is straight-forward, by iterating through the `state.widgetActivities` map:

```js
return (
  <div>
    <Title>
      Widget Activity Feed{" "}
      <TextLink href="https://near.org/dataplatform.near/widget/QueryApi.App">
        {" "}
        Powered By QueryAPI{" "}
      </TextLink>
    </Title>
    <RowContainer>
      {state.widgetActivities.map((activity, i) => (
        <Card>
          <div>
            <Widget
              src="mob.near/widget/TimeAgo"
              props={{ blockHeight: activity.block_height }}
            />{" "}
            ago
          </div>
          <CardBody>
            <div key={i}>
              <Text bold>Widget Name: {activity.widget_name}</Text>
              <Text bold>Account ID: {activity.account_id}</Text>
            </div>
          </CardBody>
          <CardFooter>
            <TextLink
              href={`/#/near/widget/ComponentDetailsPage?src=${activity.account_id}/widget/${activity.widget_name}`}
            >
              View
            </TextLink>
          </CardFooter>
        </Card>
      ))}
    </RowContainer>
  </div>
);
```

---

'''
'''--- docs/3.tutorials/nfts/0-intro.md ---
---
id: introduction
title: NFT Zero to Hero
sidebar_label: Introduction
---

In this _Zero to Hero_ series, you'll find a set of tutorials that will cover every aspect of a non-fungible token (NFT) smart contract.
You'll start by minting an NFT using a pre-deployed contract and by the end you'll end up building a fully-fledged NFT smart contract that supports every extension.

---

## Prerequisites

To complete these tutorials successfully, you'll need:

- [Rust](https://www.rust-lang.org/tools/install)
- [A Testnet wallet](https://testnet.mynearwallet.com/create)
- [NEAR-CLI](/tools/near-cli#setup)
- [cargo-near](https://github.com/near/cargo-near)

:::info New to Rust?
If you are new to Rust and want to dive into smart contract development, our [Quick-start guide](../../2.build/2.smart-contracts/quickstart.md) is a great place to start
:::

---

## Overview

These are the steps that will bring you from **_Zero_** to **_Hero_** in no time! üí™

| Step | Name                                                          | Description                                                                                                            |
|------|---------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------|
| 1    | [Pre-deployed contract](/tutorials/nfts/predeployed-contract) | Mint an NFT without the need to code, create, or deploy a smart contract.                                              |
| 2    | [Contract architecture](/tutorials/nfts/skeleton)             | Learn the basic architecture of the NFT smart contract and compile code.                                               |
| 3    | [Minting](/tutorials/nfts/minting)                            | Flesh out the skeleton so the smart contract can mint a non-fungible token.                                            |
| 4    | [Upgrade a contract](/tutorials/nfts/upgrade-contract)        | Discover the process to upgrade an existing smart contract.                                                            |
| 5    | [Enumeration](/tutorials/nfts/enumeration)                    | Explore enumeration methods that can be used to return the smart contract's states.                                    |
| 6    | [Core](/tutorials/nfts/core)                                  | Extend the NFT contract using the core standard which allows token transfer.                                        |
| 7    | [Approvals](/tutorials/nfts/approvals)                        | Expand the contract allowing other accounts to transfer NFTs on your behalf.                                           |
| 8    | [Royalty](/tutorials/nfts/royalty)                            | Add NFT royalties allowing for a set percentage to be paid out to the token creator.                                   |
| 9    | [Marketplace](/tutorials/nfts/marketplace)                    | Learn about how common marketplaces operate on NEAR and dive into some of the code that allows buying and selling NFTs. |

<!--
1. [Events](/tutorials/nfts/events): in this tutorial you'll explore the events extension, allowing the contract to react on certain events.
2. [Marketplace](/tutorials/nfts/marketplace): in the last tutorial you'll be exploring some key aspects of the marketplace contract.
-->

---

## Next steps

Ready to start? Jump to the [Pre-deployed Contract](/tutorials/nfts/predeployed-contract) tutorial and begin your learning journey!

If you already know about non-fungible tokens and smart contracts, feel free to skip and jump directly to the tutorial of your interest. The tutorials have been designed so you can start at any given point!
'''
'''--- docs/3.tutorials/nfts/0-predeployed.md ---
---
id: predeployed-contract
title: Pre-deployed Contract
sidebar_label: Pre-deployed Contract
---

Create your first non-fungible token by using a pre-deployed NFT smart contract which works exactly as the one you will build on this tutorial.

---

## Prerequisites

To complete this tutorial successfully, you'll need [a NEAR Wallet](https://testnet.mynearwallet.com/create) and [NEAR CLI](/tools/near-cli#setup)

:::tip
You can install near-cli through the following command:

```bash
npm install -g near-cli
```
:::

---

## Using the NFT contract

Minting an NFT token on NEAR is a simple process that involves calling a smart contract function.

To interact with the contract you will need to first login to your NEAR account through `near-cli`.

<hr class="subsection" />

### Setup

Log in to your newly created account with `near-cli` by running the following command in your terminal:

```bash
near login
```

Set an environment variable for your account ID to make it easy to copy and paste commands from this tutorial:

```bash
export NEARID=YOUR_ACCOUNT_NAME
```

<hr class="subsection" />

### Minting your NFTs

We have already deployed an NFT contract to `nft.examples.testnet` which allows users to freely mint tokens. Let's use it to mint our first token.

Run this command in your terminal, remember to replace the `token_id` with a string of your choice. This string will uniquely identify the token you mint. 

```bash
near call nft.examples.testnet nft_mint '{"token_id": "TYPE_A_UNIQUE_VALUE_HERE", "receiver_id": "'$NEARID'", "metadata": { "title": "GO TEAM", "description": "The Team Goes", "media": "https://bafybeidl4hjbpdr6u6xvlrizwxbrfcyqurzvcnn5xoilmcqbxfbdwrmp5m.ipfs.dweb.link/", "copies": 1}}' --accountId $NEARID --deposit 0.1
```

<details>
<summary>Example response: </summary>
<p>

```json
Log [nft.examples.testnet]: EVENT_JSON:{"standard":"nep171","version":"nft-1.0.0","event":"nft_mint","data":[{"owner_id":"benjiman.testnet","token_ids":["TYPE_A_UNIQUE_VALUE_HERE"]}]}
Transaction Id 8RFWrQvAsm2grEsd1UTASKpfvHKrjtBdEyXu7WqGBPUr
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/8RFWrQvAsm2grEsd1UTASKpfvHKrjtBdEyXu7WqGBPUr
''
```

</p>
</details>

:::tip
You can also replace the `media` URL with a link to any image file hosted on your web server.
:::

<hr class="subsection" />

### Querying your NFT

To view tokens owned by an account you can call the NFT contract with the following `near-cli` command:

```bash
near view nft.examples.testnet nft_tokens_for_owner '{"account_id": "'$NEARID'"}'
```

<details>
<summary>Example response: </summary>
<p>

```json
[
  {
    "token_id": "Goi0CZ",
    "owner_id": "bob.testnet",
    "metadata": {
      "title": "GO TEAM",
      "description": "The Team Goes",
      "media": "https://bafybeidl4hjbpdr6u6xvlrizwxbrfcyqurzvcnn5xoilmcqbxfbdwrmp5m.ipfs.dweb.link/",
      "media_hash": null,
      "copies": 1,
      "issued_at": null,
      "expires_at": null,
      "starts_at": null,
      "updated_at": null,
      "extra": null,
      "reference": null,
      "reference_hash": null
    },
    "approved_account_ids": {}
  }
]
```

</p>
</details>

**Congratulations!** You just minted your first NFT token on the NEAR blockchain! üéâ

Now try going to your [NEAR Wallet](https://testnet.mynearwallet.com) and view your NFT in the "Collectibles" tab.

---

## Final remarks

This basic example illustrates all the required steps to call an NFT smart contract on NEAR and start minting your own non-fungible tokens.

Now that you're familiar with the process, you can jump to [Contract Architecture](/tutorials/nfts/skeleton) and learn more about the smart contract structure and how you can build your own NFT contract from the ground up.

***Happy minting!*** ü™ô

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.1.0`

:::

'''
'''--- docs/3.tutorials/nfts/1-skeleton.md ---
---
id: skeleton
title: Skeleton and Rust Architecture
sidebar_label: Contract Architecture
---
import {Github} from "@site/src/components/codetabs"

In this article, you'll learn about the basic architecture behind the NFT contract that you'll develop while following this _"Zero to Hero"_ series.

You'll discover the contract's layout and you'll see how the Rust files are structured in order to build a feature-complete smart contract.

:::info Skeleton Contract
You can find the skeleton contract in our [GitHub repository](https://github.com/near-examples/nft-tutorial/tree/main/nft-contract-skeleton)
:::

:::info New to Rust?
If you are new to Rust and want to dive into smart contract development, our [Quick-start guide](../../2.build/2.smart-contracts/quickstart.md) is a great place to start.
:::

---

## Introduction

This tutorial presents the code skeleton for the NFT smart contract and its file structure.

Once every file and functions have been covered, we will guide you through the process of building the mock-up contract to confirm that your Rust setup works.

---

## File structure

Following a regular [Rust](https://www.rust-lang.org/) project, the file structure for this smart contract has:

```
nft-contract
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ approval.rs
    ‚îú‚îÄ‚îÄ enumeration.rs
    ‚îú‚îÄ‚îÄ lib.rs
    ‚îú‚îÄ‚îÄ metadata.rs
    ‚îú‚îÄ‚îÄ mint.rs
    ‚îú‚îÄ‚îÄ nft_core.rs
    ‚îú‚îÄ‚îÄ events.rs
    ‚îî‚îÄ‚îÄ royalty.rs
```

- The file `Cargo.toml` defines the code dependencies
- The `src` folder contains all the Rust source files

<hr class="subsection" />

### Source files

Here is a brief description of what each source file is responsible for:

| File                             | Description                                                                     |
|----------------------------------|---------------------------------------------------------------------------------|
| [approval.rs](#approvalrs)       | Has the functions that controls the access and transfers of non-fungible tokens |
| [enumeration.rs](#enumerationrs) | Contains the methods to list NFT tokens and their owners                        |
| [lib.rs](#librs)                 | Holds the smart contract initialization functions                               |
| [metadata.rs](#metadatars)       | Defines the token and metadata structure                                        |
| [mint.rs](#mintrs)               | Contains token minting logic                                                    |
| [nft_core.rs](#nft_corers)       | Core logic that allows you to transfer NFTs between users.                      |
| [royalty.rs](#royaltyrs)         | Contains payout-related functions                                               |
| [events.rs](#events)             | Contains events related structures                                              |

:::tip
Explore the code in our [GitHub repository](https://github.com/near-examples/nft-tutorial/).
:::

---

## `approval.rs`

> This allows people to approve other accounts to transfer NFTs on their behalf.

This file contains the logic that complies with the standard's [approvals management](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement) extension. Here is a breakdown of the methods and their functions:

| Method              | Description                                                                                               |
|---------------------|-----------------------------------------------------------------------------------------------------------|
| **nft_approve**     | Approves an account ID to transfer a token on your behalf.                                                |
| **nft_is_approved** | Checks if the input account has access to approve the token ID.                                           |
| **nft_revoke**      | Revokes a specific account from transferring the token on your behalf.                                    |
| **nft_revoke_all**  | Revokes all accounts from transferring the token on your behalf.                                          |
| **nft_on_approve**  | This callback function, initiated during `nft_approve`, is a cross contract call to an external contract. |

<Github language="rust" start="4" end="33" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/approval.rs" />

You'll learn more about these functions in the [approvals section](/tutorials/nfts/approvals) of the Zero to Hero series.

---

## `enumeration.rs`

> This file provides the functions needed to view information about NFTs, and follows the standard's [enumeration](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration) extension.

| Method                   | Description                                                                        |
|--------------------------|------------------------------------------------------------------------------------|
| **nft_total_supply**     | Returns the total amount of NFTs stored on the contract                           |
| **nft_tokens**           | Returns a paginated list of NFTs stored on the contract regardless of their owner. |
| **nft_supply_for_owner** | Allows you view the total number of NFTs owned by any given user                  |
| **nft_tokens_for_owner** | Returns a paginated list of NFTs owned by any given user                          |

<Github language="rust" start="4" end="44" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-skeleton/src/enumeration.rs" />

You'll learn more about these functions in the [enumeration section](/tutorials/nfts/enumeration) of the tutorial series.

---

## `lib.rs`

> This file outlines what information the contract stores and keeps track of.

| Method               | Description                                                                                     |
|----------------------|-------------------------------------------------------------------------------------------------|
| **new_default_meta** | Initializes the contract with default `metadata` so the user doesn't have to provide any input. |
| **new**              | Initializes the contract with the user-provided `metadata`.                                     |

:::info Keep in mind
The initialization functions (`new`, `new_default_meta`) can only be called once.
:::

<Github language="rust" start="47" end="73" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-skeleton/src/lib.rs" />

You'll learn more about these functions in the [minting section](/tutorials/nfts/minting) of the tutorial series.

---

## `metadata.rs`

> This file is used to keep track of the information to be stored for tokens, and metadata.
> In addition, you can define a function to view the contract's metadata which is part of the standard's [metadata](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata) extension.

| Name              | Description                                                                                                   |
|-------------------|---------------------------------------------------------------------------------------------------------------|
| **TokenMetadata** | This structure defines the metadata that can be stored for each token (title, description, media, etc.).      |
| **Token**         | This structure outlines what information will be stored on the contract for each token.                       |
| **JsonToken**     | When querying information about NFTs through view calls, the return information is stored in this JSON token. |
| **nft_metadata**  | This function allows users to query for the contact's internal metadata.                                      |

<Github language="rust" start="12" end="60" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-skeleton/src/metadata.rs" />

You'll learn more about these functions in the [minting section](/tutorials/nfts/minting) of the tutorial series.

---

## `mint.rs`

> Contains the logic to mint the non-fungible tokens

| Method       | Description                               |
|--------------|-------------------------------------------|
| **nft_mint** | This function mints a non-fungible token. |

<Github language="rust" start="4" end="16" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-skeleton/src/mint.rs" />

---

## `nft_core.rs`

> Core logic that allows to transfer NFTs between users.

| Method                   | Description                                                                                                                                                                                                                                                                                   |
|--------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **nft_transfer**         | Transfers an NFT to a receiver ID.                                                                                                                                                                                                                                                            |
| **nft_transfer_call**    | Transfers an NFT to a receiver and calls a function on the receiver ID's contract. The function returns `true` if the token was transferred from the sender's account.                                                                                                                        |
| **nft_token**            | Allows users to query for the information about a specific NFT.                                                                                                                                                                                                                               |
| **nft_on_transfer**      | Called by other contracts when an NFT is transferred to your contract account via the `nft_transfer_call` method. It returns `true` if the token should be returned back to the sender.                                                                                                       |
| **nft_resolve_transfer** | When you start the `nft_transfer_call` and transfer an NFT, the standard also calls a method on the receiver's contract. If the receiver needs you to return the NFT to the sender (as per the return value of the `nft_on_transfer` method), this function allows you to execute that logic. |

<Github language="rust" start="7" end="56" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-skeleton/src/nft_core.rs" />

You'll learn more about these functions in the [core section](/tutorials/nfts/core) of the tutorial series.

---

## `royalty.rs`

> Contains payout-related functions.

| Method                  | Description                                                                                                   |
|-------------------------|---------------------------------------------------------------------------------------------------------------|
| **nft_payout**          | This view method calculates the payout for a given token.                                                     |
| **nft_transfer_payout** | Transfers the token to the receiver ID and returns the payout object that should be paid for a given balance. |

<Github language="rust" start="3" end="17" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-skeleton/src/royalty.rs" />

You'll learn more about these functions in the [royalty section](/tutorials/nfts/royalty) of the tutorial series.

---

## `events.rs`

> Contains events-related structures.

| Method              | Description                                         |
|---------------------|-----------------------------------------------------|
| **EventLogVariant** | This enum represents the data type of the EventLog. |
| **EventLog**        | Interface to capture data about an event.           |
| **NftMintLog**      | An event log to capture token minting.              |
| **NftTransferLog**  | An event log to capture token transfer.             |

<Github language="rust" start="5" end="79" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-events/src/events.rs" />

You'll learn more about these functions in the [events section](/tutorials/nfts/events) of the tutorial series.

---

## Building the skeleton

If you haven't cloned the main repository yet, open a terminal and run:

```sh
git clone https://github.com/near-examples/nft-tutorial/
```

Next, go to the `nft-contract-skeleton/` folder and build the contract with `cargo-near`:

```sh
cd nft-tutorial
cd nft-contract-skeleton/
cargo near build
```

Since this source is just a skeleton you'll get many warnings about unused code, such as:

```
   Compiling nft_contract_skeleton v0.1.0 (/Users/near-examples/Documents/my/projects/near/examples/nft-tutorial/nft-contract-basic)
 ‚îÇ warning: unused imports: `LazyOption`, `LookupMap`, `UnorderedMap`, `UnorderedSet`
 ‚îÇ  --> src/lib.rs:3:29
 ‚îÇ   |
 ‚îÇ 3 | use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap, UnorderedSet};
 ‚îÇ   |                             ^^^^^^^^^^  ^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^^
 ‚îÇ   |
 ‚îÇ   = note: `#[warn(unused_imports)]` on by default
 ‚îÇ 
 ‚îÇ warning: unused import: `Base64VecU8`
 ‚îÇ  --> src/lib.rs:4:28
 ‚îÇ   |
 ‚îÇ 4 | use near_sdk::json_types::{Base64VecU8, U128};
 ‚îÇ   |   

 ‚îÇ warning: `nft_contract_skeleton` (lib) generated 48 warnings (run `cargo fix --lib -p nft_contract_skeleton` to apply 45 suggestions)
 ‚îÇ     Finished release [optimized] target(s) in 11.01s
 ‚úì Contract successfully built!
```

Don't worry about these warnings, you're not going to deploy this contract yet.
Building the skeleton is useful to validate that your Rust toolchain works properly and that you'll be able to compile improved versions of this NFT contract in the upcoming tutorials.

---

## Conclusion

You've seen the layout of this NFT smart contract, and how all the functions are laid out across the different source files.
Using `yarn`, you've been able to compile the contract, and you'll start fleshing out this skeleton in the next [Minting tutorial](/tutorials/nfts/minting).

:::note Versioning for this article
At the time of this writing, this example works with the following versions:

- rustc: `1.76.0`
- near-sdk-rs: `5.1.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.1.0`

:::

'''
'''--- docs/3.tutorials/nfts/2-minting.md ---
---
id: minting
title: Minting
sidebar_label: Minting
---
import {Github} from "@site/src/components/codetabs"

This is the first of many tutorials in a series where you'll be creating a complete NFT smart contract from scratch that conforms with all the NEAR [NFT standards](https://nomicon.io/Standards/NonFungibleToken/).

Today you'll learn how to create the logic needed to mint NFTs and have them show up in your NEAR wallet. You will be filling a bare-bones [skeleton smart contract](/tutorials/nfts/skeleton) to add minting functionalities.

:::info Contracts
You can find the skeleton contract in our [Skeleton folder](https://github.com/near-examples/nft-tutorial/tree/main/nft-contract-skeleton)

A completed version of this tutorial can be found in the [Basic NFT folder](https://github.com/near-examples/nft-tutorial/tree/main/nft-contract-basic)
:::

---

## Introduction

To get started, go to the `nft-contract-skeleton` folder in our repo. If you haven't cloned the repository, refer to the [Contract Architecture](/tutorials/nfts/skeleton) to get started.

```
cd nft-contract-skeleton/
```

If you wish to see the finished code of this step-by-step basic NFT contract tutorial, that can be found on the `nft-contract-basic` folder.

---

## Modifications to the skeleton contract {#what-does-minting-mean}

In order to implement the logic needed for minting, we should break it up into smaller tasks and handle those one-by-one. Let's step back and think about the best way to do this by asking ourselves a simple question: what does it mean to mint an NFT?

To mint a non-fungible token, in the most simple way possible, a contract needs to be able to associate a token with an owner on the blockchain. This means you'll need:

- A way to keep track of tokens and other information on the contract.
- A way to store information for each token such as `metadata` (more on that later).
- A way to link a token with an owner.

That's it! We've now broken down the larger problem into some smaller, less daunting, subtasks. Let's start by tackling the first and work our way through the rest.

<hr class="subsection" />

### Storing information on the contract {#storing-information}

Start by navigating to `nft-contract-skeleton/src/lib.rs` and filling in some of the code blocks.
You need to be able to store important information on the contract such as the list of tokens that an account has.

#### Contract Struct

The first thing to do is modifying the contract `struct` as follows:
<Github language="rust" start="35" end="52" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/lib.rs" />

This allows you to get the information stored in these data structures from anywhere in the contract. The code above has created 3 token specific storages:

- **tokens_per_owner**: allows you to keep track of the tokens owned by any account
- **tokens_by_id**: returns all the information about a specific token
- **token_metadata_by_id**: returns just the metadata for a specific token

In addition, you'll keep track of the owner of the contract as well as the metadata for the contract.

You might be confused as to some of the types that are being used. In order to make the code more readable, we've introduced custom data types which we'll briefly outline below:

- **AccountId**: a string that ensures there are no special or unsupported characters.
- **TokenId**: simply a string.

As for the `Token`, `TokenMetadata`, and `NFTContractMetadata` data types, those are structs that we'll define later in this tutorial.

#### Initialization Functions

Next, create what's called an initialization function; we will name it `new`, but you can choose any name you prefer.

This function needs to be invoked when you first deploy the contract. It will initialize all the contract's fields that you've defined above with default values.
Don't forget to add the `owner_id` and `metadata` fields as parameters to the function, so only those can be customized.

This function will default all the collections to be empty and set the `owner` and `metadata` equal to what you pass in.

<Github language="rust" start="96" end="114" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/lib.rs" />

More often than not when doing development, you'll need to deploy contracts several times. You can imagine that it might get tedious to have to pass in metadata every single time you want to initialize the contract. For this reason, let's create a function that can initialize the contract with a set of default `metadata`. You can call it `new_default_meta` and it'll only take the `owner_id` as a parameter.

<Github language="rust" start="74" end="89" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/lib.rs" />

This function is simply calling the previous `new` function and passing in the owner that you specify and also passes in some default metadata.

<hr class="subsection" />

### Metadata and token information {#metadata-and-token-info}

Now that you've defined what information to store on the contract itself and you've defined some ways to initialize the contract, you need to define what information should go in the `Token`, `TokenMetadata`, and `NFTContractMetadata` data types.

Let's switch over to the `nft-contract-skeleton/src/metadata.rs` file as this is where that information will go.

If you look at the [standards for metadata](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata), you'll find all the necessary information that you need to store for both `TokenMetadata` and `NFTContractMetadata`. Simply fill in the following code.

<Github language="rust" start="10" end="39" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/metadata.rs" />

This now leaves you with the `Token` struct and something called a `JsonToken`. The `Token` struct will hold all the information directly related to the token excluding the metadata. The metadata, if you remember, is stored in a map on the contract in a data structure called `token_metadata_by_id`. This allows you to quickly get the metadata for any token by simply passing in the token's ID.

For the `Token` struct, you'll just keep track of the owner for now.

<Github language="rust" start="41" end="46" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/metadata.rs" />

Since NEAR smart contracts receive and return data in JSON format, the purpose of the `JsonToken` is to act as output when the user asks information for an NFT. This means you'll want to store the owner, token ID, and metadata.

<Github language="rust" start="49" end="58" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/metadata.rs" />

:::tip
Some of you might be thinking _"how come we don't just store all the information in the `Token` struct?"_.
The reason behind this is that it's actually more efficient to construct the JSON token on the fly only when you need it rather than storing all the information in the token struct.
In addition, some operations might only need the metadata for a token and so having the metadata in a separate data structure is more optimal.
:::

#### Function for querying contract metadata

Now that you've defined some of the types that were used in the previous section, let's move on and create the first view function `nft_metadata`. This will allow users to query for the contract's metadata as per the [metadata standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata).

<Github language="rust" start="60" end="70" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/metadata.rs" />

This function will get the `metadata` object from the contract which is of type `NFTContractMetadata` and will return it.

Just like that, you've completed the first two tasks and are ready to move onto last part of the tutorial.

<hr class="subsection" />

### Minting Logic {#minting-logic}

Now that all the information and types are defined, let's start brainstorming how the minting logic will play out. In the end, you need to link a `Token` and `TokenId` to a specific owner. Let's look back at the `lib.rs` file to see how you can accomplish this. There are a couple data structures that might be useful:

```rust
//keeps track of all the token IDs for a given account
pub tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,

//keeps track of the token struct for a given token ID
pub tokens_by_id: LookupMap<TokenId, Token>,

//keeps track of the token metadata for a given token ID
pub token_metadata_by_id: UnorderedMap<TokenId, TokenMetadata>,
```

Looking at these data structures, you could do the following:

- Add the token ID into the set of tokens that the receiver owns. This will be done on the `tokens_per_owner` field.
- Create a token object and map the token ID to that token object in the `tokens_by_id` field.
- Map the token ID to it's metadata using the `token_metadata_by_id`.

#### Storage Implications {#storage-implications}
With those steps outlined, it's important to take into consideration the storage costs of minting NFTs. Since you're adding bytes to the contract by creating entries in the data structures, the contract needs to cover the storage costs. If you just made it so any user could go and mint an NFT for free, that system could easily be abused and users could essentially "drain" the contract of all it's funds by minting thousands of NFTs. For this reason, you'll make it so that users need to attach a deposit to the call to cover the cost of storage. You'll measure the initial storage usage before anything was added and you'll measure the final storage usage after all the logic is finished. Then you'll make sure that the user has attached enough $NEAR to cover that cost and refund them if they've attached too much.

This is how we do it in code:

<Github language="rust" start="3" end="45" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/mint.rs" />

You'll notice that we're using some internal methods such as `refund_deposit` and `internal_add_token_to_owner`. We've described the function of `refund_deposit` and as for `internal_add_token_to_owner`, this will add a token to the set of tokens an account owns for the contract's `tokens_per_owner` data structure. You can create these functions in a file called `internal.rs`. Go ahead and create the file. Your new contract architecture should look as follows:

```
nft-contract
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ build.sh
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ approval.rs
    ‚îú‚îÄ‚îÄ enumeration.rs
    ‚îú‚îÄ‚îÄ internal.rs
    ‚îú‚îÄ‚îÄ lib.rs
    ‚îú‚îÄ‚îÄ metadata.rs
    ‚îú‚îÄ‚îÄ mint.rs
    ‚îú‚îÄ‚îÄ nft_core.rs
    ‚îú‚îÄ‚îÄ events.rs
    ‚îî‚îÄ‚îÄ royalty.rs
```

Add the following to your newly created `internal.rs` file.

<Github language="rust" start="1" end="133" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/internal.rs" />

:::note
You may notice more functions in the `internal.rs` file than we need for now. You may ignore them, we'll come back to them later.
:::

Let's now quickly move to the `lib.rs` file and make the functions we just created invokable in other files. We'll add the internal crates and mod the file as shown below:

<Github language="rust" start="10" end="23" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/lib.rs" />

At this point, the core logic is all in place so that you can mint NFTs. You can use the function `nft_mint` which takes the following parameters:

- **token_id**: the ID of the token you're minting (as a string).
- **metadata**: the metadata for the token that you're minting (of type `TokenMetadata` which is found in the `metadata.rs` file).
- **receiver_id**: specifies who the owner of the token will be.

Behind the scenes, the function will:

1. Calculate the initial storage before adding anything to the contract
2. Create a `Token` object with the owner ID
3. Link the token ID to the newly created token object by inserting them into the `tokens_by_id` field.
4. Link the token ID to the passed in metadata by inserting them into the `token_metadata_by_id` field.
5. Add the token ID to the list of tokens that the owner owns by calling the `internal_add_token_to_owner` function.
6. Calculate the final and net storage to make sure that the user has attached enough NEAR to the call in order to cover those costs.

<hr class="subsection" />

### Querying for token information

If you were to go ahead and deploy this contract, initialize it, and mint an NFT, you would have no way of knowing or querying for the information about the token you just minted. Let's quickly add a way to query for the information of a specific NFT. You'll move to the `nft-contract-skeleton/src/nft_core.rs` file and edit the `nft_token` function.

It will take a token ID as a parameter and return the information for that token. The `JsonToken` contains the token ID, the owner ID, and the token's metadata.

<Github language="rust" start="129" end="143" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/nft_core.rs" />

With that finished, it's finally time to build and deploy the contract so you can mint your first NFT.

---

## Interacting with the contract on-chain

Now that the logic for minting is complete and you've added a way to query for information about specific tokens, it's time to build and deploy your contract to the blockchain.

### Deploying the contract {#deploy-the-contract}

For deployment, you will need a NEAR account with the keys stored on your local machine. Navigate to the [NEAR wallet](https://testnet.mynearwallet.com//) site and create an account.

:::info
Please ensure that you deploy the contract to an account with no pre-existing contracts. It's easiest to simply create a new account or create a sub-account for this tutorial.
:::

Log in to your newly created account with `near-cli` by running the following command in your terminal.

```bash
near login
```

To make this tutorial easier to copy/paste, we're going to set an environment variable for your account ID. In the command below, replace `YOUR_ACCOUNT_NAME` with the account name you just logged in with including the `.testnet` portion:

```bash
export NFT_CONTRACT_ID="YOUR_ACCOUNT_NAME"
```

Test that the environment variable is set correctly by running:

```bash
echo $NFT_CONTRACT_ID
```

Verify that the correct account ID is printed in the terminal. If everything looks correct you can now deploy your contract.
In the root of your NFT project run the following command to deploy your smart contract and answer questions:

```bash
cargo near deploy $NFT_CONTRACT_ID

> Select the need for initialization: with-init-call     - Add an initialize
> What is the name of the function? new_default_meta
> How would you like to pass the function arguments? json-args
> Enter the arguments to this function: {"owner_id": "<YOUR_NFT_CONTRACT_ID>"}
> Enter gas for function call: 100 TeraGas
> Enter deposit for a function call (example: 10NEAR or 0.5near or 10000yoctonear): 0 NEAR
> What is the name of the network? testnet
> Select a tool for signing the transaction: sign-with-keychain
> How would you like to proceed? send
```

You don't need to answer these questions every time. If you look at the results you will find the message `Here is the console command if you ever need to re-run it again`. The next line is the command which you may use instead of answering to interactive questions:

```bash
cargo near deploy $NFT_CONTRACT_ID with-init-call new_default_meta json-args '{"owner_id": "'$NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

You've just deployed and initialized the contract with some default metadata and set your account ID as the owner. At this point, you're ready to call your first view function.

<hr class="subsection" />

### Viewing the contract's metadata

Now that the contract has been initialized, you can call some of the functions you wrote earlier. More specifically, let's test out the function that returns the contract's metadata:

```bash
near view $NFT_CONTRACT_ID nft_metadata
```

This should return an output similar to the following:

```bash
{
  spec: 'nft-1.0.0',
  name: 'NFT Tutorial Contract',
  symbol: 'GOTEAM',
  icon: null,
  base_uri: null,
  reference: null,
  reference_hash: null
}
```

At this point, you're ready to move on and mint your first NFT.

<hr class="subsection" />

### Minting our first NFT {#minting-our-first-nft}

Let's now call the minting function that you've created. This requires a `token_id` and `metadata`. If you look back at the `TokenMetadata` struct you created earlier, there are many fields that could potentially be stored on-chain:

<Github language="rust" start="23" end="39" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/metadata.rs" />

Let's mint an NFT with a title, description, and media to start. The media field can be any URL pointing to a media file. We've got an excellent GIF to mint but if you'd like to mint a custom NFT, simply replace our media link with one of your choosing. If you run the following command, it will mint an NFT with the following parameters:

- **token_id**: "token-1"
- **metadata**:
  - _title_: "My Non Fungible Team Token"
  - _description_: "The Team Most Certainly Goes :)"
  - _media_: `https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif`
  - **receiver_id**: "'$NFT_CONTRACT_ID'"

```bash
near call $NFT_CONTRACT_ID nft_mint '{"token_id": "token-1", "metadata": {"title": "My Non Fungible Team Token", "description": "The Team Most Certainly Goes :)", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$NFT_CONTRACT_ID'"}' --accountId $NFT_CONTRACT_ID --amount 0.1
```

:::info
The `amount` flag is specifying how much NEAR to attach to the call. Since you need to pay for storage, 0.1 NEAR is attached and you'll get refunded any excess that is unused at the end.
:::

<hr class="subsection" />

### Viewing information about the NFT

Now that the NFT has been minted, you can check and see if everything went correctly by calling the `nft_token` function.
This should return a `JsonToken` which should contain the `token_id`, `owner_id`, and `metadata`.

```bash
near view $NFT_CONTRACT_ID nft_token '{"token_id": "token-1"}'
```

<details>
<summary>Example response: </summary>
<p>

```bash
{
  token_id: 'token-1',
  owner_id: 'goteam.examples.testnet',
  metadata: {
    title: 'My Non Fungible Team Token',
    description: 'The Team Most Certainly Goes :)',
    media: 'https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif',
    media_hash: null,
    copies: null,
    issued_at: null,
    expires_at: null,
    starts_at: null,
    updated_at: null,
    extra: null,
    reference: null,
    reference_hash: null
  }
}
```

</p>
</details>

**Go team!** You've now verified that everything works correctly and it's time to view your freshly minted NFT in the NEAR wallet's collectibles tab!

---

## Viewing your NFTs in the wallet

If you navigate to the [collectibles tab](https://testnet.mynearwallet.com//?tab=collectibles) in the NEAR wallet, this should list all the NFTs that you own. It should look something like the what's below.

![empty-nft-in-wallet](/docs/assets/nfts/empty-nft-in-wallet.png)

We've got a problem. The wallet correctly picked up that you minted an NFT, however, the contract doesn't implement the specific view function that is being called. Behind the scenes, the wallet is trying to call `nft_tokens_for_owner` to get a list of all the NFTs owned by your account on the contract. The only function you've created, however, is the `nft_token` function. It wouldn't be very efficient for the wallet to call `nft_token` for every single NFT that a user has to get information and so they try to call the `nft_tokens_for_owner` function.

In the next tutorial, you'll learn about how to deploy a patch fix to a pre-existing contract so that you can view the NFT in the wallet.

---

## Conclusion

In this tutorial, you went through the basics of setting up and understand the logic behind minting NFTs on the blockchain using a skeleton contract.

You first looked at [what it means](#what-does-minting-mean) to mint NFTs and how to break down the problem into more feasible chunks. You then started modifying the skeleton contract chunk by chunk starting with solving the problem of [storing information / state](#storing-information) on the contract. You then looked at what to put in the [metadata and token information](#metadata-and-token-info). Finally, you looked at the logic necessary for [minting NFTs](#minting-logic).

After the contract was written, it was time to deploy to the blockchain. You [deployed the contract](#deploy-the-contract) and [initialized it](#initialize-contract). Finally, you [minted your very first NFT](#minting-our-first-nft) and saw that some changes are needed before you can view it in the wallet.

---

## Next Steps

In the [next tutorial](/tutorials/nfts/upgrade-contract), you'll find out how to deploy a patch fix and what that means so that you can view your NFTs in the wallet.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- cargo-near `0.6.1`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.1.0`
- Metadata standard: [NEP177](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata), version `2.1.0`

:::

'''
'''--- docs/3.tutorials/nfts/2-upgrade.md ---
---
id: upgrade-contract
title: Upgrading the Contract
sidebar_label: Upgrade a Contract
---
import {Github} from "@site/src/components/codetabs"

In this tutorial, you'll build off the work you previously did to implement the [minting functionality](/tutorials/nfts/minting) on a skeleton smart contract. You got to the point where NFTs could be minted and the wallet correctly picked up on the fact that you owned an NFT. However, it had no way of displaying the tokens since your contract didn't implement the method that the wallet was trying to call.

---

## Introduction

Today you'll learn about deploying patch fixes to smart contracts and you'll use that knowledge to implement the `nft_tokens_for_owner` function on the contract you deployed in the previous tutorial.

---

## Upgrading contracts overview {#upgrading-contracts}

Upgrading contracts, when done right, can be an immensely powerful tool. If done wrong, it can lead to a lot of headaches. It's important to distinguish between the code and state of a smart contract. When a contract is deployed on top of an existing contract, the only thing that changes is the code. The state will remain the same and that's where a lot of developer's issues come to fruition.

The NEAR Runtime will read the serialized state from disk and it will attempt to load it using the current contract code. When your code changes, it might not be able to figure out how to do this.

You need to strategically upgrade your contracts and make sure that the runtime will be able to read your current state with the new contract code. For more information about upgrading contracts and some best practices, see the NEAR SDK's [upgrading contracts](/sdk/rust/building/prototyping) write-up.

---

## Modifications to our contract {#modifications-to-contract}

In order for the wallet to properly display your NFTs, you need to implement the `nft_tokens_for_owner` method. This will allow anyone to query for a paginated list of NFTs owned by a given account ID.

To accomplish this, let's break it down into some smaller subtasks. First, you need to get access to a list of all token IDs owned by a user. This information can be found in the `tokens_per_owner` data structure. Now that you have a set of token IDs, you need to convert them into `JsonToken` objects as that's what you'll be returning from the function.

Luckily, you wrote a function `nft_token` which takes a token ID and returns a `JsonToken` in the `nft_core.rs` file. As you can guess, in order to get a list of `JsonToken` objects, you would need to iterate through the token IDs owned by the user and then convert each token ID into a `JsonToken` and store that in a list.

As for the pagination, Rust has some awesome functions for skipping to a starting index and taking the first `n` elements of an iterator.

Let's move over to the `enumeration.rs` file and implement that logic:

<Github language="rust" start="46" end="75" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/enumeration.rs" />

---

## Redeploying the contract {#redeploying-contract}

Now that you've implemented the necessary logic for `nft_tokens_for_owner`, it's time to build and re-deploy the contract to your account. Using the cargo-near, deploy the contract as you did in the previous tutorial:

```bash
cargo near deploy $NFT_CONTRACT_ID without-init-call network-config testnet sign-with-keychain send
```

Once the contract has been redeployed, let's test and see if the state migrated correctly by running a simple view function:

```bash
near view $NFT_CONTRACT_ID nft_metadata
```

This should return an output similar to the following:

```bash
{
  spec: 'nft-1.0.0',
  name: 'NFT Tutorial Contract',
  symbol: 'GOTEAM',
  icon: null,
  base_uri: null,
  reference: null,
  reference_hash: null
}
```

**Go team!** At this point, you can now test and see if the new function you wrote works correctly. Let's query for the list of tokens that you own:

```bash
near view $NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$NFT_CONTRACT_ID'", "limit": 5}'
```

<details>
<summary>Example response: </summary>
<p>

```bash
[
  {
    token_id: 'token-1',
    owner_id: 'goteam.examples.testnet',
    metadata: {
      title: 'My Non Fungible Team Token',
      description: 'The Team Most Certainly Goes :)',
      media: 'https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif',
      media_hash: null,
      copies: null,
      issued_at: null,
      expires_at: null,
      starts_at: null,
      updated_at: null,
      extra: null,
      reference: null,
      reference_hash: null
    }
  }
]
```

</p>
</details>

---

## Viewing NFTs in the wallet {#viewing-nfts-in-wallet}

Now that your contract implements the necessary functions that the wallet uses to display NFTs, you should be able to see your tokens on display in the [collectibles tab](https://testnet.mynearwallet.com//?tab=collectibles).

![filled-nft-in-wallet](/docs/assets/nfts/filled-nft-in-wallet.png)

---

## Conclusion

In this tutorial, you learned about the basics of [upgrading contracts](#upgrading-contracts). Then, you implemented the necessary [modifications to your smart contract](#modifications-to-contract) and [redeployed it](#redeploying-contract). Finally you navigated to the wallet collectibles tab and [viewed your NFTs](#viewing-nfts-in-wallet).

In the [next tutorial](/tutorials/nfts/enumeration), you'll implement the remaining functions needed to complete the [enumeration](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration) standard.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- cargo-near `0.6.1`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.1.0`

:::

'''
'''--- docs/3.tutorials/nfts/3-enumeration.md ---
---
id: enumeration
title: Enumeration
sidebar_label: Enumeration
---
import {Github} from "@site/src/components/codetabs"

In the previous tutorials, you looked at ways to integrate the minting functionality into a skeleton smart contract. In order to get your NFTs to show in the wallet, you also had to deploy a patch fix that implemented one of the enumeration methods. In this tutorial, you'll expand on and finish the rest of the enumeration methods as per the [standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration)

Now you'll extend the NFT smart contract and add a couple of enumeration methods that can be used to return the contract's state.

---

## Introduction

As mentioned in the [Upgrade a Contract](/tutorials/nfts/upgrade-contract/) tutorial, you can deploy patches and fixes to smart contracts. This time, you'll use that knowledge to implement the `nft_total_supply`, `nft_tokens` and `nft_supply_for_owner` enumeration functions.

---

## Modifications to the contract

Let's start by opening the  `src/enumeration.rs` file and locating the empty `nft_total_supply` function. 

**nft_total_supply**

This function should return the total number of NFTs stored on the contract. You can easily achieve this functionality by simply returning the length of the `nft_metadata_by_id` data structure.

<Github language="rust" start="5" end="9" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/enumeration.rs" />

**nft_token**

This function should return a paginated list of `JsonTokens` that are stored on the contract regardless of their owners.
If the user provides a `from_index` parameter, you should use that as the starting point for which to start iterating through tokens; otherwise it should start from the beginning. Likewise, if the user provides a `limit` parameter, the function shall stop after reaching either the limit or the end of the list.

:::tip
Rust has useful methods for pagination, allowing you to skip to a starting index and taking the first `n` elements of an iterator.
:::

<Github language="rust" start="11" end="26" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/enumeration.rs" />

**nft_supply_for_owner**

This function should look for all the non-fungible tokens for a user-defined owner, and return the length of the resulting set.
If there isn't a set of tokens for the provided `AccountID`, then the function shall return `0`.

<Github language="rust" start="28" end="43" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/enumeration.rs" />

Next, you can use the CLI to query these new methods and validate that they work correctly.

---

## Redeploying the contract {#redeploying-contract}

Now that you've implemented the necessary logic for `nft_tokens_for_owner`, it's time to build and re-deploy the contract to your account. Using the cargo-near, deploy the contract as you did in the previous tutorials:

```bash
cargo near deploy $NFT_CONTRACT_ID without-init-call network-config testnet sign-with-keychain send
```

---

## Enumerating tokens

Once the updated contract has been redeployed, you can test and see if these new functions work as expected.

### NFT tokens

Let's query for a list of non-fungible tokens on the contract. Use the following command to query for the information of up to 50 NFTs starting from the 10th item:

```bash
near view $NFT_CONTRACT_ID nft_tokens '{"from_index": "10", "limit": 50}'
```

This command should return an output similar to the following:

<details>
<summary>Example response: </summary>
<p>

```json
[]
```

</p>
</details>

<hr class="subsection" />

### Tokens by owner

To get the total supply of NFTs owned by the `goteam.testnet` account, call the `nft_supply_for_owner` function and set the `account_id` parameter:

```bash
near view $NFT_CONTRACT_ID nft_supply_for_owner '{"account_id": "goteam.testnet"}'
```

This should return an output similar to the following:

<details>
<summary>Example response: </summary>
<p>

```json
0
```

</p>
</details>

---

## Conclusion

In this tutorial, you have added two [new enumeration functions](/tutorials/nfts/enumeration#modifications-to-the-contract), and now you have a basic NFT smart contract with minting and enumeration methods in place. After implementing these modifications, you redeployed the smart contract and tested the functions using the CLI.

In the [next tutorial](/tutorials/nfts/core), you'll implement the core functions needed to allow users to transfer the minted tokens.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- cargo-near `0.6.1`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.1.0`
- Enumeration standard: [NEP181](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration), version `1.0.0`

:::

'''
'''--- docs/3.tutorials/nfts/4-core.md ---
---
id: core
title: Transfers
---
import {Github} from "@site/src/components/codetabs"

In this tutorial you'll learn how to implement NFT transfers as defined in the [core standards](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core) into your smart contract.

We will define two methods for transferring NFTs:
- `nft_transfer`: that transfers ownership of an NFT from one account to another
- `nft_transfer_call`: that transfers an NFT to a "receiver" and calls a method on the receiver's account

:::tip Why two transfer methods?

`nft_transfer` is a simple transfer between two user, while `nft_transfer_call` allows you to **attach an NFT to a function call**

:::

---

## Introduction {#introduction}

Up until this point, you've created a simple NFT smart contract that allows users to mint tokens and view information using the [enumeration standards](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration). Today, you'll expand your smart contract to allow for users to not only mint tokens, but transfer them as well.

As we did in the [minting tutorial](/tutorials/nfts/minting), let's break down the problem into multiple subtasks to make our lives easier. When a token is minted, information is stored in 3 places:

- **tokens_per_owner**: set of tokens for each account.
- **tokens_by_id**: maps a token ID to a `Token` object.
- **token_metadata_by_id**: maps a token ID to its metadata.

Let's now consider the following scenario. If Benji owns token A and wants to transfer it to Mike as a birthday gift, what should happen? First of all, token A should be removed from Benji's set of tokens and added to Mike's set of tokens.

If that's the only logic you implement, you'll run into some problems. If you were to do a `view` call to query for information about that token after it's been transferred to Mike, it would still say that Benji is the owner.

This is because the contract is still mapping the token ID to the old `Token` object that contains the `owner_id` field set to Benji's account ID. You still have to change the `tokens_by_id` data structure so that the token ID maps to a new `Token` object which has Mike as the owner.

With that being said, the final process for when an owner transfers a token to a receiver should be the following:

- Remove the token from the owner's set.
- Add the token to the receiver's set.
- Map a token ID to a new `Token` object containing the correct owner.

:::note
You might be curious as to why we don't edit the `token_metadata_by_id` field. This is because no matter who owns the token, the token ID will always map to the same metadata. The metadata should never change and so we can just leave it alone.
:::

At this point, you're ready to move on and make the necessary modifications to your smart contract.

---

## Modifications to the contract

Let's start our journey in the `nft-contract-skeleton/src/nft_core.rs` file.

### Transfer function {#transfer-function}

You'll start by implementing the `nft_transfer` logic. This function will transfer the specified `token_id` to the `receiver_id` with an optional `memo` such as `"Happy Birthday Mike!"`.

<Github language="rust" start="60" end="80" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/nft_core.rs" />

There are a couple things to notice here. Firstly, we've introduced a new function called `assert_one_yocto()`, which ensures the user has attached exactly one yoctoNEAR to the call. This is a [security measure](../../2.build/2.smart-contracts/security/one_yocto.md) to ensure that the user is signing the transaction with a [full access key](../../1.concepts/protocol/access-keys.md).

Since the transfer function is potentially transferring very valuable assets, you'll want to make sure that whoever is calling the function has a full access key.

Secondly, we've introduced an `internal_transfer` method. This will perform all the logic necessary to transfer an NFT.

<hr class="subsection" />

### Internal helper functions

Let's quickly move over to the `nft-contract/src/internal.rs` file so that you can implement the `assert_one_yocto()` and `internal_transfer` methods.

Let's start with the easier one, `assert_one_yocto()`.

#### assert_one_yocto

<Github language="rust" start="14" end="21" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/internal.rs" />

#### internal_transfer

It's now time to explore the `internal_transfer` function which is the core of this tutorial. This function takes the following parameters:

- **sender_id**: the account that's attempting to transfer the token.
- **receiver_id**: the account that's receiving the token.
- **token_id**: the token ID being transferred.
- **memo**: an optional memo to include.

The first thing we have to do is to make sure that the sender is authorized to transfer the token. In this case, we just make sure that the sender is the owner of the token. We do that by getting the `Token` object using the `token_id` and making sure that the sender is equal to the token's `owner_id`.

Second, we remove the token ID from the sender's list and add the token ID to the receiver's list of tokens. Finally, we create a new `Token` object with the receiver as the owner and remap the token ID to that newly created object.

We want to create this function within the contract implementation (below the `internal_add_token_to_owner` you created in the minting tutorial).

<Github language="rust" start="96" end="132" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/internal.rs" />

Now let's look at the function called `internal_remove_token_from_owner`. That function implements the functionality for removing a token ID from an owner's set. 

In the remove function, we get the set of tokens for a given account ID and then remove the passed in token ID. If the account's set is empty after the removal, we simply remove the account from the `tokens_per_owner` data structure.

<Github language="rust" start="71" end="94" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/internal.rs" />

Your `internal.rs` file should now have the following outline:

```
internal.rs
‚îú‚îÄ‚îÄ hash_account_id
‚îú‚îÄ‚îÄ assert_one_yocto
‚îú‚îÄ‚îÄ refund_deposit
‚îî‚îÄ‚îÄ impl Contract
    ‚îú‚îÄ‚îÄ internal_add_token_to_owner
    ‚îú‚îÄ‚îÄ internal_remove_token_from_owner
    ‚îî‚îÄ‚îÄ internal_transfer
```

<hr class="subsection" />

### Transfer call function {#transfer-call-function}

The idea behind the `nft_transfer_call` function is to transfer an NFT to a receiver while calling a method on the receiver's contract all in the same transaction.

This way, we can effectively **attach an NFT to a function call**.

<Github language="rust" start="82" end="126" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/nft_core.rs" />

The function will first assert that the caller attached exactly 1 yocto for security purposes. It will then transfer the NFT using `internal_transfer` and start the cross contract call. It will call the method `nft_on_transfer` on the `receiver_id`'s contract, and create a promise to call back `nft_resolve_transfer` with the result. This is a very common workflow when dealing with [cross contract calls](../../2.build/2.smart-contracts/anatomy/crosscontract.md).

As dictated by the core standard, the function we are calling (`nft_on_transfer`) needs to return a boolean stating whether or not you should return the NFT to it's original owner.

<Github language="rust" start="146" end="201" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/nft_core.rs" />

If `nft_on_transfer` returned true or the called failed, you should send the token back to it's original owner. On the contrary, if false was returned, no extra logic is needed.

As for the return value of our function `nft_resolve_transfer`, the standard dictates that the function should return a boolean indicating whether or not the receiver successfully received the token or not.

This means that if `nft_on_transfer` returned true, you should return false. This is because if the token is being returned its original owner, the `receiver_id` didn't successfully receive the token in the end. On the contrary, if `nft_on_transfer` returned false, you should return true since we don't need to return the token and thus the `receiver_id` successfully owns the token.

With that finished, you've now successfully added the necessary logic to allow users to transfer NFTs. It's now time to deploy and do some testing.

---

## Redeploying the contract {#redeploying-contract}

Using cargo-near, deploy the contract as you did in the previous tutorials:

```bash
cargo near deploy $NFT_CONTRACT_ID without-init-call network-config testnet sign-with-keychain send
```

:::tip
If you haven't completed the previous tutorials and are just following along with this one, simply create an account and login with your CLI using `near login`. You can then export an environment variable `export NFT_CONTRACT_ID=YOUR_ACCOUNT_ID_HERE`.
:::

---

## Testing the new changes {#testing-changes}

Now that you've deployed a patch fix to the contract, it's time to move onto testing. Using the previous NFT contract where you had minted a token to yourself, you can test the `nft_transfer` method. If you transfer the NFT, it should be removed from your account's collectibles displayed in the wallet. In addition, if you query any of the enumeration functions, it should show that you are no longer the owner.

Let's test this out by transferring an NFT to the account `benjiman.testnet` and seeing if the NFT is no longer owned by you.

<hr class="subsection" />

### Testing the transfer function

:::note
This means that the NFT won't be recoverable unless the account `benjiman.testnet` transfers it back to you. If you don't want your NFT lost, make a new account and transfer the token to that account instead.
:::

If you run the following command, it will transfer the token `"token-1"` to the account `benjiman.testnet` with the memo `"Go Team :)"`. Take note that you're also attaching exactly 1 yoctoNEAR by using the `--depositYocto` flag. 

:::tip
If you used a different token ID in the previous tutorials, replace `token-1` with your token ID.
:::

```bash
near call $NFT_CONTRACT_ID nft_transfer '{"receiver_id": "benjiman.testnet", "token_id": "token-1", "memo": "Go Team :)"}' --accountId $NFT_CONTRACT_ID --depositYocto 1
```

If you now query for all the tokens owned by your account, that token should be missing. Similarly, if you query for the list of tokens owned by `benjiman.testnet`, that account should now own your NFT.

<hr class="subsection" />

### Testing the transfer call function

Now that you've tested the `nft_transfer` function, it's time to test the `nft_transfer_call` function. If you try to transfer an NFT to a receiver that does **not** implement the `nft_on_transfer` function, the contract will panic and the NFT will **not** be transferred. Let's test this functionality below.

First mint a new NFT that will be used to test the transfer call functionality.

```bash
near call $NFT_CONTRACT_ID nft_mint '{"token_id": "token-2", "metadata": {"title": "NFT Tutorial Token", "description": "Testing the transfer call function", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$NFT_CONTRACT_ID'"}' --accountId $NFT_CONTRACT_ID --amount 0.1
```

Now that you've minted the token, you can try to transfer the NFT to the account `no-contract.testnet` which as the name suggests, doesn't have a contract. This means that the receiver doesn't implement the `nft_on_transfer` function and the NFT should remain yours after the transaction is complete.

```bash
near call $NFT_CONTRACT_ID nft_transfer_call '{"receiver_id": "no-contract.testnet", "token_id": "token-2", "msg": "foo"}' --accountId $NFT_CONTRACT_ID --depositYocto 1 --gas 200000000000000
```

If you query for your tokens, you should still have `token-2` and at this point, you're finished!

---

## Conclusion

In this tutorial, you learned how to expand an NFT contract past the minting functionality and you added ways for users to transfer NFTs. You [broke down](#introduction) the problem into smaller, more digestible subtasks and took that information and implemented both the [NFT transfer](#transfer-function) and [NFT transfer call](#transfer-call-function) functions. In addition, you deployed another [patch fix](#redeploying-contract) to your smart contract and [tested](#testing-changes) the transfer functionality.

In the [next tutorial](/tutorials/nfts/approvals), you'll learn about the approval management system and how you can approve others to transfer tokens on your behalf.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- cargo-near `0.6.1`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.1.0`
- Enumeration standard: [NEP181](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration), version `1.0.0`

:::

'''
'''--- docs/3.tutorials/nfts/5-approval.md ---
---
id: approvals
title: Approvals
sidebar_label: Approvals
---
import {Github} from "@site/src/components/codetabs"

In this tutorial you'll learn the basics of an approval management system which will allow you to grant others access to transfer NFTs on your behalf.

This is the backbone of all NFT marketplaces and allows for some complex yet beautiful scenarios to happen. If you're joining us for the first time, feel free to clone [this repository](https://github.com/near-examples/nft-tutorial) and go to the `nft-contract-basic/` folder to follow along.

```bash
cd nft-contract-basic/
```

:::tip
If you wish to see the finished code for this _Approval_ tutorial, you can find it on the `nft-contract-approval/` folder.
:::

---

## Introduction

Up until this point you've created a smart contract that allows users to mint and transfer NFTs as well as query for information using the [enumeration standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration). As we've been doing in the previous tutorials, let's break down the problem into smaller, more digestible, tasks.

Let's first define some of the end goals that we want to accomplish as per the [approval management](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement) extension of the standard. We want a user to have the ability to:

- Grant other accounts access to transfer their NFTs on a per token basis.
- Check if an account has access to a specific token.
- Revoke a specific account the ability to transfer an NFT.
- Revoke **all** other accounts the ability to transfer an NFT.

If you look at all these goals, they are all on a per token basis. This is a strong indication that you should change the `Token` struct which keeps track of information for each token.

---

## Allow an account to transfer your NFT

Let's start by trying to accomplish the first goal. How can you grant another account access to transfer an NFT on your behalf?

The simplest way that you can achieve this is to add a list of approved accounts to the `Token` struct. When transferring the NFT, if the caller is not the owner, you could check if they're in the list.

Before transferring, you would need to clear the list of approved accounts since the new owner wouldn't expect the accounts approved by the original owner to still have access to transfer their new NFT.

<hr className="subsection" />

### The problem {#the-problem}

On the surface, this would work, but if you start thinking about the edge cases, some problems arise. Often times when doing development, a common approach is to think about the easiest and most straightforward solution. Once you've figured it out, you can start to branch off and think about optimizations and edge cases.

Let's consider the following scenario. Benji has an NFT and gives two separate marketplaces access to transfer his token. By doing so, he's putting the NFT for sale (more about that in the [marketplace integrations](#marketplace-integrations) section). Let's say he put the NFT for sale for 1 NEAR on both markets. The tokens list of approved account IDs would look like the following:

```
Token: {
    owner_id: Benji
    approved_accounts_ids: [marketplace A, marketplace B]
}
```

Josh then comes along and purchases the NFT on marketplace A for 1 NEAR. This would take the sale down from the marketplace A and clear the list of approved accounts. Marketplace B, however, still has the token listed for sale for 1 NEAR and has no way of knowing that the token was purchased on marketplace A by Josh. The new token struct would look as follows:

```
Token: {
    owner_id: Josh
    approved_accounts_ids: []
}
```

Let's say Josh is low on cash and wants to flip this NFT and put it for sale for 10 times the price on marketplace B. He goes to put it for sale and for whatever reason, the marketplace is built in a way that if you try to put a token up for sale twice, it keeps the old sale data. This would mean that from marketplace B's perspective, the token is still for sale for 1 NEAR (which was the price that Benji had originally listed it for).

Since Josh approved the marketplace to try and put it for sale, the token struct would look as follows:

```
Token: {
    owner_id: Josh
    approved_accounts_ids: [marketplace A, marketplace B]
}
```

If Mike then comes along and purchases the NFT for only 1 NEAR on marketplace B, the marketplace would go to try and transfer the NFT and since technically, Josh approved the marketplace and it's in the list of approved accounts, the transaction would go through properly.

<hr className="subsection" />

### The solution {#the-solution}

Now that we've identified a problem with the original solution, let's think about ways that we can fix it. What would happen now if, instead of just keeping track of a list of approved accounts, you introduced a specific ID that went along with each approved account. The new approved accounts would now be a map instead of a list. It would map an account to it's `approval id`.

For this to work, you need to make sure that the approval ID is **always** a unique, new ID. If you set it as an integer that always increases by 1 whenever u approve an account, this should work. Let's consider the same scenario with the new solution.

Benji puts his NFT for sale for 1 NEAR on marketplace A and marketplace B by approving both marketplaces. The "next approval ID" would start off at 0 when the NFT was first minted and will increase from there. This would result in the following token struct:

```
Token: {
    owner_id: Benji
    approved_accounts_ids: {
        marketplace A: 0
        marketplace B: 1
    }
    next_approval_id: 2
}
```

When Benji approved marketplace A, it took the original value of `next_approval_id` which started off at 0. The marketplace was then inserted into the map and the next approval ID was incremented. This process happened again for marketplace B and the next approval ID was again incremented where it's now 2.

Josh comes along and purchases the NFT on marketplace A for 1 NEAR. Notice how the next approval ID stayed at 2:

```
Token: {
    owner_id: Josh
    approved_accounts_ids: {}
    next_approval_id: 2
}
```

Josh then flips the NFT because he's once again low on cash and approves marketplace B:

```
Token: {
    owner_id: Josh
    approved_accounts_ids: {
        marketplace B: 2
    }
    next_approval_id: 3
}
```

The marketplace is inserted into the map and the next approval ID is incremented. From marketplace B's perspective it stores it's original approval ID from when Benji put the NFT up for sale which has a value of 1. If Mike were to go and purchase the NFT on marketplace B for the original 1 NEAR sale price, the NFT contract should panic. This is because the marketplace is trying to transfer the NFT with an approval ID 1 but the token struct shows that it **should** have an approval ID of 2.

<hr className="subsection" />

### Expanding the `Token` and `JsonToken` structs

Now that you understand the proposed solution to the original problem of allowing an account to transfer your NFT, it's time to implement some of the logic. The first thing you should do is modify the `Token` and `JsonToken` structs to reflect the new changes. Let's switch over to the `nft-contract-basic/src/metadata.rs` file:

<Github language="rust" start="41" end="64" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/metadata.rs" />

You'll then need to initialize both the `approved_account_ids` and `next_approval_id` to their default values when a token is minted. Switch to the `nft-contract-basic/src/mint.rs` file and when creating the `Token` struct to store in the contract, let's set the next approval ID to be 0 and the approved account IDs to be an empty map:

<Github language="rust" start="31" end="38" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/mint.rs" />

<hr className="subsection" />

### Approving accounts

Now that you've added the support for approved account IDs and the next approval ID on the token level, it's time to add the logic for populating and changing those fields through a function called `nft_approve`. This function should approve an account to have access to a specific token ID. Let's move to the `nft-contract-basic/src/approval.rs` file and edit the `nft_approve` function:

<Github language="rust" start="38" end="95" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/approval.rs" />

The function will first assert that the user has attached **at least** one yoctoNEAR (which we'll implement soon). This is both for security and to cover storage. When someone approves an account ID, they're storing that information on the contract. As you saw in the [minting tutorial](/tutorials/nfts/minting), you can either have the smart contract account cover the storage, or you can have the users cover that cost. The latter is more scalable and it's the approach you'll be working with throughout this tutorial.

After the assertion comes back with no problems, you get the token object and make sure that only the owner is calling this method. Only the owner should be able to allow other accounts to transfer their NFTs. You then get the next approval ID and insert the passed in account into the map with the next approval ID. If it's a new approval ID, storage must be paid. If it's not a new approval ID, no storage needs to be paid and only attaching 1 yoctoNEAR would be enough.

You then calculate how much storage is being used by adding that new account to the map and increment the tokens `next_approval_id` by 1. After inserting the token object back into the `tokens_by_id` map, you refund any excess storage.

You'll notice that the function contains an optional `msg` parameter. This message can be used by NFT marketplaces. If a message was provided into the function, you're going to perform a cross contract call to the account being given access. This cross contract call will invoke the `nft_on_approve` function which will parse the message and act accordingly.

It is up to the approving person to provide a properly encoded message that the marketplace can decode and use. This is usually done through the marketplace's frontend app which would know how to construct the `msg` in a useful way.

<hr className="subsection" />

### Internal functions

Now that the core logic for approving an account is finished, you need to implement the `assert_at_least_one_yocto` and `bytes_for_approved_account` functions. Move to the `nft-contract/src/internal.rs` file and copy the following function right below the `assert_one_yocto` function.

<Github language="rust" start="49" end="55" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/internal.rs" />

Next, you'll need to copy the logic for calculating how many bytes it costs to store an account ID. Place this function at the very top of the page:

<Github language="rust" start="1" end="9" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/internal.rs" />

Now that the logic for approving accounts is finished, you need to change the restrictions for transferring.

#### Changing the restrictions for transferring NFTs

Currently, an NFT can **only** be transferred by its owner. You need to change that restriction so that people that have been approved can also transfer NFTs. In addition, you'll make it so that if an approval ID is passed, you can increase the security and check if both the account trying to transfer is in the approved list **and** they correspond to the correct approval ID. This is to address the problem we ran into earlier.

In the `internal.rs` file, you need to change the logic of the `internal_transfer` method as that's where the restrictions are being made. Change the internal transfer function to be the following:

<Github language="rust" start="130" end="227" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/internal.rs" />

This will check if the sender isn't the owner and then if they're not, it will check if the sender is in the approval list. If an approval ID was passed into the function, it will check if the sender's actual approval ID stored on the contract matches the one passed in.

<hr className="subsection" />

#### Refunding storage on transfer

While you're in the internal file, you're going to need to add methods for refunding users who have paid for storing approved accounts on the contract when an NFT is transferred. This is because you'll be clearing the `approved_account_ids` map whenever NFTs are transferred and so the storage is no longer being used.

Right below the `bytes_for_approved_account_id` function, copy the following two functions:

<Github language="rust" start="11" end="29" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/internal.rs" />

These will be useful in the next section where you'll be changing the `nft_core` functions to include the new approval logic.

<hr className="subsection" />

### Changes to `nft_core.rs`

Head over to the `nft-contract-basic/src/nft_core.rs` file and the first change that you'll want to make is to add an `approval_id` to both the `nft_transfer` and `nft_transfer_call` functions. This is so that anyone trying to transfer the token that isn't the owner must pass in an approval ID to address the problem seen earlier. If they are the owner, the approval ID won't be used as we saw in the `internal_transfer` function.

<Github language="rust" start="8" end="29" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/nft_core.rs" />

You'll then need to add an `approved_account_ids` map to the parameters of `nft_resolve_transfer`. This is so that you can refund the list if the transfer went through properly.

<Github language="rust" start="47" end="66" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/nft_core.rs" />

Moving over to `nft_transfer`, the only change that you'll need to make is to pass in the approval ID into the `internal_transfer` function and then refund the previous tokens approved account IDs after the transfer is finished

<Github language="rust" start="71" end="99" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/nft_core.rs" />

Next, you need to do the same to `nft_transfer_call` but instead of refunding immediately, you need to attach the previous token's approved account IDs to `nft_resolve_transfer` instead as there's still the possibility that the transfer gets reverted.

<Github language="rust" start="101" end="158" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/nft_core.rs" />

You'll also need to add the tokens approved account IDs to the `JsonToken` being returned by `nft_token`.

<Github language="rust" start="160" end="176" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/nft_core.rs" />

Finally, you need to add the logic for refunding the approved account IDs in `nft_resolve_transfer`. If the transfer went through, you should refund the owner for the storage being released by resetting the tokens `approved_account_ids` field. If, however, you should revert the transfer, it wouldn't be enough to just not refund anybody. Since the receiver briefly owned the token, they could have added their own approved account IDs and so you should refund them if they did so.

<Github language="rust" start="181" end="279" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/nft_core.rs" />

With that finished, it's time to move on and complete the next task.

---

## Check if an account is approved

Now that the core logic is in place for approving and refunding accounts, it should be smooth sailing from this point on. You now need to implement the logic for checking if an account has been approved. This should take an account and token ID as well as an optional approval ID. If no approval ID was provided, it should simply return whether or not the account is approved.

If an approval ID was provided, it should return whether or not the account is approved and has the same approval ID as the one provided. Let's move to the `nft-contract-basic/src/approval.rs` file and add the necessary logic to the `nft_is_approved` function.

<Github language="rust" start="98" end="125" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/approval.rs" />

Let's now move on and add the logic for revoking an account

---

## Revoke an account

The next step in the tutorial is to allow a user to revoke a specific account from having access to their NFT. The first thing you'll want to do is assert one yocto for security purposes. You'll then need to make sure that the caller is the owner of the token. If those checks pass, you'll need to remove the passed in account from the tokens approved account IDs and refund the owner for the storage being released.

<Github language="rust" start="127" end="151" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/approval.rs" />

---

## Revoke all accounts

The final step in the tutorial is to allow a user to revoke all accounts from having access to their NFT. This should also assert one yocto for security purposes and make sure that the caller is the owner of the token. You then refund the owner for releasing all the accounts in the map and then clear the `approved_account_ids`.

<Github language="rust" start="153" end="173" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/approval.rs" />

With that finished, it's time to deploy and start testing the contract.

---

## Testing the new changes {#testing-changes}

Since these changes affect all the other tokens and the state won't be able to automatically be inherited by the new code, simply redeploying the contract will lead to errors. For this reason, it's best practice to create a new account and deploy the contract there.

<hr className="subsection" />

### Deployment and initialization

Next, you'll deploy this contract to the network.

```bash
export APPROVAL_NFT_CONTRACT_ID=<accountId>
near create-account $APPROVAL_NFT_CONTRACT_ID --useFaucet
```

Using the cargo-near, deploy and initialize the contract as you did in the previous tutorials:

```bash
cargo near deploy $APPROVAL_NFT_CONTRACT_ID with-init-call new_default_meta json-args '{"owner_id": "'$APPROVAL_NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

<hr className="subsection" />

### Minting {#minting}

Next, you'll need to mint a token. By running this command, you'll mint a token with a token ID `"approval-token"` and the receiver will be your new account.

```bash
near call $APPROVAL_NFT_CONTRACT_ID nft_mint '{"token_id": "approval-token", "metadata": {"title": "Approval Token", "description": "testing out the new approval extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$APPROVAL_NFT_CONTRACT_ID'"}' --accountId $APPROVAL_NFT_CONTRACT_ID --amount 0.1
```

You can check to see if everything went through properly by calling one of the enumeration functions:

```bash
near view $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$APPROVAL_NFT_CONTRACT_ID'", "limit": 10}'
```

This should return an output similar to the following:

```json
[
  {
    "token_id": "approval-token",
    "owner_id": "approval.goteam.examples.testnet",
    "metadata": {
      "title": "Approval Token",
      "description": "testing out the new approval extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
      "media_hash": null,
      "copies": null,
      "issued_at": null,
      "expires_at": null,
      "starts_at": null,
      "updated_at": null,
      "extra": null,
      "reference": null,
      "reference_hash": null
    },
    "approved_account_ids": {}
  }
]
```

Notice how the approved account IDs are now being returned from the function? This is a great sign! You're now ready to move on and approve an account to have access to your token.

<hr className="subsection" />

### Approving an account {#approving-an-account}

At this point, you should have two accounts. One stored under `$NFT_CONTRACT_ID` and the other under the `$APPROVAL_NFT_CONTRACT_ID` environment variable. You can use both of these accounts to test things out. If you approve your old account, it should have the ability to transfer the NFT to itself.

Execute the following command to approve the account stored under `$NFT_CONTRACT_ID` to have access to transfer your NFT with an ID `"approval-token"`. You don't need to pass a message since the old account didn't implement the `nft_on_approve` function. In addition, you'll need to attach enough NEAR to cover the cost of storing the account on the contract. 0.1 NEAR should be more than enough and you'll be refunded any excess that is unused.

```bash
near call $APPROVAL_NFT_CONTRACT_ID nft_approve '{"token_id": "approval-token", "account_id": "'$NFT_CONTRACT_ID'"}' --accountId $APPROVAL_NFT_CONTRACT_ID --deposit 0.1
```

If you call the same enumeration method as before, you should see the new approved account ID being returned.

```bash
near view $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$APPROVAL_NFT_CONTRACT_ID'", "limit": 10}'
```

This should return an output similar to the following:

```json
[
  {
    "token_id": "approval-token",
    "owner_id": "approval.goteam.examples.testnet",
    "metadata": {
      "title": "Approval Token",
      "description": "testing out the new approval extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
      "media_hash": null,
      "copies": null,
      "issued_at": null,
      "expires_at": null,
      "starts_at": null,
      "updated_at": null,
      "extra": null,
      "reference": null,
      "reference_hash": null
    },
    "approved_account_ids": { "goteam.examples.testnet": 0 }
  }
]
```

<hr className="subsection" />

### Transferring an NFT as an approved account {#transferring-the-nft}

Now that you've approved another account to transfer the token, you can test that behavior. You should be able to use the other account to transfer the NFT to itself by which the approved account IDs should be reset. Let's test transferring the NFT with the wrong approval ID:

```bash
near call $APPROVAL_NFT_CONTRACT_ID nft_transfer '{"receiver_id": "'$NFT_CONTRACT_ID'", "token_id": "approval-token", "approval_id": 1}' --accountId $NFT_CONTRACT_ID --depositYocto 1
```

<details>
<summary>Example response: </summary>
<p>

```bash
kind: {
    ExecutionError: "Smart contract panicked: panicked at 'assertion failed: `(left == right)`\n" +
      '  left: `0`,\n' +
      " right: `1`: The actual approval_id 0 is different from the given approval_id 1', src/internal.rs:165:17"
  },
```

</p>
</details>

If you pass the correct approval ID which is `0`, everything should work fine.

```bash
near call $APPROVAL_NFT_CONTRACT_ID nft_transfer '{"receiver_id": "'$NFT_CONTRACT_ID'", "token_id": "approval-token", "approval_id": 0}' --accountId $NFT_CONTRACT_ID --depositYocto 1
```

If you again call the enumeration method, you should see the owner updated and the approved account IDs reset.

```json
[
  {
    "token_id": "approval-token",
    "owner_id": "goteam.examples.testnet",
    "metadata": {
      "title": "Approval Token",
      "description": "testing out the new approval extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
      "media_hash": null,
      "copies": null,
      "issued_at": null,
      "expires_at": null,
      "starts_at": null,
      "updated_at": null,
      "extra": null,
      "reference": null,
      "reference_hash": null
    },
    "approved_account_ids": {}
  }
]
```

Let's now test the approval ID incrementing across different owners. If you approve the account that originally minted the token, the approval ID should be 1 now.

```bash
near call $APPROVAL_NFT_CONTRACT_ID nft_approve '{"token_id": "approval-token", "account_id": "'$APPROVAL_NFT_CONTRACT_ID'"}' --accountId $NFT_CONTRACT_ID --deposit 0.1
```

Calling the view function again show now return an approval ID of 1 for the account that was approved.

```bash
near view $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$NFT_CONTRACT_ID'", "limit": 10}'
```

<details>
<summary>Example response: </summary>
<p>

```json
[
  {
    "token_id": "approval-token",
    "owner_id": "goteam.examples.testnet",
    "metadata": {
      "title": "Approval Token",
      "description": "testing out the new approval extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
      "media_hash": null,
      "copies": null,
      "issued_at": null,
      "expires_at": null,
      "starts_at": null,
      "updated_at": null,
      "extra": null,
      "reference": null,
      "reference_hash": null
    },
    "approved_account_ids": { "approval.goteam.examples.testnet": 1 }
  }
]
```

</p>
</details>

With the testing finished, you've successfully implemented the approvals extension to the standard!

---

## Conclusion

Today you went through a lot of logic to implement the [approvals extension](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement) so let's break down exactly what you did.

First, you explored the [basic approach](#basic-solution) of how to solve the problem. You then went through and discovered some of the [problems](#the-problem) with that solution and learned how to [fix it](#the-solution).

After understanding what you should do to implement the approvals extension, you started to [modify](#expanding-json-and-token) the JsonToken and Token structs in the contract. You then implemented the logic for [approving accounts](#approving-accounts) and saw how [marketplaces](#marketplace-integrations) are integrated.

After implementing the logic behind approving accounts, you went and [changed the restrictions](#changing-restrictions) needed to transfer NFTs. The last step you did to finalize the approving logic was to go back and edit the [nft_core](#nft-core-changes) files to be compatible with the new changes.

At this point, everything was implemented in order to allow accounts to be approved and you extended the functionality of the [core standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core) to allow for approved accounts to transfer tokens.

You implemented a view method to [check](#check-if-account-approved) if an account is approved and to finish the coding portion of the tutorial, you implemented the logic necessary to [revoke an account](#revoke-account) as well as [revoke all accounts](#revoke-all-accounts).

After this, the contract code was finished and it was time to move onto testing where you created an [account](#deployment) and tested the [approving](#approving-an-account) and [transferring](#transferring-the-nft) for your NFTs.

In the next tutorial, you'll learn about the royalty standards and how you can interact with NFT marketplaces.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- cargo-near `0.6.1`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.1.0`
- Enumeration standard: [NEP181](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration), version `1.0.0`
- Approval standard: [NEP178](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement), version `1.1.0`

:::

'''
'''--- docs/3.tutorials/nfts/6-royalty.md ---
---
id: royalty
title: Royalty
sidebar_label: Royalty
---
import {Github} from "@site/src/components/codetabs"

In this tutorial you'll continue building your non-fungible token (NFT) smart contract, and learn how to implement perpetual royalties into your NFTs. This will allow people to get a percentage of the purchase price when an NFT is sold.

## Introduction

By now, you should have a fully fledged NFT contract, except for the royalties support.
To get started, go to the `nft-contract-approval/` folder from our [GitHub repository](https://github.com/near-examples/nft-tutorial/), or continue your work from the previous tutorials.

```bash
cd nft-contract-approval/
```

:::tip
If you wish to see the finished code for this _Royalty_ tutorial, you can find it in the `nft-contract-royalty` folder.
:::

---

## Thinking about the problem

In order to implement the functionality, you first need to understand how NFTs are sold. In the previous tutorial, you saw how someone with an NFT could list it on a marketplace using the `nft_approve` function by passing in a message that could be properly decoded. When a user purchases your NFT on the marketplace, what happens?

Using the knowledge you have now, a reasonable conclusion would be to say that the marketplace transfers the NFT to the buyer by performing a cross-contract call and invokes the NFT contract's `nft_transfer` method. Once that function finishes, the marketplace would pay the seller for the correct amount that the buyer paid.

Let's now think about how this can be expanded to allow for a cut of the pay going to other accounts that aren't just the seller.

<hr class="subsection" />

### Expanding the current solution

Since perpetual royalties will be on a per-token basis, it's safe to assume that you should be changing the `Token` and `JsonToken` structs. You need some way of keeping track of what percentage each account with a royalty should have. If you introduce a map of an account to an integer, that should do the trick.

Now, you need some way to relay that information to the marketplace. This method should be able to transfer the NFT exactly like the old solution but with the added benefit of telling the marketplace exactly what accounts should be paid what amounts. If you implement a method that transfers the NFT and then calculates exactly what accounts get paid and to what amount based on a passed-in balance, that should work nicely.

This is what the [royalty standards](https://nomicon.io/Standards/NonFungibleToken/Payout) outlined. Let's now move on and modify our smart contract to introduce this behavior.

---

## Modifications to the contract

The first thing you'll want to do is add the royalty information to the structs. Open the `nft-contract-approval/src/metadata.rs` file and add `royalty` to the `Token` struct:

```rust
pub royalty: HashMap<AccountId, u32>,
```

Second, you'll want to add `royalty` to the `JsonToken` struct as well:

```rust
pub royalty: HashMap<AccountId, u32>,
```

<hr class="subsection" />

### Internal helper function

**royalty_to_payout**

To simplify the payout calculation, let's add a helper `royalty_to_payout` function to `src/internal.rs`. This will convert a percentage to the actual amount that should be paid. In order to allow for percentages less than 1%, you can give 100% a value of `10,000`. This means that the minimum percentage you can give out is 0.01%, or `1`. For example, if you wanted the account `benji.testnet` to have a perpetual royalty of 20%, you would insert the pair `"benji.testnet": 2000` into the payout map.

<Github language="rust" start="5" end="8" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-royalty/src/internal.rs" />

If you were to use the `royalty_to_payout` function and pass in `2000` as the `royalty_percentage` and an `amount_to_pay` of 1 NEAR, it would return a value of 0.2 NEAR.

<hr class="subsection" />

### Royalties

**nft_payout**

Let's now implement a method to check what accounts will be paid out for an NFT given an amount, or balance. Open the `nft-contract/src/royalty.rs` file, and modify the `nft_payout` function as shown.

<Github language="rust" start="22" end="67" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-royalty/src/royalty.rs" />

This function will loop through the token's royalty map and take the balance and convert that to a payout using the `royalty_to_payout` function you created earlier. It will give the owner of the token whatever is left from the total royalties. As an example:

You have a token with the following royalty field:

```rust
Token {
    owner_id: "damian",
    royalty: {
        "benji": 1000,
        "josh": 500,
        "mike": 2000
    }
}
```

If a user were to call `nft_payout` on the token and pass in a balance of 1 NEAR, it would loop through the token's royalty field and insert the following into the payout object:

```rust
Payout {
    payout: {
        "benji": 0.1 NEAR,
        "josh": 0.05 NEAR,
        "mike": 0.2 NEAR
    }
}
```

At the very end, it will insert `damian` into the payout object and give him `1 NEAR - 0.1 - 0.05 - 0.2 = 0.65 NEAR`.

**nft_transfer_payout**

Now that you know how payouts are calculated, it's time to create the function that will transfer the NFT and return the payout to the marketplace.

<Github language="rust" start="70" end="135" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-royalty/src/royalty.rs" />

<hr class="subsection" />

### Perpetual royalties

To add support for perpetual royalties, let's edit the `src/mint.rs` file. First, add an optional parameter for perpetual royalties. This is what will determine what percentage goes to which accounts when the NFT is purchased. You will also need to create and insert the royalty to be put in the `Token` object:

<Github language="rust" start="6" end="80" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-royalty/src/mint.rs" />

Next, you can use the CLI to query the new `nft_payout` function and validate that it works correctly.

### Adding royalty object to struct implementations

Since you've added a new field to your `Token` and `JsonToken` structs, you need to edit your implementations accordingly. Move to the `nft-contract/src/internal.rs` file and edit the part of your `internal_transfer` function that creates the new `Token` object:

<Github language="rust" start="184" end="192" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-royalty/src/internal.rs" />

Once that's finished, move to the `nft-contract-approval/src/nft_core.rs` file. You need to edit your implementation of `nft_token` so that the `JsonToken` sends back the new royalty information.

<Github language="rust" start="160" end="177" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-royalty/src/nft_core.rs" />

---

## Deploying the contract {#redeploying-contract}

As you saw in the previous tutorial, adding changes like these will cause problems when redeploying. Since these changes affect all the other tokens and the state won't be able to automatically be inherited by the new code, simply redeploying the contract will lead to errors. For this reason, you'll create a new account again.

### Deployment and initialization

Next, you'll deploy this contract to the network.

```bash
export ROYALTY_NFT_CONTRACT_ID=<accountId>
near create-account $ROYALTY_NFT_CONTRACT_ID --useFaucet
```

Using the cargo-near, deploy and initialize the contract as you did in the previous tutorials:

```bash
cargo near deploy $ROYALTY_NFT_CONTRACT_ID with-init-call new_default_meta json-args '{"owner_id": "'$ROYALTY_NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

### Minting {#minting}

Next, you'll need to mint a token. By running this command, you'll mint a token with a token ID `"royalty-token"` and the receiver will be your new account. In addition, you're passing in a map with two accounts that will get perpetual royalties whenever your token is sold.

```bash
near call $ROYALTY_NFT_CONTRACT_ID nft_mint '{"token_id": "royalty-token", "metadata": {"title": "Royalty Token", "description": "testing out the new royalty extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$ROYALTY_NFT_CONTRACT_ID'", "perpetual_royalties": {"benjiman.testnet": 2000, "mike.testnet": 1000, "josh.testnet": 500}}' --accountId $ROYALTY_NFT_CONTRACT_ID --amount 0.1
```

You can check to see if everything went through properly by calling one of the enumeration functions:

```bash
near view $ROYALTY_NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$ROYALTY_NFT_CONTRACT_ID'", "limit": 10}'
```

This should return an output similar to the following:

```json
[
  {
    "token_id": "royalty-token",
    "owner_id": "royalty.goteam.examples.testnet",
    "metadata": {
      "title": "Royalty Token",
      "description": "testing out the new royalty extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
      "media_hash": null,
      "copies": null,
      "issued_at": null,
      "expires_at": null,
      "starts_at": null,
      "updated_at": null,
      "extra": null,
      "reference": null,
      "reference_hash": null
    },
    "approved_account_ids": {},
    "royalty": {
      "josh.testnet": 500,
      "benjiman.testnet": 2000,
      "mike.testnet": 1000
    }
  }
]
```

Notice how there's now a royalty field that contains the 3 accounts that will get a combined 35% of all sales of this NFT? Looks like it works! Go team :)

### NFT payout

Let's calculate the payout for the `"royalty-token"` NFT, given a balance of 100 yoctoNEAR. It's important to note that the balance being passed into the `nft_payout` function is expected to be in yoctoNEAR.

```bash
near view $ROYALTY_NFT_CONTRACT_ID nft_payout '{"token_id": "royalty-token", "balance": "100", "max_len_payout": 100}'
```

This command should return an output similar to the following:

```bash
{
  payout: {
    'josh.testnet': '5',
    'royalty.goteam.examples.testnet': '65',
    'mike.testnet': '10',
    'benjiman.testnet': '20'
  }
}
```

If the NFT was sold for 100 yoctoNEAR, josh would get 5, benji would get 20, mike would get 10, and the owner, in this case `royalty.goteam.examples.testnet` would get the rest: 65.

## Conclusion

At this point you have everything you need for a fully functioning NFT contract to interact with marketplaces.
The last remaining standard that you could implement is the events standard. This allows indexers to know what functions are being called and makes it easier and more reliable to keep track of information that can be used to populate the collectibles tab in the wallet for example.

:::info remember
If you want to see the finished code from this tutorial, you can go to the `nft-contract-royalty` folder.
:::

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- cargo-near `0.6.1`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.1.0`
- Enumeration standard: [NEP181](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration), version `1.0.0`
- Royalties standard: [NEP199](https://nomicon.io/Standards/Tokens/NonFungibleToken/Payout), version `2.0.0`

:::

'''
'''--- docs/3.tutorials/nfts/7-events.md ---
---
id: events
title: Events
---
import {Github} from "@site/src/components/codetabs"

In this tutorial, you'll learn about the [events standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event) and how to implement it in your smart contract.

---

## Understanding the use case {#understanding-the-use-case}

Have you ever wondered how the wallet knows which NFTs you own and how it can display them in the [collectibles tab](https://testnet.mynearwallet.com//?tab=collectibles)? Originally, an [indexer](/tools/indexer-for-explorer) was used and it listened for any functions starting with `nft_` on your account. These contracts were then flagged on your account as likely NFT contracts. 

When you navigated to your collectibles tab, the wallet would then query all those contracts for the list of NFTs you owned using the `nft_tokens_for_owner` function you saw in the [enumeration tutorial](/tutorials/nfts/enumeration).

<hr class="subsection" />

### The problem {#the-problem}

This method of flagging contracts was not reliable as each NFT-driven application might have its own way of minting or transferring NFTs. In addition, it's common for apps to transfer or mint many tokens at a time using batch functions. 

<hr class="subsection" />

### The solution {#the-solution}

A standard was introduced so that smart contracts could emit an event anytime NFTs were transferred, minted, or burnt. This event was in the form of a log. No matter how a contract implemented the functionality, an indexer could now listen for those standardized logs.

As per the standard, you need to implement a logging functionality that gets fired when NFTs are transferred or minted. In this case, the contract doesn't support burning so you don't need to worry about that for now.

It's important to note the standard dictates that the log should begin with `"EVENT_JSON:"`. The structure of your log should, however, always contain the 3 following things: 

- **standard**: the current name of the standard (e.g. nep171)
- **version**: the version of the standard you're using (e.g. 1.0.0)
- **event**: a list of events you're emitting.

The event interface differs based on whether you're recording transfers or mints. The interface for both events is outlined below.

**Transfer events**:
- *Optional* - **authorized_id**: the account approved to transfer on behalf of the owner.
- **old_owner_id**: the old owner of the NFT.
- **new_owner_id**: the new owner that the NFT is being transferred to.
- **token_ids**: a list of NFTs being transferred.
- *Optional* - **memo**: an optional message to include with the event.

**Minting events**:
- **owner_id**: the owner that the NFT is being minted to.
- **token_ids**: a list of NFTs being transferred.
- *Optional* - **memo**: an optional message to include with the event.

<hr class="subsection" />

### Examples {#examples}

In order to solidify your understanding of the standard, let's walk through three scenarios and see what the logs should look like.

#### Scenario A - simple mint

In this scenario, Benji wants to mint an NFT to Mike with a token ID `"team-token"` and he doesn't include a message. The log should look as follows.

```rust
EVENT_JSON:{
  "standard": "nep171",
  "version": "1.0.0",
  "event": "nft_mint",
  "data": [
    {"owner_id": "mike.testnet", "token_ids": ["team-token"]}
  ]
}
```

#### Scenario B - batch mint

In this scenario, Benji wants to perform a batch mint. He will mint an NFT to Mike, Damian, Josh, and Dorian. Dorian, however, will get two NFTs. Each token ID will be `"team-token"` followed by an incrementing number. The log is as follows.

```rust
EVENT_JSON:{
  "standard": "nep171",
  "version": "1.0.0",
  "event": "nft_mint",
  "data": [
    {"owner_id": "mike.testnet", "token_ids": ["team-token0"]},
    {"owner_id": "damian.testnet", "token_ids": ["team-token1"]},
    {"owner_id": "josh.testnet", "token_ids": ["team-token2"]}
    {"owner_id": "dorian.testnet", "token_ids": ["team-token3", "team-token4"]},
  ]
}
```

#### Scenario C - transfer NFTs

In this scenario, Mike is transferring both his team tokens to Josh. The log should look as follows.

```rust
EVENT_JSON:{
  "standard": "nep171",
  "version": "1.0.0",
  "event": "nft_transfer",
  "data": [
    {"old_owner_id": "mike.testnet", "new_owner_id": "josh.testnet", "token_ids": ["team-token", "team-token0"], "memo": "Go Team!"}
  ]
}
```

---

## Modifications to the contract {#modifications-to-the-contract}

At this point, you should have a good understanding of what the end goal should be so let's get to work! Open the repository and create a new file in the `nft-contract-basic/src` directory called `events.rs`. This is where your log structs will live.

If you wish to see the finished code of the events implementation, that can be found on the `nft-contract-events` folder.

### Creating the events file {#events-rs}

Copy the following into your file. This will outline the structs for your `EventLog`, `NftMintLog`, and `NftTransferLog`. In addition, we've added a way for `EVENT_JSON:` to be prefixed whenever you log the `EventLog`. 

<Github language="rust" start="1" end="79" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-events/src/events.rs" />

This requires the `serde_json` package which you can easily add to your `nft-contract-skeleton/Cargo.toml` file: 

<Github language="rust" start="10" end="12" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-events/Cargo.toml" />

<hr class="subsection" />

### Adding modules and constants {#lib-rs}

Now that you've created a new file, you need to add the module to the `lib.rs` file. In addition, you can define two constants for the standard and version that will be used across our contract.

<Github language="rust" start="10" end="30" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-events/src/lib.rs" />

<hr class="subsection" />

### Logging minted tokens {#logging-minted-tokens}

Now that all the tools are set in place, you can now implement the actual logging functionality. Since the contract will only be minting tokens in one place, open the `nft-contract-basic/src/mint.rs` file and navigate to the bottom of the file. This is where you'll construct the log for minting. Anytime someone successfully mints an NFT, it will now correctly emit a log.

<Github language="rust" start="5" end="58" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-events/src/mint.rs" />

<hr class="subsection" />

### Logging transfers {#logging-transfers}

Let's open the `nft-contract-basic/src/internal.rs` file and navigate to the `internal_transfer` function. This is the location where you'll build your transfer logs. Whenever an NFT is transferred, this function is called and so you'll correctly be logging the transfers.

<Github language="rust" start="96" end="159" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-events/src/internal.rs" />

This solution, unfortunately, has an edge case which will break things. If an NFT is transferred via the `nft_transfer_call` function, there's a chance that the transfer will be reverted if the `nft_on_transfer` function returns `true`. Taking a look at the logic for `nft_transfer_call`, you can see why this is a problem.

When `nft_transfer_call` is invoked, it will: 
- Call `internal_transfer` to perform the actual transfer logic.
- Initiate a cross-contract call and invoke the `nft_on_transfer` function.
- Resolve the promise and perform logic in `nft_resolve_transfer`.
    - This will either return true meaning the transfer went fine or it will revert the transfer and return false.

If you only place the log in the `internal_transfer` function, the log will be emitted and the indexer will think that the NFT was transferred. If the transfer is reverted during `nft_resolve_transfer`, however, that event should **also** be emitted. Anywhere that an NFT **could** be transferred, we should add logs. Replace the `nft_resolve_transfer` with the following code.

<Github language="rust" start="157" end="241" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-events/src/nft_core.rs" />

In addition, you need to add an `authorized_id` and `memo` to the parameters for `nft_resolve_transfer` as shown below.

:::tip

We will talk more about this [`authorized_id`](./5-approval.md) in the following chapter.

:::

<Github language="rust" start="43" end="60" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-events/src/nft_core.rs" />

The last step is to modify the `nft_transfer_call` logic to include these new parameters:

<Github language="rust" start="86" end="135" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-events/src/nft_core.rs" />

With that finished, you've successfully implemented the events standard and it's time to start testing.

---

## Deploying the contract {#redeploying-contract}

For the purpose of readability and ease of development, instead of redeploying the contract to the same account, let's create an account and deploy to that instead. You could have deployed to the same account as none of the changes you implemented in this tutorial would have caused errors.

### Deployment

Next, you'll deploy this contract to the network.

```bash
export EVENTS_NFT_CONTRACT_ID=<accountId>
near create-account $EVENTS_NFT_CONTRACT_ID --useFaucet
```

Using the cargo-near, deploy and initialize the contract as you did in the previous tutorials:

```bash
cargo near deploy $EVENTS_NFT_CONTRACT_ID with-init-call new_default_meta json-args '{"owner_id": "'$EVENTS_NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

<hr class="subsection" />

### Minting {#minting}

Next, you'll need to mint a token. By running this command, you'll mint a token with a token ID `"events-token"` and the receiver will be your new account. In addition, you're passing in a map with two accounts that will get perpetual royalties whenever your token is sold.

```bash
near call $EVENTS_NFT_CONTRACT_ID nft_mint '{"token_id": "events-token", "metadata": {"title": "Events Token", "description": "testing out the new events extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$EVENTS_NFT_CONTRACT_ID'"}' --accountId $EVENTS_NFT_CONTRACT_ID --amount 0.1
```

You can check to see if everything went through properly by looking at the output in your CLI:

```bash
Doing account.functionCall()
Receipts: F4oxNfv54cqwUwLUJ7h74H1iE66Y3H7QDfZMmGENwSxd, BJxKNFRuLDdbhbGeLA3UBSbL8UicU7oqHsWGink5WX7S
	Log [events.goteam.examples.testnet]: EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"events.goteam.examples.testnet","token_ids":["events-token"]}]}
Transaction Id 4Wy2KQVTuAWQHw5jXcRAbrz7bNyZBoiPEvLcGougciyk
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/4Wy2KQVTuAWQHw5jXcRAbrz7bNyZBoiPEvLcGougciyk
''
```

You can see that the event was properly logged!

<hr class="subsection" />

### Transferring {#transferring}

You can now test if your transfer log works as expected by sending `benjiman.testnet` your NFT.

```bash
near call $EVENTS_NFT_CONTRACT_ID nft_transfer '{"receiver_id": "benjiman.testnet", "token_id": "events-token", "memo": "Go Team :)", "approval_id": 0}' --accountId $EVENTS_NFT_CONTRACT_ID --depositYocto 1
```

This should return an output similar to the following:

```bash
Doing account.functionCall()
Receipts: EoqBxrpv9Dgb8KqK4FdeREawVVLWepEUR15KPNuZ4fGD, HZ4xQpbgc8EfU3PiV72LvfXb2f3dVC1n9aVTbQds9zfR
	Log [events.goteam.examples.testnet]: Memo: Go Team :)
	Log [events.goteam.examples.testnet]: EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"authorized_id":"events.goteam.examples.testnet","old_owner_id":"events.goteam.examples.testnet","new_owner_id":"benjiman.testnet","token_ids":["events-token"],"memo":"Go Team :)"}]}
Transaction Id 4S1VrepKzA6HxvPj3cK12vaT7Dt4vxJRWESA1ym1xdvH
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/4S1VrepKzA6HxvPj3cK12vaT7Dt4vxJRWESA1ym1xdvH
''
```

Hurray! At this point, your NFT contract is fully complete and the events standard has been implemented.

---

## Conclusion

Today you went through the [events standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event) and implemented the necessary logic in your smart contract. You created events for [minting](#logging-minted-tokens) and [transferring](#logging-transfers) NFTs. You then deployed and [tested](#initialization-and-minting) your changes by minting and transferring NFTs.

In the next tutorial, you'll look at the basics of a marketplace contract and how it was built.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- cargo-near `0.6.1`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.1.0`
- Events standard: [NEP297 extension](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event), version `1.1.0`

:::

'''
'''--- docs/3.tutorials/nfts/8-marketplace.md ---
---
id: marketplace
title: Marketplace
sidebar_label: Marketplace
---
import {Github} from "@site/src/components/codetabs"

In this tutorial, you'll learn the basics of an NFT marketplace contract where you can buy and sell non-fungible tokens for $NEAR. In the previous tutorials, you went through and created a fully fledged NFT contract that incorporates all the standards found in the [NFT standard](https://nomicon.io/Standards/NonFungibleToken). 

---

## Introduction

Throughout this tutorial, you'll learn how a marketplace contract **could** work on NEAR. This is meant to be **an example** as there is no **canonical implementation**. Feel free to branch off and modify this contract to meet your specific needs.

```bash
cd market-contract/
```

This folder contains both the actual contract code and dependencies as outlined below.

```
market-contract
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ external.rs
    ‚îú‚îÄ‚îÄ internal.rs
    ‚îú‚îÄ‚îÄ lib.rs
    ‚îú‚îÄ‚îÄ nft_callbacks.rs
    ‚îú‚îÄ‚îÄ sale.rs
    ‚îî‚îÄ‚îÄ sale_views.rs
```

---

## Understanding the contract

At first, the contract can be quite overwhelming but if you strip away all the fluff and dig into the core functionalities, it's actually quite simple. This contract was designed for only one thing - to allow people to buy and sell NFTs for NEAR. This includes the support for paying royalties, updating the price of your sales, removing sales and paying for storage.

Let's go through the files and take note of some of the important functions and what they do.

---

## lib.rs {#lib-rs}

This file outlines what information is stored on the contract as well as some other crucial functions that you'll learn about below.

### Initialization function {#initialization-function}

The first function you'll look at is the initialization function. This takes an `owner_id` as the only parameter and will default all the storage collections to their default values.

<Github language="rust" start="92" end="107" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/lib.rs" />

<hr className="subsection" />

### Storage management model {#storage-management-model}

Next, let's talk about the storage management model chosen for this contract. On the NFT contract, users attached $NEAR to the calls that needed storage paid for. For example, if someone was minting an NFT, they would need to attach `x` amount of NEAR to cover the cost of storing the data on the contract. 

On this marketplace contract, however, the storage model is a bit different. Users will need to deposit $NEAR onto the marketplace to cover the storage costs. Whenever someone puts an NFT for sale, the marketplace needs to store that information which costs $NEAR. Users can either deposit as much NEAR as they want so that they never have to worry about storage again or they can deposit the minimum amount to cover 1 sale on an as-needed basis. 

You might be thinking about the scenario when a sale is purchased. What happens to the storage that is now being released on the contract? This is why we've introduced a storage withdrawal function. This allows users to withdraw any excess storage that is not being used. Let's go through some scenarios to understand the logic. The required storage for 1 sale is 0.01 NEAR on the marketplace contract.

**Scenario A**

- Benji wants to list his NFT on the marketplace but has never paid for storage. 
- He deposits exactly 0.01 NEAR using the `storage_deposit` method. This will cover 1 sale.
- He lists his NFT on the marketplace and is now using up 1 out of his prepaid 1 sales and has no more storage left. If he were to call `storage_withdraw`, nothing would happen.
- Dorian loves his NFT and quickly purchases it before anybody else can. This means that Benji's sale has now been taken down (since it was purchased) and Benji is using up 0 out of his prepaid 1 sales. In other words, he has an excess of 1 sale or 0.01 NEAR.
- Benji can now call `storage_withdraw` and will be transferred his 0.01 NEAR back. On the contract's side, after withdrawing, he will have 0 sales paid for and will need to deposit storage before trying to list anymore NFTs.

**Scenario B**

- Dorian owns one hundred beautiful NFTs and knows that he wants to list all of them.
- To avoid having to call `storage_deposit` everytime he wants to list an NFT, he calls it once. Since Dorian is a baller, he attaches 10 NEAR which is enough to cover 1000 sales. Then he lists his 100 NFTs and now he has an excess of 9 NEAR or 900 sales.
- Dorian needs the 9 NEAR for something else but doesn't want to take down his 100 listings. Since he has an excess of 9 NEAR, he can easily withdraw and still have his 100 listings. After calling `storage_withdraw` and being transferred 9 NEAR, he will have an excess of 0 sales.

With this behavior in mind, the following two functions outline the logic.

<Github language="rust" start="111" end="139" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/lib.rs" />
<Github language="rust" start="144" end="175" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/lib.rs" />

In this contract, the storage required for each sale is 0.01 NEAR but you can query that information using the `storage_minimum_balance` function. In addition, if you wanted to check how much storage a given account has paid, you can query the `storage_balance_of` function.

With that out of the way, it's time to move onto the `sale.rs` file where you'll look at how NFTs are put for sale.

---

## sale.rs {#sale}

This file is responsible for the internal marketplace logic.

### Listing logic {#listing-logic}

In order to put an NFT on sale, a user should:

1. Approve the marketplace contract on an NFT token (by calling `nft_approve` method on the NFT contract)
2. Call the `list_nft_for_sale` method on the marketplace contract.

#### nft_approve
This method has to be called by the user to [approve our marketplace](5-approval.md), so it can transfer the NFT on behalf of the user. In our contract, we only need to implement the `nft_on_approve` method, which is called by the NFT contract when the user approves our contract.

In our case, we left it blank, but you could implement it to do some additional logic when the user approves your contract.

<Github language="rust" start="23" end="33" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/nft_callbacks.rs" />

#### list_nft_for_sale
The `list_nft_for_sale` method lists an nft for sale, for this, it takes the id of the NFT contract (`nft_contract_id`), the `token_id` to know which token is listed, the [`approval_id`](5-approval.md), and the price in yoctoNEAR at which we want to sell the NFT.

<Github language="rust" start="33" end="74" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/sale.rs" />

The function first checks if the user has [enough storage available](#storage-management-model-storage-management-model), and makes two calls in parallel to the NFT contract. The first is to check if this marketplace contract is authorized to transfer the NFT. The second is to make sure that the caller (`predecessor`) is actually the owner of the NFT, otherwise, anyone could call this method to create fake listings. This second call is mostly a measure to avoid spam, since anyways, only the owner could approve the marketplace contract to transfer the NFT.

Both calls return their results to the `process_listing` function, which executes the logic to store the sale object on the contract.

#### process_listing

The `process_listing` function will receive if our marketplace is authorized to list the NFT on sale, and if this was requested by the NFTs owner. If both conditions are met, it will proceed to check if the user has enough storage, and store the sale object on the contract.

<Github language="rust" start="264" end="344" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/sale.rs" />

<hr class="subsection" />

### Sale object {#sale-object}

It's important to understand what information the contract is storing for each sale object. Since the marketplace has many NFTs listed that come from different NFT contracts, simply storing the token ID would not be enough to distinguish between different NFTs. This is why you need to keep track of both the token ID and the contract by which the NFT came from. In addition, for each listing, the contract must keep track of the approval ID it was given to transfer the NFT. Finally, the owner and sale conditions are needed.

<Github language="rust" start="5" end="20" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/sale.rs" />

<hr className="subsection" />

### Removing sales {#removing-sales}

In order to remove a listing, the owner must call the `remove_sale` function and pass the NFT contract and token ID. Behind the scenes, this calls the `internal_remove_sale` function which you can find in the `internal.rs` file. This will assert one yoctoNEAR for security reasons.

<Github language="rust" start="76" end="87" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/sale.rs" />

<hr className="subsection" />

### Updating price {#updating-price}

In order to update the list price of a token, the owner must call the `update_price` function and pass in the contract, token ID, and desired price. This will get the sale object, change the sale conditions, and insert it back. For security reasons, this function will assert one yoctoNEAR.

<Github language="rust" start="90" end="118" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/sale.rs" />

<hr className="subsection" />

### Purchasing NFTs {#purchasing-nfts}

For purchasing NFTs, you must call the `offer` function. It takes an `nft_contract_id` and `token_id` as parameters. You must attach the correct amount of NEAR to the call in order to purchase. Behind the scenes, this will make sure your deposit is greater than the list price and call a private method `process_purchase` which will perform a cross-contract call to the NFT contract to invoke the `nft_transfer_payout` function. This will transfer the NFT using the [approval management](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement) standard that you learned about and it will return the `Payout` object which includes royalties.

The marketplace will then call `resolve_purchase` where it will check for malicious payout objects and then if everything went well, it will pay the correct accounts.

<Github language="rust" start="121" end="151" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/sale.rs" />

---

## sale_view.rs {#sale_view-rs}

The final file is [`sale_view.rs`](https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/sale_view.rs) file. This is where some of the enumeration methods are outlined. It allows users to query for important information regarding sales.

---

## Deployment and Initialization

Next, you'll deploy this contract to the network.

```bash
export MARKETPLACE_CONTRACT_ID=<accountId>
near create-account $MARKETPLACE_CONTRACT_ID --useFaucet
```

Using the build script, deploy the contract as you did in the previous tutorials:

```bash
near deploy $MARKETPLACE_CONTRACT_ID out/market.wasm
cargo near deploy $MARKETPLACE_CONTRACT_ID with-init-call new json-args '{"owner_id": "'$MARKETPLACE_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

<hr className="subsection" />

### Minting and approving

Let's mint a new NFT token and approve a marketplace contract:

```bash
near call $NFT_CONTRACT_ID nft_mint '{"token_id": "token-1", "metadata": {"title": "My Non Fungible Team Token", "description": "The Team Most Certainly Goes :)", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$NFT_CONTRACT_ID'"}' --accountId $NFT_CONTRACT_ID --amount 0.1

near call $NFT_CONTRACT_ID nft_approve '{"token_id": "token-1", "account_id": "'$MARKETPLACE_CONTRACT_ID'"}' --accountId $NFT_CONTRACT_ID --deposit 0.1
```

<hr className="subsection" />

### Listing NFT on sale

```bash
near call $MARKETPLACE_CONTRACT_ID list_nft_for_sale '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "token-1", "approval_id": 0, "msg": "{\"sale_conditions\": \"1\"}"}' --accountId $NFT_CONTRACT_ID --gas 30000000000000
```

<hr className="subsection" />

### Total supply {#total-supply}

To query for the total supply of NFTs listed on the marketplace, you can call the `get_supply_sales` function. An example can be seen below.

```bash
near view $MARKETPLACE_CONTRACT_ID get_supply_sales
```

<hr className="subsection" />

### Total supply by owner {#total-supply-by-owner}

To query for the total supply of NFTs listed by a specific owner on the marketplace, you can call the `get_supply_by_owner_id` function. An example can be seen below.

```bash
near view $MARKETPLACE_CONTRACT_ID get_supply_by_owner_id '{"account_id": "'$NFT_CONTRACT_ID'"}'
```

<hr className="subsection" />

### Total supply by contract {#total-supply-by-contract}

To query for the total supply of NFTs that belong to a specific contract, you can call the `get_supply_by_nft_contract_id` function. An example can be seen below.

```bash
near view $MARKETPLACE_CONTRACT_ID get_supply_by_nft_contract_id '{"nft_contract_id": "'$NFT_CONTRACT_ID'"}'
```

<hr className="subsection" />

### Query for listing information {#query-listing-information}

To query for important information for a specific listing, you can call the `get_sale` function. This requires that you pass in the `nft_contract_token`. This is essentially the unique identifier for sales on the market contract as explained earlier. It consists of the NFT contract followed by a `DELIMITER` followed by the token ID. In this contract, the `DELIMITER` is simply a period: `.`.  An example of this query can be seen below.

```bash
near view $MARKETPLACE_CONTRACT_ID get_sale '{"nft_contract_token": "'$NFT_CONTRACT_ID'.token-1"}'
```

In addition, you can query for paginated information about the listings for a given owner by calling the `get_sales_by_owner_id` function.

```bash
near view $MARKETPLACE_CONTRACT_ID get_sales_by_owner_id '{"account_id": "'$NFT_CONTRACT_ID'", "from_index": "0", "limit": 5}'
```

Finally, you can query for paginated information about the listings that originate from a given NFT contract by calling the `get_sales_by_nft_contract_id` function.

```bash
near view $MARKETPLACE_CONTRACT_ID get_sales_by_nft_contract_id '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "from_index": "0", "limit": 5}'
```

---

## Conclusion

In this tutorial, you learned about the basics of a marketplace contract and how it works. You went through the [lib.rs](#lib-rs) file and learned about the [initialization function](#initialization-function) in addition to the [storage management](#storage-management-model) model. 

You went through the [NFTs listing process](#listing-logic). In addition, you went through some important functions needed after you've listed an NFT. This includes [removing sales](#removing-sales), [updating the price](#updating-price), and [purchasing NFTs](#purchasing-nfts).

Finally, you went through the enumeration methods found in the [`sale_view`](#sale_view-rs) file. These allow you to query for important information found on the marketplace contract. 

You should now have a solid understanding of NFTs and marketplaces on NEAR. Feel free to branch off and expand on these contracts to create whatever cool applications you'd like. In the [next tutorial](9-series.md), you'll learn how to take the existing NFT contract and optimize it to allow for:
- Lazy Minting
- Creating Collections
- Allowlisting functionalities
- Optimized Storage Models

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- cargo-near `0.6.1`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.1.0`

:::

'''
'''--- docs/3.tutorials/nfts/9-series.md ---
---
id: series
title: Customizing the NFT Contract
sidebar_label: Lazy Minting, Collections, and More!
---
import {Github} from "@site/src/components/codetabs"

In this tutorial, you'll learn how to take the [existing NFT contract](https://github.com/near-examples/nft-tutorial) you've been working with and modify it to meet some of the most common needs in the ecosystem. This includes:
- Lazy Minting NFTs
- Creating Collections
- Restricting Minting Access
- Highly Optimizing Storage 
- Hacking Enumeration Methods

---

## Introduction

Now that you have a deeper understanding of basic NFT smart contracts, we can start to get creative and implement more unique features. The basic contract works really well for simple use-cases but as you begin to explore the potential of NFTs, you can use it as a foundation to build upon.

A fun analogy would be that you now have a standard muffin recipe and it's now up to you to decide how to alter it to create your own delicious varieties, may I suggest blueberry perhaps. 

Below we've created a few of these new varieties by showing potential solutions to the problems outlined above. As we demonstrate how to customize the basic NFT contract, we hope it activates your ingenuity thus introducing you to what's possible and helping you discover the true potential of NFTs. üí™

<hr class="subsection" />

### NFT Collections and Series

NFT Collections help solve two common problems when dealing with the basic NFT contract:
- Storing repeated data.
- Organizing data and code.

The concept of a collection in the NFT space has a very loose meaning and can be interpreted in many different ways. In our case, we'll define a collection as a set of tokens that share **similar metadata**. For example, you could create a painting and want 100 identical copies to be put for sale. In this case, all one hundred pieces would be part of the same *collection*. Each piece would have the same artist, title, description, media etc.

One of the biggest problems with the basic NFT contract is that you store similar data many times. If you mint NFTs, the contract will store the metadata individually for **every single token ID**. We can fix this by introducing the idea of NFT series, or NFT collection. 

A series can be thought of as a bucket of token IDs that *all* share similar information. This information is specified when the series is **created** and can be the metadata, royalties, price etc. Rather than storing this information for **every token ID**, you can simply store it once in the series and then associate token IDs with their respective buckets.

<hr class="subsection" />

### Restricted Access

Currently, the NFT contract allows anyone to mint NFTs. While this works well for some projects, the vast majority of dApps and creators want to restrict who can create NFTs on the contract. This is why you'll introduce an allowlist functionality for both series and for NFTs. You'll have two data structures customizable by the contract owner:
- Approved Minters
- Approved Creators

If you're an approved minter, you can freely mint NFTs for any given series. You cannot, however, create new series.

On the other hand, you can also be an approved creator. This allows you to define new series that NFTs can be minted from. It's important to note that if you're an approved creator, you're not automatically an approved minter as well. Each of these permissions need to be given by the owner of the contract and they can be revoked at any time.

<hr class="subsection" />

### Lazy Minting

Lazy minting allows users to mint *on demand*. Rather than minting all the NFTs and spending $NEAR on storage, you can instead mint the tokens **when they are purchased**. This helps to avoid burning unnecessary Gas and saves on storage for when not all the NFTs are purchased. Let's look at a common scenario to help solidify your understanding:

Benji has created an amazing digital painting of the famous Go Team gif. He wants to sell 1000 copies of it for 1 $NEAR each. Using the traditional approach, he would have to mint each copy individually and pay for the storage himself. He would then need to either find or deploy a marketplace contract and pay for the storage to put 1000 copies up for sale. He would need to burn Gas putting each token ID up for sale 1 by 1. 

After that, people would purchase the NFTs, and there would be no guarantee that all or even any would be sold. There's a real possibility that nobody buys a single piece of his artwork, and Benji spent all that time, effort and money on nothing.  

Lazy minting would allow the NFTs to be *automatically minted on-demand*. Rather than having to purchase NFTs from a marketplace, Benji could specify a price on the NFT contract and a user could directly call the `nft_mint` function whereby the funds would be distributed to Benji's account directly.

Using this model, NFTs would **only** be minted when they're actually purchased and there wouldn't be any upfront fee that Benji would need to pay in order to mint all 1000 NFTs. In addition, it removes the need to have a separate marketplace contract.

With this example laid out, a high level overview of lazy minting is that it gives the ability for someone to mint "on-demand" - they're lazily minting the NFTs instead of having to mint everything up-front even if they're unsure if there's any demand for the NFTs. With this model, you don't have to waste Gas or storage fees because you're only ever minting when someone actually purchases the artwork.

---

## New Contract File Structure

Let's now take a look at how we've implemented solutions to the issues we've discussed so far. 
	
In your locally cloned example of the [`nft-tutorial`](https://github.com/near-examples/nft-tutorial) check out the `main` branch and be sure to pull the most recent version.

```bash
git checkout main && git pull
```

You'll notice that there's a folder at the root of the project called `nft-series`. This is where the smart contract code lives. If you open the `src` folder, it should look similar to the following:

```
src
‚îú‚îÄ‚îÄ approval.rs
‚îú‚îÄ‚îÄ enumeration.rs
‚îú‚îÄ‚îÄ events.rs
‚îú‚îÄ‚îÄ internal.rs
‚îú‚îÄ‚îÄ lib.rs
‚îú‚îÄ‚îÄ metadata.rs
‚îú‚îÄ‚îÄ nft_core.rs
‚îú‚îÄ‚îÄ owner.rs
‚îú‚îÄ‚îÄ royalty.rs
‚îú‚îÄ‚îÄ series.rs
```

---

## Differences

You'll notice that most of this code is the same, however, there are a few differences between this contract and the basic NFT contract. 

### Main Library File

Starting with `lib.rs`, you'll notice that the contract struct has been modified to now store the following information.

```diff
pub owner_id: AccountId,
+ pub approved_minters: LookupSet<AccountId>,
+ pub approved_creators: LookupSet<AccountId>,
pub tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,
pub tokens_by_id: UnorderedMap<TokenId, Token>,
- pub token_metadata_by_id: UnorderedMap<TokenId, TokenMetadata>,
+ pub series_by_id: UnorderedMap<SeriesId, Series>,
pub metadata: LazyOption<NFTContractMetadata>,
```

As you can see, we've replaced `token_metadata_by_id` with `series_by_id` and added two lookup sets:

- **series_by_id**: Map a series ID (u64) to its Series object.
- **approved_minters**: Keeps track of accounts that can call the `nft_mint` function.
- **approved_creators**: Keeps track of accounts that can create new series.

<hr class="subsection" />

### Series Object {#series-object}
In addition, we're now keeping track of a new object called a `Series`.

```rust
pub struct Series {
    // Metadata including title, num copies etc.. that all tokens will derive from
    metadata: TokenMetadata,
    // Royalty used for all tokens in the collection
    royalty: Option<HashMap<AccountId, u32>>,
    // Set of tokens in the collection
    tokens: UnorderedSet<TokenId>,
    // What is the price of each token in this series? If this is specified, when minting,
    // Users will need to attach enough $NEAR to cover the price.
    price: Option<Balance>,
    // Owner of the collection
    owner_id: AccountId,
}
```

This object stores information that each token will inherit from. This includes:
- The [metadata](2-minting.md#metadata-and-token-info).
- The [royalties](6-royalty.md).
- The price.

:::caution
If a price is specified, there will be no restriction on who can mint tokens in the series. In addition, if the `copies` field is specified in the metadata, **only** that number of NFTs can be minted. If the field is omitted, an unlimited amount of tokens can be minted.
:::

We've also added a field `tokens` which keeps track of all the token IDs that have been minted for this series. This allows us to deal with the potential `copies` cap by checking the length of the set. It also allows us to paginate through all the tokens in the series.

<hr class="subsection" />

### Creating Series

`series.rs` is a new file that replaces the old [minting](2-minting.md) logic. This file has been created to combine both the series creation and minting logic into one.

<Github language="rust" start="10" end="56" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/series.rs" />

The function takes in a series ID in the form of a [u64](https://doc.rust-lang.org/std/primitive.u64.html), the metadata, royalties, and the price for tokens in the series. It will then create the [Series object](#series-object) and insert it into the contract's series_by_id data structure. It's important to note that the caller must be an approved creator and they must attach enough $NEAR to cover storage costs.

<hr class="subsection" />

### Minting NFTs

Next, we'll look at the minting function. If you remember from before, this used to take the following parameters:
- Token ID
- Metadata
- Receiver ID
- Perpetual Royalties 

With the new and improved minting function, these parameters have been changed to just two:
- The series ID
- The receiver ID.

The mint function might look complicated at first but let's break it down to understand what's happening. The first thing it does is get the [series object](#series-object) from the specified series ID. From there, it will check that the number of copies won't be exceeded if one is specified in the metadata. 

It will then store the token information on the contract as explained in the [minting section](2-minting.md#storage-implications) of the tutorial and map the token ID to the series. Once this is finished, a mint log will be emitted and it will ensure that enough deposit has been attached to the call. This amount differs based on whether or not the series has a price.

#### Required Deposit

As we went over in the [minting section](2-minting.md#storage-implications) of this tutorial, all information stored on the contract costs $NEAR. When minting, there is a required deposit to pay for this storage. For *this contract*, a series price can also be specified by the owner when the series is created. This price will be used for **all** NFTs in the series when they are minted. If the price is specified, the deposit must cover both the storage as well as the price.

If a price **is specified** and the user attaches more deposit than what is necessary, the excess is sent to the **series owner**. There is also *no restriction* on who can mint tokens for series that have a price. The caller does **not** need to be an approved minter.

If **no price** was specified in the series and the user attaches more deposit than what is necessary, the excess is *refunded to them*. In addition, the contract makes sure that the caller is an approved minter in this case.

:::info
Notice how the token ID isn't required? This is because the token ID is automatically generated when minting. The ID stored on the contract is `${series_id}:${token_id}` where the token ID is a nonce that increases each time a new token is minted in a series. This not only reduces the amount of information stored on the contract but it also acts as a way to check the specific edition number.
:::

<Github language="rust" start="60" end="147" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/series.rs" />

<hr class="subsection" />

### View Functions

Now that we've introduced the idea of series, more view functions have also been added.

:::info
Notice how we've also created a new struct `JsonSeries` instead of returning the regular `Series` struct. This is because the `Series` struct contains an `UnorderedSet` which cannot be serialized.

The common practice is to return everything **except** the `UnorderedSet` in a separate struct and then have entirely different methods for accessing the data from the `UnorderedSet` itself.
<!-- TODO: add a learn more here call to action -->
:::

<Github language="rust" start="6" end="17" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs" />

The view functions are listed below.
- **[get_series_total_supply](https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs#L92)**: Get the total number of series currently on the contract.
  - Arguments: None.
- **[get_series](https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs#L97)**: Paginate through all the series in the contract and return a vector of `JsonSeries` objects.
  - Arguments: `from_index: String | null`, `limit: number | null`.
- **[get_series_details](https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs#L115)**: Get the `JsonSeries` details for a specific series.
  - Arguments: `id: number`.
- **[nft_supply_for_series](https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs#L133)**: View the total number of NFTs minted for a specific series.
  - Arguments: `id: number`.
- **[nft_tokens_for_series](https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs#L146)**: Paginate through all NFTs for a specific series and return a vector of `JsonToken` objects.
  - Arguments: `id: number`, `from_index: String | null`, `limit: number | null`.

:::info
Notice how with every pagination function, we've also included a getter to view the total supply. This is so that you can use the `from_index` and `limit` parameters of the pagination functions in conjunction with the total supply so you know where to end your pagination.
:::

<hr class="subsection" />

### Modifying View Calls for Optimizations

Storing information on-chain can be very expensive. As you level up in your smart contract development skills, one area to look into is reducing the amount of information stored. View calls are a perfect example of this optimization.

For example, if you wanted to relay the edition number for a given NFT in its title, you don't necessarily need to store this on-chain for every token. Instead, you could modify the view functions to manually append this information to the title before returning it.

To do this, here's a way of modifying the `nft_token` function as it's central to all enumeration methods.

<Github language="rust" start="156" end="192" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/nft_core.rs" />

For example if a token had a title `"My Amazing Go Team Gif"` and the NFT was edition 42, the new title returned would be `"My Amazing Go Team Gif - 42"`. If the NFT didn't have a title in the metadata, the series and edition number would be returned in the form of `Series {} : Edition {}`.

While this is a small optimization, this idea is extremely powerful as you can potentially save on a ton of storage. As an example: most of the time NFTs don't utilize the following fields in their metadata.
- issued_at
- expires_at
- starts_at
- updated_at

As an optimization, you could change the token metadata that's **stored** on the contract to not include these fields but then when returning the information in `nft_token`, you could simply add them in as `null` values.

<hr class="subsection" />

### Owner File

The last file we'll look at is the owner file found at `owner.rs`. This file simply contains all the functions for getting and setting approved creators and approved minters which can only be called by the contract owner.

:::info
There are some other smaller changes made to the contract that you can check out if you'd like. The most notable are:
- The `Token` and `JsonToken` objects have been [changed](https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/metadata.rs#L40) to reflect the new series IDs.
- All references to `token_metadata_by_id` have been [changed](https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs#L23) to `tokens_by_id`
- Royalty functions [now](https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/royalty.rs#L43) calculate the payout objects by using the series' royalties rather than the token's royalties.
:::

---

## Building the Contract

Now that you hopefully have a good understanding of the contract, let's get started building it. Run the following build command to compile the contract to wasm.

```bash
cargo near build
```

---

## Deployment and Initialization

Next, you'll deploy this contract to the network.

```bash
export NFT_CONTRACT_ID=<accountId>
near create-account $NFT_CONTRACT_ID --useFaucet
```

Check if this worked correctly by echoing the environment variable.
```bash
echo $NFT_CONTRACT_ID
```
This should return your `<accountId>`. The next step is to initialize the contract with some default metadata.

```bash
cargo near deploy $NFT_CONTRACT_ID with-init-call new_default_meta json-args '{"owner_id": "'$NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

If you now query for the metadata of the contract, it should return our default metadata.
```bash
near view $NFT_CONTRACT_ID nft_metadata
```

---

## Creating The Series

The next step is to create two different series. One will have a price for lazy minting and the other will simply be a basic series with no price. The first step is to create an owner [sub-account](../../4.tools/cli.md#create-a-sub-account) that you can use to create both series

```bash
near create-account owner.$NFT_CONTRACT_ID --masterAccount $NFT_CONTRACT_ID --initialBalance 3 && export SERIES_OWNER=owner.$NFT_CONTRACT_ID
```

### Basic Series

You'll now need to create the simple series with no price and no royalties. If you try to run the following command before adding the owner account as an approved creator, the contract should throw an error.

```bash
near call $NFT_CONTRACT_ID create_series '{"id": 1, "metadata": {"title": "SERIES!", "description": "testing out the new series contract", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}}' --accountId $SERIES_OWNER --amount 1
```

The expected output is an error thrown: `ExecutionError: 'Smart contract panicked: only approved creators can add a type`. If you now add the series owner as a creator, it should work.

```bash
near call $NFT_CONTRACT_ID add_approved_creator '{"account_id": "'$SERIES_OWNER'"}' --accountId $NFT_CONTRACT_ID
```
```bash
near call $NFT_CONTRACT_ID create_series '{"id": 1, "metadata": {"title": "SERIES!", "description": "testing out the new series contract", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}}' --accountId $SERIES_OWNER --amount 1
```

If you now query for the series information, it should work!

```bash
near view $NFT_CONTRACT_ID get_series
```
Which should return something similar to:
```bash
[
  {
    series_id: 1,
    metadata: {
      title: 'SERIES!',
      description: 'testing out the new series contract',
      media: 'https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif',
      media_hash: null,
      copies: null,
      issued_at: null,
      expires_at: null,
      starts_at: null,
      updated_at: null,
      extra: null,
      reference: null,
      reference_hash: null
    },
    royalty: null,
    owner_id: 'owner.nft_contract.testnet'
  }
]
```

<hr class="subsection" />

### Series With a Price

Now that you've created the first, simple series, let's create the second one that has a price of 1 $NEAR associated with it. 

```bash
near call $NFT_CONTRACT_ID create_series '{"id": 2, "metadata": {"title": "COMPLEX SERIES!", "description": "testing out the new contract with a complex series", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "price": "500000000000000000000000"}' --accountId $SERIES_OWNER --amount 1
```

If you now paginate through the series again, you should see both appear.
```bash
near view $NFT_CONTRACT_ID get_series
```

Which has

```bash
[
  {
    series_id: 1,
    metadata: {
      title: 'SERIES!',
      description: 'testing out the new series contract',
      media: 'https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif',
      media_hash: null,
      copies: null,
      issued_at: null,
      expires_at: null,
      starts_at: null,
      updated_at: null,
      extra: null,
      reference: null,
      reference_hash: null
    },
    royalty: null,
    owner_id: 'owner.nft_contract.testnet'
  },
  {
    series_id: 2,
    metadata: {
      title: 'COMPLEX SERIES!',
      description: 'testing out the new contract with a complex series',
      media: 'https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif',
      media_hash: null,
      copies: null,
      issued_at: null,
      expires_at: null,
      starts_at: null,
      updated_at: null,
      extra: null,
      reference: null,
      reference_hash: null
    },
    royalty: null,
    owner_id: 'owner.nft_contract.testnet'
  }
]
```

---

## Minting NFTs

Now that you have both series created, it's time to now mint some NFTs. You can either login with an existing NEAR wallet using [`near login`](../../4.tools/cli.md#near-login) or you can create a sub-account of the NFT contract. In our case, we'll use a sub-account.

```bash
near create-account buyer.$NFT_CONTRACT_ID --masterAccount $NFT_CONTRACT_ID --initialBalance 1 && export BUYER_ID=buyer.$NFT_CONTRACT_ID
```

### Lazy Minting

The first workflow you'll test out is [lazy minting](#lazy-minting) NFTs. If you remember, the second series has a price associated with it of 1 $NEAR. This means that there are no minting restrictions and anyone can try and purchase the NFT. Let's try it out.
 
In order to view the NFT in the NEAR wallet, you'll want the `receiver_id` to be an account you have currently available in the wallet site. Let's export it to an environment variable. Run the following command but replace `YOUR_ACCOUNT_ID_HERE` with your actual NEAR account ID.

```bash
export NFT_RECEIVER_ID=YOUR_ACCOUNT_ID_HERE
```
Now if you try and run the mint command but don't attach enough $NEAR, it should throw an error.

```bash
near call $NFT_CONTRACT_ID nft_mint '{"id": "2", "receiver_id": "'$NFT_RECEIVER_ID'"}' --accountId $BUYER_ID
```

Run the command again but this time, attach 1.5 $NEAR.

```bash
near call $NFT_CONTRACT_ID nft_mint '{"id": "2", "receiver_id": "'$NFT_RECEIVER_ID'"}' --accountId $BUYER_ID --amount 0.6
```

This should output the following logs.

```bash
Receipts: BrJLxCVmxLk3yNFVnwzpjZPDRhiCinNinLQwj9A7184P, 3UwUgdq7i1VpKyw3L5bmJvbUiqvFRvpi2w7TfqmnPGH6
	Log [nft_contract.testnet]: EVENT_JSON:{"standard":"nep171","version":"nft-1.0.0","event":"nft_mint","data":[{"owner_id":"benjiman.testnet","token_ids":["2:1"]}]}
Transaction Id FxWLFGuap7SFrUPLskVr7Uxxq8hpDtAG76AvshWppBVC
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/FxWLFGuap7SFrUPLskVr7Uxxq8hpDtAG76AvshWppBVC
''
```

If you check the explorer link, it should show that the owner received on the order of `0.59305 $NEAR`. 

<img width="80%" src="/docs/assets/nfts/explorer-payout-series-owner.png" />

<hr class="subsection" />

### Becoming an Approved Minter

If you try to mint the NFT for the simple series with no price, it should throw an error saying you're not an approved minter.

```bash
near call $NFT_CONTRACT_ID nft_mint '{"id": "1", "receiver_id": "'$NFT_RECEIVER_ID'"}' --accountId $BUYER_ID --amount 0.1
```

Go ahead and run the following command to add the buyer account as an approved minter.

```bash
near call $NFT_CONTRACT_ID add_approved_minter '{"account_id": "'$BUYER_ID'"}' --accountId $NFT_CONTRACT_ID
```

If you now run the mint command again, it should work.

```bash
near call $NFT_CONTRACT_ID nft_mint '{"id": "1", "receiver_id": "'$NFT_RECEIVER_ID'"}' --accountId $BUYER_ID --amount 0.1
```

<hr class="subsection" />

### Viewing the NFTs in the Wallet

Now that you've received both NFTs, they should show up in the NEAR wallet. Open the collectibles tab and search for the contract with the title `NFT Series Contract` and you should own two NFTs. One should be the complex series and the other should just be the simple version. Both should have ` - 1` appended to the end of the title because the NFTs are the first editions for each series.

<img width="80%" src="/docs/assets/nfts/series-wallet-collectibles.png" />

Hurray! You've successfully deployed and tested the series contract! **GO TEAM!**.

---

## Conclusion

In this tutorial, you learned how to take the basic NFT contract and iterate on it to create a complex and custom version to meet the needs of the community. You optimized the storage, introduced the idea of collections, created a lazy minting functionality, hacked the enumeration functions to save on storage, and created an allowlist functionality.

You then built the contract and deployed it on chain. Once it was on-chain, you initialized it and created two sets of series. One was complex with a price and the other was a regular series. You lazy minted an NFT and purchased it for `1.5 $NEAR` and then added yourself as an approved minter. You then minted an NFT from the regular series and viewed them both in the NEAR wallet.

Thank you so much for going through this journey with us! I wish you all the best and am eager to see what sorts of neat and unique use-cases you can come up with. If you have any questions, feel free to ask on our [Discord](https://near.chat) or any other social media channels we have. If you run into any issues or have feedback, feel free to use the `Feedback` button on the right.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- cargo-near `0.6.1`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.1.0`

:::

'''
'''--- docs/3.tutorials/nfts/js/0-intro.md ---
---
id: introduction
title: NFT Zero to Hero JavaScript Edition
sidebar_label: Introduction
---

> In this _Zero to Hero_ series, you'll find a set of tutorials that will cover every aspect of a non-fungible token (NFT) smart contract.
> You'll start by minting an NFT using a pre-deployed contract and by the end you'll end up building a fully-fledged NFT smart contract that supports every extension.

## Prerequisites

To complete these tutorials successfully, you'll need:

- [Node.js](/build/smart-contracts/quickstart#prerequisites#nodejs)
- [A NEAR Wallet](https://testnet.mynearwallet.com/create)
- [NEAR-CLI](/tools/near-cli#setup)

---

## Overview

These are the steps that will bring you from **_Zero_** to **_Hero_** in no time! üí™

| Step | Name                                                             | Description                                                                                                            |
|------|------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------|
| 1    | [Pre-deployed contract](/tutorials/nfts/js/predeployed-contract) | Mint an NFT without the need to code, create, or deploy a smart contract.                                              |
| 2    | [Contract architecture](/tutorials/nfts/js/skeleton)             | Learn the basic architecture of the NFT smart contract and compile code.                                               |
| 3    | [Minting](/tutorials/nfts/js/minting)                            | Flesh out the skeleton so the smart contract can mint a non-fungible token.                                            |
| 4    | [Upgrade a contract](/tutorials/nfts/js/upgrade-contract)        | Discover the process to upgrade an existing smart contract.                                                            |
| 5    | [Enumeration](/tutorials/nfts/js/enumeration)                    | Explore enumeration methods that can be used to return the smart contract's states.                                    |
| 6    | [Core](/tutorials/nfts/js/core)                                  | Extend the NFT contract using the core standard which allows token transfer                                            |
| 7    | [Approvals](/tutorials/nfts/js/approvals)                        | Expand the contract allowing other accounts to transfer NFTs on your behalf.                                           |
| 8    | [Royalty](/tutorials/nfts/js/royalty)                            | Add NFT royalties allowing for a set percentage to be paid out to the token creator.                                   |
| 9    | [Events](/tutorials/nfts/js/events)                              | in this tutorial you'll explore the events extension, allowing the contract to react on certain events.                |
| 10   | [Marketplace](/tutorials/nfts/js/marketplace)                    | Learn about how common marketplaces operate on NEAR and dive into some of the code that allows buying and selling NFTs |

---

## Next steps

Ready to start? Jump to the [Pre-deployed Contract](/tutorials/nfts/js/predeployed-contract) tutorial and begin your learning journey!

If you already know about non-fungible tokens and smart contracts, feel free to skip and jump directly to the tutorial of your interest. The tutorials have been designed so you can start at any given point!

:::info Questions?
üëâ Join us on [Discord](https://near.chat/) and let us know in the `#development` channels. üëà

We also host daily [Office Hours](https://pages.near.org/developers/get-help/office-hours/) live where the DevRel team will answer any questions you may have. ü§î

Monday ‚Äì Friday 11AM ‚Äì 12PM Pacific (6PM ‚Äì 7PM UTC)
:::

'''
'''--- docs/3.tutorials/nfts/js/0-predeployed.md ---
---
id: predeployed-contract
title: Pre-deployed Contract
sidebar_label: Pre-deployed Contract
---

> Learn how to easily create your own non-fungible tokens without doing any software development by using a readily-available NFT smart contract.

## Prerequisites

To complete this tutorial successfully, you'll need:

- [A NEAR Wallet](https://testnet.mynearwallet.com/create)
- [NEAR-CLI](/tools/near-cli#setup)

## Using the NFT contract

### Setup

- Log in to your newly created account with `near-cli` by running the following command in your terminal:

```bash
near login
```

 - Set an environment variable for your account ID to make it easy to copy and paste commands from this tutorial:

```bash
export NEARID=YOUR_ACCOUNT_NAME
```
:::note

Be sure to replace `YOUR_ACCOUNT_NAME` with the account name you just logged in with including the `.testnet` (or `.near` for `mainnet`).

:::

- Test that the environment variable is set correctly by running:

```bash
echo $NEARID
```

### Minting your NFTs

NEAR has deployed an NFT contract to the account `nft.examples.testnet` which allows users to freely mint tokens. Using this pre-deployed contract, let's mint our first token! 

- Run this command in your terminal, however you **must replace the `token_id` value with an UNIQUE string**.

```bash
near call nft.examples.testnet nft_mint '{"token_id": "TYPE_A_UNIQUE_VALUE_HERE", "receiver_id": "'$NEARID'", "metadata": { "title": "GO TEAM", "description": "The Team Goes", "media": "https://bafybeidl4hjbpdr6u6xvlrizwxbrfcyqurzvcnn5xoilmcqbxfbdwrmp5m.ipfs.dweb.link/", "copies": 1}}' --accountId $NEARID --deposit 0.1
```

:::tip
You can also replace the `media` URL with a link to any image file hosted on your web server.
:::

<details>
<summary>Example response: </summary>
<p>

```json
Log [nft.examples.testnet]: EVENT_JSON:{"standard":"nep171","version":"nft-1.0.0","event":"nft_mint","data":[{"owner_id":"benjiman.testnet","token_ids":["TYPE_A_UNIQUE_VALUE_HERE"]}]}
Transaction Id 8RFWrQvAsm2grEsd1UTASKpfvHKrjtBdEyXu7WqGBPUr
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/8RFWrQvAsm2grEsd1UTASKpfvHKrjtBdEyXu7WqGBPUr
''
```

</p>
</details>

- To view tokens owned by an account you can call the NFT contract with the following `near-cli` command:

```bash
near view nft.examples.testnet nft_tokens_for_owner '{"account_id": "'$NEARID'"}'
```

<details>
<summary>Example response: </summary>
<p>

```json
[
  {
    "token_id": "0",
    "owner_id": "dev-xxxxxx-xxxxxxx",
    "metadata": {
      "title": "Some Art",
      "description": "My NFT media",
      "media": "https://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Olympus_Mons_alt.jpg/1024px-Olympus_Mons_alt.jpg",
      "media_hash": null,
      "copies": 1,
      "issued_at": null,
      "expires_at": null,
      "starts_at": null,
      "updated_at": null,
      "extra": null,
      "reference": null,
      "reference_hash": null
    },
    "approved_account_ids": {}
  }
]
```

</p>
</details>

***Congratulations! You just minted your first NFT token on the NEAR blockchain!*** üéâ

üëâ Now try going to your [NEAR Wallet](https://testnet.mynearwallet.com) and view your NFT in the "Collectibles" tab. üëà 

---

## Final remarks

This basic example illustrates all the required steps to call an NFT smart contract on NEAR and start minting your own non-fungible tokens.

Now that you're familiar with the process, you can jump to [Contract Architecture](/tutorials/nfts/js/skeleton) and learn more about the smart contract structure and how you can build your own NFT contract from the ground up.

***Happy minting!*** ü™ô

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.0.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`

:::

'''
'''--- docs/3.tutorials/nfts/js/1-skeleton.md ---
---
id: skeleton
title: Skeleton and JavaScript Architecture
sidebar_label: Contract Architecture
---
import {Github} from "@site/src/components/codetabs"

> In this article, you'll learn about the basic architecture behind the NFT contract that you'll develop while following this _"Zero to Hero"_ series.
> You'll discover the contract's layout and you'll see how the JavaScript files are structured in order to build a feature-complete smart contract.

## Introduction

This tutorial presents the code skeleton for the NFT smart contract and its file structure.
You'll find how all the functions are laid out as well as the missing JS code that needs to be filled in.
Once every file and function has been covered, you'll go through the process of building the mock-up contract to confirm that everything is working correctly.

## File structure

Following a regular [JavaScript](https://www.javascript.com/) project, the file structure for this smart contract has:

- `package.json` file to define the packages and scripts used in the project.
- `src` folder where all the JavaScript source files are stored
- `build` folder where the compiled `wasm` will output to.

### Source files

| File                             | Description                                                                      |
| -------------------------------- | -------------------------------------------------------------------------------- |
| [approval.ts](#approvalts)       | Has the internal functions that controls the access and transfers of non-fungible tokens. |
| [enumeration.ts](#enumerationts) | Contains the internal methods to query for NFT tokens and their owners.                        |
| [index.ts](#indexts)                 | Holds the exposed smart contract functions.                               |
| [metadata.ts](#metadatats)       | Defines the token and metadata structures.                                        |
| [mint.ts](#mintts)               | Contains the internal token minting logic.                                                    |
| [nft_core.ts](#nft_corets)       | Has the internal core logic that allows you to transfer NFTs between users.                       |
| [royalty.ts](#royaltyts)         | Contains the internal payout-related functions.                                               |

```
nft-tutorial-js
‚îî‚îÄ‚îÄ src
    market-contract
    nft-contract
    ‚îú‚îÄ‚îÄ approval.ts
    ‚îú‚îÄ‚îÄ enumeration.ts
    ‚îú‚îÄ‚îÄ index.ts
    ‚îú‚îÄ‚îÄ metadata.ts
    ‚îú‚îÄ‚îÄ mint.ts
    ‚îú‚îÄ‚îÄ nft_core.ts
    ‚îî‚îÄ‚îÄ royalty.ts
```

:::tip
Explore the code in our [GitHub repository](https://github.com/near-examples/nft-tutorial-js/tree/1.skeleton).
:::

---

## `approval.ts`

> This allows people to approve other accounts to transfer NFTs on their behalf.

This file contains the internal logic that complies with the standard's [approvals management](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement) extension. Here is a breakdown of the methods and their functions:

| Method              | Description                                                                                               |
| ------------------- | --------------------------------------------------------------------------------------------------------- |
| **internalNftApprove**     | Approves an account ID to transfer a token on your behalf. Called during **nft_approve**.                                                |
| **internalNftIsApproved** | Checks if the input account has access to approve the token ID. Called during **nft_is_approved**.                                            |
| **internalNftRevoke**      | Revokes a specific account from transferring the token on your behalf. Called during **nft_revoke**.                                     |
| **internalNftRevokeAll**  | Revokes all accounts from transferring the token on your behalf. Called during **nft_revoke_all**.                                         |

<Github language="js" start="9" end="69" url="https://github.com/near-examples/nft-tutorial-js/blob/1.skeleton/src/nft-contract/approval.ts" />

You'll learn more about these functions in the [approvals section](/tutorials/nfts/js/approvals) of the Zero to Hero series.

---

## `enumeration.ts`

> This file provides the internal functions needed to view information about NFTs, and follows the standard's [enumeration](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration) extension.

| Method                   | Description                                                                        |
| ------------------------ | ---------------------------------------------------------------------------------- |
| **internalNftTotalSupply**           | Returns the total amount of NFTs stored on the contract. Called during **nft_total_supply**.    |
| **internalNftTokens**           | Returns a paginated list of NFTs stored on the contract regardless of their owner. Called during **nft_tokens**.    |
| **internalNftSupplyForOwner** | Allows you view the total number of NFTs owned by any given user. Called during **nft_supply_for_owner**.                     |
| **internalNftTokensForOwner** | Returns a paginated list of NFTs owned by any given user. Called during **nft_tokens_for_owner**.                             |

<Github language="js" start="8" end="62" url="https://github.com/near-examples/nft-tutorial-js/blob/1.skeleton/src/nft-contract/enumeration.ts" />

You'll learn more about these functions in the [enumeration section](/tutorials/nfts/js/enumeration) of the tutorial series.

---

## `metadata.ts`

> This file is used to keep track of the information to be stored for tokens, and metadata.
> In addition, you can define a function to view the contract's metadata which is part of the standard's [metadata](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata) extension.

| Name              | Description                                                                                                   |
| ----------------- | ------------------------------------------------------------------------------------------------------------- |
| **TokenMetadata** | This structure defines the metadata that can be stored for each token. (title, description, media, etc.       |
| **Token**         | This structure outlines what information will be stored on the contract for each token.                       |
| **JsonToken**     | When querying information about NFTs through view calls, the return information is stored in this JSON token. |
| **internalNftMetadata**  | This function allows users to query for the contact's internal metadata. Called during **nft_metadata**.                                           |

<Github language="js" start="12" end="46" url="https://github.com/near-examples/nft-tutorial-js/blob/1.skeleton/src/nft-contract/metadata.ts" />

You'll learn more about these functions in the [minting section](/tutorials/nfts/js/minting) of the tutorial series.

---

## `mint.ts`

> Contains the internal token minting logic.

| Method       | Description                               |
| ------------ | ----------------------------------------- |
| **internalNftMint** | This function mints a non-fungible token. Called during **nft_mint**. |

<Github language="js" start="7" end="23" url="https://github.com/near-examples/nft-tutorial-js/blob/1.skeleton/src/nft-contract/mint.ts" />

---

## `nft_core.ts`

> Core logic that allows you to transfer NFTs between users.

| Method                   | Description                                                                                                                                                                                                                                                                                   |
| ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **internalNftTransfer**         | Transfers an NFT to a receiver ID. Called during **nft_transfer**.                                                                                                                                                                                                                                                            |
| **internalNftTransferCall**    | Transfers an NFT to a receiver and calls a function on the receiver ID's contract. The function returns `true` if the token was transferred from the sender's account. Called during **nft_transfer_call**.                                                                                                                        |
| **internalNftToken**            | Allows users to query for the information about a specific NFT. Called during **nft_token**.                                                                                                                                                                                                                               |                                                                                                       |
| **internalNftResolveTransfer** | When you start the `nft_transfer_call` and transfer an NFT, the standard dictates that you should also call a method on the receiver's contract. If the receiver needs you to return the NFT to the sender (as per the return value of the `nft_on_transfer` method), this function allows you to execute that logic. Called during **nft_resolve_transfer**. |

<Github language="js" start="10" end="85" url="https://github.com/near-examples/nft-tutorial-js/blob/1.skeleton/src/nft-contract/nft_core.ts" />

You'll learn more about these functions in the [minting section](/tutorials/nfts/js/minting) of the tutorial series.

---

## `royalty.ts`

> Contains the internal payout-related functions.

| Method                  | Description                                                                                                   |
| ----------------------- | ------------------------------------------------------------------------------------------------------------- |
| **internalNftPayout**          | This internal method calculates the payout for a given token. Called during **nft_payout**.                                                     |
| **internalNftTransferPayout** | Internal method to transfer the token to the receiver ID and return the payout object that should be paid for a given balance. Called during **nft_transfer_payout**. |

<Github language="js" start="7" end="45" url="https://github.com/near-examples/nft-tutorial-js/blob/1.skeleton/src/nft-contract/royalty.ts" />

You'll learn more about these functions in the [royalty section](/tutorials/nfts/js/royalty) of the tutorial series.

---

## `index.ts`

> This file outlines the smart contract class and what information it stores and keeps track of. In addition, it exposes all public facing methods that are callable by the user.

| Method               | Description                                                                                     |
| -------------------- | ----------------------------------------------------------------------------------------------- |
| **init** | Constructor function used to initialize the contract with some metadata and default state. |
| **nft_mint** | Calls the internal mint function to mint an NFT. |
| **nft_token** | Calls the internal function to query for info on a specific NFT |
| **nft_transfer** | Calls the internal function to transfer an NFT  |
| **nft_transfer_call** | Calls the internal function to transfer an NFT and call `nft_on_transfer` on the receiver's contract |
| **nft_resolve_transfer** | Calls the internal function to resolve the transfer call promise.|
| **nft_is_approved** | Calls the internal function to check whether someone is approved for an NFT|
| **nft_approve** | Calls the internal function to approve someone to transfer your NFT|
| **nft_payout** | Calls the internal function to query for the payout object for an NFT|
| **nft_transfer_payout** | Calls the internal function to transfer an NFT and return the payout object. |
| **nft_revoke** | Calls the internal function to revoke someone access to transfer your NFT|
| **nft_revoke_all** | Calls the internal function to revoke everyone's access to transfer your NFT|
| **nft_total_supply** | Calls the internal function to query the total supply of NFTs on the contract.|
| **nft_tokens** | Calls the internal function to paginate through NFTs on the contract|
| **nft_tokens_for_owner** | Calls the internal function to paginate through NFTs for a given owner|
| **nft_supply_for_owner** | Calls the internal function to query for the total number of NFTs owned by someone.|
| **nft_metadata** | Calls the internal function to query for the contract's metadata|

<Github language="js" start="16" end="157" url="https://github.com/near-examples/nft-tutorial-js/blob/1.skeleton/src/nft-contract/index.ts" />

You'll learn more about these functions in the [minting section](/tutorials/nfts/js/minting) of the tutorial series.

---

## Building the skeleton

- If you haven't cloned the main repository yet, open a terminal and run:

```sh
git clone https://github.com/near-examples/nft-tutorial-js/
```

- Next, switch to the `1.skeleton` branch. 
- Install the dependencies (including the JS SDK): `yarn`
- Build the contract with `yarn build`:

```sh
git clone https://github.com/near-examples/nft-tutorial-js/
cd nft-tutorial-js
git checkout 1.skeleton
yarn && yarn build
```

Once this finishes, the `nft-tutorial-js/build` directory should contain the `nft.wasm` smart contract!

Building the skeleton is useful to validate that everything works properly and that you'll be able to compile improved versions of this NFT contract in the upcoming tutorials.

---

## Conclusion

You've seen the layout of this NFT smart contract, and how all the functions are laid out across the different source files.
Using `yarn`, you've been able to compile the contract, and you'll start fleshing out this skeleton in the next [Minting tutorial](/tutorials/nfts/js/minting).

:::note Versioning for this article
At the time of this writing, this example works with the following versions:

- near-sdk-js: `0.4.0-5`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`

:::

'''
'''--- docs/3.tutorials/nfts/js/2-minting.md ---
---
id: minting
title: Minting
sidebar_label: Minting
---
import {Github} from "@site/src/components/codetabs"

This is the first of many tutorials in a series where you'll be creating a complete NFT smart contract from scratch that conforms with all the NEAR [NFT standards](https://nomicon.io/Standards/NonFungibleToken/). Today you'll learn how to create the logic needed to mint NFTs and have them show up in your NEAR wallet. You will be modifying a bare-bones [skeleton smart contract](/tutorials/nfts/js/skeleton) by filling in the necessary code snippets needed to add minting functionalities.

## Introduction

To get started, switch to the `1.skeleton` branch in our repo. If you haven't cloned the repository, refer to the [Contract Architecture](/tutorials/nfts/js/skeleton) to get started.

```
git checkout 1.skeleton
```

If you wish to see the finished code for the minting portion of the tutorial, that can be found on the `2.minting` branch.

## Modifications to the skeleton contract {#what-does-minting-mean}

In order to implement the logic needed for minting, we should break it up into smaller tasks and handle those one-by-one. Let's step back and think about the best way to do this by asking ourselves a simple question: what does it mean to mint an NFT?

To mint a non-fungible token, in the most simple way possible, a contract needs to be able to associate a token with an owner on the blockchain. This means you'll need:

- A way to keep track of tokens and other information on the contract.
- A way to store information for each token such as `metadata` (more on that later).
- A way to link a token with an owner.

That's it! We've now broken down the larger problem into some smaller, less daunting, subtasks. Let's start by tackling the first and work our way through the rest.

### Storing information on the contract {#storing-information}

Start by navigating to `nft-contract/src/index.ts` and filling in some of the code blocks.
You need to be able to store important information on the contract such as the list of tokens that an account has.

The first thing to do is add the information to the contract class.

<Github language="js" start="16" end="22" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/index.ts" />

This allows you to get the information stored in these data structures from anywhere in the contract. The code above has created 3 token specific storages:

- **tokensPerOwner**: allows you to keep track of the tokens owned by any account. It will map the account address to a set of token ID strings owned by that account.
- **tokensById**: returns all the information about a specific token. It will map a token ID string to a `Token` object. 
- **tokenMetadataById**: returns just the metadata for a specific token. It wil map a token ID string to a `TokenMetadata` object.

In addition, you'll keep track of the owner of the contract as well as the metadata for the contract.

#### Constructor Function

Next, you'll add the logic to the constructor function. This function needs to be invoked when you first deploy the contract. It will initialize all the contract's fields that you've defined above with default values.
We've added the `ownerId` and `metadata` fields as parameters to the function because those are the only ones that can be customized.

This function will default all the collections to be empty and set the `owner` and `metadata` equal to what you pass in.

<Github language="js" start="24" end="43" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/index.ts" />

More often than not when doing development, you'll need to deploy contracts several times. You can imagine that it might get tedious to have to pass in metadata every single time you want to initialize the contract. For this reason, the metadata has been defaulted with some initial data if it wasn't passed in by the user.

### Metadata and token information {#metadata-and-token-info}

Now that you've defined what information to store on the contract itself and you've defined some ways to initialize the contract, you need to define what information should go in the `Token`, `TokenMetadata`, and `NFTContractMetadata` data types.

Let's switch over to the `nft-contract/src/metadata.ts` file as this is where that information will go. If you look at the [standards for metadata](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata), you'll find all the necessary information that you need to store for both `TokenMetadata` and `NFTContractMetadata`. Simply fill in the following code.

<Github language="js" start="12" end="104" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/metadata.ts" />

This now leaves you with the `Token` struct and something called a `JsonToken`. The `Token` struct will hold all the information directly related to the token excluding the metadata. The metadata, if you remember, is stored in a map on the contract in a data structured called `tokenMetadataById`. This allows you to quickly get the metadata for any token by simply passing in the token's ID.

For the `Token` struct, you'll just keep track of the owner for now.

<Github language="js" start="106" end="117" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/metadata.ts" />

The purpose of the `JsonToken` is to hold all the information for an NFT that you want to send back as JSON whenever someone does a view call. This means you'll want to store the owner, token ID, and metadata.

<Github language="js" start="119" end="141" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/metadata.ts" />

:::tip
Some of you might be thinking _"how come we don't just store all the information in the `Token` struct?"_.
The reason behind this is that it's actually more efficient to construct the JSON token on the fly only when you need it rather than storing all the information in the token struct.
In addition, some operations might only need the metadata for a token and so having the metadata in a separate data structure is more optimal.
:::

#### Function for querying contract metadata

Now that you've defined some of the types that were used in the previous section, let's move on and create the first view function `internalNftMetadata`. This will allow users to query for the contract's metadata as per the [metadata standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata).

<Github language="js" start="143" end="150" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/metadata.ts" />

This function will get the `metadata` object from the contract which is of type `NFTContractMetadata` and will return it.

Just like that, you've completed the first two tasks and are ready to move onto last part of the tutorial.

### Minting Logic {#minting-logic}

Now that all the information and types are defined, let's start brainstorming how the minting logic will play out. In the end, you need to link a `Token` and `TokenId` to a specific owner. Let's look back at a couple data structures that might be useful:

```ts
//keeps track of all the token IDs for a given account
tokensPerOwner: LookupMap<AccountId, UnorderedSet<TokenId>>;

//keeps track of the token struct for a given token ID
tokensById: LookupMap<TokenId, Token>;

//keeps track of the token metadata for a given token ID
tokenMetadataById: UnorderedMap<TokenId, TokenMetadata>;
```

Looking at these data structures, you could do the following:

- Add the token ID into the set of tokens that the receiver owns. This will be done on the `tokensPerOwner` field.
- Create a token object and map the token ID to that token object in the `tokensById` field.
- Map the token ID to it's metadata using the `tokenMetadataById`.

With those steps outlined, it's important to take into consideration the storage costs of minting NFTs. Since you're adding bytes to the contract by creating entries in the data structures, the contract needs to cover the storage costs. If you just made it so any user could go and mint an NFT for free, that system could easily be abused and users could essentially "drain" the contract of all it's funds by minting thousands of NFTs. For this reason, you'll make it so that users need to attach a deposit to the call to cover the cost of storage. You'll measure the initial storage usage before anything was added and you'll measure the final storage usage after all the logic is finished. Then you'll make sure that the user has attached enough $NEAR to cover that cost and refund them if they've attached too much.

Now that you've got a good understanding of how everything should play out, let's fill in the necessary code.

<Github language="js" start="7" end="44" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/mint.ts" />

You'll notice that we're using some internal methods such as `refundDeposit` and `internalAddTokenToOwner`. We've described the function of `refundDeposit` and as for `internalAddTokenToOwner`, this will add a token to the set of tokens an account owns for the contract's `tokensPerOwner` data structure. You can create these functions in a file called `internal.ts`. Go ahead and create the file. Your new contract architecture should look as follows:

```
nft-contract
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ approval.ts
    ‚îú‚îÄ‚îÄ enumeration.ts
    ‚îú‚îÄ‚îÄ internal.ts
    ‚îú‚îÄ‚îÄ lib.ts
    ‚îú‚îÄ‚îÄ metadata.ts
    ‚îú‚îÄ‚îÄ mint.ts
    ‚îú‚îÄ‚îÄ nft_core.ts
    ‚îî‚îÄ‚îÄ royalty.ts
```

Add the following to your newly created `internal.ts` file.

<Github language="js" start="1" end="54" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/internal.ts" />

At this point, the core logic is all in place so that you can mint NFTs. You can use the function `nft_mint` which takes the following parameters:

- **token_id**: the ID of the token you're minting (as a string).
- **metadata**: the metadata for the token that you're minting (of type `TokenMetadata` which is found in the `metadata.ts` file).
- **receiver_id**: specifies who the owner of the token will be.

Behind the scenes, the function will:

1. Call the internal mint function.
2. Calculate the initial storage before adding anything to the contract
3. Create a `Token` object with the owner ID
4. Link the token ID to the newly created token object by inserting them into the `tokensById` field.
5. Link the token ID to the passed in metadata by inserting them into the `tokenMetadataById` field.
6. Add the token ID to the list of tokens that the owner owns by calling the `internalAddTokenToOwner` function.
7. Calculate the final and net storage to make sure that the user has attached enough NEAR to the call in order to cover those costs.

### Querying for token information

If you were to go ahead and deploy this contract, initialize it, and mint an NFT, you would have no way of knowing or querying for the information about the token you just minted. Let's quickly add a way to query for the information of a specific NFT. You'll move to the `nft-contract/src/nft_core.ts` file and edit the `internalNftToken` function.

It will take a token ID as a parameter and return the information for that token. The `JsonToken` contains the token ID, the owner ID, and the token's metadata.

<Github language="js" start="10" end="35" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/nft_core.ts" />

With that finished, it's finally time to build and deploy the contract so you can mint your first NFT.

## Interacting with the contract on-chain

Now that the logic for minting is complete and you've added a way to query for information about specific tokens, it's time to build and deploy your contract to the blockchain.

### Deploying the contract {#deploy-the-contract}

We've included a very simple way to build the smart contracts throughout this tutorial using `yarn`. The following command will build the contract and copy over the `.wasm` file to a folder `build/nft.wasm`.

```bash
yarn build:nft
```

For deployment, you will need a NEAR account with the keys stored on your local machine. Navigate to the [NEAR wallet](https://testnet.mynearwallet.com//) site and create an account.

:::info
Please ensure that you deploy the contract to an account with no pre-existing contracts. It's easiest to simply create a new account or create a sub-account for this tutorial.
:::

Log in to your newly created account with `near-cli` by running the following command in your terminal.

```bash
near login
```

To make this tutorial easier to copy/paste, we're going to set an environment variable for your account ID. In the command below, replace `YOUR_ACCOUNT_NAME` with the account name you just logged in with including the `.testnet` portion:

```bash
export NFT_CONTRACT_ID="YOUR_ACCOUNT_NAME"
```

Test that the environment variable is set correctly by running:

```bash
echo $NFT_CONTRACT_ID
```

Verify that the correct account ID is printed in the terminal. If everything looks correct you can now deploy your contract.
In the root of your NFT project run the following command to deploy your smart contract.

```bash
near deploy --wasmFile build/nft.wasm --accountId $NFT_CONTRACT_ID
```

At this point, the contract should have been deployed to your account and you're ready to move onto testing and minting NFTs.

### Initializing the contract {#initialize-contract}

The very first thing you need to do once the contract has been deployed is to initialize it. For simplicity, let's call the default metadata initialization function you wrote earlier so that you don't have to type the metadata manually in the CLI.

```bash
near call $NFT_CONTRACT_ID init '{"owner_id": "'$NFT_CONTRACT_ID'"}' --accountId $NFT_CONTRACT_ID
```

You've just initialized the contract with some default metadata and set your account ID as the owner. At this point, you're ready to call your first view function.

### Viewing the contract's metadata

Now that the contract has been initialized, you can call some of the functions you wrote earlier. More specifically, let's test out the function that returns the contract's metadata:

```bash
near view $NFT_CONTRACT_ID nft_metadata
```

This should return an output similar to the following:

```bash
{ spec: 'nft-1.0.0', name: 'NFT Tutorial Contract', symbol: 'GOTEAM' }
```

At this point, you're ready to move on and mint your first NFT.

### Minting our first NFT {#minting-our-first-nft}

Let's now call the minting function that you've created. This requires a `token_id` and `metadata`. If you look back at the `TokenMetadata` struct you created earlier, there are many fields that could potentially be stored on-chain:

<Github language="js" start="91" end="102" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/metadata.ts" />

Let's mint an NFT with a title, description, and media to start. The media field can be any URL pointing to a media file. We've got an excellent GIF to mint but if you'd like to mint a custom NFT, simply replace our media link with one of your choosing. If you run the following command, it will mint an NFT with the following parameters:

- **token_id**: "token-1"
- **metadata**:
  - _title_: "My Non Fungible Team Token"
  - _description_: "The Team Most Certainly Goes :)"
  - _media_: `https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif`
- **receiver_id**: "'$NFT_CONTRACT_ID'"

```bash
near call $NFT_CONTRACT_ID nft_mint '{"token_id": "token-1", "metadata": {"title": "My Non Fungible Team Token", "description": "The Team Most Certainly Goes :)", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$NFT_CONTRACT_ID'"}' --accountId $NFT_CONTRACT_ID --amount 0.1
```

:::info
The `amount` flag is specifying how much NEAR to attach to the call. Since you need to pay for storage, 0.1 NEAR is attached and you'll get refunded any excess that is unused at the end.
:::

### Viewing information about the NFT

Now that the NFT has been minted, you can check and see if everything went correctly by calling the `nft_token` function.
This should return a `JsonToken` which should contain the `token_id`, `owner_id`, and `metadata`.

```bash
near view $NFT_CONTRACT_ID nft_token '{"token_id": "token-1"}'
```

<details>
<summary>Example response: </summary>
<p>

```bash
{
  token_id: 'token-1',
  owner_id: 'goteam.examples.testnet',
  metadata: {
    title: 'My Non Fungible Team Token',
    description: 'The Team Most Certainly Goes :)',
    media: 'https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif'
  }
}
```

</p>
</details>

**Go team!** You've now verified that everything works correctly and it's time to view your freshly minted NFT in the NEAR wallet's collectibles tab!

## Viewing your NFTs in the wallet

If you navigate to the [collectibles tab](https://testnet.mynearwallet.com//?tab=collectibles) in the NEAR wallet, this should list all the NFTs that you own. Currently, It should be empty.

We've got a problem. The wallet correctly picked up that you minted an NFT, however, the contract doesn't implement the specific view function that is being called. Behind the scenes, the wallet is trying to call `nft_tokens_for_owner` to get a list of all the NFTs owned by your account on the contract. The only function you've created, however, is the `nft_token` function. It wouldn't be very efficient for the wallet to call `nft_token` for every single NFT that a user has to get information and so they try to call the `nft_tokens_for_owner` function instead.

In the next tutorial, you'll learn about how to deploy a patch fix to a pre-existing contract so that you can view the NFT in the wallet.

## Conclusion

In this tutorial, you went through the basics of setting up and understand the logic behind minting NFTs on the blockchain using a skeleton contract.

You first looked at [what it means](#what-does-minting-mean) to mint NFTs and how to break down the problem into more feasible chunks. You then started modifying the skeleton contract chunk by chunk starting with solving the problem of [storing information / state](#storing-information) on the contract. You then looked at what to put in the [metadata and token information](#metadata-and-token-info). Finally, you looked at the logic necessary for [minting NFTs](#minting-logic).

After the contract was written, it was time to deploy to the blockchain. You [deployed the contract](#deploy-the-contract) and [initialized it](#initialize-contract). Finally, you [minted your very first NFT](#minting-our-first-nft) and saw that some changes are needed before you can view it in the wallet.

## Next Steps

In the [next tutorial](/tutorials/nfts/js/upgrade-contract), you'll find out how to deploy a patch fix and what that means so that you can view your NFTs in the wallet.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.0.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`
- Metadata standard: [NEP177](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata), version `2.1.0`

:::

'''
'''--- docs/3.tutorials/nfts/js/2-upgrade.md ---
---
id: upgrade-contract
title: Upgrading the Contract
sidebar_label: Upgrade a Contract
---
import {Github} from "@site/src/components/codetabs"

In this tutorial, you'll build off the work you previously did to implement the [minting functionality](/tutorials/nfts/js/minting) on a skeleton smart contract. You got to the point where NFTs could be minted, however, the wallet had no way of displaying the tokens since your contract didn't implement the method that the wallet was trying to call.

## Introduction

Today you'll learn about deploying patch fixes to smart contracts and you'll use that knowledge to implement the `nft_tokens_for_owner` function on the contract you deployed in the previous tutorial.

## Upgrading contracts overview {#upgrading-contracts}

Upgrading contracts, when done right, can be an immensely powerful tool. If done wrong, it can lead to a lot of headaches. It's important to distinguish between the code and state of a smart contract. When a contract is deployed on top of an existing contract, the only thing that changes is the code. The state will remain the same and that's where a lot of developer's issues come to fruition.

The NEAR Runtime will read the serialized state from disk and it will attempt to load it using the current contract code. When your code changes, it might not be able to figure out how to do this.

You need to strategically upgrade your contracts and make sure that the runtime will be able to read your current state with the new contract code. For more information about upgrading contracts and some best practices, see the NEAR SDK's [upgrading contracts](/sdk/rust/building/prototyping) write-up.

## Modifications to our contract {#modifications-to-contract}

In order for the wallet to properly display your NFTs, you need to implement the `nft_tokens_for_owner` method. This will allow anyone to query for a paginated list of NFTs owned by a given account ID.

To accomplish this, let's break it down into some smaller subtasks. First, you need to get access to a list of all token IDs owned by a user. This information can be found in the `tokensPerOwner` data structure. Now that you have a set of token IDs, you need to convert them into `JsonToken` objects as that's what you'll be returning from the function.

Luckily, you wrote a function `nft_token` which takes a token ID and returns a `JsonToken` in the `nft_core.ts` file. As you can guess, in order to get a list of `JsonToken` objects, you would need to iterate through the token IDs owned by the user and then convert each token ID into a `JsonToken` and store that in a list.

As for the pagination, you can use some basic JavaScript to get that done. Let's move over to the `enumeration.ts` file and implement that logic:

<Github language="js" start="47" end="82" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/enumeration.ts" />

## Redeploying the contract {#redeploying-contract}

Now that you've implemented the necessary logic for `nft_tokens_for_owner`, it's time to build and re-deploy the contract to your account. Using the build script, deploy the contract as you did in the previous tutorial:

```bash
yarn build && near deploy --wasmFile build/nft.wasm --accountId $NFT_CONTRACT_ID
```

This should output a warning saying that the account has a deployed contract and will ask if you'd like to proceed. Simply type `y` and hit enter.

```bash
This account already has a deployed contract [ AKJK7sCysrWrFZ976YVBnm6yzmJuKLzdAyssfzK9yLsa ]. Do you want to proceed? (y/n)
```

Once the contract has been redeployed, let's test and see if the state migrated correctly by running a simple view function:

```bash
near view $NFT_CONTRACT_ID nft_metadata
```

This should return an output similar to the following:

```bash
{ spec: 'nft-1.0.0', name: 'NFT Tutorial Contract', symbol: 'GOTEAM' }
```

**Go team!** At this point, you can now test and see if the new function you wrote works correctly. Let's query for the list of tokens that you own:

```bash
near view $NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$NFT_CONTRACT_ID'", "limit": 5}'
```

<details>
<summary>Example response: </summary>
<p>

```bash
[
  {
    token_id: 'token-1',
    owner_id: 'goteam.examples.testnet',
    metadata: {
      title: 'My Non Fungible Team Token',
      description: 'The Team Most Certainly Goes :)',
      media: 'https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif'
    }
  }
]
```

</p>
</details>

## Viewing NFTs in the wallet {#viewing-nfts-in-wallet}

Now that your contract implements the necessary functions that the wallet uses to display NFTs, you should be able to see your tokens on display in the [collectibles tab](https://testnet.mynearwallet.com//?tab=collectibles).

![filled-nft-in-wallet](/docs/assets/nfts/filled-nft-in-wallet.png)

## Conclusion

In this tutorial, you learned about the basics of [upgrading contracts](#upgrading-contracts). Then, you implemented the necessary [modifications to your smart contract](#modifications-to-contract) and [redeployed it](#redeploying-contract). Finally you navigated to the wallet collectibles tab and [viewed your NFTs](#viewing-nfts-in-wallet).

In the [next tutorial](/tutorials/nfts/js/enumeration), you'll implement the remaining functions needed to complete the [enumeration](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration) standard.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.0.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`

:::

'''
'''--- docs/3.tutorials/nfts/js/3-enumeration.md ---
---
id: enumeration
title: Enumeration
sidebar_label: Enumeration
---
import {Github} from "@site/src/components/codetabs"

In the previous tutorials, you looked at ways to integrate the minting functionality into a skeleton smart contract. In order to get your NFTs to show in the wallet, you also had to deploy a patch fix that implemented one of the enumeration methods. In this tutorial, you'll expand on and finish the rest of the enumeration methods as per the [standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration)
Now you'll extend the NFT smart contract and add a couple of enumeration methods that can be used to return the contract's state.

## Introduction

As mentioned in the [Upgrade a Contract](/tutorials/nfts/js/upgrade-contract/) tutorial, you can deploy patches and fixes to smart contracts. This time, you'll use that knowledge to implement the `nft_total_supply`, `nft_tokens` and `nft_supply_for_owner` enumeration functions.

To get started, either switch to the `2.minting` branch from our [GitHub repository](https://github.com/near-examples/nft-tutorial/), or continue your work from the previous tutorials.
If you haven't cloned it yet, refer to the [Contract Architecture](/tutorials/nfts/js/skeleton#building-the-skeleton) to check out the repository.

```bash
git checkout 2.minting
```

:::tip
If you wish to see the finished code for this _Enumeration_ tutorial, you can find it on the `3.enumeration` branch.
:::

## Modifications to the contract

Let's start by opening the  `src/enumeration.ts` file and locating the empty `internalNftTotalSupply` function. 

### NFT Total Supply

This function should return the total number of NFTs stored on the contract. You can easily achieve this functionality by simply returning the length of the `nftMetadataById` data structure.

<Github language="js" start="8" end="16" url="https://github.com/near-examples/nft-tutorial-js/blob/3.enumeration/src/nft-contract/enumeration.ts" />

### NFT Tokens

This function should return a paginated list of `JsonTokens` that are stored on the contract regardless of their owners.
If the user provides a `from_index` parameter, you should use that as the starting point for which to start iterating through tokens; otherwise it should start from the beginning. Likewise, if the user provides a `limit` parameter, the function shall stop after reaching either the limit or the end of the list.

<Github language="js" start="18" end="43" url="https://github.com/near-examples/nft-tutorial-js/blob/3.enumeration/src/nft-contract/enumeration.ts" />

### NFT Supply For Owner

This function should look for all the non-fungible tokens for a user-defined owner, and return the length of the resulting set.
If there isn't a set of tokens for the provided Account ID, then the function shall return `0`.

<Github language="js" start="45" end="62" url="https://github.com/near-examples/nft-tutorial-js/blob/3.enumeration/src/nft-contract/enumeration.ts" />

Next, you can use the CLI to query these new methods and validate that they work correctly.

## Redeploying the contract {#redeploying-contract}

Now that you've implemented the necessary logic for `nft_tokens_for_owner`, it's time to build and re-deploy the contract to your account. Using the build script, deploy the contract as you did in the previous tutorials:

```bash
yarn build && near deploy --wasmFile build/nft.wasm --accountId $NFT_CONTRACT_ID
```

This should output a warning saying that the account has a deployed contract and will ask if you'd like to proceed. Simply type `y` and hit enter.

```
This account already has a deployed contract [ AKJK7sCysrWrFZ976YVBnm6yzmJuKLzdAyssfzK9yLsa ]. Do you want to proceed? (y/n)
```

## Enumerating tokens

Once the updated contract has been redeployed, you can test and see if these new functions work as expected.

### NFT tokens

Let's query for a list of non-fungible tokens on the contract. Use the following command to query for the information of up to 50 NFTs starting from the 10th item:

```bash
near view $NFT_CONTRACT_ID nft_tokens '{"from_index": "10", "limit": 50}'
```

This command should return an output similar to the following:

<details>
<summary>Example response: </summary>
<p>

```json
[]
```

</p>
</details>

### Tokens by owner

To get the total supply of NFTs owned by the `goteam.testnet` account, call the `nft_supply_for_owner` function and set the `account_id` parameter:

```bash
near view $NFT_CONTRACT_ID nft_supply_for_owner '{"account_id": "goteam.testnet"}'
```

This should return an output similar to the following:

<details>
<summary>Example response: </summary>
<p>

```json
0
```

</p>
</details>

## Conclusion

In this tutorial, you have added two [new enumeration functions](/tutorials/nfts/js/enumeration#modifications-to-the-contract), and now you have a basic NFT smart contract with minting and enumeration methods in place. After implementing these modifications, you redeployed the smart contract and tested the functions using the CLI.

In the [next tutorial](/tutorials/nfts/js/core), you'll implement the core functions needed to allow users to transfer the minted tokens.

:::info Remember
If you want to see the finished code from this tutorial, you can checkout the `3.enumeration` branch. 
:::

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.0.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`
- Enumeration standard: [NEP181](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration), version `1.0.0`

:::

'''
'''--- docs/3.tutorials/nfts/js/4-core.md ---
---
id: core
title: Core
sidebar_label: Core
---
import {Github} from "@site/src/components/codetabs"

In this tutorial you'll learn how to implement the [core standards](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core) into your smart contract. If you're joining us for the first time, feel free to clone [this repo](https://github.com/near-examples/nft-tutorial) and checkout the `3.enumeration` branch to follow along.

```bash
git checkout 3.enumeration
```

:::tip
If you wish to see the finished code for this _Core_ tutorial, you can find it on the `4.core` branch.
:::

## Introduction {#introduction}

Up until this point, you've created a simple NFT smart contract that allows users to mint tokens and view information using the [enumeration standards](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration). Today, you'll expand your smart contract to allow for users to not only mint tokens, but transfer them as well.

As we did in the [minting tutorial](/tutorials/nfts/js/minting), let's break down the problem into multiple subtasks to make our lives easier. When a token is minted, information is stored in 3 places:

- **tokensPerOwner**: set of tokens for each account.
- **tokensById**: maps a token ID to a `Token` object.
- **tokenMetadataById**: maps a token ID to its metadata.

Let's now consider the following scenario. If Benji owns token A and wants to transfer it to Mike as a birthday gift, what should happen? First of all, token A should be removed from Benji's set of tokens and added to Mike's set of tokens.

If that's the only logic you implement, you'll run into some problems. If you were to do a `view` call to query for information about that token after it's been transferred to Mike, it would still say that Benji is the owner.

This is because the contract is still mapping the token ID to the old `Token` object that contains the `owner_id` field set to Benji's account ID. You still have to change the `tokensById` data structure so that the token ID maps to a new `Token` object which has Mike as the owner.

With that being said, the final process for when an owner transfers a token to a receiver should be the following:

- Remove the token from the owner's set.
- Add the token to the receiver's set.
- Map a token ID to a new `Token` object containing the correct owner.

:::note
You might be curious as to why we don't edit the `tokenMetadataById` field. This is because no matter who owns the token, the token ID will always map to the same metadata. The metadata should never change and so we can just leave it alone.
:::

At this point, you're ready to move on and make the necessary modifications to your smart contract.

## Modifications to the contract

Let's start our journey in the `nft-contract/src/nft_core.ts` file.

### Transfer function {#transfer-function}

You'll start by implementing the `nft_transfer` logic. This function will transfer the specified `token_id` to the `receiver_id` with an optional `memo` such as `"Happy Birthday Mike!"`. The core logic will be found in the `internalNftTransfer` function.

<Github language="js" start="37" end="64" url="https://github.com/near-examples/nft-tutorial-js/blob/4.core/src/nft-contract/nft_core.ts" />

There are a couple things to notice here. Firstly, we've introduced a new function called `assertOneYocto()`. This method will ensure that the user has attached exactly one yoctoNEAR to the call. If a function requires a deposit, you need a full access key to sign that transaction. By adding the one yoctoNEAR deposit requirement, you're essentially forcing the user to sign the transaction with a full access key.

Since the transfer function is potentially transferring very valuable assets, you'll want to make sure that whoever is calling the function has a full access key.

Secondly, we've introduced an `internalTransfer` method. This will perform all the logic necessary to transfer an NFT.

### Internal helper functions

Let's quickly move over to the `nft-contract/src/internal.ts` file so that you can implement the `assertOneYocto()` and `internalTransfer` methods.

Let's start with the easier one, `assertOneYocto()`.

#### assertOneYocto

<Github language="js" start="38" end="41" url="https://github.com/near-examples/nft-tutorial-js/blob/4.core/src/nft-contract/internal.ts" />

#### internal_transfer

It's now time to implement the `internalTransfer` function which is the core of this tutorial. This function will take the following parameters:

- **senderId**: the account that's attempting to transfer the token.
- **receiverId**: the account that's receiving the token.
- **tokenId**: the token ID being transferred.
- **memo**: an optional memo to include.

The first thing you'll want to do is to make sure that the sender is authorized to transfer the token. In this case, you'll just make sure that the sender is the owner of the token. You'll do that by getting the `Token` object using the `token_id` and making sure that the sender is equal to the token's `owner_id`.

Second, you'll remove the token ID from the sender's list and add the token ID to the receiver's list of tokens. Finally, you'll create a new `Token` object with the receiver as the owner and remap the token ID to that newly created object.

<Github language="js" start="80" end="114" url="https://github.com/near-examples/nft-tutorial-js/blob/4.core/src/nft-contract/internal.ts" />

You've previously implemented functionality for adding a token ID to an owner's set but you haven't created the functionality for removing a token ID from an owner's set. Let's do that now by created a new function called `internalRemoveTokenFromOwner` which we'll place right above our `internalTransfer` and below the `internalAddTokenToOwner` function.

In the remove function, you'll get the set of tokens for a given account ID and then remove the passed in token ID. If the account's set is empty after the removal, you'll simply remove the account from the `tokensPerOwner` data structure.

<Github language="js" start="60" end="78" url="https://github.com/near-examples/nft-tutorial-js/blob/4.core/src/nft-contract/internal.ts" />

With these internal functions complete, the logic for transferring NFTs is finished. It's now time to move on and implement `nft_transfer_call`, one of the most integral yet complicated functions of the standard.

### Transfer call function {#transfer-call-function}

Let's consider the following scenario. An account wants to transfer an NFT to a smart contract for performing a service. The traditional approach would be to use an approval management system, where the receiving contract is granted the ability to transfer the NFT to themselves after completion. You'll learn more about the approval management system in the [approvals section](/tutorials/nfts/js/approvals) of the tutorial series.

This allowance workflow takes multiple transactions. If we introduce a ‚Äútransfer and call‚Äù workflow baked into a single transaction, the process can be greatly improved.

For this reason, we have a function `nft_transfer_call` which will transfer an NFT to a receiver and also call a method on the receiver's contract all in the same transaction.

<Github language="js" start="66" end="125" url="https://github.com/near-examples/nft-tutorial-js/blob/4.core/src/nft-contract/nft_core.ts" />

The function will first assert that the caller attached exactly 1 yocto for security purposes. It will then transfer the NFT using `internalTransfer` and start the cross contract call. It will call the method `nft_on_transfer` on the `receiver_id`'s contract which returns a promise. After the promise finishes executing, the function `nft_resolve_transfer` is called. This is a very common workflow when dealing with cross contract calls. You first initiate the call and wait for it to finish executing. You then invoke a function that resolves the result of the promise and act accordingly.

In our case, when calling `nft_on_transfer`, that function will return whether or not you should return the NFT to it's original owner in the form of a boolean. This is logic will be executed in the `internalResolveTransfer` function.

<Github language="js" start="127" end="187" url="https://github.com/near-examples/nft-tutorial-js/blob/4.core/src/nft-contract/nft_core.ts" />

If `nft_on_transfer` returned true, you should send the token back to it's original owner. On the contrary, if false was returned, no extra logic is needed. As for the return value of `nft_resolve_transfer`, the standard dictates that the function should return a boolean indicating whether or not the receiver successfully received the token or not.

This means that if `nft_on_transfer` returned true, you should return false. This is because if the token is being returned to its original owner. The `receiver_id` didn't successfully receive the token in the end. On the contrary, if `nft_on_transfer` returned false, you should return true since we don't need to return the token and thus the `receiver_id` successfully owns the token.

With that finished, you've now successfully added the necessary logic to allow users to transfer NFTs. It's now time to deploy and do some testing.

## Redeploying the contract {#redeploying-contract}

Using the build script, build and deploy the contract as you did in the previous tutorials:

```bash
yarn build && near deploy --wasmFile build/nft.wasm --accountId $NFT_CONTRACT_ID
```

This should output a warning saying that the account has a deployed contract and will ask if you'd like to proceed. Simply type `y` and hit enter.

```
This account already has a deployed contract [ AKJK7sCysrWrFZ976YVBnm6yzmJuKLzdAyssfzK9yLsa ]. Do you want to proceed? (y/n)
```

:::tip
If you haven't completed the previous tutorials and are just following along with this one, simply create an account and login with your CLI using `near login`. You can then export an environment variable `export NFT_CONTRACT_ID=YOUR_ACCOUNT_ID_HERE`.
:::

## Testing the new changes {#testing-changes}

Now that you've deployed a patch fix to the contract, it's time to move onto testing. Using the previous NFT contract where you had minted a token to yourself, you can test the `nft_transfer` method. If you transfer the NFT, it should be removed from your account's collectibles displayed in the wallet. In addition, if you query any of the enumeration functions, it should show that you are no longer the owner.

Let's test this out by transferring an NFT to the account `benjiman.testnet` and seeing if the NFT is no longer owned by you.

### Testing the transfer function

:::note
This means that the NFT won't be recoverable unless the account `benjiman.testnet` transfers it back to you. If you don't want your NFT lost, make a new account and transfer the token to that account instead.
:::

If you run the following command, it will transfer the token `"token-1"` to the account `benjiman.testnet` with the memo `"Go Team :)"`. Take note that you're also attaching exactly 1 yoctoNEAR by using the `--depositYocto` flag. 

:::tip
If you used a different token ID in the previous tutorials, replace `token-1` with your token ID.
:::

```bash
near call $NFT_CONTRACT_ID nft_transfer '{"receiver_id": "benjiman.testnet", "token_id": "token-1", "memo": "Go Team :)"}' --accountId $NFT_CONTRACT_ID --depositYocto 1
```

If you now query for all the tokens owned by your account, that token should be missing. Similarly, if you query for the list of tokens owned by `benjiman.testnet`, that account should now own your NFT.

### Testing the transfer call function

Now that you've tested the `nft_transfer` function, it's time to test the `nft_transfer_call` function. If you try to transfer an NFT to a receiver that does **not** implement the `nft_on_transfer` function, the contract will panic and the NFT will **not** be transferred. Let's test this functionality below.

First mint a new NFT that will be used to test the transfer call functionality.

```bash
near call $NFT_CONTRACT_ID nft_mint '{"token_id": "token-2", "metadata": {"title": "NFT Tutorial Token", "description": "Testing the transfer call function", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$NFT_CONTRACT_ID'"}' --accountId $NFT_CONTRACT_ID --amount 0.1
```

Now that you've minted the token, you can try to transfer the NFT to the account `no-contract.testnet` which as the name suggests, doesn't have a contract. This means that the receiver doesn't implement the `nft_on_transfer` function and the NFT should remain yours after the transaction is complete.

```bash
near call $NFT_CONTRACT_ID nft_transfer_call '{"receiver_id": "no-contract.testnet", "token_id": "token-2", "msg": "foo"}' --accountId $NFT_CONTRACT_ID --depositYocto 1 --gas 200000000000000
```

If you query for your tokens, you should still have `token-2` and at this point, you're finished!

## Conclusion

In this tutorial, you learned how to expand an NFT contract past the minting functionality and you added ways for users to transfer NFTs. You [broke down](#introduction) the problem into smaller, more digestible subtasks and took that information and implemented both the [NFT transfer](#transfer-function) and [NFT transfer call](#transfer-call-function) functions. In addition, you deployed another [patch fix](#redeploying-contract) to your smart contract and [tested](#testing-changes) the transfer functionality.

In the [next tutorial](/tutorials/nfts/js/approvals), you'll learn about the approval management system and how you can approve others to transfer tokens on your behalf.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.0.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`
- Enumeration standard: [NEP181](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration), version `1.0.0`

:::

'''
'''--- docs/3.tutorials/nfts/js/5-approval.md ---
---
id: approvals
title: Approvals
sidebar_label: Approvals
---
import {Github} from "@site/src/components/codetabs"

In this tutorial you'll learn the basics of an approval management system which will allow you to grant others access to transfer NFTs on your behalf. This is the backbone of all NFT marketplaces and allows for some complex yet beautiful scenarios to happen. If you're joining us for the first time, feel free to clone [this repository](https://github.com/near-examples/nft-tutorial) and checkout the `4.core` branch to follow along.

```bash
git checkout 4.core
```

:::tip
If you wish to see the finished code for this _Approval_ tutorial, you can find it on the `5.approval` branch.
:::

## Introduction

Up until this point you've created a smart contract that allows users to mint and transfer NFTs as well as query for information using the [enumeration standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration). As we've been doing in the previous tutorials, let's break down the problem into smaller, more digestible, tasks. Let's first define some of the end goals that we want to accomplish as per the [approval management](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement) extension of the standard. We want a user to have the ability to:

- Grant other accounts access to transfer their NFTs on a per token basis.
- Check if an account has access to a specific token.
- Revoke a specific account the ability to transfer an NFT.
- Revoke **all** other accounts the ability to transfer an NFT.

If you look at all these goals, they are all on a per token basis. This is a strong indication that you should change the `Token` struct which keeps track of information for each token.

## Allow an account to transfer your NFT

Let's start by trying to accomplish the first goal. How can you grant another account access to transfer an NFT on your behalf?

The simplest way that you can achieve this is to add a list of approved accounts to the `Token` struct. When transferring the NFT, if the caller is not the owner, you could check if they're in the list.

Before transferring, you would need to clear the list of approved accounts since the new owner wouldn't expect the accounts approved by the original owner to still have access to transfer their new NFT.

### The problem {#the-problem}

On the surface, this would work, but if you start thinking about the edge cases, some problems arise. Often times when doing development, a common approach is to think about the easiest and most straightforward solution. Once you've figured it out, you can start to branch off and think about optimizations and edge cases.

Let's consider the following scenario. Benji has an NFT and gives two separate marketplaces access to transfer his token. By doing so, he's putting the NFT for sale (more about that in the [marketplace integrations](#marketplace-integrations) section). Let's say he put the NFT for sale for 1 NEAR on both markets. The token's list of approved account IDs would look like the following:

```
Token: {
    owner_id: Benji
    approved_accounts_ids: [marketplace A, marketplace B]
}
```

Josh then comes along and purchases the NFT on marketplace A for 1 NEAR. This would take the sale down from the marketplace A and clear the list of approved accounts. Marketplace B, however, still has the token listed for sale for 1 NEAR and has no way of knowing that the token was purchased on marketplace A by Josh. The new token struct would look as follows:

```
Token: {
    owner_id: Josh
    approved_accounts_ids: []
}
```

Let's say Josh is low on cash and wants to flip this NFT and put it for sale for 10 times the price on marketplace B. He goes to put it for sale and for whatever reason, the marketplace is built in a way that if you try to put a token up for sale twice, it keeps the old sale data. This would mean that from marketplace B's perspective, the token is still for sale for 1 NEAR (which was the price that Benji had originally listed it for).

Since Josh approved the marketplace to try and put it for sale, the token struct would look as follows:

```
Token: {
    owner_id: Josh
    approved_accounts_ids: [marketplace A, marketplace B]
}
```

If Mike then comes along and purchases the NFT for only 1 NEAR on marketplace B, the marketplace would go to try and transfer the NFT and since technically, Josh approved the marketplace and it's in the list of approved accounts, the transaction would go through properly.

### The solution {#the-solution}

Now that we've identified a problem with the original solution, let's think about ways that we can fix it. What would happen now if, instead of just keeping track of a list of approved accounts, you introduced a specific ID that went along with each approved account. The new approved accounts would now be a map instead of a list. It would map an account to it's `approval id`.

For this to work, you need to make sure that the approval ID is **always** a unique, new ID. If you set it as an integer that always increases by 1 whenever u approve an account, this should work. Let's consider the same scenario with the new solution.

Benji puts his NFT for sale for 1 NEAR on marketplace A and marketplace B by approving both marketplaces. The "next approval ID" would start off at 0 when the NFT was first minted and will increase from there. This would result in the following token struct:

```
Token: {
    owner_id: Benji
    approved_accounts_ids: {
        marketplace A: 0
        marketplace B: 1
    }
    next_approval_id: 2
}
```

When Benji approved marketplace A, it took the original value of `next_approval_id` which started off at 0. The marketplace was then inserted into the map and the next approval ID was incremented. This process happened again for marketplace B and the next approval ID was again incremented where it's now 2.

Josh comes along and purchases the NFT on marketplace A for 1 NEAR. Notice how the next approval ID stayed at 2:

```
Token: {
    owner_id: Josh
    approved_accounts_ids: {}
    next_approval_id: 2
}
```

Josh then flips the NFT because he's once again low on cash and approves marketplace B:

```
Token: {
    owner_id: Josh
    approved_accounts_ids: {
        marketplace B: 2
    }
    next_approval_id: 3
}
```

The marketplace is inserted into the map and the next approval ID is incremented. From marketplace B's perspective it stores it's original approval ID from when Benji put the NFT up for sale which has a value of 1. If Mike were to go and purchase the NFT on marketplace B for the original 1 NEAR sale price, the NFT contract should panic. This is because the marketplace is trying to transfer the NFT with an approval ID 1 but the token struct shows that it **should** have an approval ID of 2.

### Expanding the `Token` and `JsonToken` structs

Now that you understand the proposed solution to the original problem of allowing an account to transfer your NFT, it's time to implement some of the logic. The first thing you should do is modify the `Token` and `JsonToken` structs to reflect the new changes. Let's switch over to the `nft-contract/src/metadata.ts` file:

<Github language="js" start="106" end="156" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/metadata.ts" />

You'll then need to initialize both the `approved_account_ids` and `next_approval_id` to their default values when a token is minted. Switch to the `nft-contract/src/mint.ts` file and when creating the `Token` struct to store in the contract, let's set the next approval ID to be 0 and the approved account IDs to be an empty object:

<Github language="js" start="23" end="31" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/mint.ts" />

### Approving accounts

Now that you've added the support for approved account IDs and the next approval ID on the token level, it's time to add the logic for populating and changing those fields through a function called `nft_approve`. This function should approve an account to have access to a specific token ID. Let's move to the `nft-contract/src/approval.ts` file and edit the `internalNftApprove` function:

<Github language="js" start="9" end="73" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/approval.ts" />

The function will first assert that the user has attached **at least** one yoctoNEAR (which we'll implement soon). This is both for security and to cover storage. When someone approves an account ID, they're storing that information on the contract. As you saw in the [minting tutorial](/tutorials/nfts/js/minting), you can either have the smart contract account cover the storage, or you can have the users cover that cost. The latter is more scalable and it's the approach you'll be working with throughout this tutorial.

After the assertion comes back with no problems, you get the token object and make sure that only the owner is calling this method. Only the owner should be able to allow other accounts to transfer their NFTs. You then get the next approval ID and insert the passed in account into the map with the next approval ID. If it's a new approval ID, storage must be paid. If it's not a new approval ID, no storage needs to be paid and only attaching 1 yoctoNEAR would be enough.

You then calculate how much storage is being used by adding that new account to the map and increment the tokens `next_approval_id` by 1. After inserting the token object back into the `tokensById` map, you refund any excess storage.

You'll notice that the function contains an optional `msg` parameter. This message is actually the foundation of all NFT marketplaces on NEAR.

#### Marketplace Integrations {#marketplace-integrations}

If a message was provided into the function, you're going to perform a cross contract call to the account being given access. This cross contract call will invoke the `nft_on_approve` function which will parse the message and act accordingly. Let's consider a general use case.

We have a marketplace that expects it's sale conditions to be passed in through the message field. Benji approves the marketplace with the `nft_approve` function and passes in a stringified JSON to the message which will outline sale conditions. These sale conditions could look something like the following:

```json
sale_conditions: {
    price: 5
}
```

By leaving the message field type as just a string, this generalizes the process and allows users to input sale conditions for many different marketplaces. It is up to the person approving to pass in an appropriate message that the marketplace can properly decode and use. This is usually done through the marketplace's frontend app which would know how to construct the `msg` in a useful way.

#### Internal functions

Now that the core logic for approving an account is finished, you need to implement the `assertAtLeastOneYocto` and `bytesForApprovedAccountId` functions. Move to the `nft-contract/src/internal.ts` file and copy the following function right below the `assertOneYocto` function.

<Github language="js" start="61" end="64" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/internal.ts" />

Next, you'll need to copy the logic for calculating how many bytes it costs to store an account ID. Place this function at the very top of the page:

<Github language="js" start="55" end="59" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/internal.ts" />

Now that the logic for approving accounts is finished, you need to change the restrictions for transferring.

### Changing the restrictions for transferring NFTs

Currently, an NFT can **only** be transferred by its owner. You need to change that restriction so that people that have been approved can also transfer NFTs. In addition, you'll make it so that if an approval ID is passed, you can increase the security and check if both the account trying to transfer is in the approved list **and** they correspond to the correct approval ID. This is to address the problem we ran into earlier.

In the `internal.ts` file, you need to change the logic of the `internalTransfer` method as that's where the restrictions are being made. Change the internal transfer function to be the following:

<Github language="js" start="108" end="163" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/internal.ts" />

This will check if the sender isn't the owner and then if they're not, it will check if the sender is in the approval list. If an approval ID was passed into the function, it will check if the sender's actual approval ID stored on the contract matches the one passed in.

#### Refunding storage on transfer

While you're in the internal file, you're going to need to add methods for refunding users who have paid for storing approved accounts on the contract when an NFT is transferred. This is because you'll be clearing the `approved_account_ids` object whenever NFTs are transferred and so the storage is no longer being used.

<Github language="js" start="13" end="28" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/internal.ts" />

These will be useful in the next section where you'll be changing the `nft_core` functions to include the new approval logic.

### Changes to `nft_core.ts`

Head over to the `nft-contract/src/nft_core.ts` file and the first change that you'll want to make is to add an `approval_id` to the `internalTransfer` function. This is so that anyone trying to transfer the token that isn't the owner must pass in an approval ID to address the problem seen earlier. If they are the owner, the approval ID won't be used as we saw in the `internalTransfer` function.

For the `nft_transfer` function, the only change that you'll need to make is to pass in the approval ID into the `internalTransfer` function and then refund the previous tokens approved account IDs after the transfer is finished

<Github language="js" start="38" end="72" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/nft_core.ts" />

Next, you need to do the same to `nft_transfer_call` but instead of refunding immediately, you need to attach the previous token's approved account IDs to `nft_resolve_transfer` instead as there's still the possibility that the transfer gets reverted.

<Github language="js" start="74" end="135" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/nft_core.ts" />

You'll also need to add the tokens approved account IDs to the `JsonToken` being returned by `nft_token`.

<Github language="js" start="10" end="36" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/nft_core.ts" />

Finally, you need to add the logic for refunding the approved account IDs in `internalResolveTransfer`. If the transfer went through, you should refund the owner for the storage being released by resetting the tokens `approved_account_ids` field. If, however, you should revert the transfer, it wouldn't be enough to just not refund anybody. Since the receiver briefly owned the token, they could have added their own approved account IDs and so you should refund them if they did so.

<Github language="js" start="137" end="208" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/nft_core.ts" />

With that finished, it's time to move on and complete the next task.

## Check if an account is approved

Now that the core logic is in place for approving and refunding accounts, it should be smooth sailing from this point on. You now need to implement the logic for checking if an account has been approved. This should take an account and token ID as well as an optional approval ID. If no approval ID was provided, it should simply return whether or not the account is approved.

If an approval ID was provided, it should return whether or not the account is approved and has the same approval ID as the one provided. Let's move to the `nft-contract/src/approval.ts` file and add the necessary logic to the `internalNftIsApproved` function.

<Github language="js" start="75" end="110" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/approval.ts" />

Let's now move on and add the logic for revoking an account

## Revoke an account

The next step in the tutorial is to allow a user to revoke a specific account from having access to their NFT. The first thing you'll want to do is assert one yocto for security purposes. You'll then need to make sure that the caller is the owner of the token. If those checks pass, you'll need to remove the passed in account from the tokens approved account IDs and refund the owner for the storage being released.

<Github language="js" start="112" end="145" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/approval.ts" />

## Revoke all accounts

The final step in the tutorial is to allow a user to revoke all accounts from having access to their NFT. This should also assert one yocto for security purposes and make sure that the caller is the owner of the token. You then refund the owner for releasing all the accounts in the map and then clear the `approved_account_ids`.

<Github language="js" start="147" end="177" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/approval.ts" />

With that finished, it's time to deploy and start testing the contract.

## Testing the new changes {#testing-changes}

Since these changes affect all the other tokens and the state won't be able to automatically be inherited by the new code, simply redeploying the contract will lead to errors. For this reason, it's best practice to create a sub-account and deploy the contract there.

### Creating a sub-account {#creating-sub-account}

Run the following command to create a sub-account `approval` of your main account with an initial balance of 25 NEAR which will be transferred from the original to your new account.

```bash
near create-account approval.$NFT_CONTRACT_ID --masterAccount $NFT_CONTRACT_ID --initialBalance 25
```

Next, you'll want to export an environment variable for ease of development:

```bash
export APPROVAL_NFT_CONTRACT_ID=approval.$NFT_CONTRACT_ID
```

Using the build script, build the deploy the contract as you did in the previous tutorials:

```bash
yarn build && near deploy --wasmFile build/nft.wasm --accountId $APPROVAL_NFT_CONTRACT_ID
```

### Initialization and minting {#initialization-and-minting}

Since this is a new contract, you'll need to initialize and mint a token. Use the following command to initialize the contract:

```bash
near call $APPROVAL_NFT_CONTRACT_ID init '{"owner_id": "'$APPROVAL_NFT_CONTRACT_ID'"}' --accountId $APPROVAL_NFT_CONTRACT_ID
```

Next, you'll need to mint a token. By running this command, you'll mint a token with a token ID `"approval-token"` and the receiver will be your new account.

```bash
near call $APPROVAL_NFT_CONTRACT_ID nft_mint '{"token_id": "approval-token", "metadata": {"title": "Approval Token", "description": "testing out the new approval extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$APPROVAL_NFT_CONTRACT_ID'"}' --accountId $APPROVAL_NFT_CONTRACT_ID --amount 0.1
```

You can check to see if everything went through properly by calling one of the enumeration functions:

```bash
near view $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$APPROVAL_NFT_CONTRACT_ID'", "limit": 10}'
```

This should return an output similar to the following:

```json
[
  {
    "token_id": "approval-token",
    "owner_id": "approval.goteam.examples.testnet",
    "metadata": {
      "title": "Approval Token",
      "description": "testing out the new approval extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
    },
    "approved_account_ids": {}
  }
]
```

Notice how the approved account IDs are now being returned from the function? This is a great sign! You're now ready to move on and approve an account to have access to your token.

### Approving an account {#approving-an-account}

At this point, you should have two accounts. One stored under `$NFT_CONTRACT_ID` and the other under the `$APPROVAL_NFT_CONTRACT_ID` environment variable. You can use both of these accounts to test things out. If you approve your old account, it should have the ability to transfer the NFT to itself.

Execute the following command to approve the account stored under `$NFT_CONTRACT_ID` to have access to transfer your NFT with an ID `"approval-token"`. You don't need to pass a message since the old account didn't implement the `nft_on_approve` function. In addition, you'll need to attach enough NEAR to cover the cost of storing the account on the contract. 0.1 NEAR should be more than enough and you'll be refunded any excess that is unused.

```bash
near call $APPROVAL_NFT_CONTRACT_ID nft_approve '{"token_id": "approval-token", "account_id": "'$NFT_CONTRACT_ID'"}' --accountId $APPROVAL_NFT_CONTRACT_ID --deposit 0.1
```

If you call the same enumeration method as before, you should see the new approved account ID being returned.

```bash
near view $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$APPROVAL_NFT_CONTRACT_ID'", "limit": 10}'
```

This should return an output similar to the following:

```json
[
  {
    "token_id": "approval-token",
    "owner_id": "approval.goteam.examples.testnet",
    "metadata": {
      "title": "Approval Token",
      "description": "testing out the new approval extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"
    },
    "approved_account_ids": { "goteam.examples.testnet": 0 }
  }
]
```

### Transferring an NFT as an approved account {#transferring-the-nft}

Now that you've approved another account to transfer the token, you can test that behavior. You should be able to use the other account to transfer the NFT to itself by which the approved account IDs should be reset. Let's test transferring the NFT with the wrong approval ID:

```bash
near call $APPROVAL_NFT_CONTRACT_ID nft_transfer '{"receiver_id": "'$NFT_CONTRACT_ID'", "token_id": "approval-token", "approval_id": 1}' --accountId $NFT_CONTRACT_ID --depositYocto 1
```

<details>
<summary>Example response: </summary>
<p>

```bash
kind: {
    ExecutionError: "Smart contract panicked: panicked at 'assertion failed: `(left == right)`\n" +
      '  left: `0`,\n' +
      " right: `1`: The actual approval_id 0 is different from the given approval_id 1', src/internal.ts:165:17"
  },
```

</p>
</details>

If you pass the correct approval ID which is `0`, everything should work fine.

```bash
near call $APPROVAL_NFT_CONTRACT_ID nft_transfer '{"receiver_id": "'$NFT_CONTRACT_ID'", "token_id": "approval-token", "approval_id": 0}' --accountId $NFT_CONTRACT_ID --depositYocto 1
```

If you again call the enumeration method, you should see the owner updated and the approved account IDs reset.

```json
[
  {
    "token_id": "approval-token",
    "owner_id": "goteam.examples.testnet",
    "metadata": {
      "title": "Approval Token",
      "description": "testing out the new approval extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"
    },
    "approved_account_ids": {}
  }
]
```

Let's now test the approval ID incrementing across different owners. If you approve the sub-account that originally minted the token, the approval ID should be 1 now.

```bash
near call $APPROVAL_NFT_CONTRACT_ID nft_approve '{"token_id": "approval-token", "account_id": "'$APPROVAL_NFT_CONTRACT_ID'"}' --accountId $NFT_CONTRACT_ID --deposit 0.1
```

Calling the view function again show now return an approval ID of 1 for the sub-account that was approved.

```bash
near view $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$NFT_CONTRACT_ID'", "limit": 10}'
```

<details>
<summary>Example response: </summary>
<p>

```json
[
  {
    "token_id": "approval-token",
    "owner_id": "goteam.examples.testnet",
    "metadata": {
      "title": "Approval Token",
      "description": "testing out the new approval extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"
    },
    "approved_account_ids": { "approval.goteam.examples.testnet": 1 }
  }
]
```

</p>
</details>

With the testing finished, you've successfully implemented the approvals extension to the standard!

## Conclusion

Today you went through a lot of logic to implement the [approvals extension](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement) so let's break down exactly what you did.

First, you explored the [basic approach](#basic-solution) of how to solve the problem. You then went through and discovered some of the [problems](#the-problem) with that solution and learned how to [fix it](#the-solution).

After understanding what you should do to implement the approvals extension, you started to [modify](#expanding-json-and-token) the JsonToken and Token structs in the contract. You then implemented the logic for [approving accounts](#approving-accounts) and saw how [marketplaces](#marketplace-integrations) are integrated.

After implementing the logic behind approving accounts, you went and [changed the restrictions](#changing-restrictions) needed to transfer NFTs. The last step you did to finalize the approving logic was to go back and edit the [nft_core](#nft-core-changes) files to be compatible with the new changes.

At this point, everything was implemented in order to allow accounts to be approved and you extended the functionality of the [core standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core) to allow for approved accounts to transfer tokens.

You implemented a view method to [check](#check-if-account-approved) if an account is approved and to finish the coding portion of the tutorial, you implemented the logic necessary to [revoke an account](#revoke-account) as well as [revoke all accounts](#revoke-all-accounts).

After this, the contract code was finished and it was time to move onto testing where you created a [subaccount](#creating-sub-account) and tested the [approving](#approving-an-account) and [transferring](#transferring-the-nft) for your NFTs.

In the next tutorial, you'll learn about the royalty standards and how you can interact with NFT marketplaces.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.0.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`
- Enumeration standard: [NEP181](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration), version `1.0.0`
- Approval standard: [NEP178](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement), version `1.0.0`

:::

'''
'''--- docs/3.tutorials/nfts/js/6-royalty.md ---
---
id: royalty
title: Royalty
sidebar_label: Royalty
---
import {Github} from "@site/src/components/codetabs"

In this tutorial you'll continue building your non-fungible token (NFT) smart contract, and learn how to implement perpetual royalties into your NFTs. This will allow people to get a percentage of the purchase price when an NFT is sold.

## Introduction

By now, you should have a fully fledged NFT contract, except for the royalties support.
To get started, either switch to the `5.approval` branch from our [GitHub repository](https://github.com/near-examples/nft-tutorial-js/), or continue your work from the previous tutorials.

```bash
git checkout 5.approval
```

:::tip
If you wish to see the finished code for this _Royalty_ tutorial, you can find it on the `6.royalty` branch.
:::

## Thinking about the problem

In order to implement the functionality, you first need to understand how NFTs are sold. In the previous tutorial, you saw how someone with an NFT could list it on a marketplace using the `nft_approve` function by passing in a message that could be properly decoded. When a user purchases your NFT on the marketplace, what happens?

Using the knowledge you have now, a reasonable conclusion would be to say that the marketplace transfers the NFT to the buyer by performing a cross-contract call and invokes the NFT contract's `nft_transfer` method. Once that function finishes, the marketplace would pay the seller for the correct amount that the buyer paid.

Let's now think about how this can be expanded to allow for a cut of the pay going to other accounts that aren't just the seller.

### Expanding the current solution

Since perpetual royalties will be on a per-token basis, it's safe to assume that you should be changing the `Token` and `JsonToken` structs. You need some way of keeping track of what percentage each account with a royalty should have. If you introduce a map of an account to an integer, that should do the trick.

Now, you need some way to relay that information to the marketplace. This method should be able to transfer the NFT exactly like the old solution but with the added benefit of telling the marketplace exactly what accounts should be paid what amounts. If you implement a method that transfers the NFT and then calculates exactly what accounts get paid and to what amount based on a passed-in balance, that should work nicely.

This is what the [royalty standards](https://nomicon.io/Standards/NonFungibleToken/Payout) outlined. Let's now move on and modify our smart contract to introduce this behavior.

## Modifications to the contract

The first thing you'll want to do is add the royalty information to the structs. Open the `nft-contract/src/metadata.ts` file and add `royalty` to the `Token` and `JsonToken` structs:

```js
royalty: { [accountId: string]: number };
```

Second, you'll want to add `royalty` to the `JsonToken` struct as well:

<Github language="js" start="106" end="166" url="https://github.com/near-examples/nft-tutorial-js/blob/6.royalty/src/nft-contract/metadata.ts" />

### Internal helper function

**royaltyToPayout**

To simplify the payout calculation, let's add a helper `royaltyToPayout` function to `src/internal.ts`. This will convert a percentage to the actual amount that should be paid. In order to allow for percentages less than 1%, you can give 100% a value of `10,000`. This means that the minimum percentage you can give out is 0.01%, or `1`. For example, if you wanted the account `benji.testnet` to have a perpetual royalty of 20%, you would insert the pair `"benji.testnet": 2000` into the payout map.

<Github language="js" start="13" end="16" url="https://github.com/near-examples/nft-tutorial-js/blob/6.royalty/src/nft-contract/internal.ts" />

If you were to use the `royaltyToPayout` function and pass in `2000` as the `royaltyPercentage` and an `amountToPay` of 1 NEAR, it would return a value of 0.2 NEAR.

### Royalties

**nft_payout**

Let's now implement a method to check what accounts will be paid out for an NFT given an amount, or balance. Open the `nft-contract/src/royalty.ts` file, and modify the `internalNftPayout` function as shown.

<Github language="js" start="7" end="53" url="https://github.com/near-examples/nft-tutorial-js/blob/6.royalty/src/nft-contract/royalty.ts" />

This function will loop through the token's royalty map and take the balance and convert that to a payout using the `royaltyToPayout` function you created earlier. It will give the owner of the token whatever is left from the total royalties. As an example:

You have a token with the following royalty field:

```js
Token {
    owner_id: "damian",
    royalty: {
        "benji": 1000,
        "josh": 500,
        "mike": 2000
    }
}
```

If a user were to call `nft_payout` on the token and pass in a balance of 1 NEAR, it would loop through the token's royalty field and insert the following into the payout object:

```js
Payout {
    payout: {
        "benji": 0.1 NEAR,
        "josh": 0.05 NEAR,
        "mike": 0.2 NEAR
    }
}
```

At the very end, it will insert `damian` into the payout object and give him `1 NEAR - 0.1 - 0.05 - 0.2 = 0.65 NEAR`.

**nft_transfer_payout**

Now that you know how payouts are calculated, it's time to create the function that will transfer the NFT and return the payout to the marketplace.

<Github language="js" start="55" end="121" url="https://github.com/near-examples/nft-tutorial-js/blob/6.royalty/src/nft-contract/royalty.ts" />

### Perpetual royalties

To add support for perpetual royalties, let's edit the `src/mint.ts` file. First, add an optional parameter for perpetual royalties. This is what will determine what percentage goes to which accounts when the NFT is purchased. You will also need to create and insert the royalty to be put in the `Token` object:

<Github language="js" start="7" end="64" url="https://github.com/near-examples/nft-tutorial-js/blob/6.royalty/src/nft-contract/mint.ts" />

### Adding royalty object to struct implementations

Since you've added a new field to your `Token` and `JsonToken` structs, you need to edit your implementations accordingly. Move to the `nft-contract/src/internal.ts` file and edit the part of your `internalTransfer` function that creates the new `Token` object:

<Github language="js" start="150" end="158" url="https://github.com/near-examples/nft-tutorial-js/blob/6.royalty/src/nft-contract/internal.ts" />

Once that's finished, move to the `nft-contract/src/nft_core.ts` file. You need to edit your implementation of `internalNftToken` so that the `JsonToken` sends back the new royalty information.

<Github language="js" start="10" end="37" url="https://github.com/near-examples/nft-tutorial-js/blob/6.royalty/src/nft-contract/nft_core.ts" />

Next, you can use the CLI to query the new `nft_payout` function and validate that it works correctly.

## Deploying the contract {#redeploying-contract}

As you saw in the previous tutorial, adding changes like these will cause problems when redeploying. Since these changes affect all the other tokens and the state won't be able to automatically be inherited by the new code, simply redeploying the contract will lead to errors. For this reason, you'll create a new sub-account again.

### Creating a sub-account

Run the following command to create a sub-account `royalty` of your main account with an initial balance of 25 NEAR which will be transferred from the original to your new account.

```bash
near create-account royalty.$NFT_CONTRACT_ID --masterAccount $NFT_CONTRACT_ID --initialBalance 25
```

Next, you'll want to export an environment variable for ease of development:

```bash
export ROYALTY_NFT_CONTRACT_ID=royalty.$NFT_CONTRACT_ID
```

Using the build script, build the deploy the contract as you did in the previous tutorials:

```bash
yarn build && near deploy --wasmFile build/nft.wasm --accountId $ROYALTY_NFT_CONTRACT_ID
```

### Initialization and minting {#initialization-and-minting}

Since this is a new contract, you'll need to initialize and mint a token. Use the following command to initialize the contract:

```bash
near call $ROYALTY_NFT_CONTRACT_ID init '{"owner_id": "'$ROYALTY_NFT_CONTRACT_ID'"}' --accountId $ROYALTY_NFT_CONTRACT_ID
```

Next, you'll need to mint a token. By running this command, you'll mint a token with a token ID `"royalty-token"` and the receiver will be your new account. In addition, you're passing in a map with two accounts that will get perpetual royalties whenever your token is sold.

```bash
near call $ROYALTY_NFT_CONTRACT_ID nft_mint '{"token_id": "approval-token", "metadata": {"title": "Approval Token", "description": "testing out the new approval extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$ROYALTY_NFT_CONTRACT_ID'", "perpetual_royalties": {"benjiman.testnet": 2000, "mike.testnet": 1000, "josh.testnet": 500}}' --accountId $ROYALTY_NFT_CONTRACT_ID --amount 0.1
```

You can check to see if everything went through properly by calling one of the enumeration functions:

```bash
near view $ROYALTY_NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$ROYALTY_NFT_CONTRACT_ID'", "limit": 10}'
```

This should return an output similar to the following:

```json
[
  {
    "token_id": "approval-token",
    "owner_id": "royalty.goteam.examples.testnet",
    "metadata": {
      "title": "Approval Token",
      "description": "testing out the new approval extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"
    },
    "approved_account_ids": {},
    "royalty": {
      "josh.testnet": 500,
      "benjiman.testnet": 2000,
      "mike.testnet": 1000
    }
  }
]
```

Notice how there's now a royalty field that contains the 3 accounts that will get a combined 35% of all sales of this NFT? Looks like it works! Go team :)

### NFT payout

Let's calculate the payout for the `"approval-token"` NFT, given a balance of 100 yoctoNEAR. It's important to note that the balance being passed into the `nft_payout` function is expected to be in yoctoNEAR.

```bash
near view $ROYALTY_NFT_CONTRACT_ID nft_payout '{"token_id": "approval-token", "balance": "100", "max_len_payout": 100}'
```

This command should return an output similar to the following:

```bash
{
  payout: {
    'josh.testnet': '5',
    'royalty.goteam.examples.testnet': '65',
    'mike.testnet': '10',
    'benjiman.testnet': '20'
  }
}
```

If the NFT was sold for 100 yoctoNEAR, josh would get 5, benji would get 20, mike would get 10, and the owner, in this case `royalty.goteam.examples.testnet` would get the rest: 65.

## Conclusion

At this point you have everything you need for a fully functioning NFT contract to interact with marketplaces.
The last remaining standard that you could implement is the events standard. This allows indexers to know what functions are being called and makes it easier and more reliable to keep track of information that can be used to populate the collectibles tab in the wallet for example.

:::info remember
If you want to see the finished code from this tutorial, you can checkout the `6.royalty` branch.
:::

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.0.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`
- Enumeration standard: [NEP181](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration), version `1.0.0`
- Royalties standard: [NEP199](https://nomicon.io/Standards/Tokens/NonFungibleToken/Payout), version `2.0.0`

:::

'''
'''--- docs/3.tutorials/nfts/js/7-events.md ---
---
id: events
title: Events
sidebar_label: Events
---
import {Github} from "@site/src/components/codetabs"

In this tutorial, you'll learn about the [events standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event) and how to implement it in your smart contract.

## Introduction

To get started, either switch to the `6.royalty` branch from our [GitHub repository](https://github.com/near-examples/nft-tutorial/), or continue your work from the previous tutorials.

```bash
git checkout 6.royalty
```

:::tip
If you wish to see the finished code for this _Events_ tutorial, you can find it on the `7.events` branch.
:::

## Understanding the use case {#understanding-the-use-case}

Have you ever wondered how the wallet knows which NFTs you own and how it can display them in the [collectibles tab](https://testnet.mynearwallet.com//?tab=collectibles)? Originally, an [indexer](/tools/indexer-for-explorer) was used and it listened for any functions starting with `nft_` on your account. These contracts were then flagged on your account as likely NFT contracts. 

When you navigated to your collectibles tab, the wallet would then query all those contracts for the list of NFTs you owned using the `nft_tokens_for_owner` function you saw in the [enumeration tutorial](/tutorials/nfts/js/enumeration).

### The problem {#the-problem}

This method of flagging contracts was not reliable as each NFT-driven application might have its own way of minting or transferring NFTs. In addition, it's common for apps to transfer or mint many tokens at a time using batch functions. 

### The solution {#the-solution}

A standard was introduced so that smart contracts could emit an event anytime NFTs were transferred, minted, or burnt. This event was in the form of a log. No matter how a contract implemented the functionality, an indexer could now listen for those standardized logs.

As per the standard, you need to implement a logging functionality that gets fired when NFTs are transferred or minted. In this case, the contract doesn't support burning so you don't need to worry about that for now.

It's important to note the standard dictates that the log should begin with `"EVENT_JSON:"`. The structure of your log should, however, always contain the 3 following things: 

- **standard**: the current name of the standard (e.g. nep171)
- **version**: the version of the standard you're using (e.g. 1.0.0)
- **event**: a list of events you're emitting.

The event interface differs based on whether you're recording transfers or mints. The interface for both events is outlined below.

**Transfer events**:
- *Optional* - **authorized_id**: the account approved to transfer on behalf of the owner.
- **old_owner_id**: the old owner of the NFT.
- **new_owner_id**: the new owner that the NFT is being transferred to.
- **token_ids**: a list of NFTs being transferred.
- *Optional* - **memo**: an optional message to include with the event.

**Minting events**:
- **owner_id**: the owner that the NFT is being minted to.
- **token_ids**: a list of NFTs being transferred.
- *Optional* - **memo**: an optional message to include with the event.

### Examples {#examples}

In order to solidify your understanding of the standard, let's walk through three scenarios and see what the logs should look like.

#### Scenario A - simple mint

In this scenario, Benji wants to mint an NFT to Mike with a token ID `"team-token"` and he doesn't include a message. The log should look as follows.

```js
EVENT_JSON:{
  "standard": "nep171",
  "version": "1.0.0",
  "event": "nft_mint",
  "data": [
    {"owner_id": "mike.testnet", "token_ids": ["team-token"]}
  ]
}
```

#### Scenario B - batch mint

In this scenario, Benji wants to perform a batch mint. He will mint an NFT to Mike, Damian, Josh, and Dorian. Dorian, however, will get two NFTs. Each token ID will be `"team-token"` followed by an incrementing number. The log is as follows.

```js
EVENT_JSON:{
  "standard": "nep171",
  "version": "1.0.0",
  "event": "nft_mint",
  "data": [
    {"owner_id": "mike.testnet", "token_ids": ["team-token0"]},
    {"owner_id": "damian.testnet", "token_ids": ["team-token1"]},
    {"owner_id": "josh.testnet", "token_ids": ["team-token2"]}
    {"owner_id": "dorian.testnet", "token_ids": ["team-token3", "team-token4"]},
  ]
}
```

#### Scenario C - transfer NFTs

In this scenario, Mike is transferring both his team tokens to Josh. The log should look as follows.

```js
EVENT_JSON:{
  "standard": "nep171",
  "version": "1.0.0",
  "event": "nft_transfer",
  "data": [
    {"old_owner_id": "mike.testnet", "new_owner_id": "josh.testnet", "token_ids": ["team-token", "team-token0"], "memo": "Go Team!"}
  ]
}
```

## Modifications to the contract {#modifications-to-the-contract}

At this point, you should have a good understanding of what the end goal should be so let's get to work!

### Logging minted tokens {#logging-minted-tokens}

Since the contract will only be minting tokens in one place, it's trivial where you should place the log. Open the `nft-contract/src/mint.ts` file and navigate to the bottom of the file. This is where you'll construct the log for minting. Anytime someone successfully mints an NFT, it will now correctly emit a log.

```js
// Construct the mint log as per the events standard.
let nftMintLog = {
    // Standard name ("nep171").
    standard: NFT_STANDARD_NAME,
    // Version of the standard ("nft-1.0.0").
    version: NFT_METADATA_SPEC,
    // The data related with the event stored in a vector.
    event: "nft_mint",
    data: [
        {
            // Owner of the token.
            owner_id: token.owner_id,
            // Vector of token IDs that were minted.
            token_ids: [tokenId],
        }
    ]
}

// Log the json.
near.log(`EVENT_JSON:${JSON.stringify(nftMintLog)}`);
```

<Github language="js" start="7" end="85" url="https://github.com/near-examples/nft-tutorial-js/blob/7.events/src/nft-contract/mint.ts" />

### Logging transfers {#logging-transfers}

Let's open the `nft-contract/src/internal.ts` file and navigate to the `internalTransfer` function. This is the location where you'll build your transfer logs. Whenever an NFT is transferred, this function is called and so you'll correctly be logging the transfers.

```js
// Construct the transfer log as per the events standard.
let nftTransferLog = {
    // Standard name ("nep171").
    standard: NFT_STANDARD_NAME,
    // Version of the standard ("nft-1.0.0").
    version: NFT_METADATA_SPEC,
    // The data related with the event stored in a vector.
    event: "nft_transfer",
    data: [
        {
            // The optional authorized account ID to transfer the token on behalf of the old owner.
            authorized_id: authorizedId,
            // The old owner's account ID.
            old_owner_id: token.owner_id,
            // The account ID of the new owner of the token.
            new_owner_id: receiverId,
            // A vector containing the token IDs as strings.
            token_ids: [tokenId],
            // An optional memo to include.
            memo,
        }
    ]
}

// Log the serialized json.
near.log(`EVENT_JSON:${JSON.stringify(nftTransferLog)}`);
```
<Github language="js" start="113" end="205" url="https://github.com/near-examples/nft-tutorial-js/blob/7.events/src/nft-contract/internal.ts" />

This solution, unfortunately, has an edge case which will break things. If an NFT is transferred via the `nft_transfer_call` function, there's a chance that the transfer will be reverted if the `nft_on_transfer` function returns `true`. Taking a look at the logic for `nft_transfer_call`, you can see why this is a problem.

When `nft_transfer_call` is invoked, it will: 
- Call `internalTransfer` to perform the actual transfer logic.
- Initiate a cross-contract call and invoke the `nft_on_transfer` function.
- Resolve the promise and perform logic in `internalResolveTransfer`.
    - This will either return true meaning the transfer went fine or it will revert the transfer and return false.

If you only place the log in the `internalTransfer` function, the log will be emitted and the indexer will think that the NFT was transferred. If the transfer is reverted during `internalResolveTransfer`, however, that event should **also** be emitted. Anywhere that an NFT **could** be transferred, we should add logs. Replace the `internalResolveTransfer` with the following code.

<Github language="js" start="138" end="242" url="https://github.com/near-examples/nft-tutorial-js/blob/7.events/src/nft-contract/nft_core.ts" />

With that finished, you've successfully implemented the events standard and it's time to start testing.

## Deploying the contract {#redeploying-contract}

For the purpose of readability and ease of development, instead of redeploying the contract to the same account, let's create a sub-account and deploy to that instead. You could have deployed to the same account as none of the changes you implemented in this tutorial would have caused errors.

### Creating a sub-account

Run the following command to create a sub-account `events` of your main account with an initial balance of 25 NEAR which will be transferred from the original to your new account.

```bash
near create-account events.$NFT_CONTRACT_ID --masterAccount $NFT_CONTRACT_ID --initialBalance 25
```

Next, you'll want to export an environment variable for ease of development:

```bash
export EVENTS_NFT_CONTRACT_ID=events.$NFT_CONTRACT_ID
```

Using the build script, build the deploy the contract as you did in the previous tutorials:

```bash
yarn build && near deploy --wasmFile build/nft.wasm --accountId $EVENTS_NFT_CONTRACT_ID
```

### Initialization and minting {#initialization-and-minting}

Since this is a new contract, you'll need to initialize and mint a token. Use the following command to initialize the contract:

```bash
near call $EVENTS_NFT_CONTRACT_ID init '{"owner_id": "'$EVENTS_NFT_CONTRACT_ID'"}' --accountId $EVENTS_NFT_CONTRACT_ID
```

Next, you'll need to mint a token. By running this command, you'll mint a token with a token ID `"events-token"` and the receiver will be your new account. In addition, you're passing in a map with two accounts that will get perpetual royalties whenever your token is sold.

```bash
near call $EVENTS_NFT_CONTRACT_ID nft_mint '{"token_id": "events-token", "metadata": {"title": "Events Token", "description": "testing out the new events extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$EVENTS_NFT_CONTRACT_ID'"}' --accountId $EVENTS_NFT_CONTRACT_ID --amount 0.1
```

You can check to see if everything went through properly by looking at the output in your CLI:

```bash
Doing account.functionCall()
Receipts: F4oxNfv54cqwUwLUJ7h74H1iE66Y3H7QDfZMmGENwSxd, BJxKNFRuLDdbhbGeLA3UBSbL8UicU7oqHsWGink5WX7S
	Log [events.goteam.examples.testnet]: EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"events.goteam.examples.testnet","token_ids":["events-token"]}]}
Transaction Id 4Wy2KQVTuAWQHw5jXcRAbrz7bNyZBoiPEvLcGougciyk
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/4Wy2KQVTuAWQHw5jXcRAbrz7bNyZBoiPEvLcGougciyk
''
```

You can see that the event was properly logged!

### Transferring {#transferring}

You can now test if your transfer log works as expected by sending `benjiman.testnet` your NFT.

```bash
near call $EVENTS_NFT_CONTRACT_ID nft_transfer '{"receiver_id": "benjiman.testnet", "token_id": "events-token", "memo": "Go Team :)", "approval_id": 0}' --accountId $EVENTS_NFT_CONTRACT_ID --depositYocto 1
```

This should return an output similar to the following:

```bash
Doing account.functionCall()
Receipts: EoqBxrpv9Dgb8KqK4FdeREawVVLWepEUR15KPNuZ4fGD, HZ4xQpbgc8EfU3PiV72LvfXb2f3dVC1n9aVTbQds9zfR
	Log [events.goteam.examples.testnet]: Memo: Go Team :)
	Log [events.goteam.examples.testnet]: EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"authorized_id":"events.goteam.examples.testnet","old_owner_id":"events.goteam.examples.testnet","new_owner_id":"benjiman.testnet","token_ids":["events-token"],"memo":"Go Team :)"}]}
Transaction Id 4S1VrepKzA6HxvPj3cK12vaT7Dt4vxJRWESA1ym1xdvH
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/4S1VrepKzA6HxvPj3cK12vaT7Dt4vxJRWESA1ym1xdvH
''
```

Hurray! At this point, your NFT contract is fully complete and the events standard has been implemented.

## Conclusion

Today you went through the [events standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event) and implemented the necessary logic in your smart contract. You created events for [minting](#logging-minted-tokens) and [transferring](#logging-transfers) NFTs. You then deployed and [tested](#initialization-and-minting) your changes by minting and transferring NFTs.

In the next tutorial, you'll look at the basics of a marketplace contract and how it was built.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.0.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`
- Events standard: [NEP297 extension](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event), version `1.0.0`

:::

'''
'''--- docs/3.tutorials/nfts/js/8-marketplace.md ---
---
id: marketplace
title: Marketplace
sidebar_label: Marketplace
---
import {Github} from "@site/src/components/codetabs"

In this tutorial, you'll learn the basics of an NFT marketplace contract where you can buy and sell non-fungible tokens for $NEAR. In the previous tutorials, you went through and created a fully fledged NFT contract that incorporates all the standards found in the [NFT standard](https://nomicon.io/Standards/NonFungibleToken). 

## Introduction

Throughout this tutorial, you'll learn how a marketplace contract could work on NEAR. This is meant to be an example and there is no canonical implementation. Feel free to branch off and modify this contract to meet your specific needs.

Using the same repository as the previous tutorials, if you checkout the `8.marketplace` branch, you should have the necessary files to complete the tutorial.

```bash
git checkout 8.marketplace
```

## File structure {#file-structure}

```
market-contract
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ internal.ts
    ‚îú‚îÄ‚îÄ index.ts
    ‚îú‚îÄ‚îÄ nft_callbacks.ts
    ‚îú‚îÄ‚îÄ sale.ts
    ‚îî‚îÄ‚îÄ sale_views.ts
```

Usually, when doing work on multiple smart contracts that all pertain to the same repository, it's a good idea to structure them in their own folders as done in this tutorial. To make your work easier when building the smart contracts, we've also modified the repository's `package.json` file so that building both smart contracts can be easily done by running the following command.

```bash
yarn build
```
This will install the dependencies for both contracts and compile them to `wasm` files that are stored in the following directory.

```
nft-tutorial-js
‚îî‚îÄ‚îÄ build
    ‚îú‚îÄ‚îÄ nft.wasm
    ‚îî‚îÄ‚îÄ market.wasm
```

## Understanding the contract

At first, the contract can be quite overwhelming but if you strip away all the fluff and dig into the core functionalities, it's actually quite simple. This contract was designed for only one thing - to allow people to buy and sell NFTs for NEAR. This includes the support for paying royalties, updating the price of your sales, removing sales and paying for storage.

Let's go through the files and take note of some of the important functions and what they do.

## index.ts {#index-ts}

This file outlines what information is stored on the contract as well as some other crucial functions that you'll learn about below.

### Constructor logic {#constructor-logic}

The first function you'll look at is the constructor function. This takes an `owner_id` as the only parameter and will default all the storage collections to their default values.

<Github language="js" start="40" end="52" url="https://github.com/near-examples/nft-tutorial-js/blob/8.marketplace/src/market-contract/index.ts" />

### Storage management model {#storage-management-model}

Next, let's talk about the storage management model chosen for this contract. On the NFT contract, users attached $NEAR to the calls that needed storage paid for. For example, if someone was minting an NFT, they would need to attach `x` amount of NEAR to cover the cost of storing the data on the contract. 

On this marketplace contract, however, the storage model is a bit different. Users will need to deposit $NEAR onto the marketplace to cover the storage costs. Whenever someone puts an NFT for sale, the marketplace needs to store that information which costs $NEAR. Users can either deposit as much NEAR as they want so that they never have to worry about storage again or they can deposit the minimum amount to cover 1 sale on an as-needed basis. 

You might be thinking about the scenario when a sale is purchased. What happens to the storage that is now being released on the contract? This is why we've introduced a storage withdrawal function. This allows users to withdraw any excess storage that is not being used. Let's go through some scenarios to understand the logic. The required storage for 1 sale is 0.01 NEAR on the marketplace contract.

**Scenario A**

- Benji wants to list his NFT on the marketplace but has never paid for storage. 
- He deposits exactly 0.01 NEAR using the `storage_deposit` method. This will cover 1 sale.
- He lists his NFT on the marketplace and is now using up 1 out of his prepaid 1 sales and has no more storage left. If he were to call `storage_withdraw`, nothing would happen.
- Dorian loves his NFT and quickly purchases it before anybody else can. This means that Benji's sale has now been taken down (since it was purchased) and Benji is using up 0 out of his prepaid 1 sales. In other words, he has an excess of 1 sale or 0.01 NEAR.
- Benji can now call `storage_withdraw` and will be transferred his 0.01 NEAR back. On the contract's side, after withdrawing, he will have 0 sales paid for and will need to deposit storage before trying to list anymore NFTs.

**Scenario B**

- Dorian owns one hundred beautiful NFTs and knows that he wants to list all of them.
- To avoid having to call `storage_deposit` everytime he wants to list an NFT, he calls it once. Since Dorian is a baller, he attaches 10 NEAR which is enough to cover 1000 sales. He now has an excess of 9 NEAR or 900 sales.
- Dorian needs the 9 NEAR for something else but doesn't want to take down his 100 listings. Since he has an excess of 9 NEAR, he can easily withdraw and still have his 100 listings. After calling `storage_withdraw` and being transferred 9 NEAR, he will have an excess of 0 sales.

With this behavior in mind, the following two functions outline the logic.

<Github language="js" start="58" end="121" url="https://github.com/near-examples/nft-tutorial-js/blob/8.marketplace/src/market-contract/index.ts" />

In this contract, the storage required for each sale is 0.01 NEAR but you can query that information using the `storage_minimum_balance` function. In addition, if you wanted to check how much storage a given account has paid, you can query the `storage_balance_of` function.

With that out of the way, it's time to move onto the `nft_callbacks.ts` file where you'll look at how NFTs are put for sale.

## nft_callbacks.ts {#nft_callbacks-ts}

This file is responsible for the logic used to put NFTs for sale. If you remember from the [marketplaces section](/tutorials/nfts/js/approvals#marketplace-integrations) of the approvals tutorial, when users call `nft_approve` and pass in a message, it will perform a cross-contract call to the `receiver_id`'s contract and call the method `nft_on_approve`. This `nft_callbacks.ts` file will implement that function.

### Listing logic {#listing-logic}

The market contract is expecting the message that the user passes into `nft_approve` on the NFT contract to be JSON stringified sale arguments. This outlines the sale price in yoctoNEAR for the NFT that is listed.

The `nft_on_approve` function is called via a cross-contract call by the NFT contract. It will make sure that the signer has enough storage to cover adding another sale. It will then attempt to get the sale conditions from the message and create the listing.

<Github language="js" start="6" end="73" url="https://github.com/near-examples/nft-tutorial-js/blob/8.marketplace/src/market-contract/nft_callbacks.ts" />

## sale.ts {#sale-ts}

Now that you're familiar with the process of both adding storage and listing NFTs on the marketplace, let's go through what you can do once a sale has been listed. The `sale.ts` file outlines the functions for updating the price, removing, and purchasing NFTs.

### Sale object {#sale-object}

It's important to understand what information the contract is storing for each sale object. Since the marketplace has many NFTs listed that come from different NFT contracts, simply storing the token ID would not be enough to distinguish between different NFTs. This is why you need to keep track of both the token ID and the contract by which the NFT came from. In addition, for each listing, the contract must keep track of the approval ID it was given to transfer the NFT. Finally, the owner and sale conditions are needed.

<Github language="js" start="9" end="42" url="https://github.com/near-examples/nft-tutorial-js/blob/8.marketplace/src/market-contract/sale.ts" />

### Removing sales {#removing-sales}

In order to remove a listing, the owner must call the `remove_sale` function and pass the NFT contract and token ID. Behind the scenes, this calls the `internallyRemoveSale` function which you can find in the `internal.ts` file. This will assert one yoctoNEAR for security reasons.

<Github language="js" start="44" end="65" url="https://github.com/near-examples/nft-tutorial-js/blob/8.marketplace/src/market-contract/sale.ts" />

### Updating price {#updating-price}

In order to update the list price of a token, the owner must call the `update_price` function and pass in the contract, token ID, and desired price. This will get the sale object, change the sale conditions, and insert it back. For security reasons, this function will assert one yoctoNEAR.

<Github language="js" start="67" end="96" url="https://github.com/near-examples/nft-tutorial-js/blob/8.marketplace/src/market-contract/sale.ts" />

### Purchasing NFTs {#purchasing-nfts}

For purchasing NFTs, you must call the `offer` function. It takes an `nft_contract_id` and `token_id` as parameters. You must attach the correct amount of NEAR to the call in order to purchase. Behind the scenes, this will make sure your deposit is greater than the list price and call a private method `processPurchase` which will perform a cross-contract call to the NFT contract to invoke the `nft_transfer_payout` function. This will transfer the NFT using the [approval management](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement) standard that you learned about and it will return the `Payout` object which includes royalties.

The marketplace will then call `resolve_purchase` where it will check for malicious payout objects and then if everything went well, it will pay the correct accounts.

<Github language="js" start="98" end="131" url="https://github.com/near-examples/nft-tutorial-js/blob/8.marketplace/src/market-contract/sale.ts" />

## sale_view.ts {#sale_view-ts}

The final file we'll go through is the `sale_view.ts` file. This is where some of the enumeration methods are outlined. It allows users to query for important information regarding sales.

### Total supply {#total-supply}

To query for the total supply of NFTs listed on the marketplace, you can call the `get_supply_sales` function. An example can be seen below.

```bash
near view $MARKETPLACE_CONTRACT_ID get_supply_sales
```

### Total supply by owner {#total-supply-by-owner}

To query for the total supply of NFTs listed by a specific owner on the marketplace, you can call the `get_supply_by_owner_id` function. An example can be seen below.

```bash
near view $MARKETPLACE_CONTRACT_ID get_supply_by_owner_id '{"account_id": "benji.testnet"}'
```

### Total supply by contract {#total-supply-by-contract}

To query for the total supply of NFTs that belong to a specific contract, you can call the `get_supply_by_nft_contract_id` function. An example can be seen below.

```bash
near view $MARKETPLACE_CONTRACT_ID get_supply_by_nft_contract_id '{"nft_contract_id": "fayyr-nft.testnet"}'
```

### Query for listing information {#query-listing-information}

To query for important information for a specific listing, you can call the `get_sale` function. This requires that you pass in the `nft_contract_token`. This is essentially the unique identifier for sales on the market contract as explained earlier. It consists of the NFT contract followed by a `DELIMITER` followed by the token ID. In this contract, the `DELIMITER` is simply a period: `.`.  An example of this query can be seen below.

```bash
near view $MARKETPLACE_CONTRACT_ID get_sale '{"nft_contract_token": "fayyr-nft.testnet.token-42"}'
```

In addition, you can query for paginated information about the listings for a given owner by calling the `get_sales_by_owner_id` function.

```bash
near view $MARKETPLACE_CONTRACT_ID get_sales_by_owner_id '{"account_id": "benji.testnet", "from_index": "5", "limit": 10}'
```

Finally, you can query for paginated information about the listings that originate from a given NFT contract by calling the `get_sales_by_nft_contract_id` function.

```bash
near view $MARKETPLACE_CONTRACT_ID get_sales_by_nft_contract_id '{"nft_contract_id": "fayyr-nft.testnet, "from_index": "5", "limit": 10}'
```

## Conclusion

In this tutorial, you learned about the basics of a marketplace contract and how it works. You went through the [index.ts](#index-ts) file and learned about the [initialization function](#initialization-function) in addition to the [storage management](#storage-management-model) model. 

You then went through the [nft_callbacks](#nft_callbacks-ts) file to understand how to [list NFTs](#listing-logic). In addition, you went through some important functions needed for after you've listed an NFT. This includes [removing sales](#removing-sales), [updating the price](#updating-price), and [purchasing NFTs](#purchasing-nfts).

Finally, you went through the enumeration methods found in the [`sale_view`](#sale_view-ts) file. These allow you to query for important information found on the marketplace contract. 

You should now have a solid understanding of NFTs and marketplaces on NEAR. Feel free to branch off and expand on these contracts to create whatever cool applications you'd like. The world is your oyster! Thanks for joining on this journey and don't forget, **Go Team!**

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.0.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`

:::

'''
'''--- docs/3.tutorials/nfts/minecraft-nfts.md ---
---
id: minecraft-nfts
title: Create NFTs in Minecraft
sidebar_label: Minecraft NFTs
---

> In this tutorial you'll learn how to take your custom Minecraft creations and mint the schematics into NFTs on the NEAR blockchain!

## Overview

This tutorial will run you through minting Minecraft structures of any size onto the NEAR blockchain. It will allow you to copy and paste the designs into your own worlds. For this, we will be using WorldEdit to download and read the schematics and we'll put them on-chain using [IPFS](https://ipfs.io/).

## Prerequisites

:::info
It is recommended that you first complete the introductory **[minting NFTs tutorial](/tutorials/nfts/minting-nfts)**
:::

To complete this tutorial successfully, you'll need:

- [A Minecraft account](https://www.minecraft.net/)
- [WorldEdit installed](https://worldedit.enginehub.org/en/latest/install/)
- [A NEAR account](#wallet)
- [NEAR command-line interface](/tools/near-cli#setup) (`near-cli`)

## Creating a Schematic

In this section, we'll be creating the Minecraft schematic to put on chain.

### Setup

- Once you have [WorldEdit](https://worldedit.enginehub.org/en/latest/install/) installed and Minecraft loaded up, let's check if WorldEdit is working properly by running:

```bash
//pos1
```

If WorldEdit is properly installed, it should output `First position set to (X, Y, Z).` where X, Y, and Z are coordinates.

For this tutorial, we will be minting a small village house. To follow along, choose any structure that you'd like to mint as shown below:

![Village House Minecraft](/docs/assets/nfts/village-house-minecraft.png)

You'll then want to choose the boundaries of the structure that you'd like to copy. We will turn these into schematics which will be placed on chain for you or others to download and paste in your own worlds.

- To do this, we'll need to outline the boundaries of the build using WorldEdit. Stand in the bottom left corner of your build and run:

```bash
//pos1
```

- You can then move to the top right corner and run:

```bash
//pos2
```

Setting these two positions has now created a cube around your build.

- We can now copy the contents of that build by running:

```bash
//copy
```

The output should look something like this:

![Copy Chat Message](/docs/assets/nfts/copy-chat-message-minecraft.png)

:::info TIP
Remember to note the position of your player when copying. If you copy the build and lets say you're standing on the roof, when you paste the build it will paste the build in a way that will result in you standing on the roof.
:::

### Sanity Check

We can check and see if our build is fine by pasting what we just copied elsewhere in our world.

- Go to a location that you would like to paste the build and run:

```bash
//paste
```

In the example below, we pasted the village house floating above a coral reef biome. You should also see a response notifying you that the clipboard has been pasted. (See example below)

![Pasted Minecraft House](/docs/assets/nfts/pasted-minecraft-house.png)

### Creating the Schematics File

When you're happy with the build you've just copied and pasted, it's time to create the schematic file that we'll mint into an NFT. To do this we'll run a WorldEdit command that will save the schematic file on our local machine.

- To do this, run the command `schematic save FILE_NAME` replacing `FILE_NAME` with a name of your choosing.

This will save the file to your Minecraft folder with under `minecraft/config/worldedit/schematics` witha `.schem` extension.

- Now test your file by loading the schematic we just saved using `schematic load FILE_NAME`.

This will load the schematic to our clipboard and we're free to paste it in our world.

## Minting the Schematic

In this section, we'll mint the schematics file, we've just created and put it on the blockchain using IPFS and web3.storage. In order to proceed, you need to locate the `FILE_NAME.schem` we created in the last section. This file can be found in your Minecraft folder under `minecraft/config/worldedit/schematics`. The location of your minecraft folder differs depending on your OS.

### Uploading the schematic

To upload the schematic, we are going to use the free [web3.storage](https://web3.storage/) service built for storing off-chain data.
Web3.storage offers free decentralized storage and bandwidth on [IPFS](https://ipfs.io/) and [Filecoin](https://filecoin.io/).

#### Steps

1. Register an account and log in to [web3.storage](https://web3.storage/) either via email or your GitHub.

2. Go to the [Files](https://web3.storage/) section, and click on the [Upload more Files](https://web3.storage/) button.

   ![web3.storage](/docs/assets/nfts/web3-storage-upload.png)

3. Once you have uploaded your file, you'll get a unique `CID` for your content, and a URL similar to:
   ```
   https://bafybeidadhfilezx23dcdaueo3bjuafqeehokw33vyepkjtppigorrhbpy.ipfs.dweb.link/
   ```

:::info
See the [web3.storage docs](https://docs.web3.storage/) for information on uploading multiple files and available API endpoints.
:::

### Interacting With the Contract

NEAR has already deployed a contract to the account `nft.examples.testnet` which allows users to freely mint tokens. This is the account we'll be interacting with to mint our NFTs. Alternatively, if you've deployed a contract when following the original tutorial, you can use that as well.

:::info
We'll be using the IPFS link we got in step three of the uploading process above as the media value when calling `nft_mint`.
:::

- Run the following command and replace the `receiver_id` field and the `--accountId` flag with the account ID you're [logged into](/tools/near-cli#near-login) with NEAR CLI:

```bash
near call nft.examples.testnet nft_mint '{"token_id": "my-token-unique-id", "receiver_id": "YOUR_ACCOUNT", "metadata": { "title": "YOUR NFT TITLE", "description": "YOUR NFT DESCRIPTION", "media": "https://bafybeidadhfilezx23dcdaueo3bjuafqeehokw33vyepkjtppigorrhbpy.ipfs.dweb.link/", "copies": 1}}' --accountId YOUR_ACCOUNT --deposit 0.1
```
- Be sure to replace the title, description and media URL with your own.

<details>
<summary>Example response: </summary>
<p>

```json
{
  "token_id": "0",
  "owner_id": "YOUR_ACCOUNT",
  "metadata": {
    "title": "My awesome Minecraft NFT",
    "description": "Custom log cabin",
    "media": "https://bafybeidadhfilezx23dcdaueo3bjuafqeehokw33vyepkjtppigorrhbpy.ipfs.dweb.link/",
    "media_hash": null,
    "copies": 1,
    "issued_at": null,
    "expires_at": null,
    "starts_at": null,
    "updated_at": null,
    "extra": null,
    "reference": null,
    "reference_hash": null
  },
  "approved_account_ids": {}
}
```

</p>
</details>

- To view tokens owned by an account on the `example-nft` contract, you can call the contract with the following `near-cli` command:

```bash
near view nft.examples.testnet nft_tokens_for_owner '{"account_id": "YOUR_ACCOUNT"}'
```

<details>
<summary>Example response: </summary>
<p>

```json
[
  {
    "token_id": "0",
    "owner_id": "YOUR_ACCOUNT",
    "metadata": {
      "title": "Some Art",
      "description": "My NFT media",
      "media": "https://bafybeidadhfilezx23dcdaueo3bjuafqeehokw33vyepkjtppigorrhbpy.ipfs.dweb.link/",
      "media_hash": null,
      "copies": 1,
      "issued_at": null,
      "expires_at": null,
      "starts_at": null,
      "updated_at": null,
      "extra": null,
      "reference": null,
      "reference_hash": null
    },
    "approved_account_ids": {}
  }
]
```

</p>
</details>

## Using the Village Schematic

Now that you've uploaded your schematic to the blockchain, all someone would need to do to paste it in their own world would be to download the `*.schem` file associated with the IPFS link we minted the NFT with and place it in their schematics folder.

As a test, we've minted an NFT that contains the village schematic we've been working with so that you can download it and paste it in your world.

### Getting the Schematics File

The first thing you'll need to do is view the metadata for the token we've minted that contains the IPFS link to the village schematic. We've minted a token with the ID `village-schematic` under the account `village-schematic.testnet`.

- To get the media link, run the following command:

```bash
near view nft.examples.testnet nft_tokens_for_owner '{"account_id": "village-schematic.testnet"}'
```

<details>
<summary>Expected response: </summary>
<p>

```bash
[
  {
    token_id: 'village-schematic',
    owner_id: 'village-schematic.testnet',
    metadata: {
      title: 'Village Schematic',
      description: 'Blockcraft Village Schematic Tutorial NFT',
      media: 'https://bafybeidadhfilezx23dcdaueo3bjuafqeehokw33vyepkjtppigorrhbpy.ipfs.dweb.link/',
      media_hash: null,
      copies: 1,
      issued_at: null,
      expires_at: null,
      starts_at: null,
      updated_at: null,
      extra: null,
      reference: null,
      reference_hash: null
    },
    approved_account_ids: {}
  }
]
```

</p>
</details>

- You can then take the media link and paste it into your browser. It should send you to a page that looks similar to this:

![IPFS Village Schem](/docs/assets/nfts/IPFS-village-schem.png)

- If you click on the file called `village-house.schem`, it will download the file.
- You can then copy the schematics file and paste it into your `minecraft/config/worldedit/schematics` folder.

### Loading the Schematics File in Minecraft

- After you've pasted the schematics file into the `minecraft/config/worldedit/schematics` folder, you can then load the schematic into your clipboard by running the following command in your minecraft world:

```bash
//schematics load village-house
```

- You can now paste the file anywhere in your world by simply using the `//paste` command and voila! You should see something similar to this:

![Final Village Pasting](/docs/assets/nfts/final-village-pasting.png)

Congratulations! You've just learned how to mint a Mincraft schematic NFT and load it into your world!

## Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `2.1.1`

'''
'''--- docs/3.tutorials/nfts/minting-nfts.md ---
---
id: minting-nfts
title: Minting NFTs
sidebar_label: Minting NFTs
---

In this tutorial you'll learn how to easily create your own NFTs without doing any software development by using a readily-available smart contract and a decentralized storage solution like [IPFS](https://ipfs.io/).

## Overview {#overview}

This article will guide you in setting up an [NFT smart contract](#non-fungible-token-contract), and show you [how to build](#building-the-contract), [test](#testing-the-contract) and [deploy](#deploying-the-contract) your NFT contract on NEAR.
Once the contract is deployed, you'll learn [how to mint](#minting-your-nfts) non-fungible tokens from media files [stored on IPFS](#uploading-the-image) and view them in your Wallet.

## Prerequisites {#prerequisites}

To complete this tutorial successfully, you'll need:

- [Rust toolchain](/build/smart-contracts/quickstart#prerequisites)
- [A NEAR account](#wallet)
- [NEAR command-line interface](/tools/near-cli#setup) (`near-cli`)

## Wallet {#wallet}

To store your non-fungible tokens you'll need a [NEAR Wallet](https://testnet.mynearwallet.com//).
If you don't have one yet, you can create one easily by following [these instructions](https://testnet.mynearwallet.com/create).

> **Tip:** for this tutorial we'll use a `testnet` wallet account. The `testnet` network is free and there's no need to deposit funds.

Once you have your Wallet account, you can click on the [Collectibles](https://testnet.mynearwallet.com//?tab=collectibles) tab where all your NFTs will be listed:

![Wallet](/docs/assets/nfts/nft-wallet.png)

<!--
Briefly talks about how the wallet listens for methods that start with `nft_` and then flags the contracts.
-->

## IPFS {#ipfs}

The [InterPlanetary File System](https://ipfs.io/) (IPFS) is a protocol and peer-to-peer network for storing and sharing data in a distributed file system. IPFS uses content-addressing to uniquely identify each file in a global namespace connecting all computing devices.

### Uploading the image {#uploading-the-image}

To upload the NFT image, you should use a [decentralized storage](/concepts/storage/storage-solutions) provider such as IPFS.

:::note
This example uses IPFS, but you could use a different solution like Filecoin, Arweave, or a regular centralized Web2 hosting.
:::

Once you have uploaded your file to IPFS, you'll get a unique `CID` for your content, and a URL like:

```
https://bafyreiabag3ztnhe5pg7js4bj6sxuvkz3sdf76cjvcuqjoidvnfjz7vwrq.ipfs.dweb.link/
```

## Non-fungible Token contract {#non-fungible-token-contract}

[This repository](https://github.com/near-examples/NFT) includes an example implementation of a [non-fungible token] contract which uses [near-contract-standards] and simulation tests.

[non-fungible token]: https://nomicon.io/Standards/NonFungibleToken
[near-contract-standards]: https://github.com/near/near-sdk-rs/tree/master/near-contract-standards

### Clone the NFT repository {#clone-the-nft-repository}

In your terminal run the following command to clone the NFT repo:

```
git clone https://github.com/near-examples/NFT
```

### Explore the smart contract {#explore-the-smart-contract}

The source code for this contract can be found in `nft/src/lib.rs`. This contract contains logic which follows the [NEP-171 standard][non-fungible token] (NEAR Enhancement Proposal) and the implementation of this standard which can be found [here](https://github.com/near/near-sdk-rs/blob/master/near-contract-standards/src/non_fungible_token/core/core_impl.rs).

At first, the code can be a bit overwhelming, but if we only consider the aspects involved with minting, we can break it down into 2 main categories - the contract struct and the minting process.

#### Contract Struct {#contract-struct}

The contract keeps track of two pieces of information - `tokens` and `metadata`. For the purpose of this tutorial we will only deal with the `tokens` field.

```rust
#[near(contract_state)]
#[derive(PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
}
```

The tokens are of type `NonFungibleToken` which come from the [core standards](https://github.com/near/near-sdk-rs/blob/master/near-contract-standards/src/non_fungible_token/core/core_impl.rs). There are several fields that make up the struct but for the purpose of this tutorial, we'll only be concerned with the `owner_by_id` field. This keeps track of the owner for any given token.

```rust
pub struct NonFungibleToken {
    // owner of contract
    pub owner_id: AccountId,

    // keeps track of the owner for any given token ID.
    pub owner_by_id: TreeMap<TokenId, AccountId>,

    ...
}
```

Now that we've explored behind the scenes and where the data is being kept, let's move to the minting functionality.

#### Minting {#minting}

In order for a token to be minted you will need to call the `nft_mint` function. There are three arguments that are passed to this function:

- `token_id`
- `receiver_id`
- `token_metadata`

This function executes `self.tokens.mint` which calls the mint function in the [core standards](https://github.com/near/near-sdk-rs/blob/master/near-contract-standards/src/non_fungible_token/core/core_impl.rs) creating a record of the token with the owner being `receiver_id`.

```rust
#[payable]
pub fn nft_mint(
    &mut self,
    token_id: TokenId,
    receiver_id: ValidAccountId,
    token_metadata: TokenMetadata,
) -> Token {
    self.tokens.mint(token_id, receiver_id, Some(token_metadata))
}
```

This creates that record by inserting the token into the `owner_by_id` data structure that we mentioned in the previous section.

```rust
self.owner_by_id.insert(&token_id, &owner_id);
```

### Building the contract {#building-the-contract}

To build your contract run the following command in your terminal which builds your contract using Rust's `cargo`.

```bash
./scripts/build.sh
```

This will generate WASM binaries into your `res/` directory. This WASM file is the smart contract we'll be deploying onto the NEAR blockchain.

> **Tip:** If you run into errors make sure you have [Rust installed](/build/smart-contracts/quickstart#prerequisites) and are in the root directory of the NFT example.

### Testing the contract {#testing-the-contract}

Written in the smart contract there are pre-written tests that you can run. Run the following command in your terminal to perform these simple tests to verify that your contract code is working.

```bash
cargo test -- --nocapture
```

> **Note:** the more complex simulation tests aren't performed with this command but you can find them in `tests/sim`.

## Using the NFT contract {#using-the-nft-contract}

Now that you have successfully built and tested the NFT smart contract, you're ready to [deploy it](#deploying-the-contract)
and start using it [mint your NFTs](#minting-your-nfts).

### Deploying the contract {#deploying-the-contract}

This smart contract will be deployed to your NEAR account. Because NEAR allows the ability to upgrade contracts on the same account, initialization functions must be cleared.

> **Note:** If you'd like to run this example on a NEAR account that has had prior contracts deployed, please use the `near-cli` command `near delete` and then recreate it in Wallet. To create (or recreate) an account, please follow the directions in [Test Wallet](https://testnet.mynearwallet.com/) or ([NEAR Wallet](https://wallet.near.org/) if we're using `mainnet`).

Log in to your newly created account with `near-cli` by running the following command in your terminal.

```bash
near login
```

To make this tutorial easier to copy/paste, we're going to set an environment variable for your account ID. In the command below, replace `YOUR_ACCOUNT_NAME` with the account name you just logged in with including the `.testnet` (or `.near` for `mainnet`):

```bash
export ID=YOUR_ACCOUNT_NAME
```

Test that the environment variable is set correctly by running:

```bash
echo $ID
```

Verify that the correct account ID is printed in the terminal. If everything looks correct you can now deploy your contract.
In the root of your NFT project run the following command to deploy your smart contract.

```bash
near deploy --wasmFile res/non_fungible_token.wasm --accountId $ID
```

<details>
<summary>Example response: </summary>
<p>

```bash
Starting deployment. Account id: ex-1.testnet, node: https://rpc.testnet.near.org, file: res/non_fungible_token.wasm
Transaction Id E1AoeTjvuNbDDdNS9SqKfoWiZT95keFrRUmsB65fVZ52
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/E1AoeTjvuNbDDdNS9SqKfoWiZT95keFrRUmsB65fVZ52
Done deploying to ex-1.testnet
```

</p>
</details>

> **Note:** For `mainnet` you will need to prepend your command with `NEAR_ENV=mainnet`. [See here](/tools/near-cli#network-selection) for more information.

### Minting your NFTs {#minting-your-nfts}

A smart contract can define an initialization method that can be used to set the contract's initial state.
In our case, we need to initialize the NFT contract before usage. For now, we'll initialize it with the default metadata.

> **Note:** each account has a data area called `storage`, which is persistent between function calls and transactions.
> For example, when you initialize a contract, the initial state is saved in the persistent storage.

```bash
near call $ID new_default_meta '{"owner_id": "'$ID'"}' --accountId $ID
```

> **Tip:** you can find more info about the NFT metadata at [nomicon.io](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata).

You can then view the metadata by running the following `view` call:

```bash
near view $ID nft_metadata
```

<details>
<summary>Example response: </summary>
<p>

```json
{
  "spec": "nft-1.0.0",
  "name": "Example NEAR non-fungible token",
  "symbol": "EXAMPLE",
  "icon": "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E",
  "base_uri": null,
  "reference": null,
  "reference_hash": null
}
```

</p>
</details>

Now let's mint our first token! The following command will mint one copy of your NFT. Replace the `media` url with the one you [uploaded to IPFS](#uploading-the-image) earlier:

```bash
near call $ID nft_mint '{"token_id": "0", "receiver_id": "'$ID'", "token_metadata": { "title": "Some Art", "description": "My NFT media", "media": "https://bafkreiabag3ztnhe5pg7js4bj6sxuvkz3sdf76cjvcuqjoidvnfjz7vwrq.ipfs.dweb.link/", "copies": 1}}' --accountId $ID --deposit 0.1
```

<details>
<summary>Example response: </summary>
<p>

```json
{
  "token_id": "0",
  "owner_id": "dev-xxxxxx-xxxxxxx",
  "metadata": {
    "title": "Some Art",
    "description": "My NFT media",
    "media": "https://bafkreiabag3ztnhe5pg7js4bj6sxuvkz3sdf76cjvcuqjoidvnfjz7vwrq.ipfs.dweb.link/",
    "media_hash": null,
    "copies": 1,
    "issued_at": null,
    "expires_at": null,
    "starts_at": null,
    "updated_at": null,
    "extra": null,
    "reference": null,
    "reference_hash": null
  },
  "approved_account_ids": {}
}
```

</p>
</details>

To view tokens owned by an account you can call the NFT contract with the following `near-cli` command:

```bash
near view $ID nft_tokens_for_owner '{"account_id": "'$ID'"}'
```

<details>
<summary>Example response: </summary>
<p>

```json
[
  {
    "token_id": "0",
    "owner_id": "dev-xxxxxx-xxxxxxx",
    "metadata": {
      "title": "Some Art",
      "description": "My NFT media",
      "media": "https://bafkreiabag3ztnhe5pg7js4bj6sxuvkz3sdf76cjvcuqjoidvnfjz7vwrq.ipfs.dweb.link/",
      "media_hash": null,
      "copies": 1,
      "issued_at": null,
      "expires_at": null,
      "starts_at": null,
      "updated_at": null,
      "extra": null,
      "reference": null,
      "reference_hash": null
    },
    "approved_account_ids": {}
  }
]
```

</p>
</details>

> <br/>
>
> **Tip:** after you mint your first non-fungible token, you can [view it in your Wallet](https://testnet.mynearwallet.com//?tab=collectibles):
>
> ![Wallet with token](/docs/assets/nfts/nft-wallet-token.png)
>
> <br/>

**_Congratulations! You just minted your first NFT token on the NEAR blockchain!_** üéâ

## Final remarks {#final-remarks}

This basic example illustrates all the required steps to deploy an NFT smart contract, store media files on IPFS,
and start minting your own non-fungible tokens.

Now that you're familiar with the process, you can check out our [NFT Example](https://examples.near.org/NFT) and learn more about the smart contract code and how you can transfer minted tokens to other accounts.
Finally, if you are new to Rust and want to dive into smart contract development, our [Quick-start guide](../../2.build/2.smart-contracts/quickstart.md) is a great place to start.

**_Happy minting!_** ü™ô

## Blockcraft - a Practical Extension

If you'd like to learn how to use Minecraft to mint NFTs and copy/paste builds across different worlds while storing all your data on-chain, be sure to check out our [Minecraft tutorial](/tutorials/nfts/minecraft-nfts)

## Versioning for this article {#versioning-for-this-article}

At the time of this writing, this example works with the following versions:

- cargo: `cargo 1.54.0 (5ae8d74b3 2021-06-22)`
- rustc: `rustc 1.54.0 (a178d0322 2021-07-26)`
- near-cli: `2.1.1`

'''
'''--- docs/3.tutorials/nfts/simple-nft-minting-example.md ---
---
id: minting-nft-frontend
title: Minting NFT Front-end
sidebar_label: Minting Front-end
---
import {Github} from "@site/src/components/codetabs"

# NFT Minting Front-end

> In this tutorial you'll learn how to create a simple NFT front-end and mint a "Go Team" NFT on the NEAR blockchain straight from your web browser.

## App Overview

The app is fairly simple: the user signs in and hits the <kbd>Mint NFT</kbd> button. Once the user hits the mint button, a "Go Team" NFT is minted and sent to their NEAR Wallet.

![Front-end](/docs/assets/nfts/nft-mint-frontend.png)

## Smart Contract code

The code for the NFT smart contract can be found in the [Zero to Hero NFT tutorial](/tutorials/nfts/introduction)'s  [GitHub repository](https://github.com/near-examples/nft-tutorial/tree/main/nft-contract/src), under the `main` branch.

The contract methods used in this application are as follows:

- `nft_mint`: Function used to mint tokens.
- `check_token`: Custom function created to check for the existence of a token. This helps to ensure one token per user.

## Front-end

The front-end of the contract was implemented using `create-near-app`. [React Bootstrap](https://react-bootstrap.github.io/) was used for the styling of the application.

To bootstrap your React front-end, run the following command on your terminal:

```sh
npx create-near-app --frontend react --contract rust
```

Then, simply import the contract files from the `main` branch, and you'll have the needed structure to run the application.

### Start

Upon mounting the application's components, the app checks for the existence of a non-fungible token.

<Github language="js" start="24" end="46" url="https://github.com/near-examples/nft-tutorial-frontend/blob/master/src/App.js" />

If no prior NFT has been minted, the mint button will be available for use.

### Mint button

Here is the function behind the mint button. The meta data has been filled out for the user already:

- `token_id` is set by the user's account id,
- and the `media` link is hard-coded to a `goteam-gif.gif` hosted on IPFS.

<Github language="js" start="7" end="23" url="https://github.com/near-examples/nft-tutorial-frontend/blob/master/src/Components/MintingTool.js" />

After hitting the <kbd>Mint NFT</kbd> button the user will be able to check out the newly minted NFT at [wallet.testnet.near.org](https://testnet.mynearwallet.com//?tab=collectibles), under the Wallet's `Collectibles` tab.

## Final remarks

You can find the complete application repository [on GitHub](https://github.com/near-examples/nft-tutorial-frontend) to clone and run.
In the configuration folder you can see that this smart contract has been deployed to `nft-frontend-simple-mint.blockhead.testnet`:

<Github language="js" start="1" end="2" url="https://github.com/near-examples/nft-tutorial-frontend/blob/master/src/config.js" />

You can also check out the [explorer link here](https://testnet.nearblocks.io/address/nft-frontend-simple-mint.blockhead.testnet) to see how many individuals have been minting their own _Go Team_ NFTs. _**Happy Minting!**_

:::tip
Clone and run this example from https://github.com/near-examples/nft-tutorial-frontend
:::

'''
'''--- docs/3.tutorials/templates/blog.md ---
---
id: blog
title: Onchain Blog
---

# Blogchain

[![Demo](https://img.shields.io/badge/Demo-Visit%20Demo-brightgreen)](https://blogchain.mintbase.xyz/)
[![Deploy](https://img.shields.io/badge/Deploy-on%20Vercel-blue)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2FMintbase%2Ftemplates%2Ftree%2Fmain%2Fblogchain)

Blogchain makes your content unstoppable. Transform your blogs into smart contracts and posts into NFTs.

![img](https://i.imgur.com/oAVyr9o.png)

:::tip Mintbase Templates
This is part of the [Mintbase Templates](https://templates.mintbase.xyz/), a collection of templates that you can use to scaffold your own project
:::

---

## Project Walkthrough

Within the framework of blogchain, every blog manifests as an nft contract deployed from the Mintbase contract factory, while each individual blog post is uniquely represented as a non-fungible token (NFT).

*NOTE: As a standard on Mintbase as we use the latest versions of Next.js we recommend using pnpm, but the package manager is up to your personal choice.*

---

## Run the project

```bash
# install
pnpm i
#run project
pnpm run dev
```

---

## Create a Blog (deploy contract)

### Step 1: check if the contract (blog) name already exists

Using [@mintbase-js/data](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/data/api/checkstorename) checkStoreName method we can check if the store already exists.

```typescript
const { data: checkStore } = await checkStoreName(
  data.name,
  NEAR_NETWORKS.TESTNET
);

if (checkStore?.nft_contracts.length === 0) {
  (...)
}
```

<hr class="subsection" />

### Step 2: if contract name doesn't exist execute the deploy contract action with the instantiated wallet

Create deploy contract args using [mintbase-js/sdk](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/sdk/deploycontract) deployContract method. This will deploy an NFT contract from the [mintbase contract factory](https://github.com/Mintbase/mb-contracts/tree/main/mb-factory-v1)

```typescript
const wallet = await selector.wallet();

const deployArgs = deployContract({
  name: data.name,
  ownerId: activeAccountId,
  factoryContractId: MINTBASE_CONTRACTS.testnet,
  metadata: {
    symbol: "",
  },
});
```

We can then execute the deploy contract by passing in the wallet. If you wan't to learn about wallet connection check out the [wallet starter template](https://templates.mintbase.xyz/templates/starter-next)

```typescript
  await execute({ wallet }, deployArgs);
```

---

## Create a Blog Post (mint an NFT)

### Step 1: call storage method to upload file inserted by the user to arweave

Using [@mintbase-js/storage](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/storage#uploadreference-referenceobject-referenceobject-arweaveresponse) uploadReference method we upload the nft image to arweave.

```typescript
const metadata = {
  title: data.title,
  media: data.media,
};
const referenceJson = await uploadReference(metadata);
const reference = referenceJson.id;
```

<hr class="subsection" />

### Step 2: mint the nft in the contract (blog)

Create mint args using [mintbase-js/sdk](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/sdk/mint) mint method.

```typescript
const wallet = await selector.wallet();

const mintCall = mint({
  noMedia: true,
  metadata: {
    reference: reference,
    title: data.title,
    description: postContent,
    extra: "blogpost",
  },
  contractAddress: data.contract,
  ownerId: activeAccountId,
});
```

We can then execute the mint nft method

```typescript
  await execute({ wallet }, mintCall);
```

:::note
We populate the 'extra' field with the value 'blogpost' to subsequently filter the displayed NFTs and blogs in blogchain, ensuring that only blogs are included.
:::

---

## Get Data

### Get blog posts (nfts) from a blog (smart contract)

Using [Mintbase GraphQL Indexer](https://docs.mintbase.xyz/dev/mintbase-graph) we can fetch the nfts from a specific smart contract - to filter by blog post we use 'blogpost' as an extra field as explained in the previous step.

```typescript
export const GET_BLOG_POSTS =
`
query GET_BLOG_POSTS($contractId: String!) {
    mb_views_nft_tokens(
      where: {extra: {_eq: "blogpost"}, _and: {nft_contract_id: {_eq: $contractId}}}
    ) {
      metadata_id
      title
      description
      media
      minted_timestamp
    }
  }
  `;
```

<hr class="subsection" />

### Get user blog posts (nfts)

```typescript
export const GET_USER_POSTS =
`
query GET_USER_POSTS($accountId: String!) {
    mb_views_nft_tokens(
      where: {extra: {_eq: "blogpost"}, _and: {nft_contract_owner_id: {_eq: $accountId}}}
    ) {
      metadata_id
      title
      description
      media
      minted_timestamp
    }
  }
  `;
```

<hr class="subsection" />

### Get user blogs (smart contracts)

```typescript
export const GET_USER_BLOGS =
`
query GET_USER_BLOGS($accountId: String!) {
    nft_contracts(where: {owner_id: {_eq: $accountId}}) {
      id
    }
  }
  `;
```

<hr class="subsection" />

### Get latest blogs (smart contracts)

```typescript
export const GET_LATEST_UPDATED_BLOGS =
`
query GET_LATEST_UPDATED_BLOGS {
  mb_views_nft_metadata(
    where: {extra: {_eq: "blogpost"}}
    distinct_on: [nft_contract_id, nft_contract_created_at]
    limit: 6
    order_by: [{nft_contract_created_at: desc}, {nft_contract_id: desc}]
  ) {
    nft_contract_id
    nft_contract_owner_id
  }
  }
  `;
```

<hr class="subsection" />

### Get latest blog posts (nfts)

```typescript
export const GET_LATEST_POSTS =
`
query GET_LATEST_POSTS {
    mb_views_nft_tokens(
      where: {extra: {_eq: "blogpost"}}
      limit: 10
      order_by: {minted_timestamp: desc}
    ) {
    metadata_id
    title
    description
    media
    minted_timestamp
    minter
    nft_contract_id
    }
  }`;
```

<hr class="subsection" />

### Get blog post (nft) data

```typescript
export const GET_POST_METADATA =
`
query GET_POST_METADATA($metadataId: String!) {
    mb_views_nft_tokens(where: {metadata_id: {_eq: $metadataId}}) {
      metadata_id
      title
      description
      media
      minted_timestamp
      minter
      nft_contract_id
    }
  }`;
```

Presently, this template exclusively functions within the testnet environment. To transition to a different network the configuration must be changed in ```<MintbaseWalletContextProvider>``` and every 'testnet' instance.

---

## Extending

This project is setup using Next.js + @mintbase/js
You can use this project as a reference to build your own, and use or remove any library you think it would suit your needs.

:::info Get in touch
You can get in touch with the mintbase team using the following channels:

- Support: [Join the Telegram](https://tg.me/mintdev)
- Twitter: [@mintbase](https://twitter.com/mintbase)
:::
'''
'''--- docs/3.tutorials/templates/marketplace.md ---
# Marketplace Frontend

[![Demo](https://img.shields.io/badge/Demo-Visit%20Demo-brightgreen)](https://marketplace-template.mintbase.xyz/)
[![Deploy](https://img.shields.io/badge/Deploy-on%20Vercel-blue)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2FMintbase%2Ftemplates%2Ftree%2Fmain%2Fmarketplace)

Unlock Your NFT Storefront: Clone & Customize Your Path to Blockchain Success with this whitelabel marketplace template!

![img](https://i.imgur.com/FjcUss9.png)

:::tip Mintbase Templates
This is part of the [Mintbase Templates](https://templates.mintbase.xyz/), a collection of templates that you can use to scaffold your own project
:::

---

## Project Walkthrough

This guide will take you step by step through the process of creating a basic marketplace frontend where you can purchase tokens and filter your selection by store. It uses [mintbase-js/data](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/data) for retrieving data and [mintbase-js/sdk](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/sdk) for executing marketplace methods on the [mintbase marketplace contract](https://github.com/Mintbase/mb-contracts/tree/main/mb-interop-market).

The mintbase-js/data package provides convenient functions for retrieving nft data from the mintbase indexer. In this example, you will be able to view and purchase NFTs from a specific nft contract.

You can find more information on Github: [GitHub link](https://github.com/Mintbase/mintbase-js/tree/beta/packages/data)

A live demo of the marketplace can be found here: [Live demo link](https://marketplace-template.mintbase.xyz/)

### Setup

```bash
# install dependencies
pnpm install

#run the project
pnpm dev
```

<hr class="subsection" />

### Step 1: Connect Wallet

Before proceeding, it is important to have a wallet connection feature implemented in your application in order to interact with the contract. To do this, you can check our guide [Wallet Connection Guide](https://docs.mintbase.xyz/dev/getting-started/add-wallet-connection-to-your-react-app).

<hr class="subsection" />

### Step 2: Get NFTs from Store

In this example, we utilized react-query to manage the loading state when retrieving NFTs from the contract via the storeNfts method. This method returns all listed NFTs from the specified contract, allowing you to display them in the user interface.

```ts
// src/hooks/useStoreNfts.ts
import { useQuery } from 'react-query';
import { storeNfts } from '@mintbase-js/data';

const useStoreNfts = (store?: string) => {
  const defaultStores = process.env.NEXT_PUBLIC_STORES || MAINNET_CONFIG.stores;
  const formattedStores = defaultStores.split(/[ ,]+/);

  const { isLoading, error, data } = useQuery(['storeNfts', store], () => storeNfts(store || formattedStores, true), {
    retry: false,
    refetchOnWindowFocus: false,
    select: mapStoreNfts,
  });

  return { ...data, error, loading: isLoading };
};

export { useStoreNfts };
```

<hr class="subsection" />

### Step 3: Get Store Data

To control the tabs, we need to retrieve store data using the storeData method. This method returns the data from the specified contract, enabling you to display it in the user interface.

```ts
// src/hooks/useStoreData.ts
import { useQuery } from 'react-query';
import { storeData } from '@mintbase-js/data';

const useStoreData = () => {
  const defaultStores = process.env.NEXT_PUBLIC_STORES || MAINNET_CONFIG.stores;
  const formattedStores = defaultStores.split(/[ ,]+/);

  const { isLoading, error, data } = useQuery('storeData', () => storeData(formattedStores), {
    retry: false,
    refetchOnWindowFocus: false,
    select: mapStoreData,
  });

  return { ...data, error, loading: isLoading };
};

export { useStoreData };

```

<hr class="subsection" />

### Step 4: Get Metadata from an NFT

To display NFT pricing information, available quantities, and other details in the user interface, it is necessary to access the NFT metadata using the metadataByMetadataId method.

```ts
// src/hooks/useMetadataByMetadataId.ts
import { useQuery } from 'react-query';
import { metadataByMetadataId } from '@mintbase-js/data';

const useMetadataByMetadataId = ({ metadataId }) => {
  const { isLoading, data: metadata } = useQuery('metadataByMetadataId', () => metadataByMetadataId(metadataId), {
    retry: false,
    refetchOnWindowFocus: false,
    select: mapMetadata,
  });

  return { ...metadata, isTokenListLoading: isLoading };
};

export { useMetadataByMetadataId };
```

<hr class="subsection" />

### Step 5: Get Current NEAR Price

To obtain the current price of the NFT in USD, it is necessary to retrieve the current Near price. We accomplish this by using the nearPrice method.

```ts
// src/hooks/useNearPrice.ts
import { useEffect, useState } from 'react';
import { nearPrice } from '@mintbase-js/data';

const useNearPrice = () => {
  const [nearPriceData, setNearPriceData] = useState('0');

  useEffect(() => {
    const getNearPrice = async () => {
      const { data: priceData, error } = await nearPrice();
      setNearPriceData(error ? '0' : priceData);
    };

    getNearPrice();
  }, []);

  return nearPriceData;
};

export { useNearPrice };
```

<hr class="subsection" />

### Step 6: Execute the Contract Call - Buy

The execute method accepts one or more contract call objects and executes them using a specified wallet instance. In this example, we need to use the execute method to execute the "buy" call, allowing the user to purchase the desired NFT.

```ts
const singleBuy = async () => {
    const wallet = await selector.wallet();

    if (tokenId) {
      (await execute(
        { wallet, callbackArgs: callback },
        {
          ...buy({
            contractAddress: nftContractId,
            tokenId,
            affiliateAccount:
              process.env.NEXT_PUBLIC_AFFILIATE_ACCOUNT ||
              MAINNET_CONFIG.affiliate,
            marketId,
            price: nearToYocto(currentPrice?.toString()) || "0",
          }),
        }
      )) as FinalExecutionOutcome;
    }
  };
```

---

## Set ENV variables

Once that's done, copy the `.env.example` file in this directory to `.env.local` (which will be ignored by Git):

```bash
cp .env.example .env.local
```

if you use windows without powershell or cygwin:

```bash
copy .env.example .env.local
```

To get your `api key` visit :

[Mintbase Developers Page for Mainnet](https://www.mintbase.xyz/developer):
[Mintbase Developers Page for testnet](https://testnet.mintbase.xyz/developer):

```
NEXT_PUBLIC_DEVELOPER_KEY=your_mintbase_api_key
```

`NEXT_PUBLIC_NETWORK` could be `testnet` or `mainnet`

```
NEXT_PUBLIC_NETWORK=testnet
```

`NEXT_PUBLIC_STORES` is your store's ids

```
NEXT_PUBLIC_STORES=latium.mintspace2.testnet,mufasa.mintspace2.testnet
```

`NEXT_PUBLIC_AFFILIATE_ACCOUNT` is your near account where your should get your market fee

```
NEXT_PUBLIC_AFFILIATE_ACCOUNT=your_near_account.near
```

## Extending

This project is setup using Next.js + @mintbase/js
You can use this project as a reference to build your own, and use or remove any library you think it would suit your needs.

:::info Get in touch
You can get in touch with the mintbase team using the following channels:

- Support: [Join the Telegram](https://tg.me/mintdev)
- Twitter: [@mintbase](https://twitter.com/mintbase)
:::
'''
'''--- docs/3.tutorials/templates/minter.md ---
---
id: minter
title: NFT minter
---

# NFT Minter

[![Demo](https://img.shields.io/badge/Demo-Visit%20Demo-brightgreen)](https://minter.mintbase.xyz/)
[![Deploy](https://img.shields.io/badge/Deploy-on%20Vercel-blue)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2FMintbase%2Ftemplates%2Fblob%2Fmain%2Fminter)

This is a Next.js 14 frontend minter example that includes a simple interface from which you can mint nfts easily

![img](https://i.imgur.com/QDJPsAA.png)

:::tip Mintbase Templates
This is part of the [Mintbase Templates](https://templates.mintbase.xyz/), a collection of templates that you can use to scaffold your own project
:::

---

## Project Walkthrough

This is a simple minter example built on top of **Next.js 14** using some of [@mintbase-js](https://github.com/Mintbase/mintbase-js) packages.

*NOTE: As a standard on Mintbase as we use the latest versions of Next.js we recommend using pnpm, but the package manager is up to your personal choice.*

if you dont have a store you can [deploy a new contract](https://www.mintbase.xyz/launchpad/contracts/0) on our launchpad

---

## Pre-Setup
If you would like the minter to use your own NFT contract you can easily deploy one through the mintbase market UI, additionally if you want to open up minting to be available for any person you will need to connect it to a proxy contract

### Deploying a Near Contract on Mintbase:
1. Login on Mintbase and access [Contracts Page](https://www.mintbase.xyz/launchpad/contracts/0)
2. Click on New Contract
3. Choose Store Name (this will be the contract address to add on your minsta instance, this need to be added on the `process.env.NEXT_PUBLIC_NFT_CONTRACT_ADDRESS` environment variable) and Store Symbol
4. Proceed to transaction.
5. Succeeded
6. Go to Contract Settings

<hr class="subsection" />

### Add Proxy Minter Contract
1. Under Contract Settings go to Minters
2. add `0.drop.proxy.mintbase.near` (this is the contract address that need to be added on `process.env.NEXT_PUBLIC_PROXY_MINTER_CONTRACT_ADDRESS`), and click Add Minters.
3. Proceed to transaction.
4. Succeeded

<hr class="subsection" />

### Step 1: Get the wallet connection

This method will get the wallet instance used to send the mint transaction. To learn more about this, you can check our guide at [Wallet Connection Guide](https://docs.mintbase.xyz/dev/getting-started/add-wallet-connection-to-your-react-app).

```typescript
 const getWallet = async () => {
    try {
      return await selector.wallet();
    } catch (error) {
      console.error("Failed to retrieve the wallet:", error);
      throw new Error("Failed to retrieve the wallet");
    }
  };
  ```

<hr class="subsection" />

### Step 2: Use the onSubmit method 

Get all the form data and use the onSubmit method to handle the minting process

```typescript
const onSubmit = async (data: SubmitData) => {
    const wallet = await getWallet();

    const reference = await uploadReference({
      title: typeof data?.title === "string" ? data.title : "",
      media: data?.media as unknown as File,
    });

    const file = uploadFile(data?.media as unknown as File);

    await handleMint(
      reference.id,
      file,
      activeAccountId as string,
      wallet,
      reference.media_url as string,
      data.title
    );
  };
  ```

<hr class="subsection" />

### Step 3: Upload the NFT reference

The nft reference represents the offchain data which permanently stored on IPFS on Arweave in this case you can use [@mintbase-js/data](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/data) to easily upload it to arweave.

In this not only are we uploading an offchain JSON object which contains the media as well as the title but also uploading a separate media file to be included onchain.

[Learn more about how references work here](https://docs.mintbase.xyz/dev/getting-started/anatomy-of-a-non-fungible-token)

```typescript
const reference = await uploadReference({
    title: typeof data?.title === "string" ? data.title : "",
    media: data?.media as unknown as File,
  });

  const file = uploadFile(data?.media as unknown as File);
```

<hr class="subsection" />

### Step 4: Handling the mint

Here we start by configuring the callback which is the link and params to where the user will be redirected after minting after signing the mint transaction on the wallet.

In this case a number of params are included to be able to show a better success page.

The argument for calling the contracts "mint" function is then built. This transaction will be sent to the proxy contract which then calls the nft contracts nft_batch_mint method

  ```typescript
   async function handleMint(
    reference: string,
    media: Promise<ArweaveResponse>,
    activeAccountId: string,
    wallet: Wallet,
    mediaUrl: string,
    nftTitle: string
  ) {
    const callbackArgs = {
      contractAddress: MintbaseWalletSetup.contractAddress.toString(),
      amount: 1,
      ref: `${reference}`,
      mediaUrl: mediaUrl,
      title: nftTitle,
    };

    if (reference) {
      await wallet.signAndSendTransaction({
        signerId: activeAccountId,
        receiverId: proxyAddress,
        callbackUrl: cbUrl(reference, callbackArgs),
        actions: [
          {
            type: "FunctionCall",
            params: {
              methodName: "mint",
              args: {
                metadata: JSON.stringify({
                  reference,
                  media: (await media).id,
                }),
                nft_contract_id: MintbaseWalletSetup.contractAddress,
              },
              gas: "200000000000000",
              deposit: "10000000000000000000000",
            },
          },
        ],
      });
    }
  }

  return { form, onSubmit, preview, setPreview };
};

```

This sums up the blockchain portion of the code

<hr class="subsection" />

### Setup
In the `minter/src/config/setup.ts` file, we define several key configurations for interacting with the Mintbase platform. This setup is crucial for ensuring that our application communicates correctly with Mintbase smart contracts.

---

## ENV Variables

- `proxyAddress`: This is the address of the proxy contract on Mintbase. It is either taken from the environment variable `NEXT_PUBLIC_PROXY_CONTRACT_ADDRESS` or defaults to `"0.minsta.proxy.mintbase.testnet"` if the environment variable is not set.

- `contractAddress`: The address of the minting contract. Similar to `proxyAddress`, it is sourced from `NEXT_PUBLIC_MINT_CONTRACT_ADDRESS` or defaults to `"test122212.mintspace2.testnet"`.

- `network`: Indicates the blockchain network we are interacting with. It defaults to `"testnet"` if `NEXT_PUBLIC_NETWORK` is not specified in the environment.

- `callbackUrl`: A URL used for callbacks, constructed dynamically based on the `network` variable. If we are on the testnet, it uses the testnet URL; otherwise, it defaults to the mainnet URL.

To customize these configurations for different environments, you can set the following environment variables in your `.env` file:

`NOTE: the env variables need to have the NEXT_PUBLIC_ on the variable name due to be available for the browser to process`

- `NEXT_PUBLIC_PROXY_CONTRACT_ADDRESS`: Your proxy contract address on Mintbase.
- `NEXT_PUBLIC_MINT_CONTRACT_ADDRESS`: Your mint contract address on Mintbase.
- `NEXT_PUBLIC_NETWORK`: The network you want to interact with (`"testnet"` or `"mainnet"`).

after that you can run

```bash
pnpm install
pnpm dev
```

---

## Extending

This project is setup using Next.js + @mintbase/js
You can use this project as a reference to build your own, and use or remove any library you think it would suit your needs.

:::info Get in touch
You can get in touch with the mintbase team using the following channels:

- Support: [Join the Telegram](https://tg.me/mintdev)
- Twitter: [@mintbase](https://twitter.com/mintbase)
:::
'''
'''--- docs/3.tutorials/welcome.md ---
---
id: welcome
title: Examples & Tutorials
sidebar_label: Home
hide_table_of_contents: true
---

import {FeatureList, Column, Feature} from "@site/src/components/featurelist"

Explore our collection of Examples and Tutorials

<FeatureList>
  <Column title="Popular Examples">
    <Feature url="/tutorials/examples/guest-book" title="Guest Book" subtitle="Create a simple guest book" image="guest-book.png" />
    <Feature url="/tutorials/examples/donation" title="Donation" subtitle="Receive and send tokens" image="donation.png" />
    <Feature url="/tutorials/examples/xcc" title="Basic Cross-Contract Call" subtitle="Learn how to call other contracts" image="cross-call.png" />
    <Feature url="/tutorials/examples/coin-flip" title="Coin Flip Game" subtitle="Learn to create basic random numbers" image="random.png" />
    <Feature url="/tutorials/examples/factory" title="Factory Contract" subtitle="Build a contract that deploys contracts" image="factory.png" />
    <Feature url="/tutorials/examples/update-contract-migrate-state" title="Update & Migrate" subtitle="Programmatically update contracts" image="update.png" />
    <Feature url="/tutorials/examples/frontend-multiple-contracts" title="Multi-Contract Frontend" subtitle="Interact with multiple contracts" image="multiple.png" />

  </Column>
  <Column title="Popular Tutorials">
    <Feature url="/tutorials/near-components/interaction" title="Components & Contracts" subtitle="Use a contract from your component" image="bos-contract.png" />
    <Feature url="/tutorials/near-components/lido" title="ETH Component" subtitle="Build an Ethereum Component" image="bos-lido.png" />
    <Feature url="/tutorials/nfts/minting-nfts" title="NFT Mint" subtitle="Mint an NFT without using code" image="frontend-bos.png" />
    <Feature url="/tutorials/near-components/indexer-tutorials/nft-indexer" title="Events (NEAR Lake)"
             subtitle="Use our Data Lake to listen for events" image="monitor.png" />
  </Column>
  <Column title="From Zero to Hero">
    <Feature url="/tutorials/nfts/js/introduction" title="Master NFTs on NEAR (JS)" subtitle="Learn everything about NFT in JS" image="nft-marketplace-js.png" />
    <Feature url="/tutorials/nfts/introduction" title="Master NFTs on NEAR (RS)" subtitle="Learn everything about NFT in Rust" image="nft-marketplace-rs.png" />
    <Feature url="/tutorials/fts/introduction" title="Fungible Tokens 101"
             subtitle="Learn everything about fungible tokens" image="ft.png" />
    <Feature url="/tutorials/crosswords/basics/overview" title="Crossword Game" 
             subtitle="Build a Crossword Game from zero" image="crossword.png" />
  </Column>
</FeatureList>

'''
'''--- docs/4.tools/cli-rs.md ---
---
id: near-cli-rs
title: NEAR CLI RS
---

# NEAR-CLI-RS

## Quick Start Guide

The `near-cli-rs` tool is a human-friendly companion that helps you interact with the [NEAR Protocol](https://near.org/) from the command line. This has a guided prompt interface to help you make your own commands built in Rust.

:::info note

This is a separate tool from [near-cli](https://docs.near.org/tools/near-cli), a CLI tool of similar functionality without the guided prompts.

:::

## Install

Download the pre-compiled version of `near-cli-rs` for your OS from [GitHub Releases Page](https://github.com/near/near-cli-rs/releases/) or install it with [Cargo](https://doc.rust-lang.org/cargo/) (Rust's package manager tool) with the following command:

```
$ cargo install near-cli-rs
```

## Getting Started

To utilize the commands that involve transactions, sending tokens, deploying contracts, etc., you'll have to store a full access key to a given account on your machine.

Run...

```
near
```

Using the arrow keys navigate to...

```
account  -Manage accounts
```

Navigate to...

```
import-account -Import existing account (a.k.a. "sign-in")
```

choose any of the preferred sign-in methods. For this example, we'll choose the...

```
using-web-wallet -Import existing account using NEAR Wallet (a.k.a. "sign in")
### Account
- Gives you information on a specified account, near balance, storage, list of access keys, etc.
```

For this tutorial select `testnet`

```
What is the name of the network?
mainnet
>testnet
shardnet
```

You'll get redirected to `wallet.testnet.near.org`. Once there, grant authorization. Then in your terminal, you'll be asked to enter your account ID. Give it the name of the account you just authorized access to and a full access key.

If you're on Mac you'll have the option to use the [Mac Keychain](https://support.apple.com/guide/keychain-access/what-is-keychain-access-kyca1083/mac) option.

Either storage option is fine. Using the legacy storage option will save a file in your root directory in a hidden folder called `./near-credentials`. This storage option is compatable with the `near-cli` tool (a cli tool without the guided prompts but similar functionality).

**Good Job!**
Now you can use `near-cli-rs` to it's full capacity.

---

## Usage

To use the `near-cli-rs` simply run the following in your terminal.

```bash
$ near
```

You should then see the following. Use the arrow keys and hit `enter` or simply type out one of the available options to select an option

![](/docs/assets/near-cli-rs.png)

### Accounts

This option will allow you to manage, control, and retrieve information on your accounts.

| Option                 | Description                                |
| ---------------------- | ------------------------------------------ |
| `view-account-summary` | View properties for an account             |
| `import-account`       | Import existing account (a.k.a. "sign in") |
| `create-account`       | Create a new account                       |
| `delete-account`       | Delete an Account                          |
| `list-keys`            | View a list of keys for an account         |
| `add-key`              | Add an access key to an account            |
| `delete-key`           | Delete an access key from an account       |

### Tokens

This will allow you to manage your token assets such as NEAR, FTs and NFTs

| Option              | Description                                                           |
| ------------------- | --------------------------------------------------------------------- |
| `send-near`         | Transfers NEAR to a specified recipient in units of NEAR or yoctoNEAR |
| `send-ft`           | Transfer Fungible Tokens to a specified user                          |
| `send-nft`          | Transfers NFTs between accounts                                       |
| `view-near-balance` | View the balance of NEAR tokens                                       |
| `view-ft-balance`   | View the balance of Fungible Tokens                                   |
| `view-nft-assets`   | View the balance of NFT Tokens                                        |

### Contract

This option allows you to manage and interact with your smart contracts

| Option          | Description             |
| --------------- | ----------------------- |
| `call-function` | Execute Function        |
| `deploy`        | Add a new contract code |
| `download-wasm` | Download Wasm           |

### Transaction

Operate Transactions

| Option                 | Description                 |
| ---------------------- | --------------------------- |
| `view-status`          | View a transaction status   |
| `construct-tansaction` | Construct a new transaction |

### Config

Manage the connection parameters inside the `config.toml` file for `near-cli-rs`

This will allow you to change or modify the network connections for your CLI.

| Option              | Description                        |
| ------------------- | ---------------------------------- |
| `show-connections`  | Show a list of network connections |
| `add-connection`    | Add a network connection           |
| `delete-connection` | Delete a network Connection        |

---

'''
'''--- docs/4.tools/cli.md ---
---
id: near-cli
title: NEAR CLI
---

The NEAR [Command Line Interface](https://github.com/near/near-cli) (CLI) is a tool that enables to interact with the NEAR network directly from the shell. Among other things, the NEAR CLI enables you to:

- Login with a NEAR account
- Deploy a contract
- Interact and query information from a deployed contract

:::tip
Under the hood, NEAR CLI utilizes the [`NEAR JavaScript API`](https://github.com/near/near-api-js)
:::
---

:::info

The NEAR CLI also comes with an implementation in Rust called [`near-cli-rs`](https://github.com/near/near-cli-rs).
If you want to use `near-cli` while you have `near-cli-rs` installed, prefix the following commands with `npx`.
:::

## Overview

_Click on a command for more information and examples._

| Command                                         | Description                                                                               |
|-------------------------------------------------|-------------------------------------------------------------------------------------------|
| **ACCESS KEYS**                                 |                                                                                           |
| [`near add-credentials`](#near-add-credentials) | Stores credentials for an account locally                                                 |
| [`near add-key`](#near-add-key)                 | adds a new access key to an account                                                       |
| [`near delete-key`](#near-delete-key)           | deletes an access key from an account                                                     |
| [`near generate-key`](#near-generate-key)       | generates a key pair and **optionally** stores it locally as credentials for an accountId |
| [`near list-keys`](#near-keys)                  | displays all access keys and their details for a given account                            |
| [`near login`](#near-login)                     | stores a full access key locally using [NEAR Wallet](https://wallet.testnet.near.org/)    |
| **ACCOUNTS**                                    |                                                                                           |
| [`near create-account`](#near-create-account)   | creates a new account, either using a faucet to fund it, or an account saved locally      |
| [`near delete-account`](#near-delete)           | deletes an account and transfers remaining balance to a beneficiary account               |
| [`near list-keys`](#near-keys)                  | displays all access keys for a given account                                              |
| [`near send-near`](#near-send)                  | sends tokens from one account to another                                                  |
| [`near state`](#near-state)                     | shows general details of an account                                                       |
| **CONTRACTS**                                   |                                                                                           |
| [`near call`](#near-call)                       | makes a contract call which can invoke `change` _or_ `view` methods                       |
| [`near deploy`](#near-deploy)                   | deploys a smart contract to the NEAR blockchain                                           |
| [`near storage`](#near-storage)                 | Shows the storage state of a given contract, i.e. the data stored in a contract           |
| [`near view`](#near-view)                       | makes a contract call which can **only** invoke a `view` method                           |
| **TRANSACTIONS**                                |                                                                                           |
| [`near tx-status`](#near-tx-status)             | queries a transaction's status by `txHash`                                                |

---

## Setup

### Installation

> Make sure you have a current version of `npm` and `NodeJS` installed.

#### Mac and Linux

1. Install `npm` and `node` using a package manager like `nvm` as sometimes there are issues using Ledger due to how OS X handles node packages related to USB devices. [[click here]](https://nodejs.org/en/download/package-manager/)
2. Ensure you have installed Node version 12 or above.
3. Install `near-cli` globally by running:

```bash
npm install -g near-cli
```

For example, on Ubuntu 20.04 `near-cli` can be installed by running:
```bash
# Install nvm (https://github.com/nvm-sh/nvm?tab=readme-ov-file#installing-and-updating)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
source ~/.bashrc

# Install node
nvm install node

# Install near-cli
npm install -g near-cli

# near-cli works!
near --help
```

#### Windows

> For Windows users, we recommend using Windows Subsystem for Linux (`WSL`).

1. Install `WSL` [[click here]](https://docs.microsoft.com/en-us/windows/wsl/install-manual#downloading-distros)
2. Install `npm` [[click here]](https://www.npmjs.com/get-npm)
3. Install ` Node.js` [ [ click here ]](https://nodejs.org/en/download/package-manager/)
4. Change `npm` default directory [ [ click here ] ](https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally#manually-change-npms-default-directory)
    - This is to avoid any permission issues with `WSL`
5. Open `WSL` and install `near-cli` globally by running:

```bash
npm install -g near-cli
```

---

### Network selection

> The default network for `near-cli` is `testnet`.

- You can change the network by prepending an environment variable to your command.

```bash
NEAR_NETWORK=testnet near send ...
```

- Alternatively, you can set up a global environment variable by running:

```bash
export NEAR_NETWORK=mainnet
```

- All commands that interact with the network also allow to pass the `--networkId` option.

```bash
near send-near ... --networkId mainnet
```

---

### Custom RPC server selection
You can set custom RPC server URL by setting these env variables:

```bash
NEAR_MAINNET_RPC
NEAR_TESTNET_RPC
```

Clear them in case you want to get back to the default RPC server.

Example:

```bash
export NEAR_TESTNET_RPC=<put_your_rpc_server_url_here>
```
---

## Access Keys

All keys are stored locally at the root of your `HOME` directory:
  -   `~/.near-credentials` _(MAC / Linux)_
  -   `C:\Users\YOUR_ACCOUNT\.near-credentials` _(Windows)_

Inside `.near-credentials`, access keys are organized in network subdirectories: `testnet`, and `mainnet`.

These network subdirectories contain `.JSON` objects with an:
  -   `account_id`
  -   `private_key`
  -   `public_key`

### `near add-credentials <accountId>`
> Stores credentials (full-access-key) locally for an already existing account.

-   arguments: `accountId`
-   options: `--seedPhrase` or `--secretKey`

**Examples:**

```bash
near add-credentials example-acct.testnet --seedPhrase "antique attitude say evolve ring arrive hollow auto wide bronze usual unfold"
```

---

### `near add-key`

> Adds either a **full access** or **function access** key to a given account.

> Optionally allows to sign with a Ledger: `--signWithLedger` `--ledgerPath`

**Note:** You will use an _existing_ full access key for the account you would like to add a _new_ key to. ([`near login`](http://docs.near.org/docs/tools/near-cli#near-login))

#### 1) add a `full access` key

- arguments: `accountId` `publicKey`

**Example:**

```bash
near add-key example-acct.testnet Cxg2wgFYrdLTEkMu6j5D6aEZqTb3kXbmJygS48ZKbo1S
```

<details>
<summary><strong>Example Response</strong></summary>
<p>

```
    Adding full access key = Cxg2wgFYrdLTEkMu6j5D6aEZqTb3kXbmJygS48ZKbo1S to example-acct.testnet.
    Transaction Id EwU1ooEvkR42HvGoJHu5ou3xLYT3JcgQwFV3fAwevGJg
    To see the transaction in the transaction explorer, please open this url in your browser
    https://testnet.nearblocks.io/txns/EwU1ooEvkR42HvGoJHu5ou3xLYT3JcgQwFV3fAwevGJg
```

</p>
</details>

#### 2) add a `function call` key

-   arguments: `accountId` `publicKey` `--contract-id`
-   options: `--method-names` `--allowance`

> `accountId` is the account you are adding the key to
>
> `--contract-id` is the contract you are allowing methods to be called on
>
> `--method-names` are optional and if omitted, all methods of the `--contract-id` can be called.
>
> `--allowance` is the amount of ‚ìÉ the key is allowed to spend on gas fees _only_ (default: 0).

**Note:** Each transaction made with this key will have gas fees deducted from the initial allowance and once it runs out a new key must be issued.

**Example:**

```bash
near add-key example-acct.testnet GkMNfc92fwM1AmwH1MTjF4b7UZuceamsq96XPkHsQ9vi --contract-id example-contract.testnet --method-names example_method --allowance 30000000000
```

<details>
<summary><strong>Example Response</strong></summary>
<p>

```
    Adding function call access key = GkMNfc92fwM1AmwH1MTjF4b7UZuceamsq96XPkHsQ9vi to example-acct.testnet.
    Transaction Id H2BQL9fXVmdTbwkXcMFfZ7qhZqC8fFhsA8KDHFdT9q2r
    To see the transaction in the transaction explorer, please open this url in your browser
    https://testnet.nearblocks.io/txns/H2BQL9fXVmdTbwkXcMFfZ7qhZqC8fFhsA8KDHFdT9q2r
```

</p>
</details>

---

### `near delete-key`

> Deletes an existing key for a given account.
> Optionally allows to sign with a Ledger: `--signWithLedger` `--ledgerPath`

-   arguments: `accountId` `publicKey`
-   options: `--networkId`, `force`

**Note:** You will need separate full access key for the account you would like to delete a key from. ([`near login`](http://docs.near.org/docs/tools/near-cli#near-login))

**Example:**

```bash
near delete-key example-acct.testnet Cxg2wgFYrdLTEkMu6j5D6aEZqTb3kXbmJygS48ZKbo1S
```

<details>
<summary><strong>Example Response</strong></summary>
<p>

```
    Transaction Id 4PwW7vjzTCno7W433nu4ieA6FvsAjp7zNFwicNLKjQFT
    To see the transaction in the transaction explorer, please open this url in your browser
    https://testnet.nearblocks.io/txns/4PwW7vjzTCno7W433nu4ieA6FvsAjp7zNFwicNLKjQFT
```

</p>
</details>

---
### `near generate-key`

> Displays a key-pair and seed-phrase and optionally stores it locally in `.near-credentials`.

-   arguments: `accountId` or `none`
-   options: `--fromSeedPhrase`, `--saveImplicit`, `--queryLedgerPK`

**Note:** There are several ways to use `generate-key` that return very different results. Please reference the examples below for further details.

---

#### 1a) `near generate-key`

> Creates and displays a key pair

```bash
near generate-key
```

<details>
<summary><strong>Example Response</strong></summary>
<p>

```bash
Seed phrase: antique attitude say evolve ring arrive hollow auto wide bronze usual unfold
Key pair: {"publicKey":"ed25519:BW5Q957u1rTATGpanKUktjVmixEmT56Df4Dt9hoGWEXz","secretKey":"ed25519:5StmPDg9xVNzpyudwxT8Y72iyRq7Fa86hcpsRk6Cq5eWGWqwsPbPT9woXbJs9Qe69crZJHh4DMkrGEPGDDfmXmy2"}
Implicit account: 9c07afc7673ea0f9a20c8a279e8bbe1dd1e283254263bb3b07403e4b6fd7a411
```

</p>
</details>

---

#### 1b) `near generate-key --saveImplicit`

> Creates and displays a key pair, saving it locally in `.near-credentials` as an implicit account.

```bash
near generate-key --saveImplicit
```

<details>
<summary><strong>Example Response</strong></summary>
<p>

```bash
Seed phrase: antique attitude say evolve ring arrive hollow auto wide bronze usual unfold
Key pair: {"publicKey":"ed25519:BW5Q957u1rTATGpanKUktjVmixEmT56Df4Dt9hoGWEXz","secretKey":"ed25519:5StmPDg9xVNzpyudwxT8Y72iyRq7Fa86hcpsRk6Cq5eWGWqwsPbPT9woXbJs9Qe69crZJHh4DMkrGEPGDDfmXmy2"}
Implicit account: 9c07afc7673ea0f9a20c8a279e8bbe1dd1e283254263bb3b07403e4b6fd7a411

Storing credentials for account: 9d6e4506ac06ab66a25f6720e400ae26bad40ecbe07d49935e83c7bdba5034fa (network: testnet)
Saving key to '~/.near-credentials/testnet/9d6e4506ac06ab66a25f6720e400ae26bad40ecbe07d49935e83c7bdba5034fa.json'
```

</p>
</details>

---

#### 2) `near generate-key accountId`

> Creates a key pair locally in `.near-credentials` with an `accountId` that you specify.

**Note:** This does NOT create an account with this name.

```bash
near generate-key example.testnet
```

<details>
<summary><strong>Example Response</strong></summary>
<p>

```bash
Seed phrase: antique attitude say evolve ring arrive hollow auto wide bronze usual unfold
Key pair: {"publicKey":"ed25519:BW5Q957u1rTATGpanKUktjVmixEmT56Df4Dt9hoGWEXz","secretKey":"ed25519:5StmPDg9xVNzpyudwxT8Y72iyRq7Fa86hcpsRk6Cq5eWGWqwsPbPT9woXbJs9Qe69crZJHh4DMkrGEPGDDfmXmy2"}
Implicit account: 9c07afc7673ea0f9a20c8a279e8bbe1dd1e283254263bb3b07403e4b6fd7a411

Storing credentials for account: example.testnet (network: testnet)
Saving key to '~/.near-credentials/testnet/example.testnet.json'
```

</p>
</details>

---

#### 3a) `near generate-key --fromSeedPhrase="your seed phrase"`

> Uses a seed phrase to display a public key and [implicit account](../1.concepts/protocol/account-id.md#implicit-accounts-implicit-accounts)

```bash
near generate-key --seedPhrase="antique attitude say evolve ring arrive hollow auto wide bronze usual unfold"
```

<details>
<summary><strong>Example Response</strong></summary>

```
Seed phrase: antique attitude say evolve ring arrive hollow auto wide bronze usual unfold
Key pair: {"publicKey":"ed25519:BW5Q957u1rTATGpanKUktjVmixEmT56Df4Dt9hoGWEXz","secretKey":"ed25519:5StmPDg9xVNzpyudwxT8Y72iyRq7Fa86hcpsRk6Cq5eWGWqwsPbPT9woXbJs9Qe69crZJHh4DMkrGEPGDDfmXmy2"}
Implicit account: 9c07afc7673ea0f9a20c8a279e8bbe1dd1e283254263bb3b07403e4b6fd7a411
```

</details>

---

#### 3b) `near generate-key accountId --seedPhrase="your seed phrase"`

Will store the key pair corresponding to the seedPhrase in `.near-credentials` with an `accountId` that you specify.

<details>
<summary><strong>Example Response</strong></summary>
<p>

```
Seed phrase: antique attitude say evolve ring arrive hollow auto wide bronze usual unfold
Key pair: {"publicKey":"ed25519:BW5Q957u1rTATGpanKUktjVmixEmT56Df4Dt9hoGWEXz","secretKey":"ed25519:5StmPDg9xVNzpyudwxT8Y72iyRq7Fa86hcpsRk6Cq5eWGWqwsPbPT9woXbJs9Qe69crZJHh4DMkrGEPGDDfmXmy2"}
Implicit account: 9c07afc7673ea0f9a20c8a279e8bbe1dd1e283254263bb3b07403e4b6fd7a411
```

</p>
</details>

---

#### 4a) `near generate-key --queryLedgerPK`

> Uses a connected Ledger device to display a public key and [implicit account](http://docs.near.org/integrations/implicit-accounts) using the default HD path (`"44'/397'/0'/0'/1'"`)

```bash
near generate-key --queryLedgerPK
```

You should then see the following prompt to confirm this request on your Ledger device:

```
  Make sure to connect your Ledger and open NEAR app
  Getting Public Key from Ledger...
```

After confirming the request on your Ledger device, a public key and implicit accountId will be displayed.

<details>
<summary><strong>Example Response</strong></summary>
<p>

```bash
Using public key: ed25519:B22RP10g695wyeRvKIWv61NjmQZEkWTMzAYgdfx6oSeB2
Implicit account: 42c320xc20739fd9a6bqf2f89z61rd14efe5d3de234199bc771235a4bb8b0e1
```

</p>
</details>

---

#### 3b) `near generate-key --queryLedgerPK --ledgerPath="HD path you specify"`

> Uses a connected Ledger device to display a public key and [implicit account](http://docs.near.org/integrations/implicit-accounts) using a custom HD path.

```bash
near generate-key --queryLedgerPK --ledgerPath="44'/397'/0'/0'/2'"
```

You should then see the following prompt to confirm this request on your Ledger device:

```
    Make sure to connect your Ledger and open NEAR app
    Waiting for confirmation on Ledger...
```

After confirming the request on your Ledger device, a public key and implicit accountId will be displayed.

<details>
<summary><strong>Example Response</strong></summary>
<p>

```bash
Using public key: ed25519:B22RP10g695wye3dfa32rDjmQZEkWTMzAYgCX6oSeB2
Implicit account: 42c320xc20739ASD9a6bqf2Dsaf289z61rd14efe5d3de23213789009afDsd5bb8b0e1
```

</p>
</details>

---

### `near list-keys`

> Displays all access keys for a given account.

-   arguments: `accountId`

**Example:**

```bash
near list-keys client.chainlink.testnet
```

<details>
<summary> <strong>Example Response</strong> </summary>
<p>

```
Keys for account client.chainlink.testnet
[
  {
    public_key: 'ed25519:4wrVrZbHrurMYgkcyusfvSJGLburmaw7m3gmCApxgvY4',
    access_key: { nonce: 97, permission: 'FullAccess' }
  },
  {
    public_key: 'ed25519:H9k5eiU4xXS3M4z8HzKJSLaZdqGdGwBG49o7orNC4eZW',
    access_key: {
      nonce: 88,
      permission: {
        FunctionCall: {
          allowance: '18483247987345065500000000',
          receiver_id: 'client.chainlink.testnet',
          method_names: [ 'get_token_price', [length]: 1 ]
        }
      }
    }
  },
  [length]: 2
]
```

</p>
</details>

---

### `near login`

> locally stores a full access key of an account you created with [MyNEARWallet](https://testnet.mynearwallet.com/).

-   arguments: `none`
-   options: `--networkId`

**Example:**

```bash
near login
```

**Custom wallet url:**

The default wallet URL is `https://testnet.mynearwallet.com/`. However, if you want to change to a different wallet URL, you can set the environmental variable `NEAR_MAINNET_WALLET` or `NEAR_TESTNET_WALLET`.

```bash
export NEAR_TESTNET_WALLET=https://wallet.testnet.near.org/
near login
```

---

## Accounts

### `near create-account`

> Creates an account using an existing account or a faucet service to pay for the account's creation and initial balance.

-   arguments: `accountId`
-   options: `--initialBalance`, `--useFaucet`, `--useAccount`, `--seedPhrase`, `--publicKey`, `--signWithLedger`, `--ledgerPath`, `--useLedgerPK`, `--PkLedgerPath`

**Examples:**:

```bash
# Creating account using `example-acct.testnet` to fund it
near create-account new-acc.testnet --useAccount example-acct.testnet
```

```bash
# Creating account using the faucet to fund it
near create-account new-acc.testnet --useFaucet
```

```bash
# Creating a pre-funded account that can be controlled by the Ledger's public key
near create-account new-acc.testnet --useFaucet --useLedgerPK 
```

```bash
# Creating an account using a Ledger account
near create-account new-acc.testnet --useAccount ledger-acct.testnet --signWithLedger
```

**Subaccount example:**

```bash
# Using an account to create a sub-account
near create-account sub-acct.example-acct.testnet --useAccount example-acct.testnet
```

```bash
# Creating a sub-account using the Ledger that can also be controlled by the ledger
near create-account sub.acc.testnet --useAccount sub.acc.testnet --signWithLedger --useLedgerPK
```

**Example using `--initialBalance`:**

```bash
near create-account sub-acct2.example-acct.testnet --useAccount example-acct.testnet --initialBalance 10
```

<details>
<summary><strong>Example Response</strong></summary>
<p>

```
    Saving key to '/HOME_DIR/.near-credentials/default/sub-acct2.example-acct.testnet.json'
    Account sub-acct2.example-acct.testnet for network "default" was created.
```

</p>
</details>

---

### `near delete-account`

> Deletes an account and transfers remaining balance to a beneficiary account.

-   arguments: `accountId` `beneficiaryId`
-   options: `force`, `--signWithLedger`, `--ledgerPath`

**Example:**

```bash
near delete-account sub-acct2.example-acct.testnet example-acct.testnet
```

<details>
<summary><strong>Example Response</strong></summary>
<p>

```
    Deleting account. Account id: sub-acct2.example-acct.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, beneficiary: example-acct.testnet
    Transaction Id 4x8xohER1E3yxeYdXPfG8GvXin1ShiaroqE5GdCd5YxX
    To see the transaction in the transaction explorer, please open this url in your browser
    https://testnet.nearblocks.io/txns/4x8xohER1E3yxeYdXPfG8GvXin1ShiaroqE5GdCd5YxX
    Account sub-acct2.example-acct.testnet for network "default" was deleted.
```

</p>
</details>

---

### `near send-near`

> Sends NEAR tokens (‚ìÉ) from one account to another.

- arguments: `senderId` `receiverId` `amount`
- options: `--signWithLedger`, `--ledgerPath`

**Note:** You will need a full access key for the sending account. ([`near login`](http://docs.near.org/docs/tools/near-cli#near-login))

**Example:**

```bash
near send-near sender.testnet receiver.testnet 10
```

<details>
<summary><strong>Example Response</strong></summary>
<p>

```
    Sending 10 NEAR to receiver.testnet from sender.testnet
    Transaction Id BYTr6WNyaEy2ykAiQB9P5VvTyrJcFk6Yw95HPhXC6KfN
    To see the transaction in the transaction explorer, please open this url in your browser
    https://testnet.nearblocks.io/txns/BYTr6WNyaEy2ykAiQB9P5VvTyrJcFk6Yw95HPhXC6KfN
```

</p>
</details>

---

### `near state`

> Shows details of an account's state.

-   arguments: `accountId`

**Example:**

```bash
near state example.testnet
```

<details>
<summary><strong>Example Response</strong></summary>
<p>

```json
{
    "amount": "99999999303364037168535000",
    "locked": "0",
    "code_hash": "G1PCjeQbvbUsJ8piXNb7Yg6dn3mfivDQN7QkvsVuMt4e",
    "storage_usage": 53528,
    "storage_paid_at": 0,
    "block_height": 21577354,
    "block_hash": "AWu1mrT3eMJLjqyhNHvMKrrbahN6DqcNxXanB5UH1RjB",
    "formattedAmount": "99.999999303364037168535"
}
```

</p>
</details>

---

## Contracts

### `near call`

> makes a contract call which can modify _or_ view state.

**Note:** Contract calls require a transaction fee (gas) so you will need an access key for the `--accountId` that will be charged. ([`near login`](http://docs.near.org/docs/tools/near-cli#near-login))

-   arguments: `contractName` `method_name` `{ args }` `--accountId`
-   options: `--gas` `--deposit` `--signWithLedger` `--ledgerPath`

**Example:**

```bash
near call guest-book.testnet addMessage '{"text": "Aloha"}' --account-id example-acct.testnet
```

<details>
<summary><strong>Example Response</strong></summary>
<p>

```bash
    Scheduling a call: guest-book.testnet.addMessage({"text": "Aloha"})
    Transaction Id FY8hBam2iyQfdHkdR1dp6w5XEPJzJSosX1wUeVPyUvVK
    To see the transaction in the transaction explorer, please open this url in your browser
    https://testnet.nearblocks.io/txns/FY8hBam2iyQfdHkdR1dp6w5XEPJzJSosX1wUeVPyUvVK
    ''
```

</p>
</details>

---

### `near deploy`

> Deploys a smart contract to a given accountId.

-   arguments: `accountId` `.wasmFile`
-   options: `initFunction` `initArgs` `initGas` `initDeposit`

**Note:** You will need a full access key for the account you are deploying the contract to. ([`near login`](http://docs.near.org/docs/tools/near-cli#near-login))

**Example:**

```bash
near deploy example-contract.testnet out/example.wasm
```

**Initialize Example:**

```bash
near deploy example-contract.testnet out/example.wasm --initFunction new --initArgs '{"owner_id": "example-contract.testnet", "total_supply": "10000000"}'
```

<details>
<summary><strong>Example Response</strong></summary>
<p>

```
    Starting deployment. Account id: example-contract.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, file: main.wasm
    Transaction Id G8GhhPuujMHTRnwursPXE1Lv5iUZ8WUecwiST1PcKWMt
    To see the transaction in the transaction explorer, please open this url in your browser
    https://testnet.nearblocks.io/txns/G8GhhPuujMHTRnwursPXE1Lv5iUZ8WUecwiST1PcKWMt
    Done deploying to example-contract.testnet
```

</p>
</details>

---

### `near storage`

> Shows the storage state of a given contract, i.e. the data stored in a contract.

- arguments: `contractName`
- options: `--finality`, `--utf8`, `--blockId`, `--prefix`

**Example:**

```bash
near storage hello.near-examples.testnet --finality optimistic --utf8
```

<details>
<summary><strong>Example Response</strong></summary>

```bash
[ { key: 'STATE', value: '\x10\x00\x00\x00Passei por aqui!' } ]
```

</details>

---

### `near view`

> Makes a contract call which can **only** view state. _(Call is free of charge)_

-   arguments: `contractName` `method_name` `{ args }`
-   options: `default`

**Example:**

```bash
near view guest-book.testnet getMessages '{}'
```

<details>
<summary><strong>Example Response</strong></summary>
<p>

```bash
    View call: guest-book.testnet.getMessages({})
    [
      { premium: false, sender: 'waverlymaven.testnet', text: 'TGIF' },
      {
        premium: true,
        sender: 'waverlymaven.testnet',
        text: 'Hello from New York üåà'
      },
      { premium: false, sender: 'fhr.testnet', text: 'Hi' },
      { premium: true, sender: 'eugenethedream', text: 'test' },
      { premium: false, sender: 'dongri.testnet', text: 'test' },
      { premium: false, sender: 'dongri.testnet', text: 'hello' },
      { premium: true, sender: 'dongri.testnet', text: 'hey' },
      { premium: false, sender: 'hirokihori.testnet', text: 'hello' },
      { premium: true, sender: 'eugenethedream', text: 'hello' },
      { premium: false, sender: 'example-acct.testnet', text: 'Aloha' },
      [length]: 10
    ]
```

</p>
</details>

---

## Transactions

### `near tx-status`

> Queries transaction status by hash and accountId.

-   arguments: `txHash` `--accountId`
-   options: `default`

**Example:**

```bash
near tx-status FY8hBam2iyQfdHkdR1dp6w5XEPJzJSosX1wUeVPyUvVK --accountId guest-book.testnet
```

<details>
<summary><strong>Example Response</strong></summary>
<p>

```json
Transaction guest-book.testnet:FY8hBam2iyQfdHkdR1dp6w5XEPJzJSosX1wUeVPyUvVK
{
  status: { SuccessValue: '' },
  transaction: {
    signer_id: 'example-acct.testnet',
    public_key: 'ed25519:AXZZKnp6ZcWXyRNdy8FztYrniKf1qt6YZw6mCCReXrDB',
    nonce: 20,
    receiver_id: 'guest-book.testnet',
    actions: [
      {
        FunctionCall: {
          method_name: 'addMessage',
          args: 'eyJ0ZXh0IjoiQWxvaGEifQ==',
          gas: 300000000000000,
          deposit: '0'
        }
      },
      [length]: 1
    ],
    signature: 'ed25519:5S6nZXPU72nzgAsTQLmAFfdVSykdKHWhtPMb5U7duacfPdUjrj8ipJxuRiWkZ4yDodvDNt92wcHLJxGLsyNEsZNB',
    hash: 'FY8hBam2iyQfdHkdR1dp6w5XEPJzJSosX1wUeVPyUvVK'
  },
  transaction_outcome: {
    proof: [ [length]: 0 ],
    block_hash: '6nsjvzt6C52SSuJ8UvfaXTsdrUwcx8JtHfnUj8XjdKy1',
    id: 'FY8hBam2iyQfdHkdR1dp6w5XEPJzJSosX1wUeVPyUvVK',
    outcome: {
      logs: [ [length]: 0 ],
      receipt_ids: [ '7n6wjMgpoBTp22ScLHxeMLzcCvN8Vf5FUuC9PMmCX6yU', [length]: 1 ],
      gas_burnt: 2427979134284,
      tokens_burnt: '242797913428400000000',
      executor_id: 'example-acct.testnet',
      status: {
        SuccessReceiptId: '7n6wjMgpoBTp22ScLHxeMLzcCvN8Vf5FUuC9PMmCX6yU'
      }
    }
  },
  receipts_outcome: [
    {
      proof: [ [length]: 0 ],
      block_hash: 'At6QMrBuFQYgEPAh6fuRBmrTAe9hXTY1NzAB5VxTH1J2',
      id: '7n6wjMgpoBTp22ScLHxeMLzcCvN8Vf5FUuC9PMmCX6yU',
      outcome: {
        logs: [ [length]: 0 ],
        receipt_ids: [ 'FUttfoM2odAhKNQrJ8F4tiBpQJPYu66NzFbxRKii294e', [length]: 1 ],
        gas_burnt: 3559403233496,
        tokens_burnt: '355940323349600000000',
        executor_id: 'guest-book.testnet',
        status: { SuccessValue: '' }
      }
    },
    {
      proof: [ [length]: 0 ],
      block_hash: 'J7KjpMPzAqE7iX82FAQT3qERDs6UR1EAqBLPJXBzoLCk',
      id: 'FUttfoM2odAhKNQrJ8F4tiBpQJPYu66NzFbxRKii294e',
      outcome: {
        logs: [ [length]: 0 ],
        receipt_ids: [ [length]: 0 ],
        gas_burnt: 0,
        tokens_burnt: '0',
        executor_id: 'example-acct.testnet',
        status: { SuccessValue: '' }
      }
    },
    [length]: 2
  ]
}
```

</p>
</details>

---

## Global Options

| Option                      | Description                                                                                     |
|-----------------------------|-------------------------------------------------------------------------------------------------|
| `--help`                    | Show help  [boolean]                                                                            |
| `--version`                 | Show version number  [boolean]                                                                  |
| `-v, --verbose`             | Prints out verbose output  [boolean] [default: false]                                           |

'''
'''--- docs/4.tools/events.md ---
---
id: realtime
title: Real-time Events (WebSocket)
---

While developing a decentralized app you might want track specific events in real time. For example, you could want
to be informed each time a specific NFT marketplace makes a sell. For this to be possible you need:

1. A way for the contract to inform that an event took place.
2. A way to track such events in real time.

To tackle these challenges is that the [standard events format (NEP-297)](https://nomicon.io/Standards/EventsFormat) was created.
[NEP-297](https://nomicon.io/Standards/EventsFormat) defines a standard way for contracts to inform about an event. Since these
events are public, a service can then be built to track them in real time through the use of websocket.

---

## NEP-297 - Events
In NEAR, `Events` use the standard logs capability of contracts, since every log is forever stored in the blockchain. In this way,
Events are normal log entries that start with the `EVENT_JSON:` prefix, followed by a single valid JSON string. The JSON string
must codify an object with the following interface:

```ts
interface EventLogData {
    standard: string, // name of standard, e.g. nep171
    version: string, // e.g. 1.0.0
    event: string, // type of the event, e.g. nft_mint
    data?: unknown, // event data defined in the nep171
}
```

See the [NEP-297 page](https://nomicon.io/Standards/EventsFormat) for examples.

:::warning
There is a known limitation of 16kb strings when capturing logs
:::

---

## Listening to Events (Mainnet)

To listen to events in the `mainnet` simply connect to the secure websocket `wss://events.near.stream/ws`. There is no websocket **for `testnet`**.

As first message you will need to pass an object stating the type of events you want to filter for, and a limit if necessary. For example, here we filter for the `nft_mint` event in the `nft.nearapps.near` account.

```json
{
  secret: "ohyeahnftsss",
  filter: [{
    "account_id": "nft.nearapps.near",
    "status": "SUCCESS",
    "event": {
      "standard": "nep171",
      "event": "nft_mint",
    }
  }],
  fetch_past_events: 20,
}
```

:::caution
There is no websocket implemented for `testnet`, but you can run your own using this [modified indexer](https://github.com/evgenykuzyakov/indexer-tutorials/tree/master/example-indexer) to
populate a database with events, and then serve them using the [event-api project](https://github.com/evgenykuzyakov/event-api). 
:::

:::tip Reference implementation
If you need a reference implementation, [here is a project from Evgeny Kuzyakov](https://github.com/evgenykuzyakov/nft-mints)
that listens for **all** `nft_mint` and `nft_transfer` events in the NEAR network.
:::

---

'''
'''--- docs/4.tools/explorer.md ---
---
id: explorer
title: Explorer
sidebar_label: Explorers
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

An Explorer allows you to quickly obtain information from the blockchain through a friendly user interface.
These useful tools enable for example to:

1. Search for a transactions and its receipts.
2. Check all the interactions in a smart contract.
3. See the balance of an account.
4. View block creations in real time

---

## NEAR Explorer

Created by NEAR, the [Near Explorer](https://nearblocks.io) enables to check information for transactions and accounts through a user-friendly interface.

![NEAR Explorer](/docs/assets/explorers/near-explorer.png)
*Main page of [NEAR Explorer](https://nearblocks.io)*

<hr className="subsection"/>

## Stats Gallery
Created by the community, [Stats Gallery](https://stats.gallery) gamifies the experience of looking to an account, adding levels and badges based on the account's activity. One of its
best features is that it allows you to see the contract's methods.

![Stats Gallery](/docs/assets/explorers/stats-gallery.png)
*Account view in [Stats Gallery](https://stats.gallery)*

<hr className="subsection"/>

## NearBlocks

Created by the community, [NearBlocks](https://nearblocks.io/) enables to check accounts and transactions with an interface similar to etherscan.

![NearBlocks](/docs/assets/explorers/nearblocks.png)
*Main page of [NearBlocks](https://nearblocks.io/)*

<hr className="subsection"/>

## Nearscope

[Nearscope](https://nearscope.net/) provides a NEAR node validator and delegator explorer.

![Nearscope](/docs/assets/explorers/nearscope.png)
*Main page of [Nearscope](https://nearscope.net/)*

<hr className="subsection"/>

## DappLooker

[DappLooker](https://dapplooker.com/) lets you analyze and query NEAR blockchain data, build dashboards to visualize data and share with your community.

![DappLooker](/docs/assets/explorers/dapplooker.png)
*Main page of [DappLooker](https://dapplooker.com/)*

<hr className="subsection"/>

## Pikespeak

[Pikespeak](https://pikespeak.ai/) provides access to real-time and historical data on the NEAR Protocol.

'''
'''--- docs/4.tools/fastnear-api.md ---
---
id: fastnear-api
title: FastNEAR API
sidebar_label: FastNEAR API
---

A fast RPC for the NEAR blockchain, based on [Redis](https://redis.io/) and [LMDB](https://www.symas.com/lmdb).

## About FastNEAR

[Fast-Near](https://github.com/fastnear/fast-near) aims to provide the fastest RPC implementation for NEAR Protocol using high-performance storage backends:
 - in-memory storage in Redis.
 - SSD optimized storage using LMDB.

It is optimized for `view` call performance and ease of deploy and scaling. 

:::info Note about data sync
FastNear doesn't sync with the NEAR blockchain on its own. Data needs to be loaded either from [NEAR Lake](https://github.com/near/near-lake-indexer) or from [Near State Indexer](https://github.com/vgrichina/near-state-indexer).
:::

---

## FastNEAR API

The [FastNEAR API server](https://github.com/fastnear/fastnear-api-server-rs) provides a low-latency RPC API for wallets and explorers.

### Supported APIs

#### Public Key

- Public Key to Account ID mapping.
- Full Access Public Key to Account ID mapping.
- Any Public Key to Account ID mapping.

#### Account ID

- Account ID to delegated staking pools (validators).
- Account ID to fungible tokens (FT contracts).
- Account ID to non-fungible tokens (NFT contracts).

#### Token ID

- Token ID to top 100 accounts by balance (for FT contracts).

:::tip V1 API

[Click here](https://github.com/fastnear/fastnear-api-server-rs?tab=readme-ov-file#api-v1) to see the complete list of API endpoints and usage examples.

:::
'''
'''--- docs/4.tools/indexer4explorer.md ---
---
id: indexer-for-explorer
title: Indexer for Explorer (Deprecated)
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

While developing a decentralized app you might want to query usage information for a contract such as:

1. Which users have called a specific method in my contract?
2. How much money and gas did they deposit?
3. Which transactions failed?

In order to simplify asking these questions is that we developed the [NEAR Indexer for Explorer](https://github.com/near/near-indexer-for-explorer).

Both `testnet` and `mainnet` networks have active instances that fill the database with all the data from the network starting from the genesis as [Explorer](https://nearblocks.io/) requires.

:::info GitHub repo

NEAR Indexer for Explorer is an indexer built on top of [NEAR Indexer microframework](/concepts/advanced/near-indexer-framework). It watches the network and stores all the data from the blockchain in the PostgreSQL database.
You can find the source code on [this GitHub repository](https://github.com/near/near-indexer-for-explorer).

:::

---

## Example Queries

### Transactions Calling a Method
Query for all transactions that called `contribute` in the `v1.faucet.nonofficial.testnet` testnet account.

```sql
select r.predecessor_account_id, t.transaction_hash 
from receipts r, action_receipt_actions ara, transactions t
where r.receiver_account_id ='v1.faucet.nonofficial.testnet'
  and ara.receipt_id = r.receipt_id
  and ara.action_kind = 'FUNCTION_CALL'
  and ara.args @> '{"method_name": "contribute"}'
  and t.transaction_hash = r.originated_from_transaction_hash
```

<hr className="subsection" />

### Users, Status, and Attached Money
Query for all users that called `contribute` in `v1.faucet.nonofficial.testnet`, how much they attached to the call, and the transaction status.

```sql
select t.transaction_hash, eo.status, r.predecessor_account_id , ara.args -> 'deposit' as deposit
from receipts r, action_receipt_actions ara, transactions t, execution_outcomes eo
where r.receiver_account_id ='v1.faucet.nonofficial.testnet'
  and ara.receipt_id = r.receipt_id and ara.action_kind = 'FUNCTION_CALL'
  and ara.args @> '{"method_name": "contribute"}'
  and t.transaction_hash = r.originated_from_transaction_hash
  and r.receipt_id = eo.receipt_id
```

<hr className="subsection" />

### Sent Money
Query for all the transfers going out from `v1.faucet.nonofficial.testnet`.

```sql
select r.receiver_account_id, ara.args -> 'deposit' as deposit	
from receipts r, action_receipt_actions ara
where r.predecessor_account_id  ='v1.faucet.nonofficial.testnet'
  and ara.receipt_id = r.receipt_id and ara.action_kind = 'TRANSFER'
```

---

## NEAR Explorer sunsetting

Pagoda made a decision to sunset NEAR Explorer as a product. This means that `nearblocks.io` (and `explorer.testnet.near.org`) will become a landing page with a list of available alternatives, and the existing [nearblocks.io](https://nearblocks.io) will be hosted under a new domain name and will be transitioned to the community through DevHub. [Read more here](https://near.social/devgovgigs.near/widget/gigs-board.pages.Post?id=635).

### What exactly is being shut down?

You will lose access to databases with these URLs, or other Replicas you might have been given access to:
* `testnet.db.explorer.indexer.near.dev/testnet_explorer`
* `mainnet.db.explorer.indexer.near.dev/mainnet_explorer`

There is no plan to shut down any other data products, such as [NEAR Lake](https://docs.near.org/concepts/advanced/near-lake-framework) or [EnhancedAPI](https://www.pagoda.co/enhanced-api) at the moment.

### What is the timeline?

Postgres users will lose access to data on the 30th of November, Thursday (12:00 pm Pacific Time Zone). Please migrate to one of the options listed below instead.

### What does this mean for me?

If you are using the public Postgres Explorer Database, you will need to migrate to other solutions, depending on your use-case. You should start planning for it right now and reach out to [this Telegram group](https://nearbuilders.com/tg-data) to get help.

### What are the alternatives?

There are two major use-cases that you might be using Explorer DB for: analytics and real-time queries from web user interfaces.

#### Analytics Use-Case

This is if you use Explorer DB to build internal or external dashboards. Pagoda has been working with Google Web3 team to enable BigQuery public dataset that has a compatible schema with Explorer DB.

:::tip

Find more information about our [BigQuery solution here](../2.build/6.data-infrastructure/big-query.md).

:::

#### Web or API usage

This is if you make queries to Explorer DB in response to API requests that your users make on your application. There are various options that you can explore:
1. If you are working with token balances, including $NEAR, fungible or non-fungible tokens, consider using [Enhanced API](https://www.pagoda.co/enhanced-api) hosted by Pagoda, or run it yourself using https://github.com/near/near-enhanced-api-server and https://github.com/near/near-microindexers 
2. Use NEAR QueryAPI ‚Äì serverless indexers and GraphQL endpoints: https://near.org/s/p?a=nearpavel.near&b=97029570
3. Use NEAR Lake Indexer. Create an indexer using [Rust](https://github.com/near/near-lake-framework-rs), [JavaScript](https://github.com/near/near-lake-framework-js). There are other languages supported by community, [try this search](https://github.com/search?q=near-lake-framework&type=repositories).
4. Consider other indexer solutions built by the community

### Can I still continue using Explorer Database?

No, you won‚Äôt be able to continue using Public Explorer Database after the sunset. However you can start your own instance of https://github.com/near/near-indexer-for-explorer and reindex the history from scratch or use a latest backup. We will share a backup of Explorer DB in September if you want to run your own instance.

To run your own infra, you will need:
* **Indexer services:** We use two e2-medium instances on GCP for redundancy, with 2 vCPUs and 4GB of RAM.
* **A database:** We use Postgres version 11, with 8+ vCPUs, 52GB+ RAM and ~8TB of SSD storage. In addition, we recommend running an extra read-replica on a similar or more powerful machine.

'''
'''--- docs/4.tools/indexing-tools.md ---
---
id: indexing
title: Indexing Solutions on NEAR
sidebar_label: "Indexing Solutions"
---

# Indexing Solutions on NEAR

Here's a quick overview of Indexer projects on the NEAR ecosystem:

- [QueryAPI](../2.build/6.data-infrastructure/query-api/intro.md): Near QueryAPI is a fully managed solution to build indexer functions, extract on-chain data, store it in a database, and be able to query it using GraphQL endpoints.

- [BigQuery](../2.build/6.data-infrastructure/big-query.md): Blockchain data indexing in NEAR Public Lakehouse is for anyone wanting to understand blockchain data.

- [NEAR Lake Framework](../2.build/6.data-infrastructure/lake-framework/near-lake.md): a companion library to NEAR Lake. It allows you to build your own indexer that watches a stream of blocks **from a NEAR Lake data source** and allows you to **create your own logic to process that data**. Keep in mind this is **the one you want to use for future projects**, instead of the Indexer Framework. Read [why is better](https://docs.near.org/concepts/advanced/near-indexer-framework#why-is-it-better-than-near-indexer-framework).

- [Indexer.xyz Multichain Indexer](https://indexer.xyz/): Indexer.xyz is an application layer that you can build your NFT or DeFi applications entirely on top of. In addition to raw transaction indexing, Indexer.xyz provides you with a standardized GraphQL API layer to easily tap into transactions across contracts and chains.

- [Pagoda NEAR Lake](https://docs.pagoda.co/near-lake): with this fully managed solution by [Pagoda Inc.](https://pagoda.co), you don't need to run your own NEAR Lake Nodes and AWS S3 buckets.

- [The Graph](https://thegraph.com/docs/en/cookbook/near/): development tools to process blockchain events and make the resulting data easily available via a GraphQL API, known individually as a subgraph. [Graph Node](https://github.com/graphprotocol/graph-node) is able to process NEAR events, which means that NEAR developers can build subgraphs to index their smart contracts.

- [GetBlock](https://getblock.io/explorers/near/blocks/): developer tools offering a simple and reliable API access to multiple blockchains including NEAR Protocol.

- [NearBlocks](https://api.nearblocks.io/api-docs/#/): build precise & reliable dApps with NearBlocks APIs.

- [Octopus Network NEAR Indexer](https://github.com/octopus-network/octopus-near-indexer-s3): an indexing solution based on NEAR Lake framework.

- [Covalent](https://www.covalenthq.com/docs/networks/aurora/): for [Aurora EVM](https://aurora.dev/) indexing, Covalent provides a unified API bringing visibility to billions of Web3 data points.

- [NEAR Indexer Framework](https://docs.near.org/concepts/advanced/near-indexer-framework): a micro-framework providing you with a "live" stream of blocks. Useful to handle on-chain real-time `events`.

- [NEAR Indexer for Explorer](https://docs.near.org/tools/indexer-for-explorer): an indexer built on top of the indexer microframework. It watches and stores all events/data from the blockchain to a **PostgreSQL database**.
  You can clone the [GitHub repository](https://github.com/near/near-indexer-for-explorer) and customize your own indexer solution.

- [SubQuery](https://academy.subquery.network/quickstart/quickstart_chains/near.html): is an end to end multi-blockchain indexing solution that provides NEAR developers with fast, flexible, universal, open source and decentralised APIs for web3 projects. The [NEAR starter project](https://github.com/subquery/near-subql-starter/tree/main/Near/near-starter) provides a template for developers to get up and running within minutes.

'''
'''--- docs/4.tools/near-api-js/cookbook.md ---
---
id: cookbook
title: Common Use Cases
sidebar_label: Cookbook
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The repository contains [many recipes](https://github.com/near/near-api-js/blob/master/packages/cookbook) that you can readily use to solve common case scenarios.

| Name                                                                                                                                                                                                   | Description                                                                                                 |
|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| ----------------------------------------------------------------------------------------------------------- |
| **ACCOUNTS**                                                                                                                                                                                           |                                                                                                             |
| [Create Account](https://github.com/near/near-api-js/blob/master/packages/cookbook/accounts/create-testnet-account.js)                                                                                 | Create [NEAR accounts](/concepts/protocol/account-model) without using NEAR Wallet.                                 |
| [Access Key Rotation](https://github.com/near/near-api-js/tree/master/packages/cookbook/accounts/access-keys)                                                                                         | Create and delete [access keys](/concepts/protocol/access-keys) for added security.                   |
| **TRANSACTIONS**                                                                                                                                                                                       |                                                                                                             |
| [Get Transaction Status](https://github.com/near/near-api-js/blob/master/packages/cookbook/transactions/get-tx-status.js)                                                                              | Gets transaction status using a tx hash and associated account/contract ID.                                 |
| [Recent Transaction Details](https://github.com/near/near-api-js/blob/master/packages/cookbook/transactions/get-tx-detail.js)                                                                          | Get recent transaction details without using an [indexing](/concepts/advanced/near-indexer-framework) service. |
| [Batch Transactions](https://github.com/near/near-api-js/blob/master/packages/cookbook/transactions/batch-transactions.js)                                                                             | Sign and send multiple [transactions](/concepts/protocol/transactions).                              |
| **UTILS**                                                                                                                                                                                              |                                                                                                             |
| [Deploy Contract](https://github.com/near/near-api-js/blob/master/packages/cookbook/utils/deploy-contract.js)                                                                                          | Deploys a smart contract using a pre-compiled WASM file.                                                    |
| [Calculate Gas](https://github.com/near/near-api-js/blob/master/packages/cookbook/utils/calculate-gas.js)                                                                                              | Calculate [gas burnt](/concepts/protocol/gas) from any contract call.                            |
| [Read State w/o Account](https://github.com/near/near-api-js/blob/master/packages/cookbook/utils/get-state.js)                                                                                         | Read state of a contract without instantiating an account.                                                  |
| [Wrap](https://github.com/near/near-api-js/blob/master/packages/cookbook/utils/wrap-near.js) & [Unwrap](https://github.com/near/near-api-js/blob/master/packages/cookbook/utils/unwrap-near.js)  NEAR  | Wrap and unwrap NEAR using the `wrap.near` smart contract.                                                  |
| [Verify Signature](https://github.com/near/near-api-js/blob/master/packages/cookbook/utils/verify-signature.js)                                                                                        | Verify a key pair signature.                                                                                |

'''
'''--- docs/4.tools/near-api-js/faq.md ---
---
id: faq
title: FAQ for NEAR JavaScript API
sidebar_label: FAQ
---

A collection of Frequently Asked Questions by the community.

## General {#general}

### Can I use `near-api-js` on a static html page? {#can-i-use-near-api-js-on-a-static-html-page}

You can load the script from a CDN.

```html
<script src="https://cdn.jsdelivr.net/npm/near-api-js@0.45.1/dist/near-api-js.min.js"></script>
```

:::note
Make sure you load the latest version.

Versions list is on [npmjs.com](https://www.npmjs.com/package/near-api-js)
:::

<details>
<summary>Example Implementation</summary>
<p>

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <ul id="messages"></ul>
  <textarea id="text" placeholder="Add Message"></textarea>
  <button id="add-text">Add Text</button>
  <script src="https://cdn.jsdelivr.net/npm/near-api-js@0.45.1/dist/near-api-js.min.js"></script>
  <script>
    // connect to NEAR
    const near = new nearApi.Near({
      keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
      networkId: 'testnet',
      nodeUrl: 'https://rpc.testnet.near.org',
      walletUrl: 'https://testnet.mynearwallet.com/'
    });
    
    // connect to the NEAR Wallet
    const wallet = new nearApi.WalletConnection(near, 'my-app');

    // connect to a NEAR smart contract
    const contract = new nearApi.Contract(wallet.account(), 'guest-book.testnet', {
      viewMethods: ['getMessages'],
      changeMethods: ['addMessage']
    });

    const button = document.getElementById('add-text');
    if (!wallet.isSignedIn()) {
      button.textContent = 'SignIn with NEAR'
    }

    // call the getMessages view method
    contract.getMessages()
      .then(messages => {
        const ul = document.getElementById('messages');
        messages.forEach(message => {
          const li = document.createElement('li');
          li.textContent = `${message.sender} - ${message.text}`;
          ul.appendChild(li);
        })
      });

    // Either sign in or call the addMessage change method on button click
    document.getElementById('add-text').addEventListener('click', () => {
      if (wallet.isSignedIn()) {
        contract.addMessage({
          args: { text: document.getElementById('text').value },
          amount: nearApi.utils.format.parseNearAmount('1')
        })
      } else {
        wallet.requestSignIn({
          contractId: 'guest-book.testnet',
          methodNames: ['getMessages', 'addMessage']
        });
      }
    });
  </script>
</body>

</html>
```

</p>
</details>

---

### What front-end frameworks can I use the JavaScript API with?

The JavaScript API is framework-agnostic. You can include it in any front-end framework, such as React, Vue, Angular, and others.

You can use [`create-near-app`](https://github.com/near/create-near-app) to quickly bootstrap projects with different templates:

    npx create-near-app

### Can I use the JavaScript API with mobile JavaScript frameworks such as React Native?

The JavaScript API can be used in most JavaScript runtimes, and under the hood, it‚Äôs an abstraction over NEAR‚Äôs [RPC API](/api/rpc/introduction). However, notice that the Wallet can‚Äôt be used everywhere. For example, in React Native apps you‚Äôll be able to use the Wallet in web versions of the apps, but it won‚Äôt work in the native app deployments.

You can use the Wallet in `WebView` components in iOS or Android, however be aware that it uses `LocalStorage` for `KeyStore`, and it‚Äôs your responsibility to persist the storage when you manage loading of `WebView` components.

---

## Transactions {#transactions}

### How to check the status of transaction

Please refer to examples about transactions in the [Cookbook](/tools/near-api-js/cookbook).

### How transactions are signed and sent by near-api-js

There are a few steps involved before transaction data is communicated to the network and eventually included in a block. The following steps are taken when creating, signing and ultimately a transaction from a user's account:

1. The user creates a transaction object using the [`account.signAndSendTransaction` method](https://github.com/near/near-api-js/blob/f78616480ba84c73f681211fe6266bd2ed2b9da1/packages/near-api-js/src/account.ts#L200). This method accepts an array of actions and returns an object for the outcome of the transaction.
2. The transaction is signed using the [`account.signTransaction` method](https://github.com/near/near-api-js/blob/f78616480ba84c73f681211fe6266bd2ed2b9da1/packages/near-api-js/src/account.ts#L204). This method accepts an array of actions and returns a signed transaction object.
3. The signed transaction object is sent to the network using the [`account.connection.provider.sendTransaction` method](https://github.com/near/near-api-js/blob/f78616480ba84c73f681211fe6266bd2ed2b9da1/packages/near-api-js/src/account.ts#L208). This method accepts a signed transaction object and returns a transaction hash. This step [performs the borsh serialization of the transaction object](https://github.com/near/near-api-js/blob/f78616480ba84c73f681211fe6266bd2ed2b9da1/packages/near-api-js/src/providers/json-rpc-provider.ts#L80) and calls the [`broadcast_tx_commit` JSON RPC method with the serialized transaction object encoded in base64](https://github.com/near/near-api-js/blob/f78616480ba84c73f681211fe6266bd2ed2b9da1/packages/near-api-js/src/providers/json-rpc-provider.ts#L81).

### How to send batch transactions

You may batch send transactions by using the `signAndSendTransaction({})` method from `account`. This method takes an array of transaction actions, and if one fails, the entire operation will fail. Here's a simple example:

```js
const { connect, transactions, keyStores } = require("near-api-js");
const fs = require("fs");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const CONTRACT_NAME = "spf.idea404.testnet";
const WASM_PATH = path.join(__dirname, "../build/uninitialized_nft.wasm");

const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
  keyStore,
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
};

sendTransactions();

async function sendTransactions() {
  const near = await connect({ ...config, keyStore });
  const account = await near.account(CONTRACT_NAME);
  const args = { some_field: 1, another_field: "hello" };

  const balanceBefore = await account.getAccountBalance();
  console.log("Balance before:", balanceBefore);

  try {
    const result = await account.signAndSendTransaction({
      receiverId: CONTRACT_NAME,
      actions: [
        transactions.deployContract(fs.readFileSync(WASM_PATH)),  // Contract does not get deployed
        transactions.functionCall("new", Buffer.from(JSON.stringify(args)), 10000000000000, "0"),  // this call fails
        transactions.transfer("1" + "0".repeat(24)), // 1 NEAR is not transferred either
      ],
    });
    console.log(result);
  } catch (e) {
    console.log("Error:", e);
  }

  const balanceAfter = await account.getAccountBalance();
  console.log("Balance after:", balanceAfter);
}
```

```
Balance before: {
  total: '49987878054959838200000000',
  stateStaked: '4555390000000000000000000',
  staked: '0',
  available: '45432488054959838200000000'
}
Receipts: 2PPueY6gnA4YmmQUzc8DytNBp4PUpgTDhmEjRSHHVHBd, 3isLCW9SBH1MrPjeEPAmG9saHLj9Z2g7HxzfBdHmaSaG
	Failure [spf.idea404.testnet]: Error: {"index":1,"kind":{"ExecutionError":"Smart contract panicked: panicked at 'Failed to deserialize input from JSON.: Error(\"missing field `owner_id`\", line: 1, column: 40)', nft/src/lib.rs:47:1"}}
Error: ServerTransactionError: {"index":1,"kind":{"ExecutionError":"Smart contract panicked: panicked at 'Failed to deserialize input from JSON.: Error(\"missing field `owner_id`\", line: 1, column: 40)', nft/src/lib.rs:47:1"}}
    at parseResultError (/Users/dennis/Code/naj-test/node_modules/near-api-js/lib/utils/rpc_errors.js:31:29)
    at Account.<anonymous> (/Users/dennis/Code/naj-test/node_modules/near-api-js/lib/account.js:156:61)
    at Generator.next (<anonymous>)
    at fulfilled (/Users/dennis/Code/naj-test/node_modules/near-api-js/lib/account.js:5:58)
    at processTicksAndRejections (node:internal/process/task_queues:96:5) {
  type: 'FunctionCallError',
  context: undefined,
  index: 1,
  kind: {
    ExecutionError: 'Smart contract panicked: panicked at \'Failed to deserialize input from JSON.: Error("missing field `owner_id`", line: 1, column: 40)\', nft/src/lib.rs:47:1'
  },
  transaction_outcome: {
    block_hash: '5SUhYcXjXR1svCxL5BhCuw88XNdEjKXqWgA9X4XZW1dW',
    id: 'SKQqAgnSN27fyHpncaX3fCUxWknBrMtxxytWLRDQfT3',
    outcome: {
      executor_id: 'spf.idea404.testnet',
      gas_burnt: 4839199843770,
      logs: [],
      metadata: [Object],
      receipt_ids: [Array],
      status: [Object],
      tokens_burnt: '483919984377000000000'
    },
    proof: [ [Object], [Object], [Object], [Object], [Object] ]
  }
}
Balance after: {
  total: '49985119959346682700000000',
  stateStaked: '4555390000000000000000000',
  staked: '0',
  available: '45429729959346682700000000'
}

```

You may also find an example of batch transactions in the [Cookbook](/tools/near-api-js/cookbook).

---

## Accounts {#accounts}

### What‚Äôs the difference between `Account` and `ConnectedWalletAccount`?

Interaction with the wallet is only possible in a web-browser environment because NEAR‚Äôs Wallet is web-based.
The difference between `Account` and `ConnectedWalletAccount` is mostly about the way it signs transactions. The `ConnectedWalletAccount` uses the wallet to approve transactions.
Under the hood the `ConnectedWalletAccount` inherits and overrides some methods of `Account`.

### How to create implicit accounts?

You can read about it in the article about [Implicit Accounts](https://docs.near.org/integrations/implicit-accounts).

---

## Contracts {#contracts}

### How do I attach gas / a deposit? {#how-do-i-attach-gas--a-deposit}

After [contract is instantiated](/tools/near-api-js/quick-reference#load-contract) you can then call the contract and specify the amount of attached gas.

```js
await contract.method_name(
  {
    arg_name: "value", // argument name and value - pass empty object if no args required
  },
  "300000000000000", // attached GAS (optional)
  "1000000000000000000000000" // attached deposit in yoctoNEAR (optional)
);
```

---

## Common Errors {#common-errors}

### RPC Errors

Refer to the exhaustive [list of error messages](https://github.com/near/near-api-js/blob/16ba17251ff7d9c8454261001cd6b87e9a994789/packages/near-api-js/src/res/error_messages.json)
that RPC endpoints throws and JavaScript API propagates.

### Missing contract methods {#missing-contract-method}

When constructing a `Contract` instance on the client-side, you need to specify
the contract's methods. If you misspell, mismatch, or miss method names - you'll
receive errors about missing methods.

There are a few cases of missing or wrong methods:
- When you call a method you didn't specify in the constructor.
- When you call a method that doesn't exist on the blockchain's contract (but you did specify it in the client-side constructor).
- When you mismatch between `viewMethods` and `changeMethods`.

For example, let's look at the following contract code.
It contains one `view` and one `call` method:

```js
@NearBindgen
class MyContract extends NearContract {
  constructor() { super(); }

  @view
  method_A_view(): string {
    return 'Hi';
  }

  @call
  method_B_call(): void {}
}
```

#### Client-side errors for missing methods

##### `TypeError: contract.METHOD_NAME is not a function`

The following contract constructor declares only `method_A_view`, it doesn't declare `method_B_call`
```js
const contract = await new nearAPI.Contract(
  walletConnection.account(), 'guest-book.testnet',
  {
    viewMethods: ['method_A_view'], // <=== Notice this
    changeMethods: [], // <=== Notice this
    sender: walletConnection.getAccountId(),
  }
);

// This will work because we declared `method_A_view` in constructor
await contract.method_A_view();

// This will throw `TypeError: contract.method_B_call is not a function` 
// because we didn't declare `method_B_call` in constructor, 
// even if it exists in the real contract.
await contract.method_B_call();

// This will also throw `TypeError: contract.method_C is not a function`,
// not because `method_C` doesn't exist on the contract, but because we didn't declare it
// in the client-side constructor.
await contract.method_C();
```

#### RPC errors for missing methods

##### `wasm execution failed with error: FunctionCallError(MethodResolveError(MethodNotFound))`

In this example we specify and call a method, but this method doesn't exist on the blockchain:
```js
const contract = await new nearAPI.Contract(
  // ...
  {
    viewMethods: ["method_C"], // <=== method_C doesn't exist on the contract above
    changeMethods: [],
    // ...
  }
);
// We did specify `method_C` name in constructor, so this function exists on client-side `contract` instance,
// but a method with this name does not exist on the actual contract on the blockchain.
// This will return an error from RPC call `FunctionCallError(MethodResolveError(MethodNotFound))`
// and will throw it on the client-side
await contract.method_C();

// Notice: if we call `method_A_view` we get `TypeError: contract.method_A_view is not a function`.
// Even though the method exists on the actual blockchain contract,
// we didn't specify `method_A_view` in the contract's client-side constructor.
await contract.method_A_view();
```

##### `wasm execution failed with error: FunctionCallError(HostError(ProhibitedInView { method_name: "storage_write" }))`

Last case is when you mismatch `viewMethods` and `changeMethods`.

In the contract above we declared:
- A `@view` method named `method_A_view`
- A `@call` method named `method_B_call`

In a client-side constructor, the contract's `@view` method names must be specified under `viewMethods`,
and the contract's `@call` method names must be specified under `changeMethods`.
If we mismatch between the types we will receive errors.

For example:
```js
const contract = await new nearAPI.Contract(
  // ...
  {
    viewMethods: ['method_B_call'], // <=== here should be `method_A_view`
    changeMethods: ['method_A_view'], // <=== and here should be `method_B_call`
    // ...
  }
);

// This will return an error from RPC call and throw:
// `wasm execution failed with error: FunctionCallError(HostError(ProhibitedInView { method_name: "storage_write" }))`
// This error indicates that we are trying to call a state-changing method but declare it as a read-only method in client-side.
await contract.method_B_call();

// The following behavior is undefined and might not work as expected.
// `method_A_veiw` should be declared under `viewMethods` and in our example here we declare it under `changeMethods`.
await contract.method_A_view();
```

### Class `{X}` is missing in schema: publicKey

There is currently a known issue with the JavaScript API library, when you `import` it more than once
it might cause a namespace collision.

A temporary workaround: make sure you don't re-import it, for example when running tests.

---

### `regeneratorRuntime` is not defined {#regeneratorruntime-is-not-defined}

You are probably using [Parcel](https://parceljs.org/) like we do in [other examples](https://github.com/near-examples). Please make sure you have this line at the top of your main JS file. (Most likely `index.js`):

```js
import "regenerator-runtime/runtime";
```

- Also, ensure the dependencies for this are added to the project by checking the dev dependencies in your `package.json`. If not found you can install this by running the following in your terminal:

```bash
npm install regenerator-runtime --save-dev
```

---

### Window error using `Node.js` {#window-error-using-nodejs}

You're maybe using a KeyStore that's for the browser. Instead, use a [filesystem key](/tools/near-api-js/quick-reference#key-store) or private key string.

**Browser KeyStore:**

```js
const { keyStores } = require("near-api-js");
const keyStore = new keyStores.BrowserLocalStorageKeyStore();
```

**FileSystem KeyStore:**

```js
const { keyStores } = require("near-api-js");
const KEY_PATH = "~./near-credentials/testnet/example-account.json";
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(KEY_PATH);
```

'''
'''--- docs/4.tools/near-api-js/naj-account.md ---
---
id: account
title: Account
sidebar_label: Account
---

You can interact with, create or delete NEAR accounts.

### Load Account {#load-account}

This will return an Account object for you to interact with.

```js
const account = await nearConnection.account("example-account.testnet");
```

[<span className="typedoc-icon typedoc-icon-class"></span> Class `Account`](https://near.github.io/near-api-js/classes/near_api_js.account.Account.html)

### Create Account {#create-account}

Create a sub-account.

```js
// creates a sub-account using funds from the account used to create it.
const account = await nearConnection.account("example-account.testnet");
await account.createAccount(
  "sub.example-account.testnet", // sub-account name
  "8hSHprDq2StXwMtNd43wDTXQYsjXcD4MJTXQYsjXcc", // public key for sub account
  "10000000000000000000" // initial balance for new account in yoctoNEAR
);
```

[<span className="typedoc-icon typedoc-icon-method"></span> Method `Account.createAccount`](https://near.github.io/near-api-js/classes/near_api_js.account.Account.html#createAccount)

For creating .near or .testnet accounts please refer to the [cookbook](https://github.com/near/near-api-js/tree/master/packages/cookbook/accounts).

### Delete Account {#delete-account}

```js
// deletes account found in the `account` object
// transfers remaining account balance to the accountId passed as an argument
const account = await nearConnection.account("example-account.testnet");
await account.deleteAccount("beneficiary-account.testnet");
```

[<span className="typedoc-icon typedoc-icon-method"></span> Method `Account.deleteAccount`](https://near.github.io/near-api-js/classes/near_api_js.account.Account.html#deleteAccount)

### Get Account Balance {#get-account-balance}

```js
// gets account balance
const account = await nearConnection.account("example-account.testnet");
await account.getAccountBalance();
```

[<span className="typedoc-icon typedoc-icon-method"></span> Method `Account.getAccountBalance`](https://near.github.io/near-api-js/classes/near_api_js.account.Account.html#getAccountBalance)

### Get Account details {#get-account-details}

Returns information about an account, such as authorized apps.

```js
// gets account details in terms of authorized apps and transactions
const account = await nearConnection.account("example-account.testnet");
await account.getAccountDetails();
```

[<span className="typedoc-icon typedoc-icon-method"></span> Method `Account.getAccountDetails`](https://near.github.io/near-api-js/classes/near_api_js.account.Account.html#getAccountDetails)

### Deploy a Contract {#deploy-a-contract}

You can deploy a contract from a compiled WASM file. This returns an object with transaction and receipts outcomes and status.

```js
const account = await nearConnection.account("example-account.testnet");
const transactionOutcome = await account.deployContract(
  fs.readFileSync("example-file.wasm")
);
```

[<span className="typedoc-icon typedoc-icon-method"></span> Method `Account.deployContract`](https://near.github.io/near-api-js/classes/near_api_js.account.Account.html#deployContract)
&nbsp;&nbsp;&nbsp;
[<span className="typedoc-icon typedoc-icon-interface"></span> Interface `FinalExecutionOutcome`](https://near.github.io/near-api-js/interfaces/_near_js_types.provider_response.FinalExecutionOutcome.html)

### Send Tokens {#send-tokens}

Transfer NEAR tokens between accounts. This returns an object with transaction and receipts outcomes and status.

```js
const account = await nearConnection.account("sender-account.testnet");
await account.sendMoney(
  "receiver-account.testnet", // receiver account
  "1000000000000000000000000" // amount in yoctoNEAR
);
```

[<span className="typedoc-icon typedoc-icon-method"></span> Method `Account.sendMoney`](https://near.github.io/near-api-js/classes/near_api_js.account.Account.html#sendMoney)
&nbsp;&nbsp;&nbsp;
[<span className="typedoc-icon typedoc-icon-interface"></span> Interface `FinalExecutionOutcome`](https://near.github.io/near-api-js/interfaces/_near_js_types.provider_response.FinalExecutionOutcome.html)

### State {#state}

Get basic account information, such as amount of tokens the account has or the amount of storage it uses.

```js
const account = await nearConnection.account("example-account.testnet");
const accountState = await account.state();
```

[<span className="typedoc-icon typedoc-icon-method"></span> Method `Account.state`](https://near.github.io/near-api-js/classes/near_api_js.account.Account.html#state)
&nbsp;&nbsp;&nbsp;
[<span className="typedoc-icon typedoc-icon-interface"></span> Interface `AccountView`](https://near.github.io/near-api-js/interfaces/near_api_js.providers_provider.AccountView.html)

### Access Keys {#access-keys}

You can get and manage keys for an account.

#### Add Full Access Key {#add-full-access-key}

```js
// takes public key as string for argument
const account = await nearConnection.account("example-account.testnet");
await account.addKey("8hSHprDq2StXwMtNd43wDTXQYsjXcD4MJTXQYsjXcc");
```

[<span className="typedoc-icon typedoc-icon-method"></span> Method `Account.addKey`](https://near.github.io/near-api-js/classes/near_api_js.account.Account.html#addKey)

#### Add Function Access Key {#add-function-access-key}

```js
const account = await nearConnection.account("example-account.testnet");
await account.addKey(
  "8hSHprDq2StXwMtNd43wDTXQYsjXcD4MJTXQYsjXcc", // public key for new account
  "example-account.testnet", // contract this key is allowed to call (optional)
  "example_method", // methods this key is allowed to call (optional)
  "2500000000000" // allowance key can use to call methods (optional)
);
```

[<span className="typedoc-icon typedoc-icon-method"></span> Method `Account.addKey`](https://near.github.io/near-api-js/classes/near_api_js.account.Account.html#addKey)

#### Get All Access Keys {#get-all-access-keys}

```js
const account = await nearConnection.account("example-account.testnet");
await account.getAccessKeys();
```

[<span className="typedoc-icon typedoc-icon-method"></span> Method `Account.getAccessKeys`](https://near.github.io/near-api-js/classes/near_api_js.account.Account.html#getAccessKeys)
&nbsp;&nbsp;&nbsp;
[<span className="typedoc-icon typedoc-icon-interface"></span> Interface `AccessKeyInfoView`](https://near.github.io/near-api-js/interfaces/near_api_js.providers_provider.AccessKeyInfoView.html)

#### Delete Access Key {#delete-access-key}

```js
const account = await nearConnection.account("example-account.testnet");
await account.deleteKey("8hSHprDq2StXwMtNd43wDTXQYsjXcD4MJTXQYsjXcc");
```

[<span className="typedoc-icon typedoc-icon-method"></span> Method `Account.deleteKey`](https://near.github.io/near-api-js/classes/near_api_js.account.Account.html#deleteKey)

'''
'''--- docs/4.tools/near-api-js/naj-contract.md ---
---
id: contract
title: Contract
sidebar_label: Contract
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

When you instantiate an instance of `Contract` you need to specify the names of the functions you have on your smart contract.
Then the new instance of `Contract` will have methods with the same names as your smart contract functions.
For example if you deployed a contract with `my_smart_contract_function` function on it, then this will work:

```js
const contract = new Contract(account, "example-contract.testnet", {
  changeMethods: ["my_smart_contract_function"], // your smart-contract has a function `my_smart_contract_function`
});
// `contract` object has `my_smart_contract_function` function on it:
contract.my_smart_contract_function();
```

### Load Contract {#load-contract}

<Tabs>
<TabItem value="Standard" label="Standard" default>

```js
const { Contract } = nearAPI;

const contract = new Contract(
  account, // the account object that is connecting
  "example-contract.testnet",
  {
    // name of contract you're connecting to
    viewMethods: ["getMessages"], // view methods do not change state but usually return a value
    changeMethods: ["addMessage"], // change methods modify state
  }
);
```

[<span className="typedoc-icon typedoc-icon-class"></span> Class `Contract`](https://near.github.io/near-api-js/classes/_near_js_accounts.contract.Contract.html)

</TabItem>
<TabItem value="wallet" label="Using Wallet">

```js
const { Contract } = nearAPI;

const contract = new Contract(
  wallet.account(), // the account object that is connecting
  "example-contract.testnet",
  {
    // name of contract you're connecting to
    viewMethods: ["getMessages"], // view methods do not change state but usually return a value
    changeMethods: ["addMessage"], // change methods modify state
  }
);
```

[<span className="typedoc-icon typedoc-icon-class"></span> Class `Contract`](https://near.github.io/near-api-js/classes/_near_js_accounts.contract.Contract.html)

</TabItem>
</Tabs>

### Call Contract {#call-contract}

<Tabs>
<TabItem value="method" label="Change Method" default>

```js
const contract = new Contract(account, "example-contract.testnet", {
  changeMethods: ["method_name"],
});
await contract.method_name(
  {
    arg_name: "value", // argument name and value - pass empty object if no args required
  },
  "300000000000000", // attached GAS (optional)
  "1000000000000000000000000" // attached deposit in yoctoNEAR (optional)
);
```

</TabItem>
<TabItem value="callback" label="Change Method w/ callbackUrl and meta">

```js
const contract = new Contract(account, "example-contract.testnet", {
  changeMethods: ["method_name"],
});
await contract.method_name({
  callbackUrl: "https://example.com/callback", // callbackUrl after the transaction approved (optional)
  meta: "some info", // meta information NEAR Wallet will send back to the application. `meta` will be attached to the `callbackUrl` as a url param
  args: {
    arg_name: "value", // argument name and value - pass empty object if no args required
  },
  gas: 300000000000000, // attached GAS (optional)
  amount: 1000000000000000000000000, // attached deposit in yoctoNEAR (optional)
});
```

</TabItem>
<TabItem value="view" label="View Method">

```js
const contract = new Contract(account, "example-contract.testnet", {
  viewMethods: ["view_method_name"],
});
const response = await contract.view_method_name();
```

</TabItem>
<TabItem value="args" label="View Method w/ args">

```js
const contract = new Contract(account, "example-contract.testnet", {
  viewMethods: ["view_method_name"],
});
const response = await contract.view_method_name({ arg_name: "arg_value" });
```

</TabItem>
</Tabs>

[<span className="typedoc-icon typedoc-icon-class"></span> Class `Contract`](https://near.github.io/near-api-js/classes/_near_js_accounts.contract.Contract.html)

[//]: # "## Transactions {#transactions}"
[//]: # "A [Transaction](/concepts/protocol/transactions) is a collection of Actions, and there are few types of Actions."
[//]: # "For every type of Action there is a function on Account that you can use to invoke the Action, but Account also exposes `signAndSendTransaction` function which you can use to build and invoke a batch transaction."

'''
'''--- docs/4.tools/near-api-js/naj-utils.md ---
---
id: utils
title: Utilities
sidebar_label: Utilities
---

### NEAR => yoctoNEAR {#near--yoctonear}

```js
// converts NEAR amount into yoctoNEAR (10^-24)

const { utils } = nearAPI;
const amountInYocto = utils.format.parseNearAmount("1");
```

[<span className="typedoc-icon typedoc-icon-function"></span> Function `parseNearAmount`](https://near.github.io/near-api-js/functions/_near_js_utils.format.parseNearAmount.html)

### YoctoNEAR => NEAR {#yoctonear--near}

```js
// converts yoctoNEAR (10^-24) amount into NEAR

const { utils } = nearAPI;
const amountInNEAR = utils.format.formatNearAmount("1000000000000000000000000");
```

[<span className="typedoc-icon typedoc-icon-function"></span> Function `formatNearAmount`](https://near.github.io/near-api-js/functions/_near_js_utils.format.formatNearAmount.html)

'''
'''--- docs/4.tools/near-api-js/naj-wallet.md ---
---
id: wallet
title: Interacting with the Wallet
sidebar_label: Wallet
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Wallet interaction is possible only in the browser, because NEAR's Wallet is web-based.

Most frequent action is Sign In. Your user is redirected to the Wallet page to authorize your application.
Once the user has Signed In, an access key is saved in browser's LocalStorage.
All following actions that require the access key will be allowed.
In case a user needs to authorize a transaction that has a deposit attached, your user will be automatically redirected to the Wallet again.

### Creating Wallet Connection {#wallet-connection}

In Wallet connection you use a LocalStorage [`KeyStore`](/tools/near-api-js/quick-reference#key-store).

<Tabs>
<TabItem value="testnet" label="TestNet" default>

```js
const { connect, keyStores, WalletConnection } = nearAPI;

const connectionConfig = {
  networkId: "testnet",
  keyStore: new keyStores.BrowserLocalStorageKeyStore(),
  nodeUrl: "https://rpc.testnet.near.org",
  walletUrl: "https://testnet.mynearwallet.com/",
  helperUrl: "https://helper.testnet.near.org",
  explorerUrl: "https://testnet.nearblocks.io",
};

// connect to NEAR
const nearConnection = await connect(connectionConfig);

// create wallet connection
const walletConnection = new WalletConnection(nearConnection);
```

</TabItem>
<TabItem value="mainnet" label="MainNet">

```js
const { connect, keyStores, WalletConnection } = nearAPI;

const connectionConfig = {
  networkId: "mainnet",
  keyStore: new keyStores.BrowserLocalStorageKeyStore(),
  nodeUrl: "https://rpc.mainnet.near.org",
  walletUrl: "https://wallet.mainnet.near.org",
  helperUrl: "https://helper.mainnet.near.org",
  explorerUrl: "https://nearblocks.io",
};

// connect to NEAR
const nearConnection = await connect(connectionConfig);

// create wallet connection
const walletConnection = new WalletConnection(nearConnection);
```

</TabItem>

</Tabs>

[<span className="typedoc-icon typedoc-icon-module"></span> Module `browserConnect`](https://near.github.io/near-api-js/modules/near_api_js.browserConnect.html)
&nbsp;&nbsp;&nbsp;
[<span className="typedoc-icon typedoc-icon-class"></span> Class `WalletConnection`](https://near.github.io/near-api-js/classes/_near_js_wallet_account.walletAccount.WalletConnection.html)

### Ask your user to Sign In {#sign-in}

You first create a [WalletConnection](#wallet-connection), and then call `requestSignIn`.
This will redirect the current page to the Wallet authentication page.
You can configure success and failure redirect URLs.

This action creates an access key that will be stored in the browser's local storage.
You can optionally list `methodNames` you want to allow for the access key.
If you don't specify `methodNames` or pass an empty array, then all methods are allowed to be called (the access key will be created with permissions to call all methods).

```js
// const walletConnection = new WalletConnection(nearConnection);
walletConnection.requestSignIn({
  contractId: "example-contract.testnet.REPLACE_ME",
  methodNames: [], // optional
  successUrl: "REPLACE_ME://.com/success", // optional redirect URL on success
  failureUrl: "REPLACE_ME://.com/failure", // optional redirect URL on failure
});
```

[<span className="typedoc-icon typedoc-icon-method"></span> Method `WalletConnection.requestSignIn`](https://near.github.io/near-api-js/classes/_near_js_wallet_account.walletAccount.WalletConnection.html#requestSignIn)

:::tip
Sign In is **_not required_** if you are using an alternative key store to local storage, or you are not signing transactions (meaning - you are only calling read-only _view_ methods on a contract)
:::

### Sign Out your user {#sign-out}

```js
// const walletConnection = new WalletConnection(nearConnection);
walletConnection.signOut();
```

[<span className="typedoc-icon typedoc-icon-method"></span> Method `WalletConnection.signOut`](https://near.github.io/near-api-js/classes/_near_js_wallet_account.walletAccount.WalletConnection.html#signOut)

### Check if Signed In {#check-if-signed-in}

```js
// const walletConnection = new WalletConnection(nearConnection);
if (walletConnection.isSignedIn()) {
  // user is signed in
}
```

[<span className="typedoc-icon typedoc-icon-method"></span> Method `WalletConnection.isSignedId`](https://near.github.io/near-api-js/classes/_near_js_wallet_account.walletAccount.WalletConnection.html#isSignedIn)

### Get Wallet Account {#get-authorized-account}

Get the [Account](naj-account.md) your user has signed in with in the Wallet.

#### Get Account ID (as string) {#get-authorized-account-id}

```js
// const walletConnection = new WalletConnection(nearConnection);
const walletAccountId = walletConnection.getAccountId();
```

[<span className="typedoc-icon typedoc-icon-method"></span> Method `WalletConnection.getAccountId`](https://near.github.io/near-api-js/classes/_near_js_wallet_account.walletAccount.WalletConnection.html#getAccountId)

#### Get Account Object {#get-authorized-account-object}

```js
// const walletConnection = new WalletConnection(nearConnection);
const walletAccountObj = walletConnection.account();
```

[<span className="typedoc-icon typedoc-icon-method"></span> Method `WalletConnection.account`](https://near.github.io/near-api-js/classes/_near_js_wallet_account.walletAccount.WalletConnection.html#account)
&nbsp;&nbsp;&nbsp;
[<span className="typedoc-icon typedoc-icon-class"></span> Class `ConnectedWalletAccount`](https://near.github.io/near-api-js/classes/_near_js_wallet_account.walletAccount.ConnectedWalletAccount.html)

'''
'''--- docs/4.tools/near-api-js/quick-reference.md ---
---
id: quick-reference
title: Using JavaScript API to interact with NEAR
sidebar_label: Using JavaScript API
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Quick Reference

- [Installation](#install)
- [Interacting with the Wallet](naj-wallet.md)
- [Accounts](naj-account.md)
- [Contracts](naj-contract.md)
- [Utilities](naj-utils.md)

## What is `near-api-js`

`near-api-js` is a complete library to interact with the NEAR blockchain. You can use it in the browser, or in Node.js runtime.

You'll typically first create a connection to NEAR with [`connect`](#connect) using a [`KeyStore`](#key-store).
With the connection object you now can:

- Interact with the [Wallet](naj-wallet.md) in a browser.
- Instantiate an [Account](naj-account.md) object to:
  - Send tokens
  - Deploy contracts
  - Inspect, create or delete accounts
  - Manage keys for accounts.
- Instantiate a [Contract](naj-contract.md) object to call smart contract methods.

The library also contains some [utility functions](naj-utils.md).

:::tip
To quickly get started with integrating NEAR in a web browser, read our [Web Frontend integration](/build/web3-apps/integrate-contracts) article.
:::

:::info
Note the difference between `near-api-js` and `near-sdk-js`:

The JavaScript _SDK_ is a library for developing smart contracts. It contains classes and functions you use to write your smart contract code.

The JavaScript _API_ is a complete library for all possible commands to interact with NEAR. It‚Äôs a wrapper for the RPC endpoints, a library to interact with NEAR Wallet in the browser, and a tool for keys management.
:::

---

## Install {#install}

Include `near-api-js` as a dependency in your package.

```bash
npm i --save near-api-js
```

## Import {#import}

You can use the API library in the browser, or in Node.js runtime. Some features are available only in one of the environments.
For example, the `WalletConnection` is only for the browser, and there are different `KeyStore` providers for each environment.

<Tabs>
<TabItem value="Browser" label="Browser" default>

```js
import * as nearAPI from "near-api-js";
```

</TabItem>
<TabItem value="Node" label="Node">

```js
const nearAPI = require("near-api-js");
```

</TabItem>
</Tabs>

## Key Store {#key-store}

If you sign transactions, you need to create a _Key Store_. In the browser, the LocalStorage KeyStore will be used once you ask your user to Sign In with the Wallet.

<Tabs>
<TabItem value="browser" label="Using Browser" default>

```js
// creates keyStore using private key in local storage

const { keyStores } = nearAPI;
const myKeyStore = new keyStores.BrowserLocalStorageKeyStore();
```

[<span className="typedoc-icon typedoc-icon-class"></span> Class `BrowserLocalStorageKeyStore`](https://near.github.io/near-api-js/classes/_near_js_keystores_browser.browser_local_storage_key_store.BrowserLocalStorageKeyStore.html)

</TabItem>
<TabItem value="dir" label="Using Credentials Directory">

```js
// creates a keyStore that searches for keys in .near-credentials
// requires credentials stored locally by using a NEAR-CLI command: `near login`
// https://docs.near.org/tools/cli#near-login

const { keyStores } = nearAPI;
const homedir = require("os").homedir();
const CREDENTIALS_DIR = ".near-credentials";
const credentialsPath = require("path").join(homedir, CREDENTIALS_DIR);
const myKeyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);
```

[<span className="typedoc-icon typedoc-icon-class"></span> Class `UnencryptedFileSystemKeyStore`](https://near.github.io/near-api-js/classes/_near_js_keystores_node.unencrypted_file_system_keystore.UnencryptedFileSystemKeyStore.html)

</TabItem>
<TabItem value="file" label="Using a File">

```js
// creates keyStore from a provided file
// you will need to pass the location of the .json key pair

const { KeyPair, keyStores } = require("near-api-js");
const fs = require("fs");
const homedir = require("os").homedir();

const ACCOUNT_ID = "near-example.testnet"; // NEAR account tied to the keyPair
const NETWORK_ID = "testnet";
// path to your custom keyPair location (ex. function access key for example account)
const KEY_PATH = "/.near-credentials/near-example-testnet/get_token_price.json";

const credentials = JSON.parse(fs.readFileSync(homedir + KEY_PATH));
const myKeyStore = new keyStores.InMemoryKeyStore();
myKeyStore.setKey(
  NETWORK_ID,
  ACCOUNT_ID,
  KeyPair.fromString(credentials.private_key)
);
```

[<span className="typedoc-icon typedoc-icon-class"></span> Class `InMemoryKeyStore`](https://near.github.io/near-api-js/classes/_near_js_keystores.in_memory_key_store.InMemoryKeyStore.html)
&nbsp;&nbsp;&nbsp;
[<span className="typedoc-icon typedoc-icon-class"></span> Class `KeyPair`](https://near.github.io/near-api-js/classes/_near_js_crypto.key_pair.KeyPair.html)

</TabItem>
<TabItem value="key" label="Using a private key string">

```js
// creates keyStore from a private key string
// you can define your key here or use an environment variable

const { keyStores, KeyPair } = nearAPI;
const myKeyStore = new keyStores.InMemoryKeyStore();
const PRIVATE_KEY =
  "by8kdJoJHu7uUkKfoaLd2J2Dp1q1TigeWMG123pHdu9UREqPcshCM223kWadm";
// creates a public / private key pair using the provided private key
const keyPair = KeyPair.fromString(PRIVATE_KEY);
// adds the keyPair you created to keyStore
await myKeyStore.setKey("testnet", "example-account.testnet", keyPair);
```

[<span className="typedoc-icon typedoc-icon-class"></span> Class `InMemoryKeyStore`](https://near.github.io/near-api-js/classes/_near_js_keystores.in_memory_key_store.InMemoryKeyStore.html)
&nbsp;&nbsp;&nbsp;
[<span className="typedoc-icon typedoc-icon-class"></span> Class `KeyPair`](https://near.github.io/near-api-js/classes/_near_js_crypto.key_pair.KeyPair.html)

</TabItem>
</Tabs>

## Connecting to NEAR {#connect}

The object returned from `connect` is your entry-point for all commands in the API.
To sign a transaction you'll need a [`KeyStore`](#key-store) to create a connection.

<Tabs>
<TabItem value="testnet" label="TestNet" default>

```js
const { connect } = nearAPI;

const connectionConfig = {
  networkId: "testnet",
  keyStore: myKeyStore, // first create a key store
  nodeUrl: "https://rpc.testnet.near.org",
  walletUrl: "https://testnet.mynearwallet.com/",
  helperUrl: "https://helper.testnet.near.org",
  explorerUrl: "https://testnet.nearblocks.io",
};
const nearConnection = await connect(connectionConfig);
```

</TabItem>
<TabItem value="mainnet" label="MainNet">

```js
const { connect } = nearAPI;

const connectionConfig = {
  networkId: "mainnet",
  keyStore: myKeyStore, // first create a key store
  nodeUrl: "https://rpc.mainnet.near.org",
  walletUrl: "https://wallet.mainnet.near.org",
  helperUrl: "https://helper.mainnet.near.org",
  explorerUrl: "https://nearblocks.io",
};
const nearConnection = await connect(connectionConfig);
```

</TabItem>

<TabItem value="localnet" label="LocalNet">

```js
const { connect } = nearAPI;
const connectionConfig = {
  networkId: "local",
  nodeUrl: "http://localhost:3030",
  walletUrl: "http://localhost:4000/wallet",
};
const nearConnection = await connect(connectionConfig);
```

</TabItem>
</Tabs>

[<span className="typedoc-icon typedoc-icon-module"></span> Module `connect`](https://near.github.io/near-api-js/modules/near_api_js.connect.html)

'''
'''--- docs/4.tools/remix-ide-plugin.md ---
---
id: remix-ide-plugin
sidebar_label: Remix IDE Plugin
---

# Remix IDE Plugin Integration

This tutorial details how to deploy and run NEAR smart contract on Remix IDE. It is a no-setup tool with a GUI for developing NEAR smart contract.

![remix-plugin](/docs/assets/remix-ide-plugin/remix-ide.png?raw=true 'remix-plugin')

## Connect to Remix IDE

[WELLDONE Code](https://docs.welldonestudio.io/code)¬†is the official Remix IDE Plug-in. Please visit the¬†[Remix IDE](https://remix.ethereum.org/)¬†and follow the guide below.

Click¬†**Plugin Manager**¬†button in the left bar and search for¬†**CODE BY WELLDONE STUDIO**¬†and click the¬†Activate¬†button.

<img src={require('/docs/assets/remix-ide-plugin/plugin-manager.png').default} alt='plugin-manager' style={{width: '500px', marginRight: '10px', display: 'inline'}}/>

<img src={require('/docs/assets/remix-ide-plugin/activate-plugin.png').default} alt='active-plugin' style={{width: '300px', display: 'inline'}}/>

## Select a Chain

Click on NEAR(NVM) in the list of chains.

If you click the¬†`Documentation`¬†button, go to WELL DONE Docs, and if you find a problem or have any questions while using it, click the¬†`Make an issue`¬†button to go to the¬†[Github Repository](https://github.com/welldonestudio/welldonestudio.github.io)¬†and feel free to create an issue.

<img src={require('/docs/assets/remix-ide-plugin/select-chain.png').default} alt='select-chain' style={{width: '318px'}}/>

## Install a browser extension wallet

:::info 
Other wallets will be supported soon, and WELLDONE Wallet can be used now.
:::

After choosing a chain, click the¬†`Connect to WELLDONE`¬†button to connect to the¬†**WELLDONE Wallet.** 

If you haven't installed the WELLDONE Wallet yet, please follow the following¬†[manual](https://docs.welldonestudio.io/wallet/manual/)¬†to install and create a wallet and create an account for the selected chain. Finally, go into the Setting tab of your wallet and activate Developer Mode.

<img src={require('/docs/assets/remix-ide-plugin/wallet-developer-mode.png').default} alt='wallet-developer-mode' style={{width: '318px', marginBottom: '10px'}}/>

And you must click the¬†Refresh¬†button in the upper right corner of the plug-in to apply changes to your wallet.

## Create the Project

In NEAR, you can write smart contracts with Rust, JavaScript, and TypeScript. Because the structure of the contract is different in each language, **WELLDONE Code** provides two features to help developers new to NEAR.

### Select a Template

Create a simple example contract code written in Rust, JavaScript, and TypeScript. You can create a sample contract by selecting the template option and clicking the `Create` button. More templates may be found at [NEAR Samples](https://github.com/near-examples/).

<img src={require('/docs/assets/remix-ide-plugin/template-code-near.png').default} alt='template-code-near' style={{width: '318px'}}/>

### New Project

Automatically generate a contract structure based on the smart contract language you want to use. Select the language option, write a name for the project, and click the `Create` button to create a contract structure that is appropriate for the language.

<img src={require('/docs/assets/remix-ide-plugin/new-project-near.png').default} alt='new-project-near' style={{width: '318px'}}/>

:::info
You can create your own contract projects without using the features above. However, for the remix plugin to build and deploy the contract, it must be built within the directory `near/`. If you start a new project, the structure should look like the following.
:::

#### 1. Writing Contracts in Rust
  ```
  near
  ‚îî‚îÄ‚îÄ <YOUR_PROJECT_NAME>
      ‚îú‚îÄ‚îÄ Cargo.toml
      ‚îî‚îÄ‚îÄ src
          ‚îî‚îÄ‚îÄ lib.rs
  ```

#### 2. Writing Contracts in TypeScript
  ```
  near
  ‚îî‚îÄ‚îÄ <YOUR_PROJECT_NAME>
      ‚îú‚îÄ‚îÄ package.json
      ‚îú‚îÄ‚îÄ babel.config.json
      ‚îú‚îÄ‚îÄ tsconfig.json
      ‚îî‚îÄ‚îÄ src
        ‚îî‚îÄ‚îÄ contract.ts
  ```

#### 3. Writing Contracts in JavaScript
  ```
  near
  ‚îî‚îÄ‚îÄ <YOUR_PROJECT_NAME>
      ‚îú‚îÄ‚îÄ package.json
      ‚îú‚îÄ‚îÄ babel.config.json
      ‚îî‚îÄ‚îÄ src
        ‚îî‚îÄ‚îÄ contract.js
  ```

## Compile the Contract

:::info
Six compilation options are now available in WELLDONE Code: `Rust`, `CARGO-NEAR`, `EMBED-ABI`, `JavaScript`, and `TypeScript`.

We now only support the AMD compilation server, however, we will shortly add support for the ARM compilation server.
:::

**Step 1**: Select the project you want to compile in the **TARGET PROJECT** section.

**Step 2**: Select a compilation option and click the `Compile` button.

**Step 3**: When the compilation is complete, a wasm file is returned.

<img src={require('/docs/assets/remix-ide-plugin/project-compile.png').default} alt='project-compile' style={{width: '318px'}}/>

:::note
You can check the returned wasm file in `near/<YOUR_PROJECT_NAME>/out` directory.

If you need to revise the contract and compile again, delete the `out` directory and click the compile button.
:::

### 1. Rust Compile

Using the `cargo build` command to compile a smart contract written in Rust. Although it offers a stable compile, it is inconvenient to enter the method's parameters directly when executing the contract.

### 2. CARGO-NEAR Compile (for Rust) - `Experimental`

Compile using `cargo near` which is officially being developed by NEAR. If Compile is successful, an executable wasm binary file and a json file containing the ABI of the contract are created together. If you have deployed and imported a compiled contract using `cargo-near`, you can find out the parameter type of the method, making it easier to run the contract.

However, because this feature is still under development, the `near-sdk-rs` version must be specified at **4.1.0** or higher in the `Cargo.toml` file, and unexpected issues may occur during compilation. Please check out the NEAR's [repository](https://github.com/near/abi) for more detail.

### 3. EMBED-ABI Compile (for Rust) - `Experimental`

When using `-embed-abi` option in `cargo-near`, generates a wasm file containing ABI inside. For contracts that have deployed the wasm file compiling with this option, you can get ABI information even when importing the contract through `At Address` button. See the [cargo-near](https://github.com/near/cargo-near) repository for a detailed description of the options.

### 4. JavaScript & TypeScript Compile

Using [`near-sdk-js`](https://github.com/near/near-sdk-js) to compile a smart contract written in JavaScript or TypeScript.

:::note
If you are using JavaScript or TypeScript compile options, you must write the name of the contract file you want to compile as follows to ensure that the compilation runs without error.
- JavaScript: `contract.js`
- TypeScript: `contract.ts` 
:::

## Deploy the Contract

:::tip
The WELLDONE Wallet automatically finds and imports networks associated with your wallet address. As a result, before deploying, you should choose whether you want to send a transaction to mainnet or testnet.
:::

**Step 1**: If you have a compiled contract code, then `Deploy` button will be activated.

**Step 2**: Enter the Account ID for which you want to deployed the contract and click the `Deploy` button. If you want to add `init function`, click `Deploy Option` to add the method name and arguments.

<img src={require('/docs/assets/remix-ide-plugin/deploy-option-near.png').default} alt='deploy-option-near' style={{width: '318px'}}/>

**Step 3**: If the AccountId already has a deployed contract, confirm once more.

**Step 4**: Click the `Send Tx` button in the **WELLDONE Wallet** to sign the transaction.

<img src={require('/docs/assets/remix-ide-plugin/deploy-near.png').default} alt='deploy-near' style={{width: '500px'}}/>

**Step 5**: A transaction success log will be printed to the terminal and the contract can be executed if contract deployment is successful.

<img src={require('/docs/assets/remix-ide-plugin/deployed-contract-near.png').default} alt='deployed-contract-near' style={{width: '318px'}}/>

## Execute the Contract

:::info
There are two ways to import contracts.

1. Automatically import contracts deployed through the above process.
2. Import existing deployed contracts through `At Address` button.

:::

**Step 1**: Select the method to run.

**Step 2**: Add parameters as you needed.

**Step 3**: In the case of the `Call` function, You can specify the number of NEAR tokens to attach to a function call and the GAS LIMIT.

**Step 4**: Run the method via clicking `View` or `Call` button. If you are sending a transaction, you must sign the transaction by clicking the `Send Tx` button in the **WELLDONE Wallet**.

<img src={require('/docs/assets/remix-ide-plugin/function-call.png').default} alt='function-call' style={{width: '318px'}}/>

:::info
If you deployed the compiled contract using `CARGO-NEAR` or `EMBED-ABI` options, you can execute the contract more easily using the ABI without directly entering the parameters of the method.
:::

<img src={require('/docs/assets/remix-ide-plugin/cargo-near.png').default} alt='cargo-near' style={{width: '250px', display: 'inline-block'}}/>
<img src={require('/docs/assets/remix-ide-plugin/cargo-near1.png').default} alt='cargo-near1' style={{width: '250px', display: 'inline-block'}}/>
<img src={require('/docs/assets/remix-ide-plugin/cargo-near2.png').default} alt='cargo-near2' style={{width: '250px', display: 'inline-block'}}/>
'''
'''--- docs/4.tools/usecases.md ---
---
id: usecases
title: Interacting with a Contract
sidebar_label: üí° Interacting with a Contract
---

Here we enumerate case scenarios, and point to where the documentation is present.

---

## Integrating Contracts into a Web App
If you are developing a website (or a web-app), then you will be using `near-api-js` to communicate with the blockchain. Go to the [website](/tools/near-api-js/quick-reference) for more information about it.

---

## Command Line Interface
You can use [NEAR CLI](./cli.md) to automatize tasks from the command line such as:
- Creating sub-accounts
- Deploying contracts to them
- Calling initialization methods

---

## Querying Post Hoc Information
The [NEAR Indexer](./indexer4explorer.md) enables you to query information from a deployed contract such as:

1. Which users called a specific method?
2. How much money they attached?
3. How much GAS was used?

It is very useful for analyzing scenarios that happened in the past.

---

## Getting Real Time Information
If you want to track real time information from your contract, then you need the [Events framework](/tools/realtime).

'''
'''--- docs/4.tools/wallet-selector.md ---
# Wallet Selector

An easy-to-navigate modal that allows users to select their preferred wallet to easily interact with the NEAR protocol.

Launched in March 2022 by the NEAR Foundation, this simple modal will appear whenever users are given the option to ‚ÄúConnect Wallet‚Äù to the NEAR blockchain.

![Preview](/docs/assets/wallet-selector-preview.png)
*Initial screen of [Wallet Selector](https://near.github.io/wallet-selector/)*

---

## Framework agnostic

[React](https://reactjs.org/) / [Next.js](https://nextjs.org/) and [Angular](https://angular.io/) variations of the [Guest Book](https://github.com/near-examples/guest-book-examples/) dApp can be found in the [`examples`](https://github.com/near/wallet-selector/tree/main/examples) directory. Developers can use these to gain a concrete understanding of how to integrate NEAR Wallet Selector into their own dApp.

### Unlocking the wallet ecosystem

Wallet Selector makes it easy for users to interact with dApps by providing an abstraction over various wallets and wallet types within the NEAR ecosystem.

:::info

You can check the current list of supported wallets in the [README.md](https://github.com/near/wallet-selector/blob/main/README.md) file of near/wallet-selector repository.

:::

Thanks to NEAR‚Äôs open and inclusive approach, other wallet developers can contribute to the NEAR ecosystem by following the documentation and instructions on the¬†[NEAR Github repository](https://github.com/near/wallet-selector) on how to add a new wallets to the Wallet Selector.

:::tip

To learn more on how to include new wallets for Wallet Selector you can check the listing criteria for third party wallets on this [link](https://github.com/near/wallet-selector/blob/main/CONTRIBUTING.md#listing-criteria-for-third-party-wallet-on-wallet-selector).

:::

## Install

The easiest way to use NEAR Wallet Selector is to install the core package from the NPM registry, some packages may require near-api-js v0.44.2 or above check them at packages.

```bash
npm install near-api-js@^0.44.2
```

```bash
npm install @near-wallet-selector/core
```

Next, you'll need to install the wallets you want to support:

```bash
npm install \
  @near-wallet-selector/near-wallet \
  @near-wallet-selector/my-near-wallet \
  @near-wallet-selector/sender \
  @near-wallet-selector/nearfi \
  @near-wallet-selector/here-wallet \
  @near-wallet-selector/math-wallet \
  @near-wallet-selector/nightly \
  @near-wallet-selector/meteor-wallet \
  @near-wallet-selector/ledger \
  @near-wallet-selector/wallet-connect \
  @near-wallet-selector/nightly-connect \
  @near-wallet-selector/default-wallets \
  @near-wallet-selector/coin98-wallet
```

## Setup Wallet Selector

Optionally, you can install our [`modal-ui`](https://www.npmjs.com/package/@near-wallet-selector/modal-ui) or [`modal-ui-js`](https://www.npmjs.com/package/@near-wallet-selector/modal-ui-js) package for a pre-built interface that wraps the `core` API and presents the supported wallets:

```bash
npm install @near-wallet-selector/modal-ui
```

Then use it in your dApp:

```ts
import { setupWalletSelector } from "@near-wallet-selector/core";
import { setupModal } from "@near-wallet-selector/modal-ui";
import { setupNearWallet } from "@near-wallet-selector/near-wallet";

const selector = await setupWalletSelector({
  network: "testnet",
  modules: [setupNearWallet()],
});

const modal = setupModal(selector, {
  contractId: "test.testnet",
});

modal.show();
```

:::info Required CSS

To integrate the Wallet Selector, you also need to include the required CSS:

```
import "@near-wallet-selector/modal-ui/styles.css"
```

:::

## API Reference

The API reference of the selector can be found [`here`](https://github.com/near/wallet-selector/blob/main/packages/core/docs/api/selector.md)

## Wallet API

### Sign in

```ts
// NEAR Wallet.
(async () => {
  const wallet = await selector.wallet("my-near-wallet");
  const accounts = await wallet.signIn({ contractId: "test.testnet" });
})();
```

### Sign out

```ts
(async () => {
  const wallet = await selector.wallet("my-near-wallet");
  await wallet.signOut();
})();
```

### Get accounts

```ts
(async () => {
  const wallet = await selector.wallet("my-near-wallet");
  const accounts = await wallet.getAccounts();
  console.log(accounts); // [{ accountId: "test.testnet" }]
})();
```

### Verify Owner

```ts
// MyNearWallet
(async () => {
  const wallet = await selector.wallet("my-near-wallet");
  await wallet.verifyOwner({
    message: "Test message",
  });
})();
```

### Sign and send transaction

```ts
(async () => {
  const wallet = await selector.wallet("my-near-wallet");
  await wallet.signAndSendTransaction({
    actions: [
      {
        type: "FunctionCall",
        params: {
          methodName: "addMessage",
          args: { text: "Hello World!" },
          gas: "30000000000000",
          deposit: "10000000000000000000000",
        },
      },
    ],
  });
})();
```

### Sign and send transactions

```ts
(async () => {
  const wallet = await selector.wallet("my-near-wallet");
  await wallet.signAndSendTransactions({
    transactions: [
      {
        receiverId: "guest-book.testnet",
        actions: [
          {
            type: "FunctionCall",
            params: {
              methodName: "addMessage",
              args: { text: "Hello World!" },
              gas: "30000000000000",
              deposit: "10000000000000000000000",
            },
          },
        ],
      },
    ],
  });
})();
```

'''
'''--- docs/4.tools/welcome.md ---
---
id: welcome
title: Tools
sidebar_label: Home
---

Welcome! The NEAR ecosystem has a complete set of tools for you to make the most out of the NEAR network.
In this page you will find:

1. [Wallets](https://www.mynearwallet.com/) to handle your assets.
2. [Explorers](explorer.md) to quickly obtain information from the blockchain.
3. Websites to simplify creating and participating on governance projects.
4. Tools to query [past information](indexer4explorer.md) from the blockchain as well as [real time events](events.md).
5. Developer tools to deploy and interact with contracts such as the [NEAR CLI](cli.md) and [NEAR JavaScript API](/tools/near-api-js/quick-reference).

'''
'''--- docs/5.api/rpc/access-keys.md ---
---
id: access-keys
title: Access Keys
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The RPC API enables you to retrieve information about an account's access keys.

---

## View access key {#view-access-key}

Returns information about a single access key for given account.

If `permission` of the key is `FunctionCall`, it will return more details such as the `allowance`, `receiver_id`, and `method_names`.

- method: `query`
- params:
  - `request_type`: `view_access_key`
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)
  - `account_id`: _`"example.testnet"`_
  - `public_key`: _`"example.testnet's public key"`_

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "query",
  "params": {
    "request_type": "view_access_key",
    "finality": "final",
    "account_id": "client.chainlink.testnet",
    "public_key": "ed25519:H9k5eiU4xXS3M4z8HzKJSLaZdqGdGwBG49o7orNC4eZW"
  }
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.query({
  request_type: "view_access_key",
  finality: "final",
  account_id: "client.chainlink.testnet",
  public_key: "ed25519:H9k5eiU4xXS3M4z8HzKJSLaZdqGdGwBG49o7orNC4eZW",
});
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
  params:='{
    "request_type": "view_access_key",
    "finality": "final",
    "account_id": "client.chainlink.testnet",
    "public_key": "ed25519:H9k5eiU4xXS3M4z8HzKJSLaZdqGdGwBG49o7orNC4eZW"
  }'
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "nonce": 85,
    "permission": {
      "FunctionCall": {
        "allowance": "18501534631167209000000000",
        "receiver_id": "client.chainlink.testnet",
        "method_names": ["get_token_price"]
      }
    },
    "block_height": 19884918,
    "block_hash": "GGJQ8yjmo7aEoj8ZpAhGehnq9BSWFx4xswHYzDwwAP2n"
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What Could Go Wrong?

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `view_access_key` request type:

<table className="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="6">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)</td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>If the block had been produced more than 5 epochs ago, try to send your request to <a href="https://near-nodes.io/intro/node-types#archival-node">an archival node</a></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INVALID_ACCOUNT</td>
      <td>The requested <code>account_id</code> is invalid</td>
      <td>
        <ul>
          <li>Provide a valid <code>account_id</code></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_ACCOUNT</td>
      <td>The requested <code>account_id</code> has not been found while viewing since the account has not been created or has been already deleted</td>
      <td>
        <ul>
          <li>Check the <code>account_id</code></li>
          <li>Specify a different block or retry if you request the latest state</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_ACCESS_KEY</td>
      <td>The requested <code>public_key</code> has not been found while viewing since the public key has not been created or has been already deleted</td>
      <td>
        <ul>
          <li>Check the <code>public_key</code></li>
          <li>Specify a different block or retry if you request the latest state</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNAVAILABLE_SHARD</td>
      <td>The node was unable to found the requested data because it does not track the shard where data is present</td>
      <td>
        <ul>
          <li>Send a request to a different node which might track the shard</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NO_SYNCED_BLOCKS</td>
      <td>The node is still syncing and the requested block is not in the database yet</td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

## View access key list {#view-access-key-list}

You can query <strong>all</strong> access keys for a given account.

- method: `query`
- params:
  - `request_type`: `view_access_key_list`
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)
  - `account_id`: _`"example.testnet"`_

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "query",
  "params": {
    "request_type": "view_access_key_list",
    "finality": "final",
    "account_id": "example.testnet"
  }
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.query({
  request_type: "view_access_key_list",
  finality: "final",
  account_id: "example.testnet",
});
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
  params:='{
    "request_type": "view_access_key_list",
    "finality": "final",
    "account_id": "example.testnet"
  }'
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "keys": [
      {
        "public_key": "ed25519:2j6qujbkPFuTstQLLTxKZUw63D5Wu3SG79Gop5JQrNJY",
        "access_key": {
          "nonce": 17,
          "permission": {
            "FunctionCall": {
              "allowance": "9999203942481156415000",
              "receiver_id": "place.meta",
              "method_names": []
            }
          }
        }
      },
      {
        "public_key": "ed25519:46etzhzZHN4NSQ8JEQtbHCX7sT8WByS3vmSEb3fbmSgf",
        "access_key": {
          "nonce": 2,
          "permission": {
            "FunctionCall": {
              "allowance": "9999930655034196535000",
              "receiver_id": "dev-1596616186817-8588944",
              "method_names": []
            }
          }
        }
      },
      {
        "public_key": "ed25519:4F9TwuSqWwvoyu7JVZDsupPhC7oYbYNsisBV2yQvyXFn",
        "access_key": {
          "nonce": 0,
          "permission": "FullAccess"
        }
      },
      {
        "public_key": "ed25519:4bZqp6nm1btr92UfKbyADDzJ4oPK9JetHXqEYqbYZmkD",
        "access_key": {
          "nonce": 2,
          "permission": "FullAccess"
        }
      },
      {
        "public_key": "ed25519:6ZPzX7hS37jiU9dRxbV1Waf8HSyKKFypJbrnZXzNhqjs",
        "access_key": {
          "nonce": 2,
          "permission": {
            "FunctionCall": {
              "allowance": "9999922083697042955000",
              "receiver_id": "example.testnet",
              "method_names": []
            }
          }
        }
      },
      {
        "public_key": "ed25519:81RKfuo7mBbsaviTmBsq18t6Eq4YLnSi3ye2CBLcKFUX",
        "access_key": {
          "nonce": 8,
          "permission": "FullAccess"
        }
      },
      {
        "public_key": "ed25519:B4W1oAYTcG8GxwKev8jQtsYWkGwGdqP24W7eZ6Fmpyzc",
        "access_key": {
          "nonce": 0,
          "permission": {
            "FunctionCall": {
              "allowance": "10000000000000000000000",
              "receiver_id": "dev-1594144238344",
              "method_names": []
            }
          }
        }
      },
      {
        "public_key": "ed25519:BA3AZbACoEzAsxKeToFd36AVpPXFSNhSMW2R6UYeGRwM",
        "access_key": {
          "nonce": 0,
          "permission": {
            "FunctionCall": {
              "allowance": "10000000000000000000000",
              "receiver_id": "new-corgis",
              "method_names": []
            }
          }
        }
      },
      {
        "public_key": "ed25519:BRyHUGAJjRKVTc9ZqXTTSJnFmSca8WLj8TuVe1wXK3LZ",
        "access_key": {
          "nonce": 17,
          "permission": "FullAccess"
        }
      },
      {
        "public_key": "ed25519:DjytaZ1HZ5ZFmH3YeJeMCiC886K1XPYeGsbz2E1AZj2J",
        "access_key": {
          "nonce": 31,
          "permission": "FullAccess"
        }
      },
      {
        "public_key": "ed25519:DqJn5UCq6vdNAvfhnbpdAeuui9a6Hv9DKYDxeRACPUDP",
        "access_key": {
          "nonce": 0,
          "permission": "FullAccess"
        }
      },
      {
        "public_key": "ed25519:FFxG8x6cDDyiErFtRsdw4dBNtCmCtap4tMTjuq3umvSq",
        "access_key": {
          "nonce": 0,
          "permission": "FullAccess"
        }
      }
    ],
    "block_height": 17798231,
    "block_hash": "Gm7YSdx22wPuciW1jTTeRGP9mFqmon69ErFQvgcFyEEB"
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What Could Go Wrong?

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `view_access_key_list` request type:

<table className="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="5">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)</td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>If the block had been produced more than 5 epochs ago, try to send your request to <a href="https://near-nodes.io/intro/node-types#archival-node">an archival node</a></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INVALID_ACCOUNT</td>
      <td>The requested <code>account_id</code> is invalid</td>
      <td>
        <ul>
          <li>Provide a valid <code>account_id</code></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_ACCOUNT</td>
      <td>The requested <code>account_id</code> has not been found while viewing since the account has not been created or has been already deleted</td>
      <td>
        <ul>
          <li>Check the <code>account_id</code></li>
          <li>Specify a different block or retry if you request the latest state</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNAVAILABLE_SHARD</td>
      <td>The node was unable to find the requested data because it does not track the shard where data is present</td>
      <td>
        <ul>
          <li>Send a request to a different node which might track the shard</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NO_SYNCED_BLOCKS</td>
      <td>The node is still syncing and the requested block is not in the database yet</td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

## View access key changes (single) {#view-access-key-changes-single}

Returns individual access key changes in a specific block. You can query multiple keys by passing an array of objects containing the `account_id` and `public_key`.

- method: `EXPERIMENTAL_changes`
- params:
  - `changes_type`: `single_access_key_changes`
  - `keys`: `[{ account_id, public_key }]`
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_changes",
  "params": {
    "changes_type": "single_access_key_changes",
    "keys": [
      {
        "account_id": "example-acct.testnet",
        "public_key": "ed25519:25KEc7t7MQohAJ4EDThd2vkksKkwangnuJFzcoiXj9oM"
      }
    ],
    "finality": "final"
  }
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.experimental_changes({
  changes_type: "single_access_key_changes",
  keys: [
    {
      account_id: "example-acct.testnet",
      public_key: "ed25519:25KEc7t7MQohAJ4EDThd2vkksKkwangnuJFzcoiXj9oM",
    },
  ],
  finality: "final",
});
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_changes \
  params:='{
    "changes_type": "single_access_key_changes",
    "keys": [
      {
        "account_id": "example-acct.testnet",
        "public_key": "ed25519:25KEc7t7MQohAJ4EDThd2vkksKkwangnuJFzcoiXj9oM"
      }
    ],
    "finality": "final"
  }'
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "4kvqE1PsA6ic1LG7S5SqymSEhvjqGqumKjAxnVdNN3ZH",
    "changes": [
      {
        "cause": {
          "type": "transaction_processing",
          "tx_hash": "HshPyqddLxsganFxHHeH9LtkGekXDCuAt6axVgJLboXV"
        },
        "type": "access_key_update",
        "change": {
          "account_id": "example-acct.testnet",
          "public_key": "ed25519:25KEc7t7MQohAJ4EDThd2vkksKkwangnuJFzcoiXj9oM",
          "access_key": {
            "nonce": 1,
            "permission": "FullAccess"
          }
        }
      }
    ]
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What Could Go Wrong?{#what-could-go-wrong-2}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `EXPERIMENTAL_changes_in_block` method:

<table className="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)</td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>If the block had been produced more than 5 epochs ago, try to send your request to <a href="https://near-nodes.io/intro/node-types#archival-node">an archival node</a></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NOT_SYNCED_YET</td>
      <td>The node is still syncing and the requested block is not in the database yet</td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

## View access key changes (all) {#view-access-key-changes-all}

Returns changes to <strong>all</strong> access keys of a specific block. Multiple accounts can be quereied by passing an array of `account_ids`.

- method: `EXPERIMENTAL_changes`
- params:
  - `changes_type`: `all_access_key_changes`
  - `account_ids`: `[ "example.testnet", "example2.testnet"]`
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_changes",
  "params": {
    "changes_type": "all_access_key_changes",
    "account_ids": ["example-acct.testnet"],
    "block_id": "4kvqE1PsA6ic1LG7S5SqymSEhvjqGqumKjAxnVdNN3ZH"
  }
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.experimental_changes({
  changes_type: "all_access_key_changes",
  account_ids: "example-acct.testnet",
  finality: "final",
});
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_changes \
  params:='{
    "changes_type": "all_access_key_changes",
    "account_ids": ["example-acct.testnet"],
    "block_id": "4kvqE1PsA6ic1LG7S5SqymSEhvjqGqumKjAxnVdNN3ZH"
  }'
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "4kvqE1PsA6ic1LG7S5SqymSEhvjqGqumKjAxnVdNN3ZH",
    "changes": [
      {
        "cause": {
          "type": "transaction_processing",
          "tx_hash": "HshPyqddLxsganFxHHeH9LtkGekXDCuAt6axVgJLboXV"
        },
        "type": "access_key_update",
        "change": {
          "account_id": "example-acct.testnet",
          "public_key": "ed25519:25KEc7t7MQohAJ4EDThd2vkksKkwangnuJFzcoiXj9oM",
          "access_key": {
            "nonce": 1,
            "permission": "FullAccess"
          }
        }
      },
      {
        "cause": {
          "type": "receipt_processing",
          "receipt_hash": "CetXstu7bdqyUyweRqpY9op5U1Kqzd8pq8T1kqfcgBv2"
        },
        "type": "access_key_update",
        "change": {
          "account_id": "example-acct.testnet",
          "public_key": "ed25519:96pj2aVJH9njmAxakjvUMnNvdB3YUeSAMjbz9aRNU6XY",
          "access_key": {
            "nonce": 0,
            "permission": "FullAccess"
          }
        }
      }
    ]
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What Could Go Wrong?{#what-could-go-wrong-3}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `EXPERIMENTAL_changes` method:

<table className="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)</td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>If the block had been produced more than 5 epochs ago, try to send your request to <a href="https://near-nodes.io/intro/node-types#archival-node">an archival node</a></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NOT_SYNCED_YET</td>
      <td>The node is still syncing and the requested block is not in the database yet</td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

'''
'''--- docs/5.api/rpc/block-chunk.md ---
---
id: block-chunk
title: Block / Chunk
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The RPC API enables you to query the network and get details about specific blocks or chunks.

---

## Block details {#block-details}

> Queries network and returns block for given height or hash. You can also use `finality` param to return latest block details.

**Note**: You may choose to search by a specific block _or_ finality, you can not choose both.

- method: `block`
- params:
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)

`finality` example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "block",
  "params": {
    "finality": "final"
  }
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.block({
  finality: "final",
});
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=block \
  params:='{
    "finality": "final"
  }'
```

</TabItem>
</Tabs>

`[block_id]`

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "block",
  "params": {
    "block_id": 17821130
  }
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.block({blockId: 17821130});
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=block \
  params:='{
    "block_id": 17821130
  }'
```

</TabItem>
</Tabs>

`[block_hash]`

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "block",
  "params": {
    "block_id": "7nsuuitwS7xcdGnD9JgrE22cRB2vf2VS4yh1N9S71F4d"
  }
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.block(
  {blockId: "7nsuuitwS7xcdGnD9JgrE22cRB2vf2VS4yh1N9S71F4d"}
);
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=block \
  params:='{
    "block_id": "7nsuuitwS7xcdGnD9JgrE22cRB2vf2VS4yh1N9S71F4d"
  }'
```

</TabItem>
</Tabs>

<details>
<summary>Example response:</summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "author": "bitcat.pool.f863973.m0",
    "header": {
      "height": 17821130,
      "epoch_id": "7Wr3GFJkYeCxjVGz3gDaxvAMUzXuzG8MjFXTFoAXB6ZZ",
      "next_epoch_id": "A5AdnxEn7mfHieQ5fRxx9AagCkHNJz6wr61ppEXiWvvh",
      "hash": "CLo31YCUhzz8ZPtS5vXLFskyZgHV5qWgXinBQHgu9Pyd",
      "prev_hash": "2yUTTubrv1gJhTUVnHXh66JG3qxStBqySoN6wzRzgdVD",
      "prev_state_root": "5rSz37fySS8XkVgEy3FAZwUncX4X1thcSpuvCgA6xmec",
      "chunk_receipts_root": "9ETNjrt6MkwTgSVMMbpukfxRshSD1avBUUa4R4NuqwHv",
      "chunk_headers_root": "HMpEoBhPvThWZvppLwrXQSSfumVdaDW7WfZoCAPtjPfo",
      "chunk_tx_root": "7tkzFg8RHBmMw1ncRJZCCZAizgq4rwCftTKYLce8RU8t",
      "outcome_root": "7tkzFg8RHBmMw1ncRJZCCZAizgq4rwCftTKYLce8RU8t",
      "chunks_included": 1,
      "challenges_root": "11111111111111111111111111111111",
      "timestamp": 1601280114229875635,
      "timestamp_nanosec": "1601280114229875635",
      "random_value": "ACdUSF3nehbMTwT7qjUB6Mm4Ynck5TVAWbNH3DR1cjQ7",
      "validator_proposals": [],
      "chunk_mask": [true],
      "gas_price": "100000000",
      "rent_paid": "0",
      "validator_reward": "0",
      "total_supply": "1042339182040791154864822502764857",
      "challenges_result": [],
      "last_final_block": "AaxTqjYND5WAKbV2UZaFed6DH1DShN9fEemtnpTsv3eR",
      "last_ds_final_block": "2yUTTubrv1gJhTUVnHXh66JG3qxStBqySoN6wzRzgdVD",
      "next_bp_hash": "3ZNEoFYh2CQeJ9dc1pLBeUd1HWG8657j2c1v72ENE45Q",
      "block_merkle_root": "H3912Nkw6rtamfjsjmafe2uV2p1XmUKDou5ywgxb1gJr",
      "approvals": [
        "ed25519:4hNtc9vLhn2PQhktWtLKJV9g8SBfpm6NBT1w4syNFqoKE7ZMts2WwKA9x1ZUSBGVKYCuDGEqogLvwCF25G7e1UR3",
        "ed25519:2UNmbTqysMMevVPqJEKSq57hkcxVFcAMdGq7CFhpW65yBKFxYwpoziiWsAtARusLn9Sy1eXM7DkGTXwAqFiSooS6",
        "ed25519:4sumGoW9dnQCsJRpzkd4FQ5NSJypGQRCppWp7eQ9tpsEcJXjHZN8GVTCyeEk19WmbbMEJ5KBNypryyHzaH2gBxd4",
        "ed25519:3fP2dri6GjYkmHgEqQWWP9GcoQEgakbaUtfr3391tXtYBgxmiJUEymRe54m7D8bQrSJ3LhKD8gTFT7qqdemRnizR",
        "ed25519:3mwdqSWNm6RiuZAoZhD6pqsirC2cL48nEZAGoKixpqbrsBpAzqV3W2paH4KtQQ4JPLvk5pnzojaint2kNBCcUyq1",
        "ed25519:D4hMnxqLyQW4Wo29MRNMej887GH46yJXDKNN4es8UDSi9shJ9Y4FcGqkxdV4AZhn1yUjwN5LwfgAgY6fyczk5L3",
        null,
        "ed25519:4WCVm4dn88VJxTkUgcvdS7vs34diBqtQY4XWMRctSN1NpbgdkwwVyxg7d2SbGC22SuED7w4nrToMhcpJXrkhkDmF",
        "ed25519:JqtC7TFP7U14s7YhRKQEqwbc2RUxoctq75mrBdX91f7DuCWsPpe6ZTTnfHPmuJPjTzFHVZTsaQJWzwfSrrgNpnc",
        "ed25519:ngGUpWc2SyHmMCkWGTNNNfvZAJQ5z7P92JCmDqB7JW3j8fNH6LobvFFXb2zVdssibJKgnjwBj8CRe6qiZtuYQZM",
        "ed25519:5kzW6RbjukyJZiw9NTzTPPsQdoqN6EecafjVFEoWmTxQ4uSv1uSXhQYcHK2eq4m84oMmPABQDz2mm73Qx8mDdCQX",
        "ed25519:5wHnuuxwJJiZ4bXNq5cESnr4YovFU2yaUcuHRDUw3DnLoxkqc15CsegoyUSQKEwtCZ4yETv8Z9QcD6Wr9zHV4AUk",
        "ed25519:3F9XzWBxto31e8RAcBShAJBzJPgSJQsWbPXR38AfQnJn6AiveGz3JjebQm9Ye63BrnNA57QrPshwknxpzSrcNEZW",
        "ed25519:2g5s4SKsHt9PMdekkDqVtwwtz14v4edhqdBX1MYA8tB6nDpj3vDCDCTy9pEU8dX31PoQe5ygnf88aTZukMBMK1Yt",
        "ed25519:3Xz4jqhdyS3qs6xTmWdgjwt5gJraU5czMA89hPhmvbAN4aA7SUKL1HkevpmutRQqqxe7c7uCFeGiDHvDcxhhmD8W",
        null,
        "ed25519:55xs3vwPEys39egf9Z8SNyn1JsHPRMgj9HCX1GE7GJsVTcAuutQUCo91E12ZdXkuToYRXb9KzoT8n9XQRCNuLpwY",
        null,
        "ed25519:28JrFw7KnhnQPN89qZnnw17KDBjS6CDN7zB1hTg7KGg8qQPoCzakz9DNnaSnx39ji7e2fQSpZt4cNJaD7K7Yu7yo",
        "ed25519:41hAr5qhtvUYpdD2NK9qqTVnpG325ZoAiwrcmk1MJH7fdpxm7oSKXvXZqh7bTmPhv61hH2RpHnhcGuN4QqLzK2zt",
        "ed25519:4QacMsQ5FJgvecAYDFq8QBh19BBjh4qU8oeD5bV7p6Zhhu3e6r2iSHTvDBU2Q62RZAaWQQkkEwDUC9rsXdkGVhAt",
        "ed25519:27smtCZ3WobEvBuD5DggY6kkGxjB9qRVY6kPixgwqvBT1eKbRVoV8cLj1z51S8RTcp7YzAr1vhHJUHgksatR9Udz",
        "ed25519:4wspCWoAbhYxb3th2eX6ZXvKep1Fsco7mFP5zBodXBR8Wr344ANXSUCri3gUgNCCSoQ2CKSdqDEsvE6Y2jQ9hmbB",
        "ed25519:46XpYf9ZB9gjDfdnJLHqqhYJpQCuvCgB9tzKWS88GANMCb2j9BM3KXyjaEzynSsaPK8VrKFXQuTsTzgQSeo9cWGW",
        null,
        "ed25519:Y5ehsrhEpTRGjG6fHJHsEXj2NYPGMmKguiJHXP7TqsCWHBvNzaJbieR7UDp78hJ1ib7C18J5MB2kCzTXBCF9c3b",
        "ed25519:3P9363Dc8Kqvgjt3TsNRncUrncCHid7aSRnuySjF4JYmQbApkAxomyMu8xm9Rgo3mj9rqXb16PM7Xjn7hKP6TyVr",
        null,
        null,
        "ed25519:65ATjGsigZ3vMp7sGcp1c4ptxoqhHPkBeAaZ5GWJguVDLyrRLPJrtXhLGjH9DpXd7CZswjyMYq5aRtorLnmmJ7GW",
        null,
        "ed25519:5SvqSViXbtsLoFMdtCufyyDgZnrEK7LheFi38X5M2ic17gfV5cz37r85RyixjUv98MbAmgVdmkxVFDGfSbeoHW7X",
        null,
        null,
        "ed25519:2n3fQiBEiDKkB84biXWyQmvnupKX7B8faugY37jVi8hVXuWLggJmaEjqub511RCYwFnwW1RBxYpuJQ455KaniCd4",
        "ed25519:2K9xKFLJ2fW74tddXtghFGFurKWomAqaJmkKYVZKHQT6zHe5wNSYT3vzMotLQcez5JD1Ta57N9zQ4H1RysB2s5DZ",
        null,
        null,
        "ed25519:3qeCRtcLAqLtQ2YSQLcHDa26ykKX1BvAhP9jshLLYapxSEGGgZJY8sU72p9E78AkXwHP3X2Eq74jvts7gTRzNgMg",
        null,
        "ed25519:2czSQCF8wBDomEeSdDRH4gFoyJrp2ppZqR6JDaDGoYpaFkpWxZf2oGDkKfQLZMbfvU6LXkQjJssVHcLCJRMzG8co"
      ],
      "signature": "ed25519:58sdWd6kxzhQdCGvHzxqvdtDLJzqspe74f3gytnqdxDLHf4eesXi7B3nYq2YaosCHZJYmcR4HPHKSoFm3WE4MbxT",
      "latest_protocol_version": 35
    },
    "chunks": [
      {
        "chunk_hash": "EBM2qg5cGr47EjMPtH88uvmXHDHqmWPzKaQadbWhdw22",
        "prev_block_hash": "2yUTTubrv1gJhTUVnHXh66JG3qxStBqySoN6wzRzgdVD",
        "outcome_root": "11111111111111111111111111111111",
        "prev_state_root": "HqWDq3f5HJuWnsTfwZS6jdAUqDjGFSTvjhb846vV27dx",
        "encoded_merkle_root": "9zYue7drR1rhfzEEoc4WUXzaYRnRNihvRoGt1BgK7Lkk",
        "encoded_length": 8,
        "height_created": 17821130,
        "height_included": 17821130,
        "shard_id": 0,
        "gas_used": 0,
        "gas_limit": 1000000000000000,
        "rent_paid": "0",
        "validator_reward": "0",
        "balance_burnt": "0",
        "outgoing_receipts_root": "H4Rd6SGeEBTbxkitsCdzfu9xL9HtZ2eHoPCQXUeZ6bW4",
        "tx_root": "11111111111111111111111111111111",
        "validator_proposals": [],
        "signature": "ed25519:4iPgpYAcPztAvnRHjfpegN37Rd8dTJKCjSd1gKAPLDaLcHUySJHjexMSSfC5iJVy28vqF9VB4psz13x2nt92cbR7"
      }
    ]
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What Could Go Wrong?? {#what-could-go-wrong}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `block` method:

<table className="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)</td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>If the block had been produced more than 5 epochs ago, try to send your request to <a href="https://near-nodes.io/intro/node-types#archival-node">an archival node</a></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NOT_SYNCED_YET</td>
      <td>The node is still syncing and the requested block is not in the database yet</td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

## Changes in Block {#changes-in-block}

> Returns changes in block for given block height or hash. You can also use `finality` param to return latest block details.

**Note**: You may choose to search by a specific block _or_ finality, you can not choose both.

- method: `EXPERIMENTAL_changes_in_block`
- params:
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)

`finality`

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_changes_in_block",
  "params": {
    "finality": "final"
  }
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.experimental_changes_in_block({
  finality: "final",
});
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_changes_in_block \
  params:='{
    "finality": "final"
  }'
```

</TabItem>
</Tabs>

`[block_id]`

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_changes_in_block",
  "params": {
    "block_id": 17821135
  }
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.experimental_changes_in_block(
  17821135
);
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_changes_in_block \
  params:='{
    "block_id": 17821135
  }'
```

</TabItem>
</Tabs>

`block_hash`

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_changes_in_block",
  "params": {
    "block_id": "81k9ked5s34zh13EjJt26mxw5npa485SY4UNoPi6yYLo"
  }
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.experimental_changes_in_block(
  "81k9ked5s34zh13EjJt26mxw5npa485SY4UNoPi6yYLo"
);
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_changes_in_block \
  params:='{
    "block_id": "81k9ked5s34zh13EjJt26mxw5npa485SY4UNoPi6yYLo"
  }'
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "81k9ked5s34zh13EjJt26mxw5npa485SY4UNoPi6yYLo",
    "changes": [
      {
        "type": "account_touched",
        "account_id": "lee.testnet"
      },
      {
        "type": "contract_code_touched",
        "account_id": "lee.testnet"
      },
      {
        "type": "access_key_touched",
        "account_id": "lee.testnet"
      }
    ]
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What Could Go Wrong?? {#what-could-go-wrong-1}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `EXPERIMENTAL_changes_in_block` method:

<table className="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)</td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>If the block had been produced more than 5 epochs ago, try to send your request to <a href="https://near-nodes.io/intro/node-types#archival-node">an archival node</a></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NOT_SYNCED_YET</td>
      <td>The node is still syncing and the requested block is not in the database yet</td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

## Chunk Details {#chunk-details}

> Returns details of a specific chunk. You can run a [block details](/api/rpc/setup#block-details) query to get a valid chunk hash.

- method: `chunk`
- params:
  - `chunk_id` _OR_ [`block_id`, `shard_id`](/api/rpc/setup#using-block_id-param)

`chunk_id` example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "chunk",
  "params": {"chunk_id": "EBM2qg5cGr47EjMPtH88uvmXHDHqmWPzKaQadbWhdw22"}
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.chunk({
  chunk_id: "EBM2qg5cGr47EjMPtH88uvmXHDHqmWPzKaQadbWhdw22"
});
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 method=chunk params:='{"chunk_id": "EBM2qg5cGr47EjMPtH88uvmXHDHqmWPzKaQadbWhdw22"}' id=dontcare
```

</TabItem>
</Tabs>

`block_id`, `shard_id` example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "chunk",
  "params": {"block_id": 58934027, "shard_id": 0}
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.chunk({
  block_id: 58934027, shard_id: 0
});
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 method=chunk params:='{"block_id": 58934027, "shard_id": 0}' id=dontcare
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "author": "bitcat.pool.f863973.m0",
    "header": {
      "chunk_hash": "EBM2qg5cGr47EjMPtH88uvmXHDHqmWPzKaQadbWhdw22",
      "prev_block_hash": "2yUTTubrv1gJhTUVnHXh66JG3qxStBqySoN6wzRzgdVD",
      "outcome_root": "11111111111111111111111111111111",
      "prev_state_root": "HqWDq3f5HJuWnsTfwZS6jdAUqDjGFSTvjhb846vV27dx",
      "encoded_merkle_root": "9zYue7drR1rhfzEEoc4WUXzaYRnRNihvRoGt1BgK7Lkk",
      "encoded_length": 8,
      "height_created": 17821130,
      "height_included": 17821130,
      "shard_id": 0,
      "gas_used": 0,
      "gas_limit": 1000000000000000,
      "rent_paid": "0",
      "validator_reward": "0",
      "balance_burnt": "0",
      "outgoing_receipts_root": "H4Rd6SGeEBTbxkitsCdzfu9xL9HtZ2eHoPCQXUeZ6bW4",
      "tx_root": "11111111111111111111111111111111",
      "validator_proposals": [],
      "signature": "ed25519:4iPgpYAcPztAvnRHjfpegN37Rd8dTJKCjSd1gKAPLDaLcHUySJHjexMSSfC5iJVy28vqF9VB4psz13x2nt92cbR7"
    },
    "transactions": [],
    "receipts": []
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What Could Go Wrong?? {#what-could-go-wrong-2}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `chunk` method:

<table className="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="4">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)</td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>If the block had been produced more than 5 epochs ago, try to send your request to <a href="https://near-nodes.io/intro/node-types#archival-node">an archival node</a></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_CHUNK</td>
      <td>The requested chunk can't be found in a database</td>
      <td>
        <ul>
          <li>Check that the requested chunk is legit</li>
          <li>If the chunk had been produced more than 5 epochs ago, try to send your request to an archival node</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INVALID_SHARD_ID</td>
      <td>Provided <code>shard_id</code> does not exist</td>
      <td>
        <ul>
          <li>Provide <code>shard_id</code> for an existing shard</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NOT_SYNCED_YET</td>
      <td>The node is still syncing and the requested chunk is not in the database yet</td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

'''
'''--- docs/5.api/rpc/contracts.md ---
---
id: contracts
title: Accounts / Contracts
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The RPC API enables you to view details about accounts and contracts as well as perform contract calls.

---

## View account {#view-account}

> Returns basic account information.

- method: `query`
- params:
  - `request_type`: `view_account`
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)
  - `account_id`: _`"example.testnet"`_

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "query",
  "params": {
    "request_type": "view_account",
    "finality": "final",
    "account_id": "nearkat.testnet"
  }
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.query({
  request_type: "view_account",
  finality: "final",
  account_id: "nearkat.testnet",
});
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
  params:='{
    "request_type": "view_account",
    "finality": "final",
    "account_id": "nearkat.testnet"
  }'
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "amount": "399992611103597728750000000",
    "locked": "0",
    "code_hash": "11111111111111111111111111111111",
    "storage_usage": 642,
    "storage_paid_at": 0,
    "block_height": 17795474,
    "block_hash": "9MjpcnwW3TSdzGweNfPbkx8M74q1XzUcT1PAN8G5bNDz"
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What Could Go Wrong? {#what-could-go-wrong}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `view_account` request type:

<table className="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="5">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)</td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>If the block had been produced more than 5 epochs ago, try to send your request to <a href="https://near-nodes.io/intro/node-types#archival-node">an archival node</a></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INVALID_ACCOUNT</td>
      <td>The requested <code>account_id</code> is invalid</td>
      <td>
        <ul>
          <li>Provide a valid <code>account_id</code></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_ACCOUNT</td>
      <td>The requested <code>account_id</code> has not been found while viewing since the account has not been created or has been already deleted</td>
      <td>
        <ul>
          <li>Check the <code>account_id</code></li>
          <li>Specify a different block or retry if you request the latest state</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNAVAILABLE_SHARD</td>
      <td>The node was unable to find the requested data because it does not track the shard where data is present</td>
      <td>
        <ul>
          <li>Send a request to a different node which might track the shard</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NO_SYNCED_BLOCKS</td>
      <td>The node is still syncing and the requested block is not in the database yet</td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

## View account changes {#view-account-changes}

> Returns account changes from transactions in a given account.

- method: `EXPERIMENTAL_changes`
- params:
  - `changes_type`: `account_changes`
  - `account_ids`: [`"example.testnet"`]
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_changes",
  "params": {
    "changes_type": "account_changes",
    "account_ids": ["your_account.testnet"],
    "block_id": 19703467
  }
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.experimental_changes({
  changes_type: "account_changes",
  account_ids: ["nearkat.testnet"],
  block_id: 19703467,
});
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_changes \
  params:='{
    "changes_type": "account_changes",
    "account_ids": ["your_account.testnet"],
    "block_id": 19703467
  }'
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "6xsfPSG89s6fCMShxxxQTP6D4ZHM9xkGCgubayTDRzAP",
    "changes": [
      {
        "cause": {
          "type": "transaction_processing",
          "tx_hash": "HLvxLKFM7gohFSqXPp5SpyydNEVpAno352qJJbnddsz3"
        },
        "type": "account_update",
        "change": {
          "account_id": "your_account.testnet",
          "amount": "499999959035075000000000000",
          "locked": "0",
          "code_hash": "11111111111111111111111111111111",
          "storage_usage": 182,
          "storage_paid_at": 0
        }
      },
      {
        "cause": {
          "type": "receipt_processing",
          "receipt_hash": "CPenN1dp4DNKnb9LiL5hkPmu1WiKLMuM7msDjEZwDmwa"
        },
        "type": "account_update",
        "change": {
          "account_id": "your_account.testnet",
          "amount": "499999959035075000000000000",
          "locked": "0",
          "code_hash": "11111111111111111111111111111111",
          "storage_usage": 264,
          "storage_paid_at": 0
        }
      }
    ]
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What Could Go Wrong? {#what-could-go-wrong-1}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `EXPERIMENTAL_changes` method:

<table className="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)</td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>If the block had been produced more than 5 epochs ago, try to send your request to <a href="https://near-nodes.io/intro/node-types#archival-node">an archival node</a></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NOT_SYNCED_YET</td>
      <td>The node is still syncing and the requested block is not in the database yet</td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

## View contract code {#view-contract-code}

> Returns the contract code (Wasm binary) deployed to the account. Please note that the returned code will be encoded in base64.

- method: `query`
- params:
  - `request_type`: `view_code`
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)
  - `account_id`: `"guest-book.testnet"`,

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "query",
  "params": {
    "request_type": "view_code",
    "finality": "final",
    "account_id": "guest-book.testnet"
  }
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.query({
  request_type: "view_code",
  finality: "final",
  account_id: "guest-book.testnet",
});
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
  params:='{
    "request_type": "view_code",
    "finality": "final",
    "account_id": "guest-book.testnet"
  }'
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "code_base64": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
    "hash": "7KoFshMQkdyo5iTx8P2LbLu9jQpxRn24d27FrKShNVXs",
    "block_height": 17814234,
    "block_hash": "GT1D8nweVQU1zyCUv399x8vDv2ogVq71w17MyR66hXBB"
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What Could Go Wrong? {#what-could-go-wrong-2}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `view_code` request type:

<table className="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="6">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)</td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>If the block had been produced more than 5 epochs ago, try to send your request to <a href="https://near-nodes.io/intro/node-types#archival-node">an archival node</a></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INVALID_ACCOUNT</td>
      <td>The requested <code>account_id</code> is invalid</td>
      <td>
        <ul>
          <li>Provide a valid <code>account_id</code></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_ACCOUNT</td>
      <td>The requested <code>account_id</code> has not been found while viewing since the account has not been created or has been already deleted</td>
      <td>
        <ul>
          <li>Check the <code>account_id</code></li>
          <li>Specify a different block or retry if you request the latest state</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NO_CONTRACT_CODE</td>
      <td>The account does not have any <code>contract</code> deployed on it</td>
      <td>
        <ul>
          <li>Use different account</li>
          <li>Specify a different block or retry if you request the latest state</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNAVAILABLE_SHARD</td>
      <td>The node was unable to find the requested data because it does not track the shard where data is present</td>
      <td>
        <ul>
          <li>Send a request to a different node which might track the shard</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NO_SYNCED_BLOCKS</td>
      <td>The node is still syncing and the requested block is not in the database yet</td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

## View contract state {#view-contract-state}

> Returns the state (key value pairs) of a contract based on the key prefix (base64 encoded). Pass an empty string for `prefix_base64` if you would like to return the entire state. Please note that the returned state will be base64 encoded as well.

- method: `query`
- params:
  - `request_type`: `view_state`
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)
  - `account_id`: `"guest-book.testnet"`,
  - `prefix_base64`: `""`

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "query",
  "params": {
    "request_type": "view_state",
    "finality": "final",
    "account_id": "guest-book.testnet",
    "prefix_base64": ""
  }
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.query({
  request_type: "view_state",
  finality: "final",
  account_id: "guest-book.testnet",
  prefix_base64: "",
});
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
  params:='{
    "request_type": "view_state",
    "finality": "final",
    "account_id": "guest-book.testnet",
    "prefix_base64": ""
  }'
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "values": [
      {
        "key": "bTo6MA==",
        "value": "eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJqb3NoZm9yZC50ZXN0bmV0IiwidGV4dCI6ImhlbGxvIn0=",
        "proof": []
      },
      {
        "key": "bTo6MQ==",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiY2hhZG9oIiwidGV4dCI6ImhlbGxvIGVyeWJvZHkifQ==",
        "proof": []
      },
      {
        "key": "bTo6MTA=",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoic2F0b3NoaWYudGVzdG5ldCIsInRleHQiOiJIaWxsbyEifQ==",
        "proof": []
      },
      {
        "key": "bTo6MTE=",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoidmFsZW50aW5lc29rb2wudGVzdG5ldCIsInRleHQiOiJIaSEifQ==",
        "proof": []
      },
      {
        "key": "bTo6MTI=",
        "value": "eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJobngudGVzdG5ldCIsInRleHQiOiJoZWxsbyJ9",
        "proof": []
      },
      {
        "key": "bTo6MTM=",
        "value": "eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJobngudGVzdG5ldCIsInRleHQiOiJzZCJ9",
        "proof": []
      },
      {
        "key": "bTo6MTQ=",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiamdoZy50ZXN0bmV0IiwidGV4dCI6IktoZyJ9",
        "proof": []
      },
      {
        "key": "bTo6MTU=",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiYWNjb3VudC50ZXN0bmV0IiwidGV4dCI6IldoZW4gSUNPPyJ9",
        "proof": []
      },
      {
        "key": "bTo6MTY=",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiYWNjb3VudC50ZXN0bmV0IiwidGV4dCI6IlRlc3QgMiJ9",
        "proof": []
      },
      {
        "key": "bTo6MTc=",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoidGVzdC1kcm9wLTEwLnRlc3RuZXQiLCJ0ZXh0IjoiRnJlZSBtZXNzYWdlcyBhcmUgdGhlIGJlc3QifQ==",
        "proof": []
      },
      {
        "key": "bTo6MTg=",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoidGVzdC1kcm9wLTEwLnRlc3RuZXQiLCJ0ZXh0IjoiV2hlbiBJQ08/In0=",
        "proof": []
      },
      {
        "key": "bTo6MTk=",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoidGVzdC1kcm9wLTEwLnRlc3RuZXQiLCJ0ZXh0IjoiV2hlbiBJQ08/In0=",
        "proof": []
      },
      {
        "key": "bTo6Mg==",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoibnVsbCIsInRleHQiOiJ1bmRlZmluZWQifQ==",
        "proof": []
      },
      {
        "key": "bTo6MjA=",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoidGVzdC04NDEudGVzdG5ldCIsInRleHQiOiJXaGVuIElDTz8ifQ==",
        "proof": []
      },
      {
        "key": "bTo6MjE=",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoidGVzdC04NDEudGVzdG5ldCIsInRleHQiOiJoZXkgaGV5IGhleSJ9",
        "proof": []
      },
      {
        "key": "bTo6MjI=",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiam9zaGZvcmQudGVzdG5ldCIsInRleHQiOiJoaSJ9",
        "proof": []
      },
      {
        "key": "bTo6MjM=",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiam9zaGZvcmQudGVzdG5ldCIsInRleHQiOiJoaSB4MiJ9",
        "proof": []
      },
      {
        "key": "bTo6MjQ=",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoibWFzdGVydGh5c2VsZi50ZXN0bmV0IiwidGV4dCI6ImhhbmRzaGFrZS5oYWNrbWVkb21haW4vICJ9",
        "proof": []
      },
      {
        "key": "bTo6MjU=",
        "value": "eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJtYXN0ZXJ0aHlzZWxmLnRlc3RuZXQiLCJ0ZXh0IjoiSGVsbG8gQ29zbW9zLCBob21lLmNvc21hdHJpeGNvbm5lY3Rpb25zLyJ9",
        "proof": []
      },
      {
        "key": "bTo6MjY=",
        "value": "eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJtYXN0ZXJ0aHlzZWxmLnRlc3RuZXQiLCJ0ZXh0IjoiYnVpbGQsIGJ1aWxkLCBidWlsZCBpIGNhbWUgdG8gYnVpbGQgYSBicmlkZ2UgaW4gUEVBQ0UsIHNvIGNvbWUgbGV0cyBidWlsZC4uLnNvbmcgYnkgXCJOYWhrbyBCZWFyXCIgIn0=",
        "proof": []
      },
      {
        "key": "bTo6Mjc=",
        "value": "eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJtYXN0ZXJ0aHlzZWxmLnRlc3RuZXQiLCJ0ZXh0IjoiYnVpbGQgYSBicmlkZ2UgKGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vdXJsP3NhPXQmcmN0PWomcT0mZXNyYz1zJnNvdXJjZT13ZWImY2Q9JmNhZD1yamEmdWFjdD04JnZlZD0yYWhVS0V3ajA0ZGlnMTlqckFoV05tbGtLSGR5X0FnUVEzeXd3QUhvRUNBVVFBZyZ1cmw9aHR0cHMlM0ElMkYlMkZ3d3cueW91dHViZS5jb20lMkZ3YXRjaCUzRnYlM0Rlb1RYNWZmOVplMCZ1c2c9QU92VmF3MFoxZzFIMkZzeF85d3FJSmg5RTk2UCkifQ==",
        "proof": []
      },
      {
        "key": "bTo6Mjg=",
        "value": "eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJtYXN0ZXJ0aHlzZWxmLnRlc3RuZXQiLCJ0ZXh0IjoiaHR0cDovL3RyaXBweS7wn42EbWFnaWMvIn0=",
        "proof": []
      },
      {
        "key": "bTo6Mjk=",
        "value": "eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJtYXN0ZXJ0aHlzZWxmLnRlc3RuZXQiLCJ0ZXh0IjoiaHR0cDovL3VuaXRlLnJhaW5ib3d0cmliZXMvIn0=",
        "proof": []
      },
      {
        "key": "bTo6Mw==",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiam9zaGZvcmQudGVzdG5ldCIsInRleHQiOiJobW1tbW1tIn0=",
        "proof": []
      },
      {
        "key": "bTo6MzA=",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiZXhlbXBsYXJ5LnRlc3RuZXQiLCJ0ZXh0IjoiaGVsbG8ifQ==",
        "proof": []
      },
      {
        "key": "bTo6MzE=",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiYWRpMjMudGVzdG5ldCIsInRleHQiOiJobW0ifQ==",
        "proof": []
      },
      {
        "key": "bTo6MzI=",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiYWRpMjMudGVzdG5ldCIsInRleHQiOiJ3aGF0In0=",
        "proof": []
      },
      {
        "key": "bTo6MzM=",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoidmxhZGJhc2gudGVzdG5ldCIsInRleHQiOiJIaSJ9",
        "proof": []
      },
      {
        "key": "bTo6NA==",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoibnVsbCIsInRleHQiOiIgIn0=",
        "proof": []
      },
      {
        "key": "bTo6NQ==",
        "value": "eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJ0ZXN0YWNjb3VudDEudGVzdG5ldCIsInRleHQiOiJ0ZXN0In0=",
        "proof": []
      },
      {
        "key": "bTo6Ng==",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiZXVnZW5ldGhlZHJlYW0iLCJ0ZXh0IjoibnVsbCJ9",
        "proof": []
      },
      {
        "key": "bTo6Nw==",
        "value": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiZGVtby50ZXN0bmV0IiwidGV4dCI6Ikkgb25seSB3cml0ZSBmcmVlIG1lc3NhZ2VzLiJ9",
        "proof": []
      },
      {
        "key": "bTo6OA==",
        "value": "eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJqb3NoZm9yZC50ZXN0bmV0IiwidGV4dCI6IkkgcHJlZmVyIHByZW1pdW0gbWVzc2FnZXMifQ==",
        "proof": []
      },
      {
        "key": "bTo6OQ==",
        "value": "eyJwcmVtaXVtIjp0cnVlLCJzZW5kZXIiOiJuZXdsZWRnZXIzLnRlc3RuZXQiLCJ0ZXh0IjoiTGVkZ2VyIn0=",
        "proof": []
      },
      {
        "key": "bTpsZW4=",
        "value": "MzQ=",
        "proof": []
      }
    ],
    "proof": [],
    "block_height": 17814234,
    "block_hash": "GT1D8nweVQU1zyCUv399x8vDv2ogVq71w17MyR66hXBB"
  },
  "id": "dontcare"
}
```
</p>

**Note**: Currently, the response includes a `proof` field directly in the
`result`, and a `proof` fields on each element of the `values` list.  In
the future, the `result.proof` will be included only if the result is **not empty**,
and the `proof` field will be removed from all `values`. When parsing the result, you
should accept objects with or without these fields set.

</details>

> **Heads up**
>
> There is a limitation on default RPC nodes. You won't be able to get the contract state if it is too big. The default limit of for contract state is 50kb of state size. You're able to change the limits if you [run your own RPC node](https://near-nodes.io/validator/compile-and-run-a-node) with adjusted `trie_viewer_state_size_limit` value in `config.json`

#### What Could Go Wrong? {#what-could-go-wrong-3}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `view_state` request type:

<table className="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="7">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)</td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>If the block had been produced more than 5 epochs ago, try to send your request to <a href="https://near-nodes.io/intro/node-types#archival-node">an archival node</a></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INVALID_ACCOUNT</td>
      <td>The requested <code>account_id</code> is invalid</td>
      <td>
        <ul>
          <li>Provide a valid <code>account_id</code></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_ACCOUNT</td>
      <td>The requested <code>account_id</code> has not been found while viewing since the account has not been created or has been already deleted</td>
      <td>
        <ul>
          <li>Check the <code>account_id</code></li>
          <li>Specify a different block or retry if you request the latest state</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NO_CONTRACT_CODE</td>
      <td>The account does not have any <code>contract</code> deployed on it</td>
      <td>
        <ul>
          <li>Query and account with contract deployed</li>
          <li>Specify a different block or retry if you request the latest state</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>TOO_LARGE_CONTRACT_STATE</td>
      <td>The requested contract state is too large to be returned from this node (the default limit is 50kb of state size)</td>
      <td>
        <ul>
          <li>Send the request to a node with larger limits in order to view the requested state</li>
          <li>Spin up your own node where you can increase the limits to view state</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNAVAILABLE_SHARD</td>
      <td>The node was unable to find the requested data because it does not track the shard where data is present</td>
      <td>
        <ul>
          <li>Send a request to a different node which might track the shard</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NO_SYNCED_BLOCKS</td>
      <td>The node is still syncing and the requested block is not in the database yet</td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

## View contract state changes {#view-contract-state-changes}

> Returns the state change details of a contract based on the key prefix (encoded to base64). Pass an empty string for this param if you would like to return all state changes.

- method: `EXPERIMENTAL_changes`
- params:
  - `changes_type`: `data_changes`
  - `account_ids`: `["example.testnet"]`,
  - `key_prefix_base64`: `"base64 encoded key value"`,
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_changes",
  "params": {
    "changes_type": "data_changes",
    "account_ids": ["guest-book.testnet"],
    "key_prefix_base64": "",
    "block_id": 19450732
  }
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.experimental_changes({
  changes_type: "data_changes",
  account_ids: ["guest-book.testnet"],
  key_prefix_base64: "",
  block_id: 19450732,
});
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_changes \
  params:='{
    "changes_type": "data_changes",
    "account_ids": ["guest-book.testnet"],
    "key_prefix_base64": "",
    "block_id": 19450732
  }'
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "6U8Yd4JFZwJUNfqkD4KaKgTKmpNSmVRTSggpjmsRWdKY",
    "changes": [
      {
        "cause": {
          "type": "receipt_processing",
          "receipt_hash": "9ewznXgs2t7vRCssxW4thgaiwggnMagKybZ7ryLNTT2z"
        },
        "type": "data_update",
        "change": {
          "account_id": "guest-book.testnet",
          "key_base64": "bTo6Mzk=",
          "value_base64": "eyJwcmVtaXVtIjpmYWxzZSwic2VuZGVyIjoiZmhyLnRlc3RuZXQiLCJ0ZXh0IjoiSGkifQ=="
        }
      },
      {
        "cause": {
          "type": "receipt_processing",
          "receipt_hash": "9ewznXgs2t7vRCssxW4thgaiwggnMagKybZ7ryLNTT2z"
        },
        "type": "data_update",
        "change": {
          "account_id": "guest-book.testnet",
          "key_base64": "bTpsZW4=",
          "value_base64": "NDA="
        }
      }
    ]
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What Could Go Wrong? {#what-could-go-wrong-4}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `EXPERIMENTAL_changes` method:

<table className="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)</td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>If the block had been produced more than 5 epochs ago, try to send your request to <a href="https://near-nodes.io/intro/node-types#archival-node">an archival node</a></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NOT_SYNCED_YET</td>
      <td>The node is still syncing and the requested block is not in the database yet</td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

## View contract code changes {#view-contract-code-changes}

> Returns code changes made when deploying a contract. Change is returned is a base64 encoded WASM file.

- method: `EXPERIMENTAL_changes`
- params:
  - `changes_type`: `contract_code_changes`
  - `account_ids`: `["example.testnet"]`,
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_changes",
  "params": {
    "changes_type": "contract_code_changes",
    "account_ids": ["dev-1602714453032-7566969"],
    "block_id": 20046655
  }
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.experimental_changes({
  changes_type: "contract_code_changes",
  account_ids: ["dev-1602714453032-7566969"],
  block_id: 20046655,
});
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_changes \
  params:='{
    "changes_type": "contract_code_changes",
    "account_ids": ["dev-1602714453032-7566969"],
    "block_id": 20046655
  }'
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "3yLNV5zdpzRJ8HP5xTXcF7jdFxuHnmKNUwWcok4616WZ",
    "changes": [
      {
        "cause": {
          "type": "receipt_processing",
          "receipt_hash": "CEm3NNaNdu9cijh9NvZMM1srbtEYSsBVwGbZxFQYKt5B"
        },
        "type": "contract_code_update",
        "change": {
          "account_id": "dev-1602714453032-7566969",
          "code_base64": "AGFzbQEAAAABpAM3YAF/AGAAAX9gAn9+AGADf35+AGAEf35+fgF+YAZ/fn5+fn4BfmADf35+AX5gAn9+AX5gAn9/AX9gAn9/AGADf39/AX9gAX8BfmACfn4AYAF+AX5gAX4AYAABfmADfn5+AGAAAGAIfn5+fn5+fn4BfmAJfn5+fn5+fn5+AX5gAn5+AX5gA35+fgF+YAd+fn5+fn5+AGAEfn5+fgBgCX5+fn5+fn5+fgBgBX5+fn5+AX5gA39/fwBgAX8Bf2ACf3wAYAR/f39+AGAFf39/fn8AYAV/f39/fwBgBH9/f38AYAN/f38BfmADf39+AGACf38BfmAFf39/f38Bf2AEf39/fwF/YAZ/f39/f38AYAV/f35/fwBgBH9+f38Bf2ACf34Bf2AHf35+f39+fwBgBX9/f39+AGAEf35+fgBgCX9+fn5+fn5+fgF+YAp/fn5+fn5+fn5+AX5gCH9+fn5+fn5+AGAFf35+fn4AYAp/fn5+fn5+fn5+AGAHf39/f39/fwBgBH98f38Bf2AGf39/f39..."
        }
      }
    ]
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What Could Go Wrong? {#what-could-go-wrong-5}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `EXPERIMENTAL_changes` method:

<table className="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)</td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>If the block had been produced more than 5 epochs ago, try to send your request to <a href="https://near-nodes.io/intro/node-types#archival-node">an archival node</a></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NOT_SYNCED_YET</td>
      <td>The node is still syncing and the requested block is not in the database yet</td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

## Call a contract function {#call-a-contract-function}
> Allows you to call a contract method as a [view function](../../4.tools/cli.md#near-view-near-view).

- method: `query`
- params:
  - `request_type`: `call_function`
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)
  - `account_id`: _`"example.testnet"`_
  - `method_name`: `name_of_a_example.testnet_method` (example [`view` methods](https://github.com/near/core-contracts/blob/master/staking-pool/src/lib.rs#L317)
  - `args_base64`: `method_arguments_base_64_encoded`

Example (`get_num`):

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "query",
  "params": {
    "request_type": "call_function",
    "finality": "final",
    "account_id": "dev-1588039999690",
    "method_name": "get_num",
    "args_base64": "e30="
  }
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.query({
  request_type: "call_function",
  finality: "final",
  account_id: "dev-1588039999690",
  method_name: "get_num",
  args_base64: "e30=",
});
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
  params:='{
    "request_type": "call_function",
    "finality": "final",
    "account_id": "dev-1588039999690",
    "method_name": "get_num",
    "args_base64": "e30="
  }'
```

</TabItem>
</Tabs>

Example (`get_account_staked_balance`):

The `args_base64` in this example is decoded as `{"account_id":"dev-1588039999690"}`.  The `account_id` would likely be the validator and not the same account for this particular view function.

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "query",
  "params": {
    "request_type": "call_function",
    "finality": "final",
    "account_id": "dev-1588039999690",
    "method_name": "get_account_staked_balance",
    "args_base64": "eyJhY2NvdW50X2lkIjoiZGV2LTE1ODgwMzk5OTk2OTAifQ=="
  }
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.query({
  request_type: "call_function",
  finality: "final",
  account_id: "dev-1588039999690",
  method_name: "get_account_staked_balance",
  args_base64: "eyJhY2NvdW50X2lkIjoiZGV2LTE1ODgwMzk5OTk2OTAifQ==",
});
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
  params:='{
    "request_type": "call_function",
    "finality": "final",
    "account_id": "dev-1588039999690",
    "method_name": "get_account_staked_balance",
    "args_base64": "eyJhY2NvdW50X2lkIjoiZGV2LTE1ODgwMzk5OTk2OTAifQ=="
  }'
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "result": [48],
    "logs": [],
    "block_height": 17817336,
    "block_hash": "4qkA4sUUG8opjH5Q9bL5mWJTnfR4ech879Db1BZXbx6P"
  },
  "id": "dontcare"
}
```

**Note**: `[48]` is an array of bytes, to be specific it is an ASCII code of `0`.`near-sdk-rs` and `near-sdk-js` return JSON-serialized results.

</p>
</details>

#### What Could Go Wrong? {#what-could-go-wrong-6}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `call_function` request type:

<table className="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="7">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)</td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>If the block had been produced more than 5 epochs ago, try to send your request to <a href="https://near-nodes.io/intro/node-types#archival-node">an archival node</a></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INVALID_ACCOUNT</td>
      <td>The requested <code>account_id</code> is invalid</td>
      <td>
        <ul>
          <li>Provide a valid <code>account_id</code></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_ACCOUNT</td>
      <td>The requested <code>account_id</code> has not been found while viewing since the account has not been created or has been already deleted</td>
      <td>
        <ul>
          <li>Check the <code>account_id</code></li>
          <li>Specify a different block or retry if you request the latest state</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NO_CONTRACT_CODE</td>
      <td>The requested <code>contract_code</code> has not been found while viewing</td>
      <td>
        <ul>
          <li>Check the <code>public_key</code></li>
          <li>Specify a different block or retry if you request the latest state</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>CONTRACT_EXECUTION_ERROR</td>
      <td>The execution of the view function call failed (crashed, run out of the default 200 TGas limit, etc)</td>
      <td>
        <ul>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNAVAILABLE_SHARD</td>
      <td>The node was unable to find the requested data because it does not track the shard where data is present</td>
      <td>
        <ul>
          <li>Send a request to a different node which might track the shard</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NO_SYNCED_BLOCKS</td>
      <td>The node is still syncing and the requested block is not in the database yet</td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

'''
'''--- docs/5.api/rpc/gas.md ---
---
id: gas
title: Gas 
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The RPC API enables you to query the gas price for a specific block or hash.

---

## Gas Price {#gas-price}

> Returns gas price for a specific `block_height` or `block_hash`.
>
> - Using `[null]` will return the most recent block's gas price.

- method: `gas_price`
- params: `[block_height]`, `["block_hash"]`, or `[null]`

`[block_height]`

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "gas_price",
  "params": [17824600]
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.gasPrice(17824600);
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 method=gas_price params:='[17824600]' id=dontcare
```

</TabItem>
</Tabs>

`["block_hash"]`

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "gas_price",
  "params": ["AXa8CHDQSA8RdFCt12rtpFraVq4fDUgJbLPxwbaZcZrj"]
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.gasPrice(
  "AXa8CHDQSA8RdFCt12rtpFraVq4fDUgJbLPxwbaZcZrj"
);
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 method=gas_price params:='["AXa8CHDQSA8RdFCt12rtpFraVq4fDUgJbLPxwbaZcZrj"]' id=dontcare
```

</TabItem>
</Tabs>

`[null]`

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "gas_price",
  "params": [null]
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.gasPrice(null);
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 method=gas_price params:='[null]' id=dontcare
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "gas_price": "100000000"
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What could go wrong? {#what-could-go-wrong}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `gas_price` method:

<table>
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)</td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>If the block had been produced more than 5 epochs ago, try to send your request to an archival node</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

'''
'''--- docs/5.api/rpc/introduction.md ---
---
id: introduction
sidebar_label: Home
title: NEAR RPC API
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The RPC API allows you to communicate directly with the NEAR network. For example,
tools such as [near-api-js](/tools/near-api-js/quick-reference) are just abstractions making RPC calls.

<hr className="subsection" />

## RPC Providers

There are multiple [RPC providers which you can choose from](./providers.md). These providers will work as intermediaries to help you interact with the NEAR network.

<hr className="subsection" />

## NEAR RPC - Quick Links

| API                                                 | Description                                                                  |
|-----------------------------------------------------|------------------------------------------------------------------------------|
| [Access Keys](/api/rpc/access-keys)                 | Retrieve information about an account's access keys.                         |
| [Accounts / Contracts](/api/rpc/contracts)          | View details about accounts and contracts as well as perform contract calls. |
| [Block / Chunk](/api/rpc/block-chunk)               | Query the network and get details about specific blocks or chunks.           |
| [Gas](/api/rpc/gas)                                 | Get gas price for a specific block or hash.                                  |
| [Protocol](/api/rpc/protocol)                       | Retrieve current genesis and protocol configuration.                         |
| [Network](/api/rpc/network)                         | Return status information for nodes and validators.                          |
| [Transactions](/api/rpc/transactions)               | Send transactions and query their status.                                    |
| [Maintenance Windows](/api/rpc/maintenance-windows) | Query the maintenance windows in current epoch for a validator.              |

:::tip
You can access the JSON RPC 2.0 endpoints using [Postman](/api/rpc/setup#postman-setup),
[JavaScript](/api/rpc/setup#javascript-setup), and [HTTPie](/api/rpc/setup#httpie-setup).
:::

'''
'''--- docs/5.api/rpc/maintenance-windows.md ---
---
id: maintenance-windows
title: Maintenance Windows
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The RPC API enables you to query future maintenance windows for a specific validator in current epoch

---

## Maintenance windows {#maintenance-windows}

> The maintenance windows for a specific validator are future block height ranges in current epoch, in which the validator does not need produce block or chunk
> If the provided account is not a validator, then it will return the range from now to the end of the epoch.

- method: `EXPERIMENTAL_maintenance_windows`
- params:
  - `account_id`

example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_maintenance_windows",
  "params": {
    "account_id": "node0"
  }
}
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_maintenance_windows \
  params:='{
    "account_id": "node0"
  }'
```

</TabItem>
</Tabs>

<details>
<summary>Example response:</summary>
<p>
The result will be a list of future maintenance windows in current epoch.
For example a window `[1028, 1031]` includes 1028, 1029 and 1030.

```json
{
    "jsonrpc": "2.0",
    "result": [
        [
            1028,
            1031
        ],
        [
            1034,
            1038
        ],
    ],
    "id": "dontcare"
}
```

</p>
</details>

#### What Could Go Wrong?? {#what-could-go-wrong}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

Here is the exhaustive list of the error variants that can be returned by `maintenance_windows` method:

<table className="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

'''
'''--- docs/5.api/rpc/network.md ---
---
id: network
title: Network
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The RPC API enables you to query status information for nodes and validators.

---

## Node Status {#node-status}

> Returns general status of a given node (sync status, nearcore node version, protocol version, etc), and the current set of validators.

- method: `status`
- params: `[]`

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "status",
  "params": []
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.status();
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 method=status params:='[]' id=dontcare
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "version": {
      "version": "1.14.0-rc.1",
      "build": "effa3b7a-modified"
    },
    "chain_id": "testnet",
    "protocol_version": 35,
    "latest_protocol_version": 35,
    "rpc_addr": "0.0.0.0:3030",
    "validators": [
      {
        "account_id": "node3",
        "is_slashed": false
      },
      {
        "account_id": "node0",
        "is_slashed": false
      },
      {
        "account_id": "staked.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "01node.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "node2",
        "is_slashed": false
      },
      {
        "account_id": "dokia.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "node1",
        "is_slashed": false
      },
      {
        "account_id": "lowfeevalidation.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "sl1sub.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "zainy.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "chorus-one.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "thepassivetrust.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "certusone.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "joe1.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "bisontrails.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "valeraverim.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "lunanova.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "bazilik.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "dsrvlabs.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "kronos.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "nodeasy.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "kytzu.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "bitcat.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "pool_easy2stake.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "fresh_lockup.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "staking-power.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "syncnode.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "inotel.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "zpool.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "aquarius.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "cloudpost.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "staked.pool.6fb1358",
        "is_slashed": false
      },
      {
        "account_id": "moonlet.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "jazza.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "orangeclub.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "blazenet.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "pathrock.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "stakin.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "northernlights.stakingpool",
        "is_slashed": false
      },
      {
        "account_id": "alexandruast.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "top.pool.f863973.m0",
        "is_slashed": false
      }
    ],
    "sync_info": {
      "latest_block_hash": "44kieHwr7Gg5r72V3DgU7cpgV2aySkk5qbBCdvwens8T",
      "latest_block_height": 17774278,
      "latest_state_root": "3MD3fQqnm3JYa9UQgenEJsR6UHoWuHV4Tpr4hZY7QwfY",
      "latest_block_time": "2020-09-27T23:59:38.008063088Z",
      "syncing": false
    },
    "validator_account_id": "nearup-node8"
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What could go wrong? {#what-could-go-wrong}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `status` method:

<table>
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

## Network Info {#network-info}

> Returns the current state of node network connections (active peers, transmitted data, etc.)

- method: `network_info`
- params: _none_

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "network_info",
  "params": []
}
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 method=network_info params:='[]' id=dontcare
```

</TabItem>
</Tabs>

<details>
<summary>Example response:</summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "active_peers": [
      {
        "id": "ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5",
        "addr": "35.193.24.121:24567",
        "account_id": null
      }
    ],
    "num_active_peers": 34,
    "peer_max_count": 40,
    "sent_bytes_per_sec": 17754754,
    "received_bytes_per_sec": 492116,
    "known_producers": [
      {
        "account_id": "node0",
        "addr": null,
        "peer_id": "ed25519:7PGseFbWxvYVgZ89K1uTJKYoKetWs7BJtbyXDzfbAcqX"
      }
    ]
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What could go wrong? {#what-could-go-wrong-1}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `network_info` method:

<table>
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

## Validation Status {#validation-status}

> Queries active validators on the network returning details and the state of 
validation on the blockchain.

- method: `validators`
- params: `["block hash"]`, `[block number]`, `{"epoch_id": "epoch id"}`, 
`{"block_id": block number}`, `{"block_id": "block hash"}`, or 
`[null]` for the latest block

**Note:** If you want the latest `block hash`, `block number` and `epoch id`, 
you will need to query from the last block in an epoch. You can also query 
validators endpoint for past epochs if you input `block hash`, `block number` 
or `epoch id` of the past epoch that you want.

Example:

input: `[block number]`

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "validators",
  "params": [17791098]
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 method=validators params:='[17791098]' id=dontcare
```

</TabItem>
</Tabs>

input: `["block hash"]`

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "validators",
  "params": ["FiG2nMjjue3YdgYAyM3ZqWXSaG6RJj5Gk7hvY8vrEoGw"]
}
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 method=validators params:='["FiG2nMjjue3YdgYAyM3ZqWXSaG6RJj5Gk7hvY8vrEoGw"]' id=dontcare
```

</TabItem>
</Tabs>

input: `{"block_id": "block hash"}`

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "validators",
  "params": {
    "block_id": "FiG2nMjjue3YdgYAyM3ZqWXSaG6RJj5Gk7hvY8vrEoGw"
  }
}
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=validators \
  params:='{
    "block_id": "FiG2nMjjue3YdgYAyM3ZqWXSaG6RJj5Gk7hvY8vrEoGw"
  }'
```

</TabItem>
</Tabs>

input: `{"block_id": block number}`

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "validators",
  "params": {
    "block_id": 17791098
  }
}
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=validators \
  params:='{
    "block_id": 17791098
  }`
```

</TabItem>
</Tabs>

input: `{"epoch_id": "epoch id"}`

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "validators",
  "params": {
    "epoch_id": "8hJSZNNyimPvsCA1v3dMr3Hg5ucYeLUbTvEfhr6jaWJy"
  }
}
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=validators \
  params:='{
    "epoch_id": "8hJSZNNyimPvsCA1v3dMr3Hg5ucYeLUbTvEfhr6jaWJy"
  }`
```

</TabItem>
</Tabs>

input: `[null]`

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "validators",
  "params": [null]
}
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 method=validators params:='[null]' id=dontcare
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "current_validators": [
      {
        "account_id": "01node.pool.f863973.m0",
        "public_key": "ed25519:3iNqnvBgxJPXCxu6hNdvJso1PEAc1miAD35KQMBCA3aL",
        "is_slashed": false,
        "stake": "176429739989396285019500901780",
        "shards": [0],
        "num_produced_blocks": 213,
        "num_expected_blocks": 213
      },
      {
        "account_id": "alexandruast.pool.f863973.m0",
        "public_key": "ed25519:A3XJ3uVGxSi9o2gnG2r8Ra3fqqodRpL4iuLTc6fNdGUj",
        "is_slashed": false,
        "stake": "151430394143736014372434860532",
        "shards": [0],
        "num_produced_blocks": 213,
        "num_expected_blocks": 213
      },
      {
        "account_id": "aquarius.pool.f863973.m0",
        "public_key": "ed25519:8NfEarjStDYjJTwKUgQGy7Z7UTGsZaPhTUsExheQN3r1",
        "is_slashed": false,
        "stake": "130367563121508828296664196836",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 212
      },
      {
        "account_id": "bazilik.pool.f863973.m0",
        "public_key": "ed25519:3pDJwDQ6Y5B9QeW1jz8KunhZH4D4GQG86reTmrRfdD7c",
        "is_slashed": false,
        "stake": "169013447850997135034919151338",
        "shards": [0],
        "num_produced_blocks": 211,
        "num_expected_blocks": 213
      },
      {
        "account_id": "bisontrails.pool.f863973.m0",
        "public_key": "ed25519:8g4P5EXyp2b2pfVMHY1QLfkRcY59hjPfWrFCKUWX3RmR",
        "is_slashed": false,
        "stake": "184162578269044826045352223479",
        "shards": [0],
        "num_produced_blocks": 213,
        "num_expected_blocks": 213
      },
      {
        "account_id": "bitcat.pool.f863973.m0",
        "public_key": "ed25519:9mtnwPQyyap1QNH9ag6r4the7Jkkpdyt9HUF5G1dWxKx",
        "is_slashed": false,
        "stake": "135215509376418353124295451543",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 212
      },
      {
        "account_id": "blazenet.pool.f863973.m0",
        "public_key": "ed25519:DiogP36wBXKFpFeqirrxN8G2Mq9vnakgBvgnHdL9CcN3",
        "is_slashed": false,
        "stake": "137364229255641651855065314186",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 212
      },
      {
        "account_id": "certusone.pool.f863973.m0",
        "public_key": "ed25519:CKW7f41Kn8YCDPzaGLs1MrPb9h3BjQmHhbei6Ff6nRRF",
        "is_slashed": false,
        "stake": "176644821310043228577017742667",
        "shards": [0],
        "num_produced_blocks": 213,
        "num_expected_blocks": 213
      },
      {
        "account_id": "chorus-one.pool.f863973.m0",
        "public_key": "ed25519:6LFwyEEsqhuDxorWfsKcPPs324zLWTaoqk4o6RDXN7Qc",
        "is_slashed": false,
        "stake": "110397600457815316527526651811",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 213
      },
      {
        "account_id": "cloudpost.pool.f863973.m0",
        "public_key": "ed25519:AVVLmJDG8z6UgmW9fmJGVFTdYxxfnqXH6c7FVQmhE6dp",
        "is_slashed": false,
        "stake": "136597929514591130855076834167",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 212
      },
      {
        "account_id": "dokia.pool.f863973.m0",
        "public_key": "ed25519:935JMz1vLcJxFApG3TY4MA4RHhvResvoGwCrQoJxHPn9",
        "is_slashed": false,
        "stake": "220445043066799898276306006919",
        "shards": [0],
        "num_produced_blocks": 426,
        "num_expected_blocks": 426
      },
      {
        "account_id": "dsrvlabs.pool.f863973.m0",
        "public_key": "ed25519:61ei2efmmLkeDR1CG6JDEC2U3oZCUuC2K1X16Vmxrud9",
        "is_slashed": false,
        "stake": "161508967845718247649113721019",
        "shards": [0],
        "num_produced_blocks": 213,
        "num_expected_blocks": 213
      },
      {
        "account_id": "fresh_lockup.pool.f863973.m0",
        "public_key": "ed25519:7CMFLtEohojtxBkmj9Jb6AGgbphb1zvxymHzpzuyCjfG",
        "is_slashed": false,
        "stake": "193574159400241036715020269158",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 212
      },
      {
        "account_id": "inotel.pool.f863973.m0",
        "public_key": "ed25519:C55jH1MCHYGa3tzUyZZdGrJmmCLP22Aa4v88KYpn2xwZ",
        "is_slashed": false,
        "stake": "178598870951670469578754984993",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 212
      },
      {
        "account_id": "jazza.pool.f863973.m0",
        "public_key": "ed25519:85cPMNVrqUz8N7oWbbvWbUuamHcJNe49uRbaSzftLCz9",
        "is_slashed": false,
        "stake": "155762349362951827286303475797",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 212
      },
      {
        "account_id": "joe1.pool.f863973.m0",
        "public_key": "ed25519:G3SxwzmiEZSm3bHnTLtxJvm3NvT1TLQcWuV1iod6i6NJ",
        "is_slashed": false,
        "stake": "129230772267511696840933436174",
        "shards": [0],
        "num_produced_blocks": 213,
        "num_expected_blocks": 213
      },
      {
        "account_id": "kronos.pool.f863973.m0",
        "public_key": "ed25519:3i2pertqzF8xqkJ4BrE4t4r67YiYYrUKCktbqvDgjzuQ",
        "is_slashed": false,
        "stake": "144544279093485390569527924033",
        "shards": [0],
        "num_produced_blocks": 202,
        "num_expected_blocks": 213
      },
      {
        "account_id": "kytzu.pool.f863973.m0",
        "public_key": "ed25519:61tgPZpy8tqFeAwG4vtf2ZKCRoENiP2A1TJVWEwnbxZU",
        "is_slashed": false,
        "stake": "113758432843198726378418342568",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 212
      },
      {
        "account_id": "lowfeevalidation.pool.f863973.m0",
        "public_key": "ed25519:EXyjSMGSnk5uGphF3gVV1jCudaAudbW8imoEccYEJg3V",
        "is_slashed": false,
        "stake": "113685537557977098595863252617",
        "shards": [0],
        "num_produced_blocks": 213,
        "num_expected_blocks": 213
      },
      {
        "account_id": "lunanova.pool.f863973.m0",
        "public_key": "ed25519:2fZ59qfo9QHNLijoht9cwUb9enSNcnRmXbQn1gKZxvkw",
        "is_slashed": false,
        "stake": "172903039219549397267702571804",
        "shards": [0],
        "num_produced_blocks": 213,
        "num_expected_blocks": 213
      },
      {
        "account_id": "moonlet.pool.f863973.m0",
        "public_key": "ed25519:3e1nVCVGNS3yr6CcUvpDAs3BhiWtyM9uTBWkyVR5Xn3K",
        "is_slashed": false,
        "stake": "140599784944681716744261599779",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 212
      },
      {
        "account_id": "node0",
        "public_key": "ed25519:7PGseFbWxvYVgZ89K1uTJKYoKetWs7BJtbyXDzfbAcqX",
        "is_slashed": false,
        "stake": "1907234923845608896091985071588",
        "shards": [0],
        "num_produced_blocks": 3614,
        "num_expected_blocks": 3616
      },
      {
        "account_id": "node1",
        "public_key": "ed25519:6DSjZ8mvsRZDvFqFxo8tCKePG96omXW7eVYVSySmDk8e",
        "is_slashed": false,
        "stake": "1906065501889463342906704128820",
        "shards": [0],
        "num_produced_blocks": 3613,
        "num_expected_blocks": 3614
      },
      {
        "account_id": "node2",
        "public_key": "ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5",
        "is_slashed": false,
        "stake": "1840271519773089248112279578450",
        "shards": [0],
        "num_produced_blocks": 3615,
        "num_expected_blocks": 3615
      },
      {
        "account_id": "node3",
        "public_key": "ed25519:ydgzeXHJ5Xyt7M1gXLxqLBW1Ejx6scNV5Nx2pxFM8su",
        "is_slashed": false,
        "stake": "1247270566437910246525604113433",
        "shards": [0],
        "num_produced_blocks": 2335,
        "num_expected_blocks": 2342
      },
      {
        "account_id": "nodeasy.pool.f863973.m0",
        "public_key": "ed25519:25Dhg8NBvQhsVTuugav3t1To1X1zKiomDmnh8yN9hHMb",
        "is_slashed": false,
        "stake": "131652957125263756523827257067",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 212
      },
      {
        "account_id": "northernlights.stakingpool",
        "public_key": "ed25519:CsMecqKCfagnebMB3ha1uRubay5Z4V85req23bNAJSG3",
        "is_slashed": false,
        "stake": "159669819380982417675619400525",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 212
      },
      {
        "account_id": "orangeclub.pool.f863973.m0",
        "public_key": "ed25519:HezFeSzcwuR5wvkqccgMCMnpf1eQkVCfk52tXZEdKZHz",
        "is_slashed": false,
        "stake": "143971234567521206686862639104",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 212
      },
      {
        "account_id": "pathrock.pool.f863973.m0",
        "public_key": "ed25519:G138GdQsU7PdFLD6X88NmTLAEDR7agPcq9HLZqGpegkm",
        "is_slashed": false,
        "stake": "125204431569306697735287326827",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 212
      },
      {
        "account_id": "pool_easy2stake.pool.f863973.m0",
        "public_key": "ed25519:8nzKxvmyeauQRehWkby8GfWNLgqPiF5FCRFSD75M1Rwh",
        "is_slashed": false,
        "stake": "176893731686620703671521068552",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 212
      },
      {
        "account_id": "sl1sub.pool.f863973.m0",
        "public_key": "ed25519:3URBpNUjNAMzugQH1rdSKMtwFM8AwHaJgZk5Z6YtnfFL",
        "is_slashed": false,
        "stake": "155741680601335529540438949153",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 213
      },
      {
        "account_id": "staked.pool.6fb1358",
        "public_key": "ed25519:684rMbuVYYgL2CkmYgC1weLh3erd2bwrmtQtJJhWzPwj",
        "is_slashed": false,
        "stake": "126911347639167461321544980789",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 212
      },
      {
        "account_id": "staked.pool.f863973.m0",
        "public_key": "ed25519:D2afKYVaKQ1LGiWbMAZRfkKLgqimTR74wvtESvjx5Ft2",
        "is_slashed": false,
        "stake": "140558085958535444819294942478",
        "shards": [0],
        "num_produced_blocks": 213,
        "num_expected_blocks": 213
      },
      {
        "account_id": "stakin.pool.f863973.m0",
        "public_key": "ed25519:GvddxjaxBCqGGB4kMNWNFtvozU1EEZ2jrnggKZW8LaU4",
        "is_slashed": false,
        "stake": "122221693837484004905170552626",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 212
      },
      {
        "account_id": "staking-power.pool.f863973.m0",
        "public_key": "ed25519:4s79F6Fdjgb3rHXPLwaXZG4Hq7Za8nogUu3vXEamRBQo",
        "is_slashed": false,
        "stake": "113293334165305165414435157738",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 212
      },
      {
        "account_id": "syncnode.pool.f863973.m0",
        "public_key": "ed25519:FUAVDkmLhuTbKYv4GWuWv9ogjKzRatLd5ZBMKXRy7WqE",
        "is_slashed": false,
        "stake": "133414422809248011010747790387",
        "shards": [0],
        "num_produced_blocks": 212,
        "num_expected_blocks": 212
      },
      {
        "account_id": "thepassivetrust.pool.f863973.m0",
        "public_key": "ed25519:4NccD2DNJpBkDmWeJ2GbqPoivQ93qcKiR4PHALJKCTod",
        "is_slashed": false,
        "stake": "162714097201953456968339272308",
        "shards": [0],
        "num_produced_blocks": 213,
        "num_expected_blocks": 213
      },
      {
        "account_id": "top.pool.f863973.m0",
        "public_key": "ed25519:FR5qxAsP8GgXDN96pappLtWMywiqWsPVqT3HLE3YaUx",
        "is_slashed": false,
        "stake": "164760602493727447176131601464",
        "shards": [0],
        "num_produced_blocks": 213,
        "num_expected_blocks": 213
      },
      {
        "account_id": "valeraverim.pool.f863973.m0",
        "public_key": "ed25519:3686ABqNUZc1qhLWLHg5xZpBzrWPiUCMNZxcCNmg3e2s",
        "is_slashed": false,
        "stake": "191733144511459134091274432419",
        "shards": [0],
        "num_produced_blocks": 213,
        "num_expected_blocks": 213
      },
      {
        "account_id": "zainy.pool.f863973.m0",
        "public_key": "ed25519:37KfhBNYjqpaUVh3ft5kPcFn3xK1eVvtDZJCQQVCGnzQ",
        "is_slashed": false,
        "stake": "113441017844444454951489924484",
        "shards": [0],
        "num_produced_blocks": 213,
        "num_expected_blocks": 213
      },
      {
        "account_id": "zpool.pool.f863973.m0",
        "public_key": "ed25519:ETFRFNHfvd6fpj74MGYYQp3diY8WB4bFmWMxjTB2yY4V",
        "is_slashed": false,
        "stake": "140932616764414290525265048028",
        "shards": [0],
        "num_produced_blocks": 120,
        "num_expected_blocks": 212
      }
    ],
    "next_validators": [
      {
        "account_id": "01node.pool.f863973.m0",
        "public_key": "ed25519:3iNqnvBgxJPXCxu6hNdvJso1PEAc1miAD35KQMBCA3aL",
        "stake": "177341160716540400974121040893",
        "shards": [0]
      },
      {
        "account_id": "alexandruast.pool.f863973.m0",
        "public_key": "ed25519:A3XJ3uVGxSi9o2gnG2r8Ra3fqqodRpL4iuLTc6fNdGUj",
        "stake": "152212670433756011274558210225",
        "shards": [0]
      },
      {
        "account_id": "aquarius.pool.f863973.m0",
        "public_key": "ed25519:8NfEarjStDYjJTwKUgQGy7Z7UTGsZaPhTUsExheQN3r1",
        "stake": "131041030638338742265060835987",
        "shards": [0]
      },
      {
        "account_id": "bazilik.pool.f863973.m0",
        "public_key": "ed25519:3pDJwDQ6Y5B9QeW1jz8KunhZH4D4GQG86reTmrRfdD7c",
        "stake": "169886556654364796730036727847",
        "shards": [0]
      },
      {
        "account_id": "bisontrails.pool.f863973.m0",
        "public_key": "ed25519:8g4P5EXyp2b2pfVMHY1QLfkRcY59hjPfWrFCKUWX3RmR",
        "stake": "185113946165399113822995097304",
        "shards": [0]
      },
      {
        "account_id": "bitcat.pool.f863973.m0",
        "public_key": "ed25519:9mtnwPQyyap1QNH9ag6r4the7Jkkpdyt9HUF5G1dWxKx",
        "stake": "135914020962862866419944507506",
        "shards": [0]
      },
      {
        "account_id": "blazenet.pool.f863973.m0",
        "public_key": "ed25519:DiogP36wBXKFpFeqirrxN8G2Mq9vnakgBvgnHdL9CcN3",
        "stake": "138073840925159254185212483041",
        "shards": [0]
      },
      {
        "account_id": "certusone.pool.f863973.m0",
        "public_key": "ed25519:CKW7f41Kn8YCDPzaGLs1MrPb9h3BjQmHhbei6Ff6nRRF",
        "stake": "177557353126393581856047095474",
        "shards": [0]
      },
      {
        "account_id": "chorus-one.pool.f863973.m0",
        "public_key": "ed25519:6LFwyEEsqhuDxorWfsKcPPs324zLWTaoqk4o6RDXN7Qc",
        "stake": "110967904880664326100649881128",
        "shards": [0]
      },
      {
        "account_id": "cloudpost.pool.f863973.m0",
        "public_key": "ed25519:AVVLmJDG8z6UgmW9fmJGVFTdYxxfnqXH6c7FVQmhE6dp",
        "stake": "137303582563490110045159846741",
        "shards": [0]
      },
      {
        "account_id": "dokia.pool.f863973.m0",
        "public_key": "ed25519:935JMz1vLcJxFApG3TY4MA4RHhvResvoGwCrQoJxHPn9",
        "stake": "221583843027440134728813179120",
        "shards": [0]
      },
      {
        "account_id": "dsrvlabs.pool.f863973.m0",
        "public_key": "ed25519:61ei2efmmLkeDR1CG6JDEC2U3oZCUuC2K1X16Vmxrud9",
        "stake": "162343309156672629963246208215",
        "shards": [0]
      },
      {
        "account_id": "fresh_lockup.pool.f863973.m0",
        "public_key": "ed25519:7CMFLtEohojtxBkmj9Jb6AGgbphb1zvxymHzpzuyCjfG",
        "stake": "194574146707912827852030100603",
        "shards": [0]
      },
      {
        "account_id": "inotel.pool.f863973.m0",
        "public_key": "ed25519:C55jH1MCHYGa3tzUyZZdGrJmmCLP22Aa4v88KYpn2xwZ",
        "stake": "179521497218882663562358374377",
        "shards": [0]
      },
      {
        "account_id": "jazza.pool.f863973.m0",
        "public_key": "ed25519:85cPMNVrqUz8N7oWbbvWbUuamHcJNe49uRbaSzftLCz9",
        "stake": "156567004141558073310769195719",
        "shards": [0]
      },
      {
        "account_id": "joe1.pool.f863973.m0",
        "public_key": "ed25519:G3SxwzmiEZSm3bHnTLtxJvm3NvT1TLQcWuV1iod6i6NJ",
        "stake": "129898367221448376460128575495",
        "shards": [0]
      },
      {
        "account_id": "kronos.pool.f863973.m0",
        "public_key": "ed25519:3i2pertqzF8xqkJ4BrE4t4r67YiYYrUKCktbqvDgjzuQ",
        "stake": "145291600307308103830278523851",
        "shards": [0]
      },
      {
        "account_id": "kytzu.pool.f863973.m0",
        "public_key": "ed25519:61tgPZpy8tqFeAwG4vtf2ZKCRoENiP2A1TJVWEwnbxZU",
        "stake": "114346099616381729581424582943",
        "shards": [0]
      },
      {
        "account_id": "lowfeevalidation.pool.f863973.m0",
        "public_key": "ed25519:EXyjSMGSnk5uGphF3gVV1jCudaAudbW8imoEccYEJg3V",
        "stake": "114272827178534171015566175242",
        "shards": [0]
      },
      {
        "account_id": "lunanova.pool.f863973.m0",
        "public_key": "ed25519:2fZ59qfo9QHNLijoht9cwUb9enSNcnRmXbQn1gKZxvkw",
        "stake": "173796241314359640924313305613",
        "shards": [0]
      },
      {
        "account_id": "moonlet.pool.f863973.m0",
        "public_key": "ed25519:3e1nVCVGNS3yr6CcUvpDAs3BhiWtyM9uTBWkyVR5Xn3K",
        "stake": "141326111231422084384405939935",
        "shards": [0]
      },
      {
        "account_id": "node0",
        "public_key": "ed25519:7PGseFbWxvYVgZ89K1uTJKYoKetWs7BJtbyXDzfbAcqX",
        "stake": "1917087533938315356792420553580",
        "shards": [0]
      },
      {
        "account_id": "node1",
        "public_key": "ed25519:6DSjZ8mvsRZDvFqFxo8tCKePG96omXW7eVYVSySmDk8e",
        "stake": "1915912070849706566898523265362",
        "shards": [0]
      },
      {
        "account_id": "node2",
        "public_key": "ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5",
        "stake": "1849778202731933988446605407109",
        "shards": [0]
      },
      {
        "account_id": "node3",
        "public_key": "ed25519:ydgzeXHJ5Xyt7M1gXLxqLBW1Ejx6scNV5Nx2pxFM8su",
        "stake": "1253713857932062021626652303305",
        "shards": [0]
      },
      {
        "account_id": "nodeasy.pool.f863973.m0",
        "public_key": "ed25519:25Dhg8NBvQhsVTuugav3t1To1X1zKiomDmnh8yN9hHMb",
        "stake": "132333065508677559475570461579",
        "shards": [0]
      },
      {
        "account_id": "northernlights.stakingpool",
        "public_key": "ed25519:CsMecqKCfagnebMB3ha1uRubay5Z4V85req23bNAJSG3",
        "stake": "160494659810582810750858869593",
        "shards": [0]
      },
      {
        "account_id": "orangeclub.pool.f863973.m0",
        "public_key": "ed25519:HezFeSzcwuR5wvkqccgMCMnpf1eQkVCfk52tXZEdKZHz",
        "stake": "144714977470413958038055754809",
        "shards": [0]
      },
      {
        "account_id": "pathrock.pool.f863973.m0",
        "public_key": "ed25519:G138GdQsU7PdFLD6X88NmTLAEDR7agPcq9HLZqGpegkm",
        "stake": "125851226796631921571804668732",
        "shards": [0]
      },
      {
        "account_id": "pool_easy2stake.pool.f863973.m0",
        "public_key": "ed25519:8nzKxvmyeauQRehWkby8GfWNLgqPiF5FCRFSD75M1Rwh",
        "stake": "177807549352374182247265978294",
        "shards": [0]
      },
      {
        "account_id": "sl1sub.pool.f863973.m0",
        "public_key": "ed25519:3URBpNUjNAMzugQH1rdSKMtwFM8AwHaJgZk5Z6YtnfFL",
        "stake": "156546228606913052982706314599",
        "shards": [0]
      },
      {
        "account_id": "staked.pool.6fb1358",
        "public_key": "ed25519:684rMbuVYYgL2CkmYgC1weLh3erd2bwrmtQtJJhWzPwj",
        "stake": "127566960646771620637977634520",
        "shards": [0]
      },
      {
        "account_id": "staked.pool.f863973.m0",
        "public_key": "ed25519:D2afKYVaKQ1LGiWbMAZRfkKLgqimTR74wvtESvjx5Ft2",
        "stake": "141284196855966747583242721111",
        "shards": [0]
      },
      {
        "account_id": "stakin.pool.f863973.m0",
        "public_key": "ed25519:GvddxjaxBCqGGB4kMNWNFtvozU1EEZ2jrnggKZW8LaU4",
        "stake": "122853080560791799567241762038",
        "shards": [0]
      },
      {
        "account_id": "staking-power.pool.f863973.m0",
        "public_key": "ed25519:4s79F6Fdjgb3rHXPLwaXZG4Hq7Za8nogUu3vXEamRBQo",
        "stake": "113878597697173990840757447344",
        "shards": [0]
      },
      {
        "account_id": "syncnode.pool.f863973.m0",
        "public_key": "ed25519:FUAVDkmLhuTbKYv4GWuWv9ogjKzRatLd5ZBMKXRy7WqE",
        "stake": "134103630138795323490241660174",
        "shards": [0]
      },
      {
        "account_id": "thepassivetrust.pool.f863973.m0",
        "public_key": "ed25519:4NccD2DNJpBkDmWeJ2GbqPoivQ93qcKiR4PHALJKCTod",
        "stake": "163554668234785516757420218799",
        "shards": [0]
      },
      {
        "account_id": "top.pool.f863973.m0",
        "public_key": "ed25519:FR5qxAsP8GgXDN96pappLtWMywiqWsPVqT3HLE3YaUx",
        "stake": "165611741467072665024638629174",
        "shards": [0]
      },
      {
        "account_id": "valeraverim.pool.f863973.m0",
        "public_key": "ed25519:3686ABqNUZc1qhLWLHg5xZpBzrWPiUCMNZxcCNmg3e2s",
        "stake": "192723621295992295990275575014",
        "shards": [0]
      },
      {
        "account_id": "zainy.pool.f863973.m0",
        "public_key": "ed25519:37KfhBNYjqpaUVh3ft5kPcFn3xK1eVvtDZJCQQVCGnzQ",
        "stake": "114027175849273464802110072969",
        "shards": [0]
      },
      {
        "account_id": "zpool.pool.f863973.m0",
        "public_key": "ed25519:ETFRFNHfvd6fpj74MGYYQp3diY8WB4bFmWMxjTB2yY4V",
        "stake": "141660662431449802378487016195",
        "shards": [0]
      }
    ],
    "current_fishermen": [
      {
        "account_id": "staked.stakingpool",
        "public_key": "ed25519:5VmCXxWepj22uFoKmrxk6DTiFa3fuTzDcwGxM8uUErpr",
        "stake": "5957256918881889179239884296"
      },
      {
        "account_id": "bisontrails.stakingpool",
        "public_key": "ed25519:ED2v5KtScbk6aNjGcTn1YMDUu3EXfD5HPt1x6RiYBypk",
        "stake": "7679439354334034871130713908"
      },
      {
        "account_id": "cryptium.stakingpool",
        "public_key": "ed25519:2usUkjmKWxQw7QUeFfELHCEqS2UxjwsRqnCkA5oQ6A2B",
        "stake": "6484546971716985483357166277"
      },
      {
        "account_id": "buildlinks3.pool.f863973.m0",
        "public_key": "ed25519:Cfy8xjSsvVquSqo7W4A2bRX1vkLPycLgyCvFNs3Rz6bb",
        "stake": "81221864655530313350540629757"
      },
      {
        "account_id": "mmm.pool.f863973.m0",
        "public_key": "ed25519:3jEqDDKaJEg1r8UGu2x2dC55BXE7i26yNFQzvfJkkHkf",
        "stake": "80030001196381772535600000000"
      }
    ],
    "next_fishermen": [
      {
        "account_id": "staked.stakingpool",
        "public_key": "ed25519:5VmCXxWepj22uFoKmrxk6DTiFa3fuTzDcwGxM8uUErpr",
        "stake": "5957256918881889179239884296"
      },
      {
        "account_id": "bisontrails.stakingpool",
        "public_key": "ed25519:ED2v5KtScbk6aNjGcTn1YMDUu3EXfD5HPt1x6RiYBypk",
        "stake": "7679439354334034871130713908"
      },
      {
        "account_id": "cryptium.stakingpool",
        "public_key": "ed25519:2usUkjmKWxQw7QUeFfELHCEqS2UxjwsRqnCkA5oQ6A2B",
        "stake": "6484546971716985483357166277"
      },
      {
        "account_id": "buildlinks3.pool.f863973.m0",
        "public_key": "ed25519:Cfy8xjSsvVquSqo7W4A2bRX1vkLPycLgyCvFNs3Rz6bb",
        "stake": "81221864655530313350540629757"
      },
      {
        "account_id": "mmm.pool.f863973.m0",
        "public_key": "ed25519:3jEqDDKaJEg1r8UGu2x2dC55BXE7i26yNFQzvfJkkHkf",
        "stake": "80030001196381772535600000000"
      }
    ],
    "current_proposals": [
      {
        "account_id": "kytzu.pool.f863973.m0",
        "public_key": "ed25519:61tgPZpy8tqFeAwG4vtf2ZKCRoENiP2A1TJVWEwnbxZU",
        "stake": "114346100195275968419224582943"
      },
      {
        "account_id": "nodeasy.pool.f863973.m0",
        "public_key": "ed25519:25Dhg8NBvQhsVTuugav3t1To1X1zKiomDmnh8yN9hHMb",
        "stake": "132333066144809013154670461579"
      },
      {
        "account_id": "thepassivetrust.pool.f863973.m0",
        "public_key": "ed25519:4NccD2DNJpBkDmWeJ2GbqPoivQ93qcKiR4PHALJKCTod",
        "stake": "163554672455685458970920218837"
      }
    ],
    "prev_epoch_kickout": [],
    "epoch_start_height": 17754191,
    "epoch_height": 321
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What could go wrong? {#what-could-go-wrong-2}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `validators` method:

<table>
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HANDLER_ERROR</td>
      <td>UNKNOWN_EPOCH</td>
      <td>An epoch for the provided block can't be found in a database</td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>If the block had been produced more than 5 epochs ago, try to send your request to an archival node</li>
          <li>Check that the requested block is the last block of some epoch</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

'''
'''--- docs/5.api/rpc/protocol.md ---
---
id: protocol
title: Protocol
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The RPC API enables you to retrieve the current genesis and protocol configuration.

---

## Genesis Config {#genesis-config}

> Returns current genesis configuration.

- method: `EXPERIMENTAL_genesis_config`
- params: _none_

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_genesis_config"
}
```

</TabItem>
<TabItem value="js" label="üåê JavaScript" label="JavaScript">

```js
const response = await near.connection.provider.experimental_genesisConfig();
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_genesis_config
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "protocol_version": 29,
    "genesis_time": "2020-07-31T03:39:42.911378Z",
    "chain_id": "testnet",
    "genesis_height": 10885359,
    "num_block_producer_seats": 100,
    "num_block_producer_seats_per_shard": [100],
    "avg_hidden_validator_seats_per_shard": [0],
    "dynamic_resharding": false,
    "protocol_upgrade_stake_threshold": [4, 5],
    "protocol_upgrade_num_epochs": 2,
    "epoch_length": 43200,
    "gas_limit": 1000000000000000,
    "min_gas_price": "5000",
    "max_gas_price": "10000000000000000000000",
    "block_producer_kickout_threshold": 80,
    "chunk_producer_kickout_threshold": 90,
    "online_min_threshold": [90, 100],
    "online_max_threshold": [99, 100],
    "gas_price_adjustment_rate": [1, 100],
    "runtime_config": {
      "storage_amount_per_byte": "90949470177292823791",
      "transaction_costs": {
        "action_receipt_creation_config": {
          "send_sir": 108059500000,
          "send_not_sir": 108059500000,
          "execution": 108059500000
        },
        "data_receipt_creation_config": {
          "base_cost": {
            "send_sir": 4697339419375,
            "send_not_sir": 4697339419375,
            "execution": 4697339419375
          },
          "cost_per_byte": {
            "send_sir": 59357464,
            "send_not_sir": 59357464,
            "execution": 59357464
          }
        },
        "action_creation_config": {
          "create_account_cost": {
            "send_sir": 99607375000,
            "send_not_sir": 99607375000,
            "execution": 99607375000
          },
          "deploy_contract_cost": {
            "send_sir": 184765750000,
            "send_not_sir": 184765750000,
            "execution": 184765750000
          },
          "deploy_contract_cost_per_byte": {
            "send_sir": 6812999,
            "send_not_sir": 6812999,
            "execution": 6812999
          },
          "function_call_cost": {
            "send_sir": 2319861500000,
            "send_not_sir": 2319861500000,
            "execution": 2319861500000
          },
          "function_call_cost_per_byte": {
            "send_sir": 2235934,
            "send_not_sir": 2235934,
            "execution": 2235934
          },
          "transfer_cost": {
            "send_sir": 115123062500,
            "send_not_sir": 115123062500,
            "execution": 115123062500
          },
          "stake_cost": {
            "send_sir": 141715687500,
            "send_not_sir": 141715687500,
            "execution": 102217625000
          },
          "add_key_cost": {
            "full_access_cost": {
              "send_sir": 101765125000,
              "send_not_sir": 101765125000,
              "execution": 101765125000
            },
            "function_call_cost": {
              "send_sir": 102217625000,
              "send_not_sir": 102217625000,
              "execution": 102217625000
            },
            "function_call_cost_per_byte": {
              "send_sir": 1925331,
              "send_not_sir": 1925331,
              "execution": 1925331
            }
          },
          "delete_key_cost": {
            "send_sir": 94946625000,
            "send_not_sir": 94946625000,
            "execution": 94946625000
          },
          "delete_account_cost": {
            "send_sir": 147489000000,
            "send_not_sir": 147489000000,
            "execution": 147489000000
          }
        },
        "storage_usage_config": {
          "num_bytes_account": 100,
          "num_extra_bytes_record": 40
        },
        "burnt_gas_reward": [3, 10],
        "pessimistic_gas_price_inflation_ratio": [103, 100]
      },
      "wasm_config": {
        "ext_costs": {
          "base": 264768111,
          "contract_compile_base": 35445963,
          "contract_compile_bytes": 216750,
          "read_memory_base": 2609863200,
          "read_memory_byte": 3801333,
          "write_memory_base": 2803794861,
          "write_memory_byte": 2723772,
          "read_register_base": 2517165186,
          "read_register_byte": 98562,
          "write_register_base": 2865522486,
          "write_register_byte": 3801564,
          "utf8_decoding_base": 3111779061,
          "utf8_decoding_byte": 291580479,
          "utf16_decoding_base": 3543313050,
          "utf16_decoding_byte": 163577493,
          "sha256_base": 4540970250,
          "sha256_byte": 24117351,
          "keccak256_base": 5879491275,
          "keccak256_byte": 21471105,
          "keccak512_base": 5811388236,
          "keccak512_byte": 36649701,
          "log_base": 3543313050,
          "log_byte": 13198791,
          "storage_write_base": 64196736000,
          "storage_write_key_byte": 70482867,
          "storage_write_value_byte": 31018539,
          "storage_write_evicted_byte": 32117307,
          "storage_read_base": 56356845750,
          "storage_read_key_byte": 30952533,
          "storage_read_value_byte": 5611005,
          "storage_remove_base": 53473030500,
          "storage_remove_key_byte": 38220384,
          "storage_remove_ret_value_byte": 11531556,
          "storage_has_key_base": 54039896625,
          "storage_has_key_byte": 30790845,
          "storage_iter_create_prefix_base": 0,
          "storage_iter_create_prefix_byte": 0,
          "storage_iter_create_range_base": 0,
          "storage_iter_create_from_byte": 0,
          "storage_iter_create_to_byte": 0,
          "storage_iter_next_base": 0,
          "storage_iter_next_key_byte": 0,
          "storage_iter_next_value_byte": 0,
          "touching_trie_node": 16101955926,
          "promise_and_base": 1465013400,
          "promise_and_per_promise": 5452176,
          "promise_return": 560152386,
          "validator_stake_base": 911834726400,
          "validator_total_stake_base": 911834726400
        },
        "grow_mem_cost": 1,
        "regular_op_cost": 3856371,
        "limit_config": {
          "max_gas_burnt": 200000000000000,
          "max_gas_burnt_view": 200000000000000,
          "max_stack_height": 16384,
          "initial_memory_pages": 1024,
          "max_memory_pages": 2048,
          "registers_memory_limit": 1073741824,
          "max_register_size": 104857600,
          "max_number_registers": 100,
          "max_number_logs": 100,
          "max_total_log_length": 16384,
          "max_total_prepaid_gas": 300000000000000,
          "max_actions_per_receipt": 100,
          "max_number_bytes_method_names": 2000,
          "max_length_method_name": 256,
          "max_arguments_length": 4194304,
          "max_length_returned_data": 4194304,
          "max_contract_size": 4194304,
          "max_length_storage_key": 4194304,
          "max_length_storage_value": 4194304,
          "max_promises_per_function_call_action": 1024,
          "max_number_input_data_dependencies": 128
        }
      },
      "account_creation_config": {
        "min_allowed_top_level_account_length": 0,
        "registrar_account_id": "registrar"
      }
    },
    "validators": [
      {
        "account_id": "node0",
        "public_key": "ed25519:7PGseFbWxvYVgZ89K1uTJKYoKetWs7BJtbyXDzfbAcqX",
        "amount": "1000000000000000000000000000000"
      },
      {
        "account_id": "node1",
        "public_key": "ed25519:6DSjZ8mvsRZDvFqFxo8tCKePG96omXW7eVYVSySmDk8e",
        "amount": "1000000000000000000000000000000"
      },
      {
        "account_id": "node2",
        "public_key": "ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5",
        "amount": "1000000000000000000000000000000"
      },
      {
        "account_id": "node3",
        "public_key": "ed25519:ydgzeXHJ5Xyt7M1gXLxqLBW1Ejx6scNV5Nx2pxFM8su",
        "amount": "1000000000000000000000000000000"
      }
    ],
    "transaction_validity_period": 86400,
    "protocol_reward_rate": [1, 10],
    "max_inflation_rate": [1, 20],
    "total_supply": "1031467299046044096035532756810080",
    "num_blocks_per_year": 31536000,
    "protocol_treasury_account": "near",
    "fishermen_threshold": "10000000000000000000",
    "minimum_stake_divisor": 10
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What could go wrong? {#what-could-go-wrong}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `EXPERIMENTAL_genesis_config` method:

<table>
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

## Protocol Config {#protocol-config}

> Returns most recent protocol configuration or a specific queried block. Useful for finding current storage and transaction costs.

- method: `EXPERIMENTAL_protocol_config`
- params:
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_protocol_config",
  "params": {
    "finality": "final"
  }
}
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_protocol_config \
  params:='{
    "finality": "final"
  }'
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "protocol_version": 45,
    "genesis_time": "2020-07-31T03:39:42.911378Z",
    "chain_id": "testnet",
    "genesis_height": 42376888,
    "num_block_producer_seats": 200,
    "num_block_producer_seats_per_shard": [200],
    "avg_hidden_validator_seats_per_shard": [0],
    "dynamic_resharding": false,
    "protocol_upgrade_stake_threshold": [4, 5],
    "epoch_length": 43200,
    "gas_limit": 1000000000000000,
    "min_gas_price": "5000",
    "max_gas_price": "10000000000000000000000",
    "block_producer_kickout_threshold": 80,
    "chunk_producer_kickout_threshold": 90,
    "online_min_threshold": [90, 100],
    "online_max_threshold": [99, 100],
    "gas_price_adjustment_rate": [1, 100],
    "runtime_config": {
      "storage_amount_per_byte": "10000000000000000000",
      "transaction_costs": {
        "action_receipt_creation_config": {
          "send_sir": 108059500000,
          "send_not_sir": 108059500000,
          "execution": 108059500000
        },
        "data_receipt_creation_config": {
          "base_cost": {
            "send_sir": 4697339419375,
            "send_not_sir": 4697339419375,
            "execution": 4697339419375
          },
          "cost_per_byte": {
            "send_sir": 59357464,
            "send_not_sir": 59357464,
            "execution": 59357464
          }
        },
        "action_creation_config": {
          "create_account_cost": {
            "send_sir": 99607375000,
            "send_not_sir": 99607375000,
            "execution": 99607375000
          },
          "deploy_contract_cost": {
            "send_sir": 184765750000,
            "send_not_sir": 184765750000,
            "execution": 184765750000
          },
          "deploy_contract_cost_per_byte": {
            "send_sir": 6812999,
            "send_not_sir": 6812999,
            "execution": 6812999
          },
          "function_call_cost": {
            "send_sir": 2319861500000,
            "send_not_sir": 2319861500000,
            "execution": 2319861500000
          },
          "function_call_cost_per_byte": {
            "send_sir": 2235934,
            "send_not_sir": 2235934,
            "execution": 2235934
          },
          "transfer_cost": {
            "send_sir": 115123062500,
            "send_not_sir": 115123062500,
            "execution": 115123062500
          },
          "stake_cost": {
            "send_sir": 141715687500,
            "send_not_sir": 141715687500,
            "execution": 102217625000
          },
          "add_key_cost": {
            "full_access_cost": {
              "send_sir": 101765125000,
              "send_not_sir": 101765125000,
              "execution": 101765125000
            },
            "function_call_cost": {
              "send_sir": 102217625000,
              "send_not_sir": 102217625000,
              "execution": 102217625000
            },
            "function_call_cost_per_byte": {
              "send_sir": 1925331,
              "send_not_sir": 1925331,
              "execution": 1925331
            }
          },
          "delete_key_cost": {
            "send_sir": 94946625000,
            "send_not_sir": 94946625000,
            "execution": 94946625000
          },
          "delete_account_cost": {
            "send_sir": 147489000000,
            "send_not_sir": 147489000000,
            "execution": 147489000000
          }
        },
        "storage_usage_config": {
          "num_bytes_account": 100,
          "num_extra_bytes_record": 40
        },
        "burnt_gas_reward": [3, 10],
        "pessimistic_gas_price_inflation_ratio": [103, 100]
      },
      "wasm_config": {
        "ext_costs": {
          "base": 264768111,
          "contract_compile_base": 35445963,
          "contract_compile_bytes": 216750,
          "read_memory_base": 2609863200,
          "read_memory_byte": 3801333,
          "write_memory_base": 2803794861,
          "write_memory_byte": 2723772,
          "read_register_base": 2517165186,
          "read_register_byte": 98562,
          "write_register_base": 2865522486,
          "write_register_byte": 3801564,
          "utf8_decoding_base": 3111779061,
          "utf8_decoding_byte": 291580479,
          "utf16_decoding_base": 3543313050,
          "utf16_decoding_byte": 163577493,
          "sha256_base": 4540970250,
          "sha256_byte": 24117351,
          "keccak256_base": 5879491275,
          "keccak256_byte": 21471105,
          "keccak512_base": 5811388236,
          "keccak512_byte": 36649701,
          "log_base": 3543313050,
          "log_byte": 13198791,
          "storage_write_base": 64196736000,
          "storage_write_key_byte": 70482867,
          "storage_write_value_byte": 31018539,
          "storage_write_evicted_byte": 32117307,
          "storage_read_base": 56356845750,
          "storage_read_key_byte": 30952533,
          "storage_read_value_byte": 5611005,
          "storage_remove_base": 53473030500,
          "storage_remove_key_byte": 38220384,
          "storage_remove_ret_value_byte": 11531556,
          "storage_has_key_base": 54039896625,
          "storage_has_key_byte": 30790845,
          "storage_iter_create_prefix_base": 0,
          "storage_iter_create_prefix_byte": 0,
          "storage_iter_create_range_base": 0,
          "storage_iter_create_from_byte": 0,
          "storage_iter_create_to_byte": 0,
          "storage_iter_next_base": 0,
          "storage_iter_next_key_byte": 0,
          "storage_iter_next_value_byte": 0,
          "touching_trie_node": 16101955926,
          "promise_and_base": 1465013400,
          "promise_and_per_promise": 5452176,
          "promise_return": 560152386,
          "validator_stake_base": 911834726400,
          "validator_total_stake_base": 911834726400
        },
        "grow_mem_cost": 1,
        "regular_op_cost": 3856371,
        "limit_config": {
          "max_gas_burnt": 200000000000000,
          "max_gas_burnt_view": 200000000000000,
          "max_stack_height": 16384,
          "initial_memory_pages": 1024,
          "max_memory_pages": 2048,
          "registers_memory_limit": 1073741824,
          "max_register_size": 104857600,
          "max_number_registers": 100,
          "max_number_logs": 100,
          "max_total_log_length": 16384,
          "max_total_prepaid_gas": 300000000000000,
          "max_actions_per_receipt": 100,
          "max_number_bytes_method_names": 2000,
          "max_length_method_name": 256,
          "max_arguments_length": 4194304,
          "max_length_returned_data": 4194304,
          "max_contract_size": 4194304,
          "max_length_storage_key": 4194304,
          "max_length_storage_value": 4194304,
          "max_promises_per_function_call_action": 1024,
          "max_number_input_data_dependencies": 128
        }
      },
      "account_creation_config": {
        "min_allowed_top_level_account_length": 0,
        "registrar_account_id": "registrar"
      }
    },
    "transaction_validity_period": 86400,
    "protocol_reward_rate": [1, 10],
    "max_inflation_rate": [1, 20],
    "num_blocks_per_year": 31536000,
    "protocol_treasury_account": "near",
    "fishermen_threshold": "340282366920938463463374607431768211455",
    "minimum_stake_divisor": 10
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What could go wrong? {#what-could-go-wrong-1}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `EXPERIMENTAL_protocol_config` method:

<table>
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>The requested block has not been produced yet or it has been garbage-collected (cleaned up to save space on the RPC node)</td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>If the block had been produced more than 5 epochs ago, try to send your request to <a href="https://near-nodes.io/intro/node-types#archival-node">an archival node</a></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

'''
'''--- docs/5.api/rpc/providers.md ---
---
id: providers
title: RPC Providers
---

There are multiple RPC providers from which you can choose from. These providers will work as intermediaries to help you interact with the NEAR network.
You'll experience different latency levels depending on the provider's location. You can potentially use multiple providers for redundancy and
balancing.

:::tip

If you want to use a custom RPC provider with NEAR Wallet Selector, [check this example](../../2.build/4.web3-apps/integrate-contracts.md#setting-customs-rpc-endpoints).

:::

| Provider                                                                   | Endpoint Root                                                |
| -------------------------------------------------------------------------- | ------------------------------------------------------------ |
| [NEAR](setup.md)                                                           | `https://rpc.mainnet.near.org`                               |
| [Pagoda](https://www.pagoda.co/console)                                    | `https://near-mainnet.api.pagoda.co/rpc/v1`                  |
| [1RPC](https://docs.1rpc.io/overview/about-1rpc)                           | `https://1rpc.io/near`                                       |
| [All That Node](https://docs.allthatnode.com/protocols/near/)              | `https://near-mainnet-rpc.allthatnode.com:3030`              |
| [ankr.com](https://www.ankr.com/docs/rpc-service/chains/chains-list/#near) | `https://rpc.ankr.com/near`                                  |
| [BlockPi](https://chains.blockpi.io/#/near)                                | `https://public-rpc.blockpi.io/http/near`                    |
| [dRPC](https://drpc.org/)                                                  | `https://near.drpc.org`                                      |
| [fast-near web4](https://github.com/vgrichina/fast-near)                   | `https://rpc.web4.near.page`                                 |
| [FASTNEAR Free](https://twitter.com/fast_near/status/1779578631318368269)  | `https://free.rpc.fastnear.com`                              |
| [Gateway.fm](https://gateway.fm/)                                          | `https://rpc.near.gateway.fm/`                               |
| [GetBlock](https://getblock.io/nodes/near/)                                | `https://getblock.io/nodes/near/`                            |
| [Lava Network](https://www.lavanet.xyz/get-started/near)                   | `https://near.lava.build`                                    |
| [Lavender.Five Nodes](https://lavenderfive.com/)                           | `https://near.lavenderfive.com/`                             |
| [NodeReal](https://nodereal.io)                                            | `https://nodereal.io/api-marketplace/near-rpc`               |
| [NOWNodes](https://nownodes.io/)                                           | `https://near.nownodes.io/`                                  |
| [OMNIA](https://omniatech.io)                                              | `https://endpoints.omniatech.io/v1/near/mainnet/public`      |
| [QuickNode](https://www.quicknode.com/chains/near)                         | -                                                            |
| [Seracle](https://docs.seracle.com/)                                       | `https://api.seracle.com/saas/baas/rpc/near/mainnet/public/` |
| [Zeeve](https://www.zeeve.io/)                                             | -                                                            |

'''
'''--- docs/5.api/rpc/setup.md ---
---
id: setup
title: Setup 
---

In order to use the RPC API you will need to setup the correct RPC endpoints.

<hr className="subsection" />

## RPC Endpoint Setup
- `POST` for all methods
- `JSON RPC 2.0`
- `id: "dontcare"`
- endpoint URL varies by network:
  - mainnet `https://rpc.mainnet.near.org`
  - testnet `https://rpc.testnet.near.org`
  - betanet `https://rpc.betanet.near.org` _(may be unstable)_
  - localnet `http://localhost:3030`

### Limits
- Maximum number of requests per IP: 600 req/min

<hr className="subsection" />

## Querying Historical Data
Querying historical data (older than 5 [epochs](../../1.concepts/basics/epoch.md) or ~2.5 days), you may get responses that the data is not available anymore. In that case, archival RPC nodes will come to your rescue:

- mainnet `https://archival-rpc.mainnet.near.org`
- testnet `https://archival-rpc.testnet.near.org`

You can see this interface defined in `nearcore` [here](https://github.com/near/nearcore/blob/bf9ae4ce8c680d3408db1935ebd0ca24c4960884/chain/jsonrpc/client/src/lib.rs#L181).

### Limits
- Maximum number of requests per IP: 600 req/min

---

## Postman Setup {#postman-setup}

An easy way to test the queries in this documentation page is to use an API request tool such as [Postman](https://www.postman.com/).
You only need to configure two things:

1. Make sure you add a header with a key of `Content-Type` and value of `application/json`.
   ![postman-setup-header](/docs/assets/postman-setup-headers.png)

2. Then select the `Body` tab and choose the `raw` radio button and ensure `JSON` is the selected format.
   ![postman-setup-header](/docs/assets/postman-setup-body.png)

After that is set up, just copy/paste the `JSON object` example snippets below into the `body` of your request, on Postman, and click `send`.

---
## JavaScript Setup {#javascript-setup}

All of the queries listed in this documentation page can be called using [`near-api-js`](https://github.com/near/near-api-js).

- For `near-api-js` installation and setup please refer to `near-api-js` [quick reference documentation](/tools/near-api-js/quick-reference).
- All JavaScript code snippets require a `near` object. For examples of how to instantiate, [**click here**](/tools/near-api-js/quick-reference#connect).

---
## HTTPie Setup {#httpie-setup}

If you prefer to use a command line interface, we have provided RPC examples you can use with [HTTPie](https://httpie.org/). Please note that params take
either an object or array passed as a string.

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=network_info params:='[]'
```

---

## Using `block_id` param {#using-block_id-param}

The `block_id` param can take either the block number (e.g. `27912554`) or the block hash (e.g. `'3Xz2wM9rigMXzA2c5vgCP8wTgFBaePucgUmVYPkMqhRL'` ) as an argument.

:::caution

The block IDs of transactions shown in [NearBlocks Explorer](https://testnet.nearblocks.io) are not necessarily the block ID of the executed transaction. Transactions may execute a block or two after its recorded, and in some cases, can take place over several blocks. Due to this, it is important to to check subsequent blocks to be sure all results related to the queried transaction are discovered.

:::

---

## Using `finality` param {#using-finality-param}

The `finality` param has two options: `optimistic` and `final`.
1. `optimistic` uses the latest block recorded on the node that responded to your query _(< 1 second delay after the transaction is submitted)_
2. `final` is for a block that has been validated on at least 66% of the nodes in the network _(usually takes 2 blocks / approx. 2 second delay)_

'''
'''--- docs/5.api/rpc/transactions.md ---
---
id: transactions
title: RPC Endpoints
sidebar_label: Transactions
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The RPC API enables you to send transactions and query their status.

---

## Send transaction {#send-tx}

> Sends transaction.
> Returns the guaranteed execution status and the results the blockchain can provide at the moment.

- method: `send_tx`
- params: 
  - `signed_tx_base64`: SignedTransaction encoded in base64
  - [Optional] `wait_until`: the required minimal execution level. [Read more here](#tx-status-result). The default value is `EXECUTED_OPTIMISTIC`.

Using `send_tx` with `wait_until = NONE` is equal to legacy `broadcast_tx_async` method.  
Using `send_tx` with finality `wait_until = EXECUTED_OPTIMISTIC` is equal to legacy `broadcast_tx_commit` method.

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "send_tx",
  "params": {
    "signed_tx_base64": "DgAAAHNlbmRlci50ZXN0bmV0AOrmAai64SZOv9e/naX4W15pJx0GAap35wTT1T/DwcbbDwAAAAAAAAAQAAAAcmVjZWl2ZXIudGVzdG5ldNMnL7URB1cxPOu3G8jTqlEwlcasagIbKlAJlF5ywVFLAQAAAAMAAACh7czOG8LTAAAAAAAAAGQcOG03xVSFQFjoagOb4NBBqWhERnnz45LY4+52JgZhm1iQKz7qAdPByrGFDQhQ2Mfga8RlbysuQ8D8LlA6bQE=",
    "wait_until": "INCLUDED_FINAL"
  }
}
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=send_tx \
    params:='{
      "signed_tx_base64": "DgAAAHNlbmRlci50ZXN0bmV0AOrmAai64SZOv9e/naX4W15pJx0GAap35wTT1T/DwcbbDwAAAAAAAAAQAAAAcmVjZWl2ZXIudGVzdG5ldNMnL7URB1cxPOu3G8jTqlEwlcasagIbKlAJlF5ywVFLAQAAAAMAAACh7czOG8LTAAAAAAAAAGQcOG03xVSFQFjoagOb4NBBqWhERnnz45LY4+52JgZhm1iQKz7qAdPByrGFDQhQ2Mfga8RlbysuQ8D8LlA6bQE=",
      "wait_until": "EXECUTED"
    }'
```

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=send_tx \
    params:='{
      "signed_tx_base64": "DgAAAHNlbmRlci50ZXN0bmV0AOrmAai64SZOv9e/naX4W15pJx0GAap35wTT1T/DwcbbDwAAAAAAAAAQAAAAcmVjZWl2ZXIudGVzdG5ldNMnL7URB1cxPOu3G8jTqlEwlcasagIbKlAJlF5ywVFLAQAAAAMAAACh7czOG8LTAAAAAAAAAGQcOG03xVSFQFjoagOb4NBBqWhERnnz45LY4+52JgZhm1iQKz7qAdPByrGFDQhQ2Mfga8RlbysuQ8D8LlA6bQE="
    }'
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "final_execution_status": "FINAL",
    "status": {
      "SuccessValue": ""
    },
    "transaction": {
      "signer_id": "sender.testnet",
      "public_key": "ed25519:Gowpa4kXNyTMRKgt5W7147pmcc2PxiFic8UHW9rsNvJ6",
      "nonce": 13,
      "receiver_id": "receiver.testnet",
      "actions": [
        {
          "Transfer": {
            "deposit": "1000000000000000000000000"
          }
        }
      ],
      "signature": "ed25519:7oCBMfSHrZkT7tzPDBxxCd3tWFhTES38eks3MCZMpYPJRfPWKxJsvmwQiVBBxRLoxPTnXVaMU2jPV3MdFKZTobH",
      "hash": "ASS7oYwGiem9HaNwJe6vS2kznx2CxueKDvU9BAYJRjNR"
    },
    "transaction_outcome": {
      "proof": [],
      "block_hash": "9MzuZrRPW1BGpFnZJUJg6SzCrixPpJDfjsNeUobRXsLe",
      "id": "ASS7oYwGiem9HaNwJe6vS2kznx2CxueKDvU9BAYJRjNR",
      "outcome": {
        "logs": [],
        "receipt_ids": ["BLV2q6p8DX7pVgXRtGtBkyUNrnqkNyU7iSksXG7BjVZh"],
        "gas_burnt": 223182562500,
        "tokens_burnt": "22318256250000000000",
        "executor_id": "sender.testnet",
        "status": {
          "SuccessReceiptId": "BLV2q6p8DX7pVgXRtGtBkyUNrnqkNyU7iSksXG7BjVZh"
        }
      }
    },
    "receipts_outcome": [
      {
        "proof": [],
        "block_hash": "5Hpj1PeCi32ZkNXgiD1DrW4wvW4Xtic74DJKfyJ9XL3a",
        "id": "BLV2q6p8DX7pVgXRtGtBkyUNrnqkNyU7iSksXG7BjVZh",
        "outcome": {
          "logs": [],
          "receipt_ids": ["3sawynPNP8UkeCviGqJGwiwEacfPyxDKRxsEWPpaUqtR"],
          "gas_burnt": 223182562500,
          "tokens_burnt": "22318256250000000000",
          "executor_id": "receiver.testnet",
          "status": {
            "SuccessValue": ""
          }
        }
      },
      {
        "proof": [],
        "block_hash": "CbwEqMpPcu6KwqVpBM3Ry83k6M4H1FrJjES9kBXThcRd",
        "id": "3sawynPNP8UkeCviGqJGwiwEacfPyxDKRxsEWPpaUqtR",
        "outcome": {
          "logs": [],
          "receipt_ids": [],
          "gas_burnt": 0,
          "tokens_burnt": "0",
          "executor_id": "sender.testnet",
          "status": {
            "SuccessValue": ""
          }
        }
      }
    ]
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What could go wrong? {#what-could-go-wrong-send-tx}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `broadcast_tx_commit` method:

<table className="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">HANDLER_ERROR</td>
      <td>INVALID_TRANSACTION</td>
      <td>An error happened during transaction execution</td>
      <td>
        <ul>
          <li>See <code>error.cause.info</code> for details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>TIMEOUT_ERROR</td>
      <td>Transaction was routed, but has not been recorded on chain in 10 seconds.</td>
      <td>
        <ul>
          <li> Re-submit the request with the identical transaction (in NEAR Protocol unique transactions apply exactly once, so if the previously sent transaction gets applied, this request will just return the known result, otherwise, it will route the transaction to the chain once again)</li>
          <li>Check that your transaction is valid</li>
          <li>Check that the signer account id has enough tokens to cover the transaction fees (keep in mind that some tokens on each account are locked to cover the storage cost)</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

## Transaction Status {#transaction-status}

> Queries status of a transaction by hash and returns the final transaction result.

- method: `tx`
- params:
  - `tx_hash` _(see [NearBlocks Explorer](https://testnet.nearblocks.io) for a valid transaction hash)_
  - `sender_account_id` _(used to determine which shard to query for transaction)_
  - [Optional] `wait_until`: the required minimal execution level. Read more [here](/api/rpc/transactions#tx-status-result). The default value is `EXECUTED_OPTIMISTIC`.

A Transaction status request with `wait_until != NONE` will wait until the transaction appears on the blockchain.
If the transaction does not exist, the method will wait until the timeout is reached.
If you only need to check whether the transaction exists, use `wait_until = NONE`, it will return the response immediately.

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "tx",
  "params": {
    "tx_hash": "6zgh2u9DqHHiXzdy9ouTP7oGky2T4nugqzqt9wJZwNFm",
    "sender_account_id": "sender.testnet",
    "wait_until": "EXECUTED"
  }
}
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=tx \
    params:='{"tx_hash": "6zgh2u9DqHHiXzdy9ouTP7oGky2T4nugqzqt9wJZwNFm", "sender_account_id": "sender.testnet"}'
```

</TabItem>
</Tabs>

<details>
<summary>Example Result:</summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "final_execution_status": "FINAL",
    "status": {
      "SuccessValue": ""
    },
    "transaction": {
      "signer_id": "sender.testnet",
      "public_key": "ed25519:Gowpa4kXNyTMRKgt5W7147pmcc2PxiFic8UHW9rsNvJ6",
      "nonce": 15,
      "receiver_id": "receiver.testnet",
      "actions": [
        {
          "Transfer": {
            "deposit": "1000000000000000000000000"
          }
        }
      ],
      "signature": "ed25519:3168QMdTpcwHvM1dmMYBc8hg9J3Wn8n7MWBSE9WrEpns6P5CaY87RM6k4uzyBkQuML38CZhU18HzmQEevPG1zCvk",
      "hash": "6zgh2u9DqHHiXzdy9ouTP7oGky2T4nugqzqt9wJZwNFm"
    },
    "transaction_outcome": {
      "proof": [
        {
          "hash": "F7mL76CMdfbdZ3xCehVGNh1fCyaR37gr3MeGX3EZkiVf",
          "direction": "Right"
        }
      ],
      "block_hash": "ADTMLVtkhsvzUxuf6m87Pt1dnF5vi1yY7ftxmNpFx7y",
      "id": "6zgh2u9DqHHiXzdy9ouTP7oGky2T4nugqzqt9wJZwNFm",
      "outcome": {
        "logs": [],
        "receipt_ids": ["3dMfwczW5GQqXbD9GMTnmf8jy5uACxG6FC5dWxm3KcXT"],
        "gas_burnt": 223182562500,
        "tokens_burnt": "22318256250000000000",
        "executor_id": "sender.testnet",
        "status": {
          "SuccessReceiptId": "3dMfwczW5GQqXbD9GMTnmf8jy5uACxG6FC5dWxm3KcXT"
        }
      }
    },
    "receipts_outcome": [
      {
        "proof": [
          {
            "hash": "6h95oEd7ih62KXfyPT4zsZYont4qy9sWEXc5VQVDhqtG",
            "direction": "Right"
          },
          {
            "hash": "6DnibgZk1T669ZprcehUy1GpCSPw1kjzXRGu69nSaUNn",
            "direction": "Right"
          }
        ],
        "block_hash": "GgFTVr33r4MrpAiHc9mr8TZqLnpZAX1BaZTNvhBnciy2",
        "id": "3dMfwczW5GQqXbD9GMTnmf8jy5uACxG6FC5dWxm3KcXT",
        "outcome": {
          "logs": [],
          "receipt_ids": ["46KYgN8ddxs4Qy8C7BDQH49XUfcYZsaQmAvdU1nfcL9V"],
          "gas_burnt": 223182562500,
          "tokens_burnt": "22318256250000000000",
          "executor_id": "receiver.testnet",
          "status": {
            "SuccessValue": ""
          }
        }
      },
      {
        "proof": [
          {
            "hash": "CD9Y7Bw3MSFgaPZzpc1yP51ajhGDCAsR61qXcMNcRoHf",
            "direction": "Left"
          }
        ],
        "block_hash": "EGAgKuW6Bd6QKYSaxAkx2pPGmnjrjAcq4UpoUiqMXvPH",
        "id": "46KYgN8ddxs4Qy8C7BDQH49XUfcYZsaQmAvdU1nfcL9V",
        "outcome": {
          "logs": [],
          "receipt_ids": [],
          "gas_burnt": 0,
          "tokens_burnt": "0",
          "executor_id": "sender.testnet",
          "status": {
            "SuccessValue": ""
          }
        }
      }
    ]
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What could go wrong? {#what-could-go-wrong-2}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `tx` method:

<table className="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="3">HANDLER_ERROR</td>
      <td>INVALID_TRANSACTION</td>
      <td>An error happened during transaction execution</td>
      <td>
        <ul>
          <li>See <code>error.cause.info</code> for details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_TRANSACTION</td>
      <td>The requested transaction is not available on the node since it might have not been recorded on the chain yet or has been garbage-collected</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>If the transaction had been submitted more than 5 epochs ago, try to send your request to <a href="https://near-nodes.io/intro/node-types#archival-node">an archival node</a></li>
          <li>Check the transaction hash</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>TIMEOUT_ERROR</td>
      <td>It was unable to wait for the transaction status for reasonable time</td>
      <td>
        <ul>
          <li>Send a request to a different node</li>
          <li>Try again later</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

## Transaction Status with Receipts {#transaction-status-with-receipts}

> Queries status of a transaction by hash, returning the final transaction result _and_ details of all receipts.

- method: `EXPERIMENTAL_tx_status`
- params:
  - `tx_hash` _(see [NearBlocks Explorer](https://testnet.nearblocks.io) for a valid transaction hash)_
  - `sender_account_id` _(used to determine which shard to query for transaction)_
  - [Optional] `wait_until`: the required minimal execution level. Read more [here](/api/rpc/transactions#tx-status-result). The default value is `EXECUTED_OPTIMISTIC`.

A Transaction status request with `wait_until != NONE` will wait until the transaction appears on the blockchain.
If the transaction does not exist, the method will wait until the timeout is reached.
If you only need to check whether the transaction exists, use `wait_until = NONE`, it will return the response immediately.

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_tx_status",
  "params": {
    "tx_hash": "HEgnVQZfs9uJzrqTob4g2Xmebqodq9waZvApSkrbcAhd",
    "sender_account_id": "bowen",
    "wait_until": "EXECUTED"
  }
}
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 method=EXPERIMENTAL_tx_status params:='{"tx_hash": "HEgnVQZfs9uJzrqTob4g2Xmebqodq9waZvApSkrbcAhd", "sender_account_id": "bowen"}' id=dontcare
```

</TabItem>
</Tabs>

<details>
<summary>Example response:</summary>
<p>

```json
{
  "id": "123",
  "jsonrpc": "2.0",
  "result": {
    "final_execution_status": "FINAL",
    "receipts": [
      {
        "predecessor_id": "bowen",
        "receipt": {
          "Action": {
            "actions": [
              {
                "FunctionCall": {
                  "args": "eyJhbW91bnQiOiIxMDAwIiwicmVjZWl2ZXJfaWQiOiJib3dlbiJ9",
                  "deposit": "0",
                  "gas": 100000000000000,
                  "method_name": "transfer"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "bowen",
            "signer_public_key": "ed25519:2f9Zv5kuyuPM5DCyEP5pSqg58NQ8Ct9uSRerZXnCS9fK"
          }
        },
        "receipt_id": "FXMVxdhSUZaZftbmPJWaoqhEB9GrKB2oqg9Wgvuyvom8",
        "receiver_id": "evgeny.lockup.m0"
      },
      {
        "predecessor_id": "evgeny.lockup.m0",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "1000"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "bowen",
            "signer_public_key": "ed25519:2f9Zv5kuyuPM5DCyEP5pSqg58NQ8Ct9uSRerZXnCS9fK"
          }
        },
        "receipt_id": "3Ad7pUygUegMUWUb1rEazfjnTaHfptXCABqKQ6WNq6Wa",
        "receiver_id": "bowen"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "19200274886926125000"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "bowen",
            "signer_public_key": "ed25519:2f9Zv5kuyuPM5DCyEP5pSqg58NQ8Ct9uSRerZXnCS9fK"
          }
        },
        "receipt_id": "5DdQg9pfoJMX1q6bvhsjyyRihzA3sb9Uq5K1J7vK43Ze",
        "receiver_id": "bowen"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "18663792669276228632284"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "bowen",
            "signer_public_key": "ed25519:2f9Zv5kuyuPM5DCyEP5pSqg58NQ8Ct9uSRerZXnCS9fK"
          }
        },
        "receipt_id": "FDp8ovTf5uJYDFemW5op6ebjCT2n4CPExHYie3S1h4qp",
        "receiver_id": "bowen"
      }
    ],
    "receipts_outcome": [
      {
        "block_hash": "HuqYrYsC7h2VERFMgFkqaNqSiFuTH9CA3uJr3BkyNxhF",
        "id": "FXMVxdhSUZaZftbmPJWaoqhEB9GrKB2oqg9Wgvuyvom8",
        "outcome": {
          "executor_id": "evgeny.lockup.m0",
          "gas_burnt": 3493189769144,
          "logs": ["Transferring 1000 to account @bowen"],
          "receipt_ids": [
            "3Ad7pUygUegMUWUb1rEazfjnTaHfptXCABqKQ6WNq6Wa",
            "FDp8ovTf5uJYDFemW5op6ebjCT2n4CPExHYie3S1h4qp"
          ],
          "status": {
            "SuccessReceiptId": "3Ad7pUygUegMUWUb1rEazfjnTaHfptXCABqKQ6WNq6Wa"
          },
          "tokens_burnt": "349318976914400000000"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "5WwHEszBcpfrHnt2VTvVDVnEEACNq5EpQdjz1aW9gTAa"
          }
        ]
      },
      {
        "block_hash": "DJ6oK5FtPPSwksS6pKdEjFvHWAaSVocnVNLoyi8aYk1k",
        "id": "3Ad7pUygUegMUWUb1rEazfjnTaHfptXCABqKQ6WNq6Wa",
        "outcome": {
          "executor_id": "bowen",
          "gas_burnt": 223182562500,
          "logs": [],
          "receipt_ids": ["5DdQg9pfoJMX1q6bvhsjyyRihzA3sb9Uq5K1J7vK43Ze"],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "22318256250000000000"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "CXSXmKpDU8R3UUrBAsffWMeGfKanKqEHCQrHeZkR3RKT"
          },
          {
            "direction": "Right",
            "hash": "2dNo7A1VHKBmMA86m1k3Z9DVXwWgQJGkKGRg8wUR3co9"
          }
        ]
      },
      {
        "block_hash": "9cjUoqAksMbs7ZJ4CXiuwm8vppz9QctTwGmgwZ5mDmUA",
        "id": "5DdQg9pfoJMX1q6bvhsjyyRihzA3sb9Uq5K1J7vK43Ze",
        "outcome": {
          "executor_id": "bowen",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": []
      },
      {
        "block_hash": "DJ6oK5FtPPSwksS6pKdEjFvHWAaSVocnVNLoyi8aYk1k",
        "id": "FDp8ovTf5uJYDFemW5op6ebjCT2n4CPExHYie3S1h4qp",
        "outcome": {
          "executor_id": "bowen",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "A2Ry6NCeuK8WhRCWc41hy6uddadc5nLJ1NBX5wVYo3Yb"
          },
          {
            "direction": "Right",
            "hash": "2dNo7A1VHKBmMA86m1k3Z9DVXwWgQJGkKGRg8wUR3co9"
          }
        ]
      }
    ],
    "status": {
      "SuccessValue": ""
    },
    "transaction": {
      "actions": [
        {
          "FunctionCall": {
            "args": "eyJhbW91bnQiOiIxMDAwIiwicmVjZWl2ZXJfaWQiOiJib3dlbiJ9",
            "deposit": "0",
            "gas": 100000000000000,
            "method_name": "transfer"
          }
        }
      ],
      "hash": "HEgnVQZfs9uJzrqTob4g2Xmebqodq9waZvApSkrbcAhd",
      "nonce": 77,
      "public_key": "ed25519:2f9Zv5kuyuPM5DCyEP5pSqg58NQ8Ct9uSRerZXnCS9fK",
      "receiver_id": "evgeny.lockup.m0",
      "signature": "ed25519:5v1hJuw5RppKGezJHBFU6z3hwmmdferETud9rUbwxVf6xSBAWyiod93Lezaq4Zdcp4zbukDusQY9PjhV47JVCgBx",
      "signer_id": "bowen"
    },
    "transaction_outcome": {
      "block_hash": "9RX2pefXKw8M4EYjLznDF3AMvbkf9asAjN8ACK7gxKsa",
      "id": "HEgnVQZfs9uJzrqTob4g2Xmebqodq9waZvApSkrbcAhd",
      "outcome": {
        "executor_id": "bowen",
        "gas_burnt": 2428026088898,
        "logs": [],
        "receipt_ids": ["FXMVxdhSUZaZftbmPJWaoqhEB9GrKB2oqg9Wgvuyvom8"],
        "status": {
          "SuccessReceiptId": "FXMVxdhSUZaZftbmPJWaoqhEB9GrKB2oqg9Wgvuyvom8"
        },
        "tokens_burnt": "242802608889800000000"
      },
      "proof": [
        {
          "direction": "Right",
          "hash": "DXf4XVmAF5jnjZhcxi1CYxGPuuQrcAmayq9X5inSAYvJ"
        }
      ]
    }
  }
}
```

</p>
</details>

#### What could go wrong? {#what-could-go-wrong-3}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `EXPERIMENTAL_tx_status` method:

<table className="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="3">HANDLER_ERROR</td>
      <td>INVALID_TRANSACTION</td>
      <td>An error happened during transaction execution</td>
      <td>
        <ul>
          <li>See <code>error.cause.info</code> for details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_TRANSACTION</td>
      <td>The requested transaction is not available on the node since it might have not been recorded on the chain yet or has been garbage-collected</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>If the transaction had been submitted more than 5 epochs ago, try to send your request to <a href="https://near-nodes.io/intro/node-types#archival-node">an archival node</a></li>
          <li>Check the transaction hash</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>TIMEOUT_ERROR</td>
      <td>It was unable to wait for the transaction status for reasonable time</td>
      <td>
        <ul>
          <li>Send a request to a different node</li>
          <li>Try again later</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

### Receipt by ID {#receipt-by-id}

> Fetches a receipt by it's ID (as is, without a status or execution outcome)

- method: `EXPERIMENTAL_receipt`
- params:
  - `receipt_id` _(see [NearBlocks Explorer](https://testnet.nearblocks.io) for a valid receipt id)_

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_receipt",
  "params": { "receipt_id": "2EbembRPJhREPtmHCrGv3Xtdm3xoc5BMVYHm3b2kjvMY" }
}
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 method=EXPERIMENTAL_receipt params:='{"receipt_id": "2EbembRPJhREPtmHCrGv3Xtdm3xoc5BMVYHm3b2kjvMY"}' id=dontcare
```

</TabItem>
</Tabs>

<details>
<summary>Example response:</summary>
<p>

```json
{
  "id": "dontcare",
  "jsonrpc": "2.0",
  "result": {
    "predecessor_id": "bohdan.testnet",
    "receipt": {
      "Action": {
        "actions": [
          {
            "Transfer": {
              "deposit": "1000000000000000000000000"
            }
          }
        ],
        "gas_price": "103000000",
        "input_data_ids": [],
        "output_data_receivers": [],
        "signer_id": "bohdan.testnet",
        "signer_public_key": "ed25519:DhC7rPNTBwWJtmVXs1U1SqJztkn9AWbj6jCmQtkrg3TA"
      }
    },
    "receipt_id": "2EbembRPJhREPtmHCrGv3Xtdm3xoc5BMVYHm3b2kjvMY",
    "receiver_id": "frol.testnet"
  }
}
```

</p>
</details>

#### What could go wrong? {#what-could-go-wrong-4}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `EXPERIMENTAL_receipt` method:

<table>
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HANDLER_ERROR</td>
      <td>UNKNOWN_RECEIPT</td>
      <td>The receipt with the given <code>receipt_id</code> was never observed on the node</td>
      <td>
        <ul>
          <li>Check the provided <code>receipt_id</code> is correct</li>
          <li>Send a request on a different node</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

## Transaction Execution Levels {#tx-status-result}

All the methods listed above have `wait_until` request parameter, and `final_execution_status` response value.
They correspond to the same enum `TxExecutionStatus`.
See the detailed explanation for all the options:

```rust
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum TxExecutionStatus {
  /// Transaction is waiting to be included into the block
  None,
  /// Transaction is included into the block. The block may be not finalized yet
  Included,
  /// Transaction is included into the block +
  /// All non-refund transaction receipts finished their execution.
  /// The corresponding blocks for tx and each receipt may be not finalized yet
  #[default]
  ExecutedOptimistic,
  /// Transaction is included into finalized block
  IncludedFinal,
  /// Transaction is included into finalized block +
  /// All non-refund transaction receipts finished their execution.
  /// The corresponding blocks for each receipt may be not finalized yet
  Executed,
  /// Transaction is included into finalized block +
  /// Execution of all transaction receipts is finalized, including refund receipts
  Final,
}
```

---

# Deprecated methods {#deprecated}

## [deprecated] Send transaction (async) {#send-transaction-async}

> Consider using [`send_tx`](/api/rpc/transactions#send-tx) instead

> Sends a transaction and immediately returns transaction hash.

- method: `broadcast_tx_async`
- params: [SignedTransaction encoded in base64]

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "broadcast_tx_async",
  "params": [
    "DgAAAHNlbmRlci50ZXN0bmV0AOrmAai64SZOv9e/naX4W15pJx0GAap35wTT1T/DwcbbDwAAAAAAAAAQAAAAcmVjZWl2ZXIudGVzdG5ldNMnL7URB1cxPOu3G8jTqlEwlcasagIbKlAJlF5ywVFLAQAAAAMAAACh7czOG8LTAAAAAAAAAGQcOG03xVSFQFjoagOb4NBBqWhERnnz45LY4+52JgZhm1iQKz7qAdPByrGFDQhQ2Mfga8RlbysuQ8D8LlA6bQE="
  ]
}
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=broadcast_tx_async \
    params:='[
        "DgAAAHNlbmRlci50ZXN0bmV0AOrmAai64SZOv9e/naX4W15pJx0GAap35wTT1T/DwcbbDwAAAAAAAAAQAAAAcmVjZWl2ZXIudGVzdG5ldNMnL7URB1cxPOu3G8jTqlEwlcasagIbKlAJlF5ywVFLAQAAAAMAAACh7czOG8LTAAAAAAAAAGQcOG03xVSFQFjoagOb4NBBqWhERnnz45LY4+52JgZhm1iQKz7qAdPByrGFDQhQ2Mfga8RlbysuQ8D8LlA6bQE="
    ]'
```

</TabItem>
</Tabs>

Example response:

```json
{
  "jsonrpc": "2.0",
  "result": "6zgh2u9DqHHiXzdy9ouTP7oGky2T4nugqzqt9wJZwNFm",
  "id": "dontcare"
}
```

Final transaction results can be queried using [Transaction Status](#transaction-status)
or [NearBlocks Explorer](https://testnet.nearblocks.io/) using the above `result` hash returning a result similar to the example below.

![NEAR-Explorer-transactionHash](/docs/assets/NEAR-Explorer-transactionHash.png)

#### What could go wrong? {#what-could-go-wrong}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `broadcast_tx_async` method:

<table class="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr class="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

## [deprecated] Send transaction (await) {#send-transaction-await}

> Consider using [`send_tx`](/api/rpc/transactions#send-tx) instead

> Sends a transaction and waits until transaction is fully complete. _(Has a 10 second timeout)_

- method: `broadcast_tx_commit`
- params: `[SignedTransaction encoded in base64]`

Example:

<Tabs>
<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "broadcast_tx_commit",
  "params": [
    "DgAAAHNlbmRlci50ZXN0bmV0AOrmAai64SZOv9e/naX4W15pJx0GAap35wTT1T/DwcbbDQAAAAAAAAAQAAAAcmVjZWl2ZXIudGVzdG5ldIODI4YfV/QS++blXpQYT+bOsRblTRW4f547y/LkvMQ9AQAAAAMAAACh7czOG8LTAAAAAAAAAAXcaTJzu9GviPT7AD4mNJGY79jxTrjFLoyPBiLGHgBi8JK1AnhK8QknJ1ourxlvOYJA2xEZE8UR24THmSJcLQw="
  ]
}
```

</TabItem>
<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=broadcast_tx_commit \
    params:='[
        "DwAAAG5lYXJrYXQudGVzdG5ldABuTi5L1rwnlb35hc9tn5WELkxfiGfGh1Q5aeGNQDejo0QAAAAAAAAAEAAAAGpvc2hmb3JkLnRlc3RuZXSiWAc6W9KlqXS5fK+vjFRDV5pAxHRKU0srKX/cmdRTBgEAAAADAAAAoe3MzhvC0wAAAAAAAAB9rOE9zc5zQYLL1j6VTh3I4fQbERs6I07gJfrAC6jo8DB4HolR9Xps3v4qrZxkgZjwv6wB0QOROM4UEbeOaBoB"
    ]'
```

</TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "jsonrpc": "2.0",
  "result": {
    "final_execution_status": "FINAL",
    "status": {
      "SuccessValue": ""
    },
    "transaction": {
      "signer_id": "sender.testnet",
      "public_key": "ed25519:Gowpa4kXNyTMRKgt5W7147pmcc2PxiFic8UHW9rsNvJ6",
      "nonce": 13,
      "receiver_id": "receiver.testnet",
      "actions": [
        {
          "Transfer": {
            "deposit": "1000000000000000000000000"
          }
        }
      ],
      "signature": "ed25519:7oCBMfSHrZkT7tzPDBxxCd3tWFhTES38eks3MCZMpYPJRfPWKxJsvmwQiVBBxRLoxPTnXVaMU2jPV3MdFKZTobH",
      "hash": "ASS7oYwGiem9HaNwJe6vS2kznx2CxueKDvU9BAYJRjNR"
    },
    "transaction_outcome": {
      "proof": [],
      "block_hash": "9MzuZrRPW1BGpFnZJUJg6SzCrixPpJDfjsNeUobRXsLe",
      "id": "ASS7oYwGiem9HaNwJe6vS2kznx2CxueKDvU9BAYJRjNR",
      "outcome": {
        "logs": [],
        "receipt_ids": ["BLV2q6p8DX7pVgXRtGtBkyUNrnqkNyU7iSksXG7BjVZh"],
        "gas_burnt": 223182562500,
        "tokens_burnt": "22318256250000000000",
        "executor_id": "sender.testnet",
        "status": {
          "SuccessReceiptId": "BLV2q6p8DX7pVgXRtGtBkyUNrnqkNyU7iSksXG7BjVZh"
        }
      }
    },
    "receipts_outcome": [
      {
        "proof": [],
        "block_hash": "5Hpj1PeCi32ZkNXgiD1DrW4wvW4Xtic74DJKfyJ9XL3a",
        "id": "BLV2q6p8DX7pVgXRtGtBkyUNrnqkNyU7iSksXG7BjVZh",
        "outcome": {
          "logs": [],
          "receipt_ids": ["3sawynPNP8UkeCviGqJGwiwEacfPyxDKRxsEWPpaUqtR"],
          "gas_burnt": 223182562500,
          "tokens_burnt": "22318256250000000000",
          "executor_id": "receiver.testnet",
          "status": {
            "SuccessValue": ""
          }
        }
      },
      {
        "proof": [],
        "block_hash": "CbwEqMpPcu6KwqVpBM3Ry83k6M4H1FrJjES9kBXThcRd",
        "id": "3sawynPNP8UkeCviGqJGwiwEacfPyxDKRxsEWPpaUqtR",
        "outcome": {
          "logs": [],
          "receipt_ids": [],
          "gas_burnt": 0,
          "tokens_burnt": "0",
          "executor_id": "sender.testnet",
          "status": {
            "SuccessValue": ""
          }
        }
      }
    ]
  },
  "id": "dontcare"
}
```

</p>
</details>

#### What could go wrong? {#what-could-go-wrong-1}

When API request fails, RPC server returns a structured error response with a limited number of well-defined error variants, so client code can exhaustively handle all the possible error cases. Our JSON-RPC errors follow [verror](https://github.com/joyent/node-verror) convention for structuring the error response:

```json
{
    "error": {
        "name": <ERROR_TYPE>,
        "cause": {
            "info": {..},
            "name": <ERROR_CAUSE>
        },
        "code": -32000,
        "data": String,
        "message": "Server error",
    },
    "id": "dontcare",
    "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered legacy ones and might be deprecated in the future. Please, don't rely on them.

Here is the exhaustive list of the error variants that can be returned by `broadcast_tx_commit` method:

<table class="custom-stripe">
  <thead>
    <tr>
      <th>
        ERROR_TYPE<br />
        <code>error.name</code>
      </th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">HANDLER_ERROR</td>
      <td>INVALID_TRANSACTION</td>
      <td>An error happened during transaction execution</td>
      <td>
        <ul>
          <li>See <code>error.cause.info</code> for details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>TIMEOUT_ERROR</td>
      <td>Transaction was routed, but has not been recorded on chain in 10 seconds.</td>
      <td>
        <ul>
          <li> Re-submit the request with the identical transaction (in NEAR Protocol unique transactions apply exactly once, so if the previously sent transaction gets applied, this request will just return the known result, otherwise, it will route the transaction to the chain once again)</li>
          <li>Check that your transaction is valid</li>
          <li>Check that the signer account id has enough tokens to cover the transaction fees (keep in mind that some tokens on each account are locked to cover the storage cost)</li>
        </ul>
      </td>
    </tr>
    <tr class="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>Passed arguments can't be parsed by JSON RPC server (missing arguments, wrong format, etc.)</td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>Check <code>error.cause.info</code> for more details</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

---

'''
'''--- docs/6.integrations/accounts.md ---
---
id: accounts
title: Accounts
sidebar_label: Accounts
---

## Introduction {#introduction}

Please see the [documentation for accounts](/concepts/protocol/account-model) for basic information.

- For exchanges, NEAR supports [implicit account](https://nomicon.io/DataStructures/Account.html#implicit-account-ids) creation which allows the creation of accounts without paying for transactions.
- You can create an implicit account by following the steps in [this guide](/integrations/implicit-accounts).
- Accounts must have enough tokens to cover its storage which currently costs `0.0001 NEAR` per byte. This equates to a minimum balance of `0.00182 NEAR` for an account with one access key. You can query the live storage price using the [`protocol-config`](https://docs.near.org/api/rpc/setup#protocol-config) RPC endpoint. For more details on storage fees see [this section of the economics paper](https://pages.near.org/papers/economics-in-sharded-blockchain/#transaction-and-storage-fees).

## Transfer from Function Call {#transfer-from-function-call}

NEAR allows transfers to happen within a function call. More importantly, when an account is deployed with some contract, it is possible that the only way to transfer tokens from that account is through a function call. Therefore, exchanges need to support transfers through function calls as well. We recommend the following approach:

Exchange can [query block by height](/api/rpc/setup#block) to get blocks on each height, and for every block,
[query its chunk](/api/rpc/setup#chunk) to obtain the transactions included in the block. For each transaction,
[query its status](/api/rpc/setup#transaction-status-with-receipts) to see the receipts generated from
transactions. Since exchanges are only interested in transfers to their addresses, they only need to filter receipts that
only contain `Transfer` action and whose `predecessor_id` is not `system` (receipts with `predecessor_id` equal to `system`
are [refunds](https://nomicon.io/RuntimeSpec/Refunds.html)). Then, to check whether the receipt succeeds, it is sufficient
to look for the `receipt_id` in `receipts_outcome` and see if its status is `SuccessValue`.

Alternatively, exchange can use [the indexer framework](https://github.com/near/nearcore/tree/master/chain/indexer)
to help index on-chain data which include receipts. An example usage of the indexer can be found [here](https://github.com/near/nearcore/tree/master/tools/indexer/example).

Below we include examples from the contracts that are likely to be used to perform transfers through function calls.

**Example of transfer from a lockup contract**

A contract `evgeny.lockup.near` is deployed and we can check its owner by

```bash
> near view evgeny.lockup.near get_owner_account_id
View call: evgeny.lockup.near.get_owner_account_id()
'evgeny.near'
```

Now we want to transfer some unlocked tokens (1 NEAR) with the following call

```bash
near call evgeny.lockup.near transfer '{"amount":"1000000000000000000000000", "receiver_id": "evgeny.near"}' --accountId=evgeny.near
```

**Note**: the response below can be obtained by hitting the RPC with the transaction hash and NEAR account like this:

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=txstatus method=EXPERIMENTAL_tx_status \
  params:='[ "GXP8YaSonoN2eBY6dB3FbMN2NyYD2JeJJvKdvbL4Jmb2", "evgeny.near"]'
```

<details>
<summary>**Example Response:**</summary>

```json
{
  "id": "123",
  "jsonrpc": "2.0",
  "result": {
    "receipts": [
      {
        "predecessor_id": "evgeny.near",
        "receipt": {
          "Action": {
            "actions": [
              {
                "FunctionCall": {
                  "args": "eyJhbW91bnQiOiIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIiwicmVjZWl2ZXJfaWQiOiJldmdlbnkubmVhciJ9",
                  "deposit": "0",
                  "gas": 100000000000000,
                  "method_name": "transfer"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "evgeny.near",
            "signer_public_key": "ed25519:BVRTxEEMx3gFceSgJtnvPFbSnPDwwUzHe6KGduRh5Byq"
          }
        },
        "receipt_id": "CyJL22SYqt26qgh2XVnk9MGfvzgyiiq5Lny7DdbTdTWU",
        "receiver_id": "evgeny.lockup.near"
      },
      {
        "predecessor_id": "evgeny.lockup.near",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "1000000000000000000000000"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "evgeny.near",
            "signer_public_key": "ed25519:BVRTxEEMx3gFceSgJtnvPFbSnPDwwUzHe6KGduRh5Byq"
          }
        },
        "receipt_id": "EvHfj4fUyVuLBRKNdCZmFGr4WfqwYf7YCbzFsRGFTFJC",
        "receiver_id": "evgeny.near"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "19200274886926125000"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "evgeny.near",
            "signer_public_key": "ed25519:BVRTxEEMx3gFceSgJtnvPFbSnPDwwUzHe6KGduRh5Byq"
          }
        },
        "receipt_id": "J1bBKH43nXHYg4NuS97R1PFzdZchrJboVAdRsK5NRrAv",
        "receiver_id": "evgeny.near"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "18655658845681462514128"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "evgeny.near",
            "signer_public_key": "ed25519:BVRTxEEMx3gFceSgJtnvPFbSnPDwwUzHe6KGduRh5Byq"
          }
        },
        "receipt_id": "6PFaxnNvK5r6qxBq5WfV9uGjoNM6qjhHwLehLP1qak9d",
        "receiver_id": "evgeny.near"
      }
    ],
    "receipts_outcome": [
      {
        "block_hash": "9boEKq9G1UFsEuzmuQrxh5dkRc8xsv8PSPGEkYiTyRLj",
        "id": "CyJL22SYqt26qgh2XVnk9MGfvzgyiiq5Lny7DdbTdTWU",
        "outcome": {
          "executor_id": "evgeny.lockup.near",
          "gas_burnt": 3574640311481,
          "logs": [
            "Transferring 1000000000000000000000000 to account @evgeny.near"
          ],
          "receipt_ids": [
            "EvHfj4fUyVuLBRKNdCZmFGr4WfqwYf7YCbzFsRGFTFJC",
            "6PFaxnNvK5r6qxBq5WfV9uGjoNM6qjhHwLehLP1qak9d"
          ],
          "status": {
            "SuccessReceiptId": "EvHfj4fUyVuLBRKNdCZmFGr4WfqwYf7YCbzFsRGFTFJC"
          },
          "tokens_burnt": "357464031148100000000"
        },
        "proof": []
      },
      {
        "block_hash": "7qn4BjmMD4QbyVvMa8QEzm7h5YuhoGTFTgLeNMUp85UQ",
        "id": "EvHfj4fUyVuLBRKNdCZmFGr4WfqwYf7YCbzFsRGFTFJC",
        "outcome": {
          "executor_id": "evgeny.near",
          "gas_burnt": 223182562500,
          "logs": [],
          "receipt_ids": ["J1bBKH43nXHYg4NuS97R1PFzdZchrJboVAdRsK5NRrAv"],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "22318256250000000000"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "AwHdk5dushTSXHFBt3R5MiexjiXybwdnEaB7L9iJ5F6t"
          }
        ]
      },
      {
        "block_hash": "46788Ay85YGnQaH5tfbboQNWJs3gyXsPbcWzRyxqw56K",
        "id": "J1bBKH43nXHYg4NuS97R1PFzdZchrJboVAdRsK5NRrAv",
        "outcome": {
          "executor_id": "evgeny.near",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": []
      },
      {
        "block_hash": "7qn4BjmMD4QbyVvMa8QEzm7h5YuhoGTFTgLeNMUp85UQ",
        "id": "6PFaxnNvK5r6qxBq5WfV9uGjoNM6qjhHwLehLP1qak9d",
        "outcome": {
          "executor_id": "evgeny.near",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "9RRJpH5VdDxsHpp323EshcAauV5wUNDyW9FpEJBRXXq8"
          }
        ]
      }
    ],
    "status": {
      "SuccessValue": ""
    },
    "transaction": {
      "actions": [
        {
          "FunctionCall": {
            "args": "eyJhbW91bnQiOiIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIiwicmVjZWl2ZXJfaWQiOiJldmdlbnkubmVhciJ9",
            "deposit": "0",
            "gas": 100000000000000,
            "method_name": "transfer"
          }
        }
      ],
      "hash": "GXP8YaSonoN2eBY6dB3FbMN2NyYD2JeJJvKdvbL4Jmb2",
      "nonce": 6,
      "public_key": "ed25519:BVRTxEEMx3gFceSgJtnvPFbSnPDwwUzHe6KGduRh5Byq",
      "receiver_id": "evgeny.lockup.near",
      "signature": "ed25519:4nfzTMpQJKCY3KaqUTFig4Xy9uxwbMeQpMJjtNKsXmwiVqgcVSWRguZEgZM8L2x1jvdpZHsYjLCxc9cSBamXuXPH",
      "signer_id": "evgeny.near"
    },
    "transaction_outcome": {
      "block_hash": "4u7maz2U43W4DPxqQE8KoRNi5dTRHrAsKsFk2qDQsQEw",
      "id": "GXP8YaSonoN2eBY6dB3FbMN2NyYD2JeJJvKdvbL4Jmb2",
      "outcome": {
        "executor_id": "evgeny.near",
        "gas_burnt": 2428086459116,
        "logs": [],
        "receipt_ids": ["CyJL22SYqt26qgh2XVnk9MGfvzgyiiq5Lny7DdbTdTWU"],
        "status": {
          "SuccessReceiptId": "CyJL22SYqt26qgh2XVnk9MGfvzgyiiq5Lny7DdbTdTWU"
        },
        "tokens_burnt": "242808645911600000000"
      },
      "proof": []
    }
  }
}
```
</details>

As we can see, there are four receipts generated in this function call. If we apply the criteria mentioned above, we can
find in `receipts` field this object

```json
{
  "predecessor_id": "evgeny.lockup.near",
  "receipt": {
    "Action": {
      "actions": [
        {
          "Transfer": {
            "deposit": "1000000000000000000000000"
          }
        }
      ],
      "gas_price": "186029458",
      "input_data_ids": [],
      "output_data_receivers": [],
      "signer_id": "evgeny.near",
      "signer_public_key": "ed25519:BVRTxEEMx3gFceSgJtnvPFbSnPDwwUzHe6KGduRh5Byq"
    }
  },
  "receipt_id": "EvHfj4fUyVuLBRKNdCZmFGr4WfqwYf7YCbzFsRGFTFJC",
  "receiver_id": "evgeny.near"
}
```

which contains only `Transfer` action and whose `predecessor_id` is not `system`. Now we can check the status of the
execution by looking for the same receipt id `EvHfj4fUyVuLBRKNdCZmFGr4WfqwYf7YCbzFsRGFTFJC` in `receipts_outcome` field
of the rpc return result, this leads us to this execution outcome

```json
{
  "block_hash": "7qn4BjmMD4QbyVvMa8QEzm7h5YuhoGTFTgLeNMUp85UQ",
  "id": "EvHfj4fUyVuLBRKNdCZmFGr4WfqwYf7YCbzFsRGFTFJC",
  "outcome": {
    "executor_id": "evgeny.near",
    "gas_burnt": 223182562500,
    "logs": [],
    "receipt_ids": ["J1bBKH43nXHYg4NuS97R1PFzdZchrJboVAdRsK5NRrAv"],
    "status": {
      "SuccessValue": ""
    },
    "tokens_burnt": "22318256250000000000"
  },
  "proof": [
    {
      "direction": "Right",
      "hash": "AwHdk5dushTSXHFBt3R5MiexjiXybwdnEaB7L9iJ5F6t"
    }
  ]
}
```

and its status contains `SuccessValue`, which indicates that the receipt has succeeded. Therefore we know that
`1000000000000000000000000` yoctoNEAR, or 1 NEAR has been successfully transferred.

**Example of transfer from a multisig contract**

Mutisig contract, as the name suggests, uses multiple signatures to confirm a transaction and therefore, actions performed
by the multisig contract involves multiple transactions. In the following example, we will show how a transfer is done from
a multisig contract that requires two confirmations.

- First step: `add_request_and_confirm`. This initiates the action that the multisig contract wants to perform with one
  confirmation. The multisig contract `multsigtest.testnet` wants to transfer 1 NEAR to `bowen` and it first
  sends a transaction that calls `add_request_and_confirm` with a request

```json
{
  "request": {
    "receiver_id": "bowen",
    "actions": [
      {
        "type": "Transfer",
        "amount": "1000000000000000000000000"
      }
    ]
  }
}
```

that indicates it wants to transfer 1 NEAR to `bowen`. Notice that this transaction only records the action
but does not perform the actual transfer. The transaction result is as follows:

<details>
<summary>**Example Response:**</summary>

```json
{
  "id": "123",
  "jsonrpc": "2.0",
  "result": {
    "receipts": [
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "3069687780141648922140"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "multisigtest.testnet",
            "signer_public_key": "ed25519:JDewsbE7nz6orFD4zJ3mVzqhfcaoSD6Hmi5as3AHHiTt"
          }
        },
        "receipt_id": "4qgDptd7Wm6vswAhWMCsVpTjBEkmLJEUxSNVQS1wu3rD",
        "receiver_id": "multisigtest.testnet"
      }
    ],
    "receipts_outcome": [
      {
        "block_hash": "6uJWHTvUrtFQAurUyfuAfy9EdoR9FhLodGh44aHJta6m",
        "id": "94LiYwKJEDherHMNg9fqLy9ShFTDiQiUN3nDaGmLZwth",
        "outcome": {
          "executor_id": "multisigtest.testnet",
          "gas_burnt": 8024094920263,
          "logs": [],
          "receipt_ids": ["4qgDptd7Wm6vswAhWMCsVpTjBEkmLJEUxSNVQS1wu3rD"],
          "status": {
            "SuccessValue": "OA=="
          },
          "tokens_burnt": "802409492026300000000"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "GedzmwRkxA5VkT8GLBCnrPUmnEhWPXadPmiq4Ho1s9pH"
          },
          {
            "direction": "Right",
            "hash": "GirkzdS9YpsAz5fXuL5T3rXd93aRcnXNAdXYi241qpWK"
          }
        ]
      },
      {
        "block_hash": "4JyQ6guJKeWZxxXrKndLDuSa5URuirmBi6RzsbKYFsBE",
        "id": "4qgDptd7Wm6vswAhWMCsVpTjBEkmLJEUxSNVQS1wu3rD",
        "outcome": {
          "executor_id": "multisigtest.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": []
      }
    ],
    "status": {
      "SuccessValue": "OA=="
    },
    "transaction": {
      "actions": [
        {
          "FunctionCall": {
            "args": "eyJyZXF1ZXN0Ijp7InJlY2VpdmVyX2lkIjoiYm93ZW4iLCJhY3Rpb25zIjpbeyJ0eXBlIjoiVHJhbnNmZXIiLCJhbW91bnQiOiIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIn1dfX0=",
            "deposit": "0",
            "gas": 30000000000000,
            "method_name": "add_request_and_confirm"
          }
        }
      ],
      "hash": "FGREJkC1e8y95Rc35iD1LVRiDy1WcAZhAxxkSinfb2mL",
      "nonce": 10,
      "public_key": "ed25519:JDewsbE7nz6orFD4zJ3mVzqhfcaoSD6Hmi5as3AHHiTt",
      "receiver_id": "multisigtest.testnet",
      "signature": "ed25519:3NUKXd4uj2eEBqGQtRAxkTFW7UfG44tjvQNNHBDvN9ZswTTMRsDrMJSd1U3GqWF7QToqWQR9J8atNEVTemSWYw41",
      "signer_id": "multisigtest.testnet"
    },
    "transaction_outcome": {
      "block_hash": "6uJWHTvUrtFQAurUyfuAfy9EdoR9FhLodGh44aHJta6m",
      "id": "FGREJkC1e8y95Rc35iD1LVRiDy1WcAZhAxxkSinfb2mL",
      "outcome": {
        "executor_id": "multisigtest.testnet",
        "gas_burnt": 2428204963618,
        "logs": [],
        "receipt_ids": ["94LiYwKJEDherHMNg9fqLy9ShFTDiQiUN3nDaGmLZwth"],
        "status": {
          "SuccessReceiptId": "94LiYwKJEDherHMNg9fqLy9ShFTDiQiUN3nDaGmLZwth"
        },
        "tokens_burnt": "242820496361800000000"
      },
      "proof": [
        {
          "direction": "Right",
          "hash": "AsNAQabPFkmaugRGhCbzcEcR8Gnd22WXxPM2fb2cwHiv"
        },
        {
          "direction": "Right",
          "hash": "GirkzdS9YpsAz5fXuL5T3rXd93aRcnXNAdXYi241qpWK"
        }
      ]
    }
  }
}
```
</details>

- Second step: `confirm`. A second transaction is sent to confirm the transfer. This transaction takes the request id
  returned by the first transaction and does the actual transfer. The transaction result is as follows

<details>
<summary>**Example Response:**</summary>

```json
{
  "id": "123",
  "jsonrpc": "2.0",
  "result": {
    "receipts": [
      {
        "predecessor_id": "multisigtest.testnet",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "1000000000000000000000000"
                }
              }
            ],
            "gas_price": "451542320",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "multisigtest.testnet",
            "signer_public_key": "ed25519:BmVX32jhvEd8d8outiQdjf66GGYV3pb7kaxrKTdNisCz"
          }
        },
        "receipt_id": "DZbHTEf3i3XznK4oJHQfcrteoiCL6WykRiA8vsn4LmAy",
        "receiver_id": "bowen"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "78458115804795000000"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "multisigtest.testnet",
            "signer_public_key": "ed25519:BmVX32jhvEd8d8outiQdjf66GGYV3pb7kaxrKTdNisCz"
          }
        },
        "receipt_id": "6SxC9GfYdjqm7Ao5EAw51XUAjgoN8Lj2X9xJfxjDQYXd",
        "receiver_id": "multisigtest.testnet"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "112870156274913516718240"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "multisigtest.testnet",
            "signer_public_key": "ed25519:BmVX32jhvEd8d8outiQdjf66GGYV3pb7kaxrKTdNisCz"
          }
        },
        "receipt_id": "CHfzz6NLcQMyiLHBQoczhgm5BFjLVfv9B7eCyXKLhhcT",
        "receiver_id": "multisigtest.testnet"
      }
    ],
    "receipts_outcome": [
      {
        "block_hash": "9JEiMrZ1SpAUEbQswde3Diptzwy35Vrvd41VZWG9hYVE",
        "id": "FfuhYhsgFL7sLC8pk1tuRnMHJdqycE6gEcfgZLW9fmFB",
        "outcome": {
          "executor_id": "multisigtest.testnet",
          "gas_burnt": 10109796553814,
          "logs": [],
          "receipt_ids": [
            "DZbHTEf3i3XznK4oJHQfcrteoiCL6WykRiA8vsn4LmAy",
            "CHfzz6NLcQMyiLHBQoczhgm5BFjLVfv9B7eCyXKLhhcT"
          ],
          "status": {
            "SuccessReceiptId": "DZbHTEf3i3XznK4oJHQfcrteoiCL6WykRiA8vsn4LmAy"
          },
          "tokens_burnt": "1010979655381400000000"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "9e2UcG6qBRahBh3V2Z8bGJLh5c4jXfZdP3WBJkCpJCfj"
          }
        ]
      },
      {
        "block_hash": "4LkVfqyhhrxDdVFmow6NxLf1jTaj6XVr7CVcUxxySd1R",
        "id": "DZbHTEf3i3XznK4oJHQfcrteoiCL6WykRiA8vsn4LmAy",
        "outcome": {
          "executor_id": "bowen",
          "gas_burnt": 223182562500,
          "logs": [],
          "receipt_ids": ["6SxC9GfYdjqm7Ao5EAw51XUAjgoN8Lj2X9xJfxjDQYXd"],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "22318256250000000000"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "FFWaWUFt6sNx5XNHzGYsYBSYFWtGPoww5XQz1QmLVc8i"
          }
        ]
      },
      {
        "block_hash": "G6LDdnAa2b38TB4KZ89HAyVgfgyiRPDDgSxoZypbUYpx",
        "id": "6SxC9GfYdjqm7Ao5EAw51XUAjgoN8Lj2X9xJfxjDQYXd",
        "outcome": {
          "executor_id": "multisigtest.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": []
      },
      {
        "block_hash": "4LkVfqyhhrxDdVFmow6NxLf1jTaj6XVr7CVcUxxySd1R",
        "id": "CHfzz6NLcQMyiLHBQoczhgm5BFjLVfv9B7eCyXKLhhcT",
        "outcome": {
          "executor_id": "multisigtest.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "DpDYAEKZTtSomgyeNcJ2i4qjvfqnCtf1CXa83Cz5wvEy"
          }
        ]
      }
    ],
    "status": {
      "SuccessValue": ""
    },
    "transaction": {
      "actions": [
        {
          "FunctionCall": {
            "args": "eyJyZXF1ZXN0X2lkIjo4fQ==",
            "deposit": "0",
            "gas": 250000000000000,
            "method_name": "confirm"
          }
        }
      ],
      "hash": "Fu39vwxC4mu9ks1DZA5Cib63RnBMHpFonk2DcbpioEYc",
      "nonce": 9,
      "public_key": "ed25519:BmVX32jhvEd8d8outiQdjf66GGYV3pb7kaxrKTdNisCz",
      "receiver_id": "multisigtest.testnet",
      "signature": "ed25519:2raQq7t3cmzSL2krE2xaNqXhAw7cKMoXrBjT2ZhAGfCVtGwzbbQ8zkB17vrCSFZDbFmPWSJpoqsw8qPZZiorwSzS",
      "signer_id": "multisigtest.testnet"
    },
    "transaction_outcome": {
      "block_hash": "9JEiMrZ1SpAUEbQswde3Diptzwy35Vrvd41VZWG9hYVE",
      "id": "Fu39vwxC4mu9ks1DZA5Cib63RnBMHpFonk2DcbpioEYc",
      "outcome": {
        "executor_id": "multisigtest.testnet",
        "gas_burnt": 2427972426482,
        "logs": [],
        "receipt_ids": ["FfuhYhsgFL7sLC8pk1tuRnMHJdqycE6gEcfgZLW9fmFB"],
        "status": {
          "SuccessReceiptId": "FfuhYhsgFL7sLC8pk1tuRnMHJdqycE6gEcfgZLW9fmFB"
        },
        "tokens_burnt": "242797242648200000000"
      },
      "proof": [
        {
          "direction": "Right",
          "hash": "B6hN48qeVP8J3hP8XGcANShM264QkNjgJAfMtsuknqex"
        }
      ]
    }
  }
}
```
</details>

Notice that similar to the transfer from lockup contract, there is also one receipt in the `receipts` field that meet
our requirements:

```json
{
  "predecessor_id": "multisigtest.testnet",
  "receipt": {
    "Action": {
      "actions": [
        {
          "Transfer": {
            "deposit": "1000000000000000000000000"
          }
        }
      ],
      "gas_price": "451542320",
      "input_data_ids": [],
      "output_data_receivers": [],
      "signer_id": "multisigtest.testnet",
      "signer_public_key": "ed25519:BmVX32jhvEd8d8outiQdjf66GGYV3pb7kaxrKTdNisCz"
    }
  },
  "receipt_id": "DZbHTEf3i3XznK4oJHQfcrteoiCL6WykRiA8vsn4LmAy",
  "receiver_id": "bowen"
}
```

and we can find its outcome in `receipts_outcome`:

```json
{
  "block_hash": "4LkVfqyhhrxDdVFmow6NxLf1jTaj6XVr7CVcUxxySd1R",
  "id": "DZbHTEf3i3XznK4oJHQfcrteoiCL6WykRiA8vsn4LmAy",
  "outcome": {
    "executor_id": "bowen",
    "gas_burnt": 223182562500,
    "logs": [],
    "receipt_ids": ["6SxC9GfYdjqm7Ao5EAw51XUAjgoN8Lj2X9xJfxjDQYXd"],
    "status": {
      "SuccessValue": ""
    },
    "tokens_burnt": "22318256250000000000"
  },
  "proof": [
    {
      "direction": "Right",
      "hash": "FFWaWUFt6sNx5XNHzGYsYBSYFWtGPoww5XQz1QmLVc8i"
    }
  ]
}
```

which indicates that the transaction is successful.

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol"> Ask it on StackOverflow! </a>
:::

'''
'''--- docs/6.integrations/balance.md ---
---
id: balance-changes
title: Balance changes
sidebar_label: Balance Changes
---

## Prerequisites {#prerequisites}

- [NEAR Account](https://testnet.mynearwallet.com/create)
- [NEAR-CLI](/tools/near-cli)
- Credentials for sender account stored locally by running [`near login`](/tools/near-cli#near-login)

### Native NEAR (‚ìÉ) {#native-near}

> Balance changes on accounts can be tracked by using our [changes RPC endpoint](/api/rpc/setup#view-account-changes). You can test this out by sending tokens to an account using [NEAR-CLI](/tools/near-cli#near-send) and then viewing the changes made.

## Send Tokens {#send-tokens}

- Send tokens using [`near send`](/tools/near-cli#near-send)

```bash
near send sender.testnet receiver.testnet 1
```

- You should see a result in your terminal that looks something like this:

```bash
Sending 1 NEAR to receiver.testnet from sender.testnet
Transaction Id 4To336bYcoGc3LMucJPMk6fMk5suKfCrdNotrRtTxqDy
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/4To336bYcoGc3LMucJPMk6fMk5suKfCrdNotrRtTxqDy
```

## View Balance Changes {#view-balance-changes}

- Open the transaction URL in [NearBlocks Explorer](https://testnet.nearblocks.io/) and copy the `BLOCK HASH`.
- Using the `BLOCK HASH` and the accountId, query the [changes RPC endpoint](/api/rpc/setup#view-account-changes) to view changes.

**Example Query using HTTPie:**

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare \
    method=EXPERIMENTAL_changes \
    'params:={
        "block_id": "CJ24svU3C9FaULVjcNVnWuVZjK6mNaQ8p6AMyUDMqB37",
        "changes_type": "account_changes",
        "account_ids": ["sender.testnet"]
    }'
```

<details>
<summary>**Example Response:**</summary>

```json
{
  "id": "dontcare",
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "BRgE4bjmUo33jmiVBcZaWGkSLVeL7TTi4ZxYTvJdPbB9",
    "changes": [
      {
        "cause": {
          "tx_hash": "4To336bYcoGc3LMucJPMk6fMk5suKfCrdNotrRtTxqDy",
          "type": "transaction_processing"
        },
        "change": {
          "account_id": "sender.testnet",
          "amount": "11767430014412510000000000",
          "code_hash": "11111111111111111111111111111111",
          "locked": "0",
          "storage_paid_at": 0,
          "storage_usage": 806
        },
        "type": "account_update"
      }
    ]
  }
}
```
</details>

---

Alternatively, you can view account balances by [querying `view_account`](/api/rpc/setup#view-account) which only requires an accountId.

**Example HTTPie Request:**

  ```bash
  http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
  params:='{
    "request_type": "view_account",
    "finality": "final",
    "account_id": "sender.testnet"
  }'
  ```

**Example Response:**

```json
{
  "id": "dontcare",
  "jsonrpc": "2.0",
  "result": {
    "amount": "11767430683960197500000000",
    "block_hash": "HUiscpNyoyR5z1UdnZhAJLNz1G8UjBrFTecSYqCrvdfW",
    "block_height": 50754977,
    "code_hash": "11111111111111111111111111111111",
    "locked": "0",
    "storage_paid_at": 0,
    "storage_usage": 806
  }
}
```

**Note:** Gas prices can change between blocks. Even for transactions with deterministic gas cost the cost in NEAR could also be different. You can query the gas price for recent blocks using the [`gas_price` RPC endpoint](https://docs.near.org/api/rpc/setup#gas-price).

---

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol"> Ask it on StackOverflow! </a>
:::

'''
'''--- docs/6.integrations/create-transactions.md ---
---
id: create-transactions
title: Create Transactions
sidebar_label: Create a Transaction
---

To construct & process transactions you will need our API JavaScript library: [`near-api-js`](/build/web3-apps/integrate-contracts). There are many ways to create transactions but for this example we'll show you two ways to create a simple token transfer transaction.

- [HIGH LEVEL](#high-level----create-a-transaction) - _easiest way to create a transaction_
- [LOW LEVEL](#low-level----create-a-transaction) - _performs the exact same transaction as above, but deconstructs the entire process for those curious about each step_

At the core, all transactions require the following:

- `signerId` _(account ID of the transaction originator)_
- `signerPublicKey`
- `receiverId` _(account ID of the transaction recipient)_
- `nonceForPublicKey` _(each time a key is used the nonce value should be incremented by 1)_
- `actions` _( [[click here]](/concepts/protocol/transactions#action) for supported arguments)_
- `blockHash` _(a current block hash (within 24hrs) to prove the transaction was recently created)_

See [Transaction Class](https://near.github.io/near-api-js/classes/near_api_js.transaction.Transaction.html) for a more in depth outline.

---

## HIGH LEVEL -- Create a transaction

### Setup

1. Clone the [transaction-examples](https://github.com/near-examples/transaction-examples) repository by running:

```bash
git clone https://github.com/near-examples/transaction-examples.git
```

2. Follow [setup instructions](https://github.com/near-examples/transaction-examples/blob/master/README.md#prerequisites)

### Imports

In [`send-tokens-easy.js`](https://github.com/near-examples/transaction-examples/blob/9e999253aafa2c3e3b537810a0b8ce7596c3506c/send-tokens-easy.js#L1-L5) we use two dependencies:

1. [NEAR API JavaScript library](https://github.com/near/near-api-js)
2. [`dotenv`](https://www.npmjs.com/package/dotenv) (used to load environment variables for private key)

```js
const nearAPI = require("near-api-js");
const { connect, KeyPair, keyStores, utils } = nearAPI;
require("dotenv").config();
```

The second line above deconstructs several utilities from nearAPI that you will use to interact with the blockchain.

- `connect` - create a connection to NEAR passing configuration variables
- `KeyPair` - creates a keyPair from the private key you'll provide in an `.env` file
- `keyStores` - stores the keyPair that you will create from the private key and used to sign Transactions
- `utils` - used to format NEAR amounts

### Accounts & Network

Next, you'll need to enter the `accountId` of the `sender` and `receiver`, as well as the `networkId` (`betanet`, `testnet`, or `mainnet`).

```js
const sender = "sender.testnet";
const receiver = "receiver.testnet";
const networkId = "testnet";
```

### Formatting Token Amounts

When sending NEAR tokens (‚ìÉ) during a transaction, the amount needs to be converted into [Yocto](https://en.wikipedia.org/wiki/Yocto-) ‚ìÉ or (10^-24).

- To perform this you will use the [`near-api-js`](https://github.com/near/near-api-js) method [`parseNearAmount()`](https://github.com/near/near-api-js/blob/d4d4cf1ac3182fa998b1e004e6782219325a641b/src/utils/format.ts#L53-L63) (located in `utils/format`)

```js
const amount = nearAPI.utils.format.parseNearAmount("1.5");
```

### Create a Key Store

In order to sign transactions you will need to create a "Key Store" that will hold a [full access key](/concepts/protocol/access-keys#full-access-keys) to sign your transactions. There are several ways to accomplish this, but for this example we will use a private key stored in either an `.env` file in your project or an environment variable exported globally.

- If you created the account using [`near-cli`](/tools/near-cli) or ran [`near login`](/tools/near-cli#for-accounts) in your terminal, your private key can be found in a `.json` file located in `/HOME/.near-credentials`.
- If you created an account using [NEAR Wallet](https://testnet.mynearwallet.com/), your key will be found in your browser's `Local Storage`.
  - In your browser's dev tools... `Application` >> `Storage` >> `Local Storage`

```js
// sets up an empty keyStore object in memory using near-api-js
const keyStore = new keyStores.InMemoryKeyStore();
// creates a keyPair from the private key provided in your .env file
const keyPair = KeyPair.fromString(process.env.SENDER_PRIVATE_KEY);
// adds the key you just created to your keyStore which can hold multiple keys (must be inside an async function)
await keyStore.setKey(networkId, sender, keyPair);
```

### Setting up a connection to NEAR

Now create a connection to NEAR using a configuration object that will contain your `networkId` setup earlier as well as your `keyStore`.

```js
// configuration used to connect to NEAR
const prefix = (networkId === "testnet") ? "testnet" : "www";

const config = {
  networkId,
  keyStore,
  nodeUrl: `https://rpc.${networkId}.near.org`,
  walletUrl: `https://wallet.${networkId}.near.org`,
  helperUrl: `https://helper.${networkId}.near.org`,
  explorerUrl: `https://${prefix}.nearblocks.io`,
};

// connect to NEAR! :)
const near = await connect(config);
// create a NEAR account object
const senderAccount = await near.account(sender);
```

You'll notice the last line uses your NEAR connection to create a `senderAccount` object that you'll use to perform the transaction.

### Create, Sign, & Send Transaction

Now that everything is setup, creating the transaction is a single line of code.

```js
const result = await senderAccount.sendMoney(receiver, amount);
```

This simple command constructs, signs, and sends a token transfer transaction on the NEAR blockchain. There is no need to create a `result` variable aside from inspecting the response details from your transaction and even create a link to [NearBlocks Explorer](https://testnet.nearblocks.io/) to view a GUI version of the transaction details.

---

## LOW LEVEL -- Create a Transaction

### Setup

1. Clone the [transaction-examples](https://github.com/near-examples/transaction-examples) repository by running:

```bash
git clone https://github.com/near-examples/transaction-examples.git
```

2. Follow [setup instructions](https://github.com/near-examples/transaction-examples/blob/master/README.md#prerequisites)

---

### Imports

In [`send-tokens-deconstructed.js`](https://github.com/near-examples/transaction-examples/blob/master/send-tokens-deconstructed.js#L1-L4) we use three dependencies:

1. [NEAR API JavaScript library](https://github.com/near/near-api-js)
2. [`js-sha256`](https://www.npmjs.com/package/js-sha256) (cryptographic hashing algorithm)
3. [`dotenv`](https://www.npmjs.com/package/dotenv) (used to load environment variables)

```js
const nearAPI = require("near-api-js");
const sha256 = require("js-sha256");
require("dotenv").config();
```

---

### Accounts & Network

Next, you'll need to enter the `accountId` of the `sender` and `receiver`, as well as the `networkId` (`betanet`, `testnet`, or `mainnet`).

```js
const sender = "sender.testnet";
const receiver = "receiver.testnet";
const networkId = "testnet";
```

---

### Formatting Token Amounts

When sending NEAR tokens (‚ìÉ) during a transaction, the amount needs to be converted into [Yocto](https://en.wikipedia.org/wiki/Yocto-) ‚ìÉ or (10^-24).

- To perform this you will use the [`near-api-js`](https://github.com/near/near-api-js) method [`parseNearAmount()`](https://github.com/near/near-api-js/blob/d4d4cf1ac3182fa998b1e004e6782219325a641b/src/utils/format.ts#L53-L63) (located in `utils/format`)

```js
const amount = nearAPI.utils.format.parseNearAmount("1.5");
```

---

### Setting up a connection to NEAR

In this example, we will create a NEAR RPC `provider` that allows us to interact with the chain via [RPC endpoints](/api/rpc/introduction).

```js
const provider = new nearAPI.providers.JsonRpcProvider(
  `https://rpc.${networkId}.near.org`
);
```

---

### Access Keys

To sign a transaction to send NEAR ‚ìÉ, we will need a `FullAccess` key to the sender's account.

- If you created the account using [`near-cli`](/tools/near-cli) or ran [`near login`](/tools/near-cli#for-accounts) in your terminal, your private key can be found in a `.json` file located in `/HOME/.near-credentials`.
- If you created an account using [NEAR Wallet](https://testnet.mynearwallet.com/), your key will be found in your browser's `Local Storage`.
  - In your browser's dev tools... `Application` >> `Storage` >> `Local Storage`

Once you have access to the private key of the sender's account, create an environment variable `SENDER_PRIVATE_KEY` or hard code it as a string on [line 18](https://github.com/near-examples/transaction-examples/blob/master/send-tokens-deconstructed.js#L18) of `send-tokens.js`.

- With this `privateKey`, we can now construct a `keyPair` object to sign transactions.

```js
const privateKey = process.env.SENDER_PRIVATE_KEY;
const keyPair = nearAPI.KeyPair.fromString(privateKey);
```

---

### Transaction Requirements

As stated before, all transactions require six parts:

1. [`signerId`](#1-signerid)
2. [`signerPublicKey`](#2-signerpublickey)
3. [`receiverId`](#3-receiverid)
4. [`nonceForPublicKey`](#4-nonceforpublickey)
5. [`actions`](/concepts/protocol/transactions#action)
6. [`blockHash`](#6-blockhash)

### 1 `signerId`

- The `signerId` is the account ID of the transaction originator.
- This value is passed as a string (ex. `'example.testnet'` or `'bob.near'`)

### 2 `signerPublicKey`

- The `signerPublicKey` is required to be an object with two key value pairs: `keyType` and `data`.

```js
PublicKey = {
  keyType: 0,
  data: Uint8Array(32)[
    (190,
    150,
    152,
    145,
    232,
    248,
    128,
    151,
    167,
    165,
    128,
    46,
    20,
    231,
    103,
    142,
    39,
    56,
    152,
    46,
    135,
    1,
    161,
    180,
    94,
    212,
    195,
    201,
    73,
    190,
    70,
    242)
  ],
};
```

- This can be constructed by calling `getPublicKey()` using the `keyPair` we [setup earlier](#access-keys).

```js
const publicKey = keyPair.getPublicKey();
```

### 3 `receiverId`

- The `receiverId` is the account ID of the transaction recipient.
- This value is passed as a string (ex. `'example.testnet'` or `'bob.near'`)
- The certain cases, the `signerId` and the `receiverId` can be the same account.

### 4 `nonceForPublicKey`

- A unique number or `nonce` is required for each transaction signed with an access key.
- To ensure a unique number is created for each transaction, the current `nonce` should be queried and then incremented by 1.
- Current nonce can be retrieved using the `provider` we [created earlier](#setting-up-a-connection-to-near).

```js
const accessKey = await provider.query(
  `access_key/${sender}/${publicKey.toString()}`,
  ""
);
```

- now we can create a unique number for our transaction by incrementing the current `nonce`.

```js
const nonce = ++accessKey.nonce;
```

### 5 `actions`

- There are currently eight supported `Action` types. [[see here]](/concepts/protocol/transactions#action)
- For this example, we are using `Transfer`
- This transfer action can be created using the [imported `nearAPI` object](#imports) and the [formatted ‚ìÉ amount](#formatting-token-amounts) created earlier.

```js
const actions = [nearAPI.transactions.transfer(amount)];
```

[[click here]](https://github.com/near/near-api-js/blob/d4d4cf1ac3182fa998b1e004e6782219325a641b/src/transaction.ts#L70-L72) to view source for `transfer()`.

### 6 `blockHash`

- Each transaction requires a current block hash (within 24hrs) to prove that the transaction was created recently.
- Hash must be converted to an array of bytes using the `base_decode` method found in [`nearAPI`](#imports).

```js
const recentBlockHash = nearAPI.utils.serialize.base_decode(
  accessKey.block_hash
);
```

[[click here]](https://github.com/near/near-api-js/blob/d4d4cf1ac3182fa998b1e004e6782219325a641b/src/utils/serialize.ts#L16-L17) to view source for `base_decode()`.

---

### Constructing the Transaction

With all of our [required arguments](#transaction-requirements), we can construct the transaction.

- Using [`nearAPI`](#imports), we call on `createTransaction()` to perform this task.

```js
const transaction = nearAPI.transactions.createTransaction(
  sender,
  publicKey,
  receiver,
  nonce,
  actions,
  recentBlockHash
);
```

[[click here]](https://github.com/near/near-api-js/blob/d4d4cf1ac3182fa998b1e004e6782219325a641b/src/transaction.ts#L95-L110) to view source code for the Transaction class

---

### Sign Transaction

Now that the transaction is created, we sign it before sending it to the NEAR blockchain. At the lowest level, there are four steps to this process.

1. Using [`nearAPI`](#imports), we call on `serialize()` to serialize the transaction in [Borsh](https://borsh.io/).

```js
const serializedTx = nearAPI.utils.serialize.serialize(
  nearAPI.transactions.SCHEMA.Transaction,
  transaction
);
```

2. Hash the serialized transaction using a `sha256` cryptographic hashing algorithm.

```js
const serializedTxHash = new Uint8Array(sha256.sha256.array(serializedTx));
```

3. Create a signature with the `keyPair`.

```js
const signature = keyPair.sign(serializedTxHash);
```

4. Construct the signed transaction using `near-api-js` [SignedTransaction class](https://github.com/near/near-api-js/blob/d4d4cf1ac3182fa998b1e004e6782219325a641b/src/transaction.ts#L112-L123).

```js
const signedTransaction = new nearAPI.transactions.SignedTransaction({
  transaction,
  signature: new nearAPI.transactions.Signature({
    keyType: transaction.publicKey.keyType,
    data: signature.signature,
  }),
});
```

### Send Transaction

Final step is to encode and send the transaction.

- First we serialize transaction into [Borsh](https://borsh.io/), and store the result as `signedSerializedTx`. _(required for all transactions)_
- Then we send the transaction via [RPC call](/api/rpc/introduction) using the `sendJsonRpc()` method nested inside [`near`](#setting-up-connection-to-near).

```js
// encodes transaction to serialized Borsh (required for all transactions)
const signedSerializedTx = signedTransaction.encode();
// sends transaction to NEAR blockchain via JSON RPC call and records the result
const result = await provider.sendJsonRpc("broadcast_tx_commit", [
  Buffer.from(signedSerializedTx).toString("base64"),
]);
```

### Transaction Results

Detailed transaction results of the transaction are returned in the following format:

```bash
{
  status: { SuccessValue: '' },
  transaction: {
    signer_id: 'sender.testnet',
    public_key: 'ed25519:8RazSLHvzj4TBSKGUo5appP7wVeqZNQYjP9hvhF4ZKS2',
    nonce: 57,
    receiver_id: 'receiver.testnet',
    actions: [ [Object] ],
    signature: 'ed25519:2sK53w6hybSxX7qWShXz6xKnjnYRUW7Co3evEaaggNW6pGSCNPvx7urY4akwnzAbxZGwsKjx8dcVm73qbitntJjz',
    hash: 'EgGzB73eFxCwZRGcEyCKedLjvvgxhDXcUtq21SqAh79j'
  },
  transaction_outcome: {
    proof: [ [Object] ],
    block_hash: 'J6cFDzAFkuknHMCEYW2uPQXDvCfSndkJmADVEWJbtTwV',
    id: 'EgGzB73eFxCwZRGcEyCKedLjvvgxhDXcUtq21SqAh79j',
    outcome: {
      logs: [],
      receipt_ids: [Array],
      gas_burnt: 223182562500,
      tokens_burnt: '22318256250000000000',
      executor_id: 'sender.testnet',
      status: [Object]
    }
  },
  receipts_outcome: [
    {
      proof: [Array],
      block_hash: 'FSS7UzTpMr4mUm6aw8MmzP6Q7wnQs35VS8vYm1R461dM',
      id: '3LjBxe2jq1s7XEPrYxihp4rPVdyHAbYfkcdJjUEVijhJ',
      outcome: [Object]
    },
    {
      proof: [Array],
      block_hash: '4XBio5dM5UGYjJgzZjgckfVgMZ9uKGbTkt8zZi5webxw',
      id: 'AXFA4kwiYfruKQ4LkD1qZA8P7HoAvtFwGqwQYdWtWNaW',
      outcome: [Object]
    }
  ]
}
Transaction Results:  {
  signer_id: 'sender.testnet',
  public_key: 'ed25519:8RazSLHvzj4TBSKGUo5appP7wVeqZNQYjP9hvhF4ZKS2',
  nonce: 57,
  receiver_id: 'receiver.testnet',
  actions: [ { Transfer: [Object] } ],
  signature: 'ed25519:2sK53w6hybSxX7qWShXz6xKnjnYRUW7Co3evEaaggNW6pGSCNPvx7urY4akwnzAbxZGwsKjx8dcVm73qbitntJjz',
  hash: 'EgGzB73eFxCwZRGcEyCKedLjvvgxhDXcUtq21SqAh79j'
}
```

For detailed information on transaction receipts [[click here]](https://nomicon.io/RuntimeSpec/Receipts.html)

- To view the transaction in [NearBlocks Explorer](https://testnet.nearblocks.io/), enter the `hash` located under `transaction` / `Transaction Results`.
- In addition, you can create a link in JS using the `networkId` and `result.transaction.hash`.

```js
const prefix = (networkId === "testnet") ? "testnet." : "";
const transactionLink = `https://${prefix}nearblocks.io/txns/${result.transaction.hash}`;
```

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol"><h8>Ask it on StackOverflow!</h8></a>
:::

Happy Coding! üöÄ

'''
'''--- docs/6.integrations/errors/error-implementation.md ---
---
id: error-implementation
title: Source Code Survey
sidebar_label: Source Code Survey
---

This page provides a very high level, sometimes "pseudocode", view of error types and related messages as implemented by the NEAR platform.

Errors raised by the NEAR platform are implemented in the following locations in `nearcore`:

- [nearcore/core/primitives/src/errors.rs](https://github.com/near/nearcore/blob/master/core/primitives/src/errors.rs)
- [nearcore/runtime/near-vm-errors/src/lib.rs](https://github.com/near/nearcore/blob/master/runtime/near-vm-errors/src/lib.rs)

---

## RuntimeError and subtypes {#runtimeerror-and-subtypes}

### RuntimeError {#runtimeerror}

#### Definition {#definition}

```rust
/// Error returned from `Runtime::apply`
pub enum RuntimeError {
    /// An unexpected integer overflow occurred. The likely issue is an invalid state or the transition.
    UnexpectedIntegerOverflow,
    /// An error happened during TX verification and account charging. It's likely the chunk is invalid.
    /// and should be challenged.
    InvalidTxError(InvalidTxError),
    /// Unexpected error which is typically related to the node storage corruption.account
    /// That it's possible the input state is invalid or malicious.
    StorageError(StorageError),
    /// An error happens if `check_balance` fails, which is likely an indication of an invalid state.
    BalanceMismatchError(BalanceMismatchError),
}
```

#### Error Messages {#error-messages}

- see below: `InvalidTxError`, `StorageError` and `BalanceMismatchError`

### InvalidTxError {#invalidtxerror}

#### Definition {#definition-1}

```rust
/// An error happened during TX execution
pub enum InvalidTxError {
    /// Happens if a wrong AccessKey used or AccessKey has not enough permissions
    InvalidAccessKeyError(InvalidAccessKeyError),
    /// TX signer_id is not in a valid format or not satisfy requirements see `near_core::primitives::utils::is_valid_account_id`
    InvalidSignerId { signer_id: AccountId },
    /// TX signer_id is not found in a storage
    SignerDoesNotExist { signer_id: AccountId },
    /// Transaction nonce must be account[access_key].nonce + 1
    InvalidNonce { tx_nonce: Nonce, ak_nonce: Nonce },
    /// TX receiver_id is not in a valid format or not satisfy requirements see `near_core::primitives::utils::is_valid_account_id`
    InvalidReceiverId { receiver_id: AccountId },
    /// TX signature is not valid
    InvalidSignature,
    /// Account does not have enough balance to cover TX cost
    NotEnoughBalance {
        signer_id: AccountId,
        balance: Balance,
        cost: Balance,
    },
    /// Signer account rent is unpaid
    RentUnpaid {
        /// An account which is required to pay the rent
        signer_id: AccountId,
        /// Required balance to cover the state rent
        amount: Balance,
    },
    /// An integer overflow occurred during transaction cost estimation.
    CostOverflow,
    /// Transaction parent block hash doesn't belong to the current chain
    InvalidChain,
    /// Transaction has expired
    Expired,
    /// An error occurred while validating actions of a Transaction.
    ActionsValidation(ActionsValidationError),
}
```

#### Error Messages {#error-messages-1}

```rust
InvalidTxError::InvalidSignerId { signer_id }
    "Invalid signer account ID {:?} according to requirements"

InvalidTxError::SignerDoesNotExist { signer_id }
    "Signer {:?} does not exist"

InvalidTxError::InvalidAccessKeyError(access_key_error)

InvalidTxError::InvalidNonce { tx_nonce, ak_nonce }
    "Transaction nonce {} must be larger than nonce of the used access key {}"

InvalidTxError::InvalidReceiverId { receiver_id }
    "Invalid receiver account ID {:?} according to requirements"

InvalidTxError::InvalidSignature
    "Transaction is not signed with the given public key"

InvalidTxError::NotEnoughBalance { signer_id, balance, cost }
    "Sender {:?} does not have enough balance {} for operation costing {}"

InvalidTxError::RentUnpaid { signer_id, amount }
    "Failed to execute, because the account {:?} wouldn't have enough to pay required rent {}" 

InvalidTxError::CostOverflow
    "Transaction gas or balance cost is too high"

InvalidTxError::InvalidChain
    "Transaction parent block hash doesn't belong to the current chain"

InvalidTxError::Expired
    "Transaction has expired"

InvalidTxError::ActionsValidation(error)
    "Transaction actions validation error: {}"
```

### StorageError {#storageerror}

#### Definition {#definition-2}

```rust
pub enum StorageError {
    /// Key-value db internal failure
    StorageInternalError,
    /// Storage is PartialStorage and requested a missing trie node
    TrieNodeMissing,
    /// Either invalid state or key-value db is corrupted.
    /// For PartialStorage it cannot be corrupted.
    /// Error message is unreliable and for debugging purposes only. It's also probably ok to
    /// panic in every place that produces this error.
    /// We can check if db is corrupted by verifying everything in the state trie.
    StorageInconsistentState(String),
}
```

### BalanceMismatchError {#balancemismatcherror}

#### Definition {#definition-3}

```rust
/// Happens when the input balance doesn't match the output balance in Runtime apply.
pub struct BalanceMismatchError {
    // Input balances
    pub incoming_validator_rewards: Balance,
    pub initial_accounts_balance: Balance,
    pub incoming_receipts_balance: Balance,
    pub processed_delayed_receipts_balance: Balance,
    pub initial_postponed_receipts_balance: Balance,
    // Output balances
    pub final_accounts_balance: Balance,
    pub outgoing_receipts_balance: Balance,
    pub new_delayed_receipts_balance: Balance,
    pub final_postponed_receipts_balance: Balance,
    pub total_rent_paid: Balance,
    pub total_validator_reward: Balance,
    pub total_balance_burnt: Balance,
    pub total_balance_slashed: Balance,
}
```

#### Error Messages {#error-messages-2}

```rust
"Balance Mismatch Error. The input balance {} doesn't match output balance {}\n\
Inputs:\n\
    \tIncoming validator rewards sum: {}\n\
    \tInitial accounts balance sum: {}\n\
    \tIncoming receipts balance sum: {}\n\
    \tProcessed delayed receipts balance sum: {}\n\
    \tInitial postponed receipts balance sum: {}\n\
Outputs:\n\
    \tFinal accounts balance sum: {}\n\
    \tOutgoing receipts balance sum: {}\n\
    \tNew delayed receipts balance sum: {}\n\
    \tFinal postponed receipts balance sum: {}\n\
    \tTotal rent paid: {}\n\
    \tTotal validators reward: {}\n\
    \tTotal balance burnt: {}\n\
    \tTotal balance slashed: {}",
```

### InvalidAccessKeyError {#invalidaccesskeyerror}

#### Definition {#definition-4}

```rust
pub enum InvalidAccessKeyError {
    /// The access key identified by the `public_key` doesn't exist for the account
    AccessKeyNotFound { account_id: AccountId, public_key: PublicKey },
    /// Transaction `receiver_id` doesn't match the access key receiver_id
    ReceiverMismatch { tx_receiver: AccountId, ak_receiver: AccountId },
    /// Transaction method name isn't allowed by the access key
    MethodNameMismatch { method_name: String },
    /// Transaction requires a full permission access key.
    RequiresFullAccess,
    /// Access Key does not have enough allowance to cover transaction cost
    NotEnoughAllowance {
        account_id: AccountId,
        public_key: PublicKey,
        allowance: Balance,
        cost: Balance,
    },
    /// Having a deposit with a function call action is not allowed with a function call access key.
    DepositWithFunctionCall,
}
```

#### Error Messages {#error-messages-3}

```rust
InvalidAccessKeyError::AccessKeyNotFound { account_id, public_key }
    "Signer {:?} doesn't have access key with the given public_key {}"

InvalidAccessKeyError::ReceiverMismatch { tx_receiver, ak_receiver }
    "Transaction receiver_id {:?} doesn't match the access key receiver_id {:?}"

InvalidAccessKeyError::MethodNameMismatch { method_name }
    "Transaction method name {:?} isn't allowed by the access key"

InvalidAccessKeyError::RequiresFullAccess
    "The transaction contains more then one action, but it was signed \
     with an access key which allows transaction to apply only one specific action. \
     To apply more then one actions TX must be signed with a full access key"

InvalidAccessKeyError::NotEnoughAllowance { account_id, public_key, allowance, cost }
    "Access Key {:?}:{} does not have enough balance {} for transaction costing {}"

InvalidAccessKeyError::DepositWithFunctionCall
    "Having a deposit with a function call action is not allowed with a function call access key."
```

### ActionsValidationError {#actionsvalidationerror}

#### Definition {#definition-5}

```rust
/// Describes the error for validating a list of actions.
pub enum ActionsValidationError {
    /// The total prepaid gas (for all given actions) exceeded the limit.
    TotalPrepaidGasExceeded { total_prepaid_gas: Gas, limit: Gas },
    /// The number of actions exceeded the given limit.
    TotalNumberOfActionsExceeded { total_number_of_actions: u64, limit: u64 },
    /// The total number of bytes of the method names exceeded the limit in a Add Key action.
    AddKeyMethodNamesNumberOfBytesExceeded { total_number_of_bytes: u64, limit: u64 },
    /// The length of some method name exceeded the limit in a Add Key action.
    AddKeyMethodNameLengthExceeded { length: u64, limit: u64 },
    /// Integer overflow during a compute.
    IntegerOverflow,
    /// Invalid account ID.
    InvalidAccountId { account_id: AccountId },
    /// The size of the contract code exceeded the limit in a DeployContract action.
    ContractSizeExceeded { size: u64, limit: u64 },
    /// The length of the method name exceeded the limit in a Function Call action.
    FunctionCallMethodNameLengthExceeded { length: u64, limit: u64 },
    /// The length of the arguments exceeded the limit in a Function Call action.
    FunctionCallArgumentsLengthExceeded { length: u64, limit: u64 },
}
```

#### Error Messages {#error-messages-4}

```rust
ActionsValidationError::TotalPrepaidGasExceeded     { total_prepaid_gas, limit }
     "The total prepaid gas {} exceeds the limit {}"
     
ActionsValidationError::TotalNumberOfActionsExceeded {total_number_of_actions, limit }
     "The total number of actions {} exceeds the limit {}"
     
ActionsValidationError::AddKeyMethodNamesNumberOfBytesExceeded { total_number_of_bytes, limit }
     "The total number of bytes in allowed method names {} exceeds the maximum allowed number {} in a AddKey action"
     
ActionsValidationError::AddKeyMethodNameLengthExceeded { length, limit }
     "The length of some method name {} exceeds the maximum allowed length {} in a AddKey action"
     
ActionsValidationError::IntegerOverflow
     "Integer overflow during a compute"
     
ActionsValidationError::InvalidAccountId { account_id }
     "Invalid account ID `{}`"
     
ActionsValidationError::ContractSizeExceeded { size, limit }
     "The length of the contract size {} exceeds the maximum allowed size {} in a DeployContract action"
     
ActionsValidationError::FunctionCallMethodNameLengthExceeded { length, limit }
     "The length of the method name {} exceeds the maximum allowed length {} in a FunctionCall action"
     
ActionsValidationError::FunctionCallArgumentsLengthExceeded { length, limit }
     "The length of the arguments {} exceeds the maximum allowed length {} in a FunctionCall action"
     
```

## TxExecutionError and subtypes {#txexecutionerror-and-subtypes}

### TxExecutionError {#txexecutionerror}

#### Definition {#definition-6}
```rust
/// Error returned in the ExecutionOutcome in case of failure
pub enum TxExecutionError {
    /// An error happened during Acton execution
    ActionError(ActionError),
    /// An error happened during Transaction execution
    InvalidTxError(InvalidTxError),
}
```

### ActionError {#actionerror}

#### Definition {#definition-7}

```rust
ActionError
pub struct ActionError {
    /// Index of the failed action in the transaction.
    /// Action index is not defined if ActionError.kind is `ActionErrorKind::RentUnpaid`
    pub index: Option<u64>,
    /// The kind of ActionError happened
    pub kind: ActionErrorKind,
}
```

### ActionErrorKind {#actionerrorkind}

#### Definition {#definition-8}

```rust
pub enum ActionErrorKind {
    /// Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage
    AccountAlreadyExists { account_id: AccountId },
    /// Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)
    AccountDoesNotExist { account_id: AccountId },
    /// A newly created account must be under a namespace of the creator account
    CreateAccountNotAllowed { account_id: AccountId, predecessor_id: AccountId },
    /// Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver
    /// or the first TX action is a `CreateAccount` action
    ActorNoPermission { account_id: AccountId, actor_id: AccountId },
    /// Account tries to remove an access key that doesn't exist
    DeleteKeyDoesNotExist { account_id: AccountId, public_key: PublicKey },
    /// The public key is already used for an existing access key
    AddKeyAlreadyExists { account_id: AccountId, public_key: PublicKey },
    /// Account is staking and can not be deleted
    DeleteAccountStaking { account_id: AccountId },
    /// Foreign sender (sender=!receiver) can delete an account only if a target account hasn't enough tokens to pay rent
    DeleteAccountHasRent {
        account_id: AccountId,
        balance: Balance,
    },
    /// ActionReceipt can't be completed, because the remaining balance will not be enough to pay rent.
    RentUnpaid {
        /// An account which is required to pay the rent
        account_id: AccountId,
        /// Rent due to pay.
        amount: Balance,
    },
    /// Account is not yet staked, but tries to unstake
    TriesToUnstake { account_id: AccountId },
    /// The account doesn't have enough balance to increase the stake.
    TriesToStake {
        account_id: AccountId,
        stake: Balance,
        locked: Balance,
        balance: Balance,
    },
    /// An error occurred during a `FunctionCall` Action.
    FunctionCallError(FunctionCallError),
    /// Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails
    /// receipt validation.
    NewReceiptValidationError(ReceiptValidationError),
}
```

#### Error Messages {#error-messages-5}

```rust
ActionErrorKind::AccountAlreadyExists { account_id } 
"Can't create a new account {:?}, because it already exists"

ActionErrorKind::AccountDoesNotExist { account_id } 
"Can't complete the action because account {:?} doesn't exist"

ActionErrorKind::ActorNoPermission { actor_id, account_id } 
"Actor {:?} doesn't have permission to account {:?} to complete the action"

ActionErrorKind::RentUnpaid { account_id, amount } 
"The account {} wouldn't have enough balance to pay required rent {}"

ActionErrorKind::TriesToUnstake { account_id } 
"Account {:?} is not yet staked, but tries to unstake"

ActionErrorKind::TriesToStake { account_id, stake, locked, balance } 
"Account {:?} tries to stake {}, but has staked {} and only has {}"

ActionErrorKind::CreateAccountNotAllowed { account_id, predecessor_id } 
"The new account_id {:?} can't be created by {:?}"

ActionErrorKind::DeleteKeyDoesNotExist { account_id, .. } 
"Account {:?} tries to remove an access key that doesn't exist"

ActionErrorKind::AddKeyAlreadyExists { public_key, .. } 
"The public key {:?} is already used for an existing access key"

ActionErrorKind::DeleteAccountStaking { account_id }
"Account {:?} is staking and can not be deleted"

ActionErrorKind::DeleteAccountHasRent { account_id, balance } 
"Account {:?} can't be deleted. It has {}, which is enough to cover the rent"

ActionErrorKind::FunctionCallError(s) 

ActionErrorKind::NewReceiptValidationError(e) 
"An new action receipt created during a FunctionCall is not valid: {}"
```

### ReceiptValidationError {#receiptvalidationerror}

#### Definition {#definition-9}

```rust
/// Describes the error for validating a receipt.
pub enum ReceiptValidationError {
    /// The `predecessor_id` of a Receipt is not valid.
    InvalidPredecessorId { account_id: AccountId },
    /// The `receiver_id` of a Receipt is not valid.
    InvalidReceiverId { account_id: AccountId },
    /// The `signer_id` of an ActionReceipt is not valid.
    InvalidSignerId { account_id: AccountId },
    /// The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.
    InvalidDataReceiverId { account_id: AccountId },
    /// The length of the returned data exceeded the limit in a DataReceipt.
    ReturnedValueLengthExceeded { length: u64, limit: u64 },
    /// The number of input data dependencies exceeds the limit in an ActionReceipt.
    NumberInputDataDependenciesExceeded { number_of_input_data_dependencies: u64, limit: u64 },
    /// An error occurred while validating actions of an ActionReceipt.
    ActionsValidation(ActionsValidationError),
}
```

#### Error Messages {#error-messages-6}

```rust
ReceiptValidationError::InvalidPredecessorId { account_id } 
"The predecessor_id `{}` of a Receipt is not valid."

ReceiptValidationError::InvalidReceiverId { account_id } 
"The receiver_id `{}` of a Receipt is not valid."

ReceiptValidationError::InvalidSignerId { account_id } 
"The signer_id `{}` of an ActionReceipt is not valid."

ReceiptValidationError::InvalidDataReceiverId { account_id } 
"The receiver_id `{}` of a DataReceiver within an ActionReceipt is not valid."

ReceiptValidationError::ReturnedValueLengthExceeded { length, limit } 
"The length of the returned data {} exceeded the limit {} in a DataReceipt"

ReceiptValidationError::NumberInputDataDependenciesExceeded { number_of_input_data_dependencies, limit } 
"The number of input data dependencies {} exceeded the limit {} in an ActionReceipt"

ReceiptValidationError::ActionsValidation(e) 
```

## VMError and subtypes {#vmerror-and-subtypes}

### VMError {#vmerror}

#### Definition {#definition-10}

```rust
pub enum VMError {
    FunctionCallError(FunctionCallError),
    /// Serialized external error from External trait implementation.
    ExternalError(Vec<u8>),
    /// An error that is caused by an operation on an inconsistent state.
    /// E.g. an integer overflow by using a value from the given context.
    InconsistentStateError(InconsistentStateError),
}
```

#### Error Messages {#error-messages-7}

```rust
VMError::ExternalError
  "Serialized ExternalError"
```

### FunctionCallError {#functioncallerror}

#### Definition {#definition-11}

```rust
pub enum FunctionCallError {
    CompilationError(CompilationError),
    LinkError { msg: String },
    MethodResolveError(MethodResolveError),
    WasmTrap { msg: String },
    HostError(HostError),
}
```

#### Error Messages {#error-messages-8}

```rust
FunctionCallError::WasmTrap
  "WebAssembly trap: {}"
```

### MethodResolveError {#methodresolveerror}

#### Definition {#definition-12}

```rust
pub enum MethodResolveError {
    MethodEmptyName,
    MethodUTF8Error,
    MethodNotFound,
    MethodInvalidSignature,
}
```

### CompilationError {#compilationerror}

#### Definition {#definition-13}

```rust
pub enum CompilationError {
    CodeDoesNotExist { account_id: String },
    PrepareError(PrepareError),
    WasmerCompileError { msg: String },
}
```
#### Error Messages {#error-messages-9}

```rust
CompilationError::CodeDoesNotExist
  "cannot find contract code for account {}"

CompilationError::PrepareError(p)
  "PrepareError: {}"

CompilationError::WasmerCompileError
  "Wasmer compilation error: {}"
```

### PrepareError {#prepareerror}

#### Definition {#definition-14}

```rust
/// Error that can occur while preparing or executing Wasm smart-contract.
pub enum PrepareError {
    /// Error happened while serializing the module.
    Serialization,
    /// Error happened while deserializing the module.
    Deserialization,
    /// Internal memory declaration has been found in the module.
    InternalMemoryDeclared,
    /// Gas instrumentation failed.
    ///
    /// This most likely indicates the module isn't valid.
    GasInstrumentation,
    /// Stack instrumentation failed.
    ///
    /// This  most likely indicates the module isn't valid.
    StackHeightInstrumentation,
    /// Error happened during instantiation.
    ///
    /// This might indicate that `start` function trapped, or module isn't
    /// instantiable and/or unlinkable.
    Instantiate,
    /// Error creating memory.
    Memory,
}
```

#### Error Messages {#error-messages-10}

```rust
Serialization
  "Error happened while serializing the module."

Deserialization
  "Error happened while deserializing the module."

InternalMemoryDeclared
  "Internal memory declaration has been found in the module."

GasInstrumentation
  "Gas instrumentation failed."

StackHeightInstrumentation
  "Stack instrumentation failed."

Instantiate
  "Error happened during instantiation."

Memory
  "Error creating memory"
```

### HostError {#hosterror}

#### Definition {#definition-15}

```rust
pub enum HostError {
    /// String encoding is bad UTF-16 sequence
    BadUTF16,
    /// String encoding is bad UTF-8 sequence
    BadUTF8,
    /// Exceeded the prepaid gas
    GasExceeded,
    /// Exceeded the maximum amount of gas allowed to burn per contract
    GasLimitExceeded,
    /// Exceeded the account balance
    BalanceExceeded,
    /// Tried to call an empty method name
    EmptyMethodName,
    /// Smart contract panicked
    GuestPanic { panic_msg: String },
    /// IntegerOverflow happened during a contract execution
    IntegerOverflow,
    /// `promise_idx` does not correspond to existing promises
    InvalidPromiseIndex { promise_idx: u64 },
    /// Actions can only be appended to non-joint promise.
    CannotAppendActionToJointPromise,
    /// Returning joint promise is currently prohibited
    CannotReturnJointPromise,
    /// Accessed invalid promise result index
    InvalidPromiseResultIndex { result_idx: u64 },
    /// Accessed invalid register id
    InvalidRegisterId { register_id: u64 },
    /// Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie
    IteratorWasInvalidated { iterator_index: u64 },
    /// Accessed memory outside the bounds
    MemoryAccessViolation,
    /// VM Logic returned an invalid receipt index
    InvalidReceiptIndex { receipt_index: u64 },
    /// Iterator index `iterator_index` does not exist
    InvalidIteratorIndex { iterator_index: u64 },
    /// VM Logic returned an invalid account id
    InvalidAccountId,
    /// VM Logic returned an invalid method name
    InvalidMethodName,
    /// VM Logic provided an invalid public key
    InvalidPublicKey,
    /// `method_name` is not allowed in view calls
    ProhibitedInView { method_name: String },
    /// The total number of logs will exceed the limit.
    NumberOfLogsExceeded { limit: u64 },
    /// The storage key length exceeded the limit.
    KeyLengthExceeded { length: u64, limit: u64 },
    /// The storage value length exceeded the limit.
    ValueLengthExceeded { length: u64, limit: u64 },
    /// The total log length exceeded the limit.
    TotalLogLengthExceeded { length: u64, limit: u64 },
    /// The maximum number of promises within a FunctionCall exceeded the limit.
    NumberPromisesExceeded { number_of_promises: u64, limit: u64 },
    /// The maximum number of input data dependencies exceeded the limit.
    NumberInputDataDependenciesExceeded { number_of_input_data_dependencies: u64, limit: u64 },
    /// The returned value length exceeded the limit.
    ReturnedValueLengthExceeded { length: u64, limit: u64 },
    /// The contract size for DeployContract action exceeded the limit.
    ContractSizeExceeded { size: u64, limit: u64 },
}
```
#### Error Messages {#error-messages-11}
```rust
BadUTF8 
  "String encoding is bad UTF-8 sequence."

BadUTF16 
  "String encoding is bad UTF-16 sequence."

GasExceeded 
  "Exceeded the prepaid gas."

GasLimitExceeded 
  "Exceeded the maximum amount of gas allowed to burn per contract."

BalanceExceeded 
  "Exceeded the account balance."

EmptyMethodName 
  "Tried to call an empty method name."

GuestPanic { panic_msg } 
  "Smart contract panicked: {}"

IntegerOverflow 
  "Integer overflow."

InvalidIteratorIndex { iterator_index } 
  "Iterator index {:?} does not exist"

InvalidPromiseIndex { promise_idx } 
  "{:?} does not correspond to existing promises"

CannotAppendActionToJointPromise 
  "Actions can only be appended to non-joint promise."

CannotReturnJointPromise 
  "Returning joint promise is currently prohibited."

InvalidPromiseResultIndex { result_idx } 
  "Accessed invalid promise result index: {:?}"

InvalidRegisterId { register_id } 
  "Accessed invalid register id: {:?}"

IteratorWasInvalidated { iterator_index } 
  "Iterator {:?} was invalidated after its creation by performing a mutable operation on trie"

MemoryAccessViolation 
  "Accessed memory outside the bounds."

InvalidReceiptIndex { receipt_index } 
  "VM Logic returned an invalid receipt index: {:?}"

InvalidAccountId 
  "VM Logic returned an invalid account id"

InvalidMethodName 
  "VM Logic returned an invalid method name"

InvalidPublicKey 
  "VM Logic provided an invalid public key"

ProhibitedInView { method_name } 
  "{} is not allowed in view calls"

NumberOfLogsExceeded { limit } 
  "The number of logs will exceed the limit {}"

KeyLengthExceeded { length, limit } 
  "The length of a storage key {} exceeds the limit {}"

ValueLengthExceeded { length, limit } 
  "The length of a storage value {} exceeds the limit {}"

TotalLogLengthExceeded{ length, limit } 
  "The length of a log message {} exceeds the limit {}"

NumberPromisesExceeded { number_of_promises, limit } 
  "The number of promises within a FunctionCall {} exceeds the limit {}"

NumberInputDataDependenciesExceeded { number_of_input_data_dependencies, limit } 
  "The number of input data dependencies {} exceeds the limit {}"

ReturnedValueLengthExceeded { length, limit } 
  "The length of a returned value {} exceeds the limit {}"

ContractSizeExceeded { size, limit } 
  "The size of a contract code in DeployContract action {} exceeds the limit {}"

```

### VMLogicError {#vmlogicerror}

#### Definition {#definition-16}

```rust
pub enum VMLogicError {
    HostError(HostError),
    /// Serialized external error from External trait implementation.
    ExternalError(Vec<u8>),
    /// An error that is caused by an operation on an inconsistent state.
    InconsistentStateError(InconsistentStateError),
}
```

### InconsistentStateError {#inconsistentstateerror}

#### Definition {#definition-17}

```rust
pub enum InconsistentStateError {
    /// Math operation with a value from the state resulted in a integer overflow.
    IntegerOverflow,
}
```

#### Error Messages {#error-messages-12}
```rust
InconsistentStateError::IntegerOverflow
    "Math operation with a value from the state resulted in a integer overflow."
```

## RPC interface {#rpc-interface}

- error name
- error subtype(s)
- error properties

### Error Schema {#error-schema}

```json
{
  "schema": {
    "BadUTF16": {
      "name": "BadUTF16",
      "subtypes": [],
      "props": {}
    },
    "BadUTF8": {
      "name": "BadUTF8",
      "subtypes": [],
      "props": {}
    },
    "BalanceExceeded": {
      "name": "BalanceExceeded",
      "subtypes": [],
      "props": {}
    },
    "CannotAppendActionToJointPromise": {
      "name": "CannotAppendActionToJointPromise",
      "subtypes": [],
      "props": {}
    },
    "CannotReturnJointPromise": {
      "name": "CannotReturnJointPromise",
      "subtypes": [],
      "props": {}
    },
    "CodeDoesNotExist": {
      "name": "CodeDoesNotExist",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "CompilationError": {
      "name": "CompilationError",
      "subtypes": [
        "CodeDoesNotExist",
        "PrepareError",
        "WasmerCompileError"
      ],
      "props": {}
    },
    "ContractSizeExceeded": {
      "name": "ContractSizeExceeded",
      "subtypes": [],
      "props": {
        "limit": "",
        "size": ""
      }
    },
    "Deserialization": {
      "name": "Deserialization",
      "subtypes": [],
      "props": {}
    },
    "EmptyMethodName": {
      "name": "EmptyMethodName",
      "subtypes": [],
      "props": {}
    },
    "FunctionCallError": {
      "name": "FunctionCallError",
      "subtypes": [
        "CompilationError",
        "LinkError",
        "MethodResolveError",
        "WasmTrap",
        "HostError"
      ],
      "props": {}
    },
    "GasExceeded": {
      "name": "GasExceeded",
      "subtypes": [],
      "props": {}
    },
    "GasInstrumentation": {
      "name": "GasInstrumentation",
      "subtypes": [],
      "props": {}
    },
    "GasLimitExceeded": {
      "name": "GasLimitExceeded",
      "subtypes": [],
      "props": {}
    },
    "GuestPanic": {
      "name": "GuestPanic",
      "subtypes": [],
      "props": {
        "panic_msg": ""
      }
    },
    "HostError": {
      "name": "HostError",
      "subtypes": [
        "BadUTF16",
        "BadUTF8",
        "GasExceeded",
        "GasLimitExceeded",
        "BalanceExceeded",
        "EmptyMethodName",
        "GuestPanic",
        "IntegerOverflow",
        "InvalidPromiseIndex",
        "CannotAppendActionToJointPromise",
        "CannotReturnJointPromise",
        "InvalidPromiseResultIndex",
        "InvalidRegisterId",
        "IteratorWasInvalidated",
        "MemoryAccessViolation",
        "InvalidReceiptIndex",
        "InvalidIteratorIndex",
        "InvalidAccountId",
        "InvalidMethodName",
        "InvalidPublicKey",
        "ProhibitedInView",
        "NumberOfLogsExceeded",
        "KeyLengthExceeded",
        "ValueLengthExceeded",
        "TotalLogLengthExceeded",
        "NumberPromisesExceeded",
        "NumberInputDataDependenciesExceeded",
        "ReturnedValueLengthExceeded",
        "ContractSizeExceeded"
      ],
      "props": {}
    },
    "Instantiate": {
      "name": "Instantiate",
      "subtypes": [],
      "props": {}
    },
    "IntegerOverflow": {
      "name": "IntegerOverflow",
      "subtypes": [],
      "props": {}
    },
    "InternalMemoryDeclared": {
      "name": "InternalMemoryDeclared",
      "subtypes": [],
      "props": {}
    },
    "InvalidAccountId": {
      "name": "InvalidAccountId",
      "subtypes": [],
      "props": {}
    },
    "InvalidIteratorIndex": {
      "name": "InvalidIteratorIndex",
      "subtypes": [],
      "props": {
        "iterator_index": ""
      }
    },
    "InvalidMethodName": {
      "name": "InvalidMethodName",
      "subtypes": [],
      "props": {}
    },
    "InvalidPromiseIndex": {
      "name": "InvalidPromiseIndex",
      "subtypes": [],
      "props": {
        "promise_idx": ""
      }
    },
    "InvalidPromiseResultIndex": {
      "name": "InvalidPromiseResultIndex",
      "subtypes": [],
      "props": {
        "result_idx": ""
      }
    },
    "InvalidPublicKey": {
      "name": "InvalidPublicKey",
      "subtypes": [],
      "props": {}
    },
    "InvalidReceiptIndex": {
      "name": "InvalidReceiptIndex",
      "subtypes": [],
      "props": {
        "receipt_index": ""
      }
    },
    "InvalidRegisterId": {
      "name": "InvalidRegisterId",
      "subtypes": [],
      "props": {
        "register_id": ""
      }
    },
    "IteratorWasInvalidated": {
      "name": "IteratorWasInvalidated",
      "subtypes": [],
      "props": {
        "iterator_index": ""
      }
    },
    "KeyLengthExceeded": {
      "name": "KeyLengthExceeded",
      "subtypes": [],
      "props": {
        "length": "",
        "limit": ""
      }
    },
    "LinkError": {
      "name": "LinkError",
      "subtypes": [],
      "props": {
        "msg": ""
      }
    },
    "Memory": {
      "name": "Memory",
      "subtypes": [],
      "props": {}
    },
    "MemoryAccessViolation": {
      "name": "MemoryAccessViolation",
      "subtypes": [],
      "props": {}
    },
    "MethodEmptyName": {
      "name": "MethodEmptyName",
      "subtypes": [],
      "props": {}
    },
    "MethodInvalidSignature": {
      "name": "MethodInvalidSignature",
      "subtypes": [],
      "props": {}
    },
    "MethodNotFound": {
      "name": "MethodNotFound",
      "subtypes": [],
      "props": {}
    },
    "MethodResolveError": {
      "name": "MethodResolveError",
      "subtypes": [
        "MethodEmptyName",
        "MethodUTF8Error",
        "MethodNotFound",
        "MethodInvalidSignature"
      ],
      "props": {}
    },
    "MethodUTF8Error": {
      "name": "MethodUTF8Error",
      "subtypes": [],
      "props": {}
    },
    "NumberInputDataDependenciesExceeded": {
      "name": "NumberInputDataDependenciesExceeded",
      "subtypes": [],
      "props": {
        "limit": "",
        "number_of_input_data_dependencies": ""
      }
    },
    "NumberOfLogsExceeded": {
      "name": "NumberOfLogsExceeded",
      "subtypes": [],
      "props": {
        "limit": ""
      }
    },
    "NumberPromisesExceeded": {
      "name": "NumberPromisesExceeded",
      "subtypes": [],
      "props": {
        "limit": "",
        "number_of_promises": ""
      }
    },
    "PrepareError": {
      "name": "PrepareError",
      "subtypes": [
        "Serialization",
        "Deserialization",
        "InternalMemoryDeclared",
        "GasInstrumentation",
        "StackHeightInstrumentation",
        "Instantiate",
        "Memory"
      ],
      "props": {}
    },
    "ProhibitedInView": {
      "name": "ProhibitedInView",
      "subtypes": [],
      "props": {
        "method_name": ""
      }
    },
    "ReturnedValueLengthExceeded": {
      "name": "ReturnedValueLengthExceeded",
      "subtypes": [],
      "props": {
        "length": "",
        "limit": ""
      }
    },
    "Serialization": {
      "name": "Serialization",
      "subtypes": [],
      "props": {}
    },
    "StackHeightInstrumentation": {
      "name": "StackHeightInstrumentation",
      "subtypes": [],
      "props": {}
    },
    "TotalLogLengthExceeded": {
      "name": "TotalLogLengthExceeded",
      "subtypes": [],
      "props": {
        "length": "",
        "limit": ""
      }
    },
    "ValueLengthExceeded": {
      "name": "ValueLengthExceeded",
      "subtypes": [],
      "props": {
        "length": "",
        "limit": ""
      }
    },
    "WasmTrap": {
      "name": "WasmTrap",
      "subtypes": [],
      "props": {
        "msg": ""
      }
    },
    "WasmerCompileError": {
      "name": "WasmerCompileError",
      "subtypes": [],
      "props": {
        "msg": ""
      }
    },
    "AccessKeyNotFound": {
      "name": "AccessKeyNotFound",
      "subtypes": [],
      "props": {
        "account_id": "",
        "public_key": ""
      }
    },
    "AccountAlreadyExists": {
      "name": "AccountAlreadyExists",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "AccountDoesNotExist": {
      "name": "AccountDoesNotExist",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "ActionError": {
      "name": "ActionError",
      "subtypes": [
        "AccountAlreadyExists",
        "AccountDoesNotExist",
        "CreateAccountNotAllowed",
        "ActorNoPermission",
        "DeleteKeyDoesNotExist",
        "AddKeyAlreadyExists",
        "DeleteAccountStaking",
        "DeleteAccountHasRent",
        "RentUnpaid",
        "TriesToUnstake",
        "TriesToStake",
        "FunctionCallError",
        "NewReceiptValidationError"
      ],
      "props": {
        "index": ""
      }
    },
    "ActorNoPermission": {
      "name": "ActorNoPermission",
      "subtypes": [],
      "props": {
        "account_id": "",
        "actor_id": ""
      }
    },
    "AddKeyAlreadyExists": {
      "name": "AddKeyAlreadyExists",
      "subtypes": [],
      "props": {
        "account_id": "",
        "public_key": ""
      }
    },
    "BalanceMismatchError": {
      "name": "BalanceMismatchError",
      "subtypes": [],
      "props": {
        "final_accounts_balance": "",
        "final_postponed_receipts_balance": "",
        "incoming_receipts_balance": "",
        "incoming_validator_rewards": "",
        "initial_accounts_balance": "",
        "initial_postponed_receipts_balance": "",
        "new_delayed_receipts_balance": "",
        "outgoing_receipts_balance": "",
        "processed_delayed_receipts_balance": "",
        "total_balance_burnt": "",
        "total_balance_slashed": "",
        "total_rent_paid": "",
        "total_validator_reward": ""
      }
    },
    "CostOverflow": {
      "name": "CostOverflow",
      "subtypes": [],
      "props": {}
    },
    "CreateAccountNotAllowed": {
      "name": "CreateAccountNotAllowed",
      "subtypes": [],
      "props": {
        "account_id": "",
        "predecessor_id": ""
      }
    },
    "DeleteAccountHasRent": {
      "name": "DeleteAccountHasRent",
      "subtypes": [],
      "props": {
        "account_id": "",
        "balance": ""
      }
    },
    "DeleteAccountStaking": {
      "name": "DeleteAccountStaking",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "DeleteKeyDoesNotExist": {
      "name": "DeleteKeyDoesNotExist",
      "subtypes": [],
      "props": {
        "account_id": "",
        "public_key": ""
      }
    },
    "DepositWithFunctionCall": {
      "name": "DepositWithFunctionCall",
      "subtypes": [],
      "props": {}
    },
    "Expired": {
      "name": "Expired",
      "subtypes": [],
      "props": {}
    },
    "InvalidAccessKeyError": {
      "name": "InvalidAccessKeyError",
      "subtypes": [
        "AccessKeyNotFound",
        "ReceiverMismatch",
        "MethodNameMismatch",
        "RequiresFullAccess",
        "NotEnoughAllowance",
        "DepositWithFunctionCall"
      ],
      "props": {}
    },
    "InvalidChain": {
      "name": "InvalidChain",
      "subtypes": [],
      "props": {}
    },
    "InvalidNonce": {
      "name": "InvalidNonce",
      "subtypes": [],
      "props": {
        "ak_nonce": "",
        "tx_nonce": ""
      }
    },
    "InvalidReceiverId": {
      "name": "InvalidReceiverId",
      "subtypes": [],
      "props": {
        "receiver_id": ""
      }
    },
    "InvalidSignature": {
      "name": "InvalidSignature",
      "subtypes": [],
      "props": {}
    },
    "InvalidSignerId": {
      "name": "InvalidSignerId",
      "subtypes": [],
      "props": {
        "signer_id": ""
      }
    },
    "InvalidTxError": {
      "name": "InvalidTxError",
      "subtypes": [
        "InvalidAccessKeyError",
        "InvalidSignerId",
        "SignerDoesNotExist",
        "InvalidNonce",
        "InvalidReceiverId",
        "InvalidSignature",
        "NotEnoughBalance",
        "RentUnpaid",
        "CostOverflow",
        "InvalidChain",
        "Expired",
        "ActionsValidation"
      ],
      "props": {}
    },
    "MethodNameMismatch": {
      "name": "MethodNameMismatch",
      "subtypes": [],
      "props": {
        "method_name": ""
      }
    },
    "NotEnoughAllowance": {
      "name": "NotEnoughAllowance",
      "subtypes": [],
      "props": {
        "account_id": "",
        "allowance": "",
        "cost": "",
        "public_key": ""
      }
    },
    "NotEnoughBalance": {
      "name": "NotEnoughBalance",
      "subtypes": [],
      "props": {
        "balance": "",
        "cost": "",
        "signer_id": ""
      }
    },
    "ReceiverMismatch": {
      "name": "ReceiverMismatch",
      "subtypes": [],
      "props": {
        "ak_receiver": "",
        "tx_receiver": ""
      }
    },
    "RentUnpaid": {
      "name": "RentUnpaid",
      "subtypes": [],
      "props": {
        "account_id": "",
        "amount": ""
      }
    },
    "RequiresFullAccess": {
      "name": "RequiresFullAccess",
      "subtypes": [],
      "props": {}
    },
    "SignerDoesNotExist": {
      "name": "SignerDoesNotExist",
      "subtypes": [],
      "props": {
        "signer_id": ""
      }
    },
    "TriesToStake": {
      "name": "TriesToStake",
      "subtypes": [],
      "props": {
        "account_id": "",
        "balance": "",
        "locked": "",
        "stake": ""
      }
    },
    "TriesToUnstake": {
      "name": "TriesToUnstake",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "TxExecutionError": {
      "name": "TxExecutionError",
      "subtypes": [
        "ActionError",
        "InvalidTxError"
      ],
      "props": {}
    },
    "Closed": {
      "name": "Closed",
      "subtypes": [],
      "props": {}
    },
    "ServerError": {
      "name": "ServerError",
      "subtypes": [
        "TxExecutionError",
        "Timeout",
        "Closed"
      ],
      "props": {}
    },
    "Timeout": {
      "name": "Timeout",
      "subtypes": [],
      "props": {}
    }
  }
}
```

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol"> Ask it on StackOverflow! </a>
:::

'''
'''--- docs/6.integrations/errors/introduction.md ---
---
id: introduction
title: Introduction
sidebar_label: Introduction
---

<blockquote className="info">
<strong>did you know?</strong><br /><br />

The [NEAR Platform overview](/concepts/welcome) clarifies much of the language in this section.

</blockquote>

## The life of a transaction: {#the-life-of-a-transaction}

- A client creates a transaction, computes the transaction hash and signs this hash to get a signed transaction. Now this signed transaction can be sent to a node.
- The RPC interface receives the transaction and routes it to the correct physical node using `signer_id`.  Since the `signer_id` must be a NEAR Account ID which lives on a single shard, the account is mapped to a shard which is followed by at least one validator running at least one machine with an IP address.
- When a node receives a new signed transaction, it validates the transaction for signer, receiver, account balance, cost overflow, signature, etc. ([see here](https://nomicon.io/RuntimeSpec/Scenarios/FinancialTransaction.html#transaction-to-receipt)) and gossips it to all peers following the same shard. If a transaction has an invalid signature or would be invalid on the latest state, it is rejected quickly and returns an error to the original RPC call. 
- Valid transactions are added to the transaction pool (every validating node has its own independent copy of a transaction pool). The transaction pool maintains transactions that are not yet discarded and not yet included into the chain.
- A pool iterator is used to pick transactions from the pool one at a time, ordered from the smallest nonce to largest, until the pool is drained or some chunk limit is reached (max number of transactions per chunk or max gas burnt per chunk to process transactions).  Please refer to articles on the [pool iterator](https://nomicon.io/ChainSpec/Transactions.html?highlight=pool#pool-iterator) and [gas](/concepts/protocol/gas) for more details.
- To accommodate the distributed nature of a sharded blockchain, all transactions are subsequently returned to a segmented transaction pool having 3 distinct layers: accepted transactions (which will be processed on the next chunk), pending transactions (which exceeded the limits of the current chunk and will be included in a later round of processing) and invalid transactions (which will be rejected at the next available opportunity).
- Before producing a chunk, transactions are ordered and validated again. This is done to produce chunks with only valid transactions across a distributed system.
- While a transaction is being processed on to a chunk, any errors raised by the application of its actions are also returned via RPC.

## NEAR Platform Errors {#near-platform-errors}

Errors raised by the NEAR platform are implemented in the following locations in `nearcore`:

- [nearcore/core/primitives/src/errors.rs](https://github.com/near/nearcore/blob/master/core/primitives/src/errors.rs)
- [nearcore/runtime/near-vm-errors/src/lib.rs](https://github.com/near/nearcore/blob/master/runtime/near-vm-errors/src/lib.rs)

This page includes: 
- **RuntimeError and subtypes**: errors raised when a transaction is first received by the destination node and again before it's processed and applied to a chunk
- **TxExecutionError and subtypes**: errors raised while a transaction and its component action(s) are being validated and applied to a chunk
- **VMerror and subtypes**: errors raised during the execution of a Wasm contract by the NEAR VM

### RuntimeError and subtypes {#runtimeerror-and-subtypes}

```text
RuntimeError                                              Error returned from `Runtime::apply  
  StorageError                                            Unexpected error which is typically related to the node storage corruption.account
  BalanceMismatchError                                    An error happens if `check_balance` fails, which is likely an indication of an invalid state
  InvalidTxError                                          An error happened during TX verification and account charging
    InvalidAccessKeyError                                 Describes the error for validating access key
    ActionsValidationError                                Describes the error for validating a list of actions    
      TotalPrepaidGasExceeded                             The total prepaid gas (for all given actions) exceeded the limit.
      TotalNumberOfActionsExceeded                        The number of actions exceeded the given limit.
      AddKeyMethodNamesNumberOfBytesExceeded              The total number of bytes of the method names exceeded the limit in a Add Key action.
      AddKeyMethodNameLengthExceeded                      The length of some method name exceeded the limit in a Add Key action.
      IntegerOverflow                                     Integer overflow during a compute.
      InvalidAccountId                                    Invalid account ID.
      ContractSizeExceeded                                The size of the contract code exceeded the limit in a DeployContract action.
      FunctionCallMethodNameLengthExceeded                The length of the method name exceeded the limit in a Function Call action.
      FunctionCallArgumentsLengthExceeded                 The length of the arguments exceeded the limit in a Function Call action.
```

### TxExecutionError and subtypes {#txexecutionerror-and-subtypes}

```text
TxExecutionError                                          Error returned in the ExecutionOutcome in case of failure
  InvalidTxError                                          An error happened during Transaction execution
    InvalidAccessKeyError                                 Describes the error for validating access key
    ActionsValidationError                                Describes the error for validating a list of actions
      TotalPrepaidGasExceeded                             The total prepaid gas (for all given actions) exceeded the limit.
      TotalNumberOfActionsExceeded                        The number of actions exceeded the given limit.
      AddKeyMethodNamesNumberOfBytesExceeded              The total number of bytes of the method names exceeded the limit in a Add Key action.
      AddKeyMethodNameLengthExceeded                      The length of some method name exceeded the limit in a Add Key action.
      IntegerOverflow                                     Integer overflow during a compute.
      InvalidAccountId                                    Invalid account ID.
      ContractSizeExceeded                                The size of the contract code exceeded the limit in a DeployContract action.
      FunctionCallMethodNameLengthExceeded                The length of the method name exceeded the limit in a Function Call action.
      FunctionCallArgumentsLengthExceeded                 The length of the arguments exceeded the limit in a Function Call action.
  ActionError                                             An error happened during Acton execution
    ActionErrorKind                                       The kind of ActionError happened
      RuntimeCallError 
      ReceiptValidationError                              Describes the error for validating a receipt
        ActionsValidationError                            Describes the error for validating a list of actions    
          TotalPrepaidGasExceeded                         The total prepaid gas (for all given actions) exceeded the limit.
          TotalNumberOfActionsExceeded                    The number of actions exceeded the given limit.
          AddKeyMethodNamesNumberOfBytesExceeded          The total number of bytes of the method names exceeded the limit in a Add Key action.
          AddKeyMethodNameLengthExceeded                  The length of some method name exceeded the limit in a Add Key action.
          IntegerOverflow                                 Integer overflow during a compute.
          InvalidAccountId                                Invalid account ID.
          ContractSizeExceeded                            The size of the contract code exceeded the limit in a DeployContract action.
          FunctionCallMethodNameLengthExceeded            The length of the method name exceeded the limit in a Function Call action.
          FunctionCallArgumentsLengthExceeded             The length of the arguments exceeded the limit in a Function Call action.
```

### VMerror and subtypes {#vmerror-and-subtypes}

```text
VMerror                                                   An error that occurs in the NEAR virtual machine
  ExternalError                                           Serialized external error from External trait implementation
  InconsistentStateError                                  An error that is caused by an operation on an inconsistent state (ie. an integer overflow by using a value from the given context
    IntegerOverflow                                       Math operation with a value from the state resulted in a integer overflow
  FunctionCallError 
    LinkError 
    WasmTrap 
    MethodResolveError 
      MethodEmptyName 
      MethodUTF8Error 
      MethodNotFound 
      MethodInvalidSignature 
    HostError 
      BadUTF16                                            String encoding is bad UTF-16 sequence
      BadUTF8                                             String encoding is bad UTF-8 sequence
      GasExceeded                                         Exceeded the prepaid ga
      GasLimitExceeded                                    Exceeded the maximum amount of gas allowed to burn per contract
      BalanceExceeded                                     Exceeded the account balance
      EmptyMethodName                                     Tried to call an empty method nam
      GuestPanic                                          Smart contract panicked
      IntegerOverflow                                     IntegerOverflow happened during a contract execution
      InvalidPromiseIndex                                 `promise_idx` does not correspond to existing promises
      CannotAppendActionToJointPromise                    Actions can only be appended to non-joint promise.
      CannotReturnJointPromise                            Returning joint promise is currently prohibited
      InvalidPromiseResultIndex                           Accessed invalid promise result index
      InvalidRegisterId                                   Accessed invalid register id
      IteratorWasInvalidated                              Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie
      MemoryAccessViolation                               Accessed memory outside the bounds
      InvalidReceiptIndex                                 VM Logic returned an invalid receipt index
      InvalidIteratorIndex                                Iterator index `iterator_index` does not exist
      InvalidAccountId                                    VM Logic returned an invalid account id
      InvalidMethodName                                   VM Logic returned an invalid method name
      InvalidPublicKey                                    VM Logic provided an invalid public key
      ProhibitedInView                                    `method_name` is not allowed in view calls
      NumberOfLogsExceeded                                The total number of logs will exceed the limit.
      KeyLengthExceeded                                   The storage key length exceeded the limit.
      ValueLengthExceeded                                 The storage value length exceeded the limit.
      TotalLogLengthExceeded                              The total log length exceeded the limit.
      NumberPromisesExceeded                              The maximum number of promises within a FunctionCall exceeded the limit.
      NumberInputDataDependenciesExceeded                 The maximum number of input data dependencies exceeded the limit.
      ReturnedValueLengthExceeded                         The returned value length exceeded the limit.
      ContractSizeExceeded                                The contract size for DeployContract action exceeded the limit.
    CompilationError 
      CodeDoesNotExist 
      WasmerCompileError 
      PrepareError                                        Error that can occur while preparing or executing Wasm smart-contract
        Serialization                                     Error happened while serializing the module
        Deserialization                                   Error happened while deserializing the module
        InternalMemoryDeclared                            Internal memory declaration has been found in the module
        GasInstrumentation                                Gas instrumentation failed.  This most likely indicates the module isn't valid
        StackHeightInstrumentation                        Stack instrumentation failed.  This  most likely indicates the module isn't valid
        Instantiate                                       Error happened during instantiation.  This might indicate that `start` function trapped, or module isn't instantiable and/or unlinkable
        Memory                                            Error creating memory
```

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol"> Ask it on StackOverflow! </a>
:::

'''
'''--- docs/6.integrations/errors/token-loss.md ---
---
id: token-loss
title: Avoiding Token Loss
sidebar_label: Avoiding Token Loss
---

:::warning
Careful! Losing tokens means losing money!
:::

Token loss is possible under multiple scenarios. These scenarios can be grouped into a few related classes:

1. Improper key management
2. Refunding deleted accounts
3. Failed function calls in batches

---

## Improper key management

Improper key management may lead to token loss. Mitigating such scenarios may be done by issuing backup keys
allowing for recovery of accounts whose keys have been lost or deleted.

### Loss of `FullAccess` key

A user may lose their private key of a `FullAccess` key pair for an account with no other keys.
No one will be able to recover the funds. Funds will remain locked in the account forever.

### Loss of `FunctionCall` access key

An account may have its one and only `FunctionCall` access key deleted.
No one will be able to recover the funds. Funds will remain locked in the account forever.

---
## Refunding deleted accounts

When a refund receipt is issued for an account, if that account no longer exists, the funds will be dispersed among
validators proportional to their stake in the current epoch.

### Deleting account with non-existent beneficiary

When you delete an account, you must assign a beneficiary.
Once deleted, a transfer receipt is generated and sent to the beneficiary account.
If the beneficiary account does not exist, a refund receipt will be generated and sent back to the original account.
Since the original account has already been deleted, the funds will be dispersed among validators.

### Account with zero balance is garbage-collected, just before it receives refund

If an account `A` transfers all of its funds to another account `B` and account `B` does not exist,
a refund receipt will be generated for account `A`. During the period of this round trip,
account `A` is vulnerable to deletion by garbage collection activities on the network.
If account `A` is deleted before the refund receipt arrives, the funds will be dispersed among validators.

---
## Failed function calls in batches

:::warning
When designing a smart contract, you should always consider the asynchronous nature of NEAR Protocol.
:::

If a contract function `f1` calls two (or more) other functions `f2` and `f3`, and at least one of these functions, `f2` and `f3` fails, then tokens will be refunded from the function that failed, but tokens will be appropriately credited to the function(s) which succeed.

The successful call's tokens may be considered lost depending on your use case if a single failure in the batch means the whole batch failed.

'''
'''--- docs/6.integrations/exchange-integration.md ---
---
id: exchange-integration
title: Exchange Integration
sidebar_label: Exchange Integration
---

## Integration Reference {#integration-reference}

- [Balance Changes](/integrations/balance-changes)
- [Accounts](/integrations/accounts)
- [Fungible Tokens](/integrations/fungible-tokens)
- [Implicit Accounts](/integrations/implicit-accounts)

### Transaction Reference Links {#transaction-reference-links}

 - [Basics](/concepts/protocol/transactions)
 - [Specifications](https://nomicon.io/RuntimeSpec/Transactions)
 - [Constructing Transactions](/integrations/create-transactions)

## Blocks and Finality {#blocks-and-finality}

Some important pieces of information regarding blocks and finality include:

- Expected block time is around 1s and expected time to finality is around 2s. The last final block can be queried by
  specifying `{"finality": "final"}` in the block query. For example, to get the latest final block on mainnet, one can run

```bash
http post https://rpc.mainnet.near.org method=block params:='{"finality":"final"}' id=123 jsonrpc=2.0
```

- Block height are not necessarily continuous and certain heights may be skipped if, for example, a block producer for that height is offline. For example, after a block at height 100 is produced, the block at height 101 may be skipped. When block at height 102 is produced, its previous block is the block at height 100.

- Some blocks may not include new chunks if, for example, the previous chunk producer is offline. Even though in the RPC
  return result every block will have non-empty `chunks` field, it does not imply that there is a new chunk included in the block.
  The way to tell whether the chunk is included in the block is to check whether `height_included` in the chunk is the same
  as the height of the block.

## Running an Archival Node {#running-an-archival-node}
Please refer to configuration changes required in `config.json` for archival node by referring to the documentation on [Run an Archival Node](https://near-nodes.io/archival/run-archival-node-with-nearup).

## Staking and Delegation {#staking-and-delegation}

- [https://github.com/nearprotocol/stakewars](https://github.com/nearprotocol/stakewars)
- [https://github.com/near/core-contracts](https://github.com/near/core-contracts)

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol"> Ask it on StackOverflow! </a>
:::

'''
'''--- docs/6.integrations/faq.md ---
---
id: faq
title: Integrator FAQ
sidebar_label: Integrator FAQ
---

## Orientation

### What is a good project summary for NEAR?

NEAR is a sharded, public, proof-of-stake blockchain and smart contract platform. It is built in Rust and contracts compile to WASM. It is conceptually similar to Ethereum 2.0.

### What's special about NEAR?

NEAR is the blockchain for builders.

If you understand the basics of web development, you can write, test and deploy scalable decentralized applications in minutes on the most developer-friendly blockchain without having to learn new tools or languages.

### Is NEAR open source?

Yes. Have a look at our [GitHub organization](https://github.com/near).

### How are cryptographic functions used?

We support both `secp256k1` and `ed25519` for account keys and `ed25519` for signing transactions. We currently use the `ed25519_dalek` and `sha2` libraries for crypto.

### Do you have any on-chain governance mechanisms?

NEAR does not have any on-chain governance at the moment. Any changes to state or state transition function must be done through a hard fork.

### Do you have a bug-bounty program?

Our plan is to have a transparent Bug Bounty program with clear guidelines for paying out to those reporting issues. Payments will likely be based on publicly available rankings provided by protocol developers based on issue severity.

### What contracts should we be aware of right now?

We have developed a number of [initial contracts](https://github.com/near/core-contracts) with **ones in bold** being most mature at time of writing

- **Staking Pool / Delegation contract**
- **Lockup / Vesting contract**
- Whitelist Contract
- Staking Pool Factory
- Multisig contract

### Do you have a cold wallet implementation (ie. Ledger)?

https://github.com/near/near-ledger-app

## Validators

### What is the process for becoming a validator?

Validation is permissionless and determined via auction. Parties who want to become a validator submit a special transaction to the chain one day ahead which indicates how many tokens they want to stake. An auction is run which determines the minimum necessary stake to get a validation seat during the next epoch and, if the amount submitted is greater than the minimum threshold, the submitter will validate at least one shard during the next epoch.

### How long does a validator remain a validator?

A validator will stop being a validator for the following reasons:

- Not producing enough blocks or chunks.
- Not getting elected in the auction for next epoch because their stake is not large enough.
- Getting slashed.
  Otherwise a validator will remain a validator indefinitely.

Validator election happens in epochs. The [Nightshade whitepaper](/docs/Nightshade.pdf) introduces epochs this way: "the maintenance of the network is done in epochs" where an epoch is a period of time on the order of half a day.

At the beginning of each epoch, some computation produces a list of validators for the _very next epoch_.
The input to this computation includes all accounts that have "raised their hand to be a validator"
by submitting a special transaction ([`StakeAction`](https://nomicon.io/RuntimeSpec/Actions.html#stakeaction))
expressing the commitment of some amount of tokens over the system's staking threshold,
as well as validators from the previous epoch.
The output of this computation is a list of the validators for the very next epoch.

### What is the penalty for misbehaving validators?

Validators are not slashed for being offline but they do miss out on the rewards of validating. Validators who miss too many blocks or chunks will be removed from the validation set in the next auction and not get any reward (but, again, without slashing).

Any foul play on the part of the validator that is detected by the system may result in a "slashing event" where the validator is marked as out of integrity and forfeit their stake (according to some formula of progressive severity). The slashed stake is burnt.

### What is the mechanism for delegating stake to validators?

NEAR supports separate validation keys that can be used in smart contracts to delegate stake. Delegation is done via smart contract which allows for a validator to define a custom way to collect stake, manage it and split rewards. This also allows validators to provide leverage or derivatives on stake. Delegated stake will be slashed like any other stake if the node misbehaves.

If a validator misbehaves the funds of the delegators are also slashed. There is no waiting period for delegators to withdraw their stake.

### Does a validator control funds that have been delegated to them? 

Delegation is custodial (you are transferring funds to a different account, the smart contract that implements staking pool). We provide a reference implementation being security reviewed and tested by 100 validators at time of writing.

We allow validators to write and deploy new contracts but it is up to users to decide if they want to delegate. Validators can compete for delegation by choosing different logic and conditions around tax optimization, etc.

Currently no slashing but will be added as we add shards into the system. At some point validators will be able to add an option to shield delegators from slashing (similar to Tezos model).

### How do we get the balance of an account after it has delegated funds?

One would need to query the staking pool contract to get balance.

## Nodes

### Can a node be configured to archive all blockchain data since genesis? 

v
Yes. Start the node using the following command:

```sh
./target/release/near run --archive
```

### Can a node be configured to expose an RPC (ex: HTTP) interface? 

Yes. All nodes expose this interface by default which can be configured by setting the value of `listen_addr:port` in the node's `config.json` file.

### Can a node be gracefully terminated and restarted (using archived data on disk to continue syncing)? 

Yes.

### Does a node expose an interface for retrieving health telemetry in a structured format (ex: JSON) over RPC?

Yes. `GET /status` and `GET /health` provide this interface.

- `/status`: block height, syncing status, peer count, etc
- `/health`: success/failure if node is up running & progressing

### Can a node be started using a Dockerfile without human supervision? 

Yes.

```sh
docker run <port mapping> <mount data folder> <ENV vars> nearprotocol/nearcore:latest
```

See `nearcore/scripts/nodelib.py` for different examples of configuration.

### What is the source of truth for current block height exposed via API? 

- MainNet
  - https://nearblocks.io
  - `https://rpc.mainnet.near.org/status`
- TestNet
  - https://testnet.nearblocks.io
  - `https://rpc.testnet.near.org/status`

### How old can the referenced block hash be before it's invalid?

There is a genesis parameter which can be discovered for any network using:

```sh
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_genesis_config
# in the line above, testnet may be replaced with mainnet or betanet
```

It's `43200` seconds or `~12` hours. You can view the live configuration for `epoch_length` using the [`protocol_config` RPC endpoint](/api/rpc/setup#protocol-config).

In the response we find `transaction_validity_period": 86400` (and since it takes about 1 second to produce a block, this period is about 24 hrs)

## Blockchain

### How will the network will be bootstrapped?

Distribution at genesis will be spread among the NEAR team, our contributors, project partners (ie. contributor, beta applications, infrastructure developers, etc.) and the NEAR foundation (with many portions of that segregated for post-MainNet distribution activity and unavailable to stake so the foundation isn‚Äôt able to control the network).

There will be auctions occurring on the platform after launch which will allocate large amounts of tokens over the next 2 years. Additionally we are planning to run TestNet where any validator who participates will receive rewards in real tokens. We are planning to onboard at least 50 separate entities to be validators at launch.

### What is the network upgrade process? 

We are currently upgrading via restarting with a new genesis block.

### Which consensus algorithm does NEAR use?

NEAR is a sharded **proof-of-stake** blockchain.

_You can read more in our [Nightshade whitepaper](/docs/Nightshade.pdf)._

> _A few relevant details have been extracted here for convenience:_
>
> [Since NEAR is a sharded blockchain, there are challenges that need to be overcome] including state validity and data
> availability problems. _Nightshade_ is the solution NEAR Protocol is built upon that addresses these issues.
>
> Nightshade uses the heaviest chain consensus. Specifically when a block producer produces a block (see section 3.3), they can collect signatures from other block producers and validators attesting to the previous block. The weight of a block is then the cumulative stake of all the signers whose signatures are included in the block. The weight of a chain is the sum of the block weights.
>
> On top of the heaviest chain consensus we use a finality gadget that uses the attestations to finalize the blocks. To reduce the complexity of the system, we use a finality gadget that doesn‚Äôt influence the fork choice rule in any way, and instead only introduces extra slashing conditions, such that once a block is finalized by the finality gadget, a fork is impossible unless a very large percentage of the total stake is slashed.

### How does on-chain transaction finality work?

Finality is deterministic, and requires at least 3 blocks as well as (2/3 +1) signatures of the current validator set.

In a normal operation, we expect this to happen right at 3 blocks but it is not guaranteed.

Finality will be exposed via RPC when querying block or transaction.

Our definition of finality is BOTH:

- Block has quorum pre-commit from the finality gadget. See details of the finality gadget [[here]](/docs/PoST.pdf)
- At least 120 blocks (2-3 minutes) built on top of the block of interest. This is relevant in case of invalid state transition in some shard and provides enough time for state change challenges. In case all shards are tracked and some mechanics to pause across nodes is employed, this is not needed. We recommend exchanges track all shards.

## Accounts

### How are addresses generated?

Please check out the spec here on accounts https://nomicon.io/DataStructures/Account.html.

### What is the balance record-keeping model on the NEAR platform?

NEAR uses an `Account`-based model. All users and contracts are associated with at least 1 account. Each account lives on a single shard. Each account can have multiple keys for signing transactions.

_You can read [more about NEAR accounts here](https://nomicon.io/DataStructures/Account.html)_

### How are user accounts represented on-chain?

Users create accounts with human-readable names (eg `alice`) which can contain multiple keypairs with individual permissions. Accounts can be atomically and securely transferred between parties as a native transaction on the network. Permissions are programmable with smart contracts as well. For example, a lock up contract is just an account with permission on the key that does not allow to transfer funds greater than those unlocked.

### Is there a minimum account balance?

To limit on-chain "dust", accounts (and contracts) are charged a refundable deposit for storing data on the chain. This means that if the balance of the account does not have enough balance to cover an increased deposit for additional storage of data, storing additional data will fail. Also, any user can remove their own account and transfer left over balance to another (beneficiary) account.

There will be a restoration mechanism for accounts removed (or slept) in this way implemented in the future.

### How many keys are used?

An account can have arbitrarily many keys, as long as it has enough tokens for their storage.

### Which balance look-ups exists? What is required?

We have an [RPC method for viewing account](/api/rpc/setup#view_account).

The [JS implementation is here](https://github.com/near/near-api-js/blob/d7f0cb87ec320b723734045a4ee9d17d94574a19/src/providers/json-rpc-provider.ts#L73). Note that in this RPC interface you can specify the finality requirement (whether to query the latest state or finalized state).

For custody purposes, it is recommended not to rely on latest state but only what is finalized.

## Fees

### What is the fee structure for on-chain transactions? 

NEAR uses a gas-based model where prices are generally deterministically adjusted based on congestion of the network.

We avoid making changes that are too large through re-sharding by changing number of available shards (and thus throughput).

Accounts don‚Äôt have associated resources. Gas amount is predetermined for all transactions except function calls. For function call transactions the user (or more likely the developer) attaches the required amount of gas. If some gas is left over after the function call, it is converted back to NEAR and refunded to the original funding account.

### How do we know how much gas to add to a transaction?

- See reference documentation here: https://nomicon.io/Economics/
- See API documentation for [discovering gas price via RPC here](/api/rpc/setup#gas-price).

The issuer of a transaction should attach some amount of gas by taking a guess at budget which will get the transaction processed. The contract knows how much to fund different cross contract calls. Gas price is calculated and fixed per block, but may change from block to block depending on how full / busy the block is. If blocks become more than half full then gas price increases.

We're also considering adding a max gas price limit.

## Transactions

### How do we follow Tx status?

See related [RPC interface for fetching transaction status here](/api/rpc/setup#transaction-status).

### How are transactions constructed and signed?

Transactions are a collection of related data that is composed and cryptographically signed by the sender using their private key. The related public key is part of the transaction and used for signature verification. Only signed transactions may be sent to the network for processing.

Transactions can be constructed and signed offline. Nodes are not required for signing. We are planning to add optional recent block hash to help prevent various replay attacks.

See [transactions](/concepts/protocol/transactions) in the concepts section of our documentation.

### How is the hash preimage generated? Which fields does the raw transaction consist of? 

For a transaction, we sign the hash of the transaction. More specifically, what is signed is the `sha256` of the transaction object serialized in borsh (https://github.com/near/borsh).

### How do transactions work on the NEAR platform?

A `Transaction` is made up of one or more `Action`s. An action can (currently) be one of 8 types: `CreateAccount`,
`DeployContract`, `FunctionCall`, `Transfer`, `Stake`, `AddKey`, `DeleteKey` and `DeleteAccount`. Transactions are composed by a sender and then signed using the private keys of a valid NEAR account to create a `SignedTransaction`. This signed transaction is considered ready to send to the network for processing.

Transactions are received via our JSON-RPC endpoint and routed to the shared where the `sender` account lives. This "home shard" for the sender account is then responsible for processing the transaction and generating related receipts to be applied across the network.

Once received by the network, signed transactions are verified (using the embedded public key of the signer) and transformed into a collection of `Receipt`s, one per action. Receipts are of two types: `Action Receipt` is the most common and represents almost all actions on the network while `Data Receipt` handles the very special case of "a `FunctionCallAction` which includes a Promise". These receipts are then propagated and applied across the network according to the "home shard" rule for all affected receiver accounts.

These receipts are then propagated around the network using the receiver account's "home shard" since each account lives on one and only one shard. Once located on the correct shard, receipts are pulled from a nonce-based [queue](https://nomicon.io/ChainSpec/Transactions#pool-iterator).

Receipts may generate other, new receipts which in turn are propagated around the network until all receipts have been applied. If any action within a transaction fails, the entire transaction is rolled back and any unburnt fees are refunded to the proper accounts.

For more detail, see specs on [`Transactions`](https://nomicon.io/RuntimeSpec/Transactions), [`Actions`](https://nomicon.io/RuntimeSpec/Actions.html), [`Receipts`](https://nomicon.io/RuntimeSpec/Receipts)

### How does NEAR serialize transactions?

We use a simple binary serialization format that's deterministic: https://borsh.io

## Additional Resources

- Whitepaper

  - General overview at [The Beginner's Guide to the NEAR Blockchain](https://near.org/blog/the-beginners-guide-to-the-near-blockchain)
  - [NEAR Whitepaper](https://pages.near.org/papers/the-official-near-white-paper/)

- Github
  - https://www.github.com/near

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol"> Ask it on StackOverflow! </a>
:::

'''
'''--- docs/6.integrations/implicit-accounts.md ---
---
id: implicit-accounts
title: Implicit Accounts
sidebar_label: Implicit Accounts
---

## Background {#background}

Implicit accounts work similarly to Bitcoin/Ethereum accounts.
 - They allow you to reserve an account ID before it's created by generating a ED25519 key-pair locally.
 - This key-pair has a public key that maps to the account ID.
 - The account ID is a lowercase hex representation of the public key.
 - An ED25519 Public key contains 32 bytes that maps to 64 characters account ID.
 - The corresponding secret key allows you to sign transactions on behalf of this account once it's created on chain.

## [Specifications](https://nomicon.io/DataStructures/Account.html#implicit-account-ids) {#specifications}

## Creating an account locally {#creating-an-account-locally}

For the purpose of this demo, we'll use the `betanet` network. 

### Set `betanet` network {#set-betanet-network}

```bash
export NEAR_ENV=betanet
```

### Generating a key-pair first {#generating-a-key-pair-first}

```bash
near generate-key --saveImplicit
```

Example Output
```
Seed phrase: lumber habit sausage used zebra brain border exist meat muscle river hidden
Key pair: {"publicKey":"ed25519:AQgnQSR1Mp3v7xrw7egJtu3ibNzoCGwUwnEehypip9od","secretKey":"ed25519:51qTiqybe8ycXwPznA8hz7GJJQ5hyZ45wh2rm5MBBjgZ5XqFjbjta1m41pq9zbRZfWGUGWYJqH4yVhSWoW6pYFkT"}
Implicit account: 8bca86065be487de45e795b2c3154fe834d53ffa07e0a44f29e76a2a5f075df8
Storing credentials for account: 8bca86065be487de45e795b2c3154fe834d53ffa07e0a44f29e76a2a5f075df8 (network: testnet)
Saving key to '~/.near-credentials/testnet/8bca86065be487de45e795b2c3154fe834d53ffa07e0a44f29e76a2a5f075df8.json'
```

#### Using the Implicit Account
We can export our account ID to a bash env variable:
```bash
export ACCOUNT="8bca86065be487de45e795b2c3154fe834d53ffa07e0a44f29e76a2a5f075df8"
```

Assuming you've received tokens on your new account, you can transfer from it using the following command:
```bash
near $ACCOUNT <receiver> <amount>
```

You can also replace `$ACCOUNT` with your actual account ID, e.g.
```bash
near send 98793cd91a3f870fb126f66285808c7e094afcfc4eda8a970f6648cdf0dbd6de <receiver> <amount>
```

## Transferring to the implicit account {#transferring-to-the-implicit-account}

Let's say someone gives you their account ID `0861ea8ddd696525696ccf3148dd706c4fda981c64d8a597490472594400c223`. You can just transfer to it by running:
```bash
near send <your_account_id> 0861ea8ddd696525696ccf3148dd706c4fda981c64d8a597490472594400c223 <amount>
```

## BONUS: Converting public key using python (for learning purposes) {#bonus-converting-public-key-using-python-for-learning-purposes}

For this flow we'll use `python3` (with version `3.5+`) with `base58` library.

You can install this library with `pip3`:
```bash
pip3 install --user base58
```

Start python3 interpreter:
```bash
python3
```

The first thing is to get the data part from the public key (without `ed25519:` prefix). Let's store it in a variable `pk58`:
```python
pk58 = 'BGCCDDHfysuuVnaNVtEhhqeT4k9Muyem3Kpgq2U1m9HX'
```

Now let's import base58:
```python
import base58
```

Finally, let's convert our base58 public key representation to bytes and then to hex:
```python
base58.b58decode(pk58).hex()
```

Output:
```
'98793cd91a3f870fb126f66285808c7e094afcfc4eda8a970f6648cdf0dbd6de'
```

This gives us the same account ID as `near-cli`, so this is encouraging.

**Note:** The default network for `near-cli` is `testnet`. If you would like to change this to `mainnet` or `betanet`, please see [`near-cli` network selection](/tools/near-cli#network-selection) for instructions.

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol"> Ask it on StackOverflow! </a>
:::

'''
'''--- docs/6.integrations/tokens.md ---
---
id: fungible-tokens
title: Fungible tokens
sidebar_label: Fungible Tokens
---

## Introduction {#introduction}

Please see the [spec for the fungible token standard](https://nomicon.io/Standards/FungibleToken/) and an [example implementation](https://github.com/near-examples/FT) for reference details.

One notable aspect of the standard is that method names are prefixed with `ft_`. This will be a helpful convention when querying for transactions related to fungible tokens.

## Get balance {#get-balance}

Using the abstraction of the [NEAR CLI](/tools/near-cli) tool, we can check the balance of a user's account with [`near view`](/tools/near-cli#near-view):

`near view ft.demo.testnet ft_balance_of '{"account_id": "mike.testnet"}'`

Returns:

```
View call: ft.demo.testnet.ft_balance_of({"account_id": "mike.testnet"})
'1000000'
```

Alternatively, you can [call a contract function](/api/rpc/setup#call-a-contract-function) using the `query` RPC endpoint. Below is an example using HTTPie:

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=ftbalance method=query \
params:='{
  "request_type": "call_function",
  "finality": "final",
  "account_id": "ft.demo.testnet",
  "method_name": "ft_balance_of",
  "args_base64": "eyJhY2NvdW50X2lkIjogIm1pa2UudGVzdG5ldCJ9"
}'
```

Returns:

```bash
HTTP/1.1 200 OK
Alt-Svc: clear
Via: 1.1 google
access-control-allow-origin:
content-length: 176
content-type: application/json
date: Thu, 27 May 2021 12:53:38 GMT

{
    "id": "dontcare",
    "jsonrpc": "2.0",
    "result": {
        "block_hash": "3mvNHpZAsXiJ6SuHU1mbLVB4iXCfh5i5d41pnkaSoaJ5",
        "block_height": 49282350,
        "logs": [],
        "result": [ 34, 49, 48, 48, 48, 48, 48, 48, 34 ]
    }
}
```

As mentioned earlier, the `result` is an array of bytes. There are various ways to convert bytes into a more human-readable form such as the [dtool CLI](https://github.com/guoxbin/dtool#installation).

`dtool a2h '[34,49,48,48,48,48,48,48,34]' | dtool h2s`

Returns:

`"1000000"`

**Note:** The fungible token balance of the account `mike.testnet` is `1000000` wrapped in double-quotes. This is because of an issue with JSON serialization. Amounts given in arguments and results must be serialized as Base-10 strings, e.g. "100". This is done to avoid JSON limitation of max integer value of 2**53, which can certainly happen with fungible tokens.

## Get info about the FT {#get-info-about-the-ft}

You can get `name`, `decimals`, `icon` and other parameters by calling the next function:
  - using NEAR CLI:

      ```bash
      near view <contract_account_id> ft_metadata
      ```
    Result:

    ```bash
    View call: ft.demo.testnet.ft_metadata()
    {
      spec: 'ft-1.0.0',
      name: 'Example Token Name',
      symbol: 'MOCHI',
      icon: null,
      reference: null,
      reference_hash: null,
      decimals: 24
    }
    ```

  - with JSON RPC call:
      ```bash
      http post https://rpc.testnet.near.org jsonrpc=2.0 id=ftmetadata method=query \
      params:='{
        "request_type": "call_function",
        "finality": "final",
        "account_id": "<contract_account_id>",
        "method_name": "ft_metadata",
        "args_base64": ""
      }'
      ```
      Example response:
      ```bash
      HTTP/1.1 200 OK
      Alt-Svc: clear
      Via: 1.1 google
      access-control-allow-origin:
      content-length: 604
      content-type: application/json
      date: Wed, 02 Jun 2021 15:51:17 GMT

      {
          "id": "ftmetadata",
          "jsonrpc": "2.0",
          "result": {
              "block_hash": "B3fu3v4dmn19B6oqjHUXN3k5NhdP9EW5kkjyuFUDpa1r",
              "block_height": 50061565,
              "logs": [],
              "result": [ 123, 34, 115, 112, 101, 99, 34, 58, 34, 102, 116, 45, 49, 46, 48, 46, 48, 34, 44, 34, 110, 97, 109, 101, 34, 58, 34, 69, 120, 97, 109, 112, 108, 101, 32, 84, 111, 107, 101, 110, 32, 78, 97, 109, 101, 34, 44, 34, 115, 121, 109, 98, 111, 108, 34, 58, 34, 77, 79, 67, 72, 73, 34, 44, 34, 105, 99, 111, 110, 34, 58, 110, 117, 108, 108, 44, 34, 114, 101, 102, 101, 114, 101, 110, 99, 101, 34, 58, 110, 117, 108, 108, 44, 34, 114, 101, 102, 101, 114, 101, 110, 99, 101, 95, 104, 97, 115, 104, 34, 58, 110, 117, 108, 108, 44, 34, 100, 101, 99, 105, 109, 97, 108, 115, 34, 58, 50, 52, 125 ]
          }
      }
      ```

      Decoded result in this case is:

      ```json
      {
        "spec": "ft-1.0.0",
        "name": "Example Token Name",
        "symbol": "MOCHI",
        "icon": null,
        "reference": null,
        "reference_hash": null,
        "decimals": 24
      }
      ```

## Simple transfer {#simple-transfer}

To follow this guide, please check the [step by step instructions](/integrations/create-transactions#low-level----create-a-transaction) on how to create a transaction first.

In order to send a fungible token to an account, the receiver must have a storage deposit. This is because each smart contract on NEAR must account for storage used, and each account on a fungible token contract is a key-value pair, taking up a small amount of storage. For more information, please see [how storage works in NEAR](/concepts/storage/storage-staking). To check if account has deposited the storage for this FT do the following:

Get storage balance of the account. `storage_balance_of` function returns the amount of deposited storage or `null` if there is no deposit.
  - using NEAR CLI:

    ```bash
    near view <contract_account_id> storage_balance_of '{"account_id": "<user_account_id>"}'
    ```

    Result:

    ```bash
    View call: ft.demo.testnet.storage_balance_of({"account_id": "serhii.testnet"})
    null
    ```

  - with JSON RPC call:
      ```bash
      http post https://rpc.testnet.near.org jsonrpc=2.0 id=storagebalanceof method=query \
      params:='{
         "request_type": "call_function",
         "finality": "final",
         "account_id": "ft.demo.testnet",
         "method_name": "storage_balance_of",
         "args_base64": "eyJhY2NvdW50X2lkIjogInNlcmhpaS50ZXN0bmV0In0K"
      }'
      ```

      Example response:

      ```bash
      HTTP/1.1 200 OK
      Alt-Svc: clear
      Via: 1.1 google
      access-control-allow-origin:
      content-length: 173
      content-type: application/json
      date: Wed, 02 Jun 2021 14:22:01 GMT
      {
          "id": "storagebalanceof",
          "jsonrpc": "2.0",
          "result": {
              "block_hash": "EkM2j4yxRVoQ1TCqF2KUb7J4w5G1VsWtMLiycq6k3f53",
              "block_height": 50054247,
              "logs": [],
              "result": [ 110, 117, 108, 108 ]
          }
      }
      ```

      Decoded result in this case is `null`.

Get the minimum storage required for FT. (The storage used for an account's key-value pair.)
  - using NEAR CLI:

    ```bash
    near view <contract_account_id> storage_balance_bounds`
    ```

    Result:

    ```bash
    View call: ft.demo.testnet.storage_balance_bounds()
    { min: '1250000000000000000000', max: '1250000000000000000000' }
    ```

  - with JSON RPC call
      ```bash
      http post https://rpc.testnet.near.org jsonrpc=2.0 id=storagebalancebounds method=query \
      params:='{
          "request_type": "call_function",
          "finality": "final",
          "account_id": "<contract_account_id>",
          "method_name": "storage_balance_bounds",
          "args_base64": ""
      }'
      ```

      Example response:
      ```bash
      HTTP/1.1 200 OK
      Alt-Svc: clear
      Via: 1.1 google
      access-control-allow-origin:
      content-length: 357
      content-type: application/json
      date: Wed, 02 Jun 2021 15:42:49 GMT

      {
          "id": "storagebalancebounds",
          "jsonrpc": "2.0",
          "result": {
              "block_hash": "Fy3mBqwj5nvUDha3X7G61kmUeituHASEX12oCASrChEE",
              "block_height": 50060878,
              "logs": [],
              "result": [ 123, 34, 109, 105, 110, 34, 58, 34, 49, 50, 53, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 34, 44, 34, 109, 97, 120, 34, 58, 34, 49, 50, 53, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 34, 125 ]
          }
      }
      ```

      Decoded result should look similar to:

      ```json
      {
        "min": "1250000000000000000000",
        "max": "1250000000000000000000"
      }
      ```

Basic fungible tokens are simple smart contracts that don't have variable storage as compared to a smart contract that might store free-form text, for instance. The only storage needed is for an accounts key-value pair, which will always be covered by the `1250000000000000000000` yocto‚ìÉ storage balance.

If there is not enough deposit for the storage or returned value is `null` - you should deposit more storage with the next command:
  - using NEAR CLI, don't forget to convert from yocto‚ìÉ to ‚ìÉ:

    ```bash
    near call <contract_account_id> storage_deposit '{"account_id": "<user_account_id>"}' --accountId <sender_account_id> --deposit <deposit in ‚ìÉ>
    ```

    Result example:

    ```bash
    Scheduling a call: ft.demo.testnet.storage_deposit() with attached 0.125 NEAR
    Transaction Id 9CMrMMt3UzeU63FFrUyFb1gNGuHXxvKfHqYJzyFTAk6z
    To see the transaction in the transaction explorer, please open this url in your browser
    https://testnet.nearblocks.io/txns/9CMrMMt3UzeU63FFrUyFb1gNGuHXxvKfHqYJzyFTAk6z
    { total: '1250000000000000000000', available: '0' }
    ```

  - with JSON RPC call:

  At the top of this section is a link detailing how to [construct a transaction](/integrations/create-transactions#low-level----create-a-transaction) without the full abstraction of the [`near-api-js` library](https://www.npmjs.com/package/near-api-js). For this and future examples that use the [RPC method `broadcast_tx_commit`](https://docs.near.org/api/rpc/setup#send-transaction-await) we will provide a JSON-like object meant to act similar to [pseudocode](https://en.wikipedia.org/wiki/Pseudocode), only imparting high-level details of a transaction. This code block below is the first example of this, detailing what goes into the transaction discussed currently, involving the method `storage_deposit`.

```yaml
Transaction: {
	block_hash: `456‚Ä¶abc`,
	signer_id: "serhii.testnet",
	public_key: "ed25519:789‚Ä¶def",
	nonce: 123,
	receiver_id: "ft.demo.testnet",
	actions: [
		FunctionCall(
			FunctionCallAction {
				method_name: storage_deposit,
				args: `{"account_id": "robertyan.near"}`,
				gas: 300000000000000,
				deposit: 1250000000000000000000,
			},
		),
	]
}
```

      ```bash
      http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=broadcast_tx_commit \
          params:='["DgAAAHNlcmhpaS50ZXN0bmV0AEKEp54fyVkp8dJE2l/m1ErjdhDGodBK8ZF6JLeHFMeZi/qoVEgrAAAPAAAAZnQuZGVtby50ZXN0bmV0JYbWPOu0P9T32vtUKnZSh+EaoboQqg0/De2i8Y+AjHIBAAAAAg8AAABzdG9yYWdlX2RlcG9zaXQCAAAAe30AQHoQ81oAAAAAILSd2XlDeBoAAAAAAAAAZF7+s4lcHOzy+re59VErt7LcZkPMMUVgOJV8LH5TsLBBv+8h/5tZ6+HFwxSp605A4c46oS9Jw4KBRXZD07lKCg=="]'
      ```

<details>
<summary>**Example Response:**</summary>

```json
{
  "id": "myid",
  "jsonrpc": "2.0",
  "result": {
    "receipts": [
      {
        "predecessor_id": "serhii.testnet",
        "receipt": {
          "Action": {
            "actions": [
              {
                "FunctionCall": {
                  "args": "e30=",
                  "deposit": "125000000000000000000000",
                  "gas": 100000000000000,
                  "method_name": "storage_deposit"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "4urgFabknn1myZkjTYdb1BFSoEimP21k9smCUWoSggA7",
        "receiver_id": "ft.demo.testnet"
      },
      {
        "predecessor_id": "ft.demo.testnet",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "123750000000000000000000"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "7neJYE45vXnQia1LQqWuAfyTRXHy4vv88JaULa5DnNBd",
        "receiver_id": "serhii.testnet"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "19200274886926125000"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "2c59u2zYj41JuhMfPUCKjNucmYfz2Jt83JLWP6VyQn1S",
        "receiver_id": "serhii.testnet"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "18587201427159524319124"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "kaYatRKxcC1NXac69WwTqg6K13oXq2yEuy4LLZtsV2G",
        "receiver_id": "serhii.testnet"
      }
    ],
    "receipts_outcome": [
      {
        "block_hash": "6Gz6P8N3F447kRc7kkxEhuZRZTzfuTUEagye65bPVGb",
        "id": "4urgFabknn1myZkjTYdb1BFSoEimP21k9smCUWoSggA7",
        "outcome": {
          "executor_id": "ft.demo.testnet",
          "gas_burnt": 4258977405434,
          "logs": [],
          "receipt_ids": [
            "7neJYE45vXnQia1LQqWuAfyTRXHy4vv88JaULa5DnNBd",
            "kaYatRKxcC1NXac69WwTqg6K13oXq2yEuy4LLZtsV2G"
          ],
          "status": {
            "SuccessValue": "eyJ0b3RhbCI6IjEyNTAwMDAwMDAwMDAwMDAwMDAwMDAiLCJhdmFpbGFibGUiOiIwIn0="
          },
          "tokens_burnt": "425897740543400000000"
        },
        "proof": []
      },
      {
        "block_hash": "J6YXMnLPfLEPyvL3fWdhWPzpWAeW8zNY2CwAFwAg9tfr",
        "id": "7neJYE45vXnQia1LQqWuAfyTRXHy4vv88JaULa5DnNBd",
        "outcome": {
          "executor_id": "serhii.testnet",
          "gas_burnt": 223182562500,
          "logs": [],
          "receipt_ids": [
            "2c59u2zYj41JuhMfPUCKjNucmYfz2Jt83JLWP6VyQn1S"
          ],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "22318256250000000000"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "D6tGfHwKh21PqzhBTsdKCsTtZvXFDkmH39dQiQBoGN3w"
          }
        ]
      },
      {
        "block_hash": "HRRF7N1PphZ46eN5g4DjqEgYHBYM76yGiXSTYWsfMGoy",
        "id": "2c59u2zYj41JuhMfPUCKjNucmYfz2Jt83JLWP6VyQn1S",
        "outcome": {
          "executor_id": "serhii.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": []
      },
      {
        "block_hash": "J6YXMnLPfLEPyvL3fWdhWPzpWAeW8zNY2CwAFwAg9tfr",
        "id": "kaYatRKxcC1NXac69WwTqg6K13oXq2yEuy4LLZtsV2G",
        "outcome": {
          "executor_id": "serhii.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "1uVJZ8vNQpHMwPA38DYJjk9PpvnHDhsDcMxrTXcwf1s"
          }
        ]
      }
    ],
    "status": {
      "SuccessValue": "eyJ0b3RhbCI6IjEyNTAwMDAwMDAwMDAwMDAwMDAwMDAiLCJhdmFpbGFibGUiOiIwIn0="
    },
    "transaction": {
      "actions": [
        {
          "FunctionCall": {
            "args": "e30=",
            "deposit": "125000000000000000000000",
            "gas": 100000000000000,
            "method_name": "storage_deposit"
          }
        }
      ],
      "hash": "6sDUF1f5hebpybUbipNJer5ez13EY4HW1VBJEBqZjCEm",
      "nonce": 47589658000011,
      "public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN",
      "receiver_id": "ft.demo.testnet",
      "signature": "ed25519:31PfuinsVvM1o2CmiZbSguFkZKYqAtkf5PHerfexhDbC3SsJWDzRFBpoUYTNDJddhKeqs93GQ3SHtUyqaSYhhQ9X",
      "signer_id": "serhii.testnet"
    },
    "transaction_outcome": {
      "block_hash": "5XiuxzTpyw6p2NTD5AqrZYNW7SHvpj8MhUCyn1x2KSQR",
      "id": "6sDUF1f5hebpybUbipNJer5ez13EY4HW1VBJEBqZjCEm",
      "outcome": {
        "executor_id": "serhii.testnet",
        "gas_burnt": 2427959010878,
        "logs": [],
        "receipt_ids": [
          "4urgFabknn1myZkjTYdb1BFSoEimP21k9smCUWoSggA7"
        ],
        "status": {
          "SuccessReceiptId": "4urgFabknn1myZkjTYdb1BFSoEimP21k9smCUWoSggA7"
        },
        "tokens_burnt": "242795901087800000000"
      },
      "proof": []
    }
  }
}
```
</details>

Transfer the tokens:
  - using NEAR CLI:

    ```bash
    near call <contract_account_id> ft_transfer '{"receiver_id": "<receiver_account_id>", "amount": "1"}' --accountId <sender_account_id> --amount 0.000000000000000000000001
    ```

    Result example:

    ```bash
    Scheduling a call: berryclub.ek.near.ft_transfer({"receiver_id": "volovyk.near", "amount": "1"}) with attached 0.000000000000000000000001 NEAR
    Receipt: GDeE3Kv1JHgs71A22NEUbgq55r2Hvcnis8gCMyJtQ2mx
    	Log [berryclub.ek.near]: Transfer 1 from serhii.near to volovyk.near
    Transaction Id 3MkWKbXVP8wyy4pBofELqiE1pwx7ie2v3SKCwaobNcEe
    To see the transaction in the transaction explorer, please open this url in your browser
    https://nearblocks.io/txns/3MkWKbXVP8wyy4pBofELqiE1pwx7ie2v3SKCwaobNcEe
    ''
    ```

  - with JSON RPC call:

Transaction representation:
```yaml
Transaction: {
	block_hash: `456‚Ä¶abc`,
	signer_id: "serhii.near",
	public_key: "ed25519:789‚Ä¶def",
	nonce: 123,
	receiver_id: "berryclub.ek.near",
	actions: [
		FunctionCall(
			FunctionCallAction {
				method_name: ft_transfer,
				args: `{"receiver_id": "volovyk.near", "amount": "1"}`,
				gas: 300000000000000,
				deposit: 1,
			},
		),
	]
}
```

      ```bash
      http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=broadcast_tx_commit \
          params:='["CwAAAHNlcmhpaS5uZWFyAAmQpgZcJM5nMc6f3tqmw/YI4eAvc84ZgsKMRRRzhY/6CQAAAAAAAAARAAAAYmVycnljbHViLmVrLm5lYXLLWPIiUOElkDF3u4hLAMJ0Sjeo1V338pDdHIp70va3ewEAAAACCwAAAGZ0X3RyYW5zZmVyKwAAAHsicmVjZWl2ZXJfaWQiOiJ2b2xvdnlrLm5lYXIiLCJhbW91bnQiOiIxIn0AQHoQ81oAAAEAAAAAAAAAAAAAAAAAAAAA7fDOZQt3zCtdS05Y8XaZFlwO/Gd5wkkNAHShzDiLQXk4Q4ixpraLPMJivs35PZD0gocXl1iGFbQ46NG3VllzCA=="]'
      ```

To get details of this transaction:

```bash
http post https://archival-rpc.mainnet.near.org jsonrpc=2.0 method=EXPERIMENTAL_tx_status \
  params:='["2Fy4714idMCoja7QLdGAbQZHzV2XEnUdwZX6yGa46VMX", "serhii.near"]' id=myid
```

<details>
<summary>**Example Response:**</summary>

```json
{
  "id": "myid",
  "jsonrpc": "2.0",
  "result": {
    "receipts": [
      {
        "predecessor_id": "serhii.near",
        "receipt": {
          "Action": {
            "actions": [
              {
                "FunctionCall": {
                  "args": "eyJyZWNlaXZlcl9pZCI6InZvbG92eWsubmVhciIsImFtb3VudCI6IjEifQ==",
                  "deposit": "1",
                  "gas": 100000000000000,
                  "method_name": "ft_transfer"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.near",
            "signer_public_key": "ed25519:eLbduR3uJGaAHLXeGKEfo1fYmYFKkLyR1R8ZPCxrJAM"
          }
        },
        "receipt_id": "ExhYcvwAUb3Jpm38pSQ5oobwJAouBqqDZjbhavKrZtur",
        "receiver_id": "berryclub.ek.near"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "18418055677558685763688"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.near",
            "signer_public_key": "ed25519:eLbduR3uJGaAHLXeGKEfo1fYmYFKkLyR1R8ZPCxrJAM"
          }
        },
        "receipt_id": "EAPh8XrBMqm6iuVH5jsfemz4YqUxWsV8Mz241cw5tjvE",
        "receiver_id": "serhii.near"
      }
    ],
    "receipts_outcome": [
      {
        "block_hash": "6Re4NTkKzD7maKx3MuoxzYVHQKqjgnXW8rNjGjeVx8YC",
        "id": "ExhYcvwAUb3Jpm38pSQ5oobwJAouBqqDZjbhavKrZtur",
        "outcome": {
          "executor_id": "berryclub.ek.near",
          "gas_burnt": 6365774114160,
          "logs": [
            "Transfer 1 from serhii.near to volovyk.near"
          ],
          "receipt_ids": [
            "EAPh8XrBMqm6iuVH5jsfemz4YqUxWsV8Mz241cw5tjvE"
          ],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "636577411416000000000"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "2eUmWnLExsH5jb6mALY9jTC8FiQH4FcuxQ16tn7RfkYr"
          },
          {
            "direction": "Right",
            "hash": "266d5QfDKXNbAWJgXMJXgLP97VwoMiC4Qyt8wH7xcs1Q"
          },
          {
            "direction": "Right",
            "hash": "EkJAuJigdVSZj41yGXSZYAtDV7Xwe2Hv9Xsqcv6LUZvq"
          }
        ]
      },
      {
        "block_hash": "3XMoeEdm1zE64aByFuWCrZaxfbvsjMHRFcL8Wsp95vyt",
        "id": "EAPh8XrBMqm6iuVH5jsfemz4YqUxWsV8Mz241cw5tjvE",
        "outcome": {
          "executor_id": "serhii.near",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "EGC9ZPJHTbmCs3aQDuCkFQboGLBxU2uzrSZMsp8WonDu"
          },
          {
            "direction": "Right",
            "hash": "EsBd1n7bDAphA3HY84DrrKd1GP1VugeNiqFCET2S5sNG"
          },
          {
            "direction": "Left",
            "hash": "H4q3ByfNB7QH9QEuHN3tcGay7tjhsZwjXx3sq3Vm3Lza"
          }
        ]
      }
    ],
    "status": {
      "SuccessValue": ""
    },
    "transaction": {
      "actions": [
        {
          "FunctionCall": {
            "args": "eyJyZWNlaXZlcl9pZCI6InZvbG92eWsubmVhciIsImFtb3VudCI6IjEifQ==",
            "deposit": "1",
            "gas": 100000000000000,
            "method_name": "ft_transfer"
          }
        }
      ],
      "hash": "2Fy4714idMCoja7QLdGAbQZHzV2XEnUdwZX6yGa46VMX",
      "nonce": 10,
      "public_key": "ed25519:eLbduR3uJGaAHLXeGKEfo1fYmYFKkLyR1R8ZPCxrJAM",
      "receiver_id": "berryclub.ek.near",
      "signature": "ed25519:5eJPGirNkBUbMeyRfEA4fgi1FtkgGk8pmbbkmiz3Faf6zrANpBsCs5bZd5heSTvQ6b3fEPLSPCPi2iwD2XJT93As",
      "signer_id": "serhii.near"
    },
    "transaction_outcome": {
      "block_hash": "EAcwavyaeNWZnfhYP2nAWzeDgMiuiyRHfaprFqhXgCRF",
      "id": "2Fy4714idMCoja7QLdGAbQZHzV2XEnUdwZX6yGa46VMX",
      "outcome": {
        "executor_id": "serhii.near",
        "gas_burnt": 2428041740436,
        "logs": [],
        "receipt_ids": [
          "ExhYcvwAUb3Jpm38pSQ5oobwJAouBqqDZjbhavKrZtur"
        ],
        "status": {
          "SuccessReceiptId": "ExhYcvwAUb3Jpm38pSQ5oobwJAouBqqDZjbhavKrZtur"
        },
        "tokens_burnt": "242804174043600000000"
      },
      "proof": [
        {
          "direction": "Right",
          "hash": "GatQmy7fW5uXRJRSg7A315CWzWWcQCGk4GJXyW3cjw4j"
        },
        {
          "direction": "Right",
          "hash": "89WJwAetivZLvAkVLXUt862o7zJX7YYt6ZixdWebq3xv"
        },
        {
          "direction": "Right",
          "hash": "CH3wHSqYPJp35krLjSgJTgCFYnv1ymhd9bJpjXA31VVD"
        }
      ]
    }
  }
}
```
</details>

You can get the same info later by the transaction hash from the previous call:

  - using NEAR Explorer: https://nearblocks.io

<!--
- using NEAR CLI:
near tx-status <transaction_hash> --accountId <transaction_signer>
-->

  - with JSON RPC call

  ```bash
      http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_tx_status \
      params:='[ "2Fy4714idMCoja7QLdGAbQZHzV2XEnUdwZX6yGa46VMX", "sender.testnet"]'
  ```

Let's create test transaction that should fail and investigate the response. We will try to send more tokens that are available on this account:
  - using NEAR CLI:

    ```bash
    near call <contract_account_id> ft_transfer '{"receiver_id": "<user_account_id>", "amount": "10000000000"}' --accountId <sender_account_id> --amount 0.000000000000000000000001
    ```

  - with JSON RPC call:

Transaction representation:
```yaml
Transaction: {
	block_hash: `456‚Ä¶abc`,
	signer_id: "serhii.near",
	public_key: "ed25519:789‚Ä¶def",
	nonce: 123,
	receiver_id: "berryclub.ek.near",
	actions: [
		FunctionCall(
			FunctionCallAction {
				method_name: ft_transfer,
				args: `{"receiver_id":"volovyk.near","amount":"10000000000000000000"}`,
				gas: 300000000000000,
				deposit: 1,
			},
		),
	]
}
```

    ```bash
      http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=broadcast_tx_commit \
      params:='["DgAAAHNlcmhpaS50ZXN0bmV0AEKEp54fyVkp8dJE2l/m1ErjdhDGodBK8ZF6JLeHFMeZofqoVEgrAAAgAAAAZGV2LTE2MjMzMzM3OTU2MjMtMjEzOTk5NTk3NzgxNTm8Xq8BTIi6utG0424Gg7CknYzLH8RH/A409jq5o0zi7gEAAAACCwAAAGZ0X3RyYW5zZmVyPwAAAHsicmVjZWl2ZXJfaWQiOiJkZXYtMTYyMzMzMzkxNjM2OC01ODcwNzQzNDg3ODUzMyIsImFtb3VudCI6IjEifQBAehDzWgAAAQAAAAAAAAAAAAAAAAAAAABCwjqayKdpWgM6PE0ixzm/Gy0EtdpxVn0xehMTBReVfVAKIBTDPoPSaOdT8fAhk343F5uOMfSijhTqU2mWV3oD"]'
    ```

To get details of this transaction:

```bash
http post https://archival-rpc.mainnet.near.org jsonrpc=2.0 method=EXPERIMENTAL_tx_status \
  params:='["CKHzodHvFw4C87PazsniycYZZHm37CEWLE2u8VUUMU7r", "serhii.near"]' id=myid
```

<details>
<summary>**Example Response:**</summary>

```json
{
  "id": "myid",
  "jsonrpc": "2.0",
  "result": {
    "receipts": [
      {
        "predecessor_id": "serhii.near",
        "receipt": {
          "Action": {
            "actions": [
              {
                "FunctionCall": {
                  "args": "eyJyZWNlaXZlcl9pZCI6InZvbG92eWsubmVhciIsImFtb3VudCI6IjEwMDAwMDAwMDAwMDAwMDAwMDAwIn0=",
                  "deposit": "1",
                  "gas": 100000000000000,
                  "method_name": "ft_transfer"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.near",
            "signer_public_key": "ed25519:eLbduR3uJGaAHLXeGKEfo1fYmYFKkLyR1R8ZPCxrJAM"
          }
        },
        "receipt_id": "5bdBKwS1RH7wm8eoG6ZeESdhNpj9HffUcf8RoP6Ng5d",
        "receiver_id": "berryclub.ek.near"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "1"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "system",
            "signer_public_key": "ed25519:11111111111111111111111111111111"
          }
        },
        "receipt_id": "Td3QxpKhMdi8bfVeMiQZwNS1VzPXceQdn6xdftoC8k6",
        "receiver_id": "serhii.near"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "18653463364152698495356"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.near",
            "signer_public_key": "ed25519:eLbduR3uJGaAHLXeGKEfo1fYmYFKkLyR1R8ZPCxrJAM"
          }
        },
        "receipt_id": "DwLMVTdqv9Z4g9QC4AthTXHqqeJVAH4s1tFXHQYMArW7",
        "receiver_id": "serhii.near"
      }
    ],
    "receipts_outcome": [
      {
        "block_hash": "DTruWLgm5Y56yDrxUipvYqKKm8F7hxVQTarNQqe147zs",
        "id": "5bdBKwS1RH7wm8eoG6ZeESdhNpj9HffUcf8RoP6Ng5d",
        "outcome": {
          "executor_id": "berryclub.ek.near",
          "gas_burnt": 4011776278642,
          "logs": [],
          "receipt_ids": [
            "Td3QxpKhMdi8bfVeMiQZwNS1VzPXceQdn6xdftoC8k6",
            "DwLMVTdqv9Z4g9QC4AthTXHqqeJVAH4s1tFXHQYMArW7"
          ],
          "status": {
            "Failure": {
              "ActionError": {
                "index": 0,
                "kind": {
                  "FunctionCallError": {
                    "ExecutionError": "Smart contract panicked: The account doesn't have enough balance"
                  }
                }
              }
            }
          },
          "tokens_burnt": "401177627864200000000"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "6GHrA42oMEF4g7YCBpPw9EakkLiepTHnQBvaKtmsenEY"
          },
          {
            "direction": "Right",
            "hash": "DCG3qZAzf415twXfHmgBUdB129g2iZoQ4v8dawwBzhSh"
          }
        ]
      },
      {
        "block_hash": "F9xNWGhJuYW336f3qVaDDAipsyfpudJHYbmt5in3MeMT",
        "id": "Td3QxpKhMdi8bfVeMiQZwNS1VzPXceQdn6xdftoC8k6",
        "outcome": {
          "executor_id": "serhii.near",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "CJNvis1CoJmccshDpPBrk3a7fdZ5HnMQuy3p2Kd2GCdS"
          },
          {
            "direction": "Left",
            "hash": "4vHM3fbdNwXGMp9uYzVKB13abEM6qdPUuZ9rfrdsaDzc"
          }
        ]
      },
      {
        "block_hash": "F9xNWGhJuYW336f3qVaDDAipsyfpudJHYbmt5in3MeMT",
        "id": "DwLMVTdqv9Z4g9QC4AthTXHqqeJVAH4s1tFXHQYMArW7",
        "outcome": {
          "executor_id": "serhii.near",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "BR3R7tjziEgXMiHaJ7VuuXCo2yBHB2ZzsoxobPhPjFeJ"
          },
          {
            "direction": "Left",
            "hash": "4vHM3fbdNwXGMp9uYzVKB13abEM6qdPUuZ9rfrdsaDzc"
          }
        ]
      }
    ],
    "status": {
      "Failure": {
        "ActionError": {
          "index": 0,
          "kind": {
            "FunctionCallError": {
              "ExecutionError": "Smart contract panicked: The account doesn't have enough balance"
            }
          }
        }
      }
    },
    "transaction": {
      "actions": [
        {
          "FunctionCall": {
            "args": "eyJyZWNlaXZlcl9pZCI6InZvbG92eWsubmVhciIsImFtb3VudCI6IjEwMDAwMDAwMDAwMDAwMDAwMDAwIn0=",
            "deposit": "1",
            "gas": 100000000000000,
            "method_name": "ft_transfer"
          }
        }
      ],
      "hash": "CKHzodHvFw4C87PazsniycYZZHm37CEWLE2u8VUUMU7r",
      "nonce": 12,
      "public_key": "ed25519:eLbduR3uJGaAHLXeGKEfo1fYmYFKkLyR1R8ZPCxrJAM",
      "receiver_id": "berryclub.ek.near",
      "signature": "ed25519:63MC3f8m5jeycpy97G9XaCwmJLx4YHRn2x5AEJDiYYzZ3TzdzWsrz8dgaz2kHR2jsWh35aZoL97tw1RRTHK6ZQYq",
      "signer_id": "serhii.near"
    },
    "transaction_outcome": {
      "block_hash": "7YUgyBHgmbGy1edhaWRZeBVq9zzbnzrRGtVRQS5PpooW",
      "id": "CKHzodHvFw4C87PazsniycYZZHm37CEWLE2u8VUUMU7r",
      "outcome": {
        "executor_id": "serhii.near",
        "gas_burnt": 2428084223182,
        "logs": [],
        "receipt_ids": [
          "5bdBKwS1RH7wm8eoG6ZeESdhNpj9HffUcf8RoP6Ng5d"
        ],
        "status": {
          "SuccessReceiptId": "5bdBKwS1RH7wm8eoG6ZeESdhNpj9HffUcf8RoP6Ng5d"
        },
        "tokens_burnt": "242808422318200000000"
      },
      "proof": [
        {
          "direction": "Right",
          "hash": "Agyg5P46kSVa4ptG9spteHpZ5c8XkvfbmDN5EUXhC1Wr"
        },
        {
          "direction": "Right",
          "hash": "3JDKkLCy5bJaAU3exa66sotTwJyGwyChxeNJgKReKw34"
        },
        {
          "direction": "Right",
          "hash": "7GXEmeQEJdd4c2kgN7NoYiF2bkjzV4bNkMmkhpK14NTz"
        }
      ]
    }
  }
}
```
</details>

Was the fungible token transfer successful?
  - Look for `result` ¬ª `transaction_outcome` ¬ª `outcome` ¬ª see if `SuccessReceiptId` is a key
  - if `SuccessReceiptId` is not a key, this fungible token transfer has `failed`.
  - If it does have that key, get the value, which is a `receipt ID`
  - Loop through `result` ¬ª `receipts_outcome` until you find an object that ID (from above) under the id key
  - in that object check `outcome` ¬ª `status` ¬ª (see if SuccessValue is a key)
  - If SuccessValue is a key, fungible token transfer succeeded, if not, it failed.

To determine how many fungible tokens were transferred, look at:
  - `result` ¬ª `transaction` ¬ª `actions` ¬ª `FunctionCall` ¬ª `args`
  - then take the args and `base64` decode it, that will give you a JSON payload and look for the `amount` key
  - It will contain a stringified number that represents the number of fungible tokens that were successfully transferred

## Transfer and call {#transfer-and-call}

If the idea of a fungible token using "transfer and call" is new, please review the comments above the function in [the Nomicon spec](https://nomicon.io/Standards/Tokens/FungibleToken/Core#reference-level-explanation). Also, see a similar idea [from EIP-677](https://github.com/ethereum/EIPs/issues/677).

For this example we will build and deploy FT contracts from [near-sdk-rs/examples/fungible-token](https://github.com/near/near-sdk-rs/tree/master/examples/fungible-token).

Let's call `ft_transfer_call` function on `ft` contract (receiver) and examine successful and unsuccessful scenarios.

### Successful transfer and call {#successful-transfer-and-call}
  Let's send 10 N to `DEFI` contract that requires only 9 N.

  - using NEAR CLI
    ```bash
    near call <ft_contract_id> ft_transfer_call '{"receiver_id": "<defi_contract_id>", "amount": "10", "msg": "take-my-money"}' --accountId <user_account_id> --amount 0.000000000000000000000001
    ```

  - with JSON RPC call

Transaction representation:
```yaml
Transaction: {
	block_hash: `456‚Ä¶abc`,
	signer_id: "serhii.testnet",
	public_key: "ed25519:789‚Ä¶def",
	nonce: 123,
	receiver_id: "dev-1623333795623-21399959778159",
	actions: [
		FunctionCall(
			FunctionCallAction {
				method_name: ft_transfer_call,
				args: `{"receiver_id":"dev-1623693121955-71667632531176","amount":"10","msg":"take-my-money"}`,
				gas: 300000000000000,
				deposit: 1,
			},
		),
	]
}
```

    ```bash
      http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=broadcast_tx_commit \
      params:='["DgAAAHNlcmhpaS50ZXN0bmV0AEKEp54fyVkp8dJE2l/m1ErjdhDGodBK8ZF6JLeHFMeZqPqoVEgrAAAgAAAAZGV2LTE2MjMzMzM3OTU2MjMtMjEzOTk5NTk3NzgxNTn9j4g2IJ8nGQ38i3+k+4WBAeJL1xP7ygQhC7CrvEG4NQEAAAACEAAAAGZ0X3RyYW5zZmVyX2NhbGxWAAAAeyJyZWNlaXZlcl9pZCI6ImRldi0xNjIzNjkzMTIxOTU1LTcxNjY3NjMyNTMxMTc2IiwiYW1vdW50IjoiMTAiLCJtc2ciOiJ0YWtlLW15LW1vbmV5In0AQHoQ81oAAAEAAAAAAAAAAAAAAAAAAAAANY2lHqJlAJYNDGEQiUNnmfiBV44Q1sdg45xNlNvlROOM+AtN1z3PSJqM6M6jAKXUwANoQTzFqXhIMHIjIPbTAA=="]'
    ```

To get details of this transaction:

```bash
http post https://archival-rpc.testnet.near.org jsonrpc=2.0 method=EXPERIMENTAL_tx_status \
    params:='["5n1kwA3TQQyFTkddR2Jau3H1Pt8ebQNGaov6aCQ6TDp1", "serhii.testnet"]' id=myid
```

<details>
<summary>**Example Response:**</summary>

```json
{
  "id": "myid",
  "jsonrpc": "2.0",
  "result": {
    "receipts": [
      {
        "predecessor_id": "serhii.testnet",
        "receipt": {
          "Action": {
            "actions": [
              {
                "FunctionCall": {
                  "args": "eyJyZWNlaXZlcl9pZCI6ImRldi0xNjIzNjkzMTIxOTU1LTcxNjY3NjMyNTMxMTc2IiwiYW1vdW50IjoiMTAiLCJtc2ciOiJ0YWtlLW15LW1vbmV5In0=",
                  "deposit": "1",
                  "gas": 100000000000000,
                  "method_name": "ft_transfer_call"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "Hw6z8kJ7CSaC6SgyQzcmXzNX9gq1gaAnLS169qgyZ2Vk",
        "receiver_id": "dev-1623333795623-21399959778159"
      },
      {
        "predecessor_id": "dev-1623333795623-21399959778159",
        "receipt": {
          "Action": {
            "actions": [
              {
                "FunctionCall": {
                  "args": "eyJzZW5kZXJfaWQiOiJzZXJoaWkudGVzdG5ldCIsImFtb3VudCI6IjEwIiwibXNnIjoidGFrZS1teS1tb25leSJ9",
                  "deposit": "0",
                  "gas": 70000000000000,
                  "method_name": "ft_on_transfer"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [
              {
                "data_id": "EiDQi54XHfdD1KEcgiNzogXxXuwTpzeQfmyqVwbq7H4D",
                "receiver_id": "dev-1623333795623-21399959778159"
              }
            ],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "EB69xtJiLRh9RNzAHgBGmom8551hrK2xSRreqbjvJgu5",
        "receiver_id": "dev-1623693121955-71667632531176"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "13116953530949529501760"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "AkwgvxUspRgy255fef2hrEWMbrMWFtnTRGduSgDRdSW1",
        "receiver_id": "serhii.testnet"
      },
      {
        "predecessor_id": "dev-1623333795623-21399959778159",
        "receipt": {
          "Action": {
            "actions": [
              {
                "FunctionCall": {
                  "args": "eyJzZW5kZXJfaWQiOiJzZXJoaWkudGVzdG5ldCIsInJlY2VpdmVyX2lkIjoiZGV2LTE2MjM2OTMxMjE5NTUtNzE2Njc2MzI1MzExNzYiLCJhbW91bnQiOiIxMCJ9",
                  "deposit": "0",
                  "gas": 5000000000000,
                  "method_name": "ft_resolve_transfer"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [
              "EiDQi54XHfdD1KEcgiNzogXxXuwTpzeQfmyqVwbq7H4D"
            ],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "4Tc8MsrJZSMpNZx7u4jSqxr3WhRzqxaNHxLJFqz8tUPR",
        "receiver_id": "dev-1623333795623-21399959778159"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "761030677610514102464"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "9rxcC9o8x4RX7ftsDCfxK8qnisYv45rA1HGPxhuukWUL",
        "receiver_id": "serhii.testnet"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "2137766093631769060520"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "H7YWFkvx16Efy2keCQ7BQ67BMEsdgdYLqJ99G4H3dR1D",
        "receiver_id": "serhii.testnet"
      }
    ],
    "receipts_outcome": [
      {
        "block_hash": "B9yZz1w3yzrqQnfBFAf17S4TLaHakXJWqmFDBbFxaEiZ",
        "id": "Hw6z8kJ7CSaC6SgyQzcmXzNX9gq1gaAnLS169qgyZ2Vk",
        "outcome": {
          "executor_id": "dev-1623333795623-21399959778159",
          "gas_burnt": 20612680932083,
          "logs": [
            "Transfer 10 from serhii.testnet to dev-1623693121955-71667632531176"
          ],
          "receipt_ids": [
            "EB69xtJiLRh9RNzAHgBGmom8551hrK2xSRreqbjvJgu5",
            "4Tc8MsrJZSMpNZx7u4jSqxr3WhRzqxaNHxLJFqz8tUPR",
            "H7YWFkvx16Efy2keCQ7BQ67BMEsdgdYLqJ99G4H3dR1D"
          ],
          "status": {
            "SuccessReceiptId": "4Tc8MsrJZSMpNZx7u4jSqxr3WhRzqxaNHxLJFqz8tUPR"
          },
          "tokens_burnt": "2061268093208300000000"
        },
        "proof": []
      },
      {
        "block_hash": "7Z4LHWksvw7sKYKwpQfjEMG8oigjtRXKa3EopN7hS2v7",
        "id": "EB69xtJiLRh9RNzAHgBGmom8551hrK2xSRreqbjvJgu5",
        "outcome": {
          "executor_id": "dev-1623693121955-71667632531176",
          "gas_burnt": 3568066327145,
          "logs": [
            "Sender @serhii.testnet is transferring 10 tokens using ft_on_transfer, msg = take-my-money"
          ],
          "receipt_ids": [
            "AkwgvxUspRgy255fef2hrEWMbrMWFtnTRGduSgDRdSW1"
          ],
          "status": {
            "SuccessValue": "IjEi"
          },
          "tokens_burnt": "356806632714500000000"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "5X2agUKpqmk7QkUZsDQ4R4HdX7zXeuPYpVAfvbmF5Gav"
          }
        ]
      },
      {
        "block_hash": "CrSDhQNn72K2Qr1mmoM9j3YHCo3wfZdmHjpHJs74WnPk",
        "id": "AkwgvxUspRgy255fef2hrEWMbrMWFtnTRGduSgDRdSW1",
        "outcome": {
          "executor_id": "serhii.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "4WG6hF5fTAtM7GSqU8mprrFwRVbChGMCV2NPZEjEdnc1"
          }
        ]
      },
      {
        "block_hash": "CrSDhQNn72K2Qr1mmoM9j3YHCo3wfZdmHjpHJs74WnPk",
        "id": "4Tc8MsrJZSMpNZx7u4jSqxr3WhRzqxaNHxLJFqz8tUPR",
        "outcome": {
          "executor_id": "dev-1623333795623-21399959778159",
          "gas_burnt": 6208280264404,
          "logs": [
            "Refund 1 from dev-1623693121955-71667632531176 to serhii.testnet"
          ],
          "receipt_ids": [
            "9rxcC9o8x4RX7ftsDCfxK8qnisYv45rA1HGPxhuukWUL"
          ],
          "status": {
            "SuccessValue": "Ijki"
          },
          "tokens_burnt": "620828026440400000000"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "BzT8YhEDDWSuoGGTBzH2Cj5GC4c56uAQxk41by4KVnXi"
          }
        ]
      },
      {
        "block_hash": "3Q2Zyscj6vG5nC2vdoYfcBHU9RVaAwoxHsHzAKVcAHZ6",
        "id": "9rxcC9o8x4RX7ftsDCfxK8qnisYv45rA1HGPxhuukWUL",
        "outcome": {
          "executor_id": "serhii.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": []
      },
      {
        "block_hash": "7Z4LHWksvw7sKYKwpQfjEMG8oigjtRXKa3EopN7hS2v7",
        "id": "H7YWFkvx16Efy2keCQ7BQ67BMEsdgdYLqJ99G4H3dR1D",
        "outcome": {
          "executor_id": "serhii.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "61ak42D3duBBunCz3w4xXxoEeR2N7oav5e938TnmGFGN"
          }
        ]
      }
    ],
    "status": {
      "SuccessValue": "Ijki"
    },
    "transaction": {
      "actions": [
        {
          "FunctionCall": {
            "args": "eyJyZWNlaXZlcl9pZCI6ImRldi0xNjIzNjkzMTIxOTU1LTcxNjY3NjMyNTMxMTc2IiwiYW1vdW50IjoiMTAiLCJtc2ciOiJ0YWtlLW15LW1vbmV5In0=",
            "deposit": "1",
            "gas": 100000000000000,
            "method_name": "ft_transfer_call"
          }
        }
      ],
      "hash": "5n1kwA3TQQyFTkddR2Jau3H1Pt8ebQNGaov6aCQ6TDp1",
      "nonce": 47589658000040,
      "public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN",
      "receiver_id": "dev-1623333795623-21399959778159",
      "signature": "ed25519:256qp2jAGXhhw2t2XfUAjWwzz3XcD83DH2v9THwDPsZjCLWHU8QJd6cuA773NP9yBmTd2ZyYiFHuxVEkYqnbsaSb",
      "signer_id": "serhii.testnet"
    },
    "transaction_outcome": {
      "block_hash": "96k8kKzFuZWxyiUnT774Rg7DC3XDZNuxhxD1qEViFupd",
      "id": "5n1kwA3TQQyFTkddR2Jau3H1Pt8ebQNGaov6aCQ6TDp1",
      "outcome": {
        "executor_id": "serhii.testnet",
        "gas_burnt": 2428149065268,
        "logs": [],
        "receipt_ids": [
          "Hw6z8kJ7CSaC6SgyQzcmXzNX9gq1gaAnLS169qgyZ2Vk"
        ],
        "status": {
          "SuccessReceiptId": "Hw6z8kJ7CSaC6SgyQzcmXzNX9gq1gaAnLS169qgyZ2Vk"
        },
        "tokens_burnt": "242814906526800000000"
      },
      "proof": []
    }
  }
}
```
</details>

Now, let's try to follow the steps described in the previous section and determine if these transactions was successful. In addition to being successful, let's analyze the various receipts in the series of cross-contract calls to determine how many fungible tokens were transferred. This will be the most complex case we'll look at.

  1. Check that `result` ¬ª `transaction_outcome` ¬ª `outcome` ¬ª `status` has `SuccessReceiptId` as a key. If not, no fungible tokens were transferred.
  2. Take the value of the `SuccessReceiptId` key. In the case above it's `Hw6z8kJ7CSaC6SgyQzcmXzNX9gq1gaAnLS169qgyZ2Vk`.
  3. Now, under `result` ¬ª `receipts` loop through the array until you find a receipt where the `receipt_id` matches the value from step 2. (Note that in the receipt, under `Actions` there's an element mentioning calling the `method_name: "ft_transfer_call"`.) On the same level of JSON, there's an `args` key. That's a base64-encoded value of the arguments passed to the method. When decoded it is:

```json
{"receiver_id":"dev-1623693121955-71667632531176","amount":"10","msg":"take-my-money"}
```

  4. Loop through `result` ¬ª `receipts_outcome` until finding the object where `id` is equal to the value from step 2. Similar to step 1, this object will also contain a `status` field that should contain the key `SuccessReceiptId`. Again, if this isn't there no fungible tokens were transferred, otherwise get the value of the `SuccessReceiptId`. In the above example, this value is `4Tc8MsrJZSMpNZx7u4jSqxr3WhRzqxaNHxLJFqz8tUPR`.
  5. Similar to the previous step, loop through the `result` ¬ª `receipts_outcome` until you find the object where the `id` matches the value from step 4. In that object check that `outcome` ¬ª `status` has the `SuccessValue` field. This `SuccessValue` represents how many fungible tokens the receiving contract is "returning" to the fungible token contract. Note that in the example above the value is `Ijki`, which is the base64-encoded version of `"9"`. At this point, we know that 10 fungible tokens were sent (from step 3) and 9 were taken.

For additional clarity, let's take a look at one more optional aspect. In step 4 we isolated an obeject in `result` ¬ª `receipts_outcome`. There's an array of `receipt_ids` that's particularly interesting. The first element in the array is the receipt ID `EB69xtJiLRh9RNzAHgBGmom8551hrK2xSRreqbjvJgu5`. If we loop through the `result` ¬ª `receipts_outcome` and find this as the value for the `id` key, we'll see what happened in the function `ft_on_transfer` which takes place in the contract receiving the fungible tokens. In this object the `status` ¬ª `SuccessValue` is `IjEi` which is the base64-encoded value of `"1"`.

In summary:
1. A user called the fungible token contract with the method `ft_transfer_call` specifying the receiver account, how many tokens to send, and custom info.
2. The receiver account implemented `ft_on_transfer`, returning `"1"` to the callback function on the fungible token contract.
3. The fungible token contract's callback is `ft_resolve_transfer` and receives this value of `"1"`. It knows that 1 token was returned, so subtracts that from the 10 it intended to send. It then returns to the user how many tokens were used in this back-and-forth series of cross-contract calls: `"9"`.

### Failed transfer and call {#failed-transfer-and-call}
Let's try to send more tokens than the account has:

  - using NEAR CLI
    ```bash
        near call <ft_contract_id> ft_transfer_call '{"receiver_id": "<defi_contract_id>", "amount": "1000000000", "msg": "take-my-money"}' --accountId <user_account_id> --amount 0.000000000000000000000001
    ```

Transaction representation:
```yaml
Transaction: {
	block_hash: `456‚Ä¶abc`,
	signer_id: "serhii.testnet",
	public_key: "ed25519:789‚Ä¶def",
	nonce: 123,
	receiver_id: "dev-1623333795623-21399959778159",
	actions: [
		FunctionCall(
			FunctionCallAction {
				method_name: ft_transfer_call,
				args: `{"receiver_id":"dev-1623333916368-58707434878533","amount":"1000000000","msg":"take-my-money"}`,
				gas: 300000000000000,
				deposit: 1,
			},
		),
	]
}
```

  - with JSON RPC call
      ```bash
          http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=broadcast_tx_commit \
          params:='["DgAAAHNlcmhpaS50ZXN0bmV0AEKEp54fyVkp8dJE2l/m1ErjdhDGodBK8ZF6JLeHFMeZn/qoVEgrAAAgAAAAZGV2LTE2MjMzMzM3OTU2MjMtMjEzOTk5NTk3NzgxNTnrbOQ93Wv9xxBwmq4yDYrssCpwKSI2bzjNNCCCHMZKNwEAAAACEAAAAGZ0X3RyYW5zZmVyX2NhbGxeAAAAeyJyZWNlaXZlcl9pZCI6ImRldi0xNjIzMzMzOTE2MzY4LTU4NzA3NDM0ODc4NTMzIiwiYW1vdW50IjoiMTAwMDAwMDAwMCIsIm1zZyI6InRha2UtbXktbW9uZXkifQBAehDzWgAAAQAAAAAAAAAAAAAAAAAAAABQh3k+7zG2m/Yz3O/FBrvLaBwR/5YRB5FbFnb27Nfu6BW/Wh77RFH7+ktBwGLBwFbJGxiumIcsqBiGXgg1EPMN"]'
      ```

To get details of this transaction:

```bash
http post https://archival-rpc.testnet.near.org jsonrpc=2.0 method=EXPERIMENTAL_tx_status \
    params:='["FQsh44pvEsK8RS9AbK868CmGwfhUU2pUrizkQ6wCWTsB", "serhii.testnet"]' id=myid
```

<details>
<summary>**Example response**:</summary>

```json
{
  "id": "myid",
  "jsonrpc": "2.0",
  "result": {
    "receipts": [
      {
        "predecessor_id": "serhii.testnet",
        "receipt": {
          "Action": {
            "actions": [
              {
                "FunctionCall": {
                  "args": "eyJyZWNlaXZlcl9pZCI6ImRldi0xNjIzMzMzOTE2MzY4LTU4NzA3NDM0ODc4NTMzIiwiYW1vdW50IjoiMTAwMDAwMDAwMCIsIm1zZyI6InRha2UtbXktbW9uZXkifQ==",
                  "deposit": "1",
                  "gas": 100000000000000,
                  "method_name": "ft_transfer_call"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "83AdQ16bpAC7BEUyF7zoRsAgeNW7HHmjhZLvytEsrygo",
        "receiver_id": "dev-1623333795623-21399959778159"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "1"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "system",
            "signer_public_key": "ed25519:11111111111111111111111111111111"
          }
        },
        "receipt_id": "Euy4Q33DfvJTXD8HirE5ACoXnw9PMTQ2Hq47aGyD1spc",
        "receiver_id": "serhii.testnet"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "18681184841157733814920"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "6ZDoSeV3gLFS2NXqMCJGEUR3VwBpSxBEPjnEEaAQfmXL",
        "receiver_id": "serhii.testnet"
      }
    ],
    "receipts_outcome": [
      {
        "block_hash": "BohRBwqjRHssDVS9Gt9dj3SYuipxHA81xXFjRVLqgGeb",
        "id": "83AdQ16bpAC7BEUyF7zoRsAgeNW7HHmjhZLvytEsrygo",
        "outcome": {
          "executor_id": "dev-1623333795623-21399959778159",
          "gas_burnt": 3734715409940,
          "logs": [],
          "receipt_ids": [
            "Euy4Q33DfvJTXD8HirE5ACoXnw9PMTQ2Hq47aGyD1spc",
            "6ZDoSeV3gLFS2NXqMCJGEUR3VwBpSxBEPjnEEaAQfmXL"
          ],
          "status": {
            "Failure": {
              "ActionError": {
                "index": 0,
                "kind": {
                  "FunctionCallError": {
                    "ExecutionError": "Smart contract panicked: The account doesn't have enough balance"
                  }
                }
              }
            }
          },
          "tokens_burnt": "373471540994000000000"
        },
        "proof": []
      },
      {
        "block_hash": "4BzTmMmTjKvfs6ANS5gmJ6GQzhqianEGWq7SaxSfPbdC",
        "id": "Euy4Q33DfvJTXD8HirE5ACoXnw9PMTQ2Hq47aGyD1spc",
        "outcome": {
          "executor_id": "serhii.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "5ipmcdgTieQqFXWQFCwcbZhFtkHE4PL4nW3mknBchpG6"
          }
        ]
      },
      {
        "block_hash": "4BzTmMmTjKvfs6ANS5gmJ6GQzhqianEGWq7SaxSfPbdC",
        "id": "6ZDoSeV3gLFS2NXqMCJGEUR3VwBpSxBEPjnEEaAQfmXL",
        "outcome": {
          "executor_id": "serhii.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "9tcjij6M8Ge4aJcAa97He5nw8pH7PF8ZjRHVahBZD2VW"
          }
        ]
      }
    ],
    "status": {
      "Failure": {
        "ActionError": {
          "index": 0,
          "kind": {
            "FunctionCallError": {
              "ExecutionError": "Smart contract panicked: The account doesn't have enough balance"
            }
          }
        }
      }
    },
    "transaction": {
      "actions": [
        {
          "FunctionCall": {
            "args": "eyJyZWNlaXZlcl9pZCI6ImRldi0xNjIzMzMzOTE2MzY4LTU4NzA3NDM0ODc4NTMzIiwiYW1vdW50IjoiMTAwMDAwMDAwMCIsIm1zZyI6InRha2UtbXktbW9uZXkifQ==",
            "deposit": "1",
            "gas": 100000000000000,
            "method_name": "ft_transfer_call"
          }
        }
      ],
      "hash": "FQsh44pvEsK8RS9AbK868CmGwfhUU2pUrizkQ6wCWTsB",
      "nonce": 47589658000031,
      "public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN",
      "receiver_id": "dev-1623333795623-21399959778159",
      "signature": "ed25519:2cPASnxKtCoQtZ9NFq63fg8RzpjvmmE8hL4s2jk8zuhnBCD3AnYQ6chZZrUBGwu7WrsGuWUyohP1bEca4vfbsorC",
      "signer_id": "serhii.testnet"
    },
    "transaction_outcome": {
      "block_hash": "FwHUeqmYpvgkL7eBrUUAEMCuaQshcSy5vm4AHchebhK1",
      "id": "FQsh44pvEsK8RS9AbK868CmGwfhUU2pUrizkQ6wCWTsB",
      "outcome": {
        "executor_id": "serhii.testnet",
        "gas_burnt": 2428166952740,
        "logs": [],
        "receipt_ids": [
          "83AdQ16bpAC7BEUyF7zoRsAgeNW7HHmjhZLvytEsrygo"
        ],
        "status": {
          "SuccessReceiptId": "83AdQ16bpAC7BEUyF7zoRsAgeNW7HHmjhZLvytEsrygo"
        },
        "tokens_burnt": "242816695274000000000"
      },
      "proof": []
    }
  }
}
```
</details>

Let's examine this response.

  * `result` ¬ª `transaction_outcome` ¬ª `outcome` ¬ª `status` ¬ª `SuccessReceiptId` is `83AdQ16bpAC7BEUyF7zoRsAgeNW7HHmjhZLvytEsrygo`
  * check `result` ¬ª `receipts_outcome` ¬ª `0` ¬ª `outcome` ¬ª `status` and find `Failure` status there

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol"> Ask it on StackOverflow! </a>
:::

'''
'''--- docs/help.md ---
---
id: help
title: NEAR - Your Gateway to an Open Web
---

# Developer Help & Resources

[![DEVHUB](https://img.shields.io/badge/DEV_HUB-03BE09)](https://neardevhub.org/)
[![CALENDAR](https://img.shields.io/badge/CALENDAR-F9F502)](https://bit.ly/near-dev-calendar)
[![DEV SUPPORT](https://img.shields.io/badge/DEV_SUPPORT-BE0303)](https://t.me/addlist/VyVjNaP190JlOGMx)
[![NEWSLETTER](https://img.shields.io/badge/NEWSLETTER-0087E5)](https://newsletter.neardevhub.org/)
[![FEEDBACK](https://img.shields.io/badge/FEEDBACK-purple)](https://github.com/orgs/near/discussions/new?category=dev-feedback)

NEAR is dedicated to providing the best developer experience possible for building an open web. This mission is next to impossible to achieve without feedback and contributions from **people like you**. ü´µ

**Get involved!** üëâ please select one of the options above or contribute to one of the essential developer repositories listed below üôè

:::info Contact Us
- [Developer Hub](https://neardevhub.org/)
- [Telegram Support](https://t.me/neardev)
- [Discord](https://near.chat)
- [Zulip](https://near.zulipchat.com)
:::

---

### üìù Docs

| Website      | Description | Repo |
| ----------- | ----------- | --- |
|[docs.near.org](https://docs.near.org) | NEAR Developer Documentation |[near/docs](https://github.com/near/docs)
|[nomicon.io](https://nomicon.io)| NEAR Protocol Specification Documentation | [near/neps](https://github.com/near/neps)
|[near-nodes.io](https://near-nodes.io)| NEAR Node Documentation _(Validator, RPC, Archival)_ |[near/node-docs](https://github.com/near/node-docs)

---

### ‚õìÔ∏è Protocol

| Name      | Description | Repo | Latest Release |
| ----------- | ----------- | --- | --- |
| nearcore | Reference implementation of NEAR Protocol  |[near/nearcore](https://github.com/near/nearcore)|[![Latest Release](https://img.shields.io/github/v/release/near/nearcore?label=)](https://github.com/near/nearcore/releases)
| NEPs | NEAR Protocol Specifications and Standards  |[near/neps](https://github.com/near/neps)| ‚ûñ

---

### üöÄ Decentralized Frontend Stack

> Create decentralized frontend components by storing it's source code on the blockchain ü§Ø.

| Name      | Description | Repo | Latest Release |
| ----------- | ----------- | --- |--|
|**üëâ GATEWAY**||||
| near-discovery    | near.org Gateway  |[near/near-discovery](https://github.com/near/near-discovery)| [![Latest Release](https://img.shields.io/github/v/release/near/near-discovery?label=)](https://github.com/near/near-discovery/releases)
| near.social | near.social Gateway | [NearSocial/viewer](https://github.com/NearSocial/viewer) | ‚ûñ
| near-discovery-components | Core components / primitives for near.org | [near/near-discovery-components](https://github.com/near/near-discovery-components)| ‚ûñ
|**üëâ EXECUTION ENVIRONMENT**||||
| VM   | B.O.S. Virtual Machine  | [nearsocial/VM](https://github.com/NearSocial/VM) |[![Latest Release](https://img.shields.io/github/v/release/nearsocial/vm?label=)](https://github.com/nearsocial/vm/releases)
| BWE | B.O.S. Web Engine ***(WIP replacement for VM)*** | [near/bos-web-engine](https://github.com/near/bos-web-engine) |‚ûñ
|**üëâ DATABASE**||||
| B.O.S. Database | Smart contract hosting frontend source code & user data | [nearsocial/social-db](https://github.com/NearSocial/social-db)|‚ûñ

---

### üõ†Ô∏è Dev Tools

| Name      | Description | Repo | Latest Release |
| ----------- | ----------- | --- |--|
| create-near-app | Easy fullstack dApp deployment tool | [near/create-near-app](https://github.com/near/create-near-app) | [![Latest Release](https://img.shields.io/github/v/release/near/create-near-app?label=)](https://github.com/near/create-near-app/releases)
| cargo-near | Cargo extension for building smart contracts and ABI schemas on NEAR | [near/cargo-near](https://github.com/near/cargo-near) | [![Latest Release](https://img.shields.io/github/v/release/near/cargo-near?label=)](https://github.com/near/cargo-near/releases)
| BOS VSCode Ext. | VSCode extension for building B.O.S. components | [near/near-vscode](https://github.com/near/near-vscode) | [![Latest Release](https://img.shields.io/github/v/release/near/near-vscode?label=)](https://github.com/near/near-vscode/releases)
| BOS Loader | Simplifying multiple component local development | [near/bos-loader](https://github.com/near/bos-loader) | [![Latest Release](https://img.shields.io/github/v/release/near/bos-loader?label=)](https://github.com/near/bos-loader/releases)

### üíª CLI

| Name      | Description | Repo | Latest Release |
| ----------- | ----------- | --- |--|
| near-cli | JS based CLI for interacting w/ NEAR | [near/near-cli](https://github.com/near/near-cli)|[![Latest Release](https://img.shields.io/github/v/release/near/near-cli?label=)](https://github.com/near/near-cli/releases)
| near-cli-rs| Rust based CLI for interacting w/ NEAR | [near/near-cli-rs](https://github.com/near/near-cli-rs)| [![Latest Release](https://img.shields.io/github/v/release/near/near-cli-rs?label=)](https://github.com/near/near-cli-rs/releases)
| BOS CLI | CLI for simplifying local development on BOS | [bos-cli-rs/bos-cli-rs](https://github.com/bos-cli-rs/bos-cli-rs) | [![Latest Release](https://img.shields.io/github/v/release/bos-cli-rs/bos-cli-rs?label=)](https://github.com/bos-cli-rs/bos-cli-rs/releases)

### üîë Wallet / Auth

| Name      | Description | Repo | Latest Release |
| ----------- | ----------- | --- | --- |
| wallet-selector |Wallet integration tool for NEAR|[near/wallet-selector](https://github.com/near/wallet-selector)|[![Latest Release](https://img.shields.io/github/v/release/near/wallet-selector?label=)](https://github.com/near/wallet-selector/releases)
| web3-onboard | Wallet integration tool for multichain |[blocknative/web3-onboard](https://github.com/blocknative/web3-onboard)|[![Latest Release](https://img.shields.io/github/v/release/blocknative/web3-onboard?label=)](https://github.com/blocknative/web3-onboard/releases)
| FastAuth Signer | Authenticate and sign transactions w/ FastAuth |[near/fast-auth-signer](https://github.com/near/fast-auth-signer)|‚ûñ
| mpc-recovery | Create and restore accounts w/ OIDC protocol|[near/mpc-recovery](https://github.com/near/mpc-recovery)|‚ûñ
| iDOS | Decentralized identity, storage, and verification | [idos-network/idos-sdk-js](https://github.com/idos-network/idos-sdk-js)|‚ûñ

### üîå API

| Name      | Description | Repo | Latest Release |
| ----------- | ----------- | --- | --- |
| near-api-js | API tool for frontend & backend JS libraries |[near/near-api-js](https://github.com/near/near-api-js)|[![Latest Release](https://img.shields.io/github/v/release/near/near-api-js?label=)](https://github.com/near/near-api-js/releases)

### üìù Smart Contracts

| Name      | Description | Repo | Latest Release |
| ----------- | ----------- | --- |---|
| near-sdk-js|Create smart contracts w/ JavaScript | [near/near-sdk-js](https://github.com/near/near-sdk-js) | [![Latest Release](https://img.shields.io/github/v/release/near/near-sdk-js?label=)](https://github.com/near/near-sdk-js/releases)
| near-sdk-rs|Create smart contracts w/ Rust | [near/near-sdk-rs](https://github.com/near/near-sdk-rs)| [![Latest Release](https://img.shields.io/github/v/release/near/near-sdk-rs?label=)](https://github.com/near/near-sdk-rs/releases)
| Keypom | Customizable key creation for NFT/FT drops  |[keypom/keypom](https://github.com/keypom/keypom)|[![Latest Release](https://img.shields.io/github/v/release/keypom/keypom?label=)](https://github.com/keypom/keypom/releases)

### üß™ Testing

| Name      | Description | Repo | Latest Release |
| ----------- | ----------- | --- | --- |
| workspaces-js| Testing sandbox written in JS  |[near/workspaces-js](https://github.com/near/workspaces-js)|[![Latest Release](https://img.shields.io/github/v/release/near/near-workspaces-js?label=)](https://github.com/near/near-workspaces-js/releases)
| workspaces-rs| Testing sandbox written in Rust |[near/workspaces-rs](https://github.com/near/workspaces-rs)|[![Latest Release](https://img.shields.io/github/v/release/near/near-workspaces-rs?label=)](https://github.com/near/near-workspaces-rs/releases)

### üîé Blockchain Data Indexing

| Name      | Description | Repo | Latest Release |
| ----------- | ----------- | --- | --- |
| QueryApi | Build custom indexers and query with GraphQL endpoints|[near/queryapi](https://github.com/near/queryapi)|‚ûñ
| near-lake-indexer | Built on [NEAR Indexer](https://github.com/near/nearcore/tree/master/chain/indexer) that stores JSON in AWS S3 bucket  |[near/near-lake-indexer](https://github.com/near/near-lake-indexer)|[![Latest Release](https://img.shields.io/github/v/release/near/near-lake-indexer?label=)](https://github.com/near/near-lake-indexer/releases)
| near-lake-framework-rs | Stream blocks from NEAR Lake into your server |[near/near-lake-framework-rs](https://github.com/near/near-lake-framework-rs)|[![Latest Release](https://img.shields.io/github/v/release/near/near-lake-framework-rs?label=)](https://github.com/near/near-lake-framework-rs/releases)
| near-lake-framework-js | Stream blocks from NEAR Lake into your server |[near/near-lake-framework-js](https://github.com/near/near-lake-framework-js)| ‚ûñ

'''
'''--- docs/index.md ---
---
id: welcome
title: NEAR - Your Gateway to an Open Web
hide_table_of_contents: true
---
import {FeatureList, Column, Feature} from "@site/src/components/featurelist"

Welcome, this is the starting point for all NEAR documentation. Learn to build and publish blockchain applications. Embrace the power of Web3.

<div className="row">
  <div className="col col--4">
    <a href="/concepts/welcome">
      <div className="card">
        <div className="card__image">
          <img src={require("@site/static/docs/assets/welcome-pages/protocol.png").default} alt="Learn" />
        </div>
        <div className="card__body">
          <h3>Understanding NEAR</h3>
          Learn what NEAR is and how it works
        </div>
      </div>
    </a>
  </div>
  <div className="col col--4">
    <a href="/build/smart-contracts/what-is">
      <div className="card">
        <div className="card__image">
          <img src={require("@site/static/docs/assets/welcome-pages/contracts.png").default} alt="Contracts" />
        </div>
        <div className="card__body">
          <h3>Smart Contracts</h3>
          Learn to build smart contracts in NEAR
        </div>
      </div>
    </a>
  </div>
  <div className="col col--4">
    <a href="/build/near-components/what-is">
      <div className="card">
        <div className="card__image">
          <img src={require("@site/static/docs/assets/welcome-pages/bos-big.png").default} alt="Web3 Components" />
        </div>
        <div className="card__body">
          <h3>Web3 Components</h3>
          The building blocks for multi-chain apps
        </div>
      </div>
    </a>
  </div>
  <div className="col col--4">
    <a href="/build/web3-apps/what-is">
      <div className="card">
        <div className="card__image">
          <img src={require("@site/static/docs/assets/welcome-pages/examples.png").default} alt="Solutions" />
        </div>
        <div className="card__body">
          <h3>Web3 Applications</h3>
          Supercharge your App using NEAR
        </div>
      </div>
    </a>
  </div>
  <div className="col col--4">
    <a href="/tools/welcome">
      <div className="card">
        <div className="card__image">
          <img src={require("@site/static/docs/assets/welcome-pages/tools.png").default} alt="Tools" />
        </div>
        <div className="card__body">
          <h3>NEAR Tools</h3>
          Discover our SDK, API, CLI, and more
        </div>
      </div>
    </a>
  </div>
  <div className="col col--4">
    <a href="/build/data-infrastructure/what-is">
      <div className="card">
        <div className="card__image">
          <img src={require("@site/static/docs/assets/welcome-pages/data-lake.png").default} alt="Data Lake" />
        </div>
        <div className="card__body">
          <h3>Query On-Chain Information</h3>
            Learn about indexers and our data lake
        </div>
      </div>
    </a>
  </div>
</div>

<hr className="subsection" />

<h1 className="text-center big-title" > Browse the Docs By Topic </h1>

<FeatureList>
  <Column title="Understanding NEAR" size="3">
    <Feature url="/concepts/basics/protocol" title="What is NEAR?" subtitle="Learn the Basics about NEAR" image="near-logo.png" />
    <Feature url="/concepts/protocol/account-id" title="Named Accounts" subtitle="NEAR uses human-readable accounts" image="user.png" />
    <Feature url="/concepts/protocol/access-keys" title="Multiple Access Keys" subtitle="More keys means more security" image="key.png" />
    <Feature url="/concepts/protocol/smartcontract" title="Smart Contracts" subtitle="Learn about our contract technology" image="contract.png" />
  </Column>
  <Column title="Developer Docs" size="3">
    <Feature url="/build/web3-apps/quickstart" title="Quickstart: WebApp" subtitle="Spin-up your first dApp" image="quickstart.png" />
    <Feature url="/build/smart-contracts/quickstart" title="Quickstart: Contract"
             subtitle="Learn how to write smart contracts" image="smartcontract.png" />
    <Feature url="/build/near-components/anatomy/state" title="Multi-chain Components"
             subtitle="Learn about multi-chain components" image="bos-lido.png" />
    <Feature url="/build/data-infrastructure/query-api/intro" title="QueryAPI" subtitle="The simplest way to build indexers" image="blocks.png" />
  </Column>
  <Column title="Developer Tools" size="3">
    <Feature url="/sdk/js/introduction" title="JavaScript SDK" subtitle="Write contracts in JavaScript" image="smartcontract-js.png" />
    <Feature url="/sdk/rust/introduction" title="Rust SDK" subtitle="Write contracts in Rust" image="smartcontract-rust.png" />
    <Feature url="/tools/near-cli" title="NEAR CLI" subtitle="Use NEAR from the Terminal" image="near-cli.png" />
    <Feature url="/tools/near-api-js/quick-reference" title="NEAR API JS" subtitle="Interact with NEAR from JS" image="near-api-js.png" />
    <Feature url="/api/rpc/introduction" title="RPC API" subtitle="Interact with the NEAR RPC API" image="rpc.png" />
  </Column>
  <Column title="Examples & Tutorials" size="3">
    <Feature url="/tutorials/examples/donation" title="Donation" subtitle="Receive and send tokens" image="donation.png" />
    <Feature url="/tutorials/examples/factory" title="Factory Contract" subtitle="Build a contract that deploys contracts" image="factory.png" />
    <Feature url="/tutorials/examples/frontend-multiple-contracts" title="Multi-Contract Frontend" subtitle="Interact with multiple contracts" image="multiple.png" />
    <Feature url="/tutorials/nfts/js/introduction" title="Master NFTs on NEAR (JS)" subtitle="Learn everything about NFT in JS" image="nft-marketplace-js.png" />
  </Column>
</FeatureList>

---

## External Resources

Here are more sources from our ecosystem that can help you to learn more about NEAR.

<div className="row cards">
  <div className="col col--6">
    <a href="https://near.org/applications">
      <div className="card">
        <div className="card__image">
          <img src={require("@site/static/docs/assets/welcome-pages/awesomenear.jpg").default} alt="Discover" />
        </div>
        <div className="card__body">
          <h3>
          Discover
          </h3>
          Discover awesome apps in the Near ecosystem.
        </div>
      </div>
    </a>
  </div>
  <div className="col col--6">
    <a href="https://nomicon.io">
      <div className="card">
        <div className="card__image">
          <img src={require("@site/static/docs/assets/welcome-pages/nomicon.png").default} alt="Nomicon" />
        </div>
        <div className="card__body">
          <h3>
          Nomicon
          </h3>
          See how NEAR is implemented in the official protocol specification.
        </div>
      </div>
    </a>
  </div>
  <div className="col col--6">
    <a href="https://near-nodes.io">
      <div className="card">
        <div className="card__image">
          <img src={require("@site/static/docs/assets/welcome-pages/validate.png").default} alt="Validate" />
        </div>
        <div className="card__body">
          <h3>
          Running a Node
          </h3>
          Documentation on becoming a validator to help keeping the blockchain safe
        </div>
      </div>
    </a>
  </div>
  <div className="col col--6">
    <a href="https://templates.mintbase.xyz/">
      <div className="card">
        <div className="card__image">
          <img src={require("@site/static/docs/assets/welcome-pages/mintbase-templates.png").default} alt="Templates" />
        </div>
        <div className="card__body">
          <h3>Templates</h3>
            Templates for creating web3 applications
        </div>
      </div>
    </a>
  </div>
</div>

'''
'''--- docs/pagoda/alerts/intro.md ---
---
sidebar_position: 1
sidebar_label: "Introduction"
---

# Pagoda Alerts & Triggers

:::warning

Please be advised that these tools and services will be discontinued soon.

:::

## What are Alerts & Triggers?

Pagoda Alerts & Triggers are designed to notify, and automated responses to important events that occur on the NEAR blockchain. Behind the scenes, Alerts are powered by  many mini-indexers, ‚ÄúAlertexers‚Äù, that stream blockchain data in real-time, enabling developers to know what‚Äôs happening to their dApp before their users do.

Alerts are broken into three parts: 
1. The NEAR address the alert should listen to (account or contract)
2. The event condition (success & failed actions, account drains, and more)
3. The alert destination ([e-mail](setup.md#setting-up-e-mail-alerts), [Telegram](setup.md#setting-up-telegram-alerts), [webhooks](webhooks.md))

Alerts can be set-up to listen for the following five conditions: 
1. Successful Actions
2. Failed Actions
3. [Event Logged](https://nomicon.io/Standards/EventsFormat)
4. Function Called
5. Account Balance Change

## Setup

- [E-mail alerts](setup.md#setting-up-e-mail-alerts)
- [Telegram alerts](setup.md#setting-up-telegram-alerts)
- [Event Log Alerts](setup.md#setting-up-event-log-alerts)
- [Function Call Specific Alerts](setup.md#setting-up-function-call-specific-alerts)

## Using Webhooks with Alerts & Triggers

See an example on how to [set up alerts using webhooks](webhooks.md).

'''
'''--- docs/pagoda/alerts/setup.md ---
---
sidebar_position: 1
sidebar_label: "Setup"
---

# Setup Alerts & Triggers

:::warning

Please be advised that these tools and services will be discontinued soon.

:::

## Setting up E-mail alerts

1. Navigate to [console.pagoda.co](https://console.pagoda.co) and log-in 

2. Navigate to the <kbd>Alerts</kbd> tab

   <img width="20%" src="/docs/pagoda/setup1.png" />

3. Select a target address for the alert to listen to
   <img width="60%" src="/docs/pagoda/setup2.png" />

4. Select one of the following conditions to listen for
   <img width="60%" src="/docs/pagoda/setup3.png" />

5. Select email as the destination to send alerts to and enter an email address to send the alert to
   <img width="60%" src="/docs/pagoda/setup4.png" />

6. This email address will need to be verified before it can be used as a valid alert destination. 
   <img width="60%" src="/docs/pagoda/setup5.png" />

7. Be sure that the email destination is toggled on as shown below and click "Create Alert" to finish setting up your email alert
   <img width="60%" src="/docs/pagoda/setup6.png" />

## Setting up Telegram alerts

Follow the steps above to begin setting-up telegram alerts. When selecting the destination select Telegram and follow these steps to authorize Alerts

<img width="60%" src="/docs/pagoda/setup7.png" />

### Private Message Alerts

1. On the device that is logged into the telegram aclick "Open Telegram" or scan the QR code. 

   <img width="60%" src="/docs/pagoda/setup8.png" />

2. by Telegram. Hit "Send Message" to continue 

   <img width="40%" src="/docs/pagoda/setup9.png" />

3. Once inside the chat, hit "Start" to begin receiving alerts at this destination 

   <img width="60%" src="/docs/pagoda/setup10.png" />

### Group message alerts 

For group chats, add `PagodaDevConsoleBot` and copy the message you see in your on-screen modal and send it in the chat that includes`PagodaDevConsoleBot` to authorize the group chat destination

<img width="70%" src="/docs/pagoda/setup11.png" />

## Setting up Event Log Alerts

You can listen to on-chain events occurring to contracts that follow NEPs standards like NEP-171 (NFTs), NEP-141 (fungible tokens), or NEP-145 (storage management). All NEAR NEPs can be found on the [Nomicon NEAR site](https://nomicon.io/Standards/). 

To set-up an alert for an event, for example `nft_transfer` from [NEP-171 version 1.1.0](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core): 

1. Follow the steps above to begin setting up an alert.
2. Select the "Event Logged" condition,
3. Type the event name `nft_transfer`,
4. The standard `nep171`, and
5. Add the version `1.1.0` as seen below

<img width="80%" src="/docs/pagoda/setup12.png" />

> Note that input fields are case sensitive, and the standards field must be written in the format `nep123` not `NEP-123`

## Setting up Function Call Specific Alerts

More generally, Pagoda Console makes it easy to generate alerts based on specific function calls. Simply follow the steps above, select the "Function Called" condition, and type the method name **exactly** as it appears in the contract code or the contract's [ABI](https://github.com/near/abi)

<img width="80%" src="/docs/pagoda/setup13.png" />

'''
'''--- docs/pagoda/alerts/webhooks.md ---
---
sidebar_position: 2
sidebar_label: "Webhooks Example"
---

# Turn on the (Hue) lights with NEAR NFTs and Pagoda Alerts & Triggers

:::warning

Please be advised that these tools and services will be discontinued soon.

:::

## Overview 

How cool would it be to have your lights turn on or your favorite song on spotify to play when someone bought your NFT on NEAR? 

With the Pagoda Console and IFTTT you can do both in minutes with zero code!

## What will we be doing? 

Using a combination of the [Pagoda Console](https://console.pagoda.co) and [IFTTT](https://ifttt.com) we will turn on our lights when a successful transaction has been processed. 

We will be using the webhook trigger to allow the pagoda console to call an endpoint on IFTTT which will then turn on our HUE Lights 

### What is IFTTT? 

IFTTT stands for "If This Then That". It's a platform (at ifttt.com) that provides a variety of services each with their own collection of applets within it that provide some unique functionality. 

<img width="60%" src="/docs/pagoda/webhook1.png" />

#### If This

It starts with the "If This" Trigger. For example time could be your trigger, so if it's 10pm you can write your own script to turn off your lights. Or something more random like, liking a song on spotify could add the music video to a youtube playlist. 

There are a lot of triggers on this service, but just to name some examples 

- Time
- Temperature 
- Webhooks (what we'll be using)

#### Then That 

Next comes the "Then That" action. An action is what happens when your trigger has been tripped. For example, turning out the lights at 10pm OR turning them on when you mint an NFT on NEAR. 

## Step 1: Getting the webhook address

We will be setting up a webhook trigger so after you make an account on ifttt.com You will see this page.... 

<img width="70%" src="/docs/pagoda/webhook2.png" />

Go to the **Services** Tab and search for "webhook"

<img width="20%" src="/docs/pagoda/webhook3.png" />

Click on the webhooks icon and then you'll be sent to this page...

<img width="50%" src="/docs/pagoda/webhook4.png" />

Click on the "Documentation Button". This should open up a new tab....

<img width="70%" src="/docs/pagoda/webhook5.png" />

Leave that page alone for now we'll come back to it. This is essentially where we get the webhook address we will call for our "IF". 

## Step 2: Setting up your Trigger 

Hit the **Create** Button on the upper right corner of the screen..

<img width="20%" src="/docs/pagoda/webhook6.png" />

Next click on the "If This" Button...

<img width="40%" src="/docs/pagoda/webhook7.png" />

Again search for **webhooks** ...

<img width="60%" src="/docs/pagoda/webhook8.png" />

Select the **Receive a Web Request** trigger...

<img width="30%" src="/docs/pagoda/webhook9.png" />

let's call this "**on_transaction**" then select create trigger 

<img width="50%" src="/docs/pagoda/webhook10.png" />

## Step 3: Select your Action 
You for this tutorial you will need to have:
- Hue Account
- Hue Lights

Next click on **Then That** ...

<img width="50%" src="/docs/pagoda/webhook11.png" />

Search for **Hue**

<img width="60%" src="/docs/pagoda/webhook12.png" />

Select Turn On Lights 

<img width="30%" src="/docs/pagoda/webhook13.png" />

Select the lights of your choosing but I will simply do all lights. 

If you haven't already create and connect your Hue Account

<img width="40%" src="/docs/pagoda/webhook14.png" />

After you do this simply hit **Create Action** Then you'll be redirected here... 

<img width="50%" src="/docs/pagoda/webhook15.png" />

As you can see you can add more than one trigger or action if you'd like. But for now we'll stick to the one. Hit **Continue**

## Step 4: Setting up your endpoint

Once you hit **Continue** you'll be redirected here...

<img width="40%" src="/docs/pagoda/webhook16.png" />

take note of the name "on_transaction" and copy it.. then hit the **Finish** button...

Next go back to the documentation tab we opened up earlier

Where it says `{event}` replace everything even the curly braces with "on_transaction"

<img width="90%" src="/docs/pagoda/webhook17.png" />

to 

<img width="90%" src="/docs/pagoda/webhook18.png" />

copy that entire line and head on over to console.pagoda.co 

## Step 5: Integrating Webhook into Pagoda Console

Once at console.pagoda.co, you should be greeted by the log-in page. Select the Non-funcable Token (NFT) project to start exploring the NFT contract

<img width="60%" src="/docs/pagoda/webhook19.png" />

Hit the "Deploy and Explore Contract" Button. This will create a dev account for you and deploy the pre written NFT smart contract onto that account for you. 

<img width="40%" src="/docs/pagoda/webhook20.png" />

Head to the <kbd>Alerts</kbd> section 

<img width="20%" src="/docs/pagoda/webhook21.png" />

And select <kbd>+ New Alert</kbd>

<img width="70%" src="/docs/pagoda/webhook22.png" />

You should see this page...

<img width="80%" src="/docs/pagoda/webhook23.png" />

Select the suggested contract which should be dev account that was created. 

<img width="80%" src="/docs/pagoda/webhook24.png" />

:::info
You can use any contract running on mainnet or testnet for an alert. We'll just use this NFT testnet example for this guide.  
:::

Under "Select Condition" hit "Successful Transaction". This means that for any successful transaction an alert will be sent. In this case for any successful method call the lights will turn on. If you want to, you can select "function call" for a specific method to be the trigger. 

But for now, we'll keep it easy and select any Successful Action. 

<img width="60%" src="/docs/pagoda/webhook25.png" />

We're almost done! Under destination select webhooks. Now that webhook we created earlier go ahead and copy and paste it into here. Then hit "Create"

:::tip
Don't forget to remove the `{}` around the name of your event! `ifttt.com/trigger/...`, not `ifftt.com/{trigger}/...`
:::

<img width="60%" src="/docs/pagoda/webhook26.png" />

Remember to hit the "+ Create Alert" button on this page... 

<img width="60%" src="/docs/pagoda/webhook27.png" />

Now head on over to the "Contracts" Section.

<img width="60%" src="/docs/pagoda/webhook28.png" />

Select the contract we just created and navigate to the "Interact" tab to connect your wallet. 

<img width="60%" src="/docs/pagoda/webhook29.png" />

Now here is the part we've all been waiting for... **Turn on the (hue) lights!** 

Select the `new_default_metadata` function (we are choosing this one because we have to initialize our contract, this is still a transaction which will trigger our new webhook). Fill in the `owner_id` field with your wallet account name and hit send transaction 

<img width="60%" src="/docs/pagoda/webhook30.png" />

## Wrapping up 

And that's it! You've just triggered something in the real world with an event that happened on the NEAR Blockchain. Hopefully this inspires you to create your own webhook using IFTTT and the Pagoda Console. 

We'd love to see what you create! Tag [@PagodaPlatform](https://twitter.com/PagodaPlatform) on Twitter with a novel implementation of a webhhook and trigger and we might retweet it. 

Happy hacking!

'''
'''--- docs/pagoda/rpc/api.md ---
---
title: NEAR Enhanced API
language_tabs:
  - shell: Shell
  - http: HTTP
  - javascript: JavaScript
  - ruby: Ruby
  - python: Python
  - php: PHP
  - java: Java
  - go: Go
toc_footers: []
includes: []
search: true
highlight_theme: darkula
headingLevel: 2

---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<!-- Generator: Widdershins v4.0.1 -->

:::warning

Please be advised that these tools and services will be discontinued soon.

:::

> Scroll down for code samples, example requests and responses. Select a language for code samples from the tabs above or the mobile navigation menu.

Try out our newly released Enhanced APIs - Balances (in Beta) and get what you need for all kinds of balances and token information at ease.
Call Enhanced APIs using the endpoint in the API URL box, varies by Network.

- https://near-testnet.api.pagoda.co/eapi/v1
- https://near-mainnet.api.pagoda.co/eapi/v1

Grab your API keys and give it a try! We will be adding more advanced Enhanced APIs in our offering, so stay tuned. Get the data you need without extra processing, NEAR Blockchain data query has never been easier!

We would love to hear from you on the data APIs you need, please leave feedback using the widget in the lower-right corner.

Base URLs:

* <a href="https://near-testnet.api.pagoda.co/eapi/v1">https://near-testnet.api.pagoda.co/eapi/v1</a>

## Authentication

* API Key (apiKey)
    - Parameter Name: **x-api-key**, in: header. Use Pagoda DevConsole API key here

## Non Fungible Tokens

### Get NFT

> Code samples

<Tabs>
<TabItem value="Shell">

```shell
# You can also use wget
curl -X GET https://near-testnet.api.pagoda.co/eapi/v1/NFT/{contract_account_id}/{token_id} \
  -H 'Accept: application/json' \
  -H 'x-api-key: API_KEY'

```

</TabItem>

<TabItem value="HTTP">

```http
GET https://near-testnet.api.pagoda.co/eapi/v1/NFT/{contract_account_id}/{token_id} HTTP/1.1
Host: near-testnet.api.pagoda.co
Accept: application/json

```

</TabItem>

<TabItem value="JS">

```javascript

const headers = {
  'Accept':'application/json',
  'x-api-key':'API_KEY'
};

fetch('https://near-testnet.api.pagoda.co/eapi/v1/NFT/{contract_account_id}/{token_id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

</TabItem>

<TabItem value="Ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json',
  'x-api-key' => 'API_KEY'
}

result = RestClient.get 'https://near-testnet.api.pagoda.co/eapi/v1/NFT/{contract_account_id}/{token_id}',
  params: {
  }, headers: headers

p JSON.parse(result)

```

</TabItem>

<TabItem value="Python">

```python
import requests
headers = {
  'Accept': 'application/json',
  'x-api-key': 'API_KEY'
}

r = requests.get('https://near-testnet.api.pagoda.co/eapi/v1/NFT/{contract_account_id}/{token_id}', headers = headers)

print(r.json())

```

</TabItem>

<TabItem value="PHP">

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
    'x-api-key' => 'API_KEY',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','https://near-testnet.api.pagoda.co/eapi/v1/NFT/{contract_account_id}/{token_id}', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

</TabItem>

<TabItem value="Java">

```java
URL obj = new URL("https://near-testnet.api.pagoda.co/eapi/v1/NFT/{contract_account_id}/{token_id}");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

</TabItem>

<TabItem value="Go">

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
        "x-api-key": []string{"API_KEY"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "https://near-testnet.api.pagoda.co/eapi/v1/NFT/{contract_account_id}/{token_id}", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

</TabItem>

</Tabs>

`GET /NFT/{contract_account_id}/{token_id}`

*Get NFT*

This endpoint returns detailed information on the NFT
 for the given `token_id`, NFT `contract_id`, `timestamp`/`block_height`.

<h3 id="get__nft_{contract_account_id}_{token_id}-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|contract_account_id|path|string|true|none|
|token_id|path|string|true|none|
|block_height|query|string|false|none|
|block_timestamp_nanos|query|string|false|none|

> Example responses

> 200 Response

```json
{
  "block_height": "string",
  "block_timestamp_nanos": "string",
  "contract_metadata": {
    "base_uri": "string",
    "icon": "string",
    "name": "string",
    "reference": "string",
    "reference_hash": "string",
    "spec": "string",
    "symbol": "string"
  },
  "nft": {
    "metadata": {
      "copies": 0,
      "description": "string",
      "extra": "string",
      "media": "string",
      "media_hash": "string",
      "reference": "string",
      "reference_hash": "string",
      "title": "string"
    },
    "owner_account_id": "string",
    "token_id": "string"
  }
}
```

<h3 id="get__nft_{contract_account_id}_{token_id}-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|OK|[NftResponse](#schemanftresponse)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|See the inner `code` value to get more details|None|

<aside class="warning">
To perform this operation, you must be authenticated by means of one of the following methods:
apiKey
</aside>

### Get NFT history

> Code samples

<Tabs>
<TabItem value="Shell">

```shell
# You can also use wget
curl -X GET https://near-testnet.api.pagoda.co/eapi/v1/NFT/{contract_account_id}/{token_id}/history \
  -H 'Accept: application/json' \
  -H 'x-api-key: API_KEY'

```

</TabItem>

<TabItem value="HTTP">

```http
GET https://near-testnet.api.pagoda.co/eapi/v1/NFT/{contract_account_id}/{token_id}/history HTTP/1.1
Host: near-testnet.api.pagoda.co
Accept: application/json

```

</TabItem>

<TabItem value="JS">

```javascript

const headers = {
  'Accept':'application/json',
  'x-api-key':'API_KEY'
};

fetch('https://near-testnet.api.pagoda.co/eapi/v1/NFT/{contract_account_id}/{token_id}/history',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

</TabItem>

<TabItem value="Ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json',
  'x-api-key' => 'API_KEY'
}

result = RestClient.get 'https://near-testnet.api.pagoda.co/eapi/v1/NFT/{contract_account_id}/{token_id}/history',
  params: {
  }, headers: headers

p JSON.parse(result)

```

</TabItem>

<TabItem value="Python">

```python
import requests
headers = {
  'Accept': 'application/json',
  'x-api-key': 'API_KEY'
}

r = requests.get('https://near-testnet.api.pagoda.co/eapi/v1/NFT/{contract_account_id}/{token_id}/history', headers = headers)

print(r.json())

```

</TabItem>

<TabItem value="PHP">

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
    'x-api-key' => 'API_KEY',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','https://near-testnet.api.pagoda.co/eapi/v1/NFT/{contract_account_id}/{token_id}/history', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

</TabItem>

<TabItem value="Java">

```java
URL obj = new URL("https://near-testnet.api.pagoda.co/eapi/v1/NFT/{contract_account_id}/{token_id}/history");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

</TabItem>

<TabItem value="Go">

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
        "x-api-key": []string{"API_KEY"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "https://near-testnet.api.pagoda.co/eapi/v1/NFT/{contract_account_id}/{token_id}/history", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

</TabItem>

</Tabs>

`GET /NFT/{contract_account_id}/{token_id}/history`

*Get NFT history*

This endpoint returns the transaction history for the given NFT and `timestamp`/`block_height`.
 **Note:** The result is centered around the history of the specific NFT and will return list of its passing owners and metadata.

 **Limitations**
 * For now, we only support NFT contracts that implement the Events NEP standard.
 * We currently provide the most recent 100 items.
   Full-featured pagination will be provided in later phases.

<h3 id="get__nft_{contract_account_id}_{token_id}_history-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|contract_account_id|path|string|true|none|
|token_id|path|string|true|none|
|limit|query|integer(int32)|false|none|

> Example responses

> 200 Response

```json
{
  "block_height": "string",
  "block_timestamp_nanos": "string",
  "history": [
    {
      "block_height": "string",
      "block_timestamp_nanos": "string",
      "cause": "string",
      "new_account_id": "string",
      "old_account_id": "string",
      "status": "string"
    }
  ],
  "nft": {
    "metadata": {
      "copies": 0,
      "description": "string",
      "extra": "string",
      "media": "string",
      "media_hash": "string",
      "reference": "string",
      "reference_hash": "string",
      "title": "string"
    },
    "owner_account_id": "string",
    "token_id": "string"
  }
}
```

<h3 id="get__nft_{contract_account_id}_{token_id}_history-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|OK|[HistoryResponse](#schemahistoryresponse)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|See the inner `code` value to get more details|None|

<aside class="warning">
To perform this operation, you must be authenticated by means of one of the following methods:
apiKey
</aside>

### Get user's NFT collection overview

> Code samples

<Tabs>
<TabItem value="Shell">

```shell
# You can also use wget
curl -X GET https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/NFT \
  -H 'Accept: application/json' \
  -H 'x-api-key: API_KEY'

```

</TabItem>

<TabItem value="HTTP">

```http
GET https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/NFT HTTP/1.1
Host: near-testnet.api.pagoda.co
Accept: application/json

```

</TabItem>

<TabItem value="JS">

```javascript

const headers = {
  'Accept':'application/json',
  'x-api-key':'API_KEY'
};

fetch('https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/NFT',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

</TabItem>

<TabItem value="Ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json',
  'x-api-key' => 'API_KEY'
}

result = RestClient.get 'https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/NFT',
  params: {
  }, headers: headers

p JSON.parse(result)

```

</TabItem>

<TabItem value="Python">

```python
import requests
headers = {
  'Accept': 'application/json',
  'x-api-key': 'API_KEY'
}

r = requests.get('https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/NFT', headers = headers)

print(r.json())

```

</TabItem>

<TabItem value="PHP">

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
    'x-api-key' => 'API_KEY',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/NFT', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

</TabItem>

<TabItem value="Java">

```java
URL obj = new URL("https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/NFT");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

</TabItem>

<TabItem value="Go">

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
        "x-api-key": []string{"API_KEY"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/NFT", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

</TabItem>

</Tabs>

`GET /accounts/{account_id}/NFT`

*Get user's NFT collection overview*

For the given `account_id` and `timestamp` or `block_height`, this endpoint returns
 the number of NFTs grouped by `contract_id`, together with the corresponding NFT contract metadata.
 The NFT contract will be present in the response if the `account_id` has at least one NFT there.

 **Note:** `block_timestamp_nanos` helps you choose a moment in time, fixing the blockchain state at that time.

 **Limitations**
 * We currently provide the most recent 100 items.
   Full-featured pagination will be provided in later phases.

<h3 id="get__accounts_{account_id}_nft-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|account_id|path|string|true|none|
|block_height|query|string|false|none|
|block_timestamp_nanos|query|string|false|none|
|limit|query|integer(int32)|false|Maximum available limit 100|

> Example responses

> 200 Response

```json
{
  "block_height": "string",
  "block_timestamp_nanos": "string",
  "nft_counts": [
    {
      "contract_account_id": "string",
      "contract_metadata": {
        "base_uri": "string",
        "icon": "string",
        "name": "string",
        "reference": "string",
        "reference_hash": "string",
        "spec": "string",
        "symbol": "string"
      },
      "last_updated_at_timestamp_nanos": "string",
      "nft_count": 0
    }
  ]
}
```

<h3 id="get__accounts_{account_id}_nft-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|OK|[NftCountsResponse](#schemanftcountsresponse)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|See the inner `code` value to get more details|None|

<aside class="warning">
To perform this operation, you must be authenticated by means of one of the following methods:
apiKey
</aside>

### Get user's NFT collection by contract

> Code samples

<Tabs>
<TabItem value="Shell">

```shell
# You can also use wget
curl -X GET https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/NFT/{contract_account_id} \
  -H 'Accept: application/json' \
  -H 'x-api-key: API_KEY'

```

</TabItem>

<TabItem value="HTTP">

```http
GET https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/NFT/{contract_account_id} HTTP/1.1
Host: near-testnet.api.pagoda.co
Accept: application/json

```

</TabItem>

<TabItem value="JS">

```javascript

const headers = {
  'Accept':'application/json',
  'x-api-key':'API_KEY'
};

fetch('https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/NFT/{contract_account_id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

</TabItem>

<TabItem value="Ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json',
  'x-api-key' => 'API_KEY'
}

result = RestClient.get 'https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/NFT/{contract_account_id}',
  params: {
  }, headers: headers

p JSON.parse(result)

```

</TabItem>

<TabItem value="Python">

```python
import requests
headers = {
  'Accept': 'application/json',
  'x-api-key': 'API_KEY'
}

r = requests.get('https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/NFT/{contract_account_id}', headers = headers)

print(r.json())

```

</TabItem>

<TabItem value="PHP">

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
    'x-api-key' => 'API_KEY',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/NFT/{contract_account_id}', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

</TabItem>

<TabItem value="Java">

```java
URL obj = new URL("https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/NFT/{contract_account_id}");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

</TabItem>

<TabItem value="Go">

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
        "x-api-key": []string{"API_KEY"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/NFT/{contract_account_id}", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

</TabItem>

</Tabs>

`GET /accounts/{account_id}/NFT/{contract_account_id}`

*Get user's NFT collection by contract*

This endpoint returns the list of NFTs with full details for the given `account_id`, NFT `contract_id`, `timestamp`/`block_height`.
 You can use the `token_id` from this response and then request the NFT history for that token.

 **Limitations**
 * We currently provide the most recent 100 items.
   Full-featured pagination will be provided in later phases.

<h3 id="get__accounts_{account_id}_nft_{contract_account_id}-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|account_id|path|string|true|none|
|contract_account_id|path|string|true|none|
|block_height|query|string|false|none|
|block_timestamp_nanos|query|string|false|none|
|limit|query|integer(int32)|false|Maximum available limit 100|

> Example responses

> 200 Response

```json
{
  "block_height": "string",
  "block_timestamp_nanos": "string",
  "contract_metadata": {
    "base_uri": "string",
    "icon": "string",
    "name": "string",
    "reference": "string",
    "reference_hash": "string",
    "spec": "string",
    "symbol": "string"
  },
  "nfts": [
    {
      "metadata": {
        "copies": 0,
        "description": "string",
        "extra": "string",
        "media": "string",
        "media_hash": "string",
        "reference": "string",
        "reference_hash": "string",
        "title": "string"
      },
      "owner_account_id": "string",
      "token_id": "string"
    }
  ]
}
```

<h3 id="get__accounts_{account_id}_nft_{contract_account_id}-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|OK|[NftsResponse](#schemanftsresponse)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|See the inner `code` value to get more details|None|

<aside class="warning">
To perform this operation, you must be authenticated by means of one of the following methods:
apiKey
</aside>

### Get NFT contract metadata

> Code samples

<Tabs>
<TabItem value="Shell">

```shell
# You can also use wget
curl -X GET https://near-testnet.api.pagoda.co/eapi/v1/nep171/metadata/{contract_account_id} \
  -H 'Accept: application/json' \
  -H 'x-api-key: API_KEY'

```

</TabItem>

<TabItem value="HTTP">

```http
GET https://near-testnet.api.pagoda.co/eapi/v1/nep171/metadata/{contract_account_id} HTTP/1.1
Host: near-testnet.api.pagoda.co
Accept: application/json

```

</TabItem>

<TabItem value="JS">

```javascript

const headers = {
  'Accept':'application/json',
  'x-api-key':'API_KEY'
};

fetch('https://near-testnet.api.pagoda.co/eapi/v1/nep171/metadata/{contract_account_id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

</TabItem>

<TabItem value="Ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json',
  'x-api-key' => 'API_KEY'
}

result = RestClient.get 'https://near-testnet.api.pagoda.co/eapi/v1/nep171/metadata/{contract_account_id}',
  params: {
  }, headers: headers

p JSON.parse(result)

```

</TabItem>

<TabItem value="Python">

```python
import requests
headers = {
  'Accept': 'application/json',
  'x-api-key': 'API_KEY'
}

r = requests.get('https://near-testnet.api.pagoda.co/eapi/v1/nep171/metadata/{contract_account_id}', headers = headers)

print(r.json())

```

</TabItem>

<TabItem value="PHP">

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
    'x-api-key' => 'API_KEY',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','https://near-testnet.api.pagoda.co/eapi/v1/nep171/metadata/{contract_account_id}', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

</TabItem>

<TabItem value="Java">

```java
URL obj = new URL("https://near-testnet.api.pagoda.co/eapi/v1/nep171/metadata/{contract_account_id}");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

</TabItem>

<TabItem value="Go">

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
        "x-api-key": []string{"API_KEY"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "https://near-testnet.api.pagoda.co/eapi/v1/nep171/metadata/{contract_account_id}", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

</TabItem>

</Tabs>

`GET /nep171/metadata/{contract_account_id}`

*Get NFT contract metadata*

This endpoint returns the metadata for a given NFT contract and `timestamp`/`block_height`.
 **Note:** This is contract-wide metadata. Each NFT also has its own metadata.

<h3 id="get__nep171_metadata_{contract_account_id}-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|contract_account_id|path|string|true|none|
|block_height|query|string|false|none|
|block_timestamp_nanos|query|string|false|none|

> Example responses

> 200 Response

```json
{
  "block_height": "string",
  "block_timestamp_nanos": "string",
  "metadata": {
    "base_uri": "string",
    "icon": "string",
    "name": "string",
    "reference": "string",
    "reference_hash": "string",
    "spec": "string",
    "symbol": "string"
  }
}
```

<h3 id="get__nep171_metadata_{contract_account_id}-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|OK|[MetadataResponse](#schemametadataresponse)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|See the inner `code` value to get more details|None|

<aside class="warning">
To perform this operation, you must be authenticated by means of one of the following methods:
apiKey
</aside>

---

## NEAR

### Get user's NEAR balance

> Code samples

<Tabs>
<TabItem value="Shell">

```shell
# You can also use wget
curl -X GET https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/NEAR \
  -H 'Accept: application/json' \
  -H 'x-api-key: API_KEY'

```

</TabItem>

<TabItem value="HTTP">

```http
GET https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/NEAR HTTP/1.1
Host: near-testnet.api.pagoda.co
Accept: application/json

```

</TabItem>

<TabItem value="JS">

```javascript

const headers = {
  'Accept':'application/json',
  'x-api-key':'API_KEY'
};

fetch('https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/NEAR',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

</TabItem>

<TabItem value="Ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json',
  'x-api-key' => 'API_KEY'
}

result = RestClient.get 'https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/NEAR',
  params: {
  }, headers: headers

p JSON.parse(result)

```

</TabItem>

<TabItem value="Python">

```python
import requests
headers = {
  'Accept': 'application/json',
  'x-api-key': 'API_KEY'
}

r = requests.get('https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/NEAR', headers = headers)

print(r.json())

```

</TabItem>

<TabItem value="PHP">

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
    'x-api-key' => 'API_KEY',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/NEAR', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

</TabItem>

<TabItem value="Java">

```java
URL obj = new URL("https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/NEAR");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

</TabItem>

<TabItem value="Go">

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
        "x-api-key": []string{"API_KEY"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/NEAR", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

</TabItem>

</Tabs>

`GET /accounts/{account_id}/coins/NEAR`

*Get user's NEAR balance*

This endpoint returns the NEAR balance of the given `account_id`
 at the given `timestamp`/`block_height`.

<h3 id="get__accounts_{account_id}_coins_near-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|account_id|path|string|true|none|
|block_height|query|string|false|none|
|block_timestamp_nanos|query|string|false|none|

> Example responses

> 200 Response

```json
{
  "balance": "string",
  "block_height": "string",
  "block_timestamp_nanos": "string",
  "metadata": {
    "decimals": 0,
    "icon": "string",
    "name": "string",
    "symbol": "string"
  }
}
```

<h3 id="get__accounts_{account_id}_coins_near-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|OK|[NearBalanceResponse](#schemanearbalanceresponse)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|See the inner `code` value to get more details|None|

<aside class="warning">
To perform this operation, you must be authenticated by means of one of the following methods:
apiKey
</aside>

### Get user's NEAR history

> Code samples

<Tabs>
<TabItem value="Shell">

```shell
# You can also use wget
curl -X GET https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/NEAR/history \
  -H 'Accept: application/json' \
  -H 'x-api-key: API_KEY'

```

</TabItem>

<TabItem value="HTTP">

```http
GET https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/NEAR/history HTTP/1.1
Host: near-testnet.api.pagoda.co
Accept: application/json

```

</TabItem>

<TabItem value="JS">

```javascript

const headers = {
  'Accept':'application/json',
  'x-api-key':'API_KEY'
};

fetch('https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/NEAR/history',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

</TabItem>

<TabItem value="Ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json',
  'x-api-key' => 'API_KEY'
}

result = RestClient.get 'https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/NEAR/history',
  params: {
  }, headers: headers

p JSON.parse(result)

```

</TabItem>

<TabItem value="Python">

```python
import requests
headers = {
  'Accept': 'application/json',
  'x-api-key': 'API_KEY'
}

r = requests.get('https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/NEAR/history', headers = headers)

print(r.json())

```

</TabItem>

<TabItem value="PHP">

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
    'x-api-key' => 'API_KEY',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/NEAR/history', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

</TabItem>

<TabItem value="Java">

```java
URL obj = new URL("https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/NEAR/history");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

</TabItem>

<TabItem value="Go">

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
        "x-api-key": []string{"API_KEY"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/NEAR/history", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

</TabItem>

</Tabs>

`GET /accounts/{account_id}/coins/NEAR/history`

*Get user's NEAR history*

This endpoint returns the history of operations with NEAR coins
 for the given `account_id`, `timestamp`/`block_height`.

 **Limitations**
 * We currently provide the most recent 100 items.
   Full-featured pagination will be provided in an upcoming update.

<h3 id="get__accounts_{account_id}_coins_near_history-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|account_id|path|string|true|none|
|limit|query|integer(int32)|false|none|

> Example responses

> 200 Response

```json
{
  "block_height": "string",
  "block_timestamp_nanos": "string",
  "history": [
    {
      "block_height": "string",
      "block_timestamp_nanos": "string",
      "cause": "string",
      "new_account_id": "string",
      "old_account_id": "string",
      "status": "string"
    }
  ],
  "nft": {
    "metadata": {
      "copies": 0,
      "description": "string",
      "extra": "string",
      "media": "string",
      "media_hash": "string",
      "reference": "string",
      "reference_hash": "string",
      "title": "string"
    },
    "owner_account_id": "string",
    "token_id": "string"
  }
}
```

<h3 id="get__accounts_{account_id}_coins_near_history-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|OK|[HistoryResponse](#schemahistoryresponse)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|See the inner `code` value to get more details|None|

<aside class="warning">
To perform this operation, you must be authenticated by means of one of the following methods:
apiKey
</aside>

---

## Fungible Tokens

### Get user's coin balances

> Code samples

<Tabs>
<TabItem value="Shell">

```shell
# You can also use wget
curl -X GET https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins \
  -H 'Accept: application/json' \
  -H 'x-api-key: API_KEY'

```

</TabItem>

<TabItem value="HTTP">

```http
GET https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins HTTP/1.1
Host: near-testnet.api.pagoda.co
Accept: application/json

```

</TabItem>

<TabItem value="JS">

```javascript

const headers = {
  'Accept':'application/json',
  'x-api-key':'API_KEY'
};

fetch('https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

</TabItem>

<TabItem value="Ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json',
  'x-api-key' => 'API_KEY'
}

result = RestClient.get 'https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins',
  params: {
  }, headers: headers

p JSON.parse(result)

```

</TabItem>

<TabItem value="Python">

```python
import requests
headers = {
  'Accept': 'application/json',
  'x-api-key': 'API_KEY'
}

r = requests.get('https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins', headers = headers)

print(r.json())

```

</TabItem>

<TabItem value="PHP">

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
    'x-api-key' => 'API_KEY',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

</TabItem>

<TabItem value="Java">

```java
URL obj = new URL("https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

</TabItem>

<TabItem value="Go">

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
        "x-api-key": []string{"API_KEY"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

</TabItem>

</Tabs>

`GET /accounts/{account_id}/coins`

*Get user's coin balances*

This endpoint returns all the countable coin balances (including NEAR, fungible tokens, and _multi-tokens_)
 of the given `account_id`, at the given `timestamp`/`block_height`.

 **Limitations**
 * For now, we only support the balance for NEAR and FT contracts that implement the Events NEP standard.
   We are working on a solution to support other FT contracts, including `wrap.near` and bridged tokens.
 * We are in the process of supporting Multi Token balances.
 * We currently provide the most recent 100 items.
   Full-featured pagination will be provided in an upcoming update.

<h3 id="get__accounts_{account_id}_coins-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|account_id|path|string|true|none|
|block_height|query|string|false|none|
|block_timestamp_nanos|query|string|false|none|
|limit|query|integer(int32)|false|Maximum available limit 100|

> Example responses

> 200 Response

```json
{
  "balances": [
    {
      "balance": "string",
      "contract_account_id": "string",
      "metadata": {
        "decimals": 0,
        "icon": "string",
        "name": "string",
        "symbol": "string"
      },
      "standard": "string"
    }
  ],
  "block_height": "string",
  "block_timestamp_nanos": "string"
}
```

<h3 id="get__accounts_{account_id}_coins-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|OK|[CoinBalancesResponse](#schemacoinbalancesresponse)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|See the inner `code` value to get more details|None|

<aside class="warning">
To perform this operation, you must be authenticated by means of one of the following methods:
apiKey
</aside>

### Get user's coin balances by contract

> Code samples

<Tabs>
<TabItem value="Shell">

```shell
# You can also use wget
curl -X GET https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/{contract_account_id} \
  -H 'Accept: application/json' \
  -H 'x-api-key: API_KEY'

```

</TabItem>

<TabItem value="HTTP">

```http
GET https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/{contract_account_id} HTTP/1.1
Host: near-testnet.api.pagoda.co
Accept: application/json

```

</TabItem>

<TabItem value="JS">

```javascript

const headers = {
  'Accept':'application/json',
  'x-api-key':'API_KEY'
};

fetch('https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/{contract_account_id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

</TabItem>

<TabItem value="Ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json',
  'x-api-key' => 'API_KEY'
}

result = RestClient.get 'https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/{contract_account_id}',
  params: {
  }, headers: headers

p JSON.parse(result)

```

</TabItem>

<TabItem value="Python">

```python
import requests
headers = {
  'Accept': 'application/json',
  'x-api-key': 'API_KEY'
}

r = requests.get('https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/{contract_account_id}', headers = headers)

print(r.json())

```

</TabItem>

<TabItem value="PHP">

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
    'x-api-key' => 'API_KEY',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/{contract_account_id}', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

</TabItem>

<TabItem value="Java">

```java
URL obj = new URL("https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/{contract_account_id}");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

</TabItem>

<TabItem value="Go">

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
        "x-api-key": []string{"API_KEY"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/{contract_account_id}", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

</TabItem>

</Tabs>

`GET /accounts/{account_id}/coins/{contract_account_id}`

*Get user's coin balances by contract*

This endpoint returns all the countable coin balances of the given `account_id`,
 for the given contract and `timestamp`/`block_height`.
 For FT contracts, the response has only 1 item in the list.
 For MT contracts, there could be several balances (MT support is still under development).

 **Limitations**
 * For now, we support only the balance for FT contracts that implement the Events NEP standard.
   We are working on a solution to support other FT contracts, including `wrap.near` and bridged tokens.
 * We are in the process of supporting Multi Token balances.

<h3 id="get__accounts_{account_id}_coins_{contract_account_id}-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|account_id|path|string|true|none|
|contract_account_id|path|string|true|none|
|block_height|query|string|false|none|
|block_timestamp_nanos|query|string|false|none|

> Example responses

> 200 Response

```json
{
  "balances": [
    {
      "balance": "string",
      "contract_account_id": "string",
      "metadata": {
        "decimals": 0,
        "icon": "string",
        "name": "string",
        "symbol": "string"
      },
      "standard": "string"
    }
  ],
  "block_height": "string",
  "block_timestamp_nanos": "string"
}
```

<h3 id="get__accounts_{account_id}_coins_{contract_account_id}-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|OK|[CoinBalancesResponse](#schemacoinbalancesresponse)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|See the inner `code` value to get more details|None|

<aside class="warning">
To perform this operation, you must be authenticated by means of one of the following methods:
apiKey
</aside>

### Get user's coin history by contract

> Code samples

<Tabs>
<TabItem value="Shell">

```shell
# You can also use wget
curl -X GET https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/{contract_account_id}/history \
  -H 'Accept: application/json' \
  -H 'x-api-key: API_KEY'

```

</TabItem>

<TabItem value="HTTP">

```http
GET https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/{contract_account_id}/history HTTP/1.1
Host: near-testnet.api.pagoda.co
Accept: application/json

```

</TabItem>

<TabItem value="JS">

```javascript

const headers = {
  'Accept':'application/json',
  'x-api-key':'API_KEY'
};

fetch('https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/{contract_account_id}/history',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

</TabItem>

<TabItem value="Ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json',
  'x-api-key' => 'API_KEY'
}

result = RestClient.get 'https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/{contract_account_id}/history',
  params: {
  }, headers: headers

p JSON.parse(result)

```

</TabItem>

<TabItem value="Python">

```python
import requests
headers = {
  'Accept': 'application/json',
  'x-api-key': 'API_KEY'
}

r = requests.get('https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/{contract_account_id}/history', headers = headers)

print(r.json())

```

</TabItem>

<TabItem value="PHP">

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
    'x-api-key' => 'API_KEY',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/{contract_account_id}/history', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

</TabItem>

<TabItem value="Java">

```java
URL obj = new URL("https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/{contract_account_id}/history");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

</TabItem>

<TabItem value="Go">

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
        "x-api-key": []string{"API_KEY"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "https://near-testnet.api.pagoda.co/eapi/v1/accounts/{account_id}/coins/{contract_account_id}/history", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

</TabItem>

</Tabs>

`GET /accounts/{account_id}/coins/{contract_account_id}/history`

*Get user's coin history by contract*

This endpoint returns the history of coin operations (FT, other standards)
 for the given `account_id`, `contract_id`, `timestamp`/`block_height`.

 **Limitations**
 * For now, we support only FT contracts that implement the Events NEP standard.
   We are working on a solution to support other FT contracts, including `wrap.near` and bridged tokens.
 * We are in the process of supporting Multi Token history.
 * We currently provide the most recent 100 items.
   Full-featured pagination will be provided in an upcoming update.

<h3 id="get__accounts_{account_id}_coins_{contract_account_id}_history-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|account_id|path|string|true|none|
|contract_account_id|path|string|true|none|
|limit|query|integer(int32)|false|none|

> Example responses

> 200 Response

```json
{
  "block_height": "string",
  "block_timestamp_nanos": "string",
  "history": [
    {
      "block_height": "string",
      "block_timestamp_nanos": "string",
      "cause": "string",
      "new_account_id": "string",
      "old_account_id": "string",
      "status": "string"
    }
  ],
  "nft": {
    "metadata": {
      "copies": 0,
      "description": "string",
      "extra": "string",
      "media": "string",
      "media_hash": "string",
      "reference": "string",
      "reference_hash": "string",
      "title": "string"
    },
    "owner_account_id": "string",
    "token_id": "string"
  }
}
```

<h3 id="get__accounts_{account_id}_coins_{contract_account_id}_history-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|OK|[HistoryResponse](#schemahistoryresponse)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|See the inner `code` value to get more details|None|

<aside class="warning">
To perform this operation, you must be authenticated by means of one of the following methods:
apiKey
</aside>

### Get FT contract metadata

> Code samples

<Tabs>
<TabItem value="Shell">

```shell
# You can also use wget
curl -X GET https://near-testnet.api.pagoda.co/eapi/v1/nep141/metadata/{contract_account_id} \
  -H 'Accept: application/json' \
  -H 'x-api-key: API_KEY'

```

</TabItem>

<TabItem value="HTTP">

```http
GET https://near-testnet.api.pagoda.co/eapi/v1/nep141/metadata/{contract_account_id} HTTP/1.1
Host: near-testnet.api.pagoda.co
Accept: application/json

```

</TabItem>

<TabItem value="JS">

```javascript

const headers = {
  'Accept':'application/json',
  'x-api-key':'API_KEY'
};

fetch('https://near-testnet.api.pagoda.co/eapi/v1/nep141/metadata/{contract_account_id}',
{
  method: 'GET',

  headers: headers
})
.then(function(res) {
    return res.json();
}).then(function(body) {
    console.log(body);
});

```

</TabItem>

<TabItem value="Ruby">

```ruby
require 'rest-client'
require 'json'

headers = {
  'Accept' => 'application/json',
  'x-api-key' => 'API_KEY'
}

result = RestClient.get 'https://near-testnet.api.pagoda.co/eapi/v1/nep141/metadata/{contract_account_id}',
  params: {
  }, headers: headers

p JSON.parse(result)

```

</TabItem>

<TabItem value="Python">

```python
import requests
headers = {
  'Accept': 'application/json',
  'x-api-key': 'API_KEY'
}

r = requests.get('https://near-testnet.api.pagoda.co/eapi/v1/nep141/metadata/{contract_account_id}', headers = headers)

print(r.json())

```

</TabItem>

<TabItem value="PHP">

```php
<?php

require 'vendor/autoload.php';

$headers = array(
    'Accept' => 'application/json',
    'x-api-key' => 'API_KEY',
);

$client = new \GuzzleHttp\Client();

// Define array of request body.
$request_body = array();

try {
    $response = $client->request('GET','https://near-testnet.api.pagoda.co/eapi/v1/nep141/metadata/{contract_account_id}', array(
        'headers' => $headers,
        'json' => $request_body,
       )
    );
    print_r($response->getBody()->getContents());
 }
 catch (\GuzzleHttp\Exception\BadResponseException $e) {
    // handle exception or api errors.
    print_r($e->getMessage());
 }

 // ...

```

</TabItem>

<TabItem value="Java">

```java
URL obj = new URL("https://near-testnet.api.pagoda.co/eapi/v1/nep141/metadata/{contract_account_id}");
HttpURLConnection con = (HttpURLConnection) obj.openConnection();
con.setRequestMethod("GET");
int responseCode = con.getResponseCode();
BufferedReader in = new BufferedReader(
    new InputStreamReader(con.getInputStream()));
String inputLine;
StringBuffer response = new StringBuffer();
while ((inputLine = in.readLine()) != null) {
    response.append(inputLine);
}
in.close();
System.out.println(response.toString());

```

</TabItem>

<TabItem value="Go">

```go
package main

import (
       "bytes"
       "net/http"
)

func main() {

    headers := map[string][]string{
        "Accept": []string{"application/json"},
        "x-api-key": []string{"API_KEY"},
    }

    data := bytes.NewBuffer([]byte{jsonReq})
    req, err := http.NewRequest("GET", "https://near-testnet.api.pagoda.co/eapi/v1/nep141/metadata/{contract_account_id}", data)
    req.Header = headers

    client := &http.Client{}
    resp, err := client.Do(req)
    // ...
}

```

</TabItem>

</Tabs>

`GET /nep141/metadata/{contract_account_id}`

*Get FT contract metadata*

This endpoint returns the metadata for a given FT contract and `timestamp`/`block_height`.

 **Limitations**
 * For now, we support only FT contracts that implement the Events NEP standard.
   We are working on a solution to support other FT contracts, including `wrap.near` and bridged tokens.

<h3 id="get__nep141_metadata_{contract_account_id}-parameters">Parameters</h3>

|Name|In|Type|Required|Description|
|---|---|---|---|---|
|contract_account_id|path|string|true|none|
|block_height|query|string|false|none|
|block_timestamp_nanos|query|string|false|none|

> Example responses

> 200 Response

```json
{
  "block_height": "string",
  "block_timestamp_nanos": "string",
  "metadata": {
    "decimals": 0,
    "icon": "string",
    "name": "string",
    "reference": "string",
    "reference_hash": "string",
    "spec": "string",
    "symbol": "string"
  }
}
```

<h3 id="get__nep141_metadata_{contract_account_id}-responses">Responses</h3>

|Status|Meaning|Description|Schema|
|---|---|---|---|
|200|[OK](https://tools.ietf.org/html/rfc7231#section-6.3.1)|OK|[FtContractMetadataResponse](#schemaftcontractmetadataresponse)|
|500|[Internal Server Error](https://tools.ietf.org/html/rfc7231#section-6.6.1)|See the inner `code` value to get more details|None|

<aside class="warning">
To perform this operation, you must be authenticated by means of one of the following methods:
apiKey
</aside>

---

## Schemas

### CoinBalancesResponse
<!-- backwards compatibility -->
<a id="schemacoinbalancesresponse"></a>
<a id="schema_CoinBalancesResponse"></a>
<a id="tocScoinbalancesresponse"></a>
<a id="tocscoinbalancesresponse"></a>

```json
{
  "balances": [
    {
      "balance": "string",
      "contract_account_id": "string",
      "metadata": {
        "decimals": 0,
        "icon": "string",
        "name": "string",
        "symbol": "string"
      },
      "standard": "string"
    }
  ],
  "block_height": "string",
  "block_timestamp_nanos": "string"
}

```

This response gives the information about all the available balances for the user.
 The answer gives the list of NEAR, FT balances, could be used for Multi Tokens.
 For MTs and other standards, balances could have multiple entries for one contract.

##### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|balances|[object]|true|none|none|
|¬ª balance|string|true|none|none|
|¬ª contract_account_id|string|false|none|null for NEAR, not null otherwise|
|¬ª metadata|object|true|none|This type describes general Metadata info, collecting the most important fields from different standards in the one format.<br /> `decimals` may contain `0` if it's not applicable (e.g. if it's general MT metadata)|
|¬ª¬ª decimals|integer(int32)|true|none|none|
|¬ª¬ª icon|string|false|none|none|
|¬ª¬ª name|string|true|none|none|
|¬ª¬ª symbol|string|true|none|none|
|¬ª standard|string|true|none|"nearprotocol" for NEAR, "nep141" for FT|
|block_height|string|true|none|none|
|block_timestamp_nanos|string|true|none|none|

### FtContractMetadataResponse
<!-- backwards compatibility -->
<a id="schemaftcontractmetadataresponse"></a>
<a id="schema_FtContractMetadataResponse"></a>
<a id="tocSftcontractmetadataresponse"></a>
<a id="tocsftcontractmetadataresponse"></a>

```json
{
  "block_height": "string",
  "block_timestamp_nanos": "string",
  "metadata": {
    "decimals": 0,
    "icon": "string",
    "name": "string",
    "reference": "string",
    "reference_hash": "string",
    "spec": "string",
    "symbol": "string"
  }
}

```

##### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|block_height|string|true|none|none|
|block_timestamp_nanos|string|true|none|none|
|metadata|object|true|none|The type for FT Contract Metadata. Inspired by<br /> https://nomicon.io/Standards/Tokens/FungibleToken/Metadata|
|¬ª decimals|integer(int32)|true|none|none|
|¬ª icon|string|false|none|none|
|¬ª name|string|true|none|none|
|¬ª reference|string|false|none|none|
|¬ª reference_hash|string|false|none|none|
|¬ª spec|string|true|none|none|
|¬ª symbol|string|true|none|none|

### HistoryResponse
<!-- backwards compatibility -->
<a id="schemahistoryresponse"></a>
<a id="schema_HistoryResponse"></a>
<a id="tocShistoryresponse"></a>
<a id="tocshistoryresponse"></a>

```json
{
  "block_height": "string",
  "block_timestamp_nanos": "string",
  "history": [
    {
      "block_height": "string",
      "block_timestamp_nanos": "string",
      "cause": "string",
      "new_account_id": "string",
      "old_account_id": "string",
      "status": "string"
    }
  ],
  "nft": {
    "metadata": {
      "copies": 0,
      "description": "string",
      "extra": "string",
      "media": "string",
      "media_hash": "string",
      "reference": "string",
      "reference_hash": "string",
      "title": "string"
    },
    "owner_account_id": "string",
    "token_id": "string"
  }
}

```

##### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|block_height|string|true|none|none|
|block_timestamp_nanos|string|true|none|none|
|history|[object]|true|none|none|
|¬ª block_height|string|true|none|none|
|¬ª block_timestamp_nanos|string|true|none|none|
|¬ª cause|string|true|none|none|
|¬ª new_account_id|string|false|none|none|
|¬ª old_account_id|string|false|none|none|
|¬ª status|string|true|none|none|
|nft|object|true|none|The type for Non Fungible Token. Inspired by<br /> https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata|
|¬ª metadata|object|true|none|The type for Non Fungible Token Metadata. Inspired by<br /> https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata|
|¬ª¬ª copies|integer(int64)|false|none|none|
|¬ª¬ª description|string|false|none|none|
|¬ª¬ª extra|string|false|none|none|
|¬ª¬ª media|string|false|none|none|
|¬ª¬ª media_hash|string|false|none|none|
|¬ª¬ª reference|string|false|none|none|
|¬ª¬ª reference_hash|string|false|none|none|
|¬ª¬ª title|string|false|none|none|
|¬ª owner_account_id|string|true|none|none|
|¬ª token_id|string|true|none|none|

### MetadataResponse
<!-- backwards compatibility -->
<a id="schemametadataresponse"></a>
<a id="schema_MetadataResponse"></a>
<a id="tocSmetadataresponse"></a>
<a id="tocsmetadataresponse"></a>

```json
{
  "block_height": "string",
  "block_timestamp_nanos": "string",
  "metadata": {
    "base_uri": "string",
    "icon": "string",
    "name": "string",
    "reference": "string",
    "reference_hash": "string",
    "spec": "string",
    "symbol": "string"
  }
}

```

##### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|block_height|string|true|none|none|
|block_timestamp_nanos|string|true|none|none|
|metadata|object|true|none|The type for Non Fungible Token Contract Metadata. Inspired by<br /> https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata|
|¬ª base_uri|string|false|none|none|
|¬ª icon|string|false|none|none|
|¬ª name|string|true|none|none|
|¬ª reference|string|false|none|none|
|¬ª reference_hash|string|false|none|none|
|¬ª spec|string|true|none|none|
|¬ª symbol|string|true|none|none|

### NearBalanceResponse
<!-- backwards compatibility -->
<a id="schemanearbalanceresponse"></a>
<a id="schema_NearBalanceResponse"></a>
<a id="tocSnearbalanceresponse"></a>
<a id="tocsnearbalanceresponse"></a>

```json
{
  "balance": "string",
  "block_height": "string",
  "block_timestamp_nanos": "string",
  "metadata": {
    "decimals": 0,
    "icon": "string",
    "name": "string",
    "symbol": "string"
  }
}

```

##### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|balance|string|true|none|Sum of staked and nonstaked balances|
|block_height|string|true|none|none|
|block_timestamp_nanos|string|true|none|none|
|metadata|object|true|none|This type describes general Metadata info, collecting the most important fields from different standards in the one format.<br /> `decimals` may contain `0` if it's not applicable (e.g. if it's general MT metadata)|
|¬ª decimals|integer(int32)|true|none|none|
|¬ª icon|string|false|none|none|
|¬ª name|string|true|none|none|
|¬ª symbol|string|true|none|none|

### NftCountsResponse
<!-- backwards compatibility -->
<a id="schemanftcountsresponse"></a>
<a id="schema_NftCountsResponse"></a>
<a id="tocSnftcountsresponse"></a>
<a id="tocsnftcountsresponse"></a>

```json
{
  "block_height": "string",
  "block_timestamp_nanos": "string",
  "nft_counts": [
    {
      "contract_account_id": "string",
      "contract_metadata": {
        "base_uri": "string",
        "icon": "string",
        "name": "string",
        "reference": "string",
        "reference_hash": "string",
        "spec": "string",
        "symbol": "string"
      },
      "last_updated_at_timestamp_nanos": "string",
      "nft_count": 0
    }
  ]
}

```

##### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|block_height|string|true|none|none|
|block_timestamp_nanos|string|true|none|none|
|nft_counts|[object]|true|none|none|
|¬ª contract_account_id|string|true|none|none|
|¬ª contract_metadata|object|true|none|The type for Non Fungible Token Contract Metadata. Inspired by<br /> https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata|
|¬ª¬ª base_uri|string|false|none|none|
|¬ª¬ª icon|string|false|none|none|
|¬ª¬ª name|string|true|none|none|
|¬ª¬ª reference|string|false|none|none|
|¬ª¬ª reference_hash|string|false|none|none|
|¬ª¬ª spec|string|true|none|none|
|¬ª¬ª symbol|string|true|none|none|
|¬ª last_updated_at_timestamp_nanos|string|true|none|none|
|¬ª nft_count|integer(int32)|true|none|none|

### NftResponse
<!-- backwards compatibility -->
<a id="schemanftresponse"></a>
<a id="schema_NftResponse"></a>
<a id="tocSnftresponse"></a>
<a id="tocsnftresponse"></a>

```json
{
  "block_height": "string",
  "block_timestamp_nanos": "string",
  "contract_metadata": {
    "base_uri": "string",
    "icon": "string",
    "name": "string",
    "reference": "string",
    "reference_hash": "string",
    "spec": "string",
    "symbol": "string"
  },
  "nft": {
    "metadata": {
      "copies": 0,
      "description": "string",
      "extra": "string",
      "media": "string",
      "media_hash": "string",
      "reference": "string",
      "reference_hash": "string",
      "title": "string"
    },
    "owner_account_id": "string",
    "token_id": "string"
  }
}

```

##### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|block_height|string|true|none|none|
|block_timestamp_nanos|string|true|none|none|
|contract_metadata|object|true|none|The type for Non Fungible Token Contract Metadata. Inspired by<br /> https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata|
|¬ª base_uri|string|false|none|none|
|¬ª icon|string|false|none|none|
|¬ª name|string|true|none|none|
|¬ª reference|string|false|none|none|
|¬ª reference_hash|string|false|none|none|
|¬ª spec|string|true|none|none|
|¬ª symbol|string|true|none|none|
|nft|object|true|none|The type for Non Fungible Token. Inspired by<br /> https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata|
|¬ª metadata|object|true|none|The type for Non Fungible Token Metadata. Inspired by<br /> https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata|
|¬ª¬ª copies|integer(int64)|false|none|none|
|¬ª¬ª description|string|false|none|none|
|¬ª¬ª extra|string|false|none|none|
|¬ª¬ª media|string|false|none|none|
|¬ª¬ª media_hash|string|false|none|none|
|¬ª¬ª reference|string|false|none|none|
|¬ª¬ª reference_hash|string|false|none|none|
|¬ª¬ª title|string|false|none|none|
|¬ª owner_account_id|string|true|none|none|
|¬ª token_id|string|true|none|none|

### NftsResponse
<!-- backwards compatibility -->
<a id="schemanftsresponse"></a>
<a id="schema_NftsResponse"></a>
<a id="tocSnftsresponse"></a>
<a id="tocsnftsresponse"></a>

```json
{
  "block_height": "string",
  "block_timestamp_nanos": "string",
  "contract_metadata": {
    "base_uri": "string",
    "icon": "string",
    "name": "string",
    "reference": "string",
    "reference_hash": "string",
    "spec": "string",
    "symbol": "string"
  },
  "nfts": [
    {
      "metadata": {
        "copies": 0,
        "description": "string",
        "extra": "string",
        "media": "string",
        "media_hash": "string",
        "reference": "string",
        "reference_hash": "string",
        "title": "string"
      },
      "owner_account_id": "string",
      "token_id": "string"
    }
  ]
}

```

##### Properties

|Name|Type|Required|Restrictions|Description|
|---|---|---|---|---|
|block_height|string|true|none|none|
|block_timestamp_nanos|string|true|none|none|
|contract_metadata|object|true|none|The type for Non Fungible Token Contract Metadata. Inspired by<br /> https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata|
|¬ª base_uri|string|false|none|none|
|¬ª icon|string|false|none|none|
|¬ª name|string|true|none|none|
|¬ª reference|string|false|none|none|
|¬ª reference_hash|string|false|none|none|
|¬ª spec|string|true|none|none|
|¬ª symbol|string|true|none|none|
|nfts|[object]|true|none|none|
|¬ª metadata|object|true|none|The type for Non Fungible Token Metadata. Inspired by<br /> https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata|
|¬ª¬ª copies|integer(int64)|false|none|none|
|¬ª¬ª description|string|false|none|none|
|¬ª¬ª extra|string|false|none|none|
|¬ª¬ª media|string|false|none|none|
|¬ª¬ª media_hash|string|false|none|none|
|¬ª¬ª reference|string|false|none|none|
|¬ª¬ª reference_hash|string|false|none|none|
|¬ª¬ª title|string|false|none|none|
|¬ª owner_account_id|string|true|none|none|
|¬ª token_id|string|true|none|none|

'''
'''--- docs/pagoda/rpc/get-keys.md ---
---
sidebar_position: 3
sidebar_label: Get API Keys 
title: Get Pagoda API Keys
---

:::warning

Please be advised that these tools and services will be discontinued soon.

:::

1. Register an account on [Pagoda Console](https://console.pagoda.co/):

   ![](/docs/pagoda/getkey1.png)

2. Create a blank project

   ![](/docs/pagoda/getkey2.png)

3. Give your project a cool name

   ![](/docs/pagoda/getkey3.png)

4. Grab your API Key

   Click the API Tab and you will see your API key already generated for you and ready to use, remember to switch networks for `MainNet` using the button on top, you can also navigate through your different projects there.

   ![](/docs/pagoda/getkey4.png)

5. Connect to Pagoda RPC Node

   Follow the instructions on the screen to set up your Pagoda RPC Access, we have created a quick setup guide for all NEAR tools.
   - `https://near-testnet.api.pagoda.co/rpc/v1/`
   - `https://near-mainnet.api.pagoda.co/rpc/v1/`

   ![](/docs/pagoda/getkey5.png)

6. You can use this line of code for a quick test

   ```sh
   curl -X POST -H 'x-api-key:<YOUR-API-KEY>' -H 'Content-Type: application/json' -d '{"jsonrpc": "2.0", "id":"dontcare","method":"status","params":[] }' https://near-testnet.api.pagoda.co/rpc/v1/
   ```

   ![](/docs/pagoda/getkey6.png)

Congrats! You are connected!

'''
'''--- docs/pagoda/rpc/intro.md ---
---
sidebar_position: 1
sidebar_label: Introduction
title: Pagoda RPC API
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::warning

Please be advised that these tools and services will be discontinued soon.

:::

## Overview

The Pagoda RPC provides you with instant access to maintenance free, scalable NEAR infrastructure, powering you on the fastest path from ideas to launch.

Developers can interact with on-chain data and send different types of transactions to the network by utilizing the RPC endpoints.

In addition to the powerful node infrastructure, we also created the Pagoda RPC Stats page so that you can have visibility into your RPC usage and performances and take control of your project from the infrastructure level. What‚Äôs more? You can subscribe to the alerts from our Status page so that you can follow the health of Pagoda RPC real time. All accesible via [Pagoda Console](https://console.pagoda.co/).

## Setup

### API Keys

- [Getting API keys](get-keys.md)
- [Testing your API keys](setup.md#test-your-api-keys)

### Tools

- [Postman](setup.md#postman-setup) setup
- [Command-line (CLI)](setup.md#command-line-setup) setup
- [JavaScript](setup.md#javascript-setup) setup
- [Rust](setup.md#rust-setup) setup

---

## RPC Endpoints - Quick Links

| API                                        | Description                                                                  |
| ------------------------------------------ | ---------------------------------------------------------------------------- |
| [Access Keys](/api/rpc/access-keys)        | Retrieve information about an account's access keys.                         |
| [Accounts / Contracts](/api/rpc/contracts) | View details about accounts and contracts as well as perform contract calls. |
| [Block / Chunk](/api/rpc/block-chunk)      | Query the network and get details about specific blocks or chunks.           |
| [Gas](/api/rpc/gas)                        | Get gas price for a specific block or hash.                                  |
| [Protocol](/api/rpc/protocol)              | Retrieve current genesis and protocol configuration.                         |
| [Network](/api/rpc/network)                | Return status information for nodes and validators.                          |
| [Transactions](/api/rpc/transactions)      | Send transactions and query their status.                                    |

:::tip

You can access the JSON RPC 2.0 endpoints using [Postman](setup.md#postman-setup),
[JavaScript](setup.md#javascript-setup), [Rust](setup.md#rust-setup), and [CLI](setup.md#command-line-setup).

:::

'''
'''--- docs/pagoda/rpc/setup.md ---
---
sidebar_position: 3
sidebar_label: Setup
title: RPC Setup
---

:::warning

Please be advised that these tools and services will be discontinued soon.

:::

In order to use the RPC API you will need to setup the correct RPC endpoints:

- `POST` for all RPC methods
- `JSON RPC 2.0`
- `id: "dontcare"`
- Endpoint URL varies by network
  -  testnet: `https://near-testnet.api.pagoda.co/rpc/v1/`
  -  mainnet: `https://near-mainnet.api.pagoda.co/rpc/v1/`

:::note

We are working on supporting historical data access in the next phase.

:::

## API Keys

When accessing the NEAR network via a node provider, API services like Pagoda require an API key, which allows developers to monitor personal apps and access usage metrics.

:::tip
For the best development experience, we recommend that you [sign up for a free API key](get-keys.md).
:::

With a dedicated API key, developers are able to:

-    Access higher request throughput and increased concurrent requests
-    Query data from [Enhanced APIs](api.md), gaining access to free processed data for NFT, FT and NEAR balances, ownership, and metadata
-    Utlize dedicated, individualized usage metrics

### Test your API keys

To quickly test your API keys and connection, try a simple request from your command line:

```sh
curl -X POST -H 'x-api-key:<YOUR-API-KEY>' -H 'Content-Type: application/json' -d '{"jsonrpc": "2.0", "id":"dontcare","method":"status","params":[] }' https://near-testnet.api.pagoda.co/rpc/v1/
```

## Postman Setup

An easy way to test the queries in this documentation page is to use an API request tool such as [Postman](https://www.postman.com/).
You only need to configure two things:

1. Make sure you add a header with a key of `Content-Type` and value of `application/json`.
   ![postman-setup-header](/docs/assets/postman-setup-headers.png)

2. Then select the `Body` tab and choose the `raw` radio button and ensure `JSON` is the selected format.
   ![postman-setup-header](/docs/assets/postman-setup-body.png)

After that is set up, just copy/paste the `JSON object` example snippets below into the `body` of your request, on Postman, and click `send`.

## Command-line Setup

### NEAR CLI

1. If you don‚Äôt yet have `near-cli` installed on your machine, follow the [near-cli installation instructions](https://docs.near.org/tools/near-cli#setup).
2. Set your RPC URL:
   ```
   export NEAR_CLI_TESTNET_RPC_SERVER_URL=https://near-testnet.api.pagoda.co/rpc/v1/
   ```
3. Configure your API key:
   ```
   near set-api-key $NEAR_CLI_TESTNET_RPC_SERVER_URL <your API Key>
   ```

### HTTPie Setup {#httpie-setup}

If you prefer to use a command line interface, we have provided RPC examples you can use with [HTTPie](https://httpie.org/). 
Please note that params take either an object or array passed as a string.

```bash
http post https://near-testnet.api.pagoda.co/rpc/v1/ jsonrpc=2.0 id=dontcare method=network_info params:='[]'
```

## JavaScript Setup

All of the queries listed in this documentation page can be called using [`near-api-js`](https://github.com/near/near-api-js).

:::tip
For `near-api-js` installation and setup please refer to `near-api-js` [quick reference documentation](https://docs.near.org/tools/near-api-js/quick-reference#install).
:::

Add the following code to get started:

```js
const { connect, keyStores } = require("near-api-js");

// Can be an empty object if not signing transactions

const keyStore = new keyStores.BrowserLocalStorageKeyStore();

const RPC_API_ENDPOINT = 'https://near-testnet.api.pagoda.co/rpc/v1/';
const API_KEY = '<YOUR-API-KEY>';

const ACCOUNT_ID = 'account.near';

const config = {
    networkId: 'testnet',
    keyStore,
    nodeUrl: RPC_API_ENDPOINT,
    headers: { 'x-api-key': API_KEY },
};

// Example: Fetching account status

async function getState(accountId) {
    const near = await connect(config);
    const account = await near.account(accountId);
    const state = await account.state();
    console.log(state);
}

getState(ACCOUNT_ID);
```

:::info
All JavaScript code snippets require a `near` object. For examples of how to instantiate, [click here](https://docs.near.org/tools/near-api-js/quick-reference#connect).
:::

## Rust Setup

You can use the [near-jsonrpc-client-rs](https://github.com/near/near-jsonrpc-client-rs) library to communicate with the Pagoda RPC endpoints via JSONRPC.

Example of asynchronously fetching the latest block using `tokio`:

```rust
use near_jsonrpc_client::{auth, methods, JsonRpcClient};
use near_primitives::types::{BlockReference, Finality};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = JsonRpcClient::connect("https://near-testnet.api.pagoda.co/rpc/v1/")
        .header(auth::ApiKey::new("<YOUR-API-KEY>")?);

    let request = methods::block::RpcBlockRequest {
        block_reference: BlockReference::Finality(Finality::Final),
    };

    let response = client.call(request).await?;

    println!("{:?}", response);

    Ok(())
}
```

---

## Using `block_id` param {#using-block_id-param}

The `block_id` param can take either the block number (e.g. `27912554`) or the block hash (e.g. `'3Xz2wM9rigMXzA2c5vgCP8wTgFBaePucgUmVYPkMqhRL'` ) as an argument.

:::caution
The block IDs of transactions shown in [NEAR Explorer](https://explorer.testnet.near.org) are not necessarily the block ID of the executed transaction. Transactions may execute a block or two after its recorded, and in some cases, can take place over several blocks. Due to this, it is important to to check subsequent blocks to be sure all results related to the queried transaction are discovered.
:::

---

## Using `finality` param {#using-finality-param}

The `finality` param has two options: `optimistic` and `final`.
1. `optimistic` uses the latest block recorded on the node that responded to your query _(&lt;1 second delay after the transaction is submitted)_
2. `final` is for a block that has been validated on at least 66% of the nodes in the network _(usually takes 2 blocks / approx. 2 second delay)_

'''
'''--- docs/pagoda/rpc/stats.md ---
---
sidebar_position: 3
sidebar_label: Statistics Dashboard 
title: RPC Statistics
---

:::warning

Please be advised that these tools and services will be discontinued soon.

:::

Inspect your RPC Usage in the [Statistics Tab](https://console.pagoda.co/apis?tab=statistics):

![](/docs/pagoda/stats1.png)

:::info
Data defaults to the last 30 days.
Currently the statistics page show the usage data across all projects and API keys within an organization set on Pagoda Console.
:::

Aggregated key metrics available at the top of the dashboard are

-    Total Request Volume
-    Request Success Rate
-    Total failed request
-    Average Latency

## Set a Time Period

Data is sent with UTC time to the browser and the browser adjusts to the user‚Äôs timezon.

-    Last 15 Minutes is the last complete 15 minutes. This updates every few seconds.
-    Last 1 Hour is the last fully completed hour; from 00 to 59 minutes and 59 seconds.
-    Last 24 Hours is the last fully completed 24 consecutive hours.
-    Last 7 Days is the previous 7 days from the current time. Each data point groups one hour‚Äôs worth of data. The most recent hour is partial data for the current hour and updates every few seconds.
-    Last 30 Days is the previous 30 days from the current time. Each data point groups one hour‚Äôs worth of data. The most recent hour is partial data for the current hour and updates every few seconds.

## Requests breakdowns

Multiple breakdowns are available in the statistics page

![](/docs/pagoda/stats2.png)

Requests can be broken down by

-    Requests Methods
-    Requests Status
-    Aggregated status display breakdown by requests methods

We are working to include more detailed breakdown by each requests and more interactive dashboard that enable clickthrough from the charts

## Network Status

Check the [Pagoda Status page](https://status.pagoda.co/) for the latest service information across all networks and subscribe to updates based on your service choice and needs.

![](/docs/pagoda/stats3.png)

'''
'''--- docs/sdk/js/building/basic-build.md ---
---
id: basics
title: "Basic Instructions"
---

# Basic instructions
To compile release version of the smart contract you can run a build script (specified in `package.json` for your project as `{ build: near-sdk-js build, ... }`):

```bash
npm run build
```

:::info
The above `build` command seeks a `index.js` file in `/src` and outputs a `contract.wasm` file in a newly created `/build` folder at the same level as `/src`. For more information, see the [source code for the CLI commands here](https://github.com/near/near-sdk-js/blob/2a51b6c6233c935c7957b91818cfe6f9c3073d71/packages/near-sdk-js/src/cli/cli.ts?_pjax=%23js-repo-pjax-container%2C%20div%5Bitemtype%3D%22http%3A%2F%2Fschema.org%2FSoftwareSourceCode%22%5D%20main%2C%20%5Bdata-pjax-container%5D#L28-L36).
:::

<!-- TODO: custom build commands using CLI -->

'''
'''--- docs/sdk/js/building/prototyping.md ---
---
id: prototyping
sidebar_label: Rapid Prototyping
title: "Upgrading Contracts: Rapid Prototyping"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Rapid Prototyping

When you change the interface of a contract and re-deploy it, you may see this error:

    Cannot deserialize the contract state.

### Why does this happen?

When your contract is executed, the NEAR Runtime reads the serialized state from disk and attempts to load it using current contract code. When your code changes but the serialized state stays the same, it can't figure out how to do this.

### How can you avoid such errors?

When you're still in the Research & Development phase, building a prototype and deploying it locally or on [testnet](../../../1.concepts/basics/networks.md), you can just delete all previous contract state when you make a breaking change. See below for a couple ways to do this.

When you're ready to deploy a more stable contract, there are a couple of [production strategies](../../../2.build/2.smart-contracts/release/upgrade.md#migrating-the-state) that will help you update the contract state without deleting it all. And once your contract graduates from "trusted mode" (when maintainers control a [Full Access key](/concepts/protocol/access-keys)) to community-governed mode (no more Full Access keys), you can set up your contract to [upgrade itself](../../../2.build/2.smart-contracts/release/upgrade.md#programmatic-update).

## Rapid Prototyping: Delete Everything All The Time

There are two ways to delete all account state:

1. Deploying on a new account each time
2. Deleting & recreating contract account

For both cases, let's consider the following example.

Let's say you deploy [a JS status message contract](https://github.com/near/near-sdk-js/blob/263c9695ab7bb853ced12886c4b3f8663070d900/examples/src/status-message-collections.js#L10-L42) contract to testnet, then call it with:

<Tabs className="language-tabs" groupId="code-tabs">
<TabItem value="near-cli">

```bash
near call [contract] set_status '{"message": "lol"}' --accountId you.testnet
near view [contract] get_status '{"account_id": "you.testnet"}'
```
</TabItem>
<TabItem value="near-cli-rs">

```bash
near contract call-function as-transaction [contract] set_status json-args '{"message": "lol"}' prepaid-gas '30 TeraGas' attached-deposit '0 NEAR' sign-as you.testnet network-config testnet sign-with-keychain send

near contract call-function as-read-only [contract] get_status text-args '{"account_id": "you.testnet"}' network-config testnet now
```

</TabItem>
</Tabs>

This will return the message that you set with the call to `set_status`, in this case `"lol"`.

At this point the contract is deployed and has some state. 

Now let's say you change the contract to store two kinds of data for each account, a status message and a tagline. You can add to the contract code a `LookupMap` for both status message and another one for the tagline, both indexed by the account ID. 

You build & deploy the contract again, thinking that maybe because the new `taglines` LookupMap has the same prefix as the old `records` LookupMap (the prefix is `a`, set by `new LookupMap("a"`), the tagline for `you.testnet` should be `"lol"`. But when you `near view` the contract, you get the "Cannot deserialize" message. What to do?

### 1. Deploying on a new account each time

When first getting started with a new project, the fastest way to deploy a contract is [creating an account](../../../4.tools/cli.md#near-create-account) and [deploying the contract](../../../4.tools/cli.md#near-deploy) into it using `NEAR CLI`.

<Tabs className="language-tabs" groupId="code-tabs">
<TabItem value="near-cli">

```bash
  near create-account <account-id> --useFaucet
  near deploy <account-id> ./path/to/compiled.wasm
```

</TabItem>
<TabItem value="near-cli-rs">

```bash
near account create-account sponsor-by-faucet-service <my-new-dev-account>.testnet autogenerate-new-keypair save-to-keychain network-config testnet create

near contract deploy <my-new-dev-account>.testnet use-file <route_to_wasm> without-init-call network-config testnet sign-with-keychain
```

</TabItem>
</Tabs>

This does a few things:

1. Creates a new testnet account pre-funded with 10N from the faucet
2. Stores the private key for this account in the `~/.near-credentials` folder
3. Deploys your contract code to this account

### 2. Deleting & Recreating Contract Account
Another option to start from scratch is to delete the account and recreate it.

<Tabs className="language-tabs" groupId="code-tabs">
<TabItem value="near-cli">

```bash title="Delete sub-account"
near delete <accountId> <beneficiaryId>
```
</TabItem>
<TabItem value="near-cli-rs">

```bash title="Delete sub-account"
near account delete-account app-name.you.testnet beneficiary you.testnet network-config testnet sign-with-keychain send
```
</TabItem>
</Tabs>

This sends all funds still on the `<accountId>` account to `<beneficiaryId>` and deletes the contract that had been deployed to it, including all contract state.

Now you create the sub-account and deploy to it again using the commands above, and it will have empty state like it did the first time you deployed it.

'''
'''--- docs/sdk/js/building/reproducible-builds.md ---
---
sidebar_position: 2
---

# Reproducible Builds
Reproducible builds let different people build the same program and get the exact same outputs as one another. It helps users trust that deployed contracts are built correctly and correspond to the source code. To verify your contract user can build it themselves and check that the binaries are identical.

## Problem
If you will build your contract on two different machines, most likely you will get two similar but not identical binaries. Your compiled `.wasm` file is dependent on several factors as the node version used and dependency sub versions. 

## Control for Dependencies
We recommend sharing lockfiles (and updating them only when dependencies are added or removed) between machines and specifying node versions to ensure that the same dependencies are used. 

'''
'''--- docs/sdk/js/cli/cli.md ---
---
title: JS SDK CLI
---

The SDK [Command Line Interface](https://github.com/near/near-sdk-js/blob/develop/packages/near-sdk-js/src/cli/cli.ts) (CLI) is a tool that enables to act on different parts of the build process as well as generate validations and an [ABI](https://github.com/near/abi). Among other things, the SDK CLI enables you to:

- Control the different parts of the build process
- Validate your contract and TypeScript code
- Create an ABI JSON file

---

## Overview {#overview}

_Click on a command for more information and examples._

**Commands**

| Command                                   | Description                                                                                                                    |
| ----------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| [`near-sdk-js build`](#build)               | Build a NEAR JS Smart-contract |
| [`near-sdk-js validateContract`](#validate-contract)                 | Validate a NEAR JS Smart-contract |
| [`near-sdk-js checkTypescript`](#check-ts) | Run TSC with some CLI flags |
| [`near-sdk-js createJsFileWithRollup`](#create-js-file)           | Create an intermediate JavaScript file for later processing with QJSC |
| [`near-sdk-js transpileJsAndBuildWasm`](#transpile-js-to-wasm)     | Transpiles the target javascript file into .c and .h using QJSC then compiles that into wasm using clang |

---

## Setup {#setup}

### Installation {#installation}

> Make sure you have a current version of `npm` and `NodeJS` installed.

#### Mac and Linux {#mac-and-linux}

1. Install `npm` and `node` using a [package manager](https://nodejs.org/en/download/package-manager/) like `nvm` as sometimes there are issues using Ledger due to how macOS handles node packages related to USB devices.
2. Ensure you have installed Node version 12 or above.
3. Install `near-cli` globally by running:

```bash
npm install -g near-cli
```

#### Windows {#windows}

> For Windows users, we recommend using Windows Subsystem for Linux (`WSL`).

1. Install `WSL` [[click here]](https://docs.microsoft.com/en-us/windows/wsl/install-manual#downloading-distros)
2. Install `npm` [[click here]](https://www.npmjs.com/get-npm)
3. Install ` Node.js` [ [ click here ]](https://nodejs.org/en/download/package-manager/)
4. Change `npm` default directory [ [ click here ] ](https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally#manually-change-npms-default-directory)
   - This is to avoid any permission issues with `WSL`
5. Open `WSL` and install `near-cli` globally by running:

```bash
npm install -g near-cli
```

:::info heads up

Copy/pasting can be a bit odd using `WSL`.

- "Quick Edit Mode" will allow right-click pasting.
- Depending on your version there may be another checkbox allowing `Ctrl` + `V` pasting as well.

![Windows option called Quick Edit allow right-click pasting in WSL](/docs/assets/windows-quickedit-mode.png)

:::

---

## Commands {#commands}

### `near-sdk-js build` {#build}

Build a NEAR JS Smart-contract, specifying the source, target, `package.json`, and `tsconfig.json` files. If none are specified, the default values are used. The argument default values are:

- source: `src/index.js`
- target: `build/contract.wasm`
- packageJson: `package.json`
- tsConfig: `tsconfig.json`

Options default values are set to `false`. 

- arguments (optional): `[source] [target] [packageJson] [tsConfig]`
- options: `--verbose --generateABI`

**Example:**

```bash
near-sdk-js build src/main.ts out/main.wasm package.json tsconfig.json --verbose true --generateABI true
```

### `near-sdk-js validateContract` {#validate-contract}

Validate a NEAR JS Smart-contract. Validates the contract by checking that all parameters are initialized in the constructor. Works only for TypeScript.

- arguments: `[source]`
- options: `--verbose`

**Example:**

```bash
near-sdk-js validateContract src/main.ts --verbose true
```

**Example Response:**

```bash
npx near-sdk-js validateContract src/index.ts
[validate] ‚Ä∫ ‚Ä¶  awaiting  Validating src/index.ts contract...
```

---

### `near-sdk-js checkTypescript` {#check-ts}

Run TSC with some CLI flags.

 :::note warning
 This command ignores `tsconfig.json`.
 :::

- arguments: `[source]`
- options: `--verbose`

**Example:**

```bash
near-sdk-js checkTypescript src/main.ts --verbose true
```

**Example Response:**

```bash
npx near-sdk-js checkTypescript src/index.ts
[checkTypescript] ‚Ä∫ ‚Ä¶  awaiting  Typechecking src/index.ts with tsc...
```

---

### `near-sdk-js createJsFileWithRollup` {#create-js-file}

Create an intermediate JavaScript file for later processing with QJSC.

- arguments: `[source]` `[target]`
- options: `--verbose`

**Example:**

```bash
near-sdk-js createJsFileWithRollup src/main.ts out/main.js --verbose true
```

**Example Response:**

```bash
npx near-sdk-js createJsFileWithRollup src/index.ts
[createJsFileWithRollup] ‚Ä∫ ‚Ä¶  awaiting  Creating src/index.ts file with Rollup...
```

### `near-sdk-js transpileJsAndBuildWasm` {#transpile-js-to-wasm}

Create an intermediate JavaScript file for later processing with QJSC.

- arguments: `[source]` `[target]`
- options: `--verbose`

**Example:**

```bash
near-sdk-js transpileJsAndBuildWasm src/main.js out/main.wasm --verbose true
```

**Example Response:**

```bash
npx near-sdk-js transpileJsAndBuildWasm
[transpileJsAndBuildWasm] ‚Ä∫ ‚úî  success   Generated build/contract.wasm contract successfully!
```

'''
'''--- docs/sdk/js/contract-interface/payable-methods.md ---
---
sidebar_position: 3
title: "Payable Methods"
---

# Payable Methods

We can allow methods to accept a NEAR token transfer together with the function call. This is done so that contracts can define a fee in tokens that needs to be paid when they are used. By default the methods are not payable and they will throw an error if someone will attempt to attach tokens to them during the invocation. This is done for safety reasons, in case someone accidentally transfers tokens during the function call.

To declare a method as payable, use the `({ payableFunction: true })` decorator parameter within the [`NearBindgen` decorated contract class](../contract-structure/near-bindgen.md) as follows:

```js
@call({ payableFunction: true })
my_method({}) {
    // ...
}
```

This will allow the `my_method` function to be called with NEAR Tokens attached to the call, transferring tokens to the contract.

Example:

```js
@NearBindgen({})
export class Contract {
    @call({ payableFunction: true })
    take_my_money({}) {
        near.log("Thanks!");
    }

    @call({})
    do_not_take_my_money({}) {
        near.log("No thanks!");
    }
}
```

is equivalent to:

```js
@NearBindgen({})
export class Contract {
    @call({})
    take_my_money({}) {
        near.log("Thanks!");
    }

    @call({})
    do_not_take_my_money({}) {
        if (near.attachedDeposit() > BigInt(0)) {
            throw new Error("Method do_not_take_my_money doesn't accept deposit");
        }
        near.log("No thanks!");
    }
}
```

'''
'''--- docs/sdk/js/contract-interface/private-methods.md ---
---
sidebar_position: 2
title: "Private Methods"
---

# Private Methods

## When Using Callbacks

Usually, when a contract has to have a callback for a remote cross-contract call, this callback method should only be called by the contract itself to avoid someone else calling it and changing the state. A common pattern is to have an assertion that validates that the direct caller (predecessor account ID) matches to the contract's account (current account ID). The `({ privateFunction: true })` decorator simplifies this by making it a single line decorator while improving readability.

Use this annotation within the designated contract class with the [`NearBindgen({})` decorator](../contract-structure/near-bindgen.md) as follows:

```js
@call({ privateFunction: true })
my_method({}) {
    // ...
}
```

Which is equivalent to:

```js
@call({})
my_method({}) {
    if near.currentAccountId() != near.predecessorAccountId() {
        throw new Error("Method method is private");
    }
    // ...
}
```

Now with this annotation, only the account of the contract itself can call this method, either directly or through a promise.

## Writing Internal Methods

Not all functions need to be exposed publicly. It may be beneficial to write private methods for helper or utility functions, for instance. There are three approaches to write internal methods:

1. Declare the method without using the `call` or `view` decorators.

```js
helperMethod(a, b) {
  // ...
}
```

2. Using an internal helper function in the module scope.

```javascript
// Function that can be called in another JS file
function getFirstName(account) {
  // ...
}
```

3. Importing a helper function or class from another module.

Another way of not exporting methods is by having a separate class, that is not marked with `NearBindgen({})`.

```js
import { getFirstName } from "./helpers.js";

@NearBindgen({})
export class Contract {
  // ...
}

class Helpers {
  // ...
}
```

'''
'''--- docs/sdk/js/contract-interface/public-methods.md ---
---
sidebar_position: 1
title: "Public Methods"
---

# Public Method Types

Methods can be called externally by using the `view({})` or `call({})` decorators within the contract class which will expose the method in the compiled WASM bytecode to be called by any other NEAR Account. Whenever a method is declared in your contract class without these decorators and is called by another NEAR Account, a `MethodNotFound` error will be thrown.

:::tip

If you need a contract to call itself, you can mark the function with these decorators but add the [`({  privateFunction: true })` annotation in the decorator parameters](private-methods.md) so that it will panic if called from anything but the contract itself.

:::

A basic usage of this would look like the following:

```js
@NearBindgen({})
export class MyContractStructure {
    @call({}) // or @view({})
    some_method({ parameter_a, parameter_b }) {
        // .. method logic here
    }
}
```

:::note `snake_case` vs `camelCase`
We recommend using `snake_case` for method names, contrary to the `camelCase` convention in JavaScript. This is because the method names for a majority of contracts in the NEAR ecosystem use `snake_case`, and it is easier to use the same convention for all contracts.
:::

Where this would expose `some_method` from the WASM binary and allow it to be called externally.

<!-- TODO: insert detail overview -->

'''
'''--- docs/sdk/js/contract-structure/collections.md ---
---
sidebar_position: 2
title: "Collections"
---

# Collections

When deciding on data structures to use for the application's data, it is important to minimize the amount of data read and written to storage, and the amount of data serialized and deserialized to minimize the cost of transactions. It is important to understand the tradeoffs of data structures in your smart contract because it can become a bottleneck as the application scales, and migrating the state to the new data structures will come at a cost.

The collections within `near-sdk-js` are designed to split the data into chunks and defer reading and writing to the store until needed. These data structures will handle the low-level storage interactions and aim to have a similar API to the [native data structures in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures).

It is important to keep in mind that when using collections, that each time state is loaded, all entries in the data structure will be read eagerly from storage and deserialized. This will come at a large cost for any non-trivial amount of data, so to minimize the amount of gas used the SDK collections should be used in most cases.

The most up to date collections and their examples can be found [in the repository on GitHub](https://github.com/near/near-sdk-js).

<!-- TODO include/update link for store module to replace collections mod when docs updated -->

The following data structures that exist in the SDK are as follows:

| SDK Collection                        | Native Equivalent           | Description |
| ------------------------------------- | ------------------------------- | ------------|
| `Vector`                           | `Array`         | A growable array type. The values are sharded in memory and can be used for iterable and indexable values that are dynamically sized. |
| <code>LookupMap</code>     | <code>Map</code>  | This structure behaves as a thin wrapper around the key-value storage available to contracts. This structure does not contain any metadata about the elements in the map, so it is not iterable. |
| <code>UnorderedMap</code>  | <code>Map</code>  | Similar to `LookupMap`, except that it stores additional data to be able to iterate through elements in the data structure. |
| `LookupSet`                        | `Set`                     | A set, which is similar to `LookupMap` but without storing values, can be used for checking the unique existence of values. This structure is not iterable and can only be used for lookups. |
| `UnorderedSet`                     | `Set`                     | An iterable equivalent of `LookupSet` which stores additional metadata for the elements contained in the set. |

## In-memory `Map` vs persistent `UnorderedMap`

- `Map` keeps all data in memory. To access it, the contract needs to deserialize the whole map.
- `UnorderedMap` keeps data in persistent storage. To access an element, you only need to deserialize this element.

Use `Map` in case:

- Need to iterate over all elements in the collection **in one function call**.
- The number of elements is small or fixed, e.g. less than 10.

Use `UnorderedMap` in case:

- Need to access a limited subset of the collection, e.g. one or two elements per call.
- Can't fit the collection into memory.

The reason is `Map` deserializes (and serializes) the entire collection in one storage operation.
Accessing the entire collection is cheaper in gas than accessing all elements through `N` storage operations.

Example of `Map`:

```javascript
import { NearBindgen, call, view, near } from "near-sdk-js";

@NearBindgen({})
export class StatusMessage {
  constructor() {
    this.records = new Map();
  }

  @call({})
  set_status({ message }) {
    let account_id = near.signerAccountId();
    near.log(`${account_id} set_status with message ${message}`);
    this.records.set(account_id, message);
  }

  @view({})
  get_status({ account_id }) {
    near.log(`get_status for account_id ${account_id}`);
    return this.records.get(account_id);
  }
}
```

Example of `UnorderedMap`:

```javascript 
import { NearBindgen, call, view, near, UnorderedMap } from "near-sdk-js";

@NearBindgen({})
export class StatusMessage {
  constructor() {
    this.records = new UnorderedMap("a");
  }

  @call({})
  set_status({ message }) {
    let account_id = near.signerAccountId();
    near.log(`${account_id} set_status with message ${message}`);
    this.records.set(account_id, message);
  }

  @view({})
  get_status({ account_id }) {
    near.log(`get_status for account_id ${account_id}`);
    return this.records.get(account_id);
  }

  @view({})
  get_all_statuses() {
    return this.records.toArray();
  }
}
```

## Error prone patterns

Because the values are not kept in memory and are lazily loaded from storage, it's important to make sure if a collection is replaced or removed, that the storage is cleared. In addition, it is important that if the collection is modified, the collection itself is updated in state because most collections will store some metadata.

Some error-prone patterns to avoid that cannot be restricted at the type level are:

```javascript
import { UnorderedMap, assert } from "near-sdk-js";

let m = new UnorderedMap("m");
m.insert(1, "test");
assert(m.length(), 1);
assert(m.get(1), "test");

// Bug 1: Should not replace any collections without clearing state, this will reset any
// metadata, such as the number of elements, leading to bugs. If you replace the collection
// with something with a different prefix, it will be functional, but you will lose any
// previous data and the old values will not be removed from storage.
let m = new UnorderedMap("m");
assert(m.length(), 0);
assert(m.get(1), "test");

// Bug 2: Should not use the same prefix as another collection
// or there will be unexpected side effects.
let m2 = new UnorderedMap("m");
assert(m2.length(), 0);
assert(m2.get(1), "test");
```

<!-- TODO: pagination with persistent collections in JS -->

## `LookupMap` vs `UnorderedMap`

### Functionality

- `UnorderedMap` supports iteration over keys and values, and also supports pagination. Internally, it has the following structures:
    - a prefix value
    - a vector of keys
    - a `LookupMap` of keys and values
- `LookupMap` only has a prefix, reading values to and from the contract's storage. Without a vector of keys, it doesn't have the ability to iterate over keys.

### Performance

`LookupMap` has a better performance and stores less data compared to `UnorderedMap`.

- `UnorderedMap` requires `2` storage reads to get the value and storage writes to insert a new entry.
- `LookupMap` requires only one storage read to get the value and only one storage write to store it.

### Storage space

`UnorderedMap` requires more storage for an entry compared to a `LookupMap`.

- `UnorderedMap` stores the key twice (once in the first vector and once in its `LookupMap`) and value once.
- `LookupMap` stores key and value once.

<!-- TODO: UnorderedSet and LookUpSet -->

'''
'''--- docs/sdk/js/contract-structure/near-bindgen.md ---
---
sidebar_position: 1
title: "NearBindgen"
---

# NearBindgen

The `@NearBindgen({})` decorator is used on the contract class to generate the necessary code to be a valid NEAR contract and expose the intended functions to be able to be called externally.

For example, on a simple counter contract, the decorator will be applied as such:

```javascript
import { NearBindgen, near, call, view } from 'near-sdk-js'

@NearBindgen({})
class Counter {
  val: number = 0;

  @view({}) // Public read-only method: Returns the counter value.
  get_num(): number {
    return this.val
  }

  @call({}) // Public method: Increment the counter.
  increment() {
    this.val += 1;
    near.log(`Increased number to ${this.val}`)
  }

  @call({}) // Public method: Decrement the counter.
  decrement() {
    this.val -= 1;
    near.log(`Decreased number to ${this.val}`)
  }

  @call({}) // Public method - Reset to zero.
  reset() {
    this.val = 0;
    near.log(`Reset counter to zero`)
  }
}
```

In this example, the `Counter` class represents the smart contract state and anything that implements serialization and deserialization methods can be included, such as `collections`, which will be covered in the next section. Whenever a function is called, the state will be loaded and deserialized, so it's important to keep this amount of data loaded as minimal as possible.

The core interactions that are important to keep in mind:
- Any `call` or `view` or `initialize` functions will be callable externally from any account/contract.
  - For more information, see [public methods](../contract-interface/public-methods.md)
- `view` or `call` decorators can be used in multiple ways to control the mutability of the contract:
  - Functions that are decorated with `view` will be read-only and do not write the updated state to storage
  - Functions that are decorated with `call` allow for mutating state, and state will always be written back at the end of the function call
- Exposed functions can omit reading and writing to state if class variables are not accessed in the function
  - This can be useful for some static functionality or returning data embedded in the contract code

## Initialization Methods

By default, the `default()` implementation of a contract will be used to initialize a contract. There can be a custom initialization function which takes parameters or performs custom logic with the following `@initialize({})` decorator:

```javascript
@NearBindgen({})
class Counter {
    @initialize({})
    init(val): void {
        this.val = val;
    }
}
```

## Payable Methods

`call` method decorators can be annotated with `{ payableFunction: true }` to allow tokens to be transferred with the method invocation. For more information, see [payable methods](../contract-interface/payable-methods.md).

To declare a function as payable, use the annotation as follows:

```javascript
@NearBindgen({})
class Counter {
    @call({ payableFunction: true })
    increment(): void {
        this.val += 1;
    }
}
```

## Private Methods

Some methods need to be exposed to allow the contract to call a method on itself through a promise, but want to disallow any other contract to call it. For this, use the `{ privateFunction: true }` annotation to throw an error when this method is called externally. See [private methods](../contract-interface/private-methods.md) for more information.

This annotation can be applied to any method through the following:

```javascript
@NearBindgen({})
class Counter {
    @call({ privateFunction: true })
    private_increment(): void {
        this.val += 1;
    }
}
```

'''
'''--- docs/sdk/js/contract-structure/nesting.md ---
---
sidebar_position: 3
title: "Nesting"
---

# Collections Nesting

<!-- TODO -->
'''
'''--- docs/sdk/js/cross-contract/callbacks.md ---
---
sidebar_position: 2
title: Callbacks
---

# Callbacks

NEAR Protocol is a sharded, proof-of-stake blockchain that behaves differently than proof-of-work blockchains. When interacting with a native Rust (compiled to Wasm) smart contract, cross-contract calls are asynchronous. Callbacks are used to either get the result of a cross-contract call or tell if a cross-contract call has succeeded or failed.

## Calculator Example

A callback method can be declared in your contract class as a regular method decorated with the `call({})` decorator. Be sure to pass in the `privateFunction: true` option to the decorator. This will ensure that the method is only callable by the contract itself.

For example, let's assume the calculator is deployed on `calc.near`, we can use the following:

```js
@NearBindgen({})
export class CalculatorCallerContract {
  @call({})
  sum_a_b({ a, b }) {
    let calculatorAccountId = "calc.near";
    // Call the method `sum` on the calculator contract.
    // Any unused GAS will be attached since the default GAS weight is 1.
    // Attached deposit is defaulted to 0.
    return NearPromise
            .new(calculatorAccountId)
            .functionCall("sum", { a, b }, BigInt(0), BigInt(100000000000000));
  }

  @call({ privateFunction: true })
  sum({ a, b })  {
    return a + b;
  }
}
```

## Allowlist Example

Next we'll look at a simple cross-contract call that is made to an allowlist smart contract, returning whether an account is in the list or not.

The common pattern with cross-contract calls is to call a method on an external smart contract, use `.then` syntax to specify a callback, and then retrieve the result or status of the promise. The callback will typically live inside the same, calling smart contract. There's a special decorator parameter used for protecting the callback function, which is [`privateFunction: true`](https://docs.rs/near-sdk-core/latest/near_sdk_core/struct.AttrSigInfo.html#structfield.is_private). We'll see this pattern in the example below.

The following example demonstrates two common approaches to callbacks using the high-level cross-contract approach with `NearPromise`. 

```js
@NearBindgen({})
export class ExtAllowlist {
    // ...

    @call({})
    is_allowlisted({ staking_pool_account_id }) {
        return this.allowlist.get(staking_pool_account_id) != null;
    };
}
```

After creating the class, we'll show a simple flow that will make a cross-contract call to the allowlist smart contract, asking if the account `idea404.testnet` is allowlisted. 

```js
@NearBindgen({})
export class Contract {
    @call({})
    xcc_query_allowlist() {
        // Call the method `is_allowlisted` on the allowlisted contract. Static GAS is only attached to the callback.
        // Any unused GAS will be split between the function call and the callback since both have a default unused GAS weight of 1
        // Attached deposit is defaulted to 0 for both the function call and the callback.
        return NearPromise
            .new("allowlist.near")
            .functionCall("is_allowlisted", { staking_pool_account_id: "idea404.testnet" }, BigInt(0), BigInt(100000000000000))
            .then("internalCallbackMethod", {}, BigInt(0), BigInt(100000000000000));
    }

    @call({ privateFunction: true })
    internalCallbackMethod() {
        assert(near.promiseResultsCount() === BigInt(1), "Error: expected 1 promise result");
        let result = JSON.parse(near.promiseResult(0));
        return result;
    }
```

The syntax begins with `NearPromise.new(<someAccountId>)` which initializes the async call to the designated `<someAccountId>`. Subsequent calls to this program in this account are invoked using `.functionCall()`. The `.functionCall()` method takes in the following parameters:

  - `functionName`: the name of the method to call on the contract
  - `args`: the arguments to pass to the method
  - `amount`: the amount of ‚ìÉ to attach to the call
  - `gas`: the amount of GAS units to attach to the call

There are a couple things to note when doing these function calls:

1. You can attach a deposit of ‚ìÉ, in yocto‚ìÉ to the call by specifying the `amount` parameter. This value is defaulted to 0 (1 ‚ìÉ = 1000000000000000000000000 yocto‚ìÉ, or 1^24 yocto‚ìÉ).
2. You can attach an amount of GAS units by specifying the `gas` method. This value is defaulted to 0.

'''
'''--- docs/sdk/js/intro.md ---
---
id: get-started
title: "Getting Started"
---

# Getting Started

:::tip Using the JS SDK on Windows
You can develop smart contracts on Windows using Windows Subsystem for Linux (WSL2).
:::

In order to use WSL2, follow the next steps:

- Run `PowerShell` as Administrator
- Execute `wsl --install` to install Ubuntu and do additional setup automatically. Check more details [here](https://learn.microsoft.com/en-us/windows/wsl/install)
- Restart your machine
- `WSL2` will continue setup process on start. Setup your username and password when prompted.
- Check [this](https://learn.microsoft.com/en-us/windows/dev-environment/javascript/nodejs-on-wsl) guide to setup `npm`, `node`, `npx`, `VSCode` and other tools of your choice in order to start developing.

In case of any issues of setting up WSL2 make sure that:

- Your Windows OS is up to date
- Virtualisation is turned on in BIOS
- `Windows Subsystem for Linux` and `Virtual Machine Platform` are turned on in `Windows Features` (Start -> Search -> Turn Windows Feature On or Off)

## Install Node

To install Node, follow the instructions on the [Node.js website](https://nodejs.org/en/download/).

## Create a new project

The best way to create a new NEAR app connected with a frontend is through [create-near-app](https://github.com/near/create-near-app). When initializing the project, be sure to select creating a project in TypeScript with a frontend option of your choice.

```bash
npx create-near-app
```

If you only wish to develop and deploy a JS contract, the [`hello-near-ts`](https://github.com/near-examples/hello-near-examples/tree/main/contract-ts) repository is great to use as a template or one of the [examples in the SDK repository](https://github.com/near/near-sdk-js/tree/develop/examples/src).

If you would like to generate a new project manually with `npm init`, make sure you include the following configuration in the generated `package.json`:

```json
  "dependencies": {
    "near-sdk-js": "*"
  }
```

'''
'''--- docs/sdk/js/js-sdk.md ---
---
id: introduction
title: About JS SDK
---

JavaScript is the most popular programming language, used by nearly 14 million developers worldwide. You can write smart-contracts in JavaScript or Typescript, and our SDK will pack them with a lightweight runtime. This can then be compiled into a single Wasm file that can be deployed into the NEAR network.

:::info Help contribute!
- [Report issues you encounter](https://github.com/near/near-sdk-js/issues) üêû 
- [Provide suggestions or feedback](https://github.com/near/near-sdk-js/discussions) üí° 
- [Show us what you've built!](https://github.com/near/near-sdk-js/discussions/categories/show-and-tell) üí™  
:::

---

## Create Your First Javascript Contract
Create your first **Javascript contract** in minutes:
1. Download and install [Node.js](https://nodejs.org/en/download/).
2. Create a new **javascript** project using our [quickstart guide](../../2.build/2.smart-contracts/quickstart.md).
3. Read our docs on **[how to write smart contract](../../2.build/2.smart-contracts/anatomy/anatomy.md)**.
'''
'''--- docs/sdk/js/promises/create-account.md ---
---
sidebar_position: 3
---

# Creating Accounts

You might want to create an account from a contract for many reasons. One example:
You want to [progressively onboard](https://www.youtube.com/watch?v=7mO4yN1zjbs&t=2s) users, hiding the whole concept of NEAR from them at the beginning, and automatically create accounts for them (these could be sub-accounts of your main contract, such as `user123.some-cool-game.near`).

Since an account with no balance is almost unusable, you probably want to combine this with the token transfer from [the last page](./token-tx.md). You will also need to give the account an access key. Here's a way do it:

```js
NearPromise.new("subaccount.example.near").createAccount().addFullAccessKey(near.signerAccountPk()).transfer(BigInt(250_000_000_000_000_000_000_000)); // 2.5e23yN, 0.25N
```

In the context of a full contract:

```js
import { NearPromise, near } from "near-sdk-js";

@NearBindgen({})
export class Contract {
  @call({ privateFunction: true })
  createSubaccount({ prefix }) {
    const subaccountId = `${prefix}.${near.currentAccountId()}`;
    return NearPromise.new(subaccount_id).createAccount().addFullAccessKey(near.signerAccountPk()).transfer(BigInt(250_000_000_000_000_000_000_000)); // 2.5e23yN, 0.25N
  }
}
```

Things to note:

- `addFullAccessKey` ‚Äì¬†This example passes in the public key of the human or app that signed the original transaction that resulted in this function call ([`signerAccountPk`](https://github.com/near/near-sdk-js/blob/d1ca261feac5c38768ab30e0b24cf7263d80aaf2/packages/near-sdk-js/src/api.ts#L187-L194)). You could also use [`addAccessKey`](https://github.com/near/near-sdk-js/blob/d1ca261feac5c38768ab30e0b24cf7263d80aaf2/packages/near-sdk-js/src/promise.ts#L526-L548) to add a Function Call access key that only permits the account to make calls to a predefined set of contract functions.
- `{ privateFunction: true }` ‚Äì if you have a function that spends your contract's funds, you probably want to protect it in some way. This example does so with a perhaps-too-simple [`{ privateFunction: true }`](../contract-interface/private-methods.md) decorator parameter.

'''
'''--- docs/sdk/js/promises/deploy-contract.md ---
---
sidebar_position: 4
---

# Deploying Contracts

You might want your smart contract to deploy subsequent smart contract code for a few reasons:

- The contract acts as a Factory, a pattern where a parent contract creates many child contracts ([Mintbase](https://www.mintbase.xyz/) does this to create a new NFT store for [anyone who wants one](https://docs.mintbase.xyz/creating/store/deploy-fee); [Rainbow Bridge](https://near.org/bridge/) does this to deploy separate Fungible Token contracts for [each bridged token](https://github.com/aurora-is-near/rainbow-token-connector/blob/ce7640da144f000e0a93b6d9373bbc2514e37f3b/bridge-token-factory/src/lib.rs#L311-L341))
- The contract [updates its own code](../../../2.build/2.smart-contracts/release/upgrade.md#programmatic-update) (calls `deploy` on itself).
- You could implement a "contract per user" system that creates app-specific subaccounts for users (`your-app.user1.near`, `your-app.user2.near`, etc) and deploys the same contract to each. This is currently prohibitively expensive due to NEAR's [storage fees](https://docs.near.org/concepts/storage/storage-staking), but that may be optimized in the future. If it is, this sort of "sharded app design" may become the more scalable, user-centric approach to contract standards and app mechanics. An early experiment with this paradigm was called [Meta NEAR](https://github.com/metanear).

If your goal is to deploy to a subaccount of your main contract like Mintbase or the Rainbow Bridge, you will also need to create the account. So, combining concepts from the last few pages, here's what you need:

```js
import { includeBytes, NearPromise, near } from "near-sdk-js";

const CODE = includeBytes("./res/contract.wasm");

NearPromise.new("subaccount.example.near")
  .createAccount()
  .addFullAccessKey(near.signerAccountPk())
  .transfer(BigInt(3_000_000_000_000_000_000_000_000)) // 3e24yN, 3N
  .deployContract(CODE);
```

Here's what a full contract might look like, showing a na√Øve way to pass `code` as an argument rather than hard-coding it with `includeBytes`:

```js
import { NearPromise, near, validateAccountId } from "near-sdk-js";

const INITIAL_BALANCE = BigInt(3_000_000_000_000_000_000_000_000); // 3e24yN, 3N

@NearBindgen({})
export class Contract {
  @call({ privateFunction: true })
  createAccount({ prefix, code }) {
    const subAccountId = `${prefix}.${near.currentAccountId()}`;
    validateAccountId(subAccountId);
    NearPromise.new(subAccountId)
        .createAccount()
        .addFullAccessKey(near.signerAccountPk())
        .transfer(INITIAL_BALANCE)
        .deployContract(code);
  }
}
```

Why is this a na√Øve approach? It could run into issues because of the 4MB transaction size limit ‚Äì the function above would deserialize and heap-allocate a whole contract. For many situations, the `includeBytes` approach is preferable. If you really need to attach compiled Wasm as an argument, you might be able to copy the approach [used by Sputnik DAO v2](https://github.com/near-daos/sputnik-dao-contract/blob/a8fc9a8c1cbde37610e56e1efda8e5971e79b845/sputnikdao2/src/types.rs#L74-L142).

'''
'''--- docs/sdk/js/promises/intro.md ---
---
sidebar_position: 1
sidebar_label: Introduction
pagination_label: "Promises: Introduction"
title: "Introduction"
---

# Promises

Transactions can be sent asynchronously from a contract through a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise). Like Promises in many programming languages, these will cause code to be executed in the future. In the case of NEAR, this "in the future" means a transaction to be executed _in the next block_ (or thereabouts), rather than in the same block as the original function call.

:::info Why wait?
Why not do these things synchronously, in the same block when the function is called? Why does NEAR require a `Promise` for sending tokens, or creating an account, or deploying a contract?

They need to be scheduled in separate blocks since sender and receiver accounts can be on different shards, and cross-shard communication happens across blocks by passing receipts (you can think of receipts in NEAR as "internal transactions"). You can see these receipts being passed from block to block [in NEAR Explorer](https://nearblocks.io/txns/36n3tBNiF497Tm9mijEpsCUvejL8mBYF1CEWthCnY8FV).
:::
'''
'''--- docs/sdk/js/promises/token-tx.md ---
---
sidebar_position: 2
title: Sending Native Tokens
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Sending $NEAR

You might want to send tokens from a contract for many reasons.

- The contract uses something like the [Storage Standard](https://nomicon.io/Standards/StorageManagement) and needs to return deposits to users when they unregister.
- Users pay into the contract and the contract later pays these fees to the maintainers, redistributes them to users, or disburses them to some cause the users vote on.
- And more!

Blockchains give us programmable money, and the ability for a smart contract to send tokens lies at the heart of that ability.

NEAR makes this easy. Transferring NEAR tokens is the simplest transaction you can send from a smart contract. Here's all you need:

```js
let amount = BigInt(1_000_000_000_000_000_000_000_000); // 1 $NEAR as yoctoNEAR
let to = "alice.near";

NearPromise.new(to).transfer(amount);
```

In the context of a full contract and function call, this could look like:

```js
import { NearPromise, NearBindgen } from "near-sdk-js";

@NearBindgen({})
export class Contract {
  pay({ amount, to }) {
    return NearPromise.new(to).transfer(amount);
  }
}
```

Most of this is boilerplate you're probably familiar with by now ‚Äì¬†imports, setting up [`NearBindgen`](../contract-structure/near-bindgen.md), etc. Some interesting details related to the transfer itself:

- The `pay` method defined here accepts JSON as input, and numbers in JS [cannot be larger than `2^53-1`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER), so for compatibility with deserializing JSON to JS, the integer is serialized as a string. Since the `transfer` method takes a value in [yocto](https://en.wikipedia.org/wiki/Yocto-)NEAR, it's likely to need numbers much larger than `2^53-1`.

- Returning the `NearPromise`: This allows NEAR Explorer, near-cli, near-api-js, and other tooling to correctly determine if a whole chain of transactions is successful. If your function does not return `Promise`, tools like near-cli will return immediately after your function call. And then even if the `transfer` fails, your function call will be considered successful.

Using near-cli or near-cli-rs, someone could invoke this function with a call like:

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="near-cli">

  ```bash
  near call <contract> pay '{"amount": "1000000000000000000000000", "to": "example.near"}' --accountId benjiman.near
  ```

  </TabItem>
  <TabItem value="near-cli-rs">

  ```bash
  near contract call-function as-transaction <contract> pay json-args '{"amount": "1000000000000000000000000", "to": "example.near"}' prepaid-gas '30 TeraGas' attached-deposit '0 NEAR' sign-as benjiman.near network-config testnet sign-with-keychain send
  ```

  </TabItem>
</Tabs>

'''
'''--- docs/sdk/js/testing/integration-tests.md ---
---
sidebar_position: 2
---

# Integration Tests

We place integration tests in JS in a separate directory at the same level as `/src`, called `/integration-tests` ([read more](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#integration-tests)), placing this folder within a `/tests` folder at root-level that contains the unit tests folder would also be plausible. Refer to this folder structure below:

```sh
‚îú‚îÄ‚îÄ package.json                ‚üµ contains `dependencies` for contract and `devDependencies` for workspaces-js tests
‚îú‚îÄ‚îÄ src
‚îÇ  ‚îî‚îÄ‚îÄ index.js                 ‚üµ contract code
‚îú‚îÄ‚îÄ node_modules
‚îî‚îÄ‚îÄ integration-tests           ‚üµ integration test directory
   ‚îî‚îÄ‚îÄ tests.js                 ‚üµ integration test file
```

A sample configuration for this project's `package.json` is shown below:

```json
{
  "name": "simple-example",
  "version": "0.1.0",
  "description": "Simple json file example",
  "main": "index.js",
  "type": "module",
  "license": "MIT",
  "directories": {
    "test": "test"
  },
  "scripts": {
    "build": "near-sdk-js build",
    "test": "ava"
  },
  "dependencies": {
    "near-sdk-js": "0.6.0"
  },
  "devDependencies": {
    "ava": "^4.3.3",
    "near-workspaces": "^3.2.2"
  },
  "ava": {
    "files": [
      "test/**/*.ava.js"
    ],
    "require": [],
    "failFast": false,
    "timeout": "2m",
    "failWithoutAssertions": true,
    "environmentVariables": {},
    "verbose": true,
    "nodeArguments": []
  }
}
```

The `tests.js` file above will contain the integration tests. These can be run with the following command from the same level as the test `package.json` file:

    npm test

<!-- TODO: add snippets of code, living everywhere spread across docs -->
'''
'''--- docs/sdk/js/testing/unit-tests.md ---
---
sidebar_position: 1
---

# Unit Tests

You can unit test abstracted logic implemented by smart contract functions like regular JavaScript functions with any testing library of your liking. A simple example would look as follows: 

#### Contract 
```js	
@NearBindgen({})
export class Contract {
  ...
  doSomething(): string {
    return callSomeFunction();
  }
}
```

#### Unit Test File 
```js
describe('Contract', () => {
  it('callSomeFunction should work', () => {
    ...
    results = callSomeFunction();
    // then assert results are what you expect
    ....
  });
});
```

As for testing the smart contract functions themselves, we recommend using [integration tests](./integration-tests.md) instead as they fully replicate the environment on which that logic will run.  
'''
'''--- docs/sdk/rust/best-practices.md ---
---
id: best-practices
title: "Best Practices"
---

# Best practices

## Enable overflow checks

It's usually helpful to panic on integer overflow. To enable it, add the following into your `Cargo.toml` file:

```toml
[profile.release]
overflow-checks = true
```

## Use `require!` early

Try to validate the input, context, state and access using `require!` before taking any actions. The earlier you panic, the more [gas](https://docs.near.org/concepts/protocol/gas) you will save for the caller.

```rust
#[nearn]
impl Contract {
    pub fn set_fee(&mut self, new_fee: Fee) {
        require!(env::predecessor_account_id() == self.owner_id, "Owner's method");
        new_fee.assert_valid();
        self.internal_set_fee(new_fee);
    }
}
```

**Note**: If you want debug information in the panic message or if you are using an SDK version before `4.0.0-pre.2`, 
the Rust `assert!` macro can be used instead of `require!`.

```rust
#[near]
impl Contract {
    pub fn set_fee(&mut self, new_fee: Fee) {
        assert_eq!(env::predecessor_account_id(), self.owner_id, "Owner's method");
        new_fee.assert_valid();
        self.internal_set_fee(new_fee);
    }
}
```

## Use `log!`

Use logging for debugging and notifying user.

When you need a formatted message, you can use the following macro:

```rust
log!("Transferred {} tokens from {} to {}", amount, sender_id, receiver_id);
```

It's equivalent to the following message:

```rust
env::log_str(format!("Transferred {} tokens from {} to {}", amount, sender_id, receiver_id).as_ref());
```

## Return `Promise`

If your method makes a cross-contract call, you probably want to return the newly created `Promise`.
This allows the caller (such as a near-cli or near-api-js call) to wait for the result of the promise instead of returning immediately.
Additionally, if the promise fails for some reason, returning it will let the caller know about the failure, as well as enabling NEAR Explorer and other tools to mark the whole transaction chain as failing.
This can prevent false-positives when the first or first few transactions in a chain succeed but a subsequent transaction fails.

E.g.

```rust
#[near]
impl Contract {
    pub fn withdraw_100(&mut self, receiver_id: AccountId) -> Promise {
        Promise::new(receiver_id).transfer(100)
    }
}
```

## Reuse crates from `near-sdk`

`near-sdk` re-exports the following crates:

- `borsh`
- `base64`
- `bs58`
- `serde`
- `serde_json`

Most common crates include `borsh` which is needed for internal STATE serialization and
`serde` for external JSON serialization.

When marking structs with `serde::Serialize` you need to use `#[serde(crate = "near_sdk::serde")]`
to point serde to the correct base crate.

```rust
/// Main contract structure serialized with Borsh
#[near(contract_state)]
#[derive(PanicOnDefault)]
pub struct Contract {
    pub pair: Pair,
}

/// Implements both `serde` and `borsh` serialization.
/// `serde` is typically useful when returning a struct in JSON format for a frontend.
#[near(serializers = [json, borsh])]
pub struct Pair {
    pub a: u32,
    pub b: u32,
}

#[near]
impl Contract {
    #[init]
    pub fn new(pair: Pair) -> Self {
        Self {
            pair,
        }
    }

    pub fn get_pair(self) -> Pair {
        self.pair
    }
}
```

## `std::panic!` vs `env::panic`

- `std::panic!` panics the current thread. It uses `format!` internally, so it can take arguments.
  SDK sets up a panic hook, which converts the generated `PanicInfo` from `panic!` into a string and uses `env::panic` internally to report it to Runtime.
  This may provide extra debugging information such as the line number of the source code where the panic happened.

- `env::panic` directly calls the host method to panic the contract.
  It doesn't provide any other extra debugging information except for the passed message.

## Use workspaces

Workspaces allow you to automate workflows and run tests for multiple contracts and cross-contract calls in a sandbox or testnet environment.
Read more, [workspaces-rs](https://github.com/near/workspaces-rs) or [workspaces-js](https://github.com/near/workspaces-js).

'''
'''--- docs/sdk/rust/building/basic-build.md ---
---
id: basics
title: "Basic Instructions"
---

# Basic instructions
To compile release version of the smart contract you can run:

```bash
cargo build --target wasm32-unknown-unknown --release
```

:::info

The above `build` command is setting a `target` flag to create a WebAssembly `.wasm` file.

:::

Notice that your project directory now has a few additional items:

```bash
.
‚îú‚îÄ‚îÄ Cargo.lock  ‚üµ created during build to lock dependencies
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ src
‚îÇ  ‚îî‚îÄ‚îÄ lib.rs
‚îî‚îÄ‚îÄ target      ‚üµ created during build, holds the compiled wasm
```
# Build and Flags
We recommend you to optimize your build artifact with the use of the next flags in your Cargo.toml file. If you are performing a multi-contract build, you should include these settings in the Cargo.toml that is at the root of your project.

```bash
[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
```

The above command is essentially setting special flags and optimizing the resulting `.wasm` file. At the end of the day, this allows you to customize the `cargo build --release` command.

# Custom Flags
If you wish to add custom flags to your build, you can perform this by adding build flags to your `ProjectFolder/.cargo/config.toml` as illustrated in this example.

```toml
[target.wasm32-unknown-unknown]
rustflags = ["-C", "link-arg=-s"]
```

A full set of build options can be accessed at https://doc.rust-lang.org/cargo/reference/config.html.

You can find an example [here](https://github.com/near/near-sdk-rs/blob/05e4539a8f3db86dd43b768ee9660dd4c8e7ea5c/examples/fungible-token/.cargo/config.toml).

'''
'''--- docs/sdk/rust/building/post-processing-tools.md ---
---
id: post-processing
title: "Post Processing Tools"
---

# Post Processing Tools
The size of the contract is a critical characteristic. The best way to keep it small is a well-designed minimalistic code with a reduced number of dependencies. It is especially important for large contracts and huge multi-contract dApps that can take a fortune to deploy.

When you have done your best with the code optimization it is worth reducing the size of the contract by minifying it. 

## Ready to use script
We have prepared a simple `bash` script that can be used to minify `.wasm` contract file. You can find it [here](https://github.com/near/near-sdk-rs/blob/master/minifier/minify.sh).

The current approach to minification is the following:
1. Snip (i.e. just replace with unreachable instruction) few known fat functions from the standard library (such as float formatting and panic-related) with `wasm-snip`.
2. Run `wasm-gc` to eliminate all functions reachable from the snipped functions.
3. Strip unneeded sections, such as names with `wasm-strip`.
4. Run `binaryen wasm-opt`, which cleans up the rest.

### Requirements to run the script:
- install [wasm-snip](https://docs.rs/wasm-snip/0.4.0/wasm_snip/) and [wasm-gc](https://docs.rs/crate/wasm-gc/0.1.6) with Cargo:
```bash
cargo install wasm-snip wasm-gc
```
- install [binaryen](https://github.com/WebAssembly/binaryen) and [wabt](https://github.com/WebAssembly/wabt) on your system. For Ubuntu and other Debian based Linux distributions run:
```bash
apt install binaryen wabt
```
## WARNING
Minification could be rather aggressive, so you must test the contract after minification. Standalone NEAR runtime could be helpful [here](https://github.com/nearprotocol/nearcore/tree/master/runtime/near-vm-runner).
'''
'''--- docs/sdk/rust/building/prototyping.md ---
---
id: prototyping
sidebar_label: Rapid Prototyping
title: "Upgrading Contracts: Rapid Prototyping"
---
import {CodeTabs, Language, Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Rapid Prototyping

When you change the interface of a contract and re-deploy it, you may see this error:

    Cannot deserialize the contract state.

### Why does this happen?

When your contract is executed, the NEAR Runtime reads the serialized state from disk and attempts to load it using current contract code. When your code changes but the serialized state stays the same, it can't figure out how to do this.

### How can you avoid such errors?

When you're still in the Research & Development phase, building a prototype and deploying it locally or on [testnet](/concepts/basics/networks), you can just delete all previous contract state when you make a breaking change. See below for a couple ways to do this.

When you're ready to deploy a more stable contract, there are a couple of [production strategies](../../../2.build/2.smart-contracts/release/upgrade.md#migrating-the-state) that will help you update the contract state without deleting it all. And once your contract graduates from "trusted mode" (when maintainers control a [Full Access key](/concepts/protocol/access-keys)) to community-governed mode (no more Full Access keys), you can set up your contract to [upgrade itself](../../../2.build/2.smart-contracts/release/upgrade.md#programmatic-update).

## Rapid Prototyping: Delete Everything All The Time

There are two ways to delete all account state:

1. Deploying on a new account each time
2. Deleting & recreating contract account

For both cases, let's consider the following example.

The [rust-status-message](https://github.com/near-examples/rust-status-message) example contract has the following structure:

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/rust-status-message/blob/b5fa6f2a30559d56a3a3ea52da8c26c5d3907606/src/lib.rs" start="5" end="29"/>
  </Language>
</CodeTabs>

Let's say you deploy this contract to testnet, then call it with:

<Tabs className="language-tabs" groupId="code-tabs">
<TabItem value="near-cli">

```bash
near call [contract] set_status '{"message": "lol"}' --accountId you.testnet
near view [contract] get_status '{"account_id": "you.testnet"}'
```

</TabItem>
<TabItem value="near-cli-rs">

```bash
near contract call-function as-transaction [contract] set_status json-args '{"message": "lol"}' prepaid-gas '30 TeraGas' attached-deposit '0 NEAR' sign-as you.testnet network-config testnet sign-with-keychain send

near contract call-function as-read-only [contract] get_status text-args '{"account_id": "you.testnet"}' network-config testnet now
```
</TabItem>
</Tabs>
This will return the message that you set with the call to `set_status`, in this case `"lol"`.

At this point the contract is deployed and has some state. 

Now let's say you change the contract to store two kinds of data for each account:

```rust
#[near(contract_state)]
pub struct StatusMessage {
    taglines: LookupMap<AccountId, String>,
    bios: LookupMap<AccountId, String>,
}

impl Default for StatusMessage {
    fn default() -> Self {
        Self {
            taglines: LookupMap::new(b"r"),
            bios: LookupMap::new(b"b"),
        }
    }
}

#[near]
impl StatusMessage {
    pub fn set_tagline(&mut self, message: String) {
        let account_id = env::signer_account_id();
        self.taglines.insert(&account_id, &message);
    }

    pub fn get_tagline(&self, account_id: AccountId) -> Option<String> {
        return self.taglines.get(&account_id);
    }

    pub fn set_bio(&mut self, message: String) {
        let account_id = env::signer_account_id();
        self.bios.insert(&account_id, &message);
    }

    pub fn get_bio(&self, account_id: AccountId) -> Option<String> {
        return self.bios.get(&account_id);
    }
}
```

You build & deploy the contract again, thinking that maybe because the new `taglines` LookupMap has the same prefix as the old `records` LookupMap (the prefix is `r`, set by `LookupMap::new(b"r".to_vec())`), the tagline for `you.testnet` should be `"lol"`. But when you `near view` the contract, you get the "Cannot deserialize" message. What to do?

### 1. Deploying on a new account each time

When first getting started with a new project, the fastest way to deploy a contract is [creating an account](../../../4.tools/cli.md#near-create-account) and [deploying the contract](../../../4.tools/cli.md#near-deploy) into it using `NEAR CLI`.

<Tabs className="language-tabs" groupId="code-tabs">
<TabItem value="near-cli">

```bash
  near create-account <account-id> --useFaucet
  near deploy <account-id> ./path/to/compiled.wasm
```

</TabItem>
<TabItem value="near-cli-rs">

```bash
near account create-account sponsor-by-faucet-service <my-new-dev-account>.testnet autogenerate-new-keypair save-to-keychain network-config testnet create

near contract deploy <my-new-dev-account>.testnet use-file <route_to_wasm> without-init-call network-config testnet sign-with-keychain
```

</TabItem>
</Tabs>

This does a few things:

1. Creates a new testnet account pre-funded with 10N from the faucet
2. Stores the private key for this account in the `~/.near-credentials` folder
3. Deploys your contract code to this account

### 2. Deleting & Recreating Contract Account
Another option to start from scratch is to delete the account and recreate it.

<Tabs className="language-tabs" groupId="code-tabs">
<TabItem value="near-cli">

```bash title="Delete sub-account"
near delete app-name.you.testnet you.testnet
```
</TabItem>
<TabItem value="near-cli-rs">

```bash title="Delete sub-account"
near account delete-account app-name.you.testnet beneficiary you.testnet network-config testnet sign-with-keychain send
```
</TabItem>
</Tabs>

This sends all funds still on the `app-name.you.testnet` account to `you.testnet` and deletes the contract that had been deployed to it, including all contract state.

Now you create the sub-account and deploy to it again using the commands above, and it will have empty state like it did the first time you deployed it.

'''
'''--- docs/sdk/rust/building/reproducible-builds.md ---
---
sidebar_position: 2
---

# Reproducible Builds
Reproducible builds let different people build the same program and get the exact same outputs as one another. It helps users trust that deployed contracts are built correctly and correspond to the source code. To verify your contract user can build it themselves and check that the binaries are identical.

## Problem
If you will build your contract on two different machines, most likely you will get two similar but not identical binaries. Your build artifact can be affected by the locale, timezone, build path, and billion other factors in your build environment. Rust community has a long story of fighting this issue but still, [it is not achieved yet](https://github.com/rust-lang/rust/labels/A-reproducibility).

## CI solution
We recommend you to build your contracts with the use of our [Contract Builder](https://github.com/near/near-sdk-rs/tree/master/contract-builder). It's is using Docker, controlled and sharable environment that can be used by both you and your users. Docker image is available [here](https://hub.docker.com/r/nearprotocol/contract-builder). The contract built in it will result in a binary that is the same if built on other machines.

'''
'''--- docs/sdk/rust/contract-interface/contract-mutability.md ---
---
sidebar_position: 2
---

# Contract Mutability

Contract state mutability is handled automatically based on how [`self`](https://doc.rust-lang.org/std/keyword.self.html) is used in the function parameters. Depending on which is used, the [`#[near]`](../contract-structure/near-bindgen.md) macro will generate the respective code to load/deserialize state for any function which uses `self` and serialize/store state only for when `&mut self` is used.

The following semantics are consistent for all [public methods](public-methods.md).

## Read-Only Functions

To access state immutably, where the existing state is not overwritten at the end of the transaction, you can use `&self` or `self` as a parameter. Both of these will generate the same code to load and deserialize the state into the structure and call the function, but the difference is that `&self` will just pass a reference to this variable into the function where `self` will move the variable into the function.

For more information about `&self` versus `self` see [this section in the Rust book](https://doc.rust-lang.org/stable/book/ch05-03-method-syntax.html?highlight=capture%20self#defining-methods).

Here are some examples of using each:

```rust
#[near(contract_state)]
#[derive(Default)]
pub struct MyContractStructure {
    integer: u64,
    message: String,
}

#[near]
impl MyContractStructure {
    pub fn get_values(self) -> (u64, String) {
        (self.integer, self.message)
    }
    pub fn log_state_string(&self) {
        near_sdk::env::log(self.message.as_bytes());
    }
}
```

There is no simple guideline that works for every case, but here are some core reasons on when to use each:

### self (owned value)

Moving the owned value into the function can be useful if `self` itself or its fields are moved within the function, as it will remove the need to `Clone`/`Copy` the data.

Example:

```rust
/// View method. More efficient, but can't be reused internally, because it consumes self.
pub fn get_owner_id(self) -> AccountId {
    self.owner_id
}
```

### &self (immutable reference)

This should be used when the contract state is only read or the function is re-used by other methods which do not have [ownership](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html) of the variable. This can also be useful if the struct uses a lot of memory, to avoid moving a large amount of data into the function scope rather than just referencing it.

Example:

```rust
/// View method. Requires cloning the account id.
pub fn get_owner_id(&self) -> AccountId {
    self.owner_id.clone()
}
```

### Returning derived data

Some less common cases may intend to use read-only methods to return objects that are derived from modified objects stored in state. Below is a demonstration of this concept:

```rust
/// View method that "modifies" state, for code structure or computational
/// efficiency reasons. Changes state in-memory, but does NOT save the new
/// state. If called internally by a change method, WILL result in updated
/// contract state.
pub fn update_stats(&self, account_id: AccountId, score: U64) -> Account {
    let account = self.accounts.get(&account_id).unwrap_or_else(|| env::panic_str("ERR_ACCT_NOT_FOUND"));
    account.total += score;
    account
}
```

## Mutable Functions

Mutable functions allow for loading the existing state, modifying it, then rewriting the modified state at the end of the function call. This should be used for any transaction which modifies the contract state. Note that the serialized contract data is stored in persistent storage under the key `STATE`.

An example of a mutable function is as follows:

```rust
#[near(contract_state)]
#[derive(Default)]
pub struct MyContractStructure {
    integer: u64,
}
#[near]
impl MyContractStructure {
    pub fn modify_value(&mut self, new_value: u64) {
        self.integer = new_value;
    }
    pub fn increment_value(&mut self) {
        self.integer += 1;
    }
}
```

## Pure Functions

These functions do not use `self` at all, and will not read or write the contract state from storage. Using public pure functions will be very rare but can be useful if returning data embedded in the contract code or executing some static shared logic that doesn't depend on state.

Some examples of pure functions are as follows:

```rust
const SOME_VALUE: u64 = 8;

#[near]
impl MyContractStructure {
    pub fn log_message(/* Parameters here */) {
        near_sdk::log!("inside log message");
    }
    pub fn log_u64(value: u64) {
        near_sdk::log!("{}", value);
    }
    pub fn return_static_u64() -> u64 {
        SOME_VALUE
    }
}
```

'''
'''--- docs/sdk/rust/contract-interface/payable-methods.md ---
---
sidebar_position: 4
---

# Payable Methods

We can allow methods to accept token transfer together with the function call. This is done so that contracts can define a fee in tokens that needs to be paid when they are used. By default the methods are not payable and they will panic if someone will attempt to transfer tokens to them during the invocation. This is done for safety reason, in case someone accidentally transfers tokens during the function call.

To declare a method as payable, use the `#[payable]` annotation within the [`near` macro](../contract-structure/near-bindgen.md) as follows:

```rust
#[payable]
pub fn my_method(&mut self) {
...
}
```

This will allow the `my_method` function to be called and transfer balance to the contract.

Example:

```rust
#[near]
impl Contract {
    #[payable]
    pub fn take_my_money(&mut self) {
        near_sdk::env::log_str("Thanks!");
    }
    pub fn do_not_take_my_money(&mut self) {
        near_sdk::env::log_str("Thanks!");
    }
}
```

is equivalent to:

```rust
#[near]
impl Contract {
    pub fn take_my_money(&mut self) {
        near_sdk::env::log_str("Thanks!");
    }
    pub fn do_not_take_my_money(&mut self) {
        if near_sdk::env::attached_deposit() != 0 {
            near_sdk::env::panic_str("Method do_not_take_my_money doesn't accept deposit");
        }
        near_sdk::env::log_str("Thanks!");
    }
}
```

'''
'''--- docs/sdk/rust/contract-interface/private-methods.md ---
---
sidebar_position: 3
---

# Private Methods

## When using callbacks

Usually, when a contract has to have a callback for a remote cross-contract call, this callback method should only be called by the contract itself. It's to avoid someone else calling it and messing the state. Pretty common pattern is to have an assertion that validates that the direct caller (predecessor account ID) matches to the contract's account (current account ID). Macro `#[private]` simplifies it, by making it a single line macro instead and improves readability.

Use this annotation within the [`near` macro](../contract-structure/near-bindgen.md) as follows:

```rust
#[private]
pub fn my_method(&mut self) {
    ‚Ä¶
}
```

Which is equivalent to:

```rust
pub fn my_method(&mut self ) {
    if near_sdk::env::current_account_id() != near_sdk::env::predecessor_account_id() {
        near_sdk::env::panic_str("Method method is private");
    }
...
}
```

Now with this annotation, only the account of the contract itself can call this method, either directly or through a promise.

## Writing internal methods

Not all functions need to be exposed publicly. It may be beneficial to write private methods for helper or utility functions, for instance. There are three approaches to write internal methods:

1. Using `fn` instead of `pub fn`

  ```rust
  fn helper_method(a: u8, b: u8) {
    ‚Ä¶
  }
  ```

2. Using `pub(crate) fn`. This may be helpful when an internal method is in a different module.

  ```rust
  // Function that can be called in another Rust file
  pub(crate) fn get_first_name(account: Account) {
    ‚Ä¶
  }
  ```

  More information from the [official Rust docs](https://doc.rust-lang.org/reference/visibility-and-privacy.html) regarding public/private methods.

3. Separate `impl` block  

  Another way of not exporting methods is by having a separate `impl Contract` section, that is not marked with `#[near]`.

  ```rust
  #[near]
  impl Contract {
      pub fn increment(&mut self) {
          self.internal_increment();
      }
  }
  impl Contract {
      /// This methods is still not exported.
      pub fn internal_increment(&mut self) {
          self.counter += 1;
      }
  }
  ```

'''
'''--- docs/sdk/rust/contract-interface/public-methods.md ---
---
sidebar_position: 1
---

# Public Method Types

Methods can be called externally by using the `pub` identifier within the [`#[near]` macro](../contract-structure/near-bindgen.md) which will expose the method in the compiled WASM bytecode.

It is important to only mark methods that should be called externally as public. If you need a contract to call itself, you can mark the function as public but add the [`#[private]` annotation](private-methods.md) so that it will panic if called from anything but the contract itself.

A basic usage of this would look like the following:

```rust
#[near]
impl MyContractStructure {
    pub fn some_method(&mut self) {
        // .. method logic here
    }
}
```

Where this would expose `some_method` from the WASM binary and allow it to be called externally.

<details>
  <summary>Expand to see generated code</summary>

```rust
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn some_method() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic("Method some_method doesn\'t accept deposit".as_bytes());
    }
    let mut contract: MyContractStructure = near_sdk::env::state_read().unwrap_or_default();
    contract.some_method();
    near_sdk::env::state_write(&contract);
}
```
</details>

## Exposing trait implementations

Functions can also be exposed through trait implementations. This can be useful if implementing a shared interface or standard for a contract. This code generation is handled very similarly to basic `pub` functions, but the `#[near]` macro only needs to be attached to the trait implementation, not the trait itself:

```rust
pub trait MyTrait {
    fn trait_method(&mut self);
}

#[near]
impl MyTrait for MyContractStructure {
    fn trait_method(&mut self) {
        // .. method logic here
    }
}
```

In this example, the generated code will be the same as the previous example, except with a different method name.

<details>
  <summary>Expand to see generated code</summary>

```rust
#[cfg(target_arch = "wasm32")]
#[no_mangle]
pub extern "C" fn trait_method() {
    near_sdk::env::setup_panic_hook();
    if near_sdk::env::attached_deposit() != 0 {
        near_sdk::env::panic("Method trait_method doesn\'t accept deposit".as_bytes());
    }
    let mut contract: MyContractStructure = near_sdk::env::state_read().unwrap_or_default();
    contract.trait_method();
    near_sdk::env::state_write(&contract);
}
```
</details>

'''
'''--- docs/sdk/rust/contract-interface/serialization-interface.md ---
---
sidebar_position: 5
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {Github} from "@site/src/components/codetabs";

# Serialization Protocols

Serialization formats within the SDK define how data structures are translated into bytes which are needed for passing data into methods of the smart contract or storing data in state. For the case of method parameters, [JSON](https://www.json.org/json-en.html) (default) and [Borsh](https://borsh.io/) are supported with the SDK and for storing data on-chain Borsh is used.

The qualities of JSON and Borsh are as follows:

JSON:
- Human-readable
- Self-describing format (don't need to know the underlying type)
- Easy interop with JavaScript
- Less efficient size and (de)serialization

Borsh:
- Compact, binary format that's efficient for serialized data size
- Need to know data format or have a schema to deserialize data
- Strict and canonical binary representation
- Fast and less overhead in most cases

In general, JSON will be used for contract calls and cross-contract calls for a better DevX, where Borsh can be used to optimize using less gas by having smaller parameter serialization and less deserialization computation within the contract.

### Overriding Serialization Protocol Default

The result and parameter serialization can be opted into separately, but all parameters must be of the same format (can't serialize some parameters as borsh and others as JSON). An example of switching both the result and parameters to borsh is as follows:

```rust
#[result_serializer(borsh)]
pub fn sum_borsh(#[serializer(borsh)] a: u32, #[serializer(borsh)] b: u32) -> u32 {
    a + b
}
```

Where the `result_serializer(borsh)` annotation will override the default result serialization protocol from JSON to borsh and the `serializer(borsh)` annotations will override the parameter serialization.

#### Example

A simple demonstration of getting a [Borsh-serialized](https://borsh.io), base64-encoded value from a unit test:

<Github language="rust" start="93" end="104" url="https://github.com/mikedotexe/rust-status-message/blob/b83c5126fdbe0f19bc904e547fda0bb12c2ea133/src/lib.rs" />

The following snippet shows a simple function that takes this value from a frontend or CLI. Note: this method doesn't have a return value, so the `#[result_serializer(borsh)]` isn't needed.

<Github language="rust" start="40" end="42" url="https://github.com/mikedotexe/rust-status-message/blob/b83c5126fdbe0f19bc904e547fda0bb12c2ea133/src/lib.rs" />

Note that this is using this simple struct:

<Github language="rust" start="13" end="17" url="https://github.com/mikedotexe/rust-status-message/blob/b83c5126fdbe0f19bc904e547fda0bb12c2ea133/src/lib.rs" />

To call this with NEAR CLI, use a command similar to this:

<Tabs className="language-tabs" groupId="code-tabs">
<TabItem value="near-cli">

```bash
near call rust-status-message.demo.testnet set_status_borsh --base64 'DAAAAEFsb2hhIGhvbnVhIQ==' --accountId demo.testnet
```
</TabItem>
<TabItem value="near-cli-rs">

```bash
near contract call-function as-transaction rust-status-message.demo.testnet set_status_borsh base64-args 'DAAAAEFsb2hhIGhvbnVhIQ==' prepaid-gas '30 TeraGas' attached-deposit '0 NEAR' sign-as demo.testnet network-config testnet sign-with-keychain send
```
</TabItem>
</Tabs>

See more details in [this GitHub gist](https://gist.github.com/mfornet/d8a94af333a68d67affd8cb78464c7c0) from [Marcelo](https://gist.github.com/mfornet).

### JSON wrapper types

To help with serializing certain types to JSON which have unexpected or inefficient default formats, there are some wrapper types in [`near_sdk::json_types`](https://docs.rs/near-sdk/3.1.0/near_sdk/json_types/index.html) that can be used.

Because JavaScript only supports integers to value `2^53 - 1`, you will lose precision if deserializing the JSON integer is above this range. To counteract this, you can use the `I64`, `U64`, `I128`, and `U128` in place of the native types for these parameters or result to serialize the value as a string. By default, all integer types will serialize as an integer in JSON.

You can convert from `U64` to `u64` and back using `std::convert::Into`, e.g.

```rust
#[near]
impl Contract {
    pub fn mult(&self, a: U64, b: U64) -> U128 {
        let a: u64 = a.into();
        let b: u64 = b.into();
        let product = u128::from(a) * u128::from(b);
        product.into()
    }
}
```

You can also access inner values and using `.0`:

```diff
 #[near]
 impl Contract {
     pub fn mult(&self, a: U64, b: U64) -> U128 {
-        let a: u64 = a.into();
+        let a = a.0;
-        let b: u64 = b.into();
+        let b = b.0;
         let product = u128::from(a) * u128::from(b);
         product.into()
     }
 }
```

And you can cast the lower-case `u` variants to upper-case `U` variants using `U64(...)` and `U128(...)`:

```diff
 #[near]
 impl Contract {
     pub fn mult(&self, a: U64, b: U64) -> U128 {
         let a = a.0;
         let b = b.0;
         let product = u128::from(a) * u128::from(b);
-        product.into()
+        U128(product)
     }
 }
```

Combining it all:

```rust
#[near]
impl Contract {
    pub fn mult(&self, a: U64, b: U64) -> U128 {
        U128(u128::from(a.0) * u128::from(b.0))
    }
}
```

Although there are these JSON wrapper types included with the SDK, any custom type can be used, as long as it implements [`serde`](https://serde.rs/) serialize and deserialize respectively. All of these types just override the JSON format and will have a consistent `borsh` serialization and deserialization as the inner types.

### Base64VecU8

Another example of a type you may want to override the default serialization of is `Vec<u8>` which represents bytes in Rust. By default, this will serialize as an array of integers, which is not compact and very hard to use. There is a wrapper type [`Base64VecU8`](https://docs.rs/near-sdk/3.1.0/near_sdk/json_types/struct.Base64VecU8.html) which serializes and deserializes to a [Base-64](https://en.wikipedia.org/wiki/Base64) string for more compact JSON serialization.

Example here:

```rust
#[near(contract_state)]
#[derive(PanicOnDefault)]
pub struct Contract {
    // Notice, internally we store `Vec<u8>` 
    pub data: Vec<u8>,
}

#[near]
impl Contract {
    #[init]
    pub fn new(data: Base64VecU8) -> Self {
        Self {
            data: data.into(),
        }
    }
    pub fn get_data(self) -> Base64VecU8 {
        self.data.into()
    }
}
```

'''
'''--- docs/sdk/rust/contract-structure/collections.md ---
---
sidebar_position: 2
---

# Collections

When deciding on data structures to use for the data of the application, it is important to minimize the amount of data read and written to storage but also the amount of data serialized and deserialized to minimize the cost of transactions. It is important to understand the tradeoffs of data structures in your smart contract because it can become a bottleneck as the application scales and migrating the state to the new data structures will come at a cost.

The collections within `near-sdk` are designed to split the data into chunks and defer reading and writing to the store until needed. These data structures will handle the low-level storage interactions and aim to have a similar API to the [`std::collections`](https://doc.rust-lang.org/std/collections/index.html).

:::info Note

The `near_sdk::collections` will be moving to `near_sdk::store` and have updated APIs. If you would like to access these updated structures as they are being implemented, enable the `unstable` feature on `near-sdk`.

:::

It is important to keep in mind that when using `std::collections`, that each time state is loaded, all entries in the data structure will be read eagerly from storage and deserialized. This will come at a large cost for any non-trivial amount of data, so to minimize the amount of gas used the SDK collections should be used in most cases.

The most up to date collections and their documentation can be found [in the rust docs](https://docs.rs/near-sdk/latest/near_sdk/collections/index.html).
<!-- TODO include/update link for store module to replace collections mod when docs updated -->

The following data structures that exist in the SDK are as follows:

| SDK collection                        | `std`&nbsp;equivalent           | Description |
| ------------------------------------- | ------------------------------- | ------------|
| `LazyOption<T>`                       | `Option<T>`      | Optional value in storage. This value will only be read from storage when interacted with. This value will be `Some<T>` when the value is saved in storage, and `None` if the value at the prefix does not exist. |
| `Vector<T>`                           | `Vec<T>`         | A growable array type. The values are sharded in memory and can be used for iterable and indexable values that are dynamically sized. |
| <code>LookupMap`<K,&nbsp;V>`</code>     | <code>HashMap`<K,&nbsp;V>`</code>  | This structure behaves as a thin wrapper around the key-value storage available to contracts. This structure does not contain any metadata about the elements in the map, so it is not iterable. |
| <code>UnorderedMap`<K,&nbsp;V>`</code>  | <code>HashMap`<K,&nbsp;V>`</code>  | Similar to `LookupMap`, except that it stores additional data to be able to iterate through elements in the data structure. |
| <code>TreeMap`<K,&nbsp;V>`</code>       | <code>BTreeMap`<K,&nbsp;V>`</code> | An ordered equivalent of `UnorderedMap`. The underlying implementation is based on an [AVL tree](https://en.wikipedia.org/wiki/AVL_tree). This structure should be used when a consistent order is needed or accessing the min/max keys is needed. |
| `LookupSet<T>`                        | `HashSet<T>`                     | A set, which is similar to `LookupMap` but without storing values, can be used for checking the unique existence of values. This structure is not iterable and can only be used for lookups. |
| `UnorderedSet<T>`                     | `HashSet<T>`                     | An iterable equivalent of `LookupSet` which stores additional metadata for the elements contained in the set. |

## In-memory `HashMap` vs persistent `UnorderedMap`

- `HashMap` keeps all data in memory. To access it, the contract needs to deserialize the whole map.
- `UnorderedMap` keeps data in persistent storage. To access an element, you only need to deserialize this element.

Use `HashMap` in case:

- Need to iterate over all elements in the collection **in one function call**.
- The number of elements is small or fixed, e.g. less than 10.

Use `UnorderedMap` in case:

- Need to access a limited subset of the collection, e.g. one or two elements per call.
- Can't fit the collection into memory.

The reason is `HashMap` deserializes (and serializes) the entire collection in one storage operation.
Accessing the entire collection is cheaper in gas than accessing all elements through `N` storage operations.

Example of `HashMap`:

```rust
/// Using Default initialization.
#[near(contract_state)]
#[derive(Default)]
pub struct Contract {
    pub status_updates: HashMap<AccountId, String>,
}

#[near]
impl Contract {
    pub fn set_status(&mut self, status: String) {
        self.status_updates.insert(env::predecessor_account_id(), status);
        assert!(self.status_updates.len() <= 10, "Too many messages");
    }

    pub fn clear(&mut self) {
        // Effectively iterating through all removing them.
        self.status_updates.clear();
    }

    pub fn get_all_updates(self) -> HashMap<AccountId, String> {
        self.status_updates
    }
}
```

Example of `UnorderedMap`:

```rust
#[near(contract_state)]
#[derive(PanicOnDefault)]
pub struct Contract {
    pub status_updates: UnorderedMap<AccountId, String>,
}

#[near]
impl Contract {
    #[init]
    pub fn new() -> Self {
        // Initializing `status_updates` with unique key prefix.
        Self {
            status_updates: UnorderedMap::new(b"s".to_vec()),
        }
    }

    pub fn set_status(&mut self, status: String) {
        self.status_updates.insert(&env::predecessor_account_id(), &status);
        // Note, don't need to check size, since `UnorderedMap` doesn't store all data in memory.
    }

    pub fn delete_status(&mut self) {
        self.status_updates.remove(&env::predecessor_account_id());
    }

    pub fn get_status(&self, account_id: AccountId) -> Option<String> {
        self.status_updates.get(&account_id)
    }
}
```

## Error prone patterns

Because the values are not kept in memory and are lazily loaded from storage, it's important to make sure if a collection is replaced or removed, that the storage is cleared. In addition, it is important that if the collection is modified, the collection itself is updated in state because most collections will store some metadata.

Some error-prone patterns to avoid that cannot be restricted at the type level are:

```rust
use near_sdk::store::UnorderedMap;

let mut m = UnorderedMap::<u8, String>::new(b"m");
m.insert(1, "test".to_string());
assert_eq!(m.len(), 1);
assert_eq!(m.get(&1), Some(&"test".to_string()));

// Bug 1: Should not replace any collections without clearing state, this will reset any
// metadata, such as the number of elements, leading to bugs. If you replace the collection
// with something with a different prefix, it will be functional, but you will lose any
// previous data and the old values will not be removed from storage.
m = UnorderedMap::new(b"m");
assert!(m.is_empty());
assert_eq!(m.get(&1), Some(&"test".to_string()));

// Bug 2: Should not use the same prefix as another collection
// or there will be unexpected side effects.
let m2 = UnorderedMap::<u8, String>::new(b"m");
assert!(m2.is_empty());
assert_eq!(m2.get(&1), Some(&"test".to_string()));

// Bug 3: forgetting to save the collection in storage. When the collection is attached to
// the contract state (`self` in `#[near]`) this will be done automatically, but if
// interacting with storage manually or working with nested collections, this is relevant.
use near_sdk::store::Vector;

// Simulate roughly what happens during a function call that initializes state.
{
    let v = Vector::<u8>::new(b"v");
    near_sdk::env::state_write(&v);
}

// Simulate what happens during a function call that just modifies the collection
// but does not store the collection itself.
{
    let mut v: Vector<u8> = near_sdk::env::state_read().unwrap();
    v.push(1);
    // The bug is here that the collection itself if not written back
}

let v: Vector<u8> = near_sdk::env::state_read().unwrap();
// This will report as if the collection is empty, even though the element exists
assert!(v.get(0).is_none());
assert!(
    near_sdk::env::storage_read(&[b"v".as_slice(), &0u32.to_le_bytes()].concat()).is_some()
);

// Bug 4 (only relevant for `near_sdk::store`): These collections will cache writes as well
// as reads, and the writes are performed on [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html)
// so if the collection is kept in static memory or something like `std::mem::forget` is used,
// the changes will not be persisted.
use near_sdk::store::LookupSet;

let mut m: LookupSet<u8> = LookupSet::new(b"l");
m.insert(1);
assert!(m.contains(&1));

// This would be the fix, manually flushing the intermediate changes to storage.
// m.flush();
std::mem::forget(m);

m = LookupSet::new(b"l");
assert!(!m.contains(&1));
```

## Pagination with persistent collections

Persistent collections such as `UnorderedMap`, `UnorderedSet` and `Vector` may
contain more elements than the amount of gas available to read them all.
In order to expose them all through view calls, we can use pagination.

This can be done using iterators with [`Skip`](https://doc.rust-lang.org/std/iter/struct.Skip.html) and [`Take`](https://doc.rust-lang.org/std/iter/struct.Take.html). This will only load elements from storage within the range.

Example of pagination for `UnorderedMap`:

```rust
#[near(contract_state)]
#[derive(PanicOnDefault)]
pub struct Contract {
    pub status_updates: UnorderedMap<AccountId, String>,
}

#[near]
impl Contract {
    /// Retrieves multiple elements from the `UnorderedMap`.
    /// - `from_index` is the index to start from.
    /// - `limit` is the maximum number of elements to return.
    pub fn get_updates(&self, from_index: usize, limit: usize) -> Vec<(AccountId, String)> {
        self.status_updates
            .iter()
            .skip(from_index)
            .take(limit)
            .collect()
    }
}
```

## `LookupMap` vs `UnorderedMap`

### Functionality

- `UnorderedMap` supports iteration over keys and values, and also supports pagination. Internally, it has the following structures:
    - a map from a key to an index
    - a vector of keys
    - a vector of values
- `LookupMap` only has a map from a key to a value. Without a vector of keys, it doesn't have the ability to iterate over keys.

### Performance

`LookupMap` has a better performance and stores less data compared to `UnorderedMap`.

- `UnorderedMap` requires `2` storage reads to get the value and `3` storage writes to insert a new entry.
- `LookupMap` requires only one storage read to get the value and only one storage write to store it.

### Storage space

`UnorderedMap` requires more storage for an entry compared to a `LookupMap`.

- `UnorderedMap` stores the key twice (once in the first map and once in the vector of keys) and value once. It also has a higher constant for storing the length of vectors and prefixes.
- `LookupMap` stores key and value once.

## `LazyOption`

It's a type of persistent collection that only stores a single value.
The goal is to prevent a contract from deserializing the given value until it's needed.
An example can be a large blob of metadata that is only needed when it's requested in a view call,
but not needed for the majority of contract operations.

It acts like an `Option` that can either hold a value or not and also requires a unique prefix (a key in this case)
like other persistent collections.

Compared to other collections, `LazyOption` only allows you to initialize the value during initialization.

```rust
#[near(contract_state)]
#[derive(PanicOnDefault)]
pub struct Contract {
    pub metadata: LazyOption<Metadata>,
}

#[near(serializers=[borsh, json])]
pub struct Metadata {
    data: String,
    image: Base64Vec,
    blobs: Vec<String>,
}

#[near]
impl Contract {
    #[init]
    pub fn new(metadata: Metadata) -> Self {
        Self {
            metadata: LazyOption::new(b"m", Some(metadata)),
        }
    }

    pub fn get_metadata(&self) -> Metadata {
        // `.get()` reads and deserializes the value from the storage. 
        self.metadata.get().unwrap()
    }
}
```

'''
'''--- docs/sdk/rust/contract-structure/near-bindgen.md ---
---
sidebar_position: 1
---

# near

The `#[near]` macro is used on a `struct` and the function implementations to generate the necessary code to be a valid NEAR contract and expose the intended functions to be able to be called externally.

For example, on a simple counter contract, the macro will be applied as such:

```rust
use near_sdk::near;

#[near(contract_state)]
#[derive(Default)]
pub struct Counter {
    value: u64,
}

#[near]
impl Counter {
    pub fn increment(&mut self) {
        self.value += 1;
    }

    pub fn get_count(&self) -> u64 {
        self.value
    }
}
```

In this example, the `Counter` struct represents the smart contract state and anything that implements `BorshSerialize` and `BorshDeserialize` can be included, even `collections`, which will be covered in the next section. Whenever a function is called, the state will be loaded and deserialized, so it's important to keep this amount of data loaded as minimal as possible.

`#[near]` also annotates the `impl` for `Counter` and this will generate any necessary boilerplate to expose the functions. The core interactions that are important to keep in mind:
- Any `pub` functions will be callable externally from any account/contract.
  - For more information, see [public methods](../contract-interface/public-methods.md)
- `self` can be used in multiple ways to control the [mutability of the contract](../contract-interface/contract-mutability.md):
  - Functions that take `&self` or `self` will be read-only and do not write the updated state to storage
  - Functions that take `&mut self` allow for mutating state, and state will always be written back at the end of the function call
- Exposed functions can omit reading and writing to state if `self` is not included in the function params
  - This can be useful for some static functionality or returning data embedded in the contract code
- If the function has a return value, it will be serialized and attached as a result through `env::value_return`

## Initialization Methods

By default, the `Default::default()` implementation of a contract will be used to initialize a contract. There can be a custom initialization function which takes parameters or performs custom logic with the following `#[init]` annotation:

```rust
#[near]
impl Counter {
    #[init]
    pub fn new(value: u64) -> Self {
        log!("Custom counter initialization!");
        Self { value }
    }
}
```

All contracts are expected to implement `Default`. If you would like to prohibit the default implementation from being used, the `PanicOnDefault` derive macro can be used:

```rust
#[near(contract_state)]
#[derive(PanicOnDefault)]
pub struct Counter {
    // ...
}
```

## Payable Methods

Methods can be annotated with `#[payable]` to allow tokens to be transferred with the method invocation. For more information, see [payable methods](../contract-interface/payable-methods.md).

To declare a function as payable, use the `#[payable]` annotation as follows:

```rust
#[payable]
pub fn my_method(&mut self) {
...
}
```

## Private Methods

Some methods need to be exposed to allow the contract to call a method on itself through a promise, but want to disallow any other contract to call it. For this, use the `#[private]` annotation to panic when this method is called externally. See [private methods](../contract-interface/private-methods.md) for more information.

This annotation can be applied to any method through the following:

```rust
#[private]
pub fn my_method(&mut self) {
...
}
```

:::info Interaction with other macros

When `near` is built for the wasm32 target, it generates the external NEAR contract bindings.  To achieve this it is actually generating another function with the signature `pub extern "C" fn function_name()` that first deserializes the contract struct from NEAR storage and then calls the `contract.function_name(parameter1, parameter2, ...)`.  If you have annotated your function with any attribute-like macros, these are then executed _twice_.  Specifically if the attribute like macro makes any modification to the function signature, or inserts any code that depends on the contract struct (in the form of `&self`, `&mut self`, or `self`) this will fail in the second invocation, because the externally exposed function does not have any concept of this struct.  It is possible to detect this by checking which build target you are building for and limit the execution of the macro to operate only on the first pass.

:::

'''
'''--- docs/sdk/rust/contract-structure/nesting.md ---
---
sidebar_position: 3
---

# Collections Nesting

## Traditional approach for unique prefixes

Hardcoded prefixes in the constructor using a short one letter prefix that was converted to a vector of bytes.
When using nested collection, the prefix must be constructed manually.

```rust
use near_sdk::borsh::{self};
use near_sdk::collections::{UnorderedMap, UnorderedSet};
use near_sdk::{near, AccountId};

#[near(contract_state)]
pub struct Contract {
    pub accounts: UnorderedMap<AccountId, UnorderedSet<String>>,
}

impl Default for Contract {
    fn default() -> Self {
        Self {
            accounts: UnorderedMap::new(b"t"),
        }
    }
}

#[near]
impl Contract {
    pub fn get_tokens(&self, account_id: &AccountId) -> Vec<String> {
        let tokens = self.accounts.get(account_id).unwrap_or_else(|| {
            // Constructing a unique prefix for a nested UnorderedSet from a concatenation
            // of a prefix and a hash of the account id.
            let prefix: Vec<u8> = [
                b"s".as_slice(),
                &near_sdk::env::sha256_array(account_id.as_bytes()),
            ]
            .concat();
            UnorderedSet::new(prefix)
        });
        tokens.to_vec()
    }
}
```

## Generating unique prefixes for persistent collections

Read more about persistent collections [from this documentation](../contract-structure/collections.md) or from [the Rust docs](https://docs.rs/near-sdk/latest/near_sdk/collections).

Every instance of a persistent collection requires a unique storage prefix.
The prefix is used to generate internal keys to store data in persistent storage.
These internal keys need to be unique to avoid collisions (including collisions with key `STATE`).

When a contract gets complicated, there may be multiple different
collections that are not all part of the main structure, but instead part of a sub-structure or nested collections.
They all need to have unique prefixes.

We can introduce an `enum` for tracking storage prefixes and keys.
And then use borsh serialization to construct a unique prefix for every collection.
It's as efficient as manually constructing them, because with Borsh serialization, an enum only takes one byte.

```rust
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{UnorderedMap, UnorderedSet};
use near_sdk::{env, near, AccountId, BorshStorageKey, CryptoHash};

#[near(contract_state)]
pub struct Contract {
    pub accounts: UnorderedMap<AccountId, UnorderedSet<String>>,
}

impl Default for Contract {
    fn default() -> Self {
        Self {
            accounts: UnorderedMap::new(StorageKeys::Accounts),
        }
    }
}

#[near(serializers = [borsh])]
pub enum StorageKeys {
    Accounts,
    SubAccount { account_hash: CryptoHash },
}

#[near]
impl Contract {
    pub fn get_tokens(&self, account_id: &AccountId) -> Vec<String> {
        let tokens = self.accounts.get(account_id).unwrap_or_else(|| {
            UnorderedSet::new(StorageKeys::SubAccount {
                account_hash: env::sha256_array(account_id.as_bytes()),
            })
        });
        tokens.to_vec()
    }
}
```

## Error prone patterns

By extension of the error-prone patterns to avoid mentioned in the [collections section](./collections.md#error-prone-patterns), it is important to keep in mind how these bugs can easily be introduced into a contract when using nested collections.

Some issues for more context:
- https://github.com/near/near-sdk-rs/issues/560
- https://github.com/near/near-sdk-rs/issues/703

The following cases are the most commonly encountered bugs that cannot be restricted at the type level:

```rust
use near_sdk::borsh::{self, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedSet};
use near_sdk::BorshStorageKey;

#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    Root,
    Nested(u8),
}

// Bug 1: Nested collection is removed without clearing it's own state.
let mut root: LookupMap<u8, UnorderedSet<String>> = LookupMap::new(StorageKey::Root);
let mut nested = UnorderedSet::new(StorageKey::Nested(1));
nested.insert(&"test".to_string());
root.insert(&1, &nested);

// Remove inserted collection without clearing it's sub-state.
let mut _removed = root.remove(&1).unwrap();

// This line would fix the bug:
// _removed.clear();

// This collection will now be in an inconsistent state if an empty UnorderedSet is put
// in the same entry of `root`.
root.insert(&1, &UnorderedSet::new(StorageKey::Nested(1)));
let n = root.get(&1).unwrap();
assert!(n.is_empty());
assert!(n.contains(&"test".to_string()));

// Bug 2 (only relevant for `near_sdk::collections`, not `near_sdk::store`): Nested
// collection is modified without updating the collection itself in the outer collection.
//
// This is fixed at the type level in `near_sdk::store` because the values are modified
// in-place and guarded by regular Rust borrow-checker rules.
root.insert(&2, &UnorderedSet::new(StorageKey::Nested(2)));

let mut nested = root.get(&2).unwrap();
nested.insert(&"some value".to_string());

// This line would fix the bug:
// root.insert(&2, &nested);

let n = root.get(&2).unwrap();
assert!(n.is_empty());
assert!(n.contains(&"some value".to_string()));
```

'''
'''--- docs/sdk/rust/cross-contract/callbacks.md ---
---
sidebar_position: 2
---

# Callbacks

NEAR Protocol is a sharded, proof-of-stake blockchain that behaves differently than proof-of-work blockchains. When interacting with a native Rust (compiled to Wasm) smart contract, cross-contract calls are asynchronous. Callbacks are used to either get the result of a cross-contract call or tell if a cross-contract call has succeeded or failed.

There are two techniques to write cross-contract calls: [high-level](https://github.com/near/near-sdk-rs/blob/master/examples/cross-contract-calls/high-level/src/lib.rs) and [low-level](https://github.com/near/near-sdk-rs/blob/master/examples/cross-contract-calls/low-level/src/lib.rs). This document will mostly focus on the high-level approach. There are two examples in the Rust SDK repository that demonstrate these, as linked above. Note that these examples use cross-contract calls "to itself." We'll show two examples demonstrating the high-level approach.

## Calculator example

There is a helper macro that allows you to make cross-contract calls with the syntax `#[ext_contract(...)]`. It takes a Rust Trait and converts it to a module with static methods. Each of these static methods takes positional arguments defined by the Trait, then the `receiver_id`, the attached deposit and the amount of gas and returns a new `Promise`.

:::info

If the function returns the promise, then it will delegate the return value and status of transaction execution, but if you return a unit type (`()`, `void`, `nothing`), then the `Promise` result will not influence the transaction status.

:::

For example, let's define a calculator contract Trait:

```rust
#[ext_contract(ext_calculator)]
trait Calculator {
    fn mult(&self, a: U64, b: U64) -> U128;

    fn sum(&self, a: U128, b: U128) -> U128;
}
```

It's equivalent to the following code:

```rust
mod ext_calculator {
    pub fn mult(a: U64, b: U64, receiver_id: &AccountId, deposit: Balance, gas: Gas) -> Promise {
        Promise::new(receiver_id.clone())
            .function_call(
                b"mult",
                json!({ "a": a, "b": b }).to_string().as_bytes(),
                deposit,
                gas,
            )
    }

    pub fn sum(a: U128, b: U128, receiver_id: &AccountId, deposit: Balance, gas: Gas) -> Promise {
        // ...
    }
}
```

Let's assume the calculator is deployed on `calc.near`, we can use the following:

```rust
#[near]
impl Contract {
    pub fn sum_a_b(&mut self, a: U128, b: U128) -> Promise {
        let calculator_account_id: AccountId = "calc.near".parse().unwrap();
        // Call the method `sum` on the calculator contract.
        // Any unused GAS will be attached since the default GAS weight is 1.
        // Attached deposit is defaulted to 0.
        ext_calculator::ext(calculator_account_id)
            .sum(a, b)
    }
}
```

## Allowlist example

Next we'll look at a simple cross-contract call that is made to an allowlist smart contract, returning whether an account is in the list or not.

The common pattern with cross-contract calls is to call a method on an external smart contract, use `.then` syntax to specify a callback, and then retrieve the result or status of the promise. The callback will typically live inside the same, calling smart contract. There's a special macro used for the callback function, which is [#[private]](https://docs.rs/near-sdk-core/latest/near_sdk_core/struct.AttrSigInfo.html#structfield.is_private). We'll see this pattern in the example below.

The following example demonstrates two common approaches to callbacks using the high-level cross-contract approach. When writing high-level cross-contract calls, special [traits](https://doc.rust-lang.org/rust-by-example/trait.html) are set up as interfaces for the smart contract being called.

```rust
#[ext_contract(ext_allowlist)]
pub trait ExtAllowlist {
    fn is_allowlisted(staking_pool_account_id: AccountId) -> bool;
}
```

After creating the trait, we'll show two simple functions that will make a cross-contract call to an allowlist smart contract, asking if the account `mike.testnet` is allowlisted. These methods will both return `true` using different approaches. First we'll look at the methods, then we'll look at the differences in callbacks. Note that for simplicity in this example, the values are hardcoded.

```rust
pub const XCC_GAS: Gas = Gas(20_000_000_000_000);
fn get_allowlist_contract() -> AccountId {
    "allowlist.demo.testnet".parse().unwrap()
}
fn get_account_to_check() -> AccountId {
    "mike.testnet".parse().unwrap()
}
```

```rust
#[near]
impl Contract {
    pub fn xcc_use_promise_result() -> Promise {
        // Call the method `is_allowlisted` on the allowlisted contract. Static GAS is only attached to the callback.
        // Any unused GAS will be split between the function call and the callback since both have a default unused GAS weight of 1
        // Attached deposit is defaulted to 0 for both the function call and the callback.
        ext_allowlist::ext(get_allowlist_contract())
            .is_allowlisted(get_account_to_check())
            .then(
                Self::ext(env::current_account_id())
                .with_static_gas(XCC_GAS)
                .callback_promise_result()
            )
    }

    pub fn xcc_use_arg_macro(&mut self) -> Promise {
        // Call the method `is_allowlisted` on the allowlisted contract. Attach static GAS equal to XCC_GAS only for the callback.
        // Any unused GAS will be split between the function call and the callback since both have a default unused GAS weight of 1
        // Attached deposit is defaulted to 0 for both the function call and the callback.
        ext_allowlist::ext(get_allowlist_contract())
            .is_allowlisted(get_account_to_check())
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(XCC_GAS)
                    .callback_arg_macro()
            )
    }
```

The syntax begins with `ext_allowlist::ext()` showing that we're using the trait to call the method on the account passed into `ext()`. We then use `with_static_gas()` to specify a base amount of GAS to attach to the call. We then call the method `is_allow_listed()` and pass in the parameters we'd like to attach.

There are a couple things to note when doing these function calls:
1. You can attach a deposit of ‚ìÉ, in yocto‚ìÉ to the call by specifying the `.with_attached_deposit()` method but it is defaulted to 0 (1 ‚ìÉ = 1000000000000000000000000 yocto‚ìÉ, or 1^24 yocto‚ìÉ).
2. You can attach a static amount of GAS by specifying the `.with_static_gas()` method but it is defaulted to 0.
3. You can attach an unused GAS weight by specifying the `.with_unused_gas_weight()` method but it is defaulted to 1. The unused GAS will be split amongst all the functions in the current execution depending on their weights. If there is only 1 function, any weight above 1 will result in all the unused GAS being attached to that function. If you specify a weight of 0, however, the unused GAS will **not** be attached to that function. If you have two functions, one with a weight of 3, and one with a weight of 1, the first function will get `3/4` of the unused GAS and the other function will get `1/4` of the unused GAS.

The two methods in the snippet above are very similar, except they will call separate callbacks in the smart contract, `callback_promise_result` and `callback_arg_macro`. These two callbacks show how a value can be obtained. 

```rust
#[private]
pub fn callback_arg_macro(#[callback_unwrap] val: bool) -> bool {
    val
}

#[private]
pub fn callback_promise_result() -> bool {
    assert_eq!(env::promise_results_count(), 1, "ERR_TOO_MANY_RESULTS");
    match env::promise_result(0) {
        PromiseResult::NotReady => unreachable!(),
        PromiseResult::Successful(val) => {
            if let Ok(is_allowlisted) = near_sdk::serde_json::from_slice::<bool>(&val) {
                is_allowlisted
            } else {
                env::panic_str("ERR_WRONG_VAL_RECEIVED")
            }
        },
        PromiseResult::Failed => env::panic_str("ERR_CALL_FAILED"),
    }
}
```

The first method uses a macro on the argument to cast the value into what's desired. In this approach, if the value is unable to be casted, it will panic. If you'd like to gracefully handle the error, you can either use the first approach, or use the `#[callback_result]` macro instead. An example of this can be seen below.

```rust
#[private]
pub fn handle_callbacks(
    // New pattern, will gracefully handle failed callback results
    #[callback_result] b: Result<u8, near_sdk::PromiseError>,
) {
    if b.is_err() {
        // ...
    }
}
```

The second method gets the value from the promise result and is essentially the expanded version of the `#[callback_result]` macro.

And that's it! Understanding how to make a cross-contract call and receive a result is an important part of developing smart contracts on NEAR. Two interesting references for using cross-contract calls can be found in the [fungible token](https://github.com/near-examples/FT) and [non-fungible token](https://github.com/near-examples/NFT) examples.

'''
'''--- docs/sdk/rust/intro.md ---
---
id: get-started
---

# Getting Started

## Install Rust and Wasm toolchain

Follow [these instructions](https://doc.rust-lang.org/book/ch01-01-installation.html) for setting up Rust.

To install Rust on Linux or MacOS, use the following command:

```bash
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh

source $HOME/.cargo/env
```

Then, add the `wasm32-unknown-unknown` toolchain. This toolchain is required because the contracts that we will build will be compiled to [Wasm](https://webassembly.org/) to run on the NEAR blockchain.

```bash
rustup target add wasm32-unknown-unknown
```

## Create a new project

The best way to create a new NEAR app connected with a frontend is through [create-near-app](https://github.com/near/create-near-app). When initializing the project, your option are `npx create-near-app <projectName> [--frontend next|vanilla|none] [--contract rs|ts|none --tests rs|ts|none]`. 

```bash
npx create-near-app my-project --contract rs --frontend none --tests rs
```

If you only wish to develop and deploy a Rust contract, the [status message example](https://github.com/near-examples/rust-status-message) is great to use as a template or through [cargo-generate](https://github.com/cargo-generate/cargo-generate).

To initialize a new project with `cargo-generate`, run the following commands:

```bash
cargo install cargo-generate --features vendored-openssl

cargo generate --git https://github.com/near-examples/rust-status-message --name my-project
cd my-project
```

If you would like to generate a new crate manually with `cargo new --lib <crate-name>`, make sure you include the following configuration in the generated `Cargo.toml`:

```toml
[dependencies]
near-sdk = "4.0.0"

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
```

'''
'''--- docs/sdk/rust/promises/create-account.md ---
---
sidebar_position: 3
---

# Creating Accounts

You might want to create an account from a contract for many reasons. One example:
You want to [progressively onboard](https://www.youtube.com/watch?v=7mO4yN1zjbs&t=2s) users, hiding the whole concept of NEAR from them at the beginning, and automatically create accounts for them (these could be sub-accounts of your main contract, such as `user123.some-cool-game.near`).

Since an account with no balance is almost unusable, you probably want to combine this with the token transfer from [the last page](./token-tx.md). You will also need to give the account an access key. Here's a way do it:

```rust
Promise::new("subaccount.example.near".parse().unwrap())
    .create_account()
    .add_full_access_key(env::signer_account_pk())
    .transfer(250_000_000_000_000_000_000_000); // 2.5e23yN, 0.25N
```

In the context of a full contract:

```rust
use near_sdk::{env, near, AccountId, Balance, Promise};

const INITIAL_BALANCE: Balance = 250_000_000_000_000_000_000_000; // 2.5e23yN, 0.25N

#[near(contract_state)]
pub struct Contract {}

#[near]
impl Contract {
    #[private]
    pub fn create_subaccount(prefix: AccountId) -> Promise {
        let subaccount_id = AccountId::new_unchecked(
          format!("{}.{}", prefix, env::current_account_id())
        );
        Promise::new(subaccount_id)
            .create_account()
            .add_full_access_key(env::signer_account_pk())
            .transfer(INITIAL_BALANCE)
    }
}
```

Things to note:

* `add_full_access_key` ‚Äì¬†This example passes in the public key of the human or app that signed the original transaction that resulted in this function call ([`signer_account_pk`](https://docs.rs/near-sdk/3.1.0/near_sdk/env/fn.signer_account_id.html)). You could also use [`add_access_key`](https://docs.rs/near-sdk/latest/near_sdk/struct.Promise.html#method.add_access_key) to add a Function Call access key that only permits the account to make calls to a predefined set of contract functions.
* `#[private]` ‚Äì if you have a function that spends your contract's funds, you probably want to protect it in some way. This example does so with a perhaps-too-simple [`#[private]`](../contract-interface/private-methods.md) macro.
* `INITIAL_BALANCE` uses the [`Balance`](https://docs.rs/near-sdk/3.1.0/near_sdk/type.Balance.html) type from near-sdk-rs. Today this is a simple alias for `u128`, but in the future may be expanded to have additional functionality, similar to recent [changes to the `Gas` type](https://github.com/near/near-sdk-rs/pull/471).

'''
'''--- docs/sdk/rust/promises/deploy-contract.md ---
---
sidebar_position: 4
---

# Deploying Contracts

You might want your smart contract to deploy subsequent smart contract code for a few reasons:

* The contract acts as a Factory, a pattern where a parent contract creates many child contracts ([Mintbase](https://www.mintbase.io/) does this to create a new NFT store for anyone who wants one; [Rainbow Bridge](https://near.org/bridge/) does this to deploy separate Fungible Token contracts for [each bridged token](https://github.com/aurora-is-near/rainbow-token-connector/blob/ce7640da144f000e0a93b6d9373bbc2514e37f3b/bridge-token-factory/src/lib.rs#L311-L341))
* The contract [updates its own code](../../../2.build/2.smart-contracts/release/upgrade.md#programmatic-update) (calls `deploy` on itself).
* You could implement a "contract per user" system that creates app-specific subaccounts for users (`your-app.user1.near`, `your-app.user2.near`, etc) and deploys the same contract to each. This is currently prohibitively expensive due to NEAR's [storage fees](https://docs.near.org/concepts/storage/storage-staking), but that may be optimized in the future. If it is, this sort of "sharded app design" may become the more scalable, user-centric approach to contract standards and app mechanics. An early experiment with this paradigm was called [Meta NEAR](https://github.com/metanear).

If your goal is to deploy to a subaccount of your main contract like Mintbase or the Rainbow Bridge, you will also need to create the account. So, combining concepts from the last few pages, here's what you need:

```rust
const CODE: &[u8] = include_bytes!("./path/to/compiled.wasm");

Promise::new("subaccount.example.near".parse().unwrap())
    .create_account()
    .add_full_access_key(env::signer_account_pk())
    .transfer(3_000_000_000_000_000_000_000_000) // 3e24yN, 3N
    .deploy_contract(CODE.to_vec())
```

Here's what a full contract might look like, showing a na√Øve way to pass `code` as an argument rather than hard-coding it with `include_bytes!`:

```rust
use near_sdk::{env, near AccountId, Balance, Promise};

const INITIAL_BALANCE: Balance = 3_000_000_000_000_000_000_000_000; // 3e24yN, 3N

#[near(contract_state)]
pub struct Contract {}

#[near]
impl Contract {
    #[private]
    pub fn create_child_contract(prefix: AccountId, code: Vec<u8>) -> Promise {
        let subaccount_id = AccountId::new_unchecked(
          format!("{}.{}", prefix, env::current_account_id())
        );
        Promise::new(subaccount_id)
            .create_account()
            .add_full_access_key(env::signer_account_pk())
            .transfer(INITIAL_BALANCE)
            .deploy_contract(code)
    }
}
```

Why is this a na√Øve approach? It could run into issues because of the 4MB transaction size limit ‚Äì the function above would deserialize and heap-allocate a whole contract. For many situations, the `include_bytes!` approach is preferable. If you really need to attach compiled Wasm as an argument, you might be able to copy the approach [used by Sputnik DAO v2](https://github.com/near-daos/sputnik-dao-contract/blob/a8fc9a8c1cbde37610e56e1efda8e5971e79b845/sputnikdao2/src/types.rs#L74-L142).

'''
'''--- docs/sdk/rust/promises/intro.md ---
---
sidebar_position: 1
sidebar_label: Introduction
pagination_label: "Promises: Introduction"
---

# Promises

Transactions can be sent asynchronously from a contract through a [`Promise`](https://docs.rs/near-sdk/latest/near_sdk/struct.Promise.html). Like Promises in many programming languages, these will cause code to be executed in the future. In the case of NEAR, this "in the future" means a transaction to be executed _in the next block_ (or thereabouts), rather than in the same block as the original function call.

You can implement any cross-contract workflow using Promises; they inhabit a middle-ground between the high-level and low-level approaches discussed in [the last section](../cross-contract/callbacks.md). See the full Promise docs, linked above, for details.

However, there are a few situations where Promises are uniquely capable, since these situations don't involve making function calls:

* Sending $NEAR
* Creating accounts
* Deploying contracts

:::info Why wait?
Why not do these things synchronously, in the same block when the function is called? Why does NEAR require a `Promise` for sending tokens, or creating an account, or deploying a contract?

They need to be scheduled in separate blocks since sender and receiver accounts can be on different shards, and cross-shard communication happens across blocks by passing receipts (you can think of receipts in NEAR as "internal transactions"). You can see these receipts being passed from block to block [in NEAR Explorer](https://nearblocks.io/txns/36n3tBNiF497Tm9mijEpsCUvejL8mBYF1CEWthCnY8FV).
:::
'''
'''--- docs/sdk/rust/promises/token-tx.md ---
---
sidebar_position: 2
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Sending $NEAR

You might want to send tokens from a contract for many reasons.

* The contract uses something like the [Storage Standard](https://nomicon.io/Standards/StorageManagement) and needs to return deposits to users when they unregister.
* Users pay into the contract and the contract later pays these fees to the maintainers, redistributes them to users, or disburses them to some cause the users vote on.
* And more!

Blockchains give us programmable money, and the ability for a smart contract to send tokens lies at the heart of that ability.

NEAR makes this easy. Transferring NEAR tokens is the simplest transaction you can send from a smart contract. Here's all you need:

```rust
let amount: u128 = 1_000_000_000_000_000_000_000_000; // 1 $NEAR as yoctoNEAR
let account_id: AccountId = "example.near".parse().unwrap();

Promise::new(account_id).transfer(amount);
```

In the context of a full contract and function call, this could look like:

```rust
use near_sdk::{json_types::U128, near, AccountId, Promise};

#[near(contract_state)]
pub struct Contract {}

#[near]
impl Contract {
    pub fn pay(amount: U128, to: AccountId) -> Promise {
        Promise::new(to).transfer(amount.0)
    }
}
```

Most of this is boilerplate you're probably familiar with by now ‚Äì¬†imports, setting up [`near(contract_state)`](../contract-structure/near-bindgen.md), [borsh](../contract-interface/serialization-interface.md), etc. Some interesting details related to the transfer itself:

* `U128` with a capital `U`: The `pay` method defined here accepts JSON as input, and numbers in JS [cannot be larger than `2^53-1`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER), so for compatibility with deserializing JSON to JS, the integer is serialized as a decimal string. Since the `transfer` method takes a number in [yocto](https://en.wikipedia.org/wiki/Yocto-)NEAR, it's likely to need numbers much larger than `2^53-1`.

  When a function takes `U128` as input, it means that callers need to specify the number a a string. near-sdk-rs will then cast it to `U128` type, which wraps Rust's native [`u128`](https://doc.rust-lang.org/std/primitive.u128.html). The underlying `u128` can be retrieved with `.0` ‚Äì¬†used in `transfer(amount.0)`.

* `AccountId`: this will automatically check that the provided string is a well-formed NEAR account ID, and panic with a useful error if not.

* Returning `Promise`: This allows NEAR Explorer, near-cli, near-api-js, and other tooling to correctly determine if a whole chain of transactions is successful. If your function does not return `Promise`, tools like near-cli will return immediately after your function call. And then even if the `transfer` fails, your function call will be considered successful. You can see an example of this behavior [here](/tutorials/examples/advanced-xcc).

Using near-cli or near-cli-rs, someone could invoke this function with a call like:

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="near-cli">

  ```bash
  near call <contract> pay '{"amount": "1000000000000000000000000", "to": "example.near"}' --accountId benjiman.near
  ```
  </TabItem>
  <TabItem value="near-cli-rs">

  ```bash
  near contract call-function as-transaction <contract> pay json-args '{"amount": "1000000000000000000000000", "to": "example.near"}' prepaid-gas '30 TeraGas' attached-deposit '0 NEAR' sign-as benjiman.near network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

'''
'''--- docs/sdk/rust/reduce-size.md ---
---
id: contract-size
title: "Reducing Contract Size"
---
import {Github} from "@site/src/components/codetabs"

# Reducing a contract's size

## Advice & examples

This page is made for developers familiar with lower-level concepts who wish to reduce their contract size significantly, perhaps at the expense of code readability.

Some common scenarios where this approach may be helpful:

- contracts intended to be tied to one's account management
- contracts deployed using a factory
- future advancements similar to the EVM on NEAR

There have been a few items that may add unwanted bytes to a contract's size when compiled. Some of these may be more easily swapped for other approaches while others require more internal knowledge about system calls.

## Small wins

### Using flags

When compiling a contract make sure to pass flag `-C link-arg=-s` to the rust compiler:

```bash
RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
```

Here is the parameters we use for the most examples in `Cargo.toml`:

```toml
[profile.release]
codegen-units = 1
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true
```

You may want to experiment with using `opt-level = "z"` instead of `opt-level = "s"` to see if generates a smaller binary. See more details on this in [The Cargo Book Profiles section](https://doc.rust-lang.org/cargo/reference/profiles.html#opt-level). You may also reference this [Shrinking .wasm Size](https://rustwasm.github.io/book/reference/code-size.html#tell-llvm-to-optimize-for-size-instead-of-speed) resource.

### Removing `rlib` from the manifest

Ensure that your manifest (`Cargo.toml`) doesn't contain `rlib` unless it needs to. Some NEAR examples have included this:

:::caution Adds unnecessary bloat

```toml
[lib]
crate-type = ["cdylib", "rlib"]
```
:::

  when it could be:

:::tip

```toml
[lib]
crate-type = ["cdylib"]
```
:::

3. When using the Rust SDK, you may override the default JSON serialization to use [Borsh](https://borsh.io) instead. [See this page](contract-interface/serialization-interface.md#overriding-serialization-protocol-default) for more information and an example.
4. When using assertions or guards, avoid using the standard `assert` macros like [`assert!`](https://doc.rust-lang.org/std/macro.assert.html), [`assert_eq!`](https://doc.rust-lang.org/std/macro.assert_eq.html), or [`assert_ne!`](https://doc.rust-lang.org/std/macro.assert_ne.html) as these may add bloat for information regarding the line number of the error. There are similar issues with `unwrap`, `expect`, and Rust's `panic!()` macro.

  Example of a standard assertion:

  :::caution Adds unnecessary bloat

  ```rust
  assert_eq!(contract_owner, predecessor_account, "ERR_NOT_OWNER");
  ```
  :::

  when it could be:

  :::tip

  ```rust
  if contract_owner != predecessor_account {
    env::panic(b"ERR_NOT_OWNER");
  }
  ```
  :::

  Example of removing `expect`:

  :::caution Adds unnecessary bloat

  ```rust
  let owner_id = self.owner_by_id.get(&token_id).expect("Token not found");
  ```
  :::

  when it could be:

  :::tip

  ```rust
  fn expect_token_found<T>(option: Option<T>) -> T {
    option.unwrap_or_else(|| env::panic_str("Token not found"))
  }
  let owner_id = expect_token_found(self.owner_by_id.get(&token_id));  
  ```
  :::

  Example of changing standard `panic!()`:

  :::caution Adds unnecessary bloat

  ```rust
  panic!("ERR_MSG_HERE"); 
  ```
  :::

  when it could be:

  :::tip

  ```rust
  env::panic_str("ERR_MSG_HERE");  
  ```
  :::

## Lower-level approach

For a `no_std` approach to minimal contracts, observe the following examples:

- [Tiny contract](https://github.com/near/nearcore/tree/1e7c6613f65c23f87adf2c92e3d877f4ffe666ea/runtime/near-test-contracts/tiny-contract-rs)
- [NEAR ETH Gateway](https://github.com/ilblackdragon/near-eth-gateway/blob/master/proxy/src/lib.rs)
- [This YouTube video](https://youtu.be/Hy4VBSCqnsE) where Eugene demonstrates a fungible token in `no_std` mode. The code for this [example lives here](https://github.com/near/core-contracts/pull/88).
- [Examples using a project called `nesdie`](https://github.com/austinabell/nesdie/tree/main/examples).
- Note that Aurora has found success using [rjson](https://crates.io/crates/rjson) as a lightweight JSON serialization crate. It has a smaller footprint than [serde](https://crates.io/crates/serde) which is currently packaged with the Rust SDK. See [this example of rjson](https://github.com/aurora-is-near/aurora-engine/blob/65a1d11fcd16192cc1bda886c62005c603189a24/src/json.rs#L254) in an Aurora repository, although implementation details will have to be gleaned by the reader and won't be expanded upon here. [This nesdie example](https://github.com/austinabell/nesdie/blob/bb6beb77e32cd54077ac54bf028f262a9dfb6ad0/examples/multisig/src/utils/json/vector.rs#L26-L30) also uses the [miniserde crate](https://crates.io/crates/miniserde), which is another option to consider for folks who choose to avoid using the Rust SDK.

:::note Information on system calls

<details>
  <summary>Expand to see what's available from <code>sys.rs</code></summary>

<Github language="rust" start="" end="" url="https://github.com/near/near-sdk-rs/blob/master/near-sdk/src/environment/sys.rs" />

</details>

:::

'''
'''--- docs/sdk/rust/rs-sdk.md ---
---
id: introduction
title: About Rust SDK
---

Rust is a programming language designed for performance and safety. It is syntactically similar to C++, but can guarantee memory safety without resorting to garbage collection. Rust has proven to be a mature and secure language, which makes it ideal to write smart contracts. Because of this, **Rust is the preferred programming language for writing smart contracts on NEAR**. While there might be a learning curve for those coming from web development, learning Rust enables to write safer and faster contracts. Furthermore, core contracts such as Fungible Tokens and DAOs are currently only available in Rust.

:::info 
If you're getting started with Rust, we recommend you look through [this overview in the `nearcore` repository](https://github.com/near/nearcore/blob/master/docs/practices/rust.md). It's a great way to get your first steps in for the language and its ecosystem. 
:::

---

## Create Your First Rust Contract
Create your first **Rust contract** in minutes:
1. Download and install [Rust](https://doc.rust-lang.org/book/ch01-01-installation.html).
2. Create a new **rust** project using our [quickstart guide](../../2.build/2.smart-contracts/quickstart.md).
3. Read our docs on **[how to write smart contracts](../../2.build/2.smart-contracts/anatomy/anatomy.md)**.
'''
'''--- docs/sdk/rust/testing/integration-tests.md ---
---
sidebar_position: 2
---
import {Github} from "@site/src/components/codetabs"

# Integration Tests

## Unit Tests vs. Integration Tests

Unit tests are great for ensuring that functionality works as expected at an insolated, functional-level. This might include checking that function `get_nth_fibonacci(n: u8)` works as expected, handles invalid input gracefully, etc. Unit tests in smart contracts might similarly test public functions, but can get unruly if there are several calls between accounts. As mentioned in the [unit tests](unit-tests.md) section, there is a `VMContext` object used by unit tests to mock some aspects of a transaction. One might, for instance, modify the testing context to have the `predecessor_account_id` of `"bob.near"`. The limits of unit tests become obvious with certain interactions, like transferring tokens. Since `"bob.near"` is simply a string and not an account object, there is no way to write a unit test that confirms that Alice sent Bob 6 NEAR (‚ìÉ). Furthermore, there is no way to write a unit test that executes cross-contract calls. Additionally, there is no way of profiling gas usage and the execution of the call (or set of calls) on the blockchain.

Integration tests provide the ability to have end-to-end testing that includes cross-contract calls, proper user accounts, access to state, structured execution outcomes, and more. In NEAR, we can make use of the `workspaces` libraries in both [Rust](https://github.com/near/workspaces-rs) and [JavaScript](https://github.com/near/workspaces-js) for this type of testing on a locally-run blockchain or testnet.

## When to Use Integration Tests

You'll probably want to use integration tests when:

- There are cross-contract calls.
- There are multiple users with balance changes.
- You'd like to gather information about gas usage and execution outcomes on-chain.
- You want to assert the use-case execution flow of your smart contract logic works as expected.
- You want to assert given execution patterns do not work (as expected).

## Setup

Unlike unit tests (which would often live in the `src/lib.rs` file of the contract), integration tests in Rust are located in a separate directory at the same level as `/src`, called `/tests` ([read more](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#integration-tests)). Refer to this folder structure below:

```sh
‚îú‚îÄ‚îÄ Cargo.toml                  ‚üµ contains `dependencies` for contract and `dev-dependencies` for workspaces-rs tests
‚îú‚îÄ‚îÄ src
‚îÇ  ‚îî‚îÄ‚îÄ lib.rs                   ‚üµ contract code
‚îú‚îÄ‚îÄ target
‚îî‚îÄ‚îÄ tests                       ‚üµ integration test directory
   ‚îî‚îÄ‚îÄ integration-tests.rs     ‚üµ integration test file
```

:::info
These tests don't have to be placed in their own `/tests` directory. Instead, you can place them in the `/src` directory which can be beneficial since then you can use the non-exported types for serialization within the test case.
:::

A sample configuration for this project's `Cargo.toml` is shown below:

```toml
[package]
name = "fungible-token-wrapper"
version = "0.0.2"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[dev-dependencies]
anyhow = "1.0"
near-primitives = "0.5.0"
near-sdk = "4.0.0"
near-units = "0.2.0"
serde_json = "1.0"
tokio = { version = "1.14", features = ["full"] }
workspaces = "0.4.1"

# remember to include a line for each contract
fungible-token = { path = "./ft" }
defi = { path = "./test-contract-defi" }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
# remember to include a member for each contract
members = [
  "ft",
  "test-contract-defi",
]
```

The `integration-tests.rs` file above will contain the integration tests. These can be run with the following command from the same level as the test `Cargo.toml` file:

    cargo test --test integration-tests

## Comparing an Example

### Unit Test

Let's take a look at a very simple unit test and integration test that accomplish the same thing. Normally you wouldn't duplicate efforts like this (as integration tests are intended to be broader in scope), but it will be informative.

We'll be using snippets from the [fungible-token example](https://github.com/near/near-sdk-rs/blob/master/examples/fungible-token) from the `near-sdk-rs` repository to demonstrate simulation tests.

First, note this unit test that tests the functionality of the `test_transfer` method:

<Github language="rust" start="100" end="165" url="https://github.com/near/near-sdk-rs/blob/6d4045251c63ec875dc55f43b065b33a36d94792/examples/fungible-token/ft/src/lib.rs" />

The test above sets up the testing context, instantiates the test environment through `get_context()`, calls the `test_transfer` method, and performs the `storage_deposit()` initialization call (to register with the fungible token contract) and the `ft_transfer()` fungible token transfer call.

Let's look at how this might be written with workspaces tests. The snippet below is a bit longer as it demonstrates a couple of things worth noting.

### Workspaces Test

<Github language="rust" start="25" end="115" url="https://github.com/near/near-sdk-rs/blob/master/examples/fungible-token/tests/workspaces.rs" />

In the test above, the compiled smart contract `.wasm` file (which we compiled into the `/out` directory) for the Fungible Token example is dev-deployed (newly created account) to the environment. The `ft_contract` account is created as a result from the environment which is used to create accounts. This specific file's format has only one test entry point (`main`), and every test is declared with `#[tokio::test]`. Tests do not share state between runs.

Notice the layout within `test_total_supply`. `.call()` obtains its required gas from the account performing it. Unlike the unit test, there is no mocking being performed before the call as the context is provided by the environment initialized during `init()`. Every call interacts with this environment to either fetch or change state.

:::info
**Pitfall**: you must compile your contract before running integration tests. Because workspaces tests use the `.wasm` files to deploy the contracts to the network. If changes are made to the smart contract code, the smart contract wasm should be rebuilt before running these tests again.
:::

:::note
In case you wish to preserve state between runs, you can call multiple tests within one function, passing the worker around from a `workspaces::sandbox()` call.
:::

## Helpful Snippets

### Create an Account

<Github language="rust" start="16" end="21" url="https://github.com/near-examples/rust-counter/blob/6a7af5a32c630e0298c09c24eab87267746552b2/integration-tests/rs/src/tests.rs" />

:::note
You can also create a `dev_account` without having to deploy a contract as follows:

<Github language="rust" start="7" end="8" url="https://github.com/near/workspaces-rs/blob/8f12f3dc3b0251ac3f44ddf6ab6fc63003579139/workspaces/tests/create_account.rs" />

:::

### Create Helper Functions

<Github language="rust" start="148" end="161" url="https://github.com/near-examples/nft-tutorial/blob/7fb267b83899d1f65f1bceb71804430fab62c7a7/integration-tests/rs/src/helpers.rs" />

### Spooning - Pulling Existing State and Contracts from Mainnet/Testnet

This example showcases spooning state from a testnet contract into our local sandbox environment:

<Github language="rust" start="64" end="122" url="https://github.com/near/workspaces-rs/blob/c14fe2aa6cdf586028b2993c6a28240f78484d3e/examples/src/spooning.rs" />

For a full example, see the [examples/src/spooning.rs](https://github.com/near/workspaces-rs/blob/main/examples/src/spooning.rs) example.

### Fast Forwarding - Fast Forward to a Future Block

`workspaces` testing offers support for forwarding the state of the blockchain to the future. This means contracts which require time sensitive data do not need to sit and wait the same amount of time for blocks on the sandbox to be produced. We can simply just call `worker.fast_forward` to get us further in time:

<Github language="rust" start="12" end="44" url="https://github.com/near/workspaces-rs/blob/c14fe2aa6cdf586028b2993c6a28240f78484d3e/examples/src/fast_forward.rs" />

For a full example, take a look at [examples/src/fast_forward.rs](https://github.com/near/workspaces-rs/blob/main/examples/src/fast_forward.rs).

### Handle Errors

<Github language="rust" start="199" end="225" url="https://github.com/near-examples/FT/blob/98b85297a270cbcb8ef3901c29c17701e1cab698/integration-tests/rs/src/tests.rs" />

:::note
Returning `Err(msg)` is also a viable (and arguably simpler) implementation.
:::

### Batch Transactions

```rust title="Batch Transaction - workspace-rs"
let res = contract
    .batch(&worker)
    .call(
        Function::new("ft_transfer_call")
            .args_json((defi_contract.id(), transfer_amount, Option::<String>::None, "10"))?
            .gas(300_000_000_000_000 / 2)
            .deposit(1),
    )
    .call(
        Function::new("storage_unregister")
            .args_json((Some(true),))?
            .gas(300_000_000_000_000 / 2)
            .deposit(1),
    )
    .transact()
    .await?;
```

### Inspecting Logs

```rust title="Logs - workspaces-rs"
assert_eq!(
    res.logs()[1],
    format!("Closed @{} with {}", contract.id(), initial_balance.0 - transfer_amount.0)
);
```

Examining receipt outcomes:

```rust title="Logs - workspaces-rs"
let outcome = &res.receipt_outcomes()[5];
assert_eq!(outcome.logs[0], "The account of the sender was deleted");
assert_eq!(outcome.logs[2], format!("Account @{} burned {}", contract.id(), 10));
```

### Profiling Gas

`CallExecutionDetails::total_gas_burnt` includes all gas burnt by call execution, including by receipts. This is exposed as a surface level API since it is a much more commonly used concept:

```rust title="Gas (all) - workspaces-rs"
println!("Burnt gas (all): {}", res.total_gas_burnt);
```

If you do actually want gas burnt by transaction itself you can do it like this:

```rust title="Gas (transaction) - workspaces-rs"
println!("Burnt gas (transaction): {}", res.outcome().gas_burnt);
```

If you want to see the gas burnt by each receipt, you can do it like this:

```rust title="Gas (receipt) - workspaces-rs"
for receipt in res.receipt_outcomes() {
   println!("Burnt gas (receipt): {}", receipt.gas_burnt);
}
```

'''
'''--- docs/sdk/rust/testing/unit-tests.md ---
---
sidebar_position: 1
---

# Unit Tests

Testing contract functionality can be done through the `cargo test` framework. These tests will run with a mocked blockchain and will allow testing function calls directly without having to set up/deploy to a network and sign serialized transactions on this network.

A common framework for tests, along with setting up a basic testing environment looks like:

```rust
#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use super::*;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, VMContext};

    fn get_context(is_view: bool) -> VMContext {
        VMContextBuilder::new()
            .signer_account_id("bob_near".parse().unwrap())
            .is_view(is_view)
            .build()
    }

    #[test]
    fn my_test() {
        let context = get_context(false);
        testing_env!(context);
        // ... Write test here
    }
}
```

Where `VMContextBuilder` allows for modifying the context of the mocked blockchain to simulate the environment that a transaction would be run. The documentation for what can be modified with this context can be found [here](https://docs.rs/near-sdk/4.1.1/near_sdk/struct.VMContext.html).

The `testing_env!` macro will initialize the blockchain interface with the `VMContext` which is either initialized through `VMContextBuilder` or manually through itself.

:::info Note

This `testing_env!` and `VMContext` is only used for testing outside of `wasm` environments. When running the built contract on a network in a `wasm` environment, the context from the blockchain will be used through host functions on the runtime.

:::

To test read-only function calls, set `is_view` to `true` on the `VMContext`. This will test to verify that function calls which just read state do not try to modify state through unit tests. In the above example, `true` should be passed into the `get_context` call, which initializes the context as read-only.

You will want to use `testing_env!` each time you need to update this context, such as mocking the `predecessor_accound_id` to simulate the functions being called by or only allowing view operations as mentioned above. Each time this is done, a new mocked blockchain will be initialized while keeping the existing state.

'''
'''--- docs/sdk/welcome.md ---
---
id: welcome
title: "NEAR SDKs"
hide_table_of_contents: false
---

import {FeatureList, Column, Feature} from "@site/src/components/featurelist";

Explore our language-specific SDK documentation

<FeatureList>
  <Column title="SDKs">
    <Feature url="/sdk/rust/introduction" title="Rust SDK" subtitle="Write Contracts in Rust" image="smartcontract-rust.png" />
  </Column>
  <Column title="&nbsp;">
    <Feature url="/sdk/js/introduction" title="JavaScript SDK" subtitle="Write Contracts in JavaScript" image="smartcontract-js.png" />
  </Column>
</FeatureList>

'''
'''--- website/crowdin.yml ---
project_id: '479619'
api_token_env: 'CROWDIN_PERSONAL_TOKEN'
base_path: ".."
preserve_hierarchy: true
files: [
  # JSON translation files
  {
    source: '/website/i18n/en/**/*',
    translation: '/website/i18n/%two_letters_code%/**/%original_file_name%',
  },
  # Docs Markdown files
  {
    source: '/docs/**/*',
    translation: '/website/i18n/%two_letters_code%/docusaurus-plugin-content-docs/current/**/%original_file_name%',
  },
  # Blog
  {
    source: '/blog/**/*',
    translation: '/website/i18n/%two_letters_code%/docusaurus-plugin-content-blog/**/%original_file_name%',
  },
]
'''
'''--- website/docusaurus.config.js ---
// @ts-check
const path = require('path');
const changelogs = require('./src/utils/changelogs.json');

/** @type {import('@docusaurus/types').Config} */
const config = {
  title: 'NEAR Documentation',
  tagline: 'NEAR Protocol Developer Documentation',
  url: 'https://docs.near.org',
  baseUrl: '/',
  organizationName: 'near',
  projectName: 'docs',
  markdown: {
    mermaid: true,
  },
  scripts: [
    'https://buttons.github.io/buttons.js',
    'https://use.fontawesome.com/221fd444f5.js',
  ],
  stylesheets: [
    'https://fonts.googleapis.com/css2?family=Inter:wght@400;600;900&family=Source+Code+Pro:ital,wght@0,400;0,600;1,400;1,600&display=swap',
  ],
  favicon: 'img/favicon.ico',
  customFields: {
    disableHeaderTitle: true,
    fonts: {
      myFont: ['Inter', 'sans-serif'],
    },
  },
  themes: ['@saucelabs/theme-github-codeblock', '@docusaurus/theme-mermaid'],
  onBrokenLinks: 'log',
  onBrokenMarkdownLinks: 'log',
  presets: [
    [
      '@docusaurus/preset-classic',
      {
        docs: {
          showLastUpdateAuthor: true,
          showLastUpdateTime: true,
          breadcrumbs: true,
          editUrl: 'https://github.com/near/docs/edit/master/website',
          path: '../docs',
          sidebarPath: './sidebars.js',
          routeBasePath: '/',
        },
        sitemap: {
          changefreq: 'weekly',
          priority: 0.5,
        },
        googleAnalytics: {
          trackingID: 'UA-100373569-7',
          anonymizeIP: true,
        },
        blog: {
          blogTitle: 'NEAR Docs Blog',
          blogSidebarTitle: 'Documentation Blog',
          blogSidebarCount: 'ALL',
          showReadingTime: true,
          routeBasePath: 'blog',
          path: '../blog',

        },
        theme: {
          customCss: './src/css/custom.scss',
        },
      },
    ],
  ],
  plugins: [
    './src/plugins/monaco-editor',
    './src/plugins/node-polyfills',
    'docusaurus-plugin-sass',
    [
      'docusaurus-plugin-remote-content',
      {
        name: 'near-changelog',
        sourceBaseUrl:
          'https://raw.githubusercontent.com/near/near-releases/main/reports/',
        outDir: '../blog',
        documents: changelogs,
        noRuntimeDownloads: true,
        modifyContent(filename, content) {
          return { filename, content: content.replace('{{', '').replace('<', '\\<') };
        },
      },
    ],
  ],
  themeConfig: {
    image: 'docs/assets/welcome-pages/protocol.png',
    announcementBar: {
      id: 'id-0002',
      content:
        'üéâ Come check <a href="/blog">our new blog</a>, where we will share weekly news and updates üéâ',
      backgroundColor: '#fafbfc',
      textColor: '#333',
      isCloseable: true,
    },
    prism: {
      additionalLanguages: [
        'rust',
        'java',
        'python',
        'ruby',
        'go',
        'typescript',
        'jsx',
      ],
    },
    colorMode: {
      defaultMode: 'light',
      respectPrefersColorScheme: true,
    },
    docs: {
      sidebar: {
        hideable: true,
        autoCollapseCategories: true
      }
    },
    navbar: {
      logo: {
        alt: 'NEAR Logo',
        src: 'img/near_logo.svg',
        srcDark: 'img/near_logo_white.svg',
      },
      items: [
        {
          to: '/concepts/welcome',
          label: 'Concepts',
          position: 'left',
        },
        {
          to: '/build/welcome',
          label: 'Build',
          position: 'left',
        },
        {
          to: '/tutorials/welcome',
          label: 'Tutorials',
          position: 'left',
        },
        {
          href: '/api/rpc/introduction',
          label: 'RPC',
        },
        {
          type: 'html',
          value: '<span class="separator"></span>',
        },
        {
          type: 'dropdown',
          label: 'Tools',
          position: 'left',
          items: [
            { label: 'üß∞ All Tools', href: '/tools/welcome' },
            {
              type: 'html',
              value: '<hr/> <small class="subtitle"> Essentials </small>',
            },
            { label: 'NEAR API', href: '/tools/near-api-js/quick-reference' },
            { label: 'NEAR SDK', href: '/sdk/welcome' },
            { label: 'NEAR CLI', href: '/tools/near-cli' },
            {
              type: 'html',
              value: '<hr/> <small class="subtitle"> Wallet Integration </small>',
            },
            { label: 'Wallet Selector', href: '/tools/wallet-selector' },
            {
              type: 'html',
              value: '<hr/> <small class="subtitle"> IDEs </small>',
            },
            { label: 'VSCode Extension ', href: 'https://marketplace.visualstudio.com/items?itemName=near-protocol.near-discovery-ide' },
            { label: 'BOS Web IDE (Jutsu)', href: 'https://jutsu.ai/editor' },
            {
              label: 'Remix IDE Plugin',
              href: 'https://docs.welldonestudio.io/code/getting-started',
            },
          ],
        },
        {
          type: 'dropdown',
          label: 'Resources',
          position: 'left',
          items: [
            {
              label: 'Github',
              href: 'https://github.com/near',
              className: 'header-github-link',
            },
            {
              type: 'html',
              value: '<hr/><div class="subtitle"> Support </dib>',
            },
            {
              href: 'https://discord.gg/GZ7735Xjce',
              label: 'Discord',
            },
            {
              href: 'https://t.me/neardev',
              label: 'Telegram',
            },
            {
              type: 'html',
              value: '<hr /><div class="subtitle"> Education </dib>',
            },
            {
              href: 'https://agorapp.dev/catalog/course?difficulty=&chains=near',
              label: 'Agor',
            },
            {
              href: 'https://learnnear.club/',
              label: 'Learn NEAR Club',
            },
            {
              type: 'html',
              value: '<hr /><div class="subtitle"> Other Docs </dib>',
            },
            {
              href: 'https://nomicon.io',
              label: 'Protocol Docs',
            },
            {
              href: 'https://near-nodes.io',
              label: 'Validator Docs',
            },
            {
              href: '/integrations/exchange-integration',
              label: 'Exchange Integrations',
            },
          ],
        },
        {
          type: 'search',
          position: 'right',
        },
        { label: 'Blog', href: '/blog' },
        {
          type: 'localeDropdown',
          position: 'right',
        },
        {
          href: 'login',
          position: 'right',
        },
      ],
    },
    footer: {
      links: [],
      copyright: 'Copyright ¬© 2023 NEAR Protocol',
      logo: {
        src: 'img/near_logo.svg',
      },
    },
    algolia: {
      // The application ID provided by Algolia
      appId: '0LUM67N2P2',
      // Public API key: it is safe to commit it
      apiKey: '129d0f429e1bb0510f0261dda1e88ed4',
      indexName: 'near',
      // Optional: see doc section below
      contextualSearch: true,
      // Optional: Algolia search parameters
      searchParameters: {
        clickAnalytics: true,
        analytics: true,
        enableReRanking: true,
        attributesToRetrieve: [
          'hierarchy.lvl0',
          'hierarchy.lvl1',
          'hierarchy.lvl2',
          'hierarchy.lvl3',
          'hierarchy.lvl4',
          'hierarchy.lvl5',
          'hierarchy.lvl6',
          'type',
          'url',
          'title',
          'description',
          'headers',
          'headersLevels'
        ],
      },
      //... other Algolia params
      placeholder: 'Search the Docs...',
      insights: true,
    },
  },
  i18n: {
    defaultLocale: 'en',
    locales: ['en', 'ko', 'vi', 'zh-CN'],
    localeConfigs: {
      'zh-CN': {
        label: 'ÁÆÄ‰Ωì‰∏≠Êñá',
      },
    },
  },
};

export default config;

'''
'''--- website/linkinator.config.json ---
{
  "recurse": true,
  "directoryListing": true,
  "retry": false,
  "retryErrorsCount": 1,
  "retryErrorsJitter": 5,
  "timeout": 5000,
  "concurrency": 100,
  "silent": true,
  "skip": [
    "https://crates.io/*",
    "https://staking.dokia.cloud/staking/near/validators",
    "https://near.zavodil.ru/?pools=",
    "https://rpc.testnet.near.org/",
    "https://rpc.betanet.near.org",
    "https://rpc.betanet.near.org/status",
    "https://rpc.betanet.near.org/network_info",
    "https://rpc.near.org/",
    "http://localhost:5000/css/fonts.css",
    "http://localhost:5000/css/landing-page.css",
    "http://localhost:5000/css/copy-code-button.css",
    "https://github.com/near/docs/tree/master/docs",
    "https://etherscan.io/chart/gasprice",
    "https://ropsten.etherscan.io/*",
    "https://near.org/near/widget/*",
    "https://www.coingecko.com/en/api",
    "https://www.coindesk.com/*",
    "/ko/*",
    "/vi/*",
    "/zh-CN/*",
    "https://github.com/",
    "https://jutsu.ai/editor",
    "https://meteorwallet.app",
    "https://t.me/cryptonear",
    "https://www.npmjs.com/package/@near-lake/framework",
    "https://mitsloan.mit.edu/ideas-made-to-matter/social-media-broken-a-new-report-offers-25-ways-to-fix-it",
    "https://www.zeeve.io/",
    "https://www.arweave.org/",
    "https://www.minecraft.net",
    "https://shard.dog/"
  ]
}

'''
'''--- website/mlc_config.json ---
{
  "ignorePatterns": [
    {
      "pattern": "^/"
    },
    {
      "pattern": "^http://127.0.0.1"
    },
    {
      "pattern": "^https://near.events"
    },
    {
      "pattern": "^https://etherscan.io"
    },
    {
      "pattern": "^https://chainstack.com"
    },
    {
      "pattern": "^https://crates.io"
    },
    {
      "pattern": "^https://ropsten.etherscan.io"
    },
    {
      "pattern": "^https://support.ledger.com"
    },
    {
      "pattern": "^https://help.github.com"
    },
    {
      "pattern": "^https://hackenproof.com"
    },
    {
      "pattern": "^https://explorer.betanet.near.org"
    },
    {
      "pattern": "^https://rpc.betanet.near.org"
    },
    {
      "pattern": "^https://rpc.testnet.near.org"
    }
  ],
  "timeout": "20s",
  "retryOn429": true,
  "retryCount": 5,
  "fallbackRetryDelay": "30s",
  "aliveStatusCodes": [200, 206]
}

'''
'''--- website/package.json ---
{
  "engines": {
    "node": ">=18.0"
  },
  "scripts": {
    "full-test": "./test-links.sh test",
    "start": "docusaurus start",
    "build": "docusaurus build",
    "build:preview": "docusaurus build --locale en",
    "swizzle": "docusaurus swizzle",
    "docusaurus": "docusaurus",
    "fetch-changelog": "node ./src/utils/getChangelogs.js && npm run docusaurus download-remote-near-changelog",
    "crowdin": "crowdin",
    "crowdin:upload": "docusaurus write-translations && crowdin upload",
    "crowdin:download": "crowdin download"
  },
  "devDependencies": {
    "@docusaurus/module-type-aliases": "3.3.2",
    "@docusaurus/types": "3.3.2",
    "@types/react": "^18.2.42",
    "buffer": "^6.0.3",
    "concurrently": "^5.3.0",
    "crypto-browserify": "^3.12.0",
    "file-loader": "^6.2.0",
    "monaco-editor-webpack-plugin": "^7.1.0",
    "process": "^0.11.10",
    "replace-in-file": "^5.0.2",
    "serve": "^11.3.2",
    "stream-browserify": "^3.0.0",
    "stream-http": "^3.2.0",
    "wait-on": "^5.2.0"
  },
  "dependencies": {
    "@crowdin/cli": "^3.9.0",
    "@docusaurus/core": "^3.3.2",
    "@docusaurus/plugin-ideal-image": "^3.3.2",
    "@docusaurus/plugin-sitemap": "^3.3.2",
    "@docusaurus/preset-classic": "^3.3.2",
    "@docusaurus/theme-mermaid": "^3.3.2",
    "@feelback/react": "^0.3.4",
    "@near-wallet-selector/core": "^8.5.1",
    "@near-wallet-selector/here-wallet": "^8.5.1",
    "@near-wallet-selector/modal-ui": "^8.5.1",
    "@near-wallet-selector/my-near-wallet": "^8.5.1",
    "@rudderstack/analytics-js": "^3.0.0-beta.20",
    "@saucelabs/theme-github-codeblock": "^0.2.3",
    "axios": "^1.6.2",
    "bootstrap": "^5.3.2",
    "bootstrap-icons": "^1.11.1",
    "clsx": "^1.1.1",
    "docusaurus-plugin-remote-content": "^4.0.0",
    "docusaurus-plugin-sass": "^0.2.5",
    "gleap": "^10.1.0",
    "https-browserify": "^1.0.0",
    "monaco-editor": "^0.44.0",
    "near-api-js": "^2.1.4",
    "near-social-vm": "github:NearSocial/VM#2.5.5",
    "react": "^18.2.0",
    "react-bootstrap": "^2.9.1",
    "react-bootstrap-typeahead": "^6.3.2",
    "react-dom": "^18.2.0",
    "react-is": "^18.2.0",
    "react-monaco-editor": "^0.54.0",
    "rxjs": "^7.8.1",
    "sass": "^1.69.5",
    "url": "^0.11.3",
    "zustand": "^4.4.4"
  }
}

'''
'''--- website/sidebars.js ---
const sidebar = {
  "concepts": [
    "concepts/welcome",
    "concepts/basics/protocol",
    {
      "type": "html",
      "value": "<hr/>"
    },
    {
      "type": "html",
      "value": "<span class='menu__link'><b><small> The NEAR Protocol </small></b></span>"
    },
    {
      type: 'category',
      label: 'Accounts / Contracts',
      link: { type: 'doc', id: 'concepts/protocol/account-model' },
      items: [
        "concepts/protocol/account-id",
        "concepts/protocol/access-keys",
        "concepts/protocol/smartcontract",
      ]
    },
    {
      type: 'category',
      label: 'Transactions',
      link: { type: 'doc', id: 'concepts/protocol/transactions' },
      items: [
        "concepts/protocol/transaction-anatomy",
        "concepts/protocol/gas",
        "concepts/protocol/transaction-execution",
      ]
    },
    {
      "Data Flow": [
        "concepts/data-flow/near-data-flow",
        "concepts/data-flow/token-transfer-flow"
      ]
    },
    {
      "Tokens": ["concepts/basics/tokens", "concepts/basics/token-loss"]
    },
    {
      "Storage": [
        "concepts/storage/data-storage",
        "concepts/storage/storage-staking",
        "concepts/storage/storage-solutions"
      ]
    },
    {
      "Network": [
        "concepts/basics/validators",
        "concepts/basics/networks",
        "concepts/basics/epoch",
      ]
    },
    {
      "type": "html",
      "value": "<hr/>"
    },
    {
      "type": "html",
      "value": "<span class='menu__link'><b><small> Chain Abstraction ‚ú®</small></b></span>"
    },
    "concepts/abstraction/introduction",
    "concepts/abstraction/meta-transactions",
    "concepts/abstraction/relayers",
    {
      "Chain Signatures": [
        "concepts/abstraction/chain-signatures",
        "concepts/abstraction/signatures/use-cases",
      ]
    },
    {
      "type": "html",
      "value": "<hr/>"
    },
    {
      "type": "html",
      "value": "<span class='menu__link'><b><small> Blockchain Data &amp; Indexing </small></b></span>"
    },
    [
      "concepts/data-flow/data-storage",
      {
        "Data Indexing": [
          "concepts/advanced/indexers",
          "concepts/advanced/near-indexer-framework",
          "concepts/advanced/near-lake-framework"
        ]
      }
    ],
    {
      "type": "html",
      "value": "<hr/>"
    },
    {
      "type": "html",
      "value": "<span class='menu__link'><b><small> Advanced Topics </small></b></span>"
    },
    [
      "concepts/basics/runtime",
      "concepts/advanced/specification",
      {
        "type": "link",
        "label": "Papers",
        "href": "https://near.org/papers"
      },
    ],
    {
      "type": "html",
      "value": "<hr/>"
    },
    {
      "type": "html",
      "value": "<span class='menu__link'><b><small> From Web 2 to Web 3 </small></b></span>"
    },
    [
      "concepts/web3/intro",
      "concepts/web3/basics",
      "concepts/web3/near",
      "concepts/web3/economics",
      "concepts/web3/nfts"
    ]
  ],
  "build": [
    "build/welcome",
    {
      "type": "html",
      "value": "<hr/>"
    },
    {
      "type": "html",
      "value": "<span class='menu__link'><b><small> Chain Abstraction ‚ú® </small></b></span>"
    },
    'build/chain-abstraction/what-is',
    {
      "Chain Abstraction Services": [
        "build/chain-abstraction/meta-transactions",
        'build/chain-abstraction/fastauth-sdk',
        'build/chain-abstraction/chain-signatures',
        'build/chain-abstraction/wallet',
        'build/chain-abstraction/nft-chain-keys',
        {
          "Multichain Gas Relayer": [
            "build/chain-abstraction/multichain-gas-relayer/multichain-server",
            "build/chain-abstraction/multichain-gas-relayer/gas-station",
            "build/chain-abstraction/multichain-gas-relayer/relayer-gas-example",
          ]
        },
        "build/chain-abstraction/data-availability",
      ]
    },
    {
      "type": "html",
      "value": "<hr/>"
    },
    {
      "type": "html",
      "value": "<span class='menu__link'><b><small> Smart Contracts </small></b></span>"
    },
    "build/smart-contracts/what-is",
    {
      "Building Smart Contracts": [
        "build/smart-contracts/quickstart",
        {
          "Anatomy of a Contract": [
            "build/smart-contracts/anatomy/anatomy",
            "build/smart-contracts/anatomy/storage",
            "build/smart-contracts/anatomy/functions",
            "build/smart-contracts/anatomy/types",
            "build/smart-contracts/anatomy/environment",
            "build/smart-contracts/anatomy/collections",
            "build/smart-contracts/anatomy/actions",
            "build/smart-contracts/anatomy/crosscontract",
            "build/smart-contracts/security/checklist",
            {
              "type": "html",
              "value": "<hr/>"
            },
            "build/smart-contracts/anatomy/serialization"
          ]
        },
        {
          "Test the Contract": [
            "build/smart-contracts/testing/introduction",
            "build/smart-contracts/testing/unit-test",
            "build/smart-contracts/testing/integration-test",
            {
              "type": "html",
              "value": "<hr/>"
            },
            "build/smart-contracts/testing/kurtosis-localnet",
          ]
        },
        {
          "Deploy, Update & Lock": [
            "build/smart-contracts/release/deploy",
            "build/smart-contracts/release/upgrade",
            "build/smart-contracts/release/lock"
          ]
        },
        {
          "type": "category",
          "label": "Security",
          "link": {
            "type": "doc",
            "id": "build/smart-contracts/security/welcome"
          },
          "items": [
            "build/smart-contracts/security/checklist",
            "build/smart-contracts/security/storage",
            "build/smart-contracts/security/callbacks",
            "build/smart-contracts/security/one-yocto",
            "build/smart-contracts/security/sybil",
            "build/smart-contracts/security/frontrunning",
            "build/smart-contracts/security/reentrancy",
            "build/smart-contracts/security/random",
            {
              "type": "html",
              "value": "<hr/>"
            },
            "build/smart-contracts/security/bounty"
          ]
        },
        {
          "type": "html",
          "value": "<hr/>"
        },
        {
          "type": "html",
          "value": "<a class='menu__link internal' href='/tutorials/examples/count-near'> üìñ Tutorials </a>",
        },
      ]
    },
    {
      "type": "html",
      "value": "<hr/>"
    },
    {
      "type": "html",
      "value": "<span class='menu__link'><b><small> Multi-Chain Components </small></b></span>"
    },
    "build/near-components/what-is",
    {
      "Building Web3 Components": [
        "build/near-components/dev-environment",
        {
          "Anatomy of a Component": [
            "build/near-components/anatomy/state",
            "build/near-components/anatomy/web-methods",
            "build/near-components/anatomy/builtin-components",
            "build/near-components/anatomy/near",
            "build/near-components/anatomy/social",
            "build/near-components/anatomy/notifications",
            "build/near-components/anatomy/bos-components"
          ]
        },
        "build/near-components/bos-gateway",
        {
          "type": "html",
          "value": "<hr/>"
        },
        {
          "type": "html",
          "value": "<a class='menu__link internal' href='/tutorials/near-components/bos-loader'> üìñ Tutorials </a>",
        },
      ]
    },
    {
      "type": "html",
      "value": "<hr/>"
    },
    {
      "type": "html",
      "value": "<span class='menu__link'><b><small> Web3 Applications </small></b></span>"
    },
    "build/web3-apps/what-is",
    {
      "Building Web3 Applications": [
        "build/web3-apps/quickstart",
        "build/web3-apps/integrate-contracts",
        "build/web3-apps/integrate-components",
        {
          "Backend": [
            "build/web3-apps/backend/backend-login",
          ]
        },
        {
          "type": "html",
          "value": "<hr/>"
        },
        {
          "type": "html",
          "value": "<a class='menu__link internal' href='/tutorials/examples/count-near'> üìñ Tutorials </a>",
        },
      ],
    },
    {
      "type": "html",
      "value": "<hr/>"
    },
    {
      "type": "html",
      "value": "<span class='menu__link'><b><small> Primitives (FT, NFT, ...) </small></b></span>"
    },
    "build/primitives/what-is",
    {
      "Primitives & Standards": [
        "build/primitives/ft",
        "build/primitives/nft",
        "build/primitives/linkdrop",
        "build/primitives/oracles",
        "build/primitives/dao",
        "build/primitives/dex",
        {
          "type": "html",
          "value": "<hr/>"
        },
        {
          "type": "html",
          "value": "<a class='menu__link internal' href='/tutorials/nfts/minting-nfts'> üìñ Tutorials </a>",
        },
      ]
    },
    {
      "type": "html",
      "value": "<hr/>"
    },
    {
      "type": "html",
      "value": "<span class='menu__link'><b><small> Data Infrastructure </small></b></span>"
    },
    "build/data-infrastructure/what-is",
    {
      "NEAR Data Infrastructure": [
        "build/data-infrastructure/big-query",
        {
          "QueryAPI": [
            "build/data-infrastructure/query-api/intro",
            "build/data-infrastructure/query-api/how-it-works",
            "build/data-infrastructure/query-api/indexers",
            "build/data-infrastructure/query-api/best-practices",
            "build/data-infrastructure/query-api/index-functions",
            "build/data-infrastructure/query-api/context-object",
            "build/data-infrastructure/query-api/query-data",
            "build/data-infrastructure/query-api/migrate-from-near-lake",
          ]
        },
        {
          "Lake Framework": [
            "build/data-infrastructure/lake-framework/near-lake",
            "build/data-infrastructure/lake-framework/near-lake-state-changes-indexer",
            "build/data-infrastructure/lake-framework/migrating-to-near-lake-framework",
            {
              "Building Indexers": [
                "build/data-infrastructure/lake-framework/building-indexers/primitives",
                {
                  "type": "link",
                  "label": "NEAR Lake Primitives",
                  "href": "https://near.github.io/near-lake-framework-js/"
                },
                "build/data-infrastructure/lake-framework/building-indexers/js-lake-indexer",
                "build/data-infrastructure/lake-framework/building-indexers/python-lake-indexer",
                "build/data-infrastructure/lake-framework/building-indexers/nft-indexer",
                "build/data-infrastructure/lake-framework/building-indexers/python-nft-indexer"
              ]
            },
            {
              "Running NEAR Lake": [
                "build/data-infrastructure/lake-framework/running-near-lake/run-lake-indexer",
                "build/data-infrastructure/lake-framework/running-near-lake/lake-start-options",
                "build/data-infrastructure/lake-framework/running-near-lake/credentials"
              ]
            },
            {
              "Lake Data Structures": [
                "build/data-infrastructure/lake-data-structures/toc",
                "build/data-infrastructure/lake-data-structures/block",
                "build/data-infrastructure/lake-data-structures/chunk",
                "build/data-infrastructure/lake-data-structures/shard",
                "build/data-infrastructure/lake-data-structures/transaction",
                "build/data-infrastructure/lake-data-structures/receipt",
                "build/data-infrastructure/lake-data-structures/execution-outcome",
                "build/data-infrastructure/lake-data-structures/state-change"
              ]
            },
          ]
        },
      ]
    }
  ],
  "tutorials": [
    "tutorials/welcome",
    {
      "type": "html",
      "value": "<hr/>"
    },
    {
      "type": "html",
      "value": "<span class='menu__link'><b><small> Examples </small></b></span>"
    },
    {
      "Frontend & Smart Contract": [
        "tutorials/examples/count-near",
        "tutorials/examples/guest-book",
        "tutorials/examples/donation",
        "tutorials/examples/xcc",
        "tutorials/examples/coin-flip",
      ]
    },
    {
      "Advanced Contracts": [
        "tutorials/examples/factory",
        "tutorials/examples/advanced-xcc",
        "tutorials/examples/update-contract-migrate-state",
      ]
    },
    "tutorials/examples/frontend-multiple-contracts",
    {
      "type": "html",
      "value": "<hr/>"
    },
    {
      "type": "html",
      "value": "<span class='menu__link'><b><small> Templates </small></b></span>"
    },
    "tutorials/templates/minter",
    "tutorials/templates/marketplace",
    "tutorials/templates/blog",
    {
      "type": "html",
      "value": "<hr/>"
    },
    {
      "type": "html",
      "value": "<span class='menu__link'><b><small> Tutorials </small></b></span>"
    },
    {
      "Components": [
        "tutorials/near-components/bos-loader",
        "tutorials/near-components/interaction",
        "tutorials/near-components/ds-components",
        "tutorials/near-components/using-iframes",
        "tutorials/near-components/blog-posts",
        "tutorials/near-components/push-notifications",
        "tutorials/near-components/queryapi-websockets",
        "tutorials/near-components/ethers-js",
        "tutorials/near-components/ethers-js-best-practices",
        "tutorials/near-components/lido",
      ]
    },
    {
      "Fungible Tokens 101 (FT)": [
        "tutorials/fts/introduction",
        "tutorials/fts/predeployed-contract",
        "tutorials/fts/skeleton",
        "tutorials/fts/defining-a-token",
        "tutorials/fts/circulating-supply",
        "tutorials/fts/registering-accounts",
        "tutorials/fts/transfers",
        "tutorials/fts/marketplace"
      ]
    },
    {
      "Non-Fungible Tokens (NFT)": [
        "tutorials/nfts/minting-nfts",
        "tutorials/nfts/minting-nft-frontend",
        "tutorials/nfts/minecraft-nfts",
        {
          "type": "link",
          "label": "Building a Frontend",
          "href": "https://github.com/near-examples/nft-tutorial-frontend"
        },
        {
          "type": "html",
          "value": "<hr/>"
        },
        {
          "üåê Contract: Zero to Hero ": [
            "tutorials/nfts/js/introduction",
            "tutorials/nfts/js/predeployed-contract",
            "tutorials/nfts/js/skeleton",
            "tutorials/nfts/js/minting",
            "tutorials/nfts/js/upgrade-contract",
            "tutorials/nfts/js/enumeration",
            "tutorials/nfts/js/core",
            "tutorials/nfts/js/approvals",
            "tutorials/nfts/js/royalty",
            "tutorials/nfts/js/events",
            "tutorials/nfts/js/marketplace"
          ]
        },
        {
          "ü¶Ä Contract: Zero to Hero": [
            "tutorials/nfts/introduction",
            {
              "Basic": [
                "tutorials/nfts/predeployed-contract",
                "tutorials/nfts/skeleton",
                "tutorials/nfts/minting",
                "tutorials/nfts/upgrade-contract",
                "tutorials/nfts/enumeration",
                "tutorials/nfts/core",              ]
            },
            "tutorials/nfts/events",
            {
              "Marketplace": [
                "tutorials/nfts/approvals",
                "tutorials/nfts/marketplace",
              ]
            },
            "tutorials/nfts/royalty",
            "tutorials/nfts/series"
          ]
        }
      ]
    },
    {
      "Build a Crossword Game": [
        {
          "type": "category",
          "label": "Basics",
          "items": [
            "tutorials/crosswords/basics/overview",
            "tutorials/crosswords/basics/set-up-skeleton",
            "tutorials/crosswords/basics/add-functions-call",
            "tutorials/crosswords/basics/hashing-and-unit-tests",
            "tutorials/crosswords/basics/simple-frontend"
          ]
        },
        {
          "type": "category",
          "label": "Beginner",
          "items": [
            "tutorials/crosswords/beginner/overview",
            "tutorials/crosswords/beginner/collections",
            "tutorials/crosswords/beginner/structs-enums",
            "tutorials/crosswords/beginner/actions",
            "tutorials/crosswords/beginner/adding-a-puzzle",
            "tutorials/crosswords/beginner/logging-in",
            "tutorials/crosswords/beginner/logging-in-implementation"
          ]
        },
        {
          "type": "category",
          "label": "Intermediate",
          "items": [
            "tutorials/crosswords/intermediate/overview",
            "tutorials/crosswords/intermediate/access-key-solution",
            "tutorials/crosswords/intermediate/use-seed-phrase",
            "tutorials/crosswords/intermediate/linkdrop",
            "tutorials/crosswords/intermediate/cross-contract-calls",
            "tutorials/crosswords/intermediate/base64vecu8"
          ]
        }
      ]
    },
    {
      "Data Infrastructure":
        [
          "tutorials/near-components/indexer-tutorials/posts-indexer",
          "tutorials/near-components/indexer-tutorials/hype-indexer",
          "tutorials/near-components/indexer-tutorials/nft-indexer",
          "tutorials/near-components/indexer-tutorials/feed-indexer",
        ]
    },

  ],
  "tools": [
    "tools/welcome",
    {
      "type": "html",
      "value": "<hr/>"
    },
    {
      "type": "html",
      "value": "<span class='menu__link'><b><small> Developer Tools </small></b></span>"
    },
    {
      "type": "category",
      "label": "JavaScript API",
      "items": [
        "tools/near-api-js/quick-reference",
        "tools/near-api-js/wallet",
        "tools/near-api-js/account",
        "tools/near-api-js/contract",
        "tools/near-api-js/utils",
        "tools/near-api-js/faq",
        {
          "type": "link",
          "label": "Handling Passphrases",
          "href": "https://github.com/near/near-seed-phrase"
        },
        {
          "type": "link",
          "label": "Type Docs",
          "href": "https://near.github.io/near-api-js"
        }
      ]
    },
    {
      "type": "category",
      "label": "Smart Contract SDKs",
      "link": {
        "type": "doc",
        "id": "sdk/welcome"
      },
      "items": [
        {
          "Rust SDK": [
            "sdk/rust/introduction",
            "sdk/rust/get-started",
            {
              "Structure of a Contract": [
                "sdk/rust/contract-structure/near-bindgen",
                "sdk/rust/contract-structure/collections",
                "sdk/rust/contract-structure/nesting"
              ]
            },
            {
              "Contract Interface": [
                "sdk/rust/contract-interface/public-methods",
                "sdk/rust/contract-interface/contract-mutability",
                "sdk/rust/contract-interface/private-methods",
                "sdk/rust/contract-interface/payable-methods",
                "sdk/rust/contract-interface/serialization-interface"
              ]
            },
            {
              "Cross-Contract Calls": ["sdk/rust/cross-contract/callbacks"]
            },
            {
              "Promises": [
                "sdk/rust/promises/intro",
                "sdk/rust/promises/token-tx",
                "sdk/rust/promises/create-account",
                "sdk/rust/promises/deploy-contract"
              ]
            },
            {
              "Building Contracts": [
                "sdk/rust/building/basics",
                "sdk/rust/building/prototyping",
                "sdk/rust/building/post-processing",
                "sdk/rust/building/reproducible-builds"
              ]
            },
            {
              "Testing": [
                "sdk/rust/testing/integration-tests",
                "sdk/rust/testing/unit-tests"
              ]
            },
            "sdk/rust/best-practices",
            "sdk/rust/contract-size"
          ],
          "JavaScript SDK": [
            "sdk/js/introduction",
            "sdk/js/get-started",
            {
              "type": "link",
              "label": "Type Docs ‚Üó",
              "href": "https://near.github.io/near-sdk-js/"
            },
            {
              "Structure of a Contract": [
                "sdk/js/contract-structure/near-bindgen",
                "sdk/js/contract-structure/collections"
              ]
            },
            {
              "Contract Interface": [
                "sdk/js/contract-interface/public-methods",
                "sdk/js/contract-interface/private-methods",
                "sdk/js/contract-interface/payable-methods"
              ]
            },
            {
              "Cross-Contract Calls": ["sdk/js/cross-contract/callbacks"]
            },
            {
              "Promises": [
                "sdk/js/promises/intro",
                "sdk/js/promises/token-tx",
                "sdk/js/promises/create-account",
                "sdk/js/promises/deploy-contract"
              ]
            },
            {
              "Building Contracts": [
                "sdk/js/building/basics",
                "sdk/js/building/prototyping",
                "sdk/js/building/reproducible-builds"
              ]
            },
            {
              "SDK CLI": ["sdk/js/cli/cli"]
            },
            {
              "Testing": [
                "sdk/js/testing/integration-tests",
                "sdk/js/testing/unit-tests"
              ]
            }
          ]
        }
      ]
    },
    {
      "type": "category",
      "label": "Command Line Tools (CLI)",
      "items": ["tools/near-cli", "tools/near-cli-rs"]
    },
    {
      "type": "category",
      "label": "BOS Web Editors",
      "items": [
        {
          "type": "link",
          "label": "near.org Web Editor",
          "href": "https://near.org/sandbox"
        },
        {
          "type": "link",
          "label": "Jutsu Web Editor",
          "href": "https://jutsu.ai/editor"
        }
      ]
    },
    {
      "type": "category",
      "label": "Wallets",
      "items": [
        "tools/wallet-selector",
        {
          "type": "link",
          "label": "Remix IDE Plugin",
          "href": "https://docs.welldonestudio.io/code/getting-started"
        }
      ]
    },
    {
      "type": "html",
      "value": "<hr/>"
    },
    {
      "type": "html",
      "value": "<span class='menu__link'><b><small> Ecosystem Tools </small></b></span>"
    },
    {
      "type": "link",
      "label": "Wallets",
      "href": "https://wallet.near.org"
    },
    {
      "type": "link",
      "label": "Testnet Faucet",
      "href": "https://near-faucet.io/"
    },
    {
      "type": "link",
      "label": "Keypom",
      "href": "https://keypom.xyz/"
    },
    'tools/fastnear-api',
    "tools/explorer",
    "tools/indexing"
  ],
  "api": [
    "api/rpc/introduction",
    "api/rpc/providers",
    {
      "type": "html",
      "value": "<hr/>"
    },
    {
      "type": "html",
      "value": "<span class='menu__link'><b><small> NEAR RPC API </small></b></span>"
    },
    "api/rpc/setup",
    "api/rpc/access-keys",
    "api/rpc/contracts",
    "api/rpc/block-chunk",
    "api/rpc/gas",
    "api/rpc/protocol",
    "api/rpc/network",
    "api/rpc/transactions"
  ],
  "pagoda": [
    {
      "type": "html",
      "value": "<hr/>"
    },
    {
      "type": "html",
      "value": "<span class='menu__link'><b><small> PAGODA CONSOLE </small></b></span>"
    },
    {
      "Pagoda RPC": [
        "pagoda/rpc/intro",
        "pagoda/rpc/get-keys",
        "pagoda/rpc/setup",
        "pagoda/rpc/stats",
      ]
    },
    {
      "Enhanced API": [
        "pagoda/rpc/api",
      ]
    },
    {
      "Alerts & Triggers": [
        "pagoda/alerts/intro",
        "pagoda/alerts/setup",
        "pagoda/alerts/webhooks",
      ]
    },
  ],
  "exchanges": [
    {
      "Integration": [
        "integrations/exchange-integration",
        "integrations/balance-changes",
        "integrations/accounts",
        "integrations/create-transactions",
        "integrations/fungible-tokens",
        "integrations/implicit-accounts"
      ]
    },
    {
      "Understanding Errors": [
        "integrations/errors/introduction",
        "integrations/errors/error-implementation",
        "integrations/errors/token-loss"
      ]
    },
    "integrations/faq"
  ]
};

export default sidebar;

'''
'''--- website/src/components/CodeExplainer/code-explainer.js ---
import React, { useState, useEffect } from "react";
import CodeBlock from '@theme/CodeBlock'

import { Github } from "../codetabs";

import DesktopView from './desktop'
import MobileView from './mobile'

export const lang2label = {
  "rust": "ü¶Ä RS",
  "js": "üåê JS",
  "ts": "üåê TS",
}

export function ExplainCode({ children, languages }) {
  const [language, setLang] = useState(languages[0]);
  const [blocks, setBlocks] = useState([]);
  const [files, setFiles] = useState([]);
  const [isWideEnough, setIsWideEnough] = useState(true);

  // validate languages
  if (!languages.every(lang => lang in lang2label)) throw new Error("languages must be one of ['rust', 'js', 'ts']");

  const setLanguage = (lang) => {
    localStorage.setItem('docusaurus.tab.code-tabs', lang);
    setLang(lang);
  }

  useEffect(() => {
    const storedLang = localStorage.getItem('docusaurus.tab.code-tabs');
    if (storedLang && languages.includes(storedLang)) setLang(storedLang);

    // check if we should render Desktop or Mobile
    setIsWideEnough(window.innerWidth > 768);
  }, [])

  useEffect(() => {
    let blocks = [];
    let files = []

    for (let child of children) {
      if (child.props.highlights && language in child.props.highlights) {
        blocks.push({ text: child.props.children, highlight: child.props.highlights[language], fname: child.props.fname });
      }
      if (language === child.props.language) files.push({ ...child.props })
    }

    setBlocks(blocks);
    setFiles(files);
  }, [language]);

  if (!blocks.length || !files.length) return "Loading...";

  if (isWideEnough) {
    return <DesktopView props={{ blocks, files, languages, language, setLanguage }} />
  } else {
    return <MobileView props={{ blocks, files, languages, language, setLanguage }} />
  }
}

export function Block({ children }) { return children; }

export function File({ children }) { return children; }

export function InnerBlock({ selected, text, index, activateFn }) {
  const cssState = selected ? 'block-selected' : '';
  return (
    <div className={`block ${cssState} padding--sm`} key={index} id={`block${index}`} onClick={() => activateFn(index)}>
      {text}
    </div>
  );
}

export function InnerFile({ url, start, end, language, fname, lineNumber, children }) {
  if (!url) {
    return (
      <div fname={fname}>
        <CodeBlock language={language} metastring={`{${lineNumber}}`} >
          {children.props.children.props.children}
        </CodeBlock>
      </div>
    );
  }

  return <>
    <div fname={fname}>
      <Github url={url} start={start} end={end}
        language={language} fname={fname}
        metastring={`{${lineNumber}}`} />
    </div>
  </>
}

export default { ExplainCode, Block, File };
'''
'''--- website/src/components/CodeExplainer/desktop.js ---
import React, { useState, useEffect } from "react";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { lang2label, InnerBlock, InnerFile } from "./code-explainer";

function DesktopView({ props: { blocks, files, languages, language, setLanguage } }) {
  const [lineNumber, setLineNumber] = useState(blocks[0].highlight);
  const [activeBlock, setActiveBlock] = useState(0);
  const [selectedFile, setSelectedFile] = useState(blocks[0].fname);

  const activateBlock = (index) => {
    setActiveBlock(index);
    setLineNumber(blocks[index].highlight);
    setSelectedFile(blocks[index].fname);
  }

  useEffect(() => {
    // scroll to the highlighted line
    const highlightedLine = document.querySelector(`div[fname="${selectedFile}"] .theme-code-block-highlighted-line`)
    const file = document.querySelector(`div[fname="${selectedFile}"] .prism-code`);

    if (highlightedLine) {
      const scrollTo = highlightedLine.offsetTop - file.clientHeight / 2;
      file.scrollTo({ top: scrollTo, behavior: 'smooth' });
    }
  }, [selectedFile, lineNumber]);

  useEffect(() => {
    activateBlock(0);

    // #files is sticky, and it "sticks" at the height of the .navbar
    const nav = document.querySelector('.navbar');
    const filesElem = document.getElementById('files');
    filesElem.style.top = `${nav.clientHeight}px`;

    // each file has a maxHeight
    const fileTabs = document.querySelector('.file-tabs');

    const allFiles = document.querySelectorAll(`.language-${language}`);
    allFiles.forEach(
      elem => elem.style.maxHeight = `calc(100vh - ${nav.clientHeight}px - ${fileTabs.clientHeight}px)`
    );

    // calculate the size of the code explanations
    const t0 = document.getElementById(`block0`).getBoundingClientRect().top;
    const bN = document.getElementById(`block${blocks.length - 1}`).getBoundingClientRect().bottom;
    let blocksHeight = Math.abs(bN - t0);

    // we want to count the scroll from the top of the codeblocks
    const nonTranslatedCodeBlocks = document.getElementById('codeblocks').getBoundingClientRect().top + window.scrollY;

    // add margin so the last block takes the code with it
    const tN = document.getElementById(`block${blocks.length - 1}`).getBoundingClientRect().top;
    document.getElementById('extra-padding').style.height = `${filesElem.clientHeight - Math.abs(tN - bN) - nav.clientHeight}px`;

    const handleScroll = () => {
      const scrolled = window.scrollY - nonTranslatedCodeBlocks + nav.clientHeight;
      const scrollPercentage = window.scrollY ? scrolled / blocksHeight : 0;

      // select the block that corresponds the percentage of the scroll bar
      let linf = 0;
      let lsup = 0;
      for (let i = 0; i < blocks.length; i++) {
        const block = document.getElementById(`block${i}`)
        linf = lsup;
        lsup += block.clientHeight / blocksHeight;

        if (scrollPercentage > linf && scrollPercentage < lsup) {
          activateBlock(i);
          break;
        }
      }
    }

    window.addEventListener('scroll', handleScroll);

    return () => { window.removeEventListener('scroll', handleScroll) };
  }, [blocks, files, language, selectedFile]);

  return (
    <>
      <div className="row code-explain">
        <div className="col-blocks col" id="codeblocks">
          <Tabs className="file-tabs" selectedValue={language} selectValue={(e) => setLanguage(e)}>
            {languages.map(lang => <TabItem value={lang} label={lang2label[lang]}></TabItem>)}
          </Tabs>
          {blocks.map(
            (block, index) =>
              <InnerBlock selected={activeBlock === index} index={index} text={block.text} activateFn={activateBlock} />)
          }
          <div id="extra-padding" style={{ width: "100%" }}></div>
        </div>
        <div className="col-files col">
          <div id="files" style={{ position: 'sticky' }}>
            <Tabs className="file-tabs" selectedValue={selectedFile || blocks[0].fname} selectValue={(e) => setSelectedFile(e)}>
              {files.map(file =>
                <TabItem value={file.fname} >
                  <InnerFile {...file} lineNumber={lineNumber} />
                </TabItem>
              )}
            </Tabs>
          </div>
        </div>
      </div>
    </>
  );
}

export default DesktopView;
'''
'''--- website/src/components/CodeExplainer/mobile.js ---
import React, { useState, useEffect } from "react";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { lang2label, InnerBlock, InnerFile } from "./code-explainer";

function MobileView({ props: { blocks, files, languages, language, setLanguage } }) {
  const [lineNumber, setLineNumber] = useState(blocks[0].highlight);
  const [activeBlock, setActiveBlock] = useState(0);
  const [selectedFile, setSelectedFile] = useState(blocks[0].fname);

  const activateBlock = (index) => {
    setActiveBlock(index);
    setLineNumber(blocks[index].highlight);
    setSelectedFile(blocks[index].fname);
  }

  useEffect(() => {
    // scroll to the highlighted line
    const highlightedLine = document.querySelector(`div[fname="${selectedFile}"] .theme-code-block-highlighted-line`)
    const file = document.querySelector(`div[fname="${selectedFile}"] .prism-code`);

    if (highlightedLine) file.scrollTo({ top: highlightedLine.offsetTop, behavior: 'smooth' });
  }, [selectedFile, lineNumber]);

  useEffect(() => {
    activateBlock(0);

    const nav = document.querySelector('.navbar');

    // each file has a maxHeight
    const fileTabs = document.querySelector('.file-tabs');

    const allFiles = document.querySelectorAll(`.language-${language}`);
    allFiles.forEach(
      elem => elem.style.maxHeight = `calc(33vh - ${fileTabs.clientHeight}px)`
    );
    
    // calculate the size of the code explanations
    const t0 = document.getElementById(`block0`).getBoundingClientRect().top;
    const bN = document.getElementById(`block${blocks.length - 1}`).getBoundingClientRect().bottom;
    let blocksHeight = Math.abs(bN - t0);

    // we want to count the scroll from the top of the codeblocks
    const nonTranslatedCodeBlocks = document.getElementById('codeblocks').getBoundingClientRect().top + window.scrollY;

    const handleScroll = () => {
      const scrolled = window.scrollY - nonTranslatedCodeBlocks + nav.clientHeight;
      const filesElem = document.getElementById('files');
      const scrollPercentage = window.scrollY ? scrolled / (blocksHeight + filesElem.clientHeight) : 0;

      // select the block that corresponds the percentage of the scroll bar
      let linf = 0;
      let lsup = 0;
      for (let i = 0; i < blocks.length; i++) {
        const block = document.getElementById(`block${i}`)
        linf = lsup;
        lsup += block.clientHeight / blocksHeight;

        if (scrollPercentage > linf && scrollPercentage < lsup) {
          activateBlock(i);
          break;
        }
      }
    };

    window.addEventListener('scroll', handleScroll);

    return () => { window.removeEventListener('scroll', handleScroll) };

  }, [blocks, files, language, selectedFile]);

  return (
    <>
      <div className="code-explain" style={{ position: "relative" }}>
        <div id="codeblocks">
          <Tabs className="file-tabs" selectedValue={language} selectValue={(e) => setLanguage(e)}>
            {languages.map(lang => <TabItem value={lang} label={lang2label[lang]}></TabItem>)}
          </Tabs>
          {
            blocks.map((block, index) =>
              <InnerBlock selected={activeBlock === index} index={index} text={block.text} activateFn={activateBlock} />)
          }
        </div>
        <div id="files" style={{ height: "33vh", position: "sticky", bottom: 0, backgroundColor: "var(--ifm-background-color)" }}>
          <Tabs className="file-tabs" selectedValue={selectedFile || blocks[0].fname} selectValue={(e) => setSelectedFile(e)}>
            {files.map(file =>
              <TabItem value={file.fname} >
                <InnerFile {...file} lineNumber={lineNumber} />
              </TabItem>
            )}
          </Tabs>
        </div>
      </div>
    </>
  );
}

export default MobileView;
'''
'''--- website/src/components/FeedbackComponent.js ---
import { useState } from "react";
import { FeelbackTaggedMessage, FeelbackValueDefinition, Question, PRESET_YESNO_LIKE_DISLIKE } from "@feelback/react";
import "@feelback/react/styles/feelback.css";

const YES_TAGS = [
    { value: "accurate", title: "Accurate", description: "Accurately describes the product or feature.", },
    { value: "problem-solved", title: "Solved my problem", description: "Helped me resolve an issue.", },
    { value: "clear", title: "Easy to understand", description: "Easy to follow and comprehend.", },
    { value: "product-chosen", title: "Helped me decide to use the product", description: "Convinced me to adopt the product or feature.", },
    { value: "other-yes", title: "Another reason" },
];

const NO_TAGS = [
    { value: "inaccurate", title: "Inaccurate", description: "Doesn't accurately describe the product or feature.", },
    { value: "missing-info", title: "Couldn't find what I was looking for", description: "Missing important information.", },
    { value: "unclear", title: "Hard to understand", description: "Too complicated or unclear.", },
    { value: "bad-examples", title: "Code samples errors", description: "One or more code samples are incorrect.", },
    { value: "other-no", title: "Another reason" },
];

const FEEDBACK_CONTENT_SET_ID = "6d4fac2e-6797-47aa-8d5c-b9318a0655e8";

export function FeedbackComponent() {
    const [choice, setChoice] = useState();

    return (
        <div className="feelback-container">
            {!choice
                ? <Question text="Was this page helpful?"
                    items={PRESET_YESNO_LIKE_DISLIKE}
                    showLabels
                    onClick={setChoice}
                />
                : <FeelbackTaggedMessage contentSetId={FEEDBACK_CONTENT_SET_ID}
                    layout="radio-group"
                    tags={choice === "y" ? YES_TAGS : NO_TAGS}
                    title={choice === "y" ? "What did you like?" : "What went wrong?"}
                    placeholder="(optional) Please, further detail the feedback"
                />
            }
        </div>
    );
}

'''
'''--- website/src/components/codetabs.js ---
import React from "react";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import GitHubInternal from "./github";

const lang2label = {
  "rust": "ü¶Ä Rust",
  "js": "üåê Javascript",
  "ts": "üåê Typescript",
}

export function CodeTabs({ children }) {
  if (!Array.isArray(children)) {
    children = [children];
  }

  return (
    <Tabs className="language-tabs" groupId="code-tabs">
      {children.map((component, index) => {
        return (
          <TabItem value={component.props.value} label={lang2label[component.props.value]}>
            {component}
          </TabItem>
        );
      })}
    </Tabs>
  );
}

export function Language({ children, language }) {
  if (!Array.isArray(children)) {
    children = [children];
  }

  children = children.map( component => change_language_to(component, language));

  if (children.length == 1) {
    return (
      <TabItem value={0} label={children[0].props.fname}>
        {children[0]}
      </TabItem>
    );
  } else {
    return (
      <Tabs className="file-tabs">
        {children.map((component, index) => {
          return (
            <TabItem value={index} label={component.props.fname}>
              {component}
            </TabItem>
          );
        })}
      </Tabs>
    );
  }
}

export function Github({ url, start, end, language, fname, metastring }) {
  return GitHubInternal({ url, start, end, language, fname, metastring });
}

/* AUX function */
function change_language_to(component, language) {
  const { children, url, start, end, fname } = component.props;

  if (component.type === Github) {
    return Github({ url, start, end, language, fname });
  }

  return component;
}

'''
'''--- website/src/components/featurelist.js ---
import React from "react";
import useDocusaurusContext from '@docusaurus/useDocusaurusContext';

export function FeatureList({ children }) {
  return <>
    <div className="row">
      {children}
    </div>
  </>
}

export function Column({ title, children, size = 4 }) {
  return <>
    <div className={`col col--${size}`}>
      <h3>{title}</h3>
      {children}
    </div>
  </>
}

export function Feature({ image, title, subtitle, url, highlight = false }) {
  const { siteConfig, i18n } = useDocusaurusContext();
  let link;
  if (url.startsWith('http')) {
    link = <svg width="0.8rem" height="0.8rem" aria-hidden="true" viewBox="0 0 24 24" className="iconExternalLink_node_modules-@docusaurus-theme-classic-lib-theme-Icon-ExternalLink-styles-module"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg>;
  } else if (i18n.currentLocale != i18n.defaultLocale) {
    url = "/" + i18n.currentLocale + url;
  }

  return <>
    <h4>  </h4>
    <a className="avatar" href={url} style={{ color: highlight && "var(--ifm-color-primary)" }}>
      <img
        className="avatar__photo"
        src={require(`@site/static/docs/assets/welcome-pages/${image}`).default} />
      <div className="avatar__intro">
        <div className="avatar__name">{title} {link}</div>
        <small className="avatar__subtitle">{subtitle}</small>
      </div>
    </a>
  </>
}
'''
'''--- website/src/components/github.js ---
import CodeBlock from '@theme/CodeBlock'
import { useEffect, useState } from 'react'

function toRaw(ref) {
  const fullUrl = ref.slice(ref.indexOf('https'));
  const [url, loc] = fullUrl.split('#');
  const [org, repo, blob, branch, ...pathSeg] = new URL(url).pathname.split('/').slice(1);
  return `https://raw.githubusercontent.com/${org}/${repo}/${branch}/${pathSeg.join('/')}`;
}

async function fetchCode(url, fromLine, toLine) {
  let res

  // check if stored in cache
  const validUntil = localStorage.getItem(`${url}-until`)

  if (validUntil && validUntil > Date.now()) {
    res = localStorage.getItem(url)
  } else {
    try {
      res = await ((await fetch(url)).text())
      localStorage.setItem(url, res)
      localStorage.setItem(`${url}-until`, Date.now() + 60000)
    } catch { return "Error fetching code, please try reloading" }
  }

  let body = res.split('\n')
  fromLine = fromLine ? Number(fromLine) - 1 : 0;
  toLine = toLine ? Number(toLine) : body.length;
  body = body.slice(fromLine, toLine);

  // Remove indentation on nested code
  const preceedingSpace = body.reduce((prev, line) => {
    if (line.length === 0) return prev

    const spaces = line.match(/^\s+/)
    if (spaces) return Math.min(prev, spaces[0].length)

    return 0
  }, Infinity)

  return body.map((line) => line.slice(preceedingSpace)).join('\n')
}

export function GitHubInternal({ url, start, end, language, fname, metastring }) {
  const [code, setCode] = useState('Loading...');

  useEffect(() => {
    const rawUrl = toRaw(url);
    const promise = fetchCode(rawUrl, start, end);
    promise.then(res => setCode(res));
  })

  return <div fname={fname}>
    <CodeBlock language={language} metastring={`${metastring} showLineNumbers`}>
      {code}
    </CodeBlock>
    <div style={{
      fontSize: '0.9em',
      fontWeight: 600,
      color: 'rgb(14, 117, 221)',
      textAlign: 'center',
      paddingBottom: '13px',
      textDecoration: 'underline'
    }}>
      <a href={url} target="_blank" rel="noreferrer noopener">See full example on GitHub</a>
    </div>
  </div>;
}

export default GitHubInternal;
'''
'''--- website/src/components/helpcomponent.js ---
import React from "react";

export function HelpComponent({ children }) {
  return <>
    <div class="theme-admonition theme-admonition-tip admonition_node_modules-@docusaurus-theme-classic-lib-theme-Admonition-Layout-styles-module alert alert--success">

      <details>
        <summary><b style={{ cursor: 'pointer' }}>Need some help? <a>Chat with us</a></b> or check our <a href="/help">Dev Resources</a>!</summary>

        <div class="row mb-1">
          <div class="col col--3">
            <div className="avatar">
              <img
                className="avatar__photo avatar__photo--sm"
                src={require("@site/static/docs/assets/home/twitter.png").default} />
              <div className="avatar__intro">
                <div className="avatar__name"><a href="https://twitter.com/@nearprotocol">Twitter</a></div>
              </div>
            </div>
          </div>
          <div class="col col--3">
            <div className="avatar">
              <img
                className="avatar__photo avatar__photo--sm"
                src={require("@site/static/docs/assets/home/telegram.png").default} />
              <div className="avatar__intro">
                <div className="avatar__name"><a href="https://t.me/neardev">Telegram</a></div>
              </div>
            </div>
          </div>
          <div class="col col--3">
            <div className="avatar">
              <img
                className="avatar__photo"
                src={require("@site/static/docs/assets/home/discord.png").default} />
              <div className="avatar__intro">
                <div className="avatar__name"><a href="https://near.chat">Discord</a></div>
              </div>
            </div>
          </div>
          <div class="col col--3">
            <div className="avatar">
              <img
                className="avatar__photo"
                src={require("@site/static/docs/assets/home/zulip.png").default} />
              <div className="avatar__intro">
                <div className="avatar__name"><a href="https://near.zulipchat.com/">Zulip</a></div>
              </div>
            </div>
          </div>
        </div>
      </details>

    </div>

  </>
}

'''
'''--- website/src/components/near-widget.js ---
import React, { useState, useEffect } from "react";
import { useWallet } from '@theme/scripts/wallet-selector';
import BrowserOnly from '@docusaurus/BrowserOnly';
import "react-bootstrap-typeahead/css/Typeahead.css";
import "react-bootstrap-typeahead/css/Typeahead.bs5.css";

export function NearWidget({ children, id = 1, height = "160px" }) {

  return (
    <BrowserOnly fallback={<div> Loading... </div>}>
      {() => {
        let startCode = '';
        try {
          if (!children.length) children = [children]
          startCode = children[0].props.children.props.children;
        } catch (e) { }
        const { Widget, useInitNear } = require('near-social-vm');

        const [code, setCode] = useState(startCode);
        const { initNear } = useInitNear();
        const { selector } = useWallet();

        useEffect(() => {
          initNear && selector && initNear({ networkId: 'testnet', selector });
        }, [initNear, selector]);

        return <>
          <div className="code_iframe">
            <div className="bootstrap-scope">
              <div className="vm-widget">
                <Widget code={code} key={id} />
              </div>
            </div>
          </div>
        </>
      }}
    </BrowserOnly>
  )
}

export default NearWidget;
'''
'''--- website/src/components/social-widget.js ---
import React, { useState, useEffect } from "react";
import { useWallet } from '@theme/scripts/wallet-selector';
import BrowserOnly from '@docusaurus/BrowserOnly';
import "react-bootstrap-typeahead/css/Typeahead.css";
import "react-bootstrap-typeahead/css/Typeahead.bs5.css";

export function WidgetEditor({ children, id = 1, height = "160px" }) {

  return (
    <BrowserOnly fallback={<div> Loading... </div>}>
      {() => {
        let startCode = '';
        try {
          if (!children.length) children = [children]
          startCode = children[0].props.children.props.children;
        } catch (e) { }
        const { Widget, useInitNear } = require('near-social-vm');
        const MonacoEditor = require('react-monaco-editor').default;

        const [code, setCode] = useState(startCode);
        const { initNear } = useInitNear();
        const { selector } = useWallet();

        useEffect(() => {
          initNear && selector && initNear({ networkId: 'testnet', selector });
        }, [initNear, selector]);

        return <div>
          <div className="monaco">
            <MonacoEditor
              height={height}
              value={code}
              options={{
                minimap: { enabled: false },
                wordWrap: 'on',
                scrollBeyondLastLine: false,
                fontSize: '14px',
                renderLineHighlight: false,
                hideMargin: true,
                glyphMargin: false,
                folding: false,
                lineNumbers: false,
                lineDecorationsWidth: 0,
                lineNumbersMinChars: 0,
                scrollBars: false,
              }}
              onChange={(newValue, event) => setCode(newValue)}
            />
          </div>

          <div className="code_iframe">
            <div className="bootstrap-scope">
              <div className="vm-widget">
                <Widget code={code} key={id} />
              </div>
            </div>
          </div>
          {children[1]}
        </div>
      }}
    </BrowserOnly>
  )
}

export default WidgetEditor;
'''
'''--- website/src/components/widget-editor.js ---
import React, { useState, useEffect } from "react";
import { useWallet } from '@theme/scripts/wallet-selector';
import BrowserOnly from '@docusaurus/BrowserOnly';
import "react-bootstrap-typeahead/css/Typeahead.css";
import "react-bootstrap-typeahead/css/Typeahead.bs5.css";

export function WidgetEditor({ children, id = 1, height = "160px" }) {

  return (
    <BrowserOnly fallback={<div> Loading... </div>}>
      {() => {
        let startCode = '';
        try {
          if (!children.length) children = [children]
          startCode = children[0].props.children.props.children;
        } catch (e) { }
        const { Widget, useInitNear } = require('near-social-vm');
        const MonacoEditor = require('react-monaco-editor').default;

        const [code, setCode] = useState(startCode);
        const { initNear } = useInitNear();
        const { selector } = useWallet();

        useEffect(() => {
          initNear && selector && initNear({ networkId: 'testnet', selector });
        }, [initNear, selector]);

        return <div>
          <div className="monaco">
            <MonacoEditor
              height={height}
              value={code}
              options={{
                minimap: { enabled: false },
                wordWrap: 'on',
                scrollBeyondLastLine: false,
                fontSize: '14px',
                renderLineHighlight: false,
                hideMargin: true,
                glyphMargin: false,
                folding: false,
                lineNumbers: false,
                lineDecorationsWidth: 0,
                lineNumbersMinChars: 0,
                scrollBars: false,
              }}
              onChange={(newValue, event) => setCode(newValue)}
            />
          </div>

          <div className="code_iframe">
            <div className="bootstrap-scope">
              <div className="vm-widget">
                <Widget code={code} key={id} />
              </div>
            </div>
          </div>
          {children[1]}
        </div>
      }}
    </BrowserOnly>
  )
}

export default WidgetEditor;
'''
'''--- website/src/plugins/monaco-editor/index.js ---
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const MonacoWebpackPlugin = require('monaco-editor-webpack-plugin');

module.exports = function(context, options) {
  return {
    name: 'monaco-editor',
    configureWebpack(config, isServer) {
      return {
        module: {
          rules: [
            {
              test: /\.ttf$/,
              use: ['file-loader'],
            },
          ],
        },
        plugins: [
          new MonacoWebpackPlugin({
            languages: ['javascript', 'json', 'typescript'],
          }),
        ],
      };
    },
  };
};
'''
'''--- website/src/plugins/node-polyfills/index.js ---
const webpack = require('webpack');

// eslint-disable-next-line
module.exports = function (context, options) {
  return {
    name: 'node-polyfills',
    // eslint-disable-next-line
    configureWebpack(config, isServer, utils) {
      return {
        plugins: [
          new webpack.ProvidePlugin({
            process: 'process/browser.js',
            Buffer: ['buffer', 'Buffer'],
          }),
        ],
        resolve: {
          alias: {
          },
          fallback: {
            crypto: require.resolve('crypto-browserify'),
            http: require.resolve('stream-http'),
            https: require.resolve("https-browserify"),
            buffer: require.resolve('buffer'),
            stream: require.resolve("stream-browserify"),
            url: require.resolve("url")
          },
        },
      }
    },
  }
};
'''
'''--- website/src/theme/DocItem/Footer/index.js ---
import React from 'react';
import Footer from '@theme-original/DocItem/Footer';
import {FeedbackComponent} from "../../../components/FeedbackComponent";
import {HelpComponent} from "../../../components/helpcomponent";

export default function FooterWrapper(props) {
  return (
    <>
      <Footer {...props} />

      <div class="theme-admonition theme-admonition-tip admonition_node_modules-@docusaurus-theme-classic-lib-theme-Admonition-Layout-styles-module alert alert--info">
      <FeedbackComponent />
      </div>

      <HelpComponent />

    </>
  );
}

'''
'''--- website/src/theme/Footer/index.js ---
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import React from 'react';
import { useThemeConfig } from '@docusaurus/theme-common';
import './footer.scss';

function Footer() {
  const { footer } = useThemeConfig();

  if (!footer) {
    return null;
  }

  return (
    <footer className="footer">
      <div>
      <div className="container relative text-white pb-40 md:pb-100 pt-100">
        <div className="row">
          <div className="col md:w-3/4 mt-50 md:mt-0" style={{ zIndex: "1" }}>
            <ul className="list-reset flex flex-wrap -mx-20">
              <li className="mx-20">
                <a
                  href="https://gov.near.org"
                  className="block hover:text-discourse"
                  target="_blank"
                  id="discourse-1"
                >
                  <span className="icon icon-36">
                    <svg
                      enableBackground="new 0 0 34 35"
                      viewBox="0 0 34 35"
                      xmlns="http://www.w3.org/2000/svg"
                    >
                      <path d="m0 25.1c0-2.6 0-5.2 0-7.8 0-4.7 1.8-8.8 5.2-12.1 2.6-2.5 5.8-4 9.4-4.5 6.9-1.1 13.7 2.3 17.2 8.4 1.6 3 2.4 6.2 2.2 9.5-.4 4.6-2.3 8.5-5.7 11.6-2.5 2.2-5.4 3.6-8.6 4.1-.6.1-1.3.2-2 .2-5.7 0-11.4 0-17.1 0-.4 0-.5-.1-.5-.5-.1-3-.1-6-.1-8.9zm16.9-17.3c-.6 0-1.2.1-1.8.2-6.2 1.3-9.6 8.1-6.7 13.7.1.3.1.5.1.7-.5 1.6-1 3.2-1.4 4.7-.1.1-.1.3-.1.4.1.1.3 0 .4-.1 1.7-.4 3.4-.9 5.1-1.3.3-.1.6-.1.9.1 1.6.7 3.4.9 5.1.6 5.2-.8 8.9-5.7 8.1-11-.8-4.5-4.8-8-9.7-8z"></path>
                    </svg>
                  </span>
                  <span className="screen-reader-text">Forum</span>
                </a>
              </li>
              <li className="mx-20">
                <a
                  href="https://twitter.com/nearprotocol"
                  className="block hover:text-twitter"
                  target="_blank"
                >
                  <span className="icon icon-36 ">
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      viewBox="0 0 512 512"
                    >
                      <path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path>
                    </svg>
                  </span>
                  <span className="screen-reader-text">Twitter</span>
                </a>
              </li>
              <li className="mx-20">
                <a
                  href="https://github.com/near"
                  className="block hover:text-github"
                  target="_blank"
                >
                  <span className="icon icon-36 ">
                    <svg
                      height="36"
                      viewBox="0 0 36 36"
                      width="36"
                      xmlns="http://www.w3.org/2000/svg"
                    >
                      <path d="m17.9991429 0c-9.93942861 0-17.9991429 8.058-17.9991429 18.0008571 0 7.9517143 5.15742857 14.6982858 12.3102857 17.0794286.9.1645714 1.2291429-.3908571 1.2291429-.8682857 0-.4268571-.0162857-1.5591429-.0248572-3.0608571-5.0065714 1.0868571-6.06342854-2.4137143-6.06342854-2.4137143-.81857143-2.0785715-1.99885715-2.6322857-1.99885715-2.6322857-1.63371428-1.1177143.12428572-1.0937143.12428572-1.0937143 1.806.1268571 2.75742857 1.8548571 2.75742857 1.8548571 1.60542857 2.7505714 4.2128571 1.956 5.238 1.4948572.1628571-1.1631429.6282857-1.956 1.1425714-2.406-3.9968571-.4542858-8.1985714-1.9988572-8.1985714-8.8962858 0-1.9654285.70114286-3.5717142 1.85228571-4.83-.18514285-.456-.80314285-2.28514281.17657143-4.76399996 0 0 1.51114286-.48342857 4.94999996 1.84542857 1.4357143-.39942857 2.9751429-.59914285 4.506-.606 1.5282858.00685715 3.0685715.20657143 4.5068572.606 3.4362857-2.32885714 4.944-1.84542857 4.944-1.84542857.9831428 2.47885715.3651428 4.30799996.1791428 4.76399996 1.1545715 1.2582858 1.8505715 2.8645715 1.8505715 4.83 0 6.9154286-4.2085715 8.436-8.2182857 8.8825715.6462857.5554285 1.2214285 1.6534285 1.2214285 3.3325714 0 2.4068571-.0214285 4.3482857-.0214285 4.938 0 .4817143.324 1.0414286 1.2377142.8657143 7.146-2.3845714 12.2991429-9.1277143 12.2991429-17.0768572 0-9.9428571-8.0597143-18.0008571-18.0008571-18.0008571" />
                    </svg>
                  </span>
                  <span className="screen-reader-text">GitHub</span>
                </a>
              </li>
              <li className="mx-20">
                <a
                  href="http://near.chat"
                  className="block hover:text-discord"
                  target="_blank"
                >
                  <span className="icon icon-36 ">
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      viewBox="0 0 448 512"
                    >
                      <path d="M297.216 243.2c0 15.616-11.52 28.416-26.112 28.416-14.336 0-26.112-12.8-26.112-28.416s11.52-28.416 26.112-28.416c14.592 0 26.112 12.8 26.112 28.416zm-119.552-28.416c-14.592 0-26.112 12.8-26.112 28.416s11.776 28.416 26.112 28.416c14.592 0 26.112-12.8 26.112-28.416.256-15.616-11.52-28.416-26.112-28.416zM448 52.736V512c-64.494-56.994-43.868-38.128-118.784-107.776l13.568 47.36H52.48C23.552 451.584 0 428.032 0 398.848V52.736C0 23.552 23.552 0 52.48 0h343.04C424.448 0 448 23.552 448 52.736zm-72.96 242.688c0-82.432-36.864-149.248-36.864-149.248-36.864-27.648-71.936-26.88-71.936-26.88l-3.584 4.096c43.52 13.312 63.744 32.512 63.744 32.512-60.811-33.329-132.244-33.335-191.232-7.424-9.472 4.352-15.104 7.424-15.104 7.424s21.248-20.224 67.328-33.536l-2.56-3.072s-35.072-.768-71.936 26.88c0 0-36.864 66.816-36.864 149.248 0 0 21.504 37.12 78.08 38.912 0 0 9.472-11.52 17.152-21.248-32.512-9.728-44.8-30.208-44.8-30.208 3.766 2.636 9.976 6.053 10.496 6.4 43.21 24.198 104.588 32.126 159.744 8.96 8.96-3.328 18.944-8.192 29.44-15.104 0 0-12.8 20.992-46.336 30.464 7.68 9.728 16.896 20.736 16.896 20.736 56.576-1.792 78.336-38.912 78.336-38.912z"></path>
                    </svg>
                  </span>
                  <span className="screen-reader-text">Discord</span>
                </a>
              </li>
              <li className="mx-20">
                <a
                  href="https://t.me/cryptonear"
                  className="block hover:text-telegram"
                  target="_blank"
                >
                  <span className="icon icon-36 ">
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      viewBox="0 0 496 512"
                    >
                      <path d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm121.8 169.9l-40.7 191.8c-3 13.6-11.1 16.9-22.4 10.5l-62-45.7-29.9 28.8c-3.3 3.3-6.1 6.1-12.5 6.1l4.4-63.1 114.9-103.8c5-4.4-1.1-6.9-7.7-2.5l-142 89.4-61.2-19.1c-13.3-4.2-13.6-13.3 2.8-19.7l239.1-92.2c11.1-4 20.8 2.7 17.2 19.5z"></path>
                    </svg>
                  </span>
                  <span className="screen-reader-text">Telegram</span>
                </a>
              </li>
              <li className="mx-20">
                <a
                  href="https://www.youtube.com/channel/UCuKdIYVN8iE3fv8alyk1aMw"
                  className="block hover:text-youtube"
                  target="_blank"
                >
                  <span className="icon icon-36 ">
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      viewBox="0 0 576 512"
                    >
                      <path d="M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z"></path>
                    </svg>
                  </span>
                  <span className="screen-reader-text">YouTube</span>
                </a>
              </li>
            </ul>
            <div className="row">
            <div className="col sm:w-1/3 mt-50">
                <h2 className="text-24 font-black text-blue-light">
                  <a href="/concepts/welcome">
                    Concepts
                  </a>
                </h2>
                <ul
                  id="menu-concepts-1"
                  className="footer-menu list-reset mt-5 text-16 md:text-16"
                >
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/concepts/basics/protocol">
                      What is Near?
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/concepts/protocol/account-model">
                      Accounts
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/concepts/protocol/transactions">
                      Transactions
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/concepts/data-flow/near-data-flow">
                      Data Flow
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/concepts/basics/tokens">
                      Token
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/concepts/storage/data-storage">
                      Storage
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/concepts/basics/validators">
                      Validators
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/concepts/abstraction/introduction">
                      Chain Abstraction
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/concepts/data-flow/data-storage">
                      Data on Blockchain
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/concepts/basics/runtime">
                      Runtime
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/concepts/web3/intro">
                      Web3 Intro
                    </a>
                  </li>
                </ul>
              </div>
              <div className="col sm:w-1/3 mt-50">
                <h2 className="text-24 font-black text-blue-light">
                  <a href="/build/welcome">
                    Build
                  </a>
                </h2>
                <ul
                  id="menu-build-1"
                  className="footer-menu list-reset mt-5 text-16 md:text-16"
                >
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/build/chain-abstraction/what-is">
                      Chain Abstraction
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/build/smart-contracts/what-is">
                      Smart Contracts
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/build/near-components/what-is">
                      Components
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/build/web3-apps/what-is">
                      Web3 Apps
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/build/primitives/what-is">
                      Primitives
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/build/chain-abstraction/data-availability">
                      Data Availability
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/build/data-infrastructure/what-is">
                      Data Infrastructure
                    </a>
                  </li>
                </ul>
              </div>
              <div className="col sm:w-1/3 mt-50">
                <h2 className="text-24 font-black text-blue-light">
                  <a href="/tutorials/welcome">
                    Tutorials
                  </a>
                </h2>
                <ul
                  id="menu-tutorials-1"
                  className="footer-menu list-reset mt-5 text-16 md:text-16"
                >
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/tutorials/examples/count-near">
                    Smart Contract
                    </a>
                  </li>                                 
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/tutorials/nfts/minting-nfts">
                      Mint NFTs
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/tutorials/fts/introduction">
                      FTs
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/tutorials/near-components/bos-loader">
                      Components
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/build/data-infrastructure/lake-framework/near-lake-state-changes-indexer">
                      Indexers
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="https://github.com/near-examples">
                      Examples
                    </a>
                  </li>   
                </ul>
              </div>
              <div className="col sm:w-1/3 mt-50">
                <h2 className="text-24 font-black text-blue-light">
                  <a href="/api/rpc/introduction">
                    RPC
                  </a>
                </h2>
                <ul
                  id="menu-rpc-1"
                  className="footer-menu list-reset mt-5 text-16 md:text-16"
                >
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/api/rpc/providers">
                      RPC Providers
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/api/rpc/setup">
                      Setup
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/api/rpc/access-keys">
                      Access Keys
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/api/rpc/contracts">
                      Contracts
                    </a>
                  </li>
                </ul>
              </div>
              <div className="col sm:w-1/3 mt-50">
                <h2 className="text-24 font-black text-blue-light">
                  <a href="/tools/welcome">
                    Tools
                  </a>
                </h2>
                <ul
                  id="menu-rpc-1"
                  className="footer-menu list-reset mt-5 text-16 md:text-16"
                >
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/tools/near-api-js/quick-reference">
                      API
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/sdk/welcome">
                      SDK
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/tools/near-cli">
                      CLI
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/tools/wallet-selector">
                      Wallet Selector
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/build/chain-abstraction/fastauth-sdk">
                      FastAuth
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/build/chain-abstraction/what-is">
                      Relayers
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="https://jutsu.ai/editor">
                      Justu IDE
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="https://docs.welldonestudio.io/code/getting-started">
                      Remix IDE
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="https://wallet.near.org">
                      Wallets
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="https://near-faucet.io/">
                      Faucet
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/tools/explorer">
                      Explorers
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/tools/indexing">
                      Indexing
                    </a>
                  </li>
                </ul>
              </div>
              <div className="col sm:w-1/3 mt-50">
                <h2 className="text-24 font-black text-blue-light">
                  Resources
                </h2>
                <ul
                  id="menu-developers-1"
                  className="footer-menu list-reset mt-5 text-16 md:text-16"
                >
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="https://near.org/devhub.near/widget/app">
                      DevHub
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="https://learnnear.club/">
                      Learn NEAR Club 
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="https://agorapp.dev/catalog/course?difficulty=&chains=near">
                      AgorApp 
                    </a>
                  </li>    
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="/blog">
                      Blog
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="https://github.com/near">
                      GitHub
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="https://discord.gg/GZ7735Xjce">
                      Discord Support
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="https://t.me/neardev">
                      Telegram Support
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="https://nomicon.io/">
                      Protocol Docs
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="https://near-nodes.io/">
                      Validator Docs
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                    <a href="https://aurora.dev/">
                      Aurora EVM
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-custom menu-item-object-custom menu-item-2945">
                    <a
                      target="_blank"
                      href="https://near.org/founders"
                    >
                      Startup Accelerator
                    </a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-2045">
                  <a href="https://wiki.near.org">
                    Wiki
                  </a>
                  </li>
                  <li className="menu-item menu-item-type-custom menu-item-object-custom menu-item-6804">
                    <a href="https://gov.near.org">Forum</a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-441">
                    <a href="https://near.org/about">About Us</a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-124">
                    <a href="https://careers.near.org/jobs">Careers</a>
                  </li>
                  <li className="menu-item menu-item-type-post_type menu-item-object-page menu-item-3267">
                    <a href="https://near.org/privacy">Privacy Policy</a>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>

        <p className="text-14 mt-50 md:mt-100">Copyright &copy;
          {new Date().getFullYear()} <a href="https://near.org" className="hover:text-yellow">NEAR Protocol</a><span className="mx-10">|</span>All rights
          reserved<span className="mx-10">|</span>
          <a href="mailto:hello@near.org" className="hover:text-yellow">
            hello@near.org
          </a>
          <span className="mx-10">|</span>
          <a href="https://near.org/privacy" className="hover:text-yellow">
            Privacy Policy
          </a>
          <span className="mx-10">|</span>
          Some icons created by <a href="https://www.flaticon.com/free-icons/coin" title="coin icons">Good Ware, Flaticon, and Freepick</a>
        </p>
      </div></div>
    </footer>
  );
}

export default Footer;

'''
'''--- website/src/theme/Icon/Arrow/index.js ---
import React from 'react';
export default function IconArrow(props) {

  if (props.className.startsWith("collapse")) return "Hide";

  return (
    <svg width="20" height="20" aria-hidden="true" {...props}>
      <g fill="#7a7a7a">
        <path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0" />
        <path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0" />
      </g>
    </svg>
  );
}

'''
'''--- website/src/theme/Navbar/MobileSidebar/index.js ---
import React from 'react';
import {
  useLockBodyScroll,
  useNavbarMobileSidebar,
} from '@docusaurus/theme-common/internal';
import NavbarMobileSidebarLayout from '@docusaurus/theme-classic/lib/theme/Navbar/MobileSidebar/Layout';
import NavbarMobileSidebarHeader from '@docusaurus/theme-classic/lib/theme/Navbar/MobileSidebar/Header';
import NavbarMobileSidebarPrimaryMenu from '@docusaurus/theme-classic/lib/theme/Navbar/MobileSidebar/PrimaryMenu';
import NavbarMobileSidebarSecondaryMenu from '@docusaurus/theme-classic/lib/theme/Navbar/MobileSidebar/SecondaryMenu';

export default function NavbarMobileSidebar() {
  const mobileSidebar = useNavbarMobileSidebar();
  useLockBodyScroll(mobileSidebar.shown);

  // @gagdiez: commented this to make sidebar always available
  // if (!mobileSidebar.shouldRender) {
  //   return null;
  // }

  return (
    <NavbarMobileSidebarLayout
      header={<NavbarMobileSidebarHeader />}
      primaryMenu={<NavbarMobileSidebarPrimaryMenu />}
      secondaryMenu={<NavbarMobileSidebarSecondaryMenu />}
    />
  );
}

'''
'''--- website/src/theme/NavbarItem/btn.module.css ---
.btn {
  vertical-align: top;
  padding: 10px;
  border-radius: .7rem;
  font-weight: 700;
  line-height: 20px;
  background-color: #00c08b;
  color: #fff;
  text-align: center;
  transition: .2s;
  text-transform: uppercase;
  letter-spacing: 1px;
  cursor: pointer;
  margin: auto .7rem auto .4rem;
}
'''
'''--- website/src/theme/NavbarItem/index.js ---
import React from 'react';
import NavbarItem from '@theme-original/NavbarItem';
import LoginButton from './login-button'

export default function NavbarItemWrapper(props) {
  if (props.href === 'login') {
    return <LoginButton {...props} />
  } else {
    return <NavbarItem {...props} />
  }
}

'''
'''--- website/src/theme/NavbarItem/login-button.js ---
import React from 'react';
import { useState, useEffect } from 'react';
import { useWallet } from '@theme/scripts/wallet-selector';
import styles from './btn.module.css';

export default function LoginButton(props) {
  const { signedAccountId, logOut, logIn } = useWallet();
  const [action, setAction] = useState(() => { });
  const [label, setLabel] = useState('Loading...');

  useEffect(() => {
    if (signedAccountId) {
      setAction(() => logOut);
      setLabel(`Logout`);
    } else {
      setAction(() => logIn);
      setLabel('Login');
    }
  }, [signedAccountId, logOut, logIn, setAction, setLabel]);

  if (props.mobile){
    return <li className='menu__list-item'>
      <button className={`menu__link ${styles.btn}`} onClick={action}> {label} </button>
    </li>
  }else{
    return <button className={`navbar__item navbar__link ${styles.btn}`} onClick={action}> {label} </button>
  }

}

'''
'''--- website/src/theme/NotFound/Content/index.js ---
import React from 'react';
import clsx from 'clsx';
import Translate from '@docusaurus/Translate';
import Heading from '@theme/Heading';
export default function NotFoundContent({ className }) {
  return (
    <main className={clsx('container margin-vert--xl', className)}>
      <div className="row">
        <div className="col col--12">
          <Heading as="h1" className="hero__title text-center">
            <Translate
              id="theme.NotFound.title"
              description="The title of the 404 page">
              üìï Oops! We Couldn't Find That Page
            </Translate>
          </Heading>
          <p className='margin-vert--md text-center'>
            <Translate
              id="theme.NotFound.p1"
              description="The first paragraph of the 404 page">
              Where you following a link? Let us know using the Feedback button and we will setup a redirect for you in no time
            </Translate>
          </p>
          <div className="container p404">
            <h4 className='text-center'> Don't give up! Check these awesome resources </h4>
            <div className="row">
              <div className="col col--4">
                <div className="card">
                  <div className="card__image">
                    <img src={require("@site/static/docs/assets/welcome-pages/protocol.png").default} alt="Learn" />
                  </div>
                  <div className="card__body">
                    <h3>Understanding NEAR</h3>
                    Learn about NEAR and how it works
                    <ul className='margin-vert--sm'>
                      <a href="/concepts/basics/protocol"><li>What is NEAR?</li></a>
                      <a href="/concepts/protocol/account-id"><li>Named Accounts</li></a>
                      <a href="/concepts/protocol/access-keys"><li>Access Keys</li></a>
                      <a href="/concepts/protocol/transactions"><li>Transactions</li></a>
                      <a href="/concepts/protocol/gas"><li>Understanding Gas</li></a>
                    </ul>
                  </div>
                </div>
              </div>
              <div className="col col--4">
                <div className="card">
                  <div className="card__image">
                    <img src={require("@site/static/docs/assets/welcome-pages/contracts.png").default} alt="Contracts" />
                  </div>
                  <div className="card__body">
                    <h3>Build</h3>
                    Build awesome applications on NEAR
                    <ul className='margin-vert--sm'>
                      <a href="/build/smart-contracts/what-is"><li>Smart Contracts</li></a>
                      <a href="/build/near-components/what-is"><li>NEAR Components</li></a>
                      <a href="/build/web3-apps/what-is"><li>Web3 Applications</li></a>
                      <a href="/build/chain-abstraction/meta-transactions"><li>Relayers</li></a>
                      <a href="/build/chain-abstraction/chain-signatures"><li>Multi-Chain Signatures</li></a>
                      <a href="/build/primitives/what-is"><li>Primitives (FT, NFT, ...)</li></a>
                      <a href="/build/data-infrastructure/what-is"><li>Indexers & Data Solutions</li></a>
                      <a href="/build/chain-abstraction/data-availability"> Data Availability .</a>
                    </ul>
                  </div>
                </div>
              </div>
              <div className="col col--4">
                <a href="/tutorials/welcome">
                  <div className="card">
                    <div className="card__image">
                      <img src={require("@site/static/docs/assets/welcome-pages/examples.png").default} alt="Tutorials" />
                    </div>
                    <div className="card__body">
                      <h3>Tutorials</h3>
                      Lots of tutorials to get you started
                      <ul className='margin-vert--sm'>
                        <a href="/tutorials/examples/count-near"><li>Basic dApps</li></a>
                        <a href="/tutorials/examples/factory"><li>Advanced Contracts</li></a>
                        <a href="/tutorials/nfts/introduction"><li>NFT: Zero to Hero</li></a>
                        <a href="/tutorials/near-components/indexer-tutorials/nft-indexer"><li>Indexer Tutorials</li></a>
                      </ul>
                    </div>
                  </div>
                </a>
              </div>
            </div>
          </div>

        </div>
      </div>
    </main>
  );
}

'''
'''--- website/src/theme/NotFound/index.js ---
import React from 'react';
import {translate} from '@docusaurus/Translate';
import {PageMetadata} from '@docusaurus/theme-common';
import Layout from '@theme/Layout';
import NotFoundContent from '@theme/NotFound/Content';
export default function Index() {
  const title = translate({
    id: 'theme.NotFound.title',
    message: 'Page Not Found',
  });
  return (
    <>
      <PageMetadata title={title} />
      <Layout>
        <NotFoundContent />
      </Layout>
    </>
  );
}

'''
'''--- website/src/theme/Root.js ---
// https://docusaurus.io/docs/swizzling#wrapper-your-site-with-root
import '@near-wallet-selector/modal-ui/styles.css';

import React from 'react';
import Gleap from "gleap"; // See https://gleap.io/docs/javascript/ and https://app.gleap.io/projects/62697858a4f6850036ae2e6a/widget
import { withRouter } from 'react-router-dom';
import useIsBrowser from '@docusaurus/useIsBrowser'; // https://docusaurus.io/docs/advanced/ssg#useisbrowser

import { useInitWallet } from '@theme/scripts/wallet-selector';

function Root({ children, location }) {
    useInitWallet({ createAccessKeyFor: 'v1.social08.testnet', networkId: 'testnet' });
    const isBrowser = useIsBrowser();

    if (isBrowser) {
        const { initRudderAnalytics, recordPageView } = require('./scripts/rudderstack');

        Gleap.initialize('K2v3kvAJ5XtPzNYSgk4Ulpe5ptgBkIMv');

        const rudderAnalytics = initRudderAnalytics();
        recordPageView(rudderAnalytics, location.pathname);
    }
    return <>{children}</>;
}

const router = withRouter(Root);

export default router;
'''
'''--- website/src/theme/SearchBar/index.js ---
import React, { useCallback, useMemo, useRef, useState } from 'react';
import { createPortal } from 'react-dom';
import { DocSearchButton, useDocSearchKeyboardEvents } from '@docsearch/react';
import Head from '@docusaurus/Head';
import Link from '@docusaurus/Link';
import { useHistory } from '@docusaurus/router';
import {
  isRegexpStringMatch,
  useSearchLinkCreator,
} from '@docusaurus/theme-common';
import {
  useAlgoliaContextualFacetFilters,
  useSearchResultUrlProcessor,
} from '@docusaurus/theme-search-algolia/client';
import Translate from '@docusaurus/Translate';
import useDocusaurusContext from '@docusaurus/useDocusaurusContext';
import translations from '@theme/SearchTranslations';

let DocSearchModal = null;

/* We only modified this */
function Hit(props) {
  const { hit, children } = props;
  return <>
    <Link to={hit.url}> {children} <div className='DocSearch-Description'>{hit.description}</div></Link>
  </>;
}

function ResultsFooter({ state, onClose }) {
  const createSearchLink = useSearchLinkCreator();
  return (
    <Link to={createSearchLink(state.query)} onClick={onClose}>
      <Translate
        id="theme.SearchBar.seeAll"
        values={{ count: state.context.nbHits }}>
        {'See all {count} results'}
      </Translate>
    </Link>
  );
}
function mergeFacetFilters(f1, f2) {
  const normalize = (f) => (typeof f === 'string' ? [f] : f);
  return [...normalize(f1), ...normalize(f2)];
}
function DocSearch({ contextualSearch, externalUrlRegex, ...props }) {
  const { siteMetadata } = useDocusaurusContext();
  const processSearchResultUrl = useSearchResultUrlProcessor();
  const contextualSearchFacetFilters = useAlgoliaContextualFacetFilters();
  const configFacetFilters = props.searchParameters?.facetFilters ?? [];
  const facetFilters = contextualSearch
    ? // Merge contextual search filters with config filters
    mergeFacetFilters(contextualSearchFacetFilters, configFacetFilters)
    : // ... or use config facetFilters
    configFacetFilters;
  // We let user override default searchParameters if she wants to
  const searchParameters = {
    ...props.searchParameters,
    facetFilters,
  };
  const history = useHistory();
  const searchContainer = useRef(null);
  const searchButtonRef = useRef(null);
  const [isOpen, setIsOpen] = useState(false);
  const [initialQuery, setInitialQuery] = useState(undefined);
  const importDocSearchModalIfNeeded = useCallback(() => {
    if (DocSearchModal) {
      return Promise.resolve();
    }
    return Promise.all([
      import('@docsearch/react/modal'),
      import('@docsearch/react/style'),
      import('./styles.css'),
    ]).then(([{ DocSearchModal: Modal }]) => {
      DocSearchModal = Modal;
    });
  }, []);
  const onOpen = useCallback(() => {
    importDocSearchModalIfNeeded().then(() => {
      searchContainer.current = document.createElement('div');
      document.body.insertBefore(
        searchContainer.current,
        document.body.firstChild,
      );
      setIsOpen(true);
    });
  }, [importDocSearchModalIfNeeded, setIsOpen]);
  const onClose = useCallback(() => {
    setIsOpen(false);
    searchContainer.current?.remove();
    searchButtonRef.current?.focus();
  }, [setIsOpen]);
  const onInput = useCallback(
    (event) => {
      importDocSearchModalIfNeeded().then(() => {
        setIsOpen(true);
        setInitialQuery(event.key);
      });
    },
    [importDocSearchModalIfNeeded, setIsOpen, setInitialQuery],
  );
  const navigator = useRef({
    navigate({ itemUrl }) {
      // Algolia results could contain URL's from other domains which cannot
      // be served through history and should navigate with window.location
      if (isRegexpStringMatch(externalUrlRegex, itemUrl)) {
        window.location.href = itemUrl;
      } else {
        history.push(itemUrl);
      }
    },
  }).current;
  const transformItems = useRef((items) =>
    props.transformItems
      ? // Custom transformItems
      props.transformItems(items)
      : // Default transformItems
      items.map((item) => ({
        ...item,
        url: processSearchResultUrl(item.url),
        description: item.description && item.description.split(/\.(?=\s)/)[0]
      })),
  ).current;
  const resultsFooterComponent = useMemo(
    () =>
      // eslint-disable-next-line react/no-unstable-nested-components
      (footerProps) =>
        <ResultsFooter {...footerProps} onClose={onClose} />,
    [onClose],
  );
  const transformSearchClient = useCallback(
    (searchClient) => {
      searchClient.addAlgoliaAgent(
        'docusaurus',
        siteMetadata.docusaurusVersion,
      );
      return searchClient;
    },
    [siteMetadata.docusaurusVersion],
  );
  useDocSearchKeyboardEvents({
    isOpen,
    onOpen,
    onClose,
    onInput,
    searchButtonRef,
  });

  return (
    <>
      <Head>
        {/* This hints the browser that the website will load data from Algolia,
        and allows it to preconnect to the DocSearch cluster. It makes the first
        query faster, especially on mobile. */}
        <link
          rel="preconnect"
          href={`https://${props.appId}-dsn.algolia.net`}
          crossOrigin="anonymous"
        />
      </Head>

      <DocSearchButton
        onTouchStart={importDocSearchModalIfNeeded}
        onFocus={importDocSearchModalIfNeeded}
        onMouseOver={importDocSearchModalIfNeeded}
        onClick={onOpen}
        ref={searchButtonRef}
        translations={translations.button}
      />
      {isOpen &&
        DocSearchModal &&
        searchContainer.current &&
        createPortal(
          <DocSearchModal
            onClose={onClose}
            initialScrollY={window.scrollY}
            initialQuery={initialQuery}
            navigator={navigator}
            transformItems={transformItems}
            hitComponent={Hit}
            transformSearchClient={transformSearchClient}
            {...(props.searchPagePath && {
              resultsFooterComponent,
            })}
            {...props}
            searchParameters={searchParameters}
            placeholder={translations.placeholder}
            translations={translations.modal}
          />,
          searchContainer.current,
        )}
    </>
  );
}
export default function SearchBar() {
  const { siteConfig } = useDocusaurusContext();
  return <DocSearch {...siteConfig.themeConfig.algolia} />;
}

'''
'''--- website/src/theme/SearchBar/styles.css ---
:root {
  --docsearch-primary-color: var(--ifm-color-primary);
  --docsearch-text-color: var(--ifm-font-color-base);
}

.DocSearch-Button {
  margin: 0;
  transition: all var(--ifm-transition-fast)
    var(--ifm-transition-timing-default);
}

.DocSearch-Container {
  z-index: calc(var(--ifm-z-index-fixed) + 1);
}

.DocSearch-Description {
  color: var(--ifm-font-color-base);
  font-size: small;
  margin: 0 .8rem .8rem 0;
}
'''
'''--- website/src/theme/scripts/rudderstack.js ---
import { nanoid } from 'nanoid';
import { createHash } from 'crypto';
import { get, split, truncate } from 'lodash';
import { RudderAnalytics } from '@rudderstack/analytics-js';

export function initRudderAnalytics() {
  const rudderAnalytics = new RudderAnalytics();
  window.rudderanalytics = rudderAnalytics;
  rudderAnalytics.load("2bP8Ev07SiL1ABLXhcru4JZQ5Uh", "https://near.dataplane.rudderstack.com", {});
  rudderAnalytics.setAnonymousId(getAnonymousId());
  return rudderAnalytics;
}

export function recordPageView(rudderAnalytics, pageName) {
  if(pageName === '/') return;
  if(!rudderAnalytics) return;
  
  // pageName should be /category/page and never contain ? or #
  // but just in case we split on ? and #
  const split = pageName.split('?')[0].split('#')[0].split('/');
  const category = split[1];
  const page = split.slice(2).join('/');
  try {
    rudderAnalytics.page(category, page, {
      hashId: localStorage.getItem('hashId') || '',
      url: filterURL(window.location.href),
      ref: filterURL(document.referrer),
    });
  } catch (e) { } // Silent error
}

// let rudderAnalytics = null;
// let hashId = '';
// let pendingEvents = [];

// export function setAccountIdHash(accountId) {
//   const hash = createHash('sha512');
//   hash.update(accountId);
//   hashId = hash.digest('hex');
//   localStorage.setItem('hashId', hashId);
// }

export function getAnonymousId() {
  const storageId = localStorage.getItem('anonymousUserId');

  if (storageId) {
    console.log("Existing storageId", storageId);
    return storageId;
  }

  console.log("Creating new storageId");
  const anonymousUserId = nanoid();
  const anonymousUserIdCreatedAt = new Date().toUTCString();
  localStorage.setItem('anonymousUserId', anonymousUserId);
  localStorage.setItem('anonymousUserIdCreatedAt', anonymousUserIdCreatedAt);

  return anonymousUserId;
}

function isStringAllowed(str) {
  const denyList = ['account_id', 'public_key', 'all_keys', 'publicKey', 'apiKey', 'accountId', 'email'];
  return !str || !denyList.some((param) => str.indexOf(param) !== -1);
}

function filterURL(url) {
  const [urlTrim, params] = split(url, '?');
  return isStringAllowed(params) ? url : urlTrim;
}

// const record = (eventType, e) => {
//   const key = get(e.target, 'placeholder', get(e.target, 'innerText', get(e.target, 'href')));
//   recordEventWithProps(eventType, {
//     element: truncate(key, { length: 255 }),
//     url: e.target ? filterURL(e.target.baseURI) : '',
//     xPath: getXPath(e.target),
//     componentSrc: getComponentName(e.target),
//   });
// };

// export const recordClick = (e) => record('click', e);
// export const recordMouseEnter = (e) => record('mouseover', e);
// export const recordTouchStart = (e) => record('touchstart', e);

// export function recordWalletConnect(accountId) {
//   if (!localStorage.getItem('hashId')) {
//     setAccountIdHash(accountId);
//     recordEvent('wallet-connected');
//   }
// }

// export function reset() {
//   if (!rudderAnalytics) return;
//   try {
//     recordEvent('wallet-logout');
//     localStorage.removeItem('hashId');
//     localStorage.removeItem('anonymousUserId');
//     localStorage.removeItem('anonymousUserIdCreatedAt');
//     rudderAnalytics.reset();
//   } catch (e) {
//     console.error(e);
//   }
// }

// export function recordEventWithProps(eventLabel, properties) {
//   if (!rudderAnalytics) return;
//   try {
//     rudderAnalytics.track(eventLabel, {
//       ...properties,
//       hashId: localStorage.getItem('hashId'),
//       anonymousUserIdCreatedAt,
//     });
//   } catch (e) {
//     console.error(e);
//   }
// }

// export function recordEvent(eventLabel) {
//   if (!rudderAnalytics) return;
//   try {
//     rudderAnalytics.track(eventLabel, {
//       hashId: localStorage.getItem('hashId'),
//       url: window.location.href,
//       anonymousUserIdCreatedAt,
//     });
//   } catch (e) {
//     console.error(e);
//   }
// }

// function getComponentName(element) {
//   if (!element) return '';
//   if (element.hasAttribute('data-component')) return element.getAttribute('data-component') || '';
//   return '';
// }

// function getXPath(element) {
//   if (!element) return '';
//   if (element.id !== '') return 'id("' + element.id + '")';
//   if (element === document.body) return element.tagName;

//   let ix = 0;
//   const siblings = element.parentNode?.children;
//   if (!siblings) return '';

//   for (let i = 0; i < siblings.length; i++) {
//     const sibling = siblings[i];
//     if (sibling === element) return getXPath(element.parentElement) + '/' + element.tagName + '[' + (ix + 1) + ']';
//     if (sibling.nodeType === 1 && sibling.tagName === element.tagName) ix++;
//   }

//   return '';
// }
'''
'''--- website/src/theme/scripts/wallet-selector.js ---
import { create as createStore } from 'zustand';
import { distinctUntilChanged, map } from 'rxjs';
import { providers } from 'near-api-js';
import { setupWalletSelector } from '@near-wallet-selector/core';
import { setupModal } from '@near-wallet-selector/modal-ui';
import { setupMyNearWallet } from '@near-wallet-selector/my-near-wallet';
import { setupHereWallet } from '@near-wallet-selector/here-wallet';

import { useEffect, useState } from 'react';

export const useWallet = createStore(set => ({
  signedAccountId: '',
  logOut: undefined,
  logIn: undefined,
  selector: undefined,
  viewMethod: undefined,
  callMethod: undefined,
  setLogActions: ({ logOut, logIn }) => set({ logOut, logIn }),
  setAuth: ({ signedAccountId }) => set({ signedAccountId }),
  setMethods: ({ viewMethod, callMethod }) => set({ viewMethod, callMethod }),
  setStoreSelector: ({ selector }) => set({ selector }),
}));

export function useInitWallet({ createAccessKeyFor, networkId }) {
  const setAuth = useWallet(store => store.setAuth);
  const setLogActions = useWallet(store => store.setLogActions);
  const setMethods = useWallet(store => store.setMethods);
  const setStoreSelector = useWallet(store => store.setStoreSelector);
  const [selector, setSelector] = useState(undefined);

  useEffect(() => {
    const selector = setupWalletSelector({
      network: networkId,
      modules: [setupMyNearWallet(), setupHereWallet()]
    });

    selector.then(walletSelector => walletSelector.store.observable
      .pipe(
        map((state) => state.accounts),
        distinctUntilChanged()
      )
      .subscribe((accounts) => {
        const signedAccountId = accounts.find((account) => account.active)?.accountId || '';
        setAuth({ signedAccountId });
      }));

    setSelector(selector);
    setStoreSelector({ selector });
  }, [networkId, setStoreSelector]);

  useEffect(() => {
    if (!selector) return;

    selector.then(walletSelector => {
      const accounts = walletSelector.store.getState().accounts;
      const signedAccountId = accounts.find((account) => account.active)?.accountId || '';
      setAuth({ signedAccountId });
    });
  }, [selector, setAuth]);

  useEffect(() => {
    if (!selector) return;

    // defined logOut and logIn actions
    const logOut = async () => {
      const wallet = await (await selector).wallet();
      await wallet.signOut();
      setAuth({ signedAccountId: '' });
    };

    const logIn = async () => {
      const modal = setupModal(await selector, { contractId: createAccessKeyFor });
      modal.show();
    };

    setLogActions({ logOut, logIn });
  }, [createAccessKeyFor, selector, setAuth, setLogActions]);

  useEffect(() => {
    if (!selector) return;

    const viewMethod = async (contractId, method, args = {}) => {
      const { network } = (await selector).options;
      const provider = new providers.JsonRpcProvider({ url: network.nodeUrl });

      let res = await provider.query({
        request_type: 'call_function',
        account_id: contractId,
        method_name: method,
        args_base64: Buffer.from(JSON.stringify(args)).toString('base64'),
        finality: 'optimistic',
      });
      return JSON.parse(Buffer.from(res.result).toString());
    };

    const callMethod = async (contractId, method, args = {}, gas = '30000000000000', deposit = 0) => {
      const wallet = await (await selector).wallet();

      const outcome = await wallet.signAndSendTransaction({
        receiverId: contractId,
        actions: [
          {
            type: 'FunctionCall',
            params: {
              methodName: method,
              args,
              gas,
              deposit,
            },
          },
        ],
      });

      return providers.getTransactionLastResult(outcome);
    };

    setMethods({ viewMethod, callMethod });

  }, [selector, setMethods]);
}
'''
'''--- website/src/utils/changelogs.json ---
[
  "2023-01-31.md",
  "2023-02-28.md",
  "2023-03-31.md",
  "2023-04-30.md",
  "2023-05-31.md",
  "2023-06-30.md",
  "2023-07-31.md",
  "2023-08-31.md",
  "2023-09-30.md",
  "2023-10-31.md",
  "2023-11-30.md",
  "2023-12-31.md",
  "2024-01-31.md",
  "2024-02-29.md"
]
'''
'''--- website/src/utils/getChangelogs.js ---
const fs = require('fs').promises;
const axios = require('axios');

async function main() {
  try {
    const response = await axios.get(
      'https://api.github.com/repos/near/near-releases/contents/reports'
    );
    const files = response.data.map((file) => file.name);

    await fs.writeFile('./src/utils/changelogs.json', JSON.stringify(files, null, 2));
    console.log('File successfully written: changelogs.json');
  } catch (error) {
    console.error(error);
  }
}

main();

'''
'''--- website/static/css/fonts.css ---
/**
 * @license
 * MyFonts Webfont Build ID 3709255, 2019-01-31T16:49:02-0500
 * 
 * The fonts listed in this notice are subject to the End User License
 * Agreement(s) entered into by the website owner. All other parties are 
 * explicitly restricted from using the Licensed Webfonts(s).
 * 
 * You may obtain a valid license at the URLs below.
 * 
 * Webfont: BwSeidoRound-Thin by Branding with Type
 * URL: https://www.myfonts.com/fonts/branding-with-type/bw-seido-round/thin/
 * 
 * Webfont: BwSeidoRound-BlackItalic by Branding with Type
 * URL: https://www.myfonts.com/fonts/branding-with-type/bw-seido-round/black-italic/
 * 
 * Webfont: BwSeidoRound-Light by Branding with Type
 * URL: https://www.myfonts.com/fonts/branding-with-type/bw-seido-round/light/
 * 
 * Webfont: BwSeidoRound-Bold by Branding with Type
 * URL: https://www.myfonts.com/fonts/branding-with-type/bw-seido-round/bold/
 * 
 * Webfont: BwSeidoRound-LightItalic by Branding with Type
 * URL: https://www.myfonts.com/fonts/branding-with-type/bw-seido-round/light-italic/
 * 
 * Webfont: BwSeidoRound-Black by Branding with Type
 * URL: https://www.myfonts.com/fonts/branding-with-type/bw-seido-round/black/
 * 
 * Webfont: BwSeidoRound-Medium by Branding with Type
 * URL: https://www.myfonts.com/fonts/branding-with-type/bw-seido-round/medium/
 * 
 * Webfont: BwSeidoRound-Regular by Branding with Type
 * URL: https://www.myfonts.com/fonts/branding-with-type/bw-seido-round/regular/
 * 
 * Webfont: BwSeidoRound-ThinItalic by Branding with Type
 * URL: https://www.myfonts.com/fonts/branding-with-type/bw-seido-round/thin-italic/
 * 
 * Webfont: BwSeidoRound-BoldItalic by Branding with Type
 * URL: https://www.myfonts.com/fonts/branding-with-type/bw-seido-round/bold-italic/
 * 
 * Webfont: BwSeidoRound-RegularItalic by Branding with Type
 * URL: https://www.myfonts.com/fonts/branding-with-type/bw-seido-round/italic/
 * 
 * Webfont: BwSeidoRound-MediumItalic by Branding with Type
 * URL: https://www.myfonts.com/fonts/branding-with-type/bw-seido-round/medium-italic/
 * 
 * 
 * License: https://www.myfonts.com/viewlicense?type=web&buildid=3709255
 * Licensed pageviews: 20,000
 * Webfonts copyright: Copyright &#x00A9; 2018 by Alberto Romanos. All rights reserved.
 * 
 * ¬© 2019 MyFonts Inc
*/

/* @import must be at top of file, otherwise CSS will not work */
@import url("//hello.myfonts.net/count/389947");

  
@font-face {font-family: 'BwSeidoRound-Thin';src: url('webfonts/389947_0_0.eot');src: url('webfonts/389947_0_0.eot?#iefix') format('embedded-opentype'),url('webfonts/389947_0_0.woff2') format('woff2'),url('webfonts/389947_0_0.woff') format('woff'),url('webfonts/389947_0_0.ttf') format('truetype');}
 
  
@font-face {font-family: 'BwSeidoRound-BlackItalic';src: url('webfonts/389947_1_0.eot');src: url('webfonts/389947_1_0.eot?#iefix') format('embedded-opentype'),url('webfonts/389947_1_0.woff2') format('woff2'),url('webfonts/389947_1_0.woff') format('woff'),url('webfonts/389947_1_0.ttf') format('truetype');}
 
  
@font-face {font-family: 'BwSeidoRound-Light';src: url('webfonts/389947_2_0.eot');src: url('webfonts/389947_2_0.eot?#iefix') format('embedded-opentype'),url('webfonts/389947_2_0.woff2') format('woff2'),url('webfonts/389947_2_0.woff') format('woff'),url('webfonts/389947_2_0.ttf') format('truetype');}
 
  
@font-face {font-family: 'BwSeidoRound-Bold';src: url('webfonts/389947_3_0.eot');src: url('webfonts/389947_3_0.eot?#iefix') format('embedded-opentype'),url('webfonts/389947_3_0.woff2') format('woff2'),url('webfonts/389947_3_0.woff') format('woff'),url('webfonts/389947_3_0.ttf') format('truetype');}
 
  
@font-face {font-family: 'BwSeidoRound-LightItalic';src: url('webfonts/389947_4_0.eot');src: url('webfonts/389947_4_0.eot?#iefix') format('embedded-opentype'),url('webfonts/389947_4_0.woff2') format('woff2'),url('webfonts/389947_4_0.woff') format('woff'),url('webfonts/389947_4_0.ttf') format('truetype');}
 
  
@font-face {font-family: 'BwSeidoRound-Black';src: url('webfonts/389947_5_0.eot');src: url('webfonts/389947_5_0.eot?#iefix') format('embedded-opentype'),url('webfonts/389947_5_0.woff2') format('woff2'),url('webfonts/389947_5_0.woff') format('woff'),url('webfonts/389947_5_0.ttf') format('truetype');}
 
  
@font-face {font-family: 'BwSeidoRound-Medium';src: url('webfonts/389947_6_0.eot');src: url('webfonts/389947_6_0.eot?#iefix') format('embedded-opentype'),url('webfonts/389947_6_0.woff2') format('woff2'),url('webfonts/389947_6_0.woff') format('woff'),url('webfonts/389947_6_0.ttf') format('truetype');}
 
  
@font-face {font-family: 'BwSeidoRound-Regular';src: url('webfonts/389947_7_0.eot');src: url('webfonts/389947_7_0.eot?#iefix') format('embedded-opentype'),url('webfonts/389947_7_0.woff2') format('woff2'),url('webfonts/389947_7_0.woff') format('woff'),url('webfonts/389947_7_0.ttf') format('truetype');}
 
  
@font-face {font-family: 'BwSeidoRound-ThinItalic';src: url('webfonts/389947_8_0.eot');src: url('webfonts/389947_8_0.eot?#iefix') format('embedded-opentype'),url('webfonts/389947_8_0.woff2') format('woff2'),url('webfonts/389947_8_0.woff') format('woff'),url('webfonts/389947_8_0.ttf') format('truetype');}
 
  
@font-face {font-family: 'BwSeidoRound-BoldItalic';src: url('webfonts/389947_9_0.eot');src: url('webfonts/389947_9_0.eot?#iefix') format('embedded-opentype'),url('webfonts/389947_9_0.woff2') format('woff2'),url('webfonts/389947_9_0.woff') format('woff'),url('webfonts/389947_9_0.ttf') format('truetype');}
 
  
@font-face {font-family: 'BwSeidoRound-RegularItalic';src: url('webfonts/389947_A_0.eot');src: url('webfonts/389947_A_0.eot?#iefix') format('embedded-opentype'),url('webfonts/389947_A_0.woff2') format('woff2'),url('webfonts/389947_A_0.woff') format('woff'),url('webfonts/389947_A_0.ttf') format('truetype');}
 
  
@font-face {font-family: 'BwSeidoRound-MediumItalic';src: url('webfonts/389947_B_0.eot');src: url('webfonts/389947_B_0.eot?#iefix') format('embedded-opentype'),url('webfonts/389947_B_0.woff2') format('woff2'),url('webfonts/389947_B_0.woff') format('woff'),url('webfonts/389947_B_0.ttf') format('truetype');}
 
'''
'''--- website/static/img/Icons/icon-arrow-left.svg ---
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11 20"><defs><style>.cls-1{fill:none;stroke:#ccc;stroke-linecap:round;stroke-linejoin:round;stroke-width:2px;}</style></defs><title>icon-arrow-left</title><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><polyline class="cls-1" points="10 19 1 10 10 1"/></g></g></svg>
'''
'''--- website/static/img/Icons/icon-arrow-up.svg ---
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 11"><defs><style>.cls-1{fill:none;stroke:#ccc;stroke-linecap:round;stroke-linejoin:round;stroke-width:2px;}</style></defs><title>icon-arrow-up</title><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><polyline class="cls-1" points="19 10 10 1 1 10"/></g></g></svg>
'''
'''--- website/static/img/Icons/telegram.svg ---
<path d="m32.65185 25.27345c-.08 1.755-.3735 2.708-.6195 3.3425-.327.84-.717 1.4395-1.347 2.0695-.6295.63-1.2295 1.02-2.0695 1.347-.6345.246-1.5875.5395-3.3425.6195-1.8975.0865-2.4665.105-7.2735.105-4.8065 0-5.376-.0185-7.2735-.105-1.7545-.08-2.708-.3735-3.342-.6195-.8405-.327-1.44-.717-2.07-1.347s-1.02-1.2295-1.3465-2.0695c-.246-.6345-.5395-1.5875-.6195-3.3425-.0865-1.898-.105-2.4675-.105-7.2735s.0185-5.3755.105-7.2735c.08-1.755.3735-2.708.6195-3.342.3265-.8405.7165-1.44 1.3465-2.07s1.2295-1.02 2.07-1.3465c.634-.2465 1.5875-.5395 3.342-.62 1.898-.086 2.4675-.105 7.2735-.105 4.8065 0 5.3755.019 7.2735.105 1.755.0805 2.708.3735 3.3425.62.84.3265 1.44.7165 2.0695 1.3465.63.63 1.02 1.2295 1.347 2.07.246.634.5395 1.587.6195 3.342.0865 1.898.105 2.4675.105 7.2735s-.0185 5.3755-.105 7.2735m3.2395-14.695c-.087-1.916-.3915-3.224-.836-4.369-.46-1.184-1.076-2.1875-2.0765-3.1885-1.001-1.0005-2.004-1.616-3.1885-2.076-1.145-.445-2.453-.749-4.369-.8365-1.92-.088-2.5325-.1085-7.4215-.1085-4.8885 0-5.5015.0205-7.421.1085-1.9165.0875-3.2245.3915-4.3695.8365-1.184.46-2.1875 1.0755-3.1885 2.076-1.0005 1.001-1.616 2.0045-2.076 3.1885-.445 1.145-.749 2.453-.8365 4.369-.088 1.92-.1085 2.533-.1085 7.4215s.0205 5.5015.1085 7.4215c.0875 1.916.3915 3.224.8365 4.369.46 1.1835 1.0755 2.1875 2.076 3.1885 1.001 1.0005 2.0045 1.6165 3.1885 2.076 1.145.445 2.453.7495 4.3695.8365 1.9195.088 2.5325.1085 7.421.1085 4.889 0 5.5015-.0205 7.4215-.1085 1.916-.087 3.224-.3915 4.369-.8365 1.1845-.4595 2.1875-1.0755 3.1885-2.076 1.0005-1.001 1.6165-2.005 2.0765-3.1885.4445-1.145.749-2.453.836-4.369.088-1.92.1085-2.533.1085-7.4215s-.0205-5.5015-.1085-7.4215"></path>
'''
'''--- website/static/img/near_logo.svg ---
<?xml version="1.0" encoding="UTF-8"?>
<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1656 567">
  <g>
    <path d="m703.42,157.72c-26.61,0-45.96,6.29-62.4,20.8l-29.03,25.15c-2.42,1.94-7.26,3.39-10.64.48-3.39-2.9-3.87-6.77-.97-10.64l15.48-23.22c2.42-3.39.49-7.74-3.87-7.74h-37.25c-4.35,0-7.74,3.39-7.74,7.74v226.4c0,4.35,3.39,7.74,7.74,7.74h38.7c4.35,0,7.74-3.39,7.74-7.74v-127.71c0-58.53,48.86-67.72,67.24-67.72,39.18,0,53.21,28.06,53.21,49.34v146.09c0,4.35,3.39,7.74,7.74,7.74h38.7c4.35,0,7.74-3.39,7.74-7.74v-150.93c0-54.18-35.32-88.04-92.4-88.04Z"/>
    <path d="m953.5,156.75c-74.98,0-122.87,45.96-122.87,108.36v34.35c0,65.79,47.89,110.78,122.87,110.78,66.27,0,112.71-34.35,117.55-80.79.49-4.84-2.9-8.22-7.74-8.22h-37.73c-3.39,0-6.29,1.94-7.26,5.32-4.84,15.48-27.57,38.7-64.82,38.7s-72.08-27.09-71.6-65.79l.49-43.05c.48-32.41,34.35-54.66,71.11-54.66,33.38,0,65.79,18.87,69.17,49.83h0c.28,3.58-2.18,6.81-5.71,7.49l-108.46,21.05c-4.35.97-7.74,4.84-7.74,9.67v.48c0,4.35,4.35,8.22,10.64,8.22h155.77c4.28,0,7.74-3.47,7.74-7.74v-30.47c0-57.56-49.83-103.52-121.42-103.52Z"/>
    <path d="m1223.42,156.75c-60.47,0-112.71,35.31-112.71,81.75,0,3.87,3.39,6.77,7.74,6.77h39.18c3.87,0,6.77-2.9,7.26-6.77,3.87-21.28,29.51-36.76,57.08-36.76,32.89,0,55.15,20.32,55.15,55.15v42.09c0,43.05-31.93,64.82-71.6,64.82-30.96,0-48.86-11.61-48.86-30.48,0-16.45,8.71-30.48,44.5-38.7l51.76-14.03c5.32-1.45,7.26-5.81,6.29-10.64-.48-3.87-4.83-5.81-8.71-5.81h-53.69c-45.47,0-91.43,29.02-91.43,71.59v6.77c0,43.54,41.12,66.27,88.04,66.27,29.99,0,55.63-11.61,71.59-25.15l23.71-20.32c3.87-3.39,7.74-3.39,11.12,0,2.9,2.9,1.93,7.26-.49,10.64l-14.51,22.74c-2.42,3.39-.49,7.74,3.87,7.74h34.83c4.35,0,7.74-3.39,7.74-7.74v-146.58c0-56.11-40.15-93.36-107.88-93.36Z"/>
    <path d="m1540.26,162.56h-54.18c-18.86,0-37.25,11.61-50.31,22.74l-21.28,18.38c-2.42,1.94-6.78,3.39-9.68.97-3.39-2.42-4.84-7.26-1.93-11.13l15.48-23.22c2.42-3.39.49-7.74-3.87-7.74h-36.28c-4.35,0-7.74,3.39-7.74,7.74v226.4c0,4.35,3.39,7.74,7.74,7.74h39.67c4.35,0,7.74-3.39,7.74-7.74v-116.1c0-49.83,20.32-72.08,64.34-72.08h50.31c4.35,0,7.74-3.39,7.74-7.74v-30.48c0-4.35-3.39-7.74-7.74-7.74Z"/>
  </g>
  <path d="m421.61,108c-13,0-25.07,6.74-31.88,17.82l-73.37,108.93c-2.39,3.59-1.42,8.43,2.17,10.82,2.91,1.94,6.76,1.7,9.41-.58l72.22-62.64c1.2-1.08,3.05-.97,4.13.23.49.55.75,1.26.75,1.99v196.12c0,1.62-1.31,2.92-2.93,2.92-.87,0-1.69-.38-2.24-1.05L181.56,121.24c-7.11-8.39-17.55-13.23-28.54-13.24h-7.63c-20.65,0-37.39,16.74-37.39,37.39v276.22c0,20.65,16.74,37.39,37.39,37.39,13,0,25.07-6.74,31.88-17.82l73.37-108.93c2.39-3.59,1.42-8.43-2.17-10.82-2.91-1.94-6.76-1.7-9.41.58l-72.22,62.64c-1.2,1.08-3.05.97-4.13-.23-.49-.55-.75-1.26-.74-1.99v-196.17c0-1.62,1.31-2.92,2.93-2.92.86,0,1.69.38,2.24,1.05l218.28,261.37c7.11,8.39,17.55,13.23,28.54,13.24h7.63c20.65.01,37.4-16.72,37.42-37.37V145.39c0-20.65-16.74-37.39-37.39-37.39Z"/>
</svg>
'''
'''--- website/static/img/near_logo_white.svg ---
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   id="Layer_1"
   data-name="Layer 1"
   viewBox="0 0 1656 567"
   version="1.1"
   sodipodi:docname="near_logo.svg"
   inkscape:version="1.2.1 (9c6d41e, 2022-07-14)"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <defs
     id="defs197" />
  <sodipodi:namedview
     id="namedview195"
     pagecolor="#ffffff"
     bordercolor="#000000"
     borderopacity="0.25"
     inkscape:showpageshadow="2"
     inkscape:pageopacity="0.0"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1"
     showgrid="false"
     inkscape:zoom="0.41622575"
     inkscape:cx="508.13771"
     inkscape:cy="283.5"
     inkscape:window-width="1403"
     inkscape:window-height="430"
     inkscape:window-x="0"
     inkscape:window-y="25"
     inkscape:window-maximized="0"
     inkscape:current-layer="Layer_1" />
  <g
     id="g190"
     style="fill:#ffffff">
    <path
       d="m703.42,157.72c-26.61,0-45.96,6.29-62.4,20.8l-29.03,25.15c-2.42,1.94-7.26,3.39-10.64.48-3.39-2.9-3.87-6.77-.97-10.64l15.48-23.22c2.42-3.39.49-7.74-3.87-7.74h-37.25c-4.35,0-7.74,3.39-7.74,7.74v226.4c0,4.35,3.39,7.74,7.74,7.74h38.7c4.35,0,7.74-3.39,7.74-7.74v-127.71c0-58.53,48.86-67.72,67.24-67.72,39.18,0,53.21,28.06,53.21,49.34v146.09c0,4.35,3.39,7.74,7.74,7.74h38.7c4.35,0,7.74-3.39,7.74-7.74v-150.93c0-54.18-35.32-88.04-92.4-88.04Z"
       id="path182"
       style="fill:#ffffff" />
    <path
       d="m953.5,156.75c-74.98,0-122.87,45.96-122.87,108.36v34.35c0,65.79,47.89,110.78,122.87,110.78,66.27,0,112.71-34.35,117.55-80.79.49-4.84-2.9-8.22-7.74-8.22h-37.73c-3.39,0-6.29,1.94-7.26,5.32-4.84,15.48-27.57,38.7-64.82,38.7s-72.08-27.09-71.6-65.79l.49-43.05c.48-32.41,34.35-54.66,71.11-54.66,33.38,0,65.79,18.87,69.17,49.83h0c.28,3.58-2.18,6.81-5.71,7.49l-108.46,21.05c-4.35.97-7.74,4.84-7.74,9.67v.48c0,4.35,4.35,8.22,10.64,8.22h155.77c4.28,0,7.74-3.47,7.74-7.74v-30.47c0-57.56-49.83-103.52-121.42-103.52Z"
       id="path184"
       style="fill:#ffffff" />
    <path
       d="m1223.42,156.75c-60.47,0-112.71,35.31-112.71,81.75,0,3.87,3.39,6.77,7.74,6.77h39.18c3.87,0,6.77-2.9,7.26-6.77,3.87-21.28,29.51-36.76,57.08-36.76,32.89,0,55.15,20.32,55.15,55.15v42.09c0,43.05-31.93,64.82-71.6,64.82-30.96,0-48.86-11.61-48.86-30.48,0-16.45,8.71-30.48,44.5-38.7l51.76-14.03c5.32-1.45,7.26-5.81,6.29-10.64-.48-3.87-4.83-5.81-8.71-5.81h-53.69c-45.47,0-91.43,29.02-91.43,71.59v6.77c0,43.54,41.12,66.27,88.04,66.27,29.99,0,55.63-11.61,71.59-25.15l23.71-20.32c3.87-3.39,7.74-3.39,11.12,0,2.9,2.9,1.93,7.26-.49,10.64l-14.51,22.74c-2.42,3.39-.49,7.74,3.87,7.74h34.83c4.35,0,7.74-3.39,7.74-7.74v-146.58c0-56.11-40.15-93.36-107.88-93.36Z"
       id="path186"
       style="fill:#ffffff" />
    <path
       d="m1540.26,162.56h-54.18c-18.86,0-37.25,11.61-50.31,22.74l-21.28,18.38c-2.42,1.94-6.78,3.39-9.68.97-3.39-2.42-4.84-7.26-1.93-11.13l15.48-23.22c2.42-3.39.49-7.74-3.87-7.74h-36.28c-4.35,0-7.74,3.39-7.74,7.74v226.4c0,4.35,3.39,7.74,7.74,7.74h39.67c4.35,0,7.74-3.39,7.74-7.74v-116.1c0-49.83,20.32-72.08,64.34-72.08h50.31c4.35,0,7.74-3.39,7.74-7.74v-30.48c0-4.35-3.39-7.74-7.74-7.74Z"
       id="path188"
       style="fill:#ffffff" />
  </g>
  <path
     d="m421.61,108c-13,0-25.07,6.74-31.88,17.82l-73.37,108.93c-2.39,3.59-1.42,8.43,2.17,10.82,2.91,1.94,6.76,1.7,9.41-.58l72.22-62.64c1.2-1.08,3.05-.97,4.13.23.49.55.75,1.26.75,1.99v196.12c0,1.62-1.31,2.92-2.93,2.92-.87,0-1.69-.38-2.24-1.05L181.56,121.24c-7.11-8.39-17.55-13.23-28.54-13.24h-7.63c-20.65,0-37.39,16.74-37.39,37.39v276.22c0,20.65,16.74,37.39,37.39,37.39,13,0,25.07-6.74,31.88-17.82l73.37-108.93c2.39-3.59,1.42-8.43-2.17-10.82-2.91-1.94-6.76-1.7-9.41.58l-72.22,62.64c-1.2,1.08-3.05.97-4.13-.23-.49-.55-.75-1.26-.74-1.99v-196.17c0-1.62,1.31-2.92,2.93-2.92.86,0,1.69.38,2.24,1.05l218.28,261.37c7.11,8.39,17.55,13.23,28.54,13.24h7.63c20.65.01,37.4-16.72,37.42-37.37V145.39c0-20.65-16.74-37.39-37.39-37.39Z"
     id="path192"
     style="fill:#ffffff" />
</svg>

'''
'''--- website/static/img/wallet.svg ---
<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 468 180.5"><defs><style>.cls-1{opacity:0.1;}.cls-2{fill:url(#linear-gradient);}.cls-3,.cls-4{fill:#fff;}.cls-4{font-size:72px;font-family:Helvetica, Helvetica;font-weight:500;}.cls-5{letter-spacing:-0.03em;}.cls-6{letter-spacing:-0.01em;}.cls-7{letter-spacing:0em;}.cls-8{fill:url(#linear-gradient-2);}</style><linearGradient id="linear-gradient" x1="40.09" y1="-2226.37" x2="140.87" y2="-2125.6" gradientTransform="matrix(1, 0, 0, -1, 0, -2086)" gradientUnits="userSpaceOnUse"><stop offset="0.21" stop-color="#fff"/><stop offset="0.42" stop-color="#fff" stop-opacity="0"/><stop offset="0.59" stop-color="#fff" stop-opacity="0"/><stop offset="0.81" stop-color="#fff"/></linearGradient><linearGradient id="linear-gradient-2" x1="40.11" y1="140.37" x2="140.87" y2="39.61" gradientUnits="userSpaceOnUse"><stop offset="0.21" stop-color="#fff"/><stop offset="0.42" stop-color="#fff" stop-opacity="0"/><stop offset="0.59" stop-color="#fff" stop-opacity="0"/><stop offset="0.81" stop-color="#fff"/></linearGradient></defs><title>wallet</title><g class="cls-1"><path class="cls-2" d="M48.84,144a12.33,12.33,0,0,0,9.35-4.29h0l84.42-97.92A12.31,12.31,0,0,0,132.11,36h0a12.38,12.38,0,0,0-9.32,4.23L38,137.59A12.36,12.36,0,0,0,48.84,144Z"/><path class="cls-3" d="M48.84,144a12.26,12.26,0,0,0,5.66-1.38V60.86l65.58,78.64a12.33,12.33,0,0,0,9.42,4.5h2.59a12.34,12.34,0,0,0,12.41-12.25V48.35A12.34,12.34,0,0,0,132.18,36h0a12.47,12.47,0,0,0-5.65,1.35v81.79L60.92,40.5A12.33,12.33,0,0,0,51.5,36H48.84A12.34,12.34,0,0,0,36.5,48.32v83.33A12.34,12.34,0,0,0,48.81,144Z"/><path class="cls-3" d="M417,36H153.46A18.88,18.88,0,0,1,158,48.35v83.31A19.06,19.06,0,0,1,153.47,144H417a15,15,0,0,0,15-15V51A15,15,0,0,0,417,36Z"/></g><text class="cls-4" transform="translate(182 117)"><tspan class="cls-5">W</tspan><tspan x="71.06" y="0">all</tspan><tspan class="cls-6" x="149.18" y="0">e</tspan><tspan class="cls-7" x="190.22" y="0">t</tspan></text><path class="cls-8" d="M48.84,144a12.32,12.32,0,0,0,9.35-4.28h0l84.42-97.93A12.32,12.32,0,0,0,132.16,36h0a12.31,12.31,0,0,0-9.31,4.24L38,137.59A12.34,12.34,0,0,0,48.84,144Z"/><path class="cls-3" d="M48.84,144a12.38,12.38,0,0,0,5.66-1.37V60.86l65.58,78.7a12.37,12.37,0,0,0,9.49,4.44h2.59a12.35,12.35,0,0,0,12.34-12.34V48.34A12.35,12.35,0,0,0,132.16,36h0a12.45,12.45,0,0,0-5.62,1.35v81.79L60.92,40.44A12.37,12.37,0,0,0,51.43,36H48.84A12.35,12.35,0,0,0,36.5,48.34v83.32A12.35,12.35,0,0,0,48.84,144Z"/></svg>
'''
'''--- website/test-links.sh ---
#!/bin/bash
set -e

find_available_port() {
    local port=3000
    while true; do
        if ! nc -z localhost $port &>/dev/null; then
            echo $port
            break
        fi
        port=$((port+1))
    done
}

start_server() {
    echo " üèóÔ∏è - Building docs site... "
    export IS_PULL_REQUEST=true
    npm run build:preview
    echo " ‚úÖ - Docs site built.  "

    local port=$(find_available_port)
    echo " üëâ Starting server on port $port..."
    npx serve build/ -l $port &
    echo $! > server.pid
    echo $port > server.port
    echo "üöÄ - Server started with PID $(cat server.pid) on port $(cat server.port)"
}

wait_for_server() {
    if [ -f server.port ]; then
        local port=$(cat server.port)
        npx wait-on http://localhost:$port
    else
        echo "‚õîÔ∏è - Server port file not found!"
        exit 1
    fi
}

stop_server() {
    if [ -f server.pid ]; then
        SERVER_PID=$(cat server.pid)
        if ps -p $SERVER_PID > /dev/null; then
           kill $SERVER_PID && echo "Server stopped."
        else
           echo "‚õîÔ∏è - Server process $SERVER_PID not found. It probably stopped already. :)"
        fi
        rm server.pid server.port
    else
        echo ‚õîÔ∏è - "No server to stop. PID file not found."
    fi
}

check_links() {
    use_trap=${1:-false}

    if [ ! -f server.port ]; then
        echo "‚õîÔ∏è - Server is not running. Please start the server first."
        exit 1
    fi
    local port=$(cat server.port)
    local base_url="http://localhost:$port"
    echo "Checking for broken links on $base_url..."

    if [ "$use_trap" = true ]; then
        # Setup trap to catch any error and stop the server
        trap 'echo "Error encountered. Stopping server..."; stop_server; exit 1' ERR
    fi

    npx linkinator $base_url --config linkinator.config.json

    if [ "$use_trap" = true ]; then
        # Disable the trap after successful completion
        trap - ERR
    fi
}

test() {
    start_server
    wait_for_server
    check_links true
}

# Command line argument handling
case "$1" in
    start)
        start_server
        ;;
    stop)
        stop_server
        ;;
    check)
        check_links
        ;;
    test)
        test
        ;;
    *)
        echo "Usage: $0 {start|stop|check|start-check}"
        exit 1
        ;;
esac

'''
'''--- website/tsconfig.json ---
{
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "jsx": "react",
    "module": "es2015",
    "moduleResolution": "node",
    "noFallthroughCasesInSwitch": true,
    "noImplicitAny": false,
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "strict": true,
    "target": "ESNEXT"
  }
}

'''