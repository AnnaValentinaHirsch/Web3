*GitHub Repository "khanhhuy-bkdn/payment-shop-rust"*

'''--- Cargo.toml ---
[package]
name = "payment-shop-rust"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[dev-dependencies]
near-sdk-sim = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p out
cp target/wasm32-unknown-unknown/release/*.wasm out/payment-shop-contract.wasm

'''
'''--- neardev/dev-account.env ---
CONTRACT_NAME=dev-1653972119007-22019094531161
'''
'''--- src/enumeration.rs ---
use crate::*;

#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PaymentShopJson {
    pub pay_id: U128,
    pub payment_fee_percent: U128,
    pub total_payment: U128
}

#[near_bindgen]
impl PaymentShop {
    pub fn get_payment_info(&self, pay_id: U128) -> PaymentJson {
        let upgradable_payment = self.payments.get(&pay_id.0);
        let payment;
        match upgradable_payment {
            Some(item) => payment = Payment::from(item),
            None => payment = Payment::default()
        };
        PaymentJson::from(pay_id.0.clone(), payment)
    }

    pub fn get_payment_shop_info(&self) -> PaymentShopJson {

        PaymentShopJson {
            pay_id: U128(self.pay_id),
            payment_fee_percent: U128(self.payment_fee_percent),
            total_payment: U128(self.total_payment)
        }
    }

    pub fn get_payid_from_orderid(&self, order_id: U128) -> U128 {
        match self.order_ids.get(&order_id.0) {
            Some(value) => {
                U128(value)
            },
            None => U128(0)
        }
    }
}
'''
'''--- src/lib.rs ---
use near_sdk::json_types::U128;
use near_sdk::{env, AccountId, Balance, near_bindgen, PanicOnDefault, BorshStorageKey, Promise};
use near_sdk::collections::{LookupMap, UnorderedMap};
use near_sdk::borsh::{self, BorshSerialize, BorshDeserialize};
use near_sdk::serde::{Deserialize, Serialize};

use crate::util::*;
use crate::payment::*;
pub use crate::enumeration::*;
pub use crate::payment::PaymentJson;
pub use crate::payment::Status;

mod util;
mod payment;
mod enumeration;

const DECIMALS: u32 = 100000;

#[derive(BorshDeserialize, BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    PayIdKey
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct PaymentShop {
    pub owner_id: AccountId,
    pub pay_id: u128,
    pub payment_fee_percent: u128,
    pub total_payment: u128,
    pub total_payment_withdraw: u128,
    pub payments: LookupMap<u128, UpgradePayment>,
    pub order_ids: UnorderedMap<u128, u128>
}

#[near_bindgen]
impl PaymentShop {
    #[init]
    pub fn new(owner_id: AccountId, payment_fee_percent: U128) -> Self {
        PaymentShop {
            owner_id,
            pay_id: 0,
            payment_fee_percent: payment_fee_percent.0,
            total_payment: 0,
            total_payment_withdraw: 0,
            payments: LookupMap::new(StorageKey::PayIdKey),
            order_ids: UnorderedMap::new(b"m")
        }
    }

    #[payable]
    pub fn req_payment(&mut self, order_id: U128, user_id: AccountId, msg: String, fee: U128) {
        let pay_id_for_order = self.order_ids.get(&order_id.0);
        assert!(pay_id_for_order.is_none(), "Order ID is set");
        assert_at_least_one_yocto();
        let shop_id = env::predecessor_account_id();
        let pay_id = self.pay_id + 1;
     
        let storage_use_before = env::storage_usage();
        let payment = Payment {
            payment_id: pay_id,
            order_id: order_id.0,
            shop: shop_id,
            user: user_id,
            msg: msg,
            fee: fee.0,
            status: Status::REQUESTING
        }; 

        let log_message = format!("Request payment: payment_id: {}, order_id: {}, account: {}, fee: {}, data: {}", &pay_id, &order_id.0, payment.user, payment.fee, payment.msg);
        self.payments.insert(&pay_id, &UpgradePayment::from(payment));
        self.order_ids.insert(&order_id.0, &pay_id);

        let storage_use_after = env::storage_usage();
        refund_deposit(storage_use_after - storage_use_before);
        self.pay_id = pay_id;
        env::log(log_message.as_bytes());
    }

    #[payable]
    pub fn pay(&mut self, pay_id: U128) {
        assert_at_least_one_yocto();

        let fee = env::attached_deposit();
        let account_id = env::predecessor_account_id();

        let upgrade_payment = self.payments.get(&pay_id.0);
        assert!(upgrade_payment.is_some(), "ERR_PAYMENT_NOT_FOUND");

        let mut payment = Payment::from(upgrade_payment.unwrap());

        assert!(payment.status == Status::REQUESTING, "Invalid status");
        assert!(fee >= payment.fee, "Required FEE deposit of at least {} yoctoNEAR", payment.fee);
        assert_eq!(account_id, payment.user, "Access deny");

        payment.status = Status::PAID;
        self.payments.insert(&self.pay_id, &UpgradePayment::from(payment));

        let log_message = format!("Pay: payment_id: {}", self.pay_id);
        env::log(log_message.as_bytes());
    }

    #[payable]
    pub fn confirm(&mut self, pay_id: U128) { 
        assert_one_yocto();
        let account_id = env::predecessor_account_id();

        let upgrade_payment = self.payments.get(&pay_id.0);
        assert!(upgrade_payment.is_some(), "ERR_PAYMENT_NOT_FOUND");

        let mut payment = Payment::from(upgrade_payment.unwrap());
        assert!(payment.status == Status::PAID, "Invalid status");

        assert!(account_id == payment.user || account_id == self.owner_id, "Access deny");

        payment.status = Status::CONFIRMED;
        self.payments.insert(&self.pay_id, &UpgradePayment::from(payment));

        let log_message = format!("Confirm: payment_id: {}", self.pay_id);
        env::log(log_message.as_bytes());
    }

    #[payable]
    pub fn claim(&mut self, pay_id: U128) {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        
        let upgrade_payment = self.payments.get(&pay_id.0);
        assert!(upgrade_payment.is_some(), "ERR_PAYMENT_NOT_FOUND");

        let mut payment = Payment::from(upgrade_payment.unwrap());
        assert!(payment.status == Status::CONFIRMED, "Invalid status");

        assert_eq!(account_id, payment.shop, "Access deny");

        let payment_fee_amount = payment.fee * self.payment_fee_percent / (DECIMALS as u128);
        let payment_recever = payment.fee - payment_fee_amount;

        payment.status = Status::CLAIMED;
        let shop_id = payment.shop.clone();
        self.payments.insert(&self.pay_id, &UpgradePayment::from(payment));

        self.total_payment += payment_fee_amount;
        Promise::new(shop_id).transfer(payment_recever);

        let log_message = format!("Shop claim: payment_id: {}, amount {}", self.pay_id, payment_recever);
        env::log(log_message.as_bytes());
    }

    #[payable]
    pub fn withdraw(&mut self) {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        assert_eq!(account_id, self.owner_id, "Not admin or owner");
        assert!(self.total_payment > 0, "No amount to withdraw");

        let payment_withdraw = self.total_payment - self.total_payment_withdraw;
        self.total_payment_withdraw = self.total_payment;
        Promise::new(account_id).transfer(payment_withdraw);

        self.total_payment_withdraw = payment_withdraw.clone();

        let log_message = format!("Withdraw: amount {}", payment_withdraw);
        env::log(log_message.as_bytes());
    }

    #[payable]
    pub fn set_payment_fee(&mut self, payment_fee_percent: U128) {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        assert_eq!(account_id, self.owner_id, "Not admin or owner");
        assert!(payment_fee_percent.0 > 0, "Invalid payment fee");

        self.payment_fee_percent = payment_fee_percent.0;

        let log_message = format!("Set payment fee: {}", payment_fee_percent.0);
        env::log(log_message.as_bytes());
    }
}
'''
'''--- src/payment.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Payment {
    pub payment_id: u128,
    pub order_id: u128,
    pub shop: AccountId,
    pub user: AccountId,
    pub msg: String,
    pub fee: Balance,
    pub status: Status,
}

#[derive(BorshDeserialize, BorshSerialize, PartialEq, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum Status {
    REQUESTING,
    PAID,
    CONFIRMED,
    CLAIMED,
}

#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub enum UpgradePayment {
    Current(Payment),
}

impl Default for Payment {
    fn default() -> Self {
        Payment {
            payment_id: 0,
            order_id: 0,
            shop: "".to_string(),
            user: "".to_string(),
            msg: "".to_string(),
            fee: 0,
            status: Status::REQUESTING,
        }
    }
}

impl From<UpgradePayment> for Payment {
    fn from(upgradable_payment: UpgradePayment) -> Self {
        match upgradable_payment {
            UpgradePayment::Current(payment) => payment,
        }
    }
}

impl From<Payment> for UpgradePayment {
    fn from(payment: Payment) -> Self {
        UpgradePayment::Current(payment)
    }
}

#[derive(Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct PaymentJson {
    pub payment_id: U128,
    pub order_id: U128,
    pub shop: AccountId,
    pub user: AccountId,
    pub msg: String,
    pub fee: U128,
    pub status: Status,
}

impl PaymentJson {
    pub fn from(payment_id: u128, payment: Payment) -> Self {
        PaymentJson {
            payment_id: U128(payment_id),
            order_id: U128(payment.order_id),
            shop: payment.shop,
            user: payment.user,
            msg: payment.msg,
            fee: U128(payment.fee),
            status: payment.status,
        }
    }
}

'''
'''--- src/util.rs ---
use crate::*;

pub(crate) fn assert_at_least_one_yocto() {
    assert!(env::attached_deposit() >= 1, "Required attached deposit of at least 1 yoctoNEAR")
}

pub(crate) fn assert_one_yocto() {
    assert_eq!(env::attached_deposit(), 1, "Required attached deposit of exactly 1 yoctoNEAR")
}

pub(crate) fn refund_deposit(storage_used: u64) {
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();

    assert!(attached_deposit >= required_cost, "Must attach {} yoctoNear to cover storage", required_cost);

    let refund = attached_deposit - required_cost;

    if refund > 0 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}
'''
'''--- tests/sim/main.rs ---
use near_sdk::{serde_json::json, json_types::U128};
use near_sdk_sim::{init_simulator, UserAccount, DEFAULT_GAS, STORAGE_AMOUNT, to_yocto};
use payment_shop_rust::{PaymentJson, PaymentShopJson, Status};
use near_sdk_sim::transaction::{ExecutionStatus};

near_sdk_sim::lazy_static_include::lazy_static_include_bytes!{
    PAYMENT_SHOP_CONTRACT_WASM_FILE => "out/payment-shop-contract.wasm",
}

const PAYMENT_SHOP_CONTRACT_ID: &str = "payment_shop_contract";
const FEE_CONTRACT_PERCENT: &str = "20000"; // 20%
const BOD_FEE_AMOUNT: u128 = 10000000000000000000000000; // 10 NEAR

pub fn init() -> (UserAccount, UserAccount, UserAccount, UserAccount) {
    let root = init_simulator(None);
    let alice = root.create_user("alice".to_string(), to_yocto("100"));
    let bod = root.create_user("bod".to_string(), to_yocto("100"));

    // Deploy and init
    let payment_shop_contract = root.deploy_and_init(
        &PAYMENT_SHOP_CONTRACT_WASM_FILE,
        PAYMENT_SHOP_CONTRACT_ID.to_string(),
        "new", 
        &json!({
            "owner_id": alice.account_id(),
            "payment_fee_percent": FEE_CONTRACT_PERCENT
        }).to_string().as_bytes(), 
        STORAGE_AMOUNT,
        DEFAULT_GAS
    );

    (root, alice, bod, payment_shop_contract)
}

#[test]
pub fn test_req_payment() {
    let (root, alice, bod, payment_shop_contract) = init();

    alice.call(
        payment_shop_contract.account_id(), 
        "req_payment", 
        &json!({
            "order_id":U128(1),
            "user_id": bod.account_id(),
            "msg": "Hello",
            "fee": U128(BOD_FEE_AMOUNT)
        }).to_string().as_bytes(), 
        DEFAULT_GAS,
        to_yocto("0.01") 
    );

    let order_id: U128 = root.view(
        payment_shop_contract.account_id(), 
        "get_payid_from_orderid", 
        &json!({
            "order_id": U128(1)
        }).to_string().as_bytes()
    ).unwrap_json();

    assert_eq!(order_id, U128(1));

    let payment_json: PaymentJson = root.view(
        payment_shop_contract.account_id(), 
        "get_payment_info", 
        &json!({
            "pay_id": U128(1)
        }).to_string().as_bytes()
    ).unwrap_json();

    assert_eq!(payment_json.payment_id, U128(1));
    assert_eq!(payment_json.order_id, U128(1));
    assert_eq!(payment_json.shop, alice.account_id());
    assert_eq!(payment_json.user, bod.account_id());
    assert_eq!(payment_json.msg, "Hello");
    assert_eq!(payment_json.fee, U128(10000000000000000000000000));
    assert_eq!(payment_json.status, Status::REQUESTING);

    let outcome_req = alice.call(
        payment_shop_contract.account_id(), 
        "req_payment", 
        &json!({
            "order_id":U128(1),
            "user_id": bod.account_id(),
            "msg": "Hello",
            "fee": U128(BOD_FEE_AMOUNT)
        }).to_string().as_bytes(), 
        DEFAULT_GAS,
        to_yocto("0.01") 
    );

    // assert error type
    if let ExecutionStatus::Failure(error) = &outcome_req.promise_errors().remove(0).unwrap().outcome().status {
        println!("Excute error: {}", error.to_string());
        assert!(error.to_string().contains("Order ID is set"));
    } else {
        unreachable!()
    }
}

#[test]
pub fn test_pay() {
    let (root, alice, bod, payment_shop_contract) = init();

    alice.call(
        payment_shop_contract.account_id(), 
        "req_payment", 
        &json!({
            "order_id":U128(1),
            "user_id": bod.account_id(),
            "msg": "Hello",
            "fee": U128(BOD_FEE_AMOUNT)
        }).to_string().as_bytes(), 
        DEFAULT_GAS,
        to_yocto("0.01") 
    );

    bod.call(
        payment_shop_contract.account_id(), 
        "pay", 
        &json!({
            "pay_id": U128(1)
        }).to_string().as_bytes(), 
        DEFAULT_GAS,
        BOD_FEE_AMOUNT 
    );

    let payment_json: PaymentJson = root.view(
        payment_shop_contract.account_id(), 
        "get_payment_info", 
        &json!({
            "pay_id": U128(1)
        }).to_string().as_bytes()
    ).unwrap_json();

    assert_eq!(payment_json.payment_id, U128(1));
    assert_eq!(payment_json.shop, alice.account_id());
    assert_eq!(payment_json.user, bod.account_id());
    assert_eq!(payment_json.msg, "Hello");
    assert_eq!(payment_json.fee, U128(10000000000000000000000000));
    assert_eq!(payment_json.status, Status::PAID);
}

#[test]
pub fn test_confirm() {
    let (root, alice, bod, payment_shop_contract) = init();

    alice.call(
        payment_shop_contract.account_id(), 
        "req_payment", 
        &json!({
            "order_id":U128(1),
            "user_id": bod.account_id(),
            "msg": "Hello",
            "fee": U128(BOD_FEE_AMOUNT)
        }).to_string().as_bytes(), 
        DEFAULT_GAS,
        to_yocto("0.01") 
    );

    let mut outcome = alice.call(
        payment_shop_contract.account_id(), 
        "pay", 
        &json!({
            "pay_id": U128(1)
        }).to_string().as_bytes(), 
        DEFAULT_GAS,
        to_yocto("0.01")
    );

    assert_eq!(outcome.promise_errors().len(), 1);

    // assert error type
    if let ExecutionStatus::Failure(error) = &outcome.promise_errors().remove(0).unwrap().outcome().status {
        println!("Excute error: {}", error.to_string());
        assert!(error.to_string().contains("Required FEE deposit of at least 10000000000000000000000000 yoctoNEAR"));
    } else {
        unreachable!()
    }

    outcome = alice.call(
        payment_shop_contract.account_id(), 
        "pay", 
        &json!({
            "pay_id": U128(1)
        }).to_string().as_bytes(), 
        DEFAULT_GAS,
        BOD_FEE_AMOUNT
    );

    assert_eq!(outcome.promise_errors().len(), 1);

    // assert error type
    if let ExecutionStatus::Failure(error) = &outcome.promise_errors().remove(0).unwrap().outcome().status {
        println!("Excute error: {}", error.to_string());
        assert!(error.to_string().contains("Access deny"));
    } else {
        unreachable!()
    }

    bod.call(
        payment_shop_contract.account_id(), 
        "pay", 
        &json!({
            "pay_id": U128(1)
        }).to_string().as_bytes(), 
        DEFAULT_GAS,
        BOD_FEE_AMOUNT
    );

    bod.call(
        payment_shop_contract.account_id(), 
        "confirm", 
        &json!({
            "pay_id": U128(1)
        }).to_string().as_bytes(), 
        DEFAULT_GAS,
        1 
    );

    let payment_json: PaymentJson = root.view(
        payment_shop_contract.account_id(), 
        "get_payment_info", 
        &json!({
            "pay_id": U128(1)
        }).to_string().as_bytes()
    ).unwrap_json();

    assert_eq!(payment_json.payment_id, U128(1));
    assert_eq!(payment_json.shop, alice.account_id());
    assert_eq!(payment_json.user, bod.account_id());
    assert_eq!(payment_json.msg, "Hello");
    assert_eq!(payment_json.fee, U128(10000000000000000000000000));
    assert_eq!(payment_json.status, Status::CONFIRMED);
}

#[test]
pub fn test_claim() {
    let (root, alice, bod, payment_shop_contract) = init();

    alice.call(
        payment_shop_contract.account_id(), 
        "req_payment", 
        &json!({
            "order_id":U128(1),
            "user_id": bod.account_id(),
            "msg": "Hello",
            "fee": U128(BOD_FEE_AMOUNT)
        }).to_string().as_bytes(), 
        DEFAULT_GAS,
        to_yocto("0.01") 
    );

    bod.call(
        payment_shop_contract.account_id(), 
        "pay", 
        &json!({
            "pay_id": U128(1)
        }).to_string().as_bytes(), 
        DEFAULT_GAS,
        BOD_FEE_AMOUNT
    );

    bod.call(
        payment_shop_contract.account_id(), 
        "confirm", 
        &json!({
            "pay_id": U128(1)
        }).to_string().as_bytes(), 
        DEFAULT_GAS,
        1 
    );

    let mut outcome = bod.call(
        payment_shop_contract.account_id(), 
        "claim", 
        &json!({
            "pay_id": U128(1)
        }).to_string().as_bytes(), 
        DEFAULT_GAS,
        1
    );

    assert_eq!(outcome.promise_errors().len(), 1);

    // assert error type
    if let ExecutionStatus::Failure(error) = &outcome.promise_errors().remove(0).unwrap().outcome().status {
        println!("Excute error: {}", error.to_string());
        assert!(error.to_string().contains("Access deny"));
    } else {
        unreachable!()
    }

    outcome = alice.call(
        payment_shop_contract.account_id(), 
        "claim", 
        &json!({
            "pay_id": U128(2)
        }).to_string().as_bytes(), 
        DEFAULT_GAS,
        1
    );

    assert_eq!(outcome.promise_errors().len(), 1);

    // assert error type
    if let ExecutionStatus::Failure(error) = &outcome.promise_errors().remove(0).unwrap().outcome().status {
        println!("Excute error: {}", error.to_string());
        assert!(error.to_string().contains("ERR_PAYMENT_NOT_FOUND"));
    } else {
        unreachable!()
    }

    alice.call(
        payment_shop_contract.account_id(), 
        "claim", 
        &json!({
            "pay_id": U128(1)
        }).to_string().as_bytes(), 
        DEFAULT_GAS,
        1
    );

    let mut payment_json: PaymentJson = root.view(
        payment_shop_contract.account_id(), 
        "get_payment_info", 
        &json!({
            "pay_id": U128(1)
        }).to_string().as_bytes()
    ).unwrap_json();

    assert_eq!(payment_json.payment_id, U128(1));
    assert_eq!(payment_json.shop, alice.account_id());
    assert_eq!(payment_json.user, bod.account_id());
    assert_eq!(payment_json.msg, "Hello");
    assert_eq!(payment_json.fee, U128(10000000000000000000000000));
    assert_eq!(payment_json.status, Status::CLAIMED);

    let payment_shop_json: PaymentShopJson = root.view(
        payment_shop_contract.account_id(), 
        "get_payment_shop_info", 
        &json!({}).to_string().as_bytes()
    ).unwrap_json();

    assert_eq!(payment_shop_json.pay_id, U128(1));
    assert_eq!(payment_shop_json.payment_fee_percent, U128(20000));
    assert_eq!(payment_shop_json.total_payment, U128(10000000000000000000000000 * 20000 / 100000));

    payment_json = root.view(
        payment_shop_contract.account_id(), 
        "get_payment_info", 
        &json!({
            "pay_id": U128(10)
        }).to_string().as_bytes()
    ).unwrap_json();
    println!("payment_json {:#?}", payment_json)

}

#[test]
pub fn test_set_payment_fee() {
    let (root, alice, bod, payment_shop_contract) = init();

    let mut outcome = bod.call(
        payment_shop_contract.account_id(), 
        "set_payment_fee", 
        &json!({
            "payment_fee_percent": U128(30000)
        }).to_string().as_bytes(), 
        DEFAULT_GAS,
        1
    );

    assert_eq!(outcome.promise_errors().len(), 1);

    // assert error type
    if let ExecutionStatus::Failure(error) = &outcome.promise_errors().remove(0).unwrap().outcome().status {
        println!("Excute error: {}", error.to_string());
        assert!(error.to_string().contains("Not admin or owner"));
    } else {
        unreachable!()
    }

    outcome = alice.call(
        payment_shop_contract.account_id(), 
        "set_payment_fee", 
        &json!({
            "payment_fee_percent": U128(0)
        }).to_string().as_bytes(), 
        DEFAULT_GAS,
        1
    );

    assert_eq!(outcome.promise_errors().len(), 1);

    // assert error type
    if let ExecutionStatus::Failure(error) = &outcome.promise_errors().remove(0).unwrap().outcome().status {
        println!("Excute error: {}", error.to_string());
        assert!(error.to_string().contains("Invalid payment fee"));
    } else {
        unreachable!()
    }

    alice.call(
        payment_shop_contract.account_id(), 
        "set_payment_fee", 
        &json!({
            "payment_fee_percent": U128(30000)
        }).to_string().as_bytes(), 
        DEFAULT_GAS,
        1
    );

    let payment_shop_json: PaymentShopJson = root.view(
        payment_shop_contract.account_id(), 
        "get_payment_shop_info", 
        &json!({}).to_string().as_bytes()
    ).unwrap_json();

    assert_eq!(payment_shop_json.pay_id, U128(0));
    assert_eq!(payment_shop_json.payment_fee_percent, U128(30000));

}
'''