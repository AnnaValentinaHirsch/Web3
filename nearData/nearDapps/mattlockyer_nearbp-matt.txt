*GitHub Repository "mattlockyer/nearbp-matt"*

'''--- .eslintrc.js ---
module.exports = {
	parserOptions: {
		ecmaVersion: 2020,
        sourceType: 'module',
        ecmaFeatures: {
            jsx: true,
        }
    },
	rules: {
        semi: [2, 'always'],
        indent: [2, 'tab'],
	}
};

'''
'''--- README.md ---
# NEAR App Boilerplate

Most of this repo is how to use React 17 with useContext and useReducer.

There is a helper in `src/utils/state` that handles a lot of this. You can follow the code as an example or read below to understand how it works.

## NEAR Config

There is only one config.js file found in `src/config.js`, this is also used for running tests.

Using `src/config.js` you can set up your different environments. Use `REACT_APP_ENV` to switch environments e.g. in `package.json` script `deploy`.

## Running Tests

You can run unit tests in the Rust contracts themselves, but it may be more useful to JS tests against testnet itself.

Commands:
- `test:deploy` - will deploy a new dev account (`/neardev`) and deploy a new contract to this account
- `test` will simply run the tests against the contract already deployed

If you've changed your contract or your dev account has run out of funds use `test:deploy`, if you're updating your JS tests only then use `test`.

## Test Utils

There are helpers in `test/test-utils.js` that take care of:
1. creating a near connection and establishing a keystore for the dev account
2. creating test accounts each time a test is run
3. establishing a contract instance so you can call methods

You can change the default funding amount for test accounts in `src/config.js`

## Using the NEAR Config in your app

In `src/state/near.js` you will see that `src/config.js` is loaded as a function. This is to satisfy the jest/node test runner.

You can destructure any properies of the config easily in any module you import it in like this:

```
// example file app.js

import getConfig from '../config';
export const {
	GAS,
	networkId, nodeUrl, walletUrl, nameSuffix,
	contractName,
} = getConfig();
```
Note the export const in the destructuring?

Now you can import these like so:
```
//example file Component.js
import { GAS } from '../app.js'
...
await contract.withdraw({ amount: parseNearAmount('1') }, GAS)
...
```

# React 17, Parcel with useContext and useReducer
- Bundled with Parcel 2.0 (@next) && eslint
- *Minimal all-in-one state management with async/await support*

## Getting Started: State Store & useContext

>The following steps describe how to use `src/utils/state` to create and use your own `store` and `StateProvider`.

1. Create a file e.g. `/state/app.js` and add the following code
```js
import { State } from '../utils/state';

// example
const initialState = {
	app: {
		mounted: false
	}
};

export const { store, Provider } = State(initialState);
```
2. Now in your `index.js` wrap your `App` component with the `StateProvider`
```js
import { Provider } from './state/app';

ReactDOM.render(
    <Provider>
        <App />
    </Provider>,
    document.getElementById('root')
);
```
3. Finally in `App.js` you can `useContext(store)`
```js
const { state, dispatch, update } = useContext(store);
```

## Usage in Components
### Print out state values
```js
<p>Hello {state.foo && state.foo.bar.hello}</p>
```
### Update state directly in component functions
```js
const handleClick = () => {
    update('clicked', !state.clicked);
};
```
### Dispatch a state update function (action listener)
```js
const onMount = () => {
    dispatch(onAppMount('world'));
};
useEffect(onMount, []);
```
## Dispatched Functions with context (update, getState, dispatch)

When a function is called using dispatch, it expects arguments passed in to the outer function and the inner function returned to be async with the following json args: `{ update, getState, dispatch }`

Example of a call:
```js
dispatch(onAppMount('world'));
```

All dispatched methods **and** update calls are async and can be awaited. It also doesn't matter what file/module the functions are in, since the json args provide all the context needed for updates to state.

For example:
```js
import { helloWorld } from './hello';

export const onAppMount = (message) => async ({ update, getState, dispatch }) => {
	update('app', { mounted: true });
	update('clicked', false);
	update('data', { mounted: true });
	await update('', { data: { mounted: false } });

	console.log('getState', getState());

	update('foo.bar', { hello: true });
	update('foo.bar', { hello: false, goodbye: true });
	update('foo', { bar: { hello: true, goodbye: false } });
	update('foo.bar.goodbye', true);

	await new Promise((resolve) => setTimeout(() => {
		console.log('getState', getState());
		resolve();
	}, 2000));

	dispatch(helloWorld(message));
};
```
## Prefixing store and Provider

The default names the `State` factory method returns are `store` and `Provider`. However, if you want multiple stores and provider contexts you can pass an additional `prefix` argument to disambiguate.

```js
export const { appStore, AppProvider } = State(initialState, 'app');
```

## Performance and memo

The updating of a single store, even several levels down, is quite quick. If you're worried about components re-rendering, use `memo`:
```js
import React, { memo } from 'react';

const HelloMessage = memo(({ message }) => {
	console.log('rendered message');
	return <p>Hello { message }</p>;
});

export default HelloMessage;
```
Higher up the component hierarchy you might have:
```js
const App = () => {
	const { state, dispatch, update } = useContext(appStore);
    ...
	const handleClick = () => {
		update('clicked', !state.clicked);
	};

	return (
		<div className="root">
			<HelloMessage message={state.foo && state.foo.bar.hello} />
			<p>clicked: {JSON.stringify(state.clicked)}</p>
			<button onClick={handleClick}>Click Me</button>
		</div>
	);
};
```
When the button is clicked, the component HelloMessage will not re-render, it's value has been memoized (cached). Using this method you can easily prevent performance intensive state updates in further down components until they are neccessary.

Reference:
- https://reactjs.org/docs/context.html
- https://dmitripavlutin.com/use-react-memo-wisely/

'''
'''--- contracts/Cargo.toml ---
[package]
name = "basic-token"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0.61"
near-sdk = "2.0.0"
borsh = "0.7.1"
wee_alloc = "0.4.5"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- contracts/README.md ---
Minimal NEP#4 Implementation
============================

This contract implements bare-minimum functionality to satisfy the [NEP#4](https://github.com/nearprotocol/NEPs/pull/4) specification

Notable limitations of this implementation
==========================================

* Only the token owner can mint tokens.
* You cannot give another account escrow access to a limited set of your tokens; an escrow must be trusted with all of your tokens or none at all
* No functions to return the maximum or current supply of tokens
* No functions to return metadata such as the name or symbol of this NFT
* No functions (or storage primitives) to find all tokens belonging to a given account
* Usability issues: some functions (e.g. `revoke_access`, `transfer`, `get_token_owner`) do not verify that they were given sensible inputs; if given non-existent keys, the errors they throw will not be very useful

Still, if you track some of this information in an off-chain database, these limitations may be acceptable for your needs. In that case, this implementation may help reduce gas and storage costs.

Notable additions that go beyond the specification of NEP#4
===========================================================

`mint_token`: the spec gives no guidance or requirements on how tokens are minted/created/assigned. This specific implementation only allows the contract owner to mint new tokens. If this implementation of `mint_token` is close to matching your needs, feel free to ship your NFT with only minor modifications. If you'd rather go with a strategy such as minting the whole supply of tokens upon deploy of the contract, or something else entirely, you may want to drastically change this behavior.

'''
'''--- contracts/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../out
cp target/wasm32-unknown-unknown/release/*.wasm ../out/main.wasm

'''
'''--- contracts/src/lib.rs ---
use borsh::{ BorshDeserialize, BorshSerialize };
use near_sdk::{
    env, near_bindgen, AccountId, Balance, Promise,
    collections::{ UnorderedMap },
    json_types::{ U128 },
};

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Trust {
    pub owner_id: AccountId,
    pub balances: UnorderedMap<AccountId, Balance>,
}

impl Default for Trust {
    fn default() -> Self {
        panic!("should be initialized before usage")
    }
}

#[near_bindgen]
impl Trust {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        assert!(env::is_valid_account_id(owner_id.as_bytes()), "Owner's account ID is invalid.");
        assert!(!env::state_exists(), "Already initialized");
        Self {
            owner_id,
            balances: UnorderedMap::new(b"balances".to_vec()),
        }
    }

    #[payable]
    pub fn deposit(&mut self) {
        let deposit = env::attached_deposit();
        let account_id = env::signer_account_id();
        let mut balance = self.balances.get(&account_id).unwrap_or(0);
        balance += deposit;
        self.balances.insert(&account_id, &balance);
    }

    pub fn withdraw(&mut self, amount: U128) {
        let amount_u128 = amount.into();
        let account_id = env::signer_account_id();
        let mut balance = self.balances.get(&account_id).unwrap_or(0);
        assert!(balance >= amount_u128, "not enough tokens");
        assert!(env::account_balance() >= balance, "missing funds");
        balance -= amount_u128;
        self.balances.insert(&account_id, &balance);
        Promise::new(account_id).transfer(balance);
    }

    pub fn get_balance(&self, account_id: AccountId) -> U128 {
        self.balances.get(&account_id).unwrap_or(0).into()
    }
}

// use the attribute below for unit tests
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};
    
    fn ntoy(near_amount: Balance) -> Balance {
        near_amount * 10u128.pow(24)
    }

    fn get_context() -> VMContext {
        VMContext {
            predecessor_account_id: "alice.testnet".to_string(),
            current_account_id: "alice.testnet".to_string(),
            signer_account_id: "bob.testnet".to_string(),
            signer_account_pk: vec![0, 1, 2],
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 19,
            storage_usage: 0,
        }
    }

    #[test]
    fn deposit() {
        let mut context = get_context();
        testing_env!(context.clone());
        let mut contract = Trust::new(context.current_account_id.clone());

        context.attached_deposit = ntoy(1000);
        testing_env!(context.clone());

        contract.deposit();
        let balance = contract.get_balance(context.signer_account_id.clone());

        assert_eq!(balance, ntoy(1000));
    }

    #[test]
    fn withdraw() {
        let mut context = get_context();
        testing_env!(context.clone());
        let mut contract = Trust::new(context.current_account_id.clone());

        context.attached_deposit = ntoy(1000);
        testing_env!(context.clone());

        contract.deposit();
        let balance = contract.get_balance(context.signer_account_id.clone());

        assert_eq!(balance, ntoy(1000));

        contract.withdraw(ntoy(1000));
        let balance = contract.get_balance(context.signer_account_id.clone());

        assert_eq!(balance, 0);
    }

    #[test]
    #[should_panic(
        expected = r#"not enough tokens"#
    )]
    fn should_panic_withdraw() {
        let mut context = get_context();
        testing_env!(context.clone());
        let mut contract = Trust::new(context.current_account_id.clone());

        context.attached_deposit = ntoy(1000);
        testing_env!(context.clone());

        contract.deposit();
        let balance = contract.get_balance(context.signer_account_id.clone());

        assert_eq!(balance, ntoy(1000));

        contract.withdraw(ntoy(2000));
        let balance = contract.get_balance(context.signer_account_id.clone());

        assert_eq!(balance, 0);
    }
}
'''
'''--- package.json ---
{
    "name": "react-parcel-boilerplate",
    "version": "1.0.0",
    "description": "React Parcel Boilerplate",
    "author": "Matt Lockyer",
    "license": "ISC",
    "dependencies": {
        "bn": "^1.0.5",
        "near-api-js": "^0.36.2",
        "parcel": "^2.0.0-beta.1",
        "react": "^17.0.1",
        "react-dom": "^17.0.1"
    },
    "devDependencies": {
        "eslint": "^7.14.0",
        "jest": "^26.6.3",
        "jest-environment-uint8array": "^1.0.0",
        "node-fetch": "^2.6.1",
        "rimraf": "^3.0.2"
    },
    "browserslist": [
        "last 2 Chrome versions"
    ],
    "scripts": {
        "prestart": "yarn clean",
        "start:deploy": "yarn test:deploy && yarn start",
        "start": "REACT_APP_ENV=dev parcel src/index.html --open",
        "prebuild": "yarn clean",
        "build": "parcel build src/index.html --no-source-maps",
        "clean": "rimraf ./dist ./parcel-cache",
        "fix": "eslint src/ test/ server/ --fix",
        "build:contracts": "(cd contracts && ./build.sh)",
        "patch:config": "node ./utils/patch-config.js",
        "dev:deploy": "yarn build:contracts && rm -rf neardev && (DEV_DEPLOY=true near dev-deploy || exit 0) && yarn patch:config",
        "test:unit": "(cd contracts && cargo test -- --nocapture --color always)",
        "test:deploy": "yarn dev:deploy && yarn test",
        "test": "REACT_APP_ENV=dev jest app.test.js --useStderr",
        "test:server": "REACT_APP_ENV=dev jest server.test.js --useStderr",
        "deploy": "REACT_APP_ENV=prod yarn build && cp -a static/* dist && gh-pages -d dist"
    },
    "jest": {
        "testEnvironment": "jest-environment-uint8array"
    }
}

'''
'''--- server/app.js ---
const express = require('express');
const cors = require('cors');
const nearAPI = require('near-api-js');
const getConfig = require('../src/config');
const { contractAccount, withNear, hasAccessKey } = require('./middleware/near');
const { contractName } = getConfig();
const {
	
} = nearAPI;

const app = express();
const port = 3000;

app.use(cors());
app.use(express.json());
app.use(withNear());

app.get('/', (req, res) => {
	res.send('Hello World!');
});

app.post('/has-access-key', hasAccessKey, (req, res) => {
	res.json({ success: true });
});

app.post('/add-key', hasAccessKey, async (req, res) => {
    const { publicKey } = req.body;
    const result = await contractAccount.addAccessKey(publicKey);
	res.json({ success: true, result });
});

app.listen(port, () => {
	console.log(`\nContract Account ID:\n${contractName}\nListening at http://localhost:${port}`);
});
'''
'''--- server/middleware/near.js ---

const nacl = require('tweetnacl');
const crypto = require('crypto');
const bs58 = require('bs58');
const { near, connection, contractAccount } = require('../utils/near-utils')

const withNear = () => (req, res, next) => {
	req.near = near;
	next();
};

const VALID_BLOCK_AGE = 100;

const validBlock = async (blockNumber) => {
	const currentBlock = (await connection.provider.status()).sync_info.latest_block_height;
	const givenBlock = Number(blockNumber);
	if (givenBlock <= currentBlock - VALID_BLOCK_AGE || givenBlock > currentBlock) {
		return false;
	}
	return true;
};

const verifySignature = async (accountId, data, signature, contractName = '') => {
	const nearAccount = await near.account(accountId);
	try {
		const hash = crypto.createHash('sha256').update(data).digest();
		let accessKeys = await nearAccount.getAccessKeys();
		if (contractName.length) {
			accessKeys = accessKeys.filter(({ access_key: { permission }}) => permission && permission.FunctionCall && permission.FunctionCall.receiver_id === contractName);
		} else {
			accessKeys = accessKeys.filter(({ access_key: { permission }}) => permission === 'FullAccess');
        }

		return accessKeys.some(({ public_key }) => {
			const publicKey = public_key.replace('ed25519:', '');
			return nacl.sign.detached.verify(hash, Buffer.from(signature, 'base64'), bs58.decode(publicKey));
		});
	} catch (e) {
		console.error(e);
		return false;
	}
};

const hasAccessKey = async (req, res, next) => {
    const { accountId, contractName, blockNumber, blockNumberSignature } = req.body;
    
	if (!accountId || !contractName || !blockNumber || !blockNumberSignature) {
		return res.status(403).send({ error: 'You must provide an accountId, contractName, blockNumber, and blockNumberSignature' });
	}

	if (!(await validBlock(blockNumber))) {
		return res.status(403).send({ error: `You must provide a blockNumber within ${VALID_BLOCK_AGE} of the most recent block; provided: ${blockNumber}, current: ${currentBlock}`});
	}

	if (!(await verifySignature(accountId, blockNumber, blockNumberSignature, contractName))) {
		return res.status(403).send({ error: `blockNumberSignature did not match a signature of blockNumber=${blockNumber} from accountId=${accountId}`});
	}

	return await next();
};

module.exports = {
    contractAccount,
	withNear,
	hasAccessKey,
};
'''
'''--- server/package.json ---
{
    "name": "server",
    "version": "1.0.0",
    "description": "near utility server",
    "main": "app.js",
    "scripts": {
        "start": "nodemon app.js",
        "test": "echo \"Error: no test specified\" && exit 1"
    },
    "author": "mattlockyer",
    "license": "ISC",
    "dependencies": {
        "bs58": "^4.0.1",
        "cors": "^2.8.5",
        "express": "^4.17.1",
        "near-api-js": "^0.36.2",
        "tweetnacl": "^1.0.3"
    },
    "devDependencies": {
        "nodemon": "^2.0.7"
    }
}

'''
'''--- server/utils/near-utils.js ---
const fs = require('fs');
const nearAPI = require('near-api-js');
const getConfig = require('../../src/config');
const { nodeUrl, networkId, contractName, contractMethods } = getConfig(true);
const {
    Near, Account, Contract, KeyPair,
    utils: {
        format: {
            parseNearAmount
        }
    }
} = nearAPI;

const credentials = JSON.parse(fs.readFileSync(process.env.HOME + '/.near-credentials/default/' + contractName + '.json'));
const keyStore = {
    keys: {},
	getKey(networkId, accountId) {
		const value = this.keys[`${accountId}:${networkId}`];
        if (!value) {
            return null;
        }
        return KeyPair.fromString(value);
    },
    setKey(networkId, accountId, keyPair) {
        this.keys[`${accountId}:${networkId}`] = keyPair.toString();
    }
};
keyStore.setKey(networkId, contractName, KeyPair.fromString(credentials.private_key))
const near = new Near({
	networkId, nodeUrl,
	deps: { keyStore },
});
const { connection } = near
const contractAccount = new Account(connection, contractName);
contractAccount.addAccessKey = (publicKey) => contractAccount.addKey(publicKey, contractName, contractMethods.changeMethods, parseNearAmount('0.1'))
const contract = new Contract(contractAccount, contractName, contractMethods);

module.exports = {
    near,
    keyStore,
    connection,
    contract,
    contractName,
    contractAccount,
}
'''
'''--- src/App.css ---

body {
    margin: 0;
}

.root {
    margin: 16px;
}

button {
    margin-right: 16px;
}
'''
'''--- src/App.js ---
import React, { useContext, useEffect } from 'react';

import { appStore, onAppMount } from './state/app';
import { signFetch } from './state/near';

import { Wallet } from './components/Wallet';
import { Trust } from './components/Trust';

import './App.css';

const App = () => {
	const { state, dispatch, update } = useContext(appStore);
    
	console.log(state);
    
	const { wallet, account, contract } = state;

	const onMount = () => {
		dispatch(onAppMount());
	};
	useEffect(onMount, []);
    
	return (
		<div className="root">
			<Wallet {...{ wallet, account }} />
			<Trust {...{ contract, account, dispatch }} />

			<button onClick={() => dispatch(signFetch('http://localhost:3000/has-access-key'))}>Test Signed Message</button>
			<button onClick={() => dispatch(signFetch('http://localhost:3000/get-key'))}>Test Add Key</button>
		</div>
	);
};

export default App;

'''
'''--- src/components/Trust.js ---
import { BN } from 'bn.js';

import React, {useState} from 'react';

import { GAS, parseNearAmount } from '../state/near';
import { getBalances, setDepositAction } from '../state/trust';

export const Trust = ({ contract, account, dispatch }) => {
	if (!contract || !account) return null;

	const [amount, setAmount] = useState('');

	const handleDeposit = async () => {
		const deposit = parseNearAmount(amount);
		// calc what should be the next deposit amount
		const pendingDepositAmount = new BN(parseNearAmount(account.trustBalance)).add(new BN(deposit)).toString();
		setDepositAction(pendingDepositAmount);
		//redirect to wallet will lose state here
		contract.deposit({}, GAS, deposit);
	};

	const handleWithdraw = async () => {
		const withdrawal = parseNearAmount(amount);
		const result = await contract.withdraw({ amount: withdrawal }, GAS);
		console.log(result);
		dispatch(getBalances());
	};

	return <>
		<p>Trust Contract: {contract.contractId}</p>
		<p>Balance: {account.trustBalance}</p>

		<p>Make a Deposit to the Trust Contract</p>
		<input id="amount" placeholder="Amount (N)" onChange={(e) => setAmount(e.target.value)} />
		<br />
		<br />
		<button onClick={handleDeposit}>Deposit</button>
		{ account.trustBalance !== '0' &&
            <button onClick={handleWithdraw}>Withdraw</button>
		}
		<button onClick={() => setAmount(111)}>Clear</button>
	</>;
};

'''
'''--- src/components/Wallet.js ---
import React from 'react';

export const Wallet = ({ wallet, account }) => {
	if (!wallet) return null;

	if (wallet.signedIn) {
		return <>
			<p>Signed In: { account.accountId }</p>
			<p>Balance: { wallet.balance }</p>
			<button onClick={() => wallet.signOut()}>Sign Out</button>
		</>;
	}

	return <button onClick={() => wallet.signIn()}>Sign In</button>;
};

'''
'''--- src/config.js ---
const contractName = 'dev-1611676909628-9977742';

module.exports = function getConfig(isServer = false) {
	let config = {
		networkId: 'default',
		nodeUrl: 'https://rpc.testnet.near.org',
		walletUrl: 'https://wallet.testnet.near.org',
		helperUrl: 'https://helper.testnet.near.org',
		contractName,
	};
    
	if (!process.env.DEV_DEPLOY && (isServer || process.env.REACT_APP_ENV === 'dev')) {
		config = {
			...config,
			GAS: '200000000000000',
			DEFAULT_NEW_ACCOUNT_AMOUNT: '5',
			contractMethods: {
				changeMethods: ['new', 'deposit', 'withdraw'],
				viewMethods: ['get_balance'],
			},
		};
	}

	if (process.env.REACT_APP_ENV === 'prod') {
		config = {
			...config,
			networkId: 'mainnet',
			nodeUrl: 'https://rpc.mainnet.near.org',
			walletUrl: 'https://wallet.near.org',
			helperUrl: 'https://helper.mainnet.near.org',
			contractName: 'near',
		};
	}

	return config;
};

'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>React Parcel Boilerplate</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script src="./index.js"></script>
  </body>
</html>

'''
'''--- src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import { AppProvider } from './state/app.js';

ReactDOM.render(
	<AppProvider>
		<App />
	</AppProvider>,
	document.getElementById('root')
);

'''
'''--- src/state/app.js ---
import { State } from '../utils/state';

import { initNear } from './near';

const initialState = {
	app: {
		mounted: false,
	},
	near: {
		initialized: false,
	}
};

export const { appStore, AppProvider } = State(initialState, 'app');

export const onAppMount = () => async ({ update, getState, dispatch }) => {
	update('app', { mounted: true });
	dispatch(initNear());
};

'''
'''--- src/state/near.js ---
import getConfig from '../config';
import * as nearAPI from 'near-api-js';
import { getWallet, postSignedJson } from '../utils/near-utils';
import { initContract } from './trust';

export const {
	GAS,
	networkId, nodeUrl, walletUrl, nameSuffix,
	contractName,
} = getConfig();

export const {
	utils: {
		format: {
			formatNearAmount, parseNearAmount
		}
	}
} = nearAPI;

export const initNear = () => async ({ update, getState, dispatch }) => {
	const { near, wallet } = await getWallet();

	wallet.signIn = () => {
		wallet.requestSignIn(contractName, 'Blah Blah');
	};
	const signOut = wallet.signOut;
	wallet.signOut = () => {
		signOut.call(wallet);
		update('wallet.signedIn', false);
	};

	wallet.signedIn = wallet.isSignedIn();
    
	let account;
	if (wallet.signedIn) {
		wallet.balance = formatNearAmount((await wallet.account().getAccountBalance()).available, 2);
		account = wallet.account();
	}

	update('', { near, wallet, account });
    
	dispatch(initContract());
};

export const signFetch = (url, data = {}) => async ({ getState }) => {
	const { account } = await getState();
	const result = await postSignedJson({ account, contractName, url, data });
	console.log(result);
};

'''
'''--- src/state/trust.js ---
import { getContract } from '../utils/near-utils';
import { get, set, del } from '../utils/storage';
import { formatNearAmount, parseNearAmount } from './near';

export const DEPOSIT_ACTION = '__DEPOSIT_ACTION';

export const initContract = () => async ({ update, getState, dispatch }) => {
	const { account } = await getState();
	const contract = getContract(account);
	await update('', { contract });
	dispatch(getDepositAction());
};

export const getBalances = () => async ({ update, getState, dispatch }) => {
	const { account, contract } = await getState();
	console.log(contract);
	const trustBalance = formatNearAmount(await contract.get_balance({ account_id: account.accountId }), 2);
	update('account', { trustBalance });
};

export const getDepositAction = () => async ({ update, dispatch, getState }) => {
	const amount = get(DEPOSIT_ACTION, '0');
	if (amount) {
		update('account', { pendingDeposit: true });
		const limit = 60, delay = 2000;
		let checks = 0;
		const check = async () => {
			await dispatch(getBalances());
			const { account } = await getState();
			const balance = parseNearAmount(account.trustBalance);
			console.log('checking', checks, amount, balance);
			if (amount === balance) {
				delDepositAction();
				return update('account', { pendingDeposit: false });
			}
			checks++;
			if (checks < limit) {
				setTimeout(check, delay);
			}
		};
		check();
	} else {
		await dispatch(getBalances());
	}
};

/********************************
Not dispatched
********************************/

export const setDepositAction = (amount) => {
	set(DEPOSIT_ACTION, amount);
};

export const delDepositAction = () => {
	del(DEPOSIT_ACTION);
};
'''
'''--- src/utils/near-utils.js ---
import getConfig from '../config';
import * as nearAPI from 'near-api-js';

export const {
	GAS,
	networkId, nodeUrl, walletUrl, nameSuffix,
	contractName, contractMethods
} = getConfig();

const {
	Contract,
	InMemorySigner,
} = nearAPI;

export function getContract(account) {
	return new Contract(account, contractName, { ...contractMethods });
}

export const getWallet = async () => {
	const near = await nearAPI.connect({
		networkId, nodeUrl, walletUrl, deps: { keyStore: new nearAPI.keyStores.BrowserLocalStorageKeyStore() },
	});
	const wallet = new nearAPI.WalletAccount(near);
	return { near, wallet };
};

export const getSignature = async (account) => {
	const { accountId } = account;
	const block = await account.connection.provider.block({ finality: 'final' });
	const blockNumber = block.header.height.toString();
	const signer = account.inMemorySigner || account.connection.signer;
	const signed = await signer.signMessage(Buffer.from(blockNumber), accountId, networkId);
	const blockNumberSignature = Buffer.from(signed.signature).toString('base64');
	return { blockNumber, blockNumberSignature };
};

export const postSignedJson = async ({ account, contractName, url, data = {} }) => {
	const result = await fetch(url, {
		method: 'POST',
		headers: new Headers({ 'content-type': 'application/json' }),
		body: JSON.stringify({
			...data,
			accountId: account.accountId,
			contractName,
			...(await getSignature(account))
		})
	}).then((res) => res.json());
	console.log(result);
};

/********************************
Not used
********************************/

export const hasKey = async (near, accountId, publicKey) => {
	const pubKeyStr = publicKey.toString();
	const account = new nearAPI.Account(near.connection, accountId);
	try {
		const accessKeys = await account.getAccessKeys();
		if (accessKeys.length > 0 && accessKeys.find(({ public_key }) => public_key === pubKeyStr)) {
			return true;
		}
	} catch (e) {
		console.warn(e);
	}
	return false;
};

export const isAccountTaken = async (near, accountId) => {
	if (accountId.indexOf(nameSuffix) > -1) {
		return true;
	}
	accountId = accountId + nameSuffix;
	const account = new nearAPI.Account(near.connection, accountId);
	try {
		await account.state();
		return true;
	} catch (e) {
		if (!/does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return false;
};

export const getContractSigner = async ({ keyPair }) => {
	const signer = await InMemorySigner.fromKeyPair(networkId, contractName, keyPair);
	const near = await nearAPI.connect({
		networkId, nodeUrl, walletUrl, deps: { keyStore: signer.keyStore },
	});
	const account = new nearAPI.Account(near.connection, contractName);
	const contract = await new nearAPI.Contract(account, contractName, {
		changeMethods: ['send', 'claim', 'create_account_and_claim'],
		sender: account
	});
	return { contract };
};
'''
'''--- src/utils/state.js ---
import React, { createContext, useReducer } from 'react';

export const State = (initialState, prefix) => {
	let updatedState;
	const getState = () => updatedState;
	const store = createContext(initialState);
	const { Provider: InnerProvider } = store;

	const updateState = (state, newState, path = '') => {
		// console.log('updateState', state, path, newState) // debugging
		if (path.length === 0) {
			return { ...state, ...newState };
		}
		const pathArr = path.split('.');
		const first = pathArr[0];
		state = { ...state };
		if (!state[first]) {
			state[first] = {};
		}
		if (pathArr.length === 1) {
			state[first] = !!newState && typeof newState === 'object' ? {
				...state[first],
				...newState
			} : newState;
		} else {
			state[first] = {
				...state[first],
				...updateState(state[first], newState, pathArr.slice(1).join('.'))
			};
		}

		return state;
	};

	const Provider = ({ children }) => {
		const [state, dispatch] = useReducer((state, payload) => {
			const { path, newState } = payload;
			if (path === undefined) {
				return state;
			}
			updatedState = updateState(state, newState, path);
			return updatedState;
		}, initialState);

		const update = (path, newState) => {
			dispatch({ path, newState });
		};
		const wrappedDispatch = (fn) => fn({ update, getState, dispatch: wrappedDispatch });

		return <InnerProvider value={{ update, state, dispatch: wrappedDispatch }}>{children}</InnerProvider>;
	};

	if (prefix) {
		return {
			[prefix + 'Store']: store,
			[prefix.substr(0, 1).toUpperCase() + prefix.substr(1) + 'Provider']: Provider,
		};
	}
    
	return { store, Provider };
};

'''
'''--- src/utils/storage.js ---
export const get = (k, d = {}) => {
	let v = localStorage.getItem(k);
	if (typeof d !== 'object') {
		return v;
	}
	try {
		return JSON.parse(v || JSON.stringify(d));
	} catch (e) {
		return v;
	}
};
export const set = (k, v) => localStorage.setItem(k, typeof v === 'string' ? v : JSON.stringify(v));
export const del = (k) => localStorage.removeItem(k);
'''
'''--- test/app.test.js ---
const nearAPI = require('near-api-js');
const nearUtils = require('./test-utils');
const getConfig = require('../src/config');

const { Account, utils: { format: { parseNearAmount }} } = nearAPI;
const { connection, initContract, getAccount, getContract } = nearUtils;
const { GAS, contractName } = getConfig();

jasmine.DEFAULT_TIMEOUT_INTERVAL = 50000;

describe('deploy contract ' + contractName, () => {
	let alice;

	beforeAll(async () => {
		alice = await getAccount();
		await initContract(alice.accountId);
	});

	test('contract hash', async () => {
		let state = (await new Account(connection, contractName)).state();
		expect(state.code_hash).not.toEqual('11111111111111111111111111111111');
	});

	test('check deposit', async () => {
		console.log('alice balance', (await alice.state()).amount);

		const contract = await getContract(alice);
		await contract.deposit({}, GAS, parseNearAmount('1.123'));
		const balance = await contract.get_balance({ account_id: alice.accountId });

		// weird bug where you have to get new Account instance before state will give you latest balance
		alice = await getAccount(alice.accountId);
		expect((await alice.state()).amount).not.toEqual(parseNearAmount('5'));
		expect(balance).toEqual(parseNearAmount('1.123'));
	});

	// contract has the same state (hasn't been redeployed) and "alice" account is the same
	test('check withdraw', async () => {
		const contract = await getContract(alice);
		await contract.withdraw({ amount: parseNearAmount('0.123') }, GAS);
		const balance = await contract.get_balance({ account_id: alice.accountId });
		expect(balance).toEqual(parseNearAmount('1'));
	});

});
'''
'''--- test/near-utils.js ---
const fs = require('fs');
const nearAPI = require('near-api-js');
const getConfig = require('../src/config');
const { nodeUrl, networkId, contractName, contractMethods } = getConfig(true);
const {
    Near, Account, Contract, KeyPair,
    utils: {
        format: {
            parseNearAmount
        }
    }
} = nearAPI;

const credentials = JSON.parse(fs.readFileSync(process.env.HOME + '/.near-credentials/default/' + contractName + '.json'));
const keyStore = {
    keys: {},
	getKey(networkId, accountId) {
		const value = this.keys[`${accountId}:${networkId}`];
        if (!value) {
            return null;
        }
        return KeyPair.fromString(value);
    },
    setKey(networkId, accountId, keyPair) {
        this.keys[`${accountId}:${networkId}`] = keyPair.toString();
    }
};
keyStore.setKey(networkId, contractName, KeyPair.fromString(credentials.private_key))
const near = new Near({
	networkId, nodeUrl,
	deps: { keyStore },
});
const { connection } = near
const contractAccount = new Account(connection, contractName);
contractAccount.addAccessKey = (publicKey) => contractAccount.addKey(publicKey, contractName, contractMethods.changeMethods, parseNearAmount('0.1'))
const contract = new Contract(contractAccount, contractName, contractMethods);

module.exports = {
    near,
    keyStore,
    connection,
    contract,
    contractName,
    contractAccount,
}
'''
'''--- test/server.test.js ---
const nearAPI = require('near-api-js');
const nearUtils = require('./test-utils');
const getConfig = require('../src/config');

const { KeyPair, utils: { format: { parseNearAmount }} } = nearAPI;
const { keyStore, initContract, getAccount, contractAccount, postSignedJson } = nearUtils;
const { contractName, networkId } = getConfig();

jasmine.DEFAULT_TIMEOUT_INTERVAL = 50000;

describe('deploy contract ' + contractName, () => {
    let alice;
    let accessKey;

	beforeAll(async () => {
		alice = await getAccount();
		await initContract();
	});

	test('contract hash', async () => {
		let state = await (await getAccount(contractName)).state();
		expect(state.code_hash).not.toEqual('11111111111111111111111111111111');
	});

	test('check wallet sign in', async () => {
        // simulated wallet sign in
        // add a new key and manually set the signer for alice to the access key instead of full access key
        const newKeyPair = KeyPair.fromRandom('ed25519');
        await alice.addKey(newKeyPair.publicKey, contractName, null, parseNearAmount('0.1'));
        keyStore.setKey(networkId, alice.accountId, newKeyPair)
        const result = await postSignedJson({ account: alice, contractName, url: 'http://localhost:3000/has-access-key/' })
        expect(result.success).toEqual(true);
	});

	test('check adding key to contract account', async () => {
        accessKey = KeyPair.fromRandom('ed25519');
        const publicKey = accessKey.publicKey.toString()
        const result = await postSignedJson({
            account: alice, contractName, url: 'http://localhost:3000/add-key/',
            data: {
                publicKey
            }
        })
        expect(result.success).toEqual(true);
        const accessKeys = await contractAccount.getAccessKeys();
        expect(accessKeys.find(({ public_key }) => public_key === publicKey)).not.toEqual(undefined)
	});

	test('check using contract key', async () => {
        // use the access key from the previous test to sign txs on behalf of the contract account now
        keyStore.setKey(networkId, contractName, accessKey)
        const result = await postSignedJson({ account: contractAccount, contractName, url: 'http://localhost:3000/has-access-key/' })
        expect(result.success).toEqual(true);
	});

});
'''
'''--- test/test-utils.js ---
const BN = require('bn.js');
const fetch = require('node-fetch');
const nearAPI = require('near-api-js');
const { KeyPair, Account, Contract, utils: { format: { parseNearAmount } } } = nearAPI;
const { near, connection, keyStore, contract, contractAccount } = require('./near-utils')
const getConfig = require('../src/config');
const {
    networkId, contractName, contractMethods, DEFAULT_NEW_ACCOUNT_AMOUNT
} = getConfig();

/********************************
Internal Helpers
********************************/
async function createAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT) {
	const contractAccount = new Account(connection, contractName);
	const newKeyPair = KeyPair.fromRandom('ed25519');
	await contractAccount.createAccount(accountId, newKeyPair.publicKey, new BN(parseNearAmount(fundingAmount)));
    keyStore.setKey(networkId, accountId, newKeyPair);
	return new nearAPI.Account(connection, accountId);
}

const getSignature = async (account) => {
	const { accountId } = account;
	const block = await account.connection.provider.block({ finality: 'final' });
	const blockNumber = block.header.height.toString();
	const signer = account.inMemorySigner || account.connection.signer;
	const signed = await signer.signMessage(Buffer.from(blockNumber), accountId, networkId);
	const blockNumberSignature = Buffer.from(signed.signature).toString('base64');
	return { blockNumber, blockNumberSignature };
};

function generateUniqueString(prefix) {
	return `${prefix}-${Date.now()}-${Math.round(Math.random() * 1000000)}`;
}

/********************************
Exports
********************************/

async function initContract() {
	try {
		await contract.new({ owner_id: contractName });
	} catch (e) {
		if (!/Already initialized/.test(e.toString())) {
			throw e;
		}
	}
	return { contract, contractName };
}

async function getContract(account) {
	return new Contract(account || contractAccount, contractName, {
		...contractMethods,
		signer: account || undefined
	});
}

async function getAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT) {
	accountId = accountId || generateUniqueString('test');
	const account = new nearAPI.Account(connection, accountId);
	try {
		await account.state();
		return account;
	} catch(e) {
		if (!/does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return await createAccount(accountId, fundingAmount);
};

const postSignedJson = async ({ account, contractName, url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: { 'content-type': 'application/json' },
		body: JSON.stringify({
			...data,
			accountId: account.accountId,
			contractName,
			...(await getSignature(account))
		})
	}).then((res) => res.json());
};

module.exports = { 
    near,
    connection,
    keyStore,
    getContract,
    contract,
    contractName,
    contractAccount,
    initContract, getAccount, postSignedJson
};
'''
'''--- utils/patch-config.js ---
const fs = require('fs');
const contractName = fs.readFileSync('./neardev/dev-account').toString()
const path = './src/config.js'
 
fs.readFile(path, 'utf-8', function(err, data) {
    if (err) throw err;
 
    data = data.replace(/.*const contractName.*/gim, `const contractName = '${contractName}';`);
 
    fs.writeFile(path, data, 'utf-8', function(err) {
        if (err) throw err;
        console.log('Done!');
    })
})

'''