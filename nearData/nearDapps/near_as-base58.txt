*GitHub Repository "near/as-base58"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- .travis.yml ---
language: node_js
node_js:
  - "10"
  - "11"
  - "12"

jobs:
  include:
    - name: yarn
      script:
      - yarn test

    - name: fossa
      before_script:
        - "curl -H 'Cache-Control: no-cache' https://raw.githubusercontent.com/fossas/fossa-cli/fc60c6631a5d372d5a45fea35e31665b338f260d/install.sh | sudo bash"
      script:
        - fossa init
        - fossa analyze --server-scan
        - fossa test

'''
'''--- README.md ---
# as-base58
Base58 encoder / decoder for AssemblyScript.

Special thanks to https://github.com/cryptocoinjs/base-x for the javascript version.

# Usage

```ts
import { encode, decode } from "as-base58";

const input = "ABCD1234"

assert(input = enocde(decode("ABCD1234"));
```

'''
'''--- as-pect.config.js ---
module.exports = {
  /**
   * A set of globs passed to the glob package that qualify typescript files for testing.
   */
  include: ["assembly/__tests__/**/*.spec.ts"],
  /**
   * A set of globs passed to the glob package that quality files to be added to each test.
   */
  add: ["assembly/__tests__/**/*.include.ts"],
  /**
   * All the compiler flags needed for this test suite. Make sure that a binary file is output.
   */
  flags: {
    "--validate": [],
    "--debug": [],
    /** This is required. Do not change this. The filename is ignored, but required by the compiler. */
    "--binaryFile": ["output.wasm"],
    /** To enable wat file output, use the following flag. The filename is ignored, but required by the compiler. */
    "--textFile": ["output.wat"],
    "--runtime": ["stub"], // Acceptable values are: full, half, stub (arena), and none,
    "--baseDir": process.cwd()
    // "--runPasses": ["dce"]
  },
  /**
   * A set of regexp that will disclude source files from testing.
   */
  disclude: [/node_modules/],
  /**
   * Add your required AssemblyScript imports here.
   */
  imports: {},
  /**
   * All performance statistics reporting can be configured here.
   */
  performance: {
    /** Enable performance statistics gathering. */
    enabled: false,
    /** Set the maximum number of samples to run for each test. */
    maxSamples: 10000,
    /** Set the maximum test run time in milliseconds. */
    maxTestRunTime: 2000,
    /** Set the number of decimal places to round to. */
    roundDecimalPlaces: 3,
    /** Report the median time in the default reporter. */
    reportMedian: true,
    /** Report the average time in milliseconds. */
    reportAverage: true,
    /** Report the standard deviation. */
    reportStandardDeviation: false,
    /** Report the maximum run time in milliseconds. */
    reportMax: false,
    /** Report the minimum run time in milliseconds. */
    reportMin: false,
    /** Report the variance. */
    reportVariance: false,
  },
  /**
   * Add a custom reporter here if you want one. The following example is in typescript.
   *
   * @example
   * import { TestReporter, TestGroup, TestResult, TestContext } from "as-pect";
   *
   * export class CustomReporter extends TestReporter {
   *   // implement each abstract method here
   *   public abstract onStart(suite: TestContext): void;
   *   public abstract onGroupStart(group: TestGroup): void;
   *   public abstract onGroupFinish(group: TestGroup): void;
   *   public abstract onTestStart(group: TestGroup, result: TestResult): void;
   *   public abstract onTestFinish(group: TestGroup, result: TestResult): void;
   *   public abstract onFinish(suite: TestContext): void;
   * }
   */
  // reporter: new CustomReporter(),
};

'''
'''--- assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- assembly/__tests__/roundtrip.spec.ts ---
import { encode, decodeUnsafe, decode } from '..';

function roundtripTest(inputString: string): void {
  const inputBuf = String.UTF8.encode(inputString);
  const input = inputBuf.byteLength > 0 ? Uint8Array.wrap(inputBuf) : new Uint8Array(0);
  expect(String.UTF8.decode(decode(encode(input)).buffer)).toBe(inputString);
}

describe("Round trip", () => {
  it("should handle empty object", () => {
    roundtripTest("{}");
  });

  it("should handle int32", () => {
    roundtripTest('{"int":4660}');
  });

  it("should handle int32Sign", () => {
    roundtripTest('{"int":-4660}');
  });

  it("should handle true", () => {
    roundtripTest('{"val":true}');
  });

  it("should handle false", () => {
    roundtripTest('{"val":false}');
  });

  it("should handle null", () => {
    roundtripTest('{"val":null}');
  });

  it("should handle string", () => {
    roundtripTest('{"str":"foo"}');
  });

  it("should handle string escaped", () => {
    roundtripTest(
      '"\\"\\\\\\/\\n\\t\\b\\r\\t"');
  });

  it("should handle string unicode escaped simple", () => {
    roundtripTest('"\\u0022"');
  });

  it("should handle string unicode escaped", () => {
   roundtripTest('"Полтора Землекопа"');
   
  });

  it("should multiple keys", () => {
    roundtripTest('{"str":"foo","bar":"baz"}');
  });

  it("should handle nested objects", () => {
    roundtripTest('{"str":"foo","obj":{"a":1,"b":-123456}}');
  });

  it("should handle empty array", () => {
    roundtripTest("[]");
  });

  it("should handle array", () => {
    roundtripTest("[1,2,3]");
  });

  it("should handle nested arrays", () => {
    roundtripTest("[[1,2,3],[4,[5,6]]]");
  });

  it("should handle nested objects and arrays", () => {
    roundtripTest('{"str":"foo","arr":[{"obj":{"a":1,"b":-123456}}]}');
  });

  it("should handle whitespace", () => {
    roundtripTest(' { "str":"foo","obj": {"a":1, "b" :\n -123456} } ');
  });
});

describe("Bad input", () => {
  throws("invalid bas58 char", () =>{
    expect(decodeUnsafe("=")).toBeNull();
    decode("=");
  })
})
'''
'''--- assembly/index.ts ---
// Code converted from:
// https://github.com/cryptocoinjs/base-x/blob/master/src/index.js

const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
@inline const BASE = 58;

const LEADER = ALPHABET.charAt(0);
const LEADER_CODE = ALPHABET.charCodeAt(0);
// log(256) / log(58) = 1.365658237309761 ~= 554 / 405
@inline const FACTOR_NUM = 406;
@inline const FACTOR_DEN = 554;

@inline const INV_FACTOR_NUM = FACTOR_DEN;
@inline const INV_FACTOR_DEN = FACTOR_NUM - 1;

const BASE_MAP = new Uint8Array(256).fill(0xFF);

for (let i = 0; i < BASE; i++) {
  let code = ALPHABET.charCodeAt(i);
  if (unchecked(BASE_MAP[code]) != 0xFF) {
    throw new TypeError(String.fromCharCode(code) + ' is ambiguous');
  }
  unchecked(BASE_MAP[code] = i);
}

@inline
function FACTOR(length: i32): i32 {
  return length * FACTOR_NUM / FACTOR_DEN + 1; // log(58) / log(256), rounded up
}

@inline
function INV_FACTOR(length: i32): i32 {
  return length * INV_FACTOR_NUM / INV_FACTOR_DEN + 1; // log(256) / log(58), rounded up
}

/**
* Encode Uint8Array as a base58 string.
* @param bytes Byte array of type Uint8Array.
*/
export function encode(source: Uint8Array): string {

  // Skip & count leading zeroes.
  let pend = source.length;
  let pbegin = 0;
  while (pbegin != pend && source[pbegin] == 0) ++pbegin;
  let zeroes = pbegin;

  // Allocate enough space in big-endian base58 representation.
  let size = INV_FACTOR(pend - pbegin);
  let b58 = new Uint8Array(size);
  let length = 0;

  // Process the bytes.
  while (pbegin != pend) {
    let carry = u32(source[pbegin])
    // Apply "b58 = b58 * 256 + ch".
    let i = 0
    for (let it = size - 1; it != -1 && (carry != 0 || i < length); --it, ++i) {
      carry += u32(b58[it]) << 8;
      b58[it] = carry % BASE;
      carry = carry / BASE;
    }
    if (ASC_OPTIMIZE_LEVEL == 0) {
      assert(!carry, 'Non-zero carry');
    }
    length = i;
    pbegin++;
  }

  // Skip leading zeroes in base58 result.
  let it = size - length;
  while (it != size && b58[it] == 0) ++it;

  // Translate the result into a string.
  let str = LEADER.repeat(zeroes);
  for (; it < size; ++it) str += ALPHABET.charAt(b58[it]);
  return str;
}

export function decodeUnsafe(source: string): Uint8Array | null {
  let srcLen = source.length;
  if (!srcLen) return new Uint8Array(0);
  // Skip leading spaces.
  if (source.charCodeAt(0) == /* Space */ 0x20) return null;
  // Skip and count leading '1's.
  let length = 0;
  let psz = 0;

  while (source.charCodeAt(psz) == LEADER_CODE) ++psz;

  let zeroes = psz;
  // Allocate enough space in big-endian base256 representation.
  let size = FACTOR(srcLen - psz);
  let b256 = new Uint8Array(size);
  // Process the characters;
  while (srcLen > psz) {
    // Decode character
    let carry: u32 = unchecked(BASE_MAP[source.charCodeAt(psz++)])
    // Invalid character
    if (carry == 0xFF) return null;
    let i = 0;
    let it3 = size - 1;
    for (; it3 != -1 && (carry != 0 || i < length); --it3, ++i) {
      carry += u32(BASE * b256[it3]);
      b256[it3] = carry;
      carry >>>= 8;
    }
    if (ASC_OPTIMIZE_LEVEL == 0) {
      assert(!carry, 'Non-zero carry');
    }
    length = i;
  }
  // Skip trailing spaces.
  if (source.charCodeAt(psz) == /* Space */ 0x20) return null;
  // Skip leading zeroes in b256.
  let it4 = size - length;
  while (it4 != size && b256[it4] == 0) ++it4;

  let vch = new Uint8Array(zeroes + (size - it4));
  if (zeroes) vch.fill(0, 0, zeroes);
  let j = zeroes;
  while (it4 != size) {
    vch[j++] = b256[it4++];
  }
  return vch;
}

export function decode(source: string): Uint8Array {
  let buffer = decodeUnsafe(source);
  if (buffer) return buffer;
  throw new Error('Non-base' + String.fromCharCode(BASE) + ' character');
}
'''
'''--- assembly/tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- package.json ---
{
  "name": "as-base58",
  "version": "0.1.1",
  "types": "assembly/index.ts",
  "license": "MIT",
  "author": "Willem Wyndham <hello@near.org>",
  "scripts": {
    "test": "asp"
  },
  "devDependencies": {
    "@as-pect/cli": "^3.1.6",
    "assemblyscript": "^0.9.4"
  },
  "keywords": [
    "crypto",
    "AssemblyScript",
    "encoder",
    "decoder",
    "base58"
  ]
}

'''