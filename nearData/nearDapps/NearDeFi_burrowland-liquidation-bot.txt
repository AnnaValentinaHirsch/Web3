*GitHub Repository "NearDeFi/burrowland-liquidation-bot"*

'''--- export.sh ---
#!/bin/bash
set -e

export NEAR_ENV=mainnet

cd $(dirname "$0")

env MIN_DISCOUNT=0.0 /usr/local/bin/node src/export.js 2>&1

'''
'''--- package.json ---
{
  "name": "liquidation-bot",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "private": true,
  "bin": {
    "main": "src/main.js"
  },
  "dependencies": {
    "lodash": "^4.17.21",
    "near-api-js": "^0.38.0",
    "node-fetch": "^2.6.1",
    "big.js": "^6.0.3"
  },
  "devDependencies": {
    "prettier": "^2.2.1"
  }

}

'''
'''--- run.sh ---
#!/bin/bash

mkdir -p logs

export NEAR_ENV=mainnet
export NEAR_ACCOUNT_ID=$YOUR_ACCOUNT_ID
export MIN_PROFIT=0.25
export MIN_DISCOUNT=0.01

cd $(dirname "$0")
DATE=$(date "+%Y_%m_%d")
while :
do
  date | tee -a logs/logs_$DATE.txt
  /usr/local/bin/node ./src/main.js 2>&1 | tee -a logs/logs_$DATE.txt
  sleep 5
done

'''
'''--- src/account.js ---
const Big = require("big.js");
const { bigMin } = require("./utils");

const volatilityRatioCmp = (a, b) =>
  b.asset.config.volatilityRatio.cmp(a.asset.config.volatilityRatio);

const parseAccountAsset = (a) => {
  return {
    tokenId: a.tokenId,
    shares: Big(a.shares),
  };
};

const parseAccount = (a) => {
  return {
    accountId: a.accountId,
    collateral: a.collateral.map(parseAccountAsset),
    borrowed: a.borrowed.map(parseAccountAsset),
  };
};

const processAccountAsset = (a, assets, prices, supplied) => {
  const asset = assets[a.tokenId];
  const pool = supplied ? asset.supplied : asset.borrowed;
  const price = prices.prices[a.tokenId];
  a.asset = asset;
  a.price = price;
  a.balance = pool.balance
    .mul(a.shares)
    .div(pool.shares)
    .round(0, supplied ? 0 : 3);
  a.pricedBalance = price
    ? a.balance
        .mul(price.multiplier)
        .div(Big(10).pow(price.decimals + asset.config.extraDecimals))
    : null;
  a.adjustedPricedBalance = price
    ? supplied
      ? a.pricedBalance.mul(asset.config.volatilityRatio)
      : a.pricedBalance.div(asset.config.volatilityRatio)
    : null;
  return a;
};

const assetAdjustedPricedSum = (aa) =>
  aa.reduce(
    (acc, a) =>
      a.adjustedPricedBalance && acc ? acc.add(a.adjustedPricedBalance) : null,
    Big(0)
  );

const assetPricedSum = (aa) =>
  aa.reduce(
    (acc, a) => (a.pricedBalance && acc ? acc.add(a.pricedBalance) : null),
    Big(0)
  );

const recomputeAccountDiscount = (account) => {
  if (account.adjustedBorrowedSum && account.adjustedCollateralSum) {
    account.adjustedDebt = account.adjustedBorrowedSum.sub(
      account.adjustedCollateralSum
    );
    account.healthFactor = account.adjustedBorrowedSum.gt(0)
      ? account.adjustedCollateralSum.div(account.adjustedBorrowedSum)
      : Big(1e9);
    account.discount = account.adjustedDebt.gt(0)
      ? account.adjustedDebt.div(account.adjustedBorrowedSum).div(2)
      : Big(0);
  }
};

const processAccount = (account, assets, prices) => {
  account.collateral.forEach(
    (a) => (a = processAccountAsset(a, assets, prices, true))
  );
  account.collateralSum = assetPricedSum(account.collateral);
  account.adjustedCollateralSum = assetAdjustedPricedSum(account.collateral);
  account.borrowed.forEach((a) =>
    processAccountAsset(a, assets, prices, false)
  );
  account.borrowedSum = assetPricedSum(account.borrowed);
  account.adjustedBorrowedSum = assetAdjustedPricedSum(account.borrowed);
  recomputeAccountDiscount(account);

  return account;
};

const computeLiquidation = (account) => {
  // When liquidating, it's beneficial to take collateral with higher volatilityRatio first, because
  // it will decrease the adjustedCollateralSum less. Similarly it's more beneficial to
  // repay debt with higher volatilityRatio first, because it'll decrease adjustedBorrowedSum less.
  account.collateral.sort(volatilityRatioCmp);
  account.borrowed.sort(volatilityRatioCmp);
  // Liquidation rules:
  // 1) Taken discounted collateral, should be less than the repaid debt
  // 2) The new health factor should still be less than 100%.
  // We can claim all collateral, but can't repay all debt.

  // Debt 100 DAI at 95% vol             -> 100$ deb -> 105.26$ adj debt
  // Collateral 7 NEAR at 20$ at 60% vol -> 140$ col -> 84$ adj col
  // Health factor: 0.798
  // Discount: 0.101

  const collateralAssets = [];
  const borrowedAssets = [];

  let collateralIndex = 0;
  let borrowedIndex = 0;
  const origHealth = account.healthFactor;
  const origDiscount = account.discount;
  const discountMul = Big(1).sub(account.discount);
  const maxHealthFactor = Big(995).div(1000);
  const minPricedBalance = Big(1).div(100);
  let totalPricedProfit = Big(0);
  while (
    collateralIndex < account.collateral.length &&
    borrowedIndex < account.borrowed.length &&
    account.healthFactor.lt(maxHealthFactor)
  ) {
    const collateral = account.collateral[collateralIndex];

    if (collateral.pricedBalance.lt(minPricedBalance)) {
      collateralIndex++;
      continue;
    }

    const borrowed = account.borrowed[borrowedIndex];

    if (borrowed.pricedBalance.lt(minPricedBalance)) {
      borrowedIndex++;
      continue;
    }

    const discountedPricedBalance = collateral.pricedBalance.mul(discountMul);
    const maxPricedAmount = bigMin(
      discountedPricedBalance,
      borrowed.pricedBalance
    );
    // Need to compute pricedAmount that the new health factor still less than 100%
    // adjColSum - X / discountMul * col_vol(60%) = adjBorSum - X / bor_vol(95%)
    // adjBorSum - adjColSum = X * 1 / bor_vol - X * col_vol / discountMul
    // adjBorSum - adjColSum = X * (1 / bor_vol - col_vol / discountMul)
    // X = (adjBorSum - adjColSum) / (1 / bor_vol - col_vol / discountMul)
    const denom = Big(1)
      .div(borrowed.asset.config.volatilityRatio)
      .sub(collateral.asset.config.volatilityRatio.div(discountMul));
    const maxHealthAmount = denom.gt(0)
      ? account.adjustedBorrowedSum
          .sub(account.adjustedCollateralSum)
          .div(denom)
      : maxPricedAmount.mul(2);

    const pricedAmount = bigMin(maxHealthAmount, maxPricedAmount);

    const collateralPricedAmount = pricedAmount.div(discountMul);

    const pricedProfit = collateralPricedAmount.sub(pricedAmount);
    // console.log(
    //   `Profit $${collateralPricedAmount.toFixed(2)} of ${
    //     tokenIdToName(collateral.tokenId)
    //   } -> $${pricedAmount.toFixed(2)} of ${
    //     tokenIdToName(borrowed.tokenId)
    //   }: $${pricedProfit.toFixed(2)}`
    // );
    totalPricedProfit = totalPricedProfit.add(pricedProfit);

    const collateralAmount = collateralPricedAmount
      .div(collateral.price.multiplier)
      .mul(
        Big(10).pow(
          collateral.price.decimals + collateral.asset.config.extraDecimals
        )
      )
      .round(0, 0);
    const borrowedAmount = pricedAmount
      .div(borrowed.price.multiplier)
      .mul(
        Big(10).pow(
          borrowed.price.decimals + borrowed.asset.config.extraDecimals
        )
      )
      .round(0, 0);

    if (
      collateralAssets.length === 0 ||
      collateralAssets[collateralAssets.length - 1].tokenId !==
        collateral.tokenId
    ) {
      collateralAssets.push({
        tokenId: collateral.tokenId,
        amount: Big(0),
      });
    }
    const collateralAsset = collateralAssets[collateralAssets.length - 1];
    collateralAsset.amount = collateralAsset.amount.add(collateralAmount);

    if (
      borrowedAssets.length === 0 ||
      borrowedAssets[borrowedAssets.length - 1].tokenId !== borrowed.tokenId
    ) {
      borrowedAssets.push({
        tokenId: borrowed.tokenId,
        amount: Big(0),
      });
    }
    const borrowedAsset = borrowedAssets[borrowedAssets.length - 1];
    borrowedAsset.amount = borrowedAsset.amount.add(borrowedAmount);

    const adjustedCollateralAmount = collateralPricedAmount.mul(
      collateral.asset.config.volatilityRatio
    );
    const adjustedBorrowedAmount = pricedAmount.div(
      borrowed.asset.config.volatilityRatio
    );

    collateral.pricedBalance = collateral.pricedBalance.sub(
      collateralPricedAmount
    );
    collateral.adjustedPricedBalance = collateral.adjustedPricedBalance.sub(
      adjustedCollateralAmount
    );
    account.adjustedCollateralSum = account.adjustedCollateralSum.sub(
      adjustedCollateralAmount
    );

    borrowed.pricedBalance = borrowed.pricedBalance.sub(pricedAmount);
    borrowed.adjustedPricedBalance = borrowed.adjustedPricedBalance.sub(
      adjustedBorrowedAmount
    );
    account.adjustedBorrowedSum = account.adjustedBorrowedSum.sub(
      adjustedBorrowedAmount
    );

    recomputeAccountDiscount(account);
  }
  // console.log(
  //   `After liq: ${account.accountId} -> health ${account.healthFactor
  //     .mul(100)
  //     .toFixed(2)}% discount ${account.discount.mul(100).toFixed(2)}%`
  // );
  console.log(
    `Maybe liq ${account.accountId} -> discount ${origDiscount
      .mul(100)
      .toFixed(2)}% -> profit $${totalPricedProfit.toFixed(3)}`
  );

  // Adjusting collateralAssets amounts.
  collateralAssets.forEach((a) => {
    a.amount = a.amount.mul(9989).div(10000).round(0, 0);
  });
  borrowedAssets.forEach((a) => {
    a.amount = a.amount.mul(9990).div(10000).round(0, 0);
  });

  const liquidationAction = {
    account_id: account.accountId,
    in_assets: borrowedAssets.map((a) => ({
      token_id: a.tokenId,
      amount: a.amount.toFixed(0),
    })),
    out_assets: collateralAssets.map((a) => ({
      token_id: a.tokenId,
      amount: a.amount.toFixed(0),
    })),
  };
  // console.log(liquidationAction);
  return {
    liquidationAction,
    totalPricedProfit,
    origDiscount,
    origHealth,
    health: account.healthFactor,
  };
};

module.exports = {
  parseAccount,
  processAccount,
  computeLiquidation,
};

'''
'''--- src/asset.js ---
const { parseRatio, parseRate, parseTimestamp } = require("./utils");
const Big = require("big.js");

const parsePool = (p) => {
  return {
    shares: Big(p.shares),
    balance: Big(p.balance),
  };
};

const parseConfig = (c) => {
  return Object.assign(c, {
    reserveRatio: parseRatio(c.reserveRatio),
    targetUtilization: parseRatio(c.targetUtilization),
    targetUtilizationRate: parseRate(c.targetUtilizationRate),
    maxUtilizationRate: parseRate(c.maxUtilizationRate),
    volatilityRatio: parseRatio(c.volatilityRatio),
  });
};

const parseAsset = (a) => {
  return {
    supplied: parsePool(a.supplied),
    borrowed: parsePool(a.borrowed),
    reserved: Big(a.reserved),
    lastUpdateTimestamp: parseTimestamp(a.lastUpdateTimestamp),
    config: parseConfig(a.config),
  };
};

module.exports = {
  parseAsset,
};

'''
'''--- src/burrow.js ---
const Big = require("big.js");
const _ = require("lodash");
const fs = require("fs");
const { keysToCamel } = require("./utils");
const { parseAsset } = require("./asset");
const { parsePriceData } = require("./priceData");
const {
  parseAccount,
  processAccount,
  computeLiquidation,
} = require("./account");

Big.DP = 27;

module.exports = {
  main: async (nearObjects, liquidate) => {
    const {
      near,
      account,
      tokenContract,
      refFinanceContract,
      burrowContract,
      priceOracleContract,
      NearConfig,
    } = nearObjects;

    const rawAssets = keysToCamel(await burrowContract.get_assets_paged());
    const assets = rawAssets.reduce((assets, [assetId, asset]) => {
      assets[assetId] = parseAsset(asset);
      return assets;
    }, {});
    // console.log(assets);

    const [rawPriceData, numAccountsStr] = (
      await Promise.all([
        priceOracleContract.get_price_data({
          asset_ids: Object.keys(assets),
        }),
        burrowContract.get_num_accounts(),
      ])
    ).map(keysToCamel);
    const numAccounts = parseInt(numAccountsStr);

    const prices = parsePriceData(rawPriceData);

    console.log("Num accounts: ", numAccounts);
    const limit = 100;

    const promises = [];
    for (let i = 0; i < numAccounts; i += limit) {
      promises.push(
        burrowContract.get_accounts_paged({ from_index: i, limit: i + limit })
      );
    }
    const accounts = (await Promise.all(promises))
      .flat()
      .map((a) => processAccount(parseAccount(keysToCamel(a)), assets, prices))
      .filter((a) => !!a.healthFactor);

    accounts.sort((a, b) => {
      return a.healthFactor.cmp(b.healthFactor);
    });

    console.log(
      accounts
        .filter((a) => a.healthFactor.lt(2))
        .map(
          (a) =>
            `${a.accountId} -> ${a.healthFactor
              .mul(100)
              .toFixed(2)}% -> $${a.borrowedSum.toFixed(2)}`
        )
        .slice(0, 20)
    );

    if (NearConfig.showWhales) {
      console.log(
        accounts
          .sort((a, b) => b.borrowedSum.sub(a.borrowedSum).toNumber())
          .map(
            (a) =>
              `${a.accountId} -> ${a.healthFactor
                .mul(100)
                .toFixed(2)}% -> $${a.borrowedSum.toFixed(2)}`
          )
          .slice(0, 20)
      );
    }
    // console.log(JSON.stringify(accounts, undefined, 2));

    const accountsWithDebt = accounts.filter((a) =>
      a.discount.gte(NearConfig.minDiscount)
    );

    accountsWithDebt.sort((a, b) => {
      return b.discount.cmp(a.discount);
    });

    if (liquidate) {
      for (let i = 0; i < accountsWithDebt.length; ++i) {
        const {
          liquidationAction,
          totalPricedProfit,
          origDiscount,
          origHealth,
          health,
        } = computeLiquidation(accountsWithDebt[i]);
        if (
          totalPricedProfit.lte(NearConfig.minProfit) ||
          origDiscount.lte(NearConfig.minDiscount) ||
          origHealth.gte(health)
        ) {
          continue;
        }
        console.log("Executing liquidation");
        const msg = JSON.stringify({
          Execute: {
            actions: [
              {
                Liquidate: liquidationAction,
              },
            ],
          },
        });
        await priceOracleContract.oracle_call(
          {
            receiver_id: NearConfig.burrowContractId,
            msg,
          },
          Big(10).pow(12).mul(300).toFixed(0),
          "1"
        );
        break;
      }
    }

    return {
      numAccounts,
      accounts: JSON.stringify(accounts, undefined, 2),
      accountsWithDebt: JSON.stringify(accountsWithDebt, undefined, 2),
    };
  },
};

'''
'''--- src/config.js ---
const Big = require("big.js");
module.exports = {
  getConfig: (env) => {
    const config = (() => {
      switch (env) {
        case "production":
        case "mainnet":
          return {
            networkId: "mainnet",
            nodeUrl: process.env.NODE_URL || "https://rpc.mainnet.near.org",
            walletUrl: "https://wallet.near.org",
            helperUrl: "https://helper.mainnet.near.org",
            explorerUrl: "https://explorer.mainnet.near.org",
            refFinanceContractId: "v2.ref-finance.near",
            priceOracleContractId: "priceoracle.near",
            burrowContractId: "contract.main.burrow.near",
            accountId: process.env.NEAR_ACCOUNT_ID,
          };
        case "development":
        case "testnet":
          return {
            networkId: "testnet",
            nodeUrl: process.env.NODE_URL || "https://rpc.testnet.near.org",
            walletUrl: "https://wallet.testnet.near.org",
            helperUrl: "https://helper.testnet.near.org",
            explorerUrl: "https://explorer.testnet.near.org",
            refFinanceContractId: "ref-finance-101.testnet",
            priceOracleContractId: "priceoracle.testnet",
            burrowContractId: "contract.1638481328.burrow.testnet",
            accountId: process.env.NEAR_ACCOUNT_ID,
          };
        default:
          throw Error(
            `Unconfigured environment '${env}'. Can be configured in src/config.js.`
          );
      }
    })();
    config.minProfit = Big(process.env.MIN_PROFIT || "0.25");
    config.minDiscount = Big(process.env.MIN_DISCOUNT || "0.01");
    config.showWhales = !!process.env.SHOW_WHALES;
    return config;
  },
};

'''
'''--- src/export.js ---
#!/usr/bin/env node

const { initNear } = require("./near");
const { main } = require("./burrow");
const fs = require("fs");

const FILENAME = "burrow.json";

initNear(false)
  .then((nearObject) => main(nearObject, false))
  .then((data) => {
    fs.writeFile(FILENAME, data.accounts, function (err) {
      if (err) {
        console.log(err);
      } else {
        console.log(`File ${FILENAME} saved`);
      }
    });
  });

'''
'''--- src/main.js ---
#!/usr/bin/env node

const { initNear } = require("./near");
const { main } = require("./burrow");

initNear(true).then((nearObject) => main(nearObject, true));

'''
'''--- src/near.js ---
const nearAPI = require("near-api-js");
const os = require("os");

const { getConfig } = require("./config");
const path = require("path");

const NearConfig = getConfig(process.env.NEAR_ENV || "development");

module.exports = {
  initNear: async (loadAccount) => {
    const keyStore = new nearAPI.keyStores.InMemoryKeyStore();

    let near;
    let account;

    if (loadAccount) {
      const keyPath = path.join(
          os.homedir(),
          ".near-credentials",
          NearConfig.networkId,
          NearConfig.accountId + ".json"
      );
      near = await nearAPI.connect(
          Object.assign({ keyPath, deps: { keyStore } }, NearConfig)
      );
      account = new nearAPI.Account(near.connection, NearConfig.accountId);
    }
    else {
      const nearRpc = new nearAPI.providers.JsonRpcProvider(NearConfig.nodeUrl);
      account = new nearAPI.Account({provider: nearRpc,
        networkId:  NearConfig.networkId, signer:  NearConfig.accountId},  NearConfig.accountId);
    }

    const tokenContract = (tokenAccountId) =>
      new nearAPI.Contract(account, tokenAccountId, {
        viewMethods: [
          "storage_balance_of",
          "ft_balance_of",
          "storage_balance_bounds",
          "ft_metadata",
        ],
        changeMethods: ["ft_transfer_call", "ft_transfer", "storage_deposit"],
      });

    const refFinanceContract = new nearAPI.Contract(
      account,
      NearConfig.refFinanceContractId,
      {
        viewMethods: [
          "get_deposits",
          "get_pools",
          "get_pool",
          "get_return",
          "get_number_of_pools",
          "get_deposit",
        ],
        changeMethods: ["storage_deposit", "swap", "withdraw"],
      }
    );

    const burrowContract = new nearAPI.Contract(
      account,
      NearConfig.burrowContractId,
      {
        viewMethods: [
          "get_account",
          "get_num_accounts",
          "get_accounts_paged",
          "get_asset",
          "get_assets",
          "get_assets_paged",
          "get_assets_paged_detailed",
          "get_config",
          "get_asset_farm",
          "get_asset_farms",
          "get_asset_farms_paged",
        ],
        changeMethods: ["storage_deposit", "execute"],
      }
    );

    const priceOracleContract = new nearAPI.Contract(
      account,
      NearConfig.priceOracleContractId,
      {
        viewMethods: ["get_price_data"],
        changeMethods: ["oracle_call"],
      }
    );

    return {
      near,
      account,
      tokenContract,
      refFinanceContract,
      burrowContract,
      priceOracleContract,
      NearConfig,
    };
  },
};

'''
'''--- src/priceData.js ---
const { parseTimestamp } = require("./utils");
const Big = require("big.js");

const parsePrice = (p) => {
  return p
    ? {
        multiplier: Big(p.multiplier),
        decimals: p.decimals,
      }
    : null;
};

const parsePriceData = (r) => {
  return Object.assign(r, {
    timestamp: parseTimestamp(r.timestamp),
    prices: r.prices.reduce((prices, ap) => {
      prices[ap.assetId] = parsePrice(ap.price);
      return prices;
    }, {}),
  });
};

module.exports = {
  parsePriceData,
};

'''
'''--- src/test.js ---
#!/usr/bin/env node

const nearAPI = require("near-api-js");
const { initNear } = require("./near");
const Big = require("big.js");
const _ = require("lodash");
const fs = require("fs");
const {
  keysToCamel,
  parseTimestamp,
  parseRatio,
  parseRate,
} = require("./utils");
const { parseAsset } = require("./asset");
const { parsePriceData } = require("./priceData");
const {
  parseAccount,
  processAccount,
  computeLiquidation,
} = require("./account");

Big.DP = 27;

const mainTest = () => {
  const assets = {
    NEAR: {
      supplied: {
        balance: Big(10).pow(24).mul(10000),
        shares: Big(10).pow(24).mul(10000),
      },
      borrowed: {
        balance: Big(10).pow(24).mul(10000),
        shares: Big(10).pow(24).mul(10000),
      },
      reserved: Big(0),
      config: {
        volatilityRatio: parseRatio(6000),
        extraDecimals: 0,
      },
    },
    USDC: {
      supplied: {
        balance: Big(10).pow(18).mul(10000),
        shares: Big(10).pow(18).mul(10000),
      },
      borrowed: {
        balance: Big(10).pow(18).mul(10000),
        shares: Big(10).pow(18).mul(10000),
      },
      reserved: Big(0),
      config: {
        volatilityRatio: parseRatio(9500),
        extraDecimals: 12,
      },
    },
    DAI: {
      supplied: {
        balance: Big(10).pow(18).mul(10000),
        shares: Big(10).pow(18).mul(10000),
      },
      borrowed: {
        balance: Big(10).pow(18).mul(10000),
        shares: Big(10).pow(18).mul(10000),
      },
      reserved: Big(0),
      config: {
        volatilityRatio: parseRatio(9500),
        extraDecimals: 0,
      },
    },
  };

  const prices = {
    prices: {
      NEAR: {
        multiplier: Big(200000),
        decimals: 28,
      },
      USDC: {
        multiplier: Big(10000),
        decimals: 10,
      },
      DAI: {
        multiplier: Big(10000),
        decimals: 22,
      },
    },
  };

  const accounts = [
    {
      accountId: "alice",
      collateral: [
        {
          tokenId: "NEAR",
          shares: Big(10).pow(24).mul(7),
        },
      ],
      borrowed: [
        {
          tokenId: "DAI",
          shares: Big(10).pow(18).mul(50),
        },
      ],
    },
    {
      accountId: "rekt",
      collateral: [
        {
          tokenId: "NEAR",
          shares: Big(10).pow(24).mul(5),
        },
        {
          tokenId: "USDC",
          shares: Big(10).pow(18).mul(20),
        },
      ],
      borrowed: [
        {
          tokenId: "DAI",
          shares: Big(10).pow(18).mul(100),
        },
      ],
    },
    {
      accountId: "bob",
      collateral: [
        {
          tokenId: "NEAR",
          shares: Big(10).pow(24).mul(7).sub(Big("3049877847073640764176570")),
        },
      ],
      borrowed: [
        {
          tokenId: "DAI",
          shares: Big(10).pow(18).mul(100).sub(Big("54867607456639504711")),
        },
      ],
    },
  ]
    .map((a) => processAccount(a, assets, prices))
    .filter((a) => !!a.healthFactor);

  accounts.sort((a, b) => {
    return a.healthFactor.cmp(b.healthFactor);
  });

  console.log(
    accounts.map(
      (a) =>
        `${a.accountId} -> health ${a.healthFactor
          .mul(100)
          .toFixed(2)}% discount ${a.discount.mul(100).toFixed(2)}%`
    )
  );
  // console.log(JSON.stringify(accounts, undefined, 2));

  const accountsWithDebt = accounts.filter((a) => a.discount.gt(0));

  accountsWithDebt.sort((a, b) => {
    return b.discount.cmp(a.discount);
  });

  if (accountsWithDebt.length > 0) {
    computeLiquidation(accountsWithDebt[0]);
  }

  // console.log(JSON.stringify(accountsWithDebt, undefined, 2));
};

mainTest();

'''
'''--- src/utils.js ---
const Big = require("big.js");

const toCamel = (s) => {
  return s.replace(/([-_][a-z])/gi, ($1) => {
    return $1.toUpperCase().replace("-", "").replace("_", "");
  });
};

const isArray = (a) => Array.isArray(a);

const isObject = (o) =>
  o === Object(o) && !isArray(o) && typeof o !== "function";

const keysToCamel = (o) => {
  if (isObject(o)) {
    const n = {};

    Object.keys(o).forEach((k) => {
      n[toCamel(k)] = keysToCamel(o[k]);
    });

    return n;
  } else if (isArray(o)) {
    return o.map((i) => {
      return keysToCamel(i);
    });
  }

  return o;
};

const parseRate = (s) => Big(s).div(Big(10).pow(27));
const parseRatio = (r) => Big(r).div(10000);
const parseTimestamp = (s) => parseFloat(s) / 1e6;

const bigMin = (a, b) => (a.lt(b) ? a : b);

module.exports = {
  bigMin,
  keysToCamel,
  parseRate,
  parseRatio,
  parseTimestamp,
};

'''